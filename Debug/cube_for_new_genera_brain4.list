
cube_for_new_genera_brain4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0002d630  08000298  08000298  00010298  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00022a18  0802d8c8  0802d8c8  0003d8c8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  080502e0  080502e0  0007049c  2**0
                  CONTENTS
  4 .ARM          00000008  080502e0  080502e0  000602e0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  080502e8  080502e8  0007049c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  080502e8  080502e8  000602e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  080502ec  080502ec  000602ec  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000049c  20000000  080502f0  00070000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00019030  200004a0  0805078c  000704a0  2**3
                  ALLOC
 10 ._user_heap_stack 00006000  200194d0  0805078c  000794d0  2**0
                  ALLOC
 11 .RAM_D1       0007eb58  24000000  24000000  00080000  2**5
                  ALLOC
 12 .RAM_D2       000015e8  30000000  30000000  00080000  2**5
                  ALLOC
 13 .RAM_D3       00000201  38000000  38000000  00080000  2**5
                  ALLOC
 14 .SDRAM        02000000  60000000  60000000  00080000  2**5
                  ALLOC
 15 .ARM.attributes 0000002e  00000000  00000000  0007049c  2**0
                  CONTENTS, READONLY
 16 .debug_info   000c7cc1  00000000  00000000  000704ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_abbrev 00010fa3  00000000  00000000  0013818b  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00066791  00000000  00000000  0014912e  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_aranges 00004478  00000000  00000000  001af8c0  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_ranges 00011d38  00000000  00000000  001b3d38  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_macro  0004a3e2  00000000  00000000  001c5a70  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0005523c  00000000  00000000  0020fe52  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_str    0018c7ee  00000000  00000000  0026508e  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .comment      0000007b  00000000  00000000  003f187c  2**0
                  CONTENTS, READONLY
 25 .debug_frame  00010590  00000000  00000000  003f18f8  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

08000298 <__do_global_dtors_aux>:
 8000298:	b510      	push	{r4, lr}
 800029a:	4c05      	ldr	r4, [pc, #20]	; (80002b0 <__do_global_dtors_aux+0x18>)
 800029c:	7823      	ldrb	r3, [r4, #0]
 800029e:	b933      	cbnz	r3, 80002ae <__do_global_dtors_aux+0x16>
 80002a0:	4b04      	ldr	r3, [pc, #16]	; (80002b4 <__do_global_dtors_aux+0x1c>)
 80002a2:	b113      	cbz	r3, 80002aa <__do_global_dtors_aux+0x12>
 80002a4:	4804      	ldr	r0, [pc, #16]	; (80002b8 <__do_global_dtors_aux+0x20>)
 80002a6:	f3af 8000 	nop.w
 80002aa:	2301      	movs	r3, #1
 80002ac:	7023      	strb	r3, [r4, #0]
 80002ae:	bd10      	pop	{r4, pc}
 80002b0:	200004a0 	.word	0x200004a0
 80002b4:	00000000 	.word	0x00000000
 80002b8:	0802d8b0 	.word	0x0802d8b0

080002bc <frame_dummy>:
 80002bc:	b508      	push	{r3, lr}
 80002be:	4b03      	ldr	r3, [pc, #12]	; (80002cc <frame_dummy+0x10>)
 80002c0:	b11b      	cbz	r3, 80002ca <frame_dummy+0xe>
 80002c2:	4903      	ldr	r1, [pc, #12]	; (80002d0 <frame_dummy+0x14>)
 80002c4:	4803      	ldr	r0, [pc, #12]	; (80002d4 <frame_dummy+0x18>)
 80002c6:	f3af 8000 	nop.w
 80002ca:	bd08      	pop	{r3, pc}
 80002cc:	00000000 	.word	0x00000000
 80002d0:	200004a4 	.word	0x200004a4
 80002d4:	0802d8b0 	.word	0x0802d8b0

080002d8 <strlen>:
 80002d8:	4603      	mov	r3, r0
 80002da:	f813 2b01 	ldrb.w	r2, [r3], #1
 80002de:	2a00      	cmp	r2, #0
 80002e0:	d1fb      	bne.n	80002da <strlen+0x2>
 80002e2:	1a18      	subs	r0, r3, r0
 80002e4:	3801      	subs	r0, #1
 80002e6:	4770      	bx	lr

080002e8 <__aeabi_drsub>:
 80002e8:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002ec:	e002      	b.n	80002f4 <__adddf3>
 80002ee:	bf00      	nop

080002f0 <__aeabi_dsub>:
 80002f0:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002f4 <__adddf3>:
 80002f4:	b530      	push	{r4, r5, lr}
 80002f6:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002fa:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002fe:	ea94 0f05 	teq	r4, r5
 8000302:	bf08      	it	eq
 8000304:	ea90 0f02 	teqeq	r0, r2
 8000308:	bf1f      	itttt	ne
 800030a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800030e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000312:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000316:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800031a:	f000 80e2 	beq.w	80004e2 <__adddf3+0x1ee>
 800031e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000322:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000326:	bfb8      	it	lt
 8000328:	426d      	neglt	r5, r5
 800032a:	dd0c      	ble.n	8000346 <__adddf3+0x52>
 800032c:	442c      	add	r4, r5
 800032e:	ea80 0202 	eor.w	r2, r0, r2
 8000332:	ea81 0303 	eor.w	r3, r1, r3
 8000336:	ea82 0000 	eor.w	r0, r2, r0
 800033a:	ea83 0101 	eor.w	r1, r3, r1
 800033e:	ea80 0202 	eor.w	r2, r0, r2
 8000342:	ea81 0303 	eor.w	r3, r1, r3
 8000346:	2d36      	cmp	r5, #54	; 0x36
 8000348:	bf88      	it	hi
 800034a:	bd30      	pophi	{r4, r5, pc}
 800034c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000350:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000354:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000358:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800035c:	d002      	beq.n	8000364 <__adddf3+0x70>
 800035e:	4240      	negs	r0, r0
 8000360:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000364:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000368:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800036c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000370:	d002      	beq.n	8000378 <__adddf3+0x84>
 8000372:	4252      	negs	r2, r2
 8000374:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000378:	ea94 0f05 	teq	r4, r5
 800037c:	f000 80a7 	beq.w	80004ce <__adddf3+0x1da>
 8000380:	f1a4 0401 	sub.w	r4, r4, #1
 8000384:	f1d5 0e20 	rsbs	lr, r5, #32
 8000388:	db0d      	blt.n	80003a6 <__adddf3+0xb2>
 800038a:	fa02 fc0e 	lsl.w	ip, r2, lr
 800038e:	fa22 f205 	lsr.w	r2, r2, r5
 8000392:	1880      	adds	r0, r0, r2
 8000394:	f141 0100 	adc.w	r1, r1, #0
 8000398:	fa03 f20e 	lsl.w	r2, r3, lr
 800039c:	1880      	adds	r0, r0, r2
 800039e:	fa43 f305 	asr.w	r3, r3, r5
 80003a2:	4159      	adcs	r1, r3
 80003a4:	e00e      	b.n	80003c4 <__adddf3+0xd0>
 80003a6:	f1a5 0520 	sub.w	r5, r5, #32
 80003aa:	f10e 0e20 	add.w	lr, lr, #32
 80003ae:	2a01      	cmp	r2, #1
 80003b0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003b4:	bf28      	it	cs
 80003b6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003ba:	fa43 f305 	asr.w	r3, r3, r5
 80003be:	18c0      	adds	r0, r0, r3
 80003c0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003c4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003c8:	d507      	bpl.n	80003da <__adddf3+0xe6>
 80003ca:	f04f 0e00 	mov.w	lr, #0
 80003ce:	f1dc 0c00 	rsbs	ip, ip, #0
 80003d2:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003d6:	eb6e 0101 	sbc.w	r1, lr, r1
 80003da:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003de:	d31b      	bcc.n	8000418 <__adddf3+0x124>
 80003e0:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003e4:	d30c      	bcc.n	8000400 <__adddf3+0x10c>
 80003e6:	0849      	lsrs	r1, r1, #1
 80003e8:	ea5f 0030 	movs.w	r0, r0, rrx
 80003ec:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003f0:	f104 0401 	add.w	r4, r4, #1
 80003f4:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003f8:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003fc:	f080 809a 	bcs.w	8000534 <__adddf3+0x240>
 8000400:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000404:	bf08      	it	eq
 8000406:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800040a:	f150 0000 	adcs.w	r0, r0, #0
 800040e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000412:	ea41 0105 	orr.w	r1, r1, r5
 8000416:	bd30      	pop	{r4, r5, pc}
 8000418:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800041c:	4140      	adcs	r0, r0
 800041e:	eb41 0101 	adc.w	r1, r1, r1
 8000422:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000426:	f1a4 0401 	sub.w	r4, r4, #1
 800042a:	d1e9      	bne.n	8000400 <__adddf3+0x10c>
 800042c:	f091 0f00 	teq	r1, #0
 8000430:	bf04      	itt	eq
 8000432:	4601      	moveq	r1, r0
 8000434:	2000      	moveq	r0, #0
 8000436:	fab1 f381 	clz	r3, r1
 800043a:	bf08      	it	eq
 800043c:	3320      	addeq	r3, #32
 800043e:	f1a3 030b 	sub.w	r3, r3, #11
 8000442:	f1b3 0220 	subs.w	r2, r3, #32
 8000446:	da0c      	bge.n	8000462 <__adddf3+0x16e>
 8000448:	320c      	adds	r2, #12
 800044a:	dd08      	ble.n	800045e <__adddf3+0x16a>
 800044c:	f102 0c14 	add.w	ip, r2, #20
 8000450:	f1c2 020c 	rsb	r2, r2, #12
 8000454:	fa01 f00c 	lsl.w	r0, r1, ip
 8000458:	fa21 f102 	lsr.w	r1, r1, r2
 800045c:	e00c      	b.n	8000478 <__adddf3+0x184>
 800045e:	f102 0214 	add.w	r2, r2, #20
 8000462:	bfd8      	it	le
 8000464:	f1c2 0c20 	rsble	ip, r2, #32
 8000468:	fa01 f102 	lsl.w	r1, r1, r2
 800046c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000470:	bfdc      	itt	le
 8000472:	ea41 010c 	orrle.w	r1, r1, ip
 8000476:	4090      	lslle	r0, r2
 8000478:	1ae4      	subs	r4, r4, r3
 800047a:	bfa2      	ittt	ge
 800047c:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000480:	4329      	orrge	r1, r5
 8000482:	bd30      	popge	{r4, r5, pc}
 8000484:	ea6f 0404 	mvn.w	r4, r4
 8000488:	3c1f      	subs	r4, #31
 800048a:	da1c      	bge.n	80004c6 <__adddf3+0x1d2>
 800048c:	340c      	adds	r4, #12
 800048e:	dc0e      	bgt.n	80004ae <__adddf3+0x1ba>
 8000490:	f104 0414 	add.w	r4, r4, #20
 8000494:	f1c4 0220 	rsb	r2, r4, #32
 8000498:	fa20 f004 	lsr.w	r0, r0, r4
 800049c:	fa01 f302 	lsl.w	r3, r1, r2
 80004a0:	ea40 0003 	orr.w	r0, r0, r3
 80004a4:	fa21 f304 	lsr.w	r3, r1, r4
 80004a8:	ea45 0103 	orr.w	r1, r5, r3
 80004ac:	bd30      	pop	{r4, r5, pc}
 80004ae:	f1c4 040c 	rsb	r4, r4, #12
 80004b2:	f1c4 0220 	rsb	r2, r4, #32
 80004b6:	fa20 f002 	lsr.w	r0, r0, r2
 80004ba:	fa01 f304 	lsl.w	r3, r1, r4
 80004be:	ea40 0003 	orr.w	r0, r0, r3
 80004c2:	4629      	mov	r1, r5
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	fa21 f004 	lsr.w	r0, r1, r4
 80004ca:	4629      	mov	r1, r5
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	f094 0f00 	teq	r4, #0
 80004d2:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004d6:	bf06      	itte	eq
 80004d8:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004dc:	3401      	addeq	r4, #1
 80004de:	3d01      	subne	r5, #1
 80004e0:	e74e      	b.n	8000380 <__adddf3+0x8c>
 80004e2:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004e6:	bf18      	it	ne
 80004e8:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004ec:	d029      	beq.n	8000542 <__adddf3+0x24e>
 80004ee:	ea94 0f05 	teq	r4, r5
 80004f2:	bf08      	it	eq
 80004f4:	ea90 0f02 	teqeq	r0, r2
 80004f8:	d005      	beq.n	8000506 <__adddf3+0x212>
 80004fa:	ea54 0c00 	orrs.w	ip, r4, r0
 80004fe:	bf04      	itt	eq
 8000500:	4619      	moveq	r1, r3
 8000502:	4610      	moveq	r0, r2
 8000504:	bd30      	pop	{r4, r5, pc}
 8000506:	ea91 0f03 	teq	r1, r3
 800050a:	bf1e      	ittt	ne
 800050c:	2100      	movne	r1, #0
 800050e:	2000      	movne	r0, #0
 8000510:	bd30      	popne	{r4, r5, pc}
 8000512:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000516:	d105      	bne.n	8000524 <__adddf3+0x230>
 8000518:	0040      	lsls	r0, r0, #1
 800051a:	4149      	adcs	r1, r1
 800051c:	bf28      	it	cs
 800051e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000522:	bd30      	pop	{r4, r5, pc}
 8000524:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000528:	bf3c      	itt	cc
 800052a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800052e:	bd30      	popcc	{r4, r5, pc}
 8000530:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000534:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000538:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800053c:	f04f 0000 	mov.w	r0, #0
 8000540:	bd30      	pop	{r4, r5, pc}
 8000542:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000546:	bf1a      	itte	ne
 8000548:	4619      	movne	r1, r3
 800054a:	4610      	movne	r0, r2
 800054c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000550:	bf1c      	itt	ne
 8000552:	460b      	movne	r3, r1
 8000554:	4602      	movne	r2, r0
 8000556:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800055a:	bf06      	itte	eq
 800055c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000560:	ea91 0f03 	teqeq	r1, r3
 8000564:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000568:	bd30      	pop	{r4, r5, pc}
 800056a:	bf00      	nop

0800056c <__aeabi_ui2d>:
 800056c:	f090 0f00 	teq	r0, #0
 8000570:	bf04      	itt	eq
 8000572:	2100      	moveq	r1, #0
 8000574:	4770      	bxeq	lr
 8000576:	b530      	push	{r4, r5, lr}
 8000578:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800057c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000580:	f04f 0500 	mov.w	r5, #0
 8000584:	f04f 0100 	mov.w	r1, #0
 8000588:	e750      	b.n	800042c <__adddf3+0x138>
 800058a:	bf00      	nop

0800058c <__aeabi_i2d>:
 800058c:	f090 0f00 	teq	r0, #0
 8000590:	bf04      	itt	eq
 8000592:	2100      	moveq	r1, #0
 8000594:	4770      	bxeq	lr
 8000596:	b530      	push	{r4, r5, lr}
 8000598:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800059c:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005a0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005a4:	bf48      	it	mi
 80005a6:	4240      	negmi	r0, r0
 80005a8:	f04f 0100 	mov.w	r1, #0
 80005ac:	e73e      	b.n	800042c <__adddf3+0x138>
 80005ae:	bf00      	nop

080005b0 <__aeabi_f2d>:
 80005b0:	0042      	lsls	r2, r0, #1
 80005b2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005b6:	ea4f 0131 	mov.w	r1, r1, rrx
 80005ba:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005be:	bf1f      	itttt	ne
 80005c0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005c4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005c8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005cc:	4770      	bxne	lr
 80005ce:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80005d2:	bf08      	it	eq
 80005d4:	4770      	bxeq	lr
 80005d6:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80005da:	bf04      	itt	eq
 80005dc:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80005e0:	4770      	bxeq	lr
 80005e2:	b530      	push	{r4, r5, lr}
 80005e4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005e8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ec:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005f0:	e71c      	b.n	800042c <__adddf3+0x138>
 80005f2:	bf00      	nop

080005f4 <__aeabi_ul2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f04f 0500 	mov.w	r5, #0
 8000602:	e00a      	b.n	800061a <__aeabi_l2d+0x16>

08000604 <__aeabi_l2d>:
 8000604:	ea50 0201 	orrs.w	r2, r0, r1
 8000608:	bf08      	it	eq
 800060a:	4770      	bxeq	lr
 800060c:	b530      	push	{r4, r5, lr}
 800060e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000612:	d502      	bpl.n	800061a <__aeabi_l2d+0x16>
 8000614:	4240      	negs	r0, r0
 8000616:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800061a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800061e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000622:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000626:	f43f aed8 	beq.w	80003da <__adddf3+0xe6>
 800062a:	f04f 0203 	mov.w	r2, #3
 800062e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000632:	bf18      	it	ne
 8000634:	3203      	addne	r2, #3
 8000636:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800063a:	bf18      	it	ne
 800063c:	3203      	addne	r2, #3
 800063e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000642:	f1c2 0320 	rsb	r3, r2, #32
 8000646:	fa00 fc03 	lsl.w	ip, r0, r3
 800064a:	fa20 f002 	lsr.w	r0, r0, r2
 800064e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000652:	ea40 000e 	orr.w	r0, r0, lr
 8000656:	fa21 f102 	lsr.w	r1, r1, r2
 800065a:	4414      	add	r4, r2
 800065c:	e6bd      	b.n	80003da <__adddf3+0xe6>
 800065e:	bf00      	nop

08000660 <__aeabi_uldivmod>:
 8000660:	b953      	cbnz	r3, 8000678 <__aeabi_uldivmod+0x18>
 8000662:	b94a      	cbnz	r2, 8000678 <__aeabi_uldivmod+0x18>
 8000664:	2900      	cmp	r1, #0
 8000666:	bf08      	it	eq
 8000668:	2800      	cmpeq	r0, #0
 800066a:	bf1c      	itt	ne
 800066c:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 8000670:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000674:	f000 b972 	b.w	800095c <__aeabi_idiv0>
 8000678:	f1ad 0c08 	sub.w	ip, sp, #8
 800067c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000680:	f000 f806 	bl	8000690 <__udivmoddi4>
 8000684:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000688:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 800068c:	b004      	add	sp, #16
 800068e:	4770      	bx	lr

08000690 <__udivmoddi4>:
 8000690:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000694:	9e08      	ldr	r6, [sp, #32]
 8000696:	4604      	mov	r4, r0
 8000698:	4688      	mov	r8, r1
 800069a:	2b00      	cmp	r3, #0
 800069c:	d14b      	bne.n	8000736 <__udivmoddi4+0xa6>
 800069e:	428a      	cmp	r2, r1
 80006a0:	4615      	mov	r5, r2
 80006a2:	d967      	bls.n	8000774 <__udivmoddi4+0xe4>
 80006a4:	fab2 f282 	clz	r2, r2
 80006a8:	b14a      	cbz	r2, 80006be <__udivmoddi4+0x2e>
 80006aa:	f1c2 0720 	rsb	r7, r2, #32
 80006ae:	fa01 f302 	lsl.w	r3, r1, r2
 80006b2:	fa20 f707 	lsr.w	r7, r0, r7
 80006b6:	4095      	lsls	r5, r2
 80006b8:	ea47 0803 	orr.w	r8, r7, r3
 80006bc:	4094      	lsls	r4, r2
 80006be:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80006c2:	0c23      	lsrs	r3, r4, #16
 80006c4:	fbb8 f7fe 	udiv	r7, r8, lr
 80006c8:	fa1f fc85 	uxth.w	ip, r5
 80006cc:	fb0e 8817 	mls	r8, lr, r7, r8
 80006d0:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80006d4:	fb07 f10c 	mul.w	r1, r7, ip
 80006d8:	4299      	cmp	r1, r3
 80006da:	d909      	bls.n	80006f0 <__udivmoddi4+0x60>
 80006dc:	18eb      	adds	r3, r5, r3
 80006de:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 80006e2:	f080 811b 	bcs.w	800091c <__udivmoddi4+0x28c>
 80006e6:	4299      	cmp	r1, r3
 80006e8:	f240 8118 	bls.w	800091c <__udivmoddi4+0x28c>
 80006ec:	3f02      	subs	r7, #2
 80006ee:	442b      	add	r3, r5
 80006f0:	1a5b      	subs	r3, r3, r1
 80006f2:	b2a4      	uxth	r4, r4
 80006f4:	fbb3 f0fe 	udiv	r0, r3, lr
 80006f8:	fb0e 3310 	mls	r3, lr, r0, r3
 80006fc:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000700:	fb00 fc0c 	mul.w	ip, r0, ip
 8000704:	45a4      	cmp	ip, r4
 8000706:	d909      	bls.n	800071c <__udivmoddi4+0x8c>
 8000708:	192c      	adds	r4, r5, r4
 800070a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800070e:	f080 8107 	bcs.w	8000920 <__udivmoddi4+0x290>
 8000712:	45a4      	cmp	ip, r4
 8000714:	f240 8104 	bls.w	8000920 <__udivmoddi4+0x290>
 8000718:	3802      	subs	r0, #2
 800071a:	442c      	add	r4, r5
 800071c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000720:	eba4 040c 	sub.w	r4, r4, ip
 8000724:	2700      	movs	r7, #0
 8000726:	b11e      	cbz	r6, 8000730 <__udivmoddi4+0xa0>
 8000728:	40d4      	lsrs	r4, r2
 800072a:	2300      	movs	r3, #0
 800072c:	e9c6 4300 	strd	r4, r3, [r6]
 8000730:	4639      	mov	r1, r7
 8000732:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000736:	428b      	cmp	r3, r1
 8000738:	d909      	bls.n	800074e <__udivmoddi4+0xbe>
 800073a:	2e00      	cmp	r6, #0
 800073c:	f000 80eb 	beq.w	8000916 <__udivmoddi4+0x286>
 8000740:	2700      	movs	r7, #0
 8000742:	e9c6 0100 	strd	r0, r1, [r6]
 8000746:	4638      	mov	r0, r7
 8000748:	4639      	mov	r1, r7
 800074a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800074e:	fab3 f783 	clz	r7, r3
 8000752:	2f00      	cmp	r7, #0
 8000754:	d147      	bne.n	80007e6 <__udivmoddi4+0x156>
 8000756:	428b      	cmp	r3, r1
 8000758:	d302      	bcc.n	8000760 <__udivmoddi4+0xd0>
 800075a:	4282      	cmp	r2, r0
 800075c:	f200 80fa 	bhi.w	8000954 <__udivmoddi4+0x2c4>
 8000760:	1a84      	subs	r4, r0, r2
 8000762:	eb61 0303 	sbc.w	r3, r1, r3
 8000766:	2001      	movs	r0, #1
 8000768:	4698      	mov	r8, r3
 800076a:	2e00      	cmp	r6, #0
 800076c:	d0e0      	beq.n	8000730 <__udivmoddi4+0xa0>
 800076e:	e9c6 4800 	strd	r4, r8, [r6]
 8000772:	e7dd      	b.n	8000730 <__udivmoddi4+0xa0>
 8000774:	b902      	cbnz	r2, 8000778 <__udivmoddi4+0xe8>
 8000776:	deff      	udf	#255	; 0xff
 8000778:	fab2 f282 	clz	r2, r2
 800077c:	2a00      	cmp	r2, #0
 800077e:	f040 808f 	bne.w	80008a0 <__udivmoddi4+0x210>
 8000782:	1b49      	subs	r1, r1, r5
 8000784:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000788:	fa1f f885 	uxth.w	r8, r5
 800078c:	2701      	movs	r7, #1
 800078e:	fbb1 fcfe 	udiv	ip, r1, lr
 8000792:	0c23      	lsrs	r3, r4, #16
 8000794:	fb0e 111c 	mls	r1, lr, ip, r1
 8000798:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 800079c:	fb08 f10c 	mul.w	r1, r8, ip
 80007a0:	4299      	cmp	r1, r3
 80007a2:	d907      	bls.n	80007b4 <__udivmoddi4+0x124>
 80007a4:	18eb      	adds	r3, r5, r3
 80007a6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80007aa:	d202      	bcs.n	80007b2 <__udivmoddi4+0x122>
 80007ac:	4299      	cmp	r1, r3
 80007ae:	f200 80cd 	bhi.w	800094c <__udivmoddi4+0x2bc>
 80007b2:	4684      	mov	ip, r0
 80007b4:	1a59      	subs	r1, r3, r1
 80007b6:	b2a3      	uxth	r3, r4
 80007b8:	fbb1 f0fe 	udiv	r0, r1, lr
 80007bc:	fb0e 1410 	mls	r4, lr, r0, r1
 80007c0:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80007c4:	fb08 f800 	mul.w	r8, r8, r0
 80007c8:	45a0      	cmp	r8, r4
 80007ca:	d907      	bls.n	80007dc <__udivmoddi4+0x14c>
 80007cc:	192c      	adds	r4, r5, r4
 80007ce:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80007d2:	d202      	bcs.n	80007da <__udivmoddi4+0x14a>
 80007d4:	45a0      	cmp	r8, r4
 80007d6:	f200 80b6 	bhi.w	8000946 <__udivmoddi4+0x2b6>
 80007da:	4618      	mov	r0, r3
 80007dc:	eba4 0408 	sub.w	r4, r4, r8
 80007e0:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80007e4:	e79f      	b.n	8000726 <__udivmoddi4+0x96>
 80007e6:	f1c7 0c20 	rsb	ip, r7, #32
 80007ea:	40bb      	lsls	r3, r7
 80007ec:	fa22 fe0c 	lsr.w	lr, r2, ip
 80007f0:	ea4e 0e03 	orr.w	lr, lr, r3
 80007f4:	fa01 f407 	lsl.w	r4, r1, r7
 80007f8:	fa20 f50c 	lsr.w	r5, r0, ip
 80007fc:	fa21 f30c 	lsr.w	r3, r1, ip
 8000800:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000804:	4325      	orrs	r5, r4
 8000806:	fbb3 f9f8 	udiv	r9, r3, r8
 800080a:	0c2c      	lsrs	r4, r5, #16
 800080c:	fb08 3319 	mls	r3, r8, r9, r3
 8000810:	fa1f fa8e 	uxth.w	sl, lr
 8000814:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000818:	fb09 f40a 	mul.w	r4, r9, sl
 800081c:	429c      	cmp	r4, r3
 800081e:	fa02 f207 	lsl.w	r2, r2, r7
 8000822:	fa00 f107 	lsl.w	r1, r0, r7
 8000826:	d90b      	bls.n	8000840 <__udivmoddi4+0x1b0>
 8000828:	eb1e 0303 	adds.w	r3, lr, r3
 800082c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000830:	f080 8087 	bcs.w	8000942 <__udivmoddi4+0x2b2>
 8000834:	429c      	cmp	r4, r3
 8000836:	f240 8084 	bls.w	8000942 <__udivmoddi4+0x2b2>
 800083a:	f1a9 0902 	sub.w	r9, r9, #2
 800083e:	4473      	add	r3, lr
 8000840:	1b1b      	subs	r3, r3, r4
 8000842:	b2ad      	uxth	r5, r5
 8000844:	fbb3 f0f8 	udiv	r0, r3, r8
 8000848:	fb08 3310 	mls	r3, r8, r0, r3
 800084c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000850:	fb00 fa0a 	mul.w	sl, r0, sl
 8000854:	45a2      	cmp	sl, r4
 8000856:	d908      	bls.n	800086a <__udivmoddi4+0x1da>
 8000858:	eb1e 0404 	adds.w	r4, lr, r4
 800085c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000860:	d26b      	bcs.n	800093a <__udivmoddi4+0x2aa>
 8000862:	45a2      	cmp	sl, r4
 8000864:	d969      	bls.n	800093a <__udivmoddi4+0x2aa>
 8000866:	3802      	subs	r0, #2
 8000868:	4474      	add	r4, lr
 800086a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 800086e:	fba0 8902 	umull	r8, r9, r0, r2
 8000872:	eba4 040a 	sub.w	r4, r4, sl
 8000876:	454c      	cmp	r4, r9
 8000878:	46c2      	mov	sl, r8
 800087a:	464b      	mov	r3, r9
 800087c:	d354      	bcc.n	8000928 <__udivmoddi4+0x298>
 800087e:	d051      	beq.n	8000924 <__udivmoddi4+0x294>
 8000880:	2e00      	cmp	r6, #0
 8000882:	d069      	beq.n	8000958 <__udivmoddi4+0x2c8>
 8000884:	ebb1 050a 	subs.w	r5, r1, sl
 8000888:	eb64 0403 	sbc.w	r4, r4, r3
 800088c:	fa04 fc0c 	lsl.w	ip, r4, ip
 8000890:	40fd      	lsrs	r5, r7
 8000892:	40fc      	lsrs	r4, r7
 8000894:	ea4c 0505 	orr.w	r5, ip, r5
 8000898:	e9c6 5400 	strd	r5, r4, [r6]
 800089c:	2700      	movs	r7, #0
 800089e:	e747      	b.n	8000730 <__udivmoddi4+0xa0>
 80008a0:	f1c2 0320 	rsb	r3, r2, #32
 80008a4:	fa20 f703 	lsr.w	r7, r0, r3
 80008a8:	4095      	lsls	r5, r2
 80008aa:	fa01 f002 	lsl.w	r0, r1, r2
 80008ae:	fa21 f303 	lsr.w	r3, r1, r3
 80008b2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80008b6:	4338      	orrs	r0, r7
 80008b8:	0c01      	lsrs	r1, r0, #16
 80008ba:	fbb3 f7fe 	udiv	r7, r3, lr
 80008be:	fa1f f885 	uxth.w	r8, r5
 80008c2:	fb0e 3317 	mls	r3, lr, r7, r3
 80008c6:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80008ca:	fb07 f308 	mul.w	r3, r7, r8
 80008ce:	428b      	cmp	r3, r1
 80008d0:	fa04 f402 	lsl.w	r4, r4, r2
 80008d4:	d907      	bls.n	80008e6 <__udivmoddi4+0x256>
 80008d6:	1869      	adds	r1, r5, r1
 80008d8:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 80008dc:	d22f      	bcs.n	800093e <__udivmoddi4+0x2ae>
 80008de:	428b      	cmp	r3, r1
 80008e0:	d92d      	bls.n	800093e <__udivmoddi4+0x2ae>
 80008e2:	3f02      	subs	r7, #2
 80008e4:	4429      	add	r1, r5
 80008e6:	1acb      	subs	r3, r1, r3
 80008e8:	b281      	uxth	r1, r0
 80008ea:	fbb3 f0fe 	udiv	r0, r3, lr
 80008ee:	fb0e 3310 	mls	r3, lr, r0, r3
 80008f2:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 80008f6:	fb00 f308 	mul.w	r3, r0, r8
 80008fa:	428b      	cmp	r3, r1
 80008fc:	d907      	bls.n	800090e <__udivmoddi4+0x27e>
 80008fe:	1869      	adds	r1, r5, r1
 8000900:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8000904:	d217      	bcs.n	8000936 <__udivmoddi4+0x2a6>
 8000906:	428b      	cmp	r3, r1
 8000908:	d915      	bls.n	8000936 <__udivmoddi4+0x2a6>
 800090a:	3802      	subs	r0, #2
 800090c:	4429      	add	r1, r5
 800090e:	1ac9      	subs	r1, r1, r3
 8000910:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000914:	e73b      	b.n	800078e <__udivmoddi4+0xfe>
 8000916:	4637      	mov	r7, r6
 8000918:	4630      	mov	r0, r6
 800091a:	e709      	b.n	8000730 <__udivmoddi4+0xa0>
 800091c:	4607      	mov	r7, r0
 800091e:	e6e7      	b.n	80006f0 <__udivmoddi4+0x60>
 8000920:	4618      	mov	r0, r3
 8000922:	e6fb      	b.n	800071c <__udivmoddi4+0x8c>
 8000924:	4541      	cmp	r1, r8
 8000926:	d2ab      	bcs.n	8000880 <__udivmoddi4+0x1f0>
 8000928:	ebb8 0a02 	subs.w	sl, r8, r2
 800092c:	eb69 020e 	sbc.w	r2, r9, lr
 8000930:	3801      	subs	r0, #1
 8000932:	4613      	mov	r3, r2
 8000934:	e7a4      	b.n	8000880 <__udivmoddi4+0x1f0>
 8000936:	4660      	mov	r0, ip
 8000938:	e7e9      	b.n	800090e <__udivmoddi4+0x27e>
 800093a:	4618      	mov	r0, r3
 800093c:	e795      	b.n	800086a <__udivmoddi4+0x1da>
 800093e:	4667      	mov	r7, ip
 8000940:	e7d1      	b.n	80008e6 <__udivmoddi4+0x256>
 8000942:	4681      	mov	r9, r0
 8000944:	e77c      	b.n	8000840 <__udivmoddi4+0x1b0>
 8000946:	3802      	subs	r0, #2
 8000948:	442c      	add	r4, r5
 800094a:	e747      	b.n	80007dc <__udivmoddi4+0x14c>
 800094c:	f1ac 0c02 	sub.w	ip, ip, #2
 8000950:	442b      	add	r3, r5
 8000952:	e72f      	b.n	80007b4 <__udivmoddi4+0x124>
 8000954:	4638      	mov	r0, r7
 8000956:	e708      	b.n	800076a <__udivmoddi4+0xda>
 8000958:	4637      	mov	r7, r6
 800095a:	e6e9      	b.n	8000730 <__udivmoddi4+0xa0>

0800095c <__aeabi_idiv0>:
 800095c:	4770      	bx	lr
 800095e:	bf00      	nop

08000960 <HAL_InitTick>:
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 8000960:	f240 0300 	movw	r3, #0
 8000964:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000968:	781b      	ldrb	r3, [r3, #0]
 800096a:	b90b      	cbnz	r3, 8000970 <HAL_InitTick+0x10>
  {
    return HAL_ERROR;
 800096c:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 800096e:	4770      	bx	lr
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8000970:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8000974:	f240 21b0 	movw	r1, #688	; 0x2b0
 8000978:	fbb2 f3f3 	udiv	r3, r2, r3
 800097c:	f2c2 0100 	movt	r1, #8192	; 0x2000
{
 8000980:	b510      	push	{r4, lr}
 8000982:	4604      	mov	r4, r0
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8000984:	6808      	ldr	r0, [r1, #0]
 8000986:	fbb0 f0f3 	udiv	r0, r0, r3
 800098a:	f001 fe9b 	bl	80026c4 <HAL_SYSTICK_Config>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800098e:	2c0f      	cmp	r4, #15
 8000990:	d800      	bhi.n	8000994 <HAL_InitTick+0x34>
 8000992:	b108      	cbz	r0, 8000998 <HAL_InitTick+0x38>
    return HAL_ERROR;
 8000994:	2001      	movs	r0, #1
}
 8000996:	bd10      	pop	{r4, pc}
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000998:	2200      	movs	r2, #0
 800099a:	4621      	mov	r1, r4
 800099c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80009a0:	f001 fe0e 	bl	80025c0 <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 80009a4:	f240 0304 	movw	r3, #4
 80009a8:	2000      	movs	r0, #0
 80009aa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80009ae:	601c      	str	r4, [r3, #0]
}
 80009b0:	bd10      	pop	{r4, pc}
 80009b2:	bf00      	nop

080009b4 <HAL_Init>:
{
 80009b4:	b530      	push	{r4, r5, lr}
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009b6:	f44f 4588 	mov.w	r5, #17408	; 0x4400
{
 80009ba:	b083      	sub	sp, #12
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009bc:	2003      	movs	r0, #3
  SystemCoreClock = common_system_clock;
 80009be:	f240 24b0 	movw	r4, #688	; 0x2b0
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009c2:	f6c5 0502 	movt	r5, #22530	; 0x5802
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80009c6:	f001 fddd 	bl	8002584 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009ca:	f008 fee9 	bl	80097a0 <HAL_RCC_GetSysClockFreq>
 80009ce:	f64e 22c0 	movw	r2, #60096	; 0xeac0
 80009d2:	69ab      	ldr	r3, [r5, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009d4:	f240 21b4 	movw	r1, #692	; 0x2b4
 80009d8:	69ad      	ldr	r5, [r5, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009da:	f6c0 0202 	movt	r2, #2050	; 0x802
 80009de:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009e2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80009e6:	f005 050f 	and.w	r5, r5, #15
  SystemCoreClock = common_system_clock;
 80009ea:	f2c2 0400 	movt	r4, #8192	; 0x2000
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009ee:	5cd3      	ldrb	r3, [r2, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009f0:	5d52      	ldrb	r2, [r2, r5]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009f2:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 80009f6:	f002 021f 	and.w	r2, r2, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 80009fa:	fa20 f303 	lsr.w	r3, r0, r3
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80009fe:	2000      	movs	r0, #0
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8000a00:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
 8000a04:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8000a06:	600a      	str	r2, [r1, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000a08:	f7ff ffaa 	bl	8000960 <HAL_InitTick>
 8000a0c:	b110      	cbz	r0, 8000a14 <HAL_Init+0x60>
    return HAL_ERROR;
 8000a0e:	2001      	movs	r0, #1
}
 8000a10:	b003      	add	sp, #12
 8000a12:	bd30      	pop	{r4, r5, pc}
 8000a14:	9001      	str	r0, [sp, #4]
  HAL_MspInit();
 8000a16:	f01e fb87 	bl	801f128 <HAL_MspInit>
  return HAL_OK;
 8000a1a:	9801      	ldr	r0, [sp, #4]
}
 8000a1c:	b003      	add	sp, #12
 8000a1e:	bd30      	pop	{r4, r5, pc}

08000a20 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8000a20:	f240 6360 	movw	r3, #1632	; 0x660
 8000a24:	f240 0100 	movw	r1, #0
 8000a28:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a2c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8000a30:	6818      	ldr	r0, [r3, #0]
 8000a32:	780a      	ldrb	r2, [r1, #0]
 8000a34:	4402      	add	r2, r0
 8000a36:	601a      	str	r2, [r3, #0]
}
 8000a38:	4770      	bx	lr
 8000a3a:	bf00      	nop

08000a3c <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000a3c:	f240 6360 	movw	r3, #1632	; 0x660
 8000a40:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a44:	6818      	ldr	r0, [r3, #0]
}
 8000a46:	4770      	bx	lr

08000a48 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000a48:	b538      	push	{r3, r4, r5, lr}
 8000a4a:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000a4c:	f7ff fff6 	bl	8000a3c <HAL_GetTick>
 8000a50:	4605      	mov	r5, r0
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000a52:	1c63      	adds	r3, r4, #1
 8000a54:	d005      	beq.n	8000a62 <HAL_Delay+0x1a>
  {
    wait += (uint32_t)(uwTickFreq);
 8000a56:	f240 0300 	movw	r3, #0
 8000a5a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8000a5e:	781b      	ldrb	r3, [r3, #0]
 8000a60:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8000a62:	f7ff ffeb 	bl	8000a3c <HAL_GetTick>
 8000a66:	1b40      	subs	r0, r0, r5
 8000a68:	42a0      	cmp	r0, r4
 8000a6a:	d3fa      	bcc.n	8000a62 <HAL_Delay+0x1a>
  {
  }
}
 8000a6c:	bd38      	pop	{r3, r4, r5, pc}
 8000a6e:	bf00      	nop

08000a70 <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 8000a70:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8000a74:	f6c5 4300 	movt	r3, #23552	; 0x5c00
 8000a78:	6818      	ldr	r0, [r3, #0]
}
 8000a7a:	0c00      	lsrs	r0, r0, #16
 8000a7c:	4770      	bx	lr
 8000a7e:	bf00      	nop

08000a80 <HAL_SetFMCMemorySwappingConfig>:
  * @retval HAL state
  */
void HAL_SetFMCMemorySwappingConfig(uint32_t BankMapConfig)
{
  /* Check the parameter */
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000a80:	f030 7380 	bics.w	r3, r0, #16777216	; 0x1000000
{
 8000a84:	b510      	push	{r4, lr}
 8000a86:	4604      	mov	r4, r0
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000a88:	d002      	beq.n	8000a90 <HAL_SetFMCMemorySwappingConfig+0x10>
 8000a8a:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 8000a8e:	d109      	bne.n	8000aa4 <HAL_SetFMCMemorySwappingConfig+0x24>
  MODIFY_REG(FMC_Bank1_R->BTCR[0], FMC_BCR1_BMAP, BankMapConfig);
 8000a90:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000a94:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8000a98:	6818      	ldr	r0, [r3, #0]
 8000a9a:	f020 7040 	bic.w	r0, r0, #50331648	; 0x3000000
 8000a9e:	4320      	orrs	r0, r4
 8000aa0:	6018      	str	r0, [r3, #0]
}
 8000aa2:	bd10      	pop	{r4, pc}
  assert_param(IS_FMC_SWAPBMAP_MODE(BankMapConfig));
 8000aa4:	f64d 1014 	movw	r0, #55572	; 0xd914
 8000aa8:	f44f 6181 	mov.w	r1, #1032	; 0x408
 8000aac:	f6c0 0002 	movt	r0, #2050	; 0x802
 8000ab0:	f014 feda 	bl	8015868 <assert_failed>
 8000ab4:	e7ec      	b.n	8000a90 <HAL_SetFMCMemorySwappingConfig+0x10>
 8000ab6:	bf00      	nop

08000ab8 <HAL_ADC_Start_DMA>:
  * @param pData Destination Buffer address.
  * @param Length Number of data to be transferred from ADC peripheral to memory
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef *hadc, uint32_t *pData, uint32_t Length)
{
 8000ab8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  HAL_StatusTypeDef tmp_hal_status;
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000abc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
 8000ac0:	460e      	mov	r6, r1
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000ac2:	6801      	ldr	r1, [r0, #0]
{
 8000ac4:	4604      	mov	r4, r0
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000ac6:	f2c4 0302 	movt	r3, #16386	; 0x4002
{
 8000aca:	4690      	mov	r8, r2
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000acc:	4299      	cmp	r1, r3
 8000ace:	d047      	beq.n	8000b60 <HAL_ADC_Start_DMA+0xa8>
 8000ad0:	f44f 5304 	mov.w	r3, #8448	; 0x2100
 8000ad4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000ad8:	4299      	cmp	r1, r3
 8000ada:	d041      	beq.n	8000b60 <HAL_ADC_Start_DMA+0xa8>
 8000adc:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
 8000ae0:	f6c5 0302 	movt	r3, #22530	; 0x5802

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000ae4:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 8000ae8:	f44f 5004 	mov.w	r0, #8448	; 0x2100
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_SIM_INJ_ALT
  *         @arg @ref LL_ADC_MULTI_DUAL_REG_INT_INJ_SIM
  */
__STATIC_INLINE uint32_t LL_ADC_GetMultimode(ADC_Common_TypeDef *ADCxy_COMMON)
{
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000aec:	689d      	ldr	r5, [r3, #8]
 8000aee:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8000af2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000af6:	42b9      	cmp	r1, r7
 8000af8:	bf18      	it	ne
 8000afa:	4281      	cmpne	r1, r0
 8000afc:	d005      	beq.n	8000b0a <HAL_ADC_Start_DMA+0x52>
 8000afe:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8000b02:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8000b06:	4299      	cmp	r1, r3
 8000b08:	d12f      	bne.n	8000b6a <HAL_ADC_Start_DMA+0xb2>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000b0a:	688b      	ldr	r3, [r1, #8]
 8000b0c:	075b      	lsls	r3, r3, #29
 8000b0e:	d438      	bmi.n	8000b82 <HAL_ADC_Start_DMA+0xca>

  /* Perform ADC enable and conversion start if no conversion is on going */
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
  {
    /* Process locked */
    __HAL_LOCK(hadc);
 8000b10:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8000b14:	2b01      	cmp	r3, #1
 8000b16:	d034      	beq.n	8000b82 <HAL_ADC_Start_DMA+0xca>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000b18:	f005 051f 	and.w	r5, r5, #31
 8000b1c:	2301      	movs	r3, #1

    /* Ensure that multimode regular conversions are not enabled.   */
    /* Otherwise, dedicated API HAL_ADCEx_MultiModeStart_DMA() must be used.  */
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000b1e:	2d09      	cmp	r5, #9
    __HAL_LOCK(hadc);
 8000b20:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000b24:	d905      	bls.n	8000b32 <HAL_ADC_Start_DMA+0x7a>
        LL_ADC_REG_StartConversion(hadc->Instance);
      }
      else
      {
        /* Process unlocked */
        __HAL_UNLOCK(hadc);
 8000b26:	2300      	movs	r3, #0
 8000b28:	2001      	movs	r0, #1
 8000b2a:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
    tmp_hal_status = HAL_BUSY;
  }

  /* Return function status */
  return tmp_hal_status;
}
 8000b2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if ((tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000b32:	f240 2321 	movw	r3, #545	; 0x221
 8000b36:	40eb      	lsrs	r3, r5
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8000b38:	07df      	lsls	r7, r3, #31
 8000b3a:	d5f4      	bpl.n	8000b26 <HAL_ADC_Start_DMA+0x6e>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8000b3c:	688b      	ldr	r3, [r1, #8]
 8000b3e:	07d8      	lsls	r0, r3, #31
 8000b40:	d422      	bmi.n	8000b88 <HAL_ADC_Start_DMA+0xd0>
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (LL_ADC_IsEnabled(hadc->Instance) == 0UL)
  {
    /* Check if conditions to enable the ADC are fulfilled */
    if ((hadc->Instance->CR & (ADC_CR_ADCAL | ADC_CR_JADSTP | ADC_CR_ADSTP | ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADDIS | ADC_CR_ADEN)) != 0UL)
 8000b42:	233f      	movs	r3, #63	; 0x3f
 8000b44:	688a      	ldr	r2, [r1, #8]
 8000b46:	f2c8 0300 	movt	r3, #32768	; 0x8000
 8000b4a:	421a      	tst	r2, r3
 8000b4c:	d073      	beq.n	8000c36 <HAL_ADC_Start_DMA+0x17e>
        }

        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
        {
          /* Update ADC state machine to error */
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000b4e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000b50:	f043 0310 	orr.w	r3, r3, #16
 8000b54:	6563      	str	r3, [r4, #84]	; 0x54

          /* Set ADC error code to ADC peripheral internal error */
          SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8000b56:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000b58:	f043 0301 	orr.w	r3, r3, #1
 8000b5c:	65a3      	str	r3, [r4, #88]	; 0x58
 8000b5e:	e7e2      	b.n	8000b26 <HAL_ADC_Start_DMA+0x6e>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000b60:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8000b64:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000b68:	e7bc      	b.n	8000ae4 <HAL_ADC_Start_DMA+0x2c>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000b6a:	f64d 1048 	movw	r0, #55624	; 0xd948
 8000b6e:	f240 71a7 	movw	r1, #1959	; 0x7a7
 8000b72:	f6c0 0002 	movt	r0, #2050	; 0x802
 8000b76:	f014 fe77 	bl	8015868 <assert_failed>
 8000b7a:	6821      	ldr	r1, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000b7c:	688b      	ldr	r3, [r1, #8]
 8000b7e:	075b      	lsls	r3, r3, #29
 8000b80:	d5c6      	bpl.n	8000b10 <HAL_ADC_Start_DMA+0x58>
    tmp_hal_status = HAL_BUSY;
 8000b82:	2002      	movs	r0, #2
}
 8000b84:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8000b88:	f44f 5304 	mov.w	r3, #8448	; 0x2100
 8000b8c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8000b90:	1ac9      	subs	r1, r1, r3
 8000b92:	bf18      	it	ne
 8000b94:	2101      	movne	r1, #1
        ADC_STATE_CLR_SET(hadc->State,
 8000b96:	f24f 03fe 	movw	r3, #61694	; 0xf0fe
 8000b9a:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8000b9c:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8000ba0:	4013      	ands	r3, r2
 8000ba2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000ba6:	6563      	str	r3, [r4, #84]	; 0x54
            || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000ba8:	b105      	cbz	r5, 8000bac <HAL_ADC_Start_DMA+0xf4>
 8000baa:	b119      	cbz	r1, 8000bb4 <HAL_ADC_Start_DMA+0xfc>
          CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 8000bac:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000bae:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 8000bb2:	6563      	str	r3, [r4, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) != 0UL)
 8000bb4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000bb6:	f413 5380 	ands.w	r3, r3, #4096	; 0x1000
 8000bba:	d03a      	beq.n	8000c32 <HAL_ADC_Start_DMA+0x17a>
          CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));
 8000bbc:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000bbe:	f023 0306 	bic.w	r3, r3, #6
 8000bc2:	65a3      	str	r3, [r4, #88]	; 0x58
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000bc4:	f241 072d 	movw	r7, #4141	; 0x102d
 8000bc8:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000bca:	f640 40e9 	movw	r0, #3305	; 0xce9
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000bce:	f241 0195 	movw	r1, #4245	; 0x1095
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000bd2:	f6c0 0700 	movt	r7, #2048	; 0x800
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000bd6:	4632      	mov	r2, r6
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000bd8:	f6c0 0000 	movt	r0, #2048	; 0x800
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000bdc:	f6c0 0100 	movt	r1, #2048	; 0x800
        hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
 8000be0:	63ef      	str	r7, [r5, #60]	; 0x3c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8000be2:	261c      	movs	r6, #28
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000be4:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000be6:	4643      	mov	r3, r8
        hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
 8000be8:	6428      	str	r0, [r5, #64]	; 0x40
        __HAL_UNLOCK(hadc);
 8000bea:	2500      	movs	r5, #0
        hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
 8000bec:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8000bee:	64c1      	str	r1, [r0, #76]	; 0x4c
        __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 8000bf0:	6821      	ldr	r1, [r4, #0]
 8000bf2:	600e      	str	r6, [r1, #0]
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8000bf4:	6820      	ldr	r0, [r4, #0]
        __HAL_UNLOCK(hadc);
 8000bf6:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
        __HAL_ADC_ENABLE_IT(hadc, ADC_IT_OVR);
 8000bfa:	6841      	ldr	r1, [r0, #4]
 8000bfc:	f041 0110 	orr.w	r1, r1, #16
 8000c00:	6041      	str	r1, [r0, #4]
        LL_ADC_REG_SetDataTransferMode(hadc->Instance, (uint32_t)hadc->Init.ConversionDataManagement);
 8000c02:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(ADCx->CFGR, ADC_CFGR_DMNGT, DataTransferMode);
 8000c04:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
 8000c06:	68c1      	ldr	r1, [r0, #12]
 8000c08:	f021 0103 	bic.w	r1, r1, #3
 8000c0c:	4329      	orrs	r1, r5
 8000c0e:	60c1      	str	r1, [r0, #12]
        tmp_hal_status = HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
 8000c10:	6821      	ldr	r1, [r4, #0]
 8000c12:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8000c14:	3140      	adds	r1, #64	; 0x40
 8000c16:	f002 ff01 	bl	8003a1c <HAL_DMA_Start_IT>
        LL_ADC_REG_StartConversion(hadc->Instance);
 8000c1a:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(ADCx->CR,
 8000c1c:	f64f 73c0 	movw	r3, #65472	; 0xffc0
 8000c20:	6891      	ldr	r1, [r2, #8]
 8000c22:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
 8000c26:	400b      	ands	r3, r1
 8000c28:	f043 0304 	orr.w	r3, r3, #4
 8000c2c:	6093      	str	r3, [r2, #8]
}
 8000c2e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
          ADC_CLEAR_ERRORCODE(hadc);
 8000c32:	65a3      	str	r3, [r4, #88]	; 0x58
 8000c34:	e7c6      	b.n	8000bc4 <HAL_ADC_Start_DMA+0x10c>
  MODIFY_REG(ADCx->CR,
 8000c36:	f64f 73c0 	movw	r3, #65472	; 0xffc0
 8000c3a:	688a      	ldr	r2, [r1, #8]
 8000c3c:	f6c7 73ff 	movt	r3, #32767	; 0x7fff
 8000c40:	4013      	ands	r3, r2
 8000c42:	f043 0301 	orr.w	r3, r3, #1
 8000c46:	608b      	str	r3, [r1, #8]
    tickstart = HAL_GetTick();
 8000c48:	f7ff fef8 	bl	8000a3c <HAL_GetTick>
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000c4c:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000c50:	6823      	ldr	r3, [r4, #0]
    tickstart = HAL_GetTick();
 8000c52:	4607      	mov	r7, r0
    uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000c54:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000c58:	4293      	cmp	r3, r2
 8000c5a:	d028      	beq.n	8000cae <HAL_ADC_Start_DMA+0x1f6>
 8000c5c:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000c60:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000c64:	4293      	cmp	r3, r2
 8000c66:	d022      	beq.n	8000cae <HAL_ADC_Start_DMA+0x1f6>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000c68:	f44f 42c6 	mov.w	r2, #25344	; 0x6300
 8000c6c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8000c70:	6892      	ldr	r2, [r2, #8]
  MODIFY_REG(ADCx->CR,
 8000c72:	f64f 79c0 	movw	r9, #65472	; 0xffc0
 8000c76:	f6c7 79ff 	movt	r9, #32767	; 0x7fff
 8000c7a:	e00c      	b.n	8000c96 <HAL_ADC_Start_DMA+0x1de>
 8000c7c:	689a      	ldr	r2, [r3, #8]
 8000c7e:	ea02 0209 	and.w	r2, r2, r9
 8000c82:	f042 0201 	orr.w	r2, r2, #1
 8000c86:	609a      	str	r2, [r3, #8]
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8000c88:	f7ff fed8 	bl	8000a3c <HAL_GetTick>
 8000c8c:	1bc0      	subs	r0, r0, r7
 8000c8e:	2802      	cmp	r0, #2
 8000c90:	f63f af5d 	bhi.w	8000b4e <HAL_ADC_Start_DMA+0x96>
 8000c94:	6823      	ldr	r3, [r4, #0]
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == 0UL)
 8000c96:	681a      	ldr	r2, [r3, #0]
 8000c98:	07d2      	lsls	r2, r2, #31
 8000c9a:	d41d      	bmi.n	8000cd8 <HAL_ADC_Start_DMA+0x220>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8000c9c:	689a      	ldr	r2, [r3, #8]
 8000c9e:	07d1      	lsls	r1, r2, #31
 8000ca0:	d5ec      	bpl.n	8000c7c <HAL_ADC_Start_DMA+0x1c4>
        if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8000ca2:	f7ff fecb 	bl	8000a3c <HAL_GetTick>
 8000ca6:	1bc0      	subs	r0, r0, r7
 8000ca8:	2802      	cmp	r0, #2
 8000caa:	d9f3      	bls.n	8000c94 <HAL_ADC_Start_DMA+0x1dc>
 8000cac:	e74f      	b.n	8000b4e <HAL_ADC_Start_DMA+0x96>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DUAL));
 8000cae:	f44f 510c 	mov.w	r1, #8960	; 0x2300
    if (    (__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000cb2:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000cb6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8000cba:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000cbe:	6889      	ldr	r1, [r1, #8]
         || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000cc0:	f011 0f1f 	tst.w	r1, #31
 8000cc4:	bf0c      	ite	eq
 8000cc6:	2101      	moveq	r1, #1
 8000cc8:	2100      	movne	r1, #0
 8000cca:	4293      	cmp	r3, r2
 8000ccc:	bf18      	it	ne
 8000cce:	f041 0101 	orrne.w	r1, r1, #1
 8000cd2:	2900      	cmp	r1, #0
 8000cd4:	d1cd      	bne.n	8000c72 <HAL_ADC_Start_DMA+0x1ba>
 8000cd6:	e75e      	b.n	8000b96 <HAL_ADC_Start_DMA+0xde>
 8000cd8:	f44f 5104 	mov.w	r1, #8448	; 0x2100
 8000cdc:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8000ce0:	1a59      	subs	r1, r3, r1
 8000ce2:	bf18      	it	ne
 8000ce4:	2101      	movne	r1, #1
 8000ce6:	e756      	b.n	8000b96 <HAL_ADC_Start_DMA+0xde>

08000ce8 <ADC_DMAHalfConvCplt>:
  * @brief  DMA half transfer complete callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)
{
 8000ce8:	b508      	push	{r3, lr}

  /* Half conversion callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ConvHalfCpltCallback(hadc);
#else
  HAL_ADC_ConvHalfCpltCallback(hadc);
 8000cea:	6b80      	ldr	r0, [r0, #56]	; 0x38
 8000cec:	f014 fbd2 	bl	8015494 <HAL_ADC_ConvHalfCpltCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 8000cf0:	bd08      	pop	{r3, pc}
 8000cf2:	bf00      	nop

08000cf4 <HAL_ADC_LevelOutOfWindowCallback>:
 8000cf4:	4770      	bx	lr
 8000cf6:	bf00      	nop

08000cf8 <HAL_ADC_ErrorCallback>:
 8000cf8:	4770      	bx	lr
 8000cfa:	bf00      	nop

08000cfc <HAL_ADC_IRQHandler>:
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000cfc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
{
 8000d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000d02:	f2c4 0202 	movt	r2, #16386	; 0x4002
  uint32_t tmp_isr = hadc->Instance->ISR;
 8000d06:	6803      	ldr	r3, [r0, #0]
{
 8000d08:	4604      	mov	r4, r0
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000d0a:	4293      	cmp	r3, r2
  uint32_t tmp_isr = hadc->Instance->ISR;
 8000d0c:	681d      	ldr	r5, [r3, #0]
  uint32_t tmp_ier = hadc->Instance->IER;
 8000d0e:	685e      	ldr	r6, [r3, #4]
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000d10:	f000 80ae 	beq.w	8000e70 <HAL_ADC_IRQHandler+0x174>
 8000d14:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000d18:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d1c:	4293      	cmp	r3, r2
 8000d1e:	f000 80a7 	beq.w	8000e70 <HAL_ADC_IRQHandler+0x174>
 8000d22:	f44f 40c6 	mov.w	r0, #25344	; 0x6300
 8000d26:	f6c5 0002 	movt	r0, #22530	; 0x5802
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000d2a:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8000d2e:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000d32:	6887      	ldr	r7, [r0, #8]
 8000d34:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8000d38:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d3c:	f007 071f 	and.w	r7, r7, #31
 8000d40:	428b      	cmp	r3, r1
 8000d42:	bf18      	it	ne
 8000d44:	4293      	cmpne	r3, r2
 8000d46:	d006      	beq.n	8000d56 <HAL_ADC_IRQHandler+0x5a>
 8000d48:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8000d4c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8000d50:	4293      	cmp	r3, r2
 8000d52:	f040 809b 	bne.w	8000e8c <HAL_ADC_IRQHandler+0x190>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8000d56:	6923      	ldr	r3, [r4, #16]
 8000d58:	2b04      	cmp	r3, #4
 8000d5a:	d002      	beq.n	8000d62 <HAL_ADC_IRQHandler+0x66>
 8000d5c:	2b08      	cmp	r3, #8
 8000d5e:	f040 808c 	bne.w	8000e7a <HAL_ADC_IRQHandler+0x17e>
  if (((tmp_isr & ADC_FLAG_EOSMP) == ADC_FLAG_EOSMP) && ((tmp_ier & ADC_IT_EOSMP) == ADC_IT_EOSMP))
 8000d62:	07a8      	lsls	r0, r5, #30
 8000d64:	d502      	bpl.n	8000d6c <HAL_ADC_IRQHandler+0x70>
 8000d66:	07b1      	lsls	r1, r6, #30
 8000d68:	f100 80c4 	bmi.w	8000ef4 <HAL_ADC_IRQHandler+0x1f8>
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8000d6c:	076b      	lsls	r3, r5, #29
 8000d6e:	d574      	bpl.n	8000e5a <HAL_ADC_IRQHandler+0x15e>
 8000d70:	0770      	lsls	r0, r6, #29
 8000d72:	d572      	bpl.n	8000e5a <HAL_ADC_IRQHandler+0x15e>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000d74:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d76:	06db      	lsls	r3, r3, #27
 8000d78:	d403      	bmi.n	8000d82 <HAL_ADC_IRQHandler+0x86>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8000d7a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000d7c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000d80:	6563      	str	r3, [r4, #84]	; 0x54
    if (LL_ADC_REG_IsTriggerSourceSWStart(hadc->Instance) != 0UL)
 8000d82:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000d84:	68da      	ldr	r2, [r3, #12]
 8000d86:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 8000d8a:	d11f      	bne.n	8000dcc <HAL_ADC_IRQHandler+0xd0>
      if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000d8c:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000d90:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000d94:	4293      	cmp	r3, r2
 8000d96:	f000 8119 	beq.w	8000fcc <HAL_ADC_IRQHandler+0x2d0>
        tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8000d9a:	68da      	ldr	r2, [r3, #12]
      if (READ_BIT(tmp_cfgr, ADC_CFGR_CONT) != ADC_CFGR_CONT)
 8000d9c:	0490      	lsls	r0, r2, #18
 8000d9e:	d415      	bmi.n	8000dcc <HAL_ADC_IRQHandler+0xd0>
        if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS))
 8000da0:	681a      	ldr	r2, [r3, #0]
 8000da2:	0711      	lsls	r1, r2, #28
 8000da4:	d512      	bpl.n	8000dcc <HAL_ADC_IRQHandler+0xd0>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8000da6:	689a      	ldr	r2, [r3, #8]
 8000da8:	0752      	lsls	r2, r2, #29
 8000daa:	f100 8130 	bmi.w	800100e <HAL_ADC_IRQHandler+0x312>
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC | ADC_IT_EOS);
 8000dae:	685a      	ldr	r2, [r3, #4]
 8000db0:	f022 020c 	bic.w	r2, r2, #12
 8000db4:	605a      	str	r2, [r3, #4]
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8000db6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000db8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8000dbc:	6563      	str	r3, [r4, #84]	; 0x54
            if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8000dbe:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000dc0:	04db      	lsls	r3, r3, #19
 8000dc2:	d403      	bmi.n	8000dcc <HAL_ADC_IRQHandler+0xd0>
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000dc4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000dc6:	f043 0301 	orr.w	r3, r3, #1
 8000dca:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
 8000dcc:	4620      	mov	r0, r4
 8000dce:	f014 fb5f 	bl	8015490 <HAL_ADC_ConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 8000dd2:	6823      	ldr	r3, [r4, #0]
 8000dd4:	220c      	movs	r2, #12
 8000dd6:	601a      	str	r2, [r3, #0]
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8000dd8:	06a8      	lsls	r0, r5, #26
 8000dda:	d544      	bpl.n	8000e66 <HAL_ADC_IRQHandler+0x16a>
 8000ddc:	06b1      	lsls	r1, r6, #26
 8000dde:	d542      	bpl.n	8000e66 <HAL_ADC_IRQHandler+0x16a>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000de0:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000de2:	06d8      	lsls	r0, r3, #27
 8000de4:	d403      	bmi.n	8000dee <HAL_ADC_IRQHandler+0xf2>
      SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
 8000de6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000de8:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8000dec:	6563      	str	r3, [r4, #84]	; 0x54
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000dee:	f44f 5004 	mov.w	r0, #8448	; 0x2100
    tmp_adc_inj_is_trigger_source_sw_start = LL_ADC_INJ_IsTriggerSourceSWStart(hadc->Instance);
 8000df2:	6823      	ldr	r3, [r4, #0]
    if ((__LL_ADC_MULTI_INSTANCE_MASTER(hadc->Instance) == hadc->Instance)
 8000df4:	f2c4 0002 	movt	r0, #16386	; 0x4002
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8000df8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000dfa:	68d9      	ldr	r1, [r3, #12]
 8000dfc:	4283      	cmp	r3, r0
  return ((READ_BIT(ADCx->JSQR, ADC_JSQR_JEXTEN) == (LL_ADC_INJ_TRIG_SOFTWARE & ADC_JSQR_JEXTEN)) ? 1UL : 0UL);
 8000dfe:	f402 72c0 	and.w	r2, r2, #384	; 0x180
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8000e02:	f401 6140 	and.w	r1, r1, #3072	; 0xc00
 8000e06:	f000 8083 	beq.w	8000f10 <HAL_ADC_IRQHandler+0x214>
      tmp_cfgr = READ_REG(hadc->Instance->CFGR);
 8000e0a:	68d8      	ldr	r0, [r3, #12]
    if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
 8000e0c:	2a00      	cmp	r2, #0
 8000e0e:	f000 808e 	beq.w	8000f2e <HAL_ADC_IRQHandler+0x232>
        ((READ_BIT(tmp_cfgr, ADC_CFGR_JAUTO) == 0UL)      &&
 8000e12:	f000 7200 	and.w	r2, r0, #33554432	; 0x2000000
 8000e16:	430a      	orrs	r2, r1
 8000e18:	f000 80e0 	beq.w	8000fdc <HAL_ADC_IRQHandler+0x2e0>
    HAL_ADCEx_InjectedConvCpltCallback(hadc);
 8000e1c:	4620      	mov	r0, r4
 8000e1e:	f001 fab9 	bl	8002394 <HAL_ADCEx_InjectedConvCpltCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOC | ADC_FLAG_JEOS);
 8000e22:	6823      	ldr	r3, [r4, #0]
 8000e24:	2260      	movs	r2, #96	; 0x60
 8000e26:	601a      	str	r2, [r3, #0]
  if (((tmp_isr & ADC_FLAG_AWD1) == ADC_FLAG_AWD1) && ((tmp_ier & ADC_IT_AWD1) == ADC_IT_AWD1))
 8000e28:	0628      	lsls	r0, r5, #24
 8000e2a:	d502      	bpl.n	8000e32 <HAL_ADC_IRQHandler+0x136>
 8000e2c:	0631      	lsls	r1, r6, #24
 8000e2e:	f100 80b6 	bmi.w	8000f9e <HAL_ADC_IRQHandler+0x2a2>
  if (((tmp_isr & ADC_FLAG_AWD2) == ADC_FLAG_AWD2) && ((tmp_ier & ADC_IT_AWD2) == ADC_IT_AWD2))
 8000e32:	05ea      	lsls	r2, r5, #23
 8000e34:	d502      	bpl.n	8000e3c <HAL_ADC_IRQHandler+0x140>
 8000e36:	05f3      	lsls	r3, r6, #23
 8000e38:	f100 80bc 	bmi.w	8000fb4 <HAL_ADC_IRQHandler+0x2b8>
  if (((tmp_isr & ADC_FLAG_AWD3) == ADC_FLAG_AWD3) && ((tmp_ier & ADC_IT_AWD3) == ADC_IT_AWD3))
 8000e3c:	05a8      	lsls	r0, r5, #22
 8000e3e:	d502      	bpl.n	8000e46 <HAL_ADC_IRQHandler+0x14a>
 8000e40:	05b1      	lsls	r1, r6, #22
 8000e42:	f100 80a0 	bmi.w	8000f86 <HAL_ADC_IRQHandler+0x28a>
  if (((tmp_isr & ADC_FLAG_OVR) == ADC_FLAG_OVR) && ((tmp_ier & ADC_IT_OVR) == ADC_IT_OVR))
 8000e46:	06ea      	lsls	r2, r5, #27
 8000e48:	d501      	bpl.n	8000e4e <HAL_ADC_IRQHandler+0x152>
 8000e4a:	06f3      	lsls	r3, r6, #27
 8000e4c:	d427      	bmi.n	8000e9e <HAL_ADC_IRQHandler+0x1a2>
  if (((tmp_isr & ADC_FLAG_JQOVF) == ADC_FLAG_JQOVF) && ((tmp_ier & ADC_IT_JQOVF) == ADC_IT_JQOVF))
 8000e4e:	0568      	lsls	r0, r5, #21
 8000e50:	d502      	bpl.n	8000e58 <HAL_ADC_IRQHandler+0x15c>
 8000e52:	0571      	lsls	r1, r6, #21
 8000e54:	f100 8086 	bmi.w	8000f64 <HAL_ADC_IRQHandler+0x268>
}
 8000e58:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if ((((tmp_isr & ADC_FLAG_EOC) == ADC_FLAG_EOC) && ((tmp_ier & ADC_IT_EOC) == ADC_IT_EOC)) ||
 8000e5a:	0729      	lsls	r1, r5, #28
 8000e5c:	d5bc      	bpl.n	8000dd8 <HAL_ADC_IRQHandler+0xdc>
      (((tmp_isr & ADC_FLAG_EOS) == ADC_FLAG_EOS) && ((tmp_ier & ADC_IT_EOS) == ADC_IT_EOS)))
 8000e5e:	0732      	lsls	r2, r6, #28
 8000e60:	d488      	bmi.n	8000d74 <HAL_ADC_IRQHandler+0x78>
  if ((((tmp_isr & ADC_FLAG_JEOC) == ADC_FLAG_JEOC) && ((tmp_ier & ADC_IT_JEOC) == ADC_IT_JEOC)) ||
 8000e62:	06a8      	lsls	r0, r5, #26
 8000e64:	d4ba      	bmi.n	8000ddc <HAL_ADC_IRQHandler+0xe0>
 8000e66:	066a      	lsls	r2, r5, #25
 8000e68:	d5de      	bpl.n	8000e28 <HAL_ADC_IRQHandler+0x12c>
      (((tmp_isr & ADC_FLAG_JEOS) == ADC_FLAG_JEOS) && ((tmp_ier & ADC_IT_JEOS) == ADC_IT_JEOS)))
 8000e6a:	0673      	lsls	r3, r6, #25
 8000e6c:	d5dc      	bpl.n	8000e28 <HAL_ADC_IRQHandler+0x12c>
 8000e6e:	e7b7      	b.n	8000de0 <HAL_ADC_IRQHandler+0xe4>
  uint32_t tmp_multimode_config = LL_ADC_GetMultimode(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8000e70:	f44f 500c 	mov.w	r0, #8960	; 0x2300
 8000e74:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000e78:	e757      	b.n	8000d2a <HAL_ADC_IRQHandler+0x2e>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8000e7a:	f64d 1048 	movw	r0, #55624	; 0xd948
 8000e7e:	f640 0199 	movw	r1, #2201	; 0x899
 8000e82:	f6c0 0002 	movt	r0, #2050	; 0x802
 8000e86:	f014 fcef 	bl	8015868 <assert_failed>
 8000e8a:	e76a      	b.n	8000d62 <HAL_ADC_IRQHandler+0x66>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8000e8c:	f64d 1048 	movw	r0, #55624	; 0xd948
 8000e90:	f640 0198 	movw	r1, #2200	; 0x898
 8000e94:	f6c0 0002 	movt	r0, #2050	; 0x802
 8000e98:	f014 fce6 	bl	8015868 <assert_failed>
 8000e9c:	e75b      	b.n	8000d56 <HAL_ADC_IRQHandler+0x5a>
    if (hadc->Init.Overrun == ADC_OVR_DATA_PRESERVED)
 8000e9e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000ea0:	b1cb      	cbz	r3, 8000ed6 <HAL_ADC_IRQHandler+0x1da>
 8000ea2:	6823      	ldr	r3, [r4, #0]
      if (tmp_multimode_config != LL_ADC_MULTI_INDEPENDENT)
 8000ea4:	2f00      	cmp	r7, #0
 8000ea6:	f000 80a4 	beq.w	8000ff2 <HAL_ADC_IRQHandler+0x2f6>
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8000eaa:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000eae:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000eb2:	4293      	cmp	r3, r2
 8000eb4:	f000 80b4 	beq.w	8001020 <HAL_ADC_IRQHandler+0x324>
 8000eb8:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8000ebc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000ec0:	4293      	cmp	r3, r2
 8000ec2:	f000 80ad 	beq.w	8001020 <HAL_ADC_IRQHandler+0x324>
 8000ec6:	f44f 42c6 	mov.w	r2, #25344	; 0x6300
 8000eca:	f6c5 0202 	movt	r2, #22530	; 0x5802
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_DAMDF));
 8000ece:	6892      	ldr	r2, [r2, #8]
 8000ed0:	f412 4f40 	tst.w	r2, #49152	; 0xc000
 8000ed4:	d00b      	beq.n	8000eee <HAL_ADC_IRQHandler+0x1f2>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8000ed6:	6d63      	ldr	r3, [r4, #84]	; 0x54
      HAL_ADC_ErrorCallback(hadc);
 8000ed8:	4620      	mov	r0, r4
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_OVR);
 8000eda:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8000ede:	6563      	str	r3, [r4, #84]	; 0x54
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_OVR);
 8000ee0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000ee2:	f043 0302 	orr.w	r3, r3, #2
 8000ee6:	65a3      	str	r3, [r4, #88]	; 0x58
      HAL_ADC_ErrorCallback(hadc);
 8000ee8:	f7ff ff06 	bl	8000cf8 <HAL_ADC_ErrorCallback>
 8000eec:	6823      	ldr	r3, [r4, #0]
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_OVR);
 8000eee:	2210      	movs	r2, #16
 8000ef0:	601a      	str	r2, [r3, #0]
 8000ef2:	e7ac      	b.n	8000e4e <HAL_ADC_IRQHandler+0x152>
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8000ef4:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000ef6:	06da      	lsls	r2, r3, #27
 8000ef8:	d403      	bmi.n	8000f02 <HAL_ADC_IRQHandler+0x206>
      SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOSMP);
 8000efa:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000efc:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8000f00:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_EndOfSamplingCallback(hadc);
 8000f02:	4620      	mov	r0, r4
 8000f04:	f001 fa4e 	bl	80023a4 <HAL_ADCEx_EndOfSamplingCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOSMP);
 8000f08:	6823      	ldr	r3, [r4, #0]
 8000f0a:	2202      	movs	r2, #2
 8000f0c:	601a      	str	r2, [r3, #0]
 8000f0e:	e72d      	b.n	8000d6c <HAL_ADC_IRQHandler+0x70>
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_SIMULT)
 8000f10:	1fb8      	subs	r0, r7, #6
        || (tmp_multimode_config == LL_ADC_MULTI_DUAL_REG_INTERL)
 8000f12:	2801      	cmp	r0, #1
 8000f14:	f67f af79 	bls.w	8000e0a <HAL_ADC_IRQHandler+0x10e>
 8000f18:	2f00      	cmp	r7, #0
 8000f1a:	f43f af76 	beq.w	8000e0a <HAL_ADC_IRQHandler+0x10e>
      tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8000f1e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000f22:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8000f26:	68c0      	ldr	r0, [r0, #12]
    if ((tmp_adc_inj_is_trigger_source_sw_start != 0UL)            ||
 8000f28:	2a00      	cmp	r2, #0
 8000f2a:	f47f af72 	bne.w	8000e12 <HAL_ADC_IRQHandler+0x116>
      if (__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS))
 8000f2e:	681a      	ldr	r2, [r3, #0]
 8000f30:	0652      	lsls	r2, r2, #25
 8000f32:	f57f af73 	bpl.w	8000e1c <HAL_ADC_IRQHandler+0x120>
        if (READ_BIT(tmp_cfgr, ADC_CFGR_JQM) == 0UL)
 8000f36:	0281      	lsls	r1, r0, #10
 8000f38:	f53f af70 	bmi.w	8000e1c <HAL_ADC_IRQHandler+0x120>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group injected.
  */
__STATIC_INLINE uint32_t LL_ADC_INJ_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8000f3c:	689a      	ldr	r2, [r3, #8]
 8000f3e:	0712      	lsls	r2, r2, #28
 8000f40:	d45c      	bmi.n	8000ffc <HAL_ADC_IRQHandler+0x300>
            __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC | ADC_IT_JEOS);
 8000f42:	685a      	ldr	r2, [r3, #4]
 8000f44:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8000f48:	605a      	str	r2, [r3, #4]
            CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);
 8000f4a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000f4c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8000f50:	6563      	str	r3, [r4, #84]	; 0x54
            if ((hadc->State & HAL_ADC_STATE_REG_BUSY) == 0UL)
 8000f52:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000f54:	05db      	lsls	r3, r3, #23
 8000f56:	f53f af61 	bmi.w	8000e1c <HAL_ADC_IRQHandler+0x120>
              SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8000f5a:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000f5c:	f043 0301 	orr.w	r3, r3, #1
 8000f60:	6563      	str	r3, [r4, #84]	; 0x54
 8000f62:	e75b      	b.n	8000e1c <HAL_ADC_IRQHandler+0x120>
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8000f64:	6d63      	ldr	r3, [r4, #84]	; 0x54
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8000f66:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000f6a:	6822      	ldr	r2, [r4, #0]
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8000f6c:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_INJ_JQOVF);
 8000f6e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000f72:	6563      	str	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_JQOVF);
 8000f74:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8000f76:	f043 0308 	orr.w	r3, r3, #8
 8000f7a:	65a3      	str	r3, [r4, #88]	; 0x58
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JQOVF);
 8000f7c:	6011      	str	r1, [r2, #0]
}
 8000f7e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    HAL_ADCEx_InjectedQueueOverflowCallback(hadc);
 8000f82:	f001 ba09 	b.w	8002398 <HAL_ADCEx_InjectedQueueOverflowCallback>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8000f86:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8000f88:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD3);
 8000f8a:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000f8e:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow3Callback(hadc);
 8000f90:	f001 fa06 	bl	80023a0 <HAL_ADCEx_LevelOutOfWindow3Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD3);
 8000f94:	6823      	ldr	r3, [r4, #0]
 8000f96:	f44f 7200 	mov.w	r2, #512	; 0x200
 8000f9a:	601a      	str	r2, [r3, #0]
 8000f9c:	e753      	b.n	8000e46 <HAL_ADC_IRQHandler+0x14a>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8000f9e:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8000fa0:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
 8000fa2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000fa6:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADC_LevelOutOfWindowCallback(hadc);
 8000fa8:	f7ff fea4 	bl	8000cf4 <HAL_ADC_LevelOutOfWindowCallback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD1);
 8000fac:	6823      	ldr	r3, [r4, #0]
 8000fae:	2280      	movs	r2, #128	; 0x80
 8000fb0:	601a      	str	r2, [r3, #0]
 8000fb2:	e73e      	b.n	8000e32 <HAL_ADC_IRQHandler+0x136>
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8000fb4:	6d63      	ldr	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8000fb6:	4620      	mov	r0, r4
    SET_BIT(hadc->State, HAL_ADC_STATE_AWD2);
 8000fb8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000fbc:	6563      	str	r3, [r4, #84]	; 0x54
    HAL_ADCEx_LevelOutOfWindow2Callback(hadc);
 8000fbe:	f001 f9ed 	bl	800239c <HAL_ADCEx_LevelOutOfWindow2Callback>
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD2);
 8000fc2:	6823      	ldr	r3, [r4, #0]
 8000fc4:	f44f 7280 	mov.w	r2, #256	; 0x100
 8000fc8:	601a      	str	r2, [r3, #0]
 8000fca:	e737      	b.n	8000e3c <HAL_ADC_IRQHandler+0x140>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000fcc:	2f09      	cmp	r7, #9
 8000fce:	d909      	bls.n	8000fe4 <HAL_ADC_IRQHandler+0x2e8>
        tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
 8000fd0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8000fd4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8000fd8:	68d2      	ldr	r2, [r2, #12]
 8000fda:	e6df      	b.n	8000d9c <HAL_ADC_IRQHandler+0xa0>
         ((tmp_adc_reg_is_trigger_source_sw_start != 0UL)  &&
 8000fdc:	0481      	lsls	r1, r0, #18
 8000fde:	f53f af1d 	bmi.w	8000e1c <HAL_ADC_IRQHandler+0x120>
 8000fe2:	e7a4      	b.n	8000f2e <HAL_ADC_IRQHandler+0x232>
          || (tmp_multimode_config == LL_ADC_MULTI_INDEPENDENT)
 8000fe4:	f240 2221 	movw	r2, #545	; 0x221
 8000fe8:	40fa      	lsrs	r2, r7
          || (tmp_multimode_config == LL_ADC_MULTI_DUAL_INJ_ALTERN)
 8000fea:	07d2      	lsls	r2, r2, #31
 8000fec:	f53f aed5 	bmi.w	8000d9a <HAL_ADC_IRQHandler+0x9e>
 8000ff0:	e7ee      	b.n	8000fd0 <HAL_ADC_IRQHandler+0x2d4>
      if ((hadc->Instance->CFGR & ADC_CFGR_DMNGT) != 0UL)
 8000ff2:	68da      	ldr	r2, [r3, #12]
 8000ff4:	0797      	lsls	r7, r2, #30
 8000ff6:	f43f af7a 	beq.w	8000eee <HAL_ADC_IRQHandler+0x1f2>
 8000ffa:	e76c      	b.n	8000ed6 <HAL_ADC_IRQHandler+0x1da>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8000ffc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8000ffe:	f043 0310 	orr.w	r3, r3, #16
 8001002:	6563      	str	r3, [r4, #84]	; 0x54
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001004:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001006:	f043 0301 	orr.w	r3, r3, #1
 800100a:	65a3      	str	r3, [r4, #88]	; 0x58
 800100c:	e706      	b.n	8000e1c <HAL_ADC_IRQHandler+0x120>
            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800100e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8001010:	f043 0310 	orr.w	r3, r3, #16
 8001014:	6563      	str	r3, [r4, #84]	; 0x54
            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001016:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001018:	f043 0301 	orr.w	r3, r3, #1
 800101c:	65a3      	str	r3, [r4, #88]	; 0x58
 800101e:	e6d5      	b.n	8000dcc <HAL_ADC_IRQHandler+0xd0>
        if (LL_ADC_GetMultiDMATransfer(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) != LL_ADC_MULTI_REG_DMA_EACH_ADC)
 8001020:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8001024:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001028:	e751      	b.n	8000ece <HAL_ADC_IRQHandler+0x1d2>
 800102a:	bf00      	nop

0800102c <ADC_DMAConvCplt>:
{
 800102c:	b510      	push	{r4, lr}
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800102e:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 8001030:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001032:	f012 0f50 	tst.w	r2, #80	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 8001036:	6d5a      	ldr	r2, [r3, #84]	; 0x54
  if ((hadc->State & (HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA)) == 0UL)
 8001038:	d11d      	bne.n	8001076 <ADC_DMAConvCplt+0x4a>
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 800103a:	6819      	ldr	r1, [r3, #0]
    SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 800103c:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001040:	655a      	str	r2, [r3, #84]	; 0x54
    if ((hadc->Instance->ISR & ADC_FLAG_EOS) != 0UL)
 8001042:	680a      	ldr	r2, [r1, #0]
 8001044:	f012 0f08 	tst.w	r2, #8
  return ((READ_BIT(ADCx->CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE & ADC_CFGR_EXTEN)) ? 1UL : 0UL);
 8001048:	68ca      	ldr	r2, [r1, #12]
 800104a:	d01b      	beq.n	8001084 <ADC_DMAConvCplt+0x58>
 800104c:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 8001050:	d10d      	bne.n	800106e <ADC_DMAConvCplt+0x42>
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_CONT) == 0UL)
 8001052:	68ca      	ldr	r2, [r1, #12]
 8001054:	0494      	lsls	r4, r2, #18
 8001056:	d40a      	bmi.n	800106e <ADC_DMAConvCplt+0x42>
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 8001058:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800105a:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 800105e:	655a      	str	r2, [r3, #84]	; 0x54
        if ((hadc->State & HAL_ADC_STATE_INJ_BUSY) == 0UL)
 8001060:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001062:	04d1      	lsls	r1, r2, #19
 8001064:	d403      	bmi.n	800106e <ADC_DMAConvCplt+0x42>
          SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 8001066:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 8001068:	f042 0201 	orr.w	r2, r2, #1
 800106c:	655a      	str	r2, [r3, #84]	; 0x54
    HAL_ADC_ConvCpltCallback(hadc);
 800106e:	4618      	mov	r0, r3
 8001070:	f014 fa0e 	bl	8015490 <HAL_ADC_ConvCpltCallback>
}
 8001074:	bd10      	pop	{r4, pc}
    if ((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) != 0UL)
 8001076:	06d2      	lsls	r2, r2, #27
 8001078:	d407      	bmi.n	800108a <ADC_DMAConvCplt+0x5e>
      hadc->DMA_Handle->XferErrorCallback(hdma);
 800107a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
 800107c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      hadc->DMA_Handle->XferErrorCallback(hdma);
 8001080:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001082:	4718      	bx	r3
      if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMNGT) == 0UL)
 8001084:	0790      	lsls	r0, r2, #30
 8001086:	d1f2      	bne.n	800106e <ADC_DMAConvCplt+0x42>
 8001088:	e7e6      	b.n	8001058 <ADC_DMAConvCplt+0x2c>
      HAL_ADC_ErrorCallback(hadc);
 800108a:	4618      	mov	r0, r3
 800108c:	f7ff fe34 	bl	8000cf8 <HAL_ADC_ErrorCallback>
}
 8001090:	bd10      	pop	{r4, pc}
 8001092:	bf00      	nop

08001094 <ADC_DMAError>:
  * @brief  DMA error callback.
  * @param hdma pointer to DMA handle.
  * @retval None
  */
void ADC_DMAError(DMA_HandleTypeDef *hdma)
{
 8001094:	b508      	push	{r3, lr}
  /* Retrieve ADC handle corresponding to current DMA handle */
  ADC_HandleTypeDef *hadc = (ADC_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 8001096:	6b83      	ldr	r3, [r0, #56]	; 0x38

  /* Set ADC state */
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 8001098:	6d5a      	ldr	r2, [r3, #84]	; 0x54

  /* Error callback */
#if (USE_HAL_ADC_REGISTER_CALLBACKS == 1)
  hadc->ErrorCallback(hadc);
#else
  HAL_ADC_ErrorCallback(hadc);
 800109a:	4618      	mov	r0, r3
  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
 800109c:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80010a0:	655a      	str	r2, [r3, #84]	; 0x54
  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
 80010a2:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 80010a4:	f042 0204 	orr.w	r2, r2, #4
 80010a8:	659a      	str	r2, [r3, #88]	; 0x58
  HAL_ADC_ErrorCallback(hadc);
 80010aa:	f7ff fe25 	bl	8000cf8 <HAL_ADC_ErrorCallback>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
}
 80010ae:	bd08      	pop	{r3, pc}

080010b0 <HAL_ADC_ConfigChannel>:
{
 80010b0:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80010b2:	f44f 5204 	mov.w	r2, #8448	; 0x2100
{
 80010b6:	4605      	mov	r5, r0
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80010b8:	f44f 5000 	mov.w	r0, #8192	; 0x2000
{
 80010bc:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80010be:	682b      	ldr	r3, [r5, #0]
 80010c0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 80010c4:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __IO uint32_t wait_loop_index = 0;
 80010c8:	2600      	movs	r6, #0
{
 80010ca:	460c      	mov	r4, r1
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80010cc:	4283      	cmp	r3, r0
 80010ce:	bf18      	it	ne
 80010d0:	4293      	cmpne	r3, r2
  __IO uint32_t wait_loop_index = 0;
 80010d2:	9601      	str	r6, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80010d4:	d006      	beq.n	80010e4 <HAL_ADC_ConfigChannel+0x34>
 80010d6:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 80010da:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80010de:	4293      	cmp	r3, r2
 80010e0:	f040 8234 	bne.w	800154c <HAL_ADC_ConfigChannel+0x49c>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 80010e4:	6862      	ldr	r2, [r4, #4]
 80010e6:	f422 7340 	bic.w	r3, r2, #768	; 0x300
 80010ea:	f422 7180 	bic.w	r1, r2, #256	; 0x100
 80010ee:	1f98      	subs	r0, r3, #6
 80010f0:	bf18      	it	ne
 80010f2:	2001      	movne	r0, #1
 80010f4:	2918      	cmp	r1, #24
 80010f6:	f240 8147 	bls.w	8001388 <HAL_ADC_ConfigChannel+0x2d8>
 80010fa:	2301      	movs	r3, #1
 80010fc:	f422 7600 	bic.w	r6, r2, #512	; 0x200
 8001100:	f5a2 7100 	sub.w	r1, r2, #512	; 0x200
 8001104:	f5b6 7680 	subs.w	r6, r6, #256	; 0x100
 8001108:	bf18      	it	ne
 800110a:	2601      	movne	r6, #1
 800110c:	2918      	cmp	r1, #24
 800110e:	f240 8132 	bls.w	8001376 <HAL_ADC_ConfigChannel+0x2c6>
 8001112:	2201      	movs	r2, #1
 8001114:	4003      	ands	r3, r0
 8001116:	421e      	tst	r6, r3
 8001118:	d002      	beq.n	8001120 <HAL_ADC_ConfigChannel+0x70>
 800111a:	2a00      	cmp	r2, #0
 800111c:	f040 846f 	bne.w	80019fe <HAL_ADC_ConfigChannel+0x94e>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
 8001120:	68a3      	ldr	r3, [r4, #8]
 8001122:	2b07      	cmp	r3, #7
 8001124:	f200 829f 	bhi.w	8001666 <HAL_ADC_ConfigChannel+0x5b6>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
 8001128:	68e3      	ldr	r3, [r4, #12]
 800112a:	f240 72ff 	movw	r2, #2047	; 0x7ff
 800112e:	4293      	cmp	r3, r2
 8001130:	d005      	beq.n	800113e <HAL_ADC_ConfigChannel+0x8e>
 8001132:	2200      	movs	r2, #0
 8001134:	f2c4 72ff 	movt	r2, #18431	; 0x47ff
 8001138:	4293      	cmp	r3, r2
 800113a:	f040 8145 	bne.w	80013c8 <HAL_ADC_ConfigChannel+0x318>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
 800113e:	6923      	ldr	r3, [r4, #16]
 8001140:	2b04      	cmp	r3, #4
 8001142:	f200 814d 	bhi.w	80013e0 <HAL_ADC_ConfigChannel+0x330>
  if (hadc->Init.OversamplingMode == ENABLE)
 8001146:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 800114a:	6961      	ldr	r1, [r4, #20]
 800114c:	2b01      	cmp	r3, #1
 800114e:	682a      	ldr	r2, [r5, #0]
 8001150:	f000 8155 	beq.w	80013fe <HAL_ADC_ConfigChannel+0x34e>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
 8001154:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001158:	f6c5 4300 	movt	r3, #23552	; 0x5c00
 800115c:	681b      	ldr	r3, [r3, #0]
 800115e:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001162:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8001166:	f040 81e9 	bne.w	800153c <HAL_ADC_ConfigChannel+0x48c>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
 800116a:	68d2      	ldr	r2, [r2, #12]
 800116c:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001170:	0852      	lsrs	r2, r2, #1
 8001172:	f002 020e 	and.w	r2, r2, #14
 8001176:	40d3      	lsrs	r3, r2
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
 8001178:	4299      	cmp	r1, r3
 800117a:	f200 81f0 	bhi.w	800155e <HAL_ADC_ConfigChannel+0x4ae>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 800117e:	2300      	movs	r3, #0
 8001180:	68e2      	ldr	r2, [r4, #12]
 8001182:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
 8001186:	429a      	cmp	r2, r3
 8001188:	f000 8165 	beq.w	8001456 <HAL_ADC_ConfigChannel+0x3a6>
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 800118c:	2302      	movs	r3, #2
 800118e:	6822      	ldr	r2, [r4, #0]
 8001190:	2604      	movs	r6, #4
 8001192:	2108      	movs	r1, #8
 8001194:	f2c0 4330 	movt	r3, #1072	; 0x430
 8001198:	2010      	movs	r0, #16
 800119a:	f6c0 0660 	movt	r6, #2144	; 0x860
 800119e:	f6c0 4190 	movt	r1, #3216	; 0xc90
 80011a2:	2a01      	cmp	r2, #1
 80011a4:	bf18      	it	ne
 80011a6:	429a      	cmpne	r2, r3
 80011a8:	f2c1 00c0 	movt	r0, #4288	; 0x10c0
 80011ac:	bf14      	ite	ne
 80011ae:	2301      	movne	r3, #1
 80011b0:	2300      	moveq	r3, #0
 80011b2:	42b2      	cmp	r2, r6
 80011b4:	bf0c      	ite	eq
 80011b6:	2300      	moveq	r3, #0
 80011b8:	f003 0301 	andne.w	r3, r3, #1
 80011bc:	2640      	movs	r6, #64	; 0x40
 80011be:	428a      	cmp	r2, r1
 80011c0:	bf0c      	ite	eq
 80011c2:	2300      	moveq	r3, #0
 80011c4:	f003 0301 	andne.w	r3, r3, #1
 80011c8:	2120      	movs	r1, #32
 80011ca:	f6c1 1620 	movt	r6, #6432	; 0x1920
 80011ce:	4282      	cmp	r2, r0
 80011d0:	bf0c      	ite	eq
 80011d2:	2300      	moveq	r3, #0
 80011d4:	f003 0301 	andne.w	r3, r3, #1
 80011d8:	f2c1 41f0 	movt	r1, #5360	; 0x14f0
 80011dc:	f44f 7080 	mov.w	r0, #256	; 0x100
 80011e0:	428a      	cmp	r2, r1
 80011e2:	bf0c      	ite	eq
 80011e4:	2300      	moveq	r3, #0
 80011e6:	f003 0301 	andne.w	r3, r3, #1
 80011ea:	2180      	movs	r1, #128	; 0x80
 80011ec:	f2c2 1080 	movt	r0, #8576	; 0x2180
 80011f0:	42b2      	cmp	r2, r6
 80011f2:	bf0c      	ite	eq
 80011f4:	2300      	moveq	r3, #0
 80011f6:	f003 0301 	andne.w	r3, r3, #1
 80011fa:	f6c1 5150 	movt	r1, #7504	; 0x1d50
 80011fe:	f44f 6680 	mov.w	r6, #1024	; 0x400
 8001202:	428a      	cmp	r2, r1
 8001204:	bf0c      	ite	eq
 8001206:	2300      	moveq	r3, #0
 8001208:	f003 0301 	andne.w	r3, r3, #1
 800120c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8001210:	f6c2 2600 	movt	r6, #10752	; 0x2a00
 8001214:	4282      	cmp	r2, r0
 8001216:	bf0c      	ite	eq
 8001218:	2300      	moveq	r3, #0
 800121a:	f003 0301 	andne.w	r3, r3, #1
 800121e:	f2c2 51b0 	movt	r1, #9648	; 0x25b0
 8001222:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8001226:	428a      	cmp	r2, r1
 8001228:	bf0c      	ite	eq
 800122a:	2300      	moveq	r3, #0
 800122c:	f003 0301 	andne.w	r3, r3, #1
 8001230:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001234:	f2c3 2060 	movt	r0, #12896	; 0x3260
 8001238:	42b2      	cmp	r2, r6
 800123a:	bf0c      	ite	eq
 800123c:	2300      	moveq	r3, #0
 800123e:	f003 0301 	andne.w	r3, r3, #1
 8001242:	f6c2 6130 	movt	r1, #11824	; 0x2e30
 8001246:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800124a:	428a      	cmp	r2, r1
 800124c:	bf0c      	ite	eq
 800124e:	2300      	moveq	r3, #0
 8001250:	f003 0301 	andne.w	r3, r3, #1
 8001254:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001258:	f6c3 26c0 	movt	r6, #15040	; 0x3ac0
 800125c:	4282      	cmp	r2, r0
 800125e:	bf0c      	ite	eq
 8001260:	2300      	moveq	r3, #0
 8001262:	f003 0301 	andne.w	r3, r3, #1
 8001266:	f2c3 6190 	movt	r1, #13968	; 0x3690
 800126a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800126e:	428a      	cmp	r2, r1
 8001270:	bf0c      	ite	eq
 8001272:	2300      	moveq	r3, #0
 8001274:	f003 0301 	andne.w	r3, r3, #1
 8001278:	2100      	movs	r1, #0
 800127a:	f6c3 60f0 	movt	r0, #16112	; 0x3ef0
 800127e:	42b2      	cmp	r2, r6
 8001280:	bf0c      	ite	eq
 8001282:	2300      	moveq	r3, #0
 8001284:	f003 0301 	andne.w	r3, r3, #1
 8001288:	f2c4 3121 	movt	r1, #17185	; 0x4321
 800128c:	4282      	cmp	r2, r0
 800128e:	bf0c      	ite	eq
 8001290:	2300      	moveq	r3, #0
 8001292:	f003 0301 	andne.w	r3, r3, #1
 8001296:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 800129a:	2000      	movs	r0, #0
 800129c:	428a      	cmp	r2, r1
 800129e:	bf0c      	ite	eq
 80012a0:	2300      	moveq	r3, #0
 80012a2:	f003 0301 	andne.w	r3, r3, #1
 80012a6:	4601      	mov	r1, r0
 80012a8:	f2c4 7052 	movt	r0, #18258	; 0x4752
 80012ac:	f6c4 3184 	movt	r1, #19332	; 0x4b84
 80012b0:	4282      	cmp	r2, r0
 80012b2:	bf0c      	ite	eq
 80012b4:	2300      	moveq	r3, #0
 80012b6:	f003 0301 	andne.w	r3, r3, #1
 80012ba:	428a      	cmp	r2, r1
 80012bc:	bf0c      	ite	eq
 80012be:	2300      	moveq	r3, #0
 80012c0:	f003 0301 	andne.w	r3, r3, #1
 80012c4:	2b00      	cmp	r3, #0
 80012c6:	d171      	bne.n	80013ac <HAL_ADC_ConfigChannel+0x2fc>
  __HAL_LOCK(hadc);
 80012c8:	f895 3050 	ldrb.w	r3, [r5, #80]	; 0x50
 80012cc:	2b01      	cmp	r3, #1
 80012ce:	f000 82c8 	beq.w	8001862 <HAL_ADC_ConfigChannel+0x7b2>
 80012d2:	2001      	movs	r0, #1
  if (LL_ADC_REG_IsConversionOngoing(hadc->Instance) == 0UL)
 80012d4:	682a      	ldr	r2, [r5, #0]
  __HAL_LOCK(hadc);
 80012d6:	f885 0050 	strb.w	r0, [r5, #80]	; 0x50
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 80012da:	6893      	ldr	r3, [r2, #8]
 80012dc:	075b      	lsls	r3, r3, #29
 80012de:	d45c      	bmi.n	800139a <HAL_ADC_ConfigChannel+0x2ea>
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 80012e0:	6823      	ldr	r3, [r4, #0]
 80012e2:	f3c3 0113 	ubfx	r1, r3, #0, #20
 80012e6:	2900      	cmp	r1, #0
 80012e8:	f040 81c8 	bne.w	800167c <HAL_ADC_ConfigChannel+0x5cc>
 80012ec:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80012f0:	4098      	lsls	r0, r3
 80012f2:	69d3      	ldr	r3, [r2, #28]
  MODIFY_REG(*preg,
 80012f4:	271f      	movs	r7, #31
 80012f6:	4318      	orrs	r0, r3
 80012f8:	61d0      	str	r0, [r2, #28]
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 80012fa:	6862      	ldr	r2, [r4, #4]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 80012fc:	6829      	ldr	r1, [r5, #0]
 80012fe:	0990      	lsrs	r0, r2, #6
  MODIFY_REG(*preg,
 8001300:	6823      	ldr	r3, [r4, #0]
 8001302:	403a      	ands	r2, r7
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, ((Rank & ADC_REG_SQRX_REGOFFSET_MASK) >> ADC_SQRX_REGOFFSET_POS));
 8001304:	3130      	adds	r1, #48	; 0x30
 8001306:	f000 000c 	and.w	r0, r0, #12
  MODIFY_REG(*preg,
 800130a:	f3c3 6384 	ubfx	r3, r3, #26, #5
 800130e:	4097      	lsls	r7, r2
 8001310:	5846      	ldr	r6, [r0, r1]
 8001312:	4093      	lsls	r3, r2
 8001314:	ea26 0207 	bic.w	r2, r6, r7
 8001318:	4313      	orrs	r3, r2
 800131a:	5043      	str	r3, [r0, r1]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 800131c:	682b      	ldr	r3, [r5, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800131e:	689a      	ldr	r2, [r3, #8]
 8001320:	0757      	lsls	r7, r2, #29
 8001322:	f100 81a9 	bmi.w	8001678 <HAL_ADC_ConfigChannel+0x5c8>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001326:	689e      	ldr	r6, [r3, #8]
 8001328:	f016 0608 	ands.w	r6, r6, #8
 800132c:	f000 8129 	beq.w	8001582 <HAL_ADC_ConfigChannel+0x4d2>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001330:	689a      	ldr	r2, [r3, #8]
 8001332:	07d6      	lsls	r6, r2, #31
 8001334:	d41d      	bmi.n	8001372 <HAL_ADC_ConfigChannel+0x2c2>
  MODIFY_REG(ADCx->DIFSEL,
 8001336:	68e1      	ldr	r1, [r4, #12]
 8001338:	f64f 72ff 	movw	r2, #65535	; 0xffff
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 800133c:	6826      	ldr	r6, [r4, #0]
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 800133e:	2000      	movs	r0, #0
 8001340:	f001 0118 	and.w	r1, r1, #24
 8001344:	f2c0 020f 	movt	r2, #15
 8001348:	f3c6 0713 	ubfx	r7, r6, #0, #20
 800134c:	f2c4 70ff 	movt	r0, #18431	; 0x47ff
 8001350:	40ca      	lsrs	r2, r1
 8001352:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
 8001356:	4032      	ands	r2, r6
 8001358:	ea21 0107 	bic.w	r1, r1, r7
 800135c:	430a      	orrs	r2, r1
 800135e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 8001362:	68e3      	ldr	r3, [r4, #12]
 8001364:	4283      	cmp	r3, r0
 8001366:	f000 823d 	beq.w	80017e4 <HAL_ADC_ConfigChannel+0x734>
      if(__LL_ADC_IS_CHANNEL_INTERNAL(sConfig->Channel))
 800136a:	6822      	ldr	r2, [r4, #0]
 800136c:	2a00      	cmp	r2, #0
 800136e:	f2c0 81e9 	blt.w	8001744 <HAL_ADC_ConfigChannel+0x694>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001372:	2000      	movs	r0, #0
 8001374:	e015      	b.n	80013a2 <HAL_ADC_ConfigChannel+0x2f2>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 8001376:	f241 0201 	movw	r2, #4097	; 0x1001
 800137a:	f2c0 1204 	movt	r2, #260	; 0x104
 800137e:	40ca      	lsrs	r2, r1
 8001380:	43d2      	mvns	r2, r2
 8001382:	f002 0201 	and.w	r2, r2, #1
 8001386:	e6c5      	b.n	8001114 <HAL_ADC_ConfigChannel+0x64>
 8001388:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800138c:	f2c0 1304 	movt	r3, #260	; 0x104
 8001390:	40cb      	lsrs	r3, r1
 8001392:	43db      	mvns	r3, r3
 8001394:	f003 0301 	and.w	r3, r3, #1
 8001398:	e6b0      	b.n	80010fc <HAL_ADC_ConfigChannel+0x4c>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800139a:	6d6b      	ldr	r3, [r5, #84]	; 0x54
 800139c:	f043 0320 	orr.w	r3, r3, #32
 80013a0:	656b      	str	r3, [r5, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 80013a2:	2300      	movs	r3, #0
 80013a4:	f885 3050 	strb.w	r3, [r5, #80]	; 0x50
}
 80013a8:	b003      	add	sp, #12
 80013aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_CHANNEL(sConfig->Channel));
 80013ac:	2300      	movs	r3, #0
 80013ae:	f6c4 73b8 	movt	r3, #20408	; 0x4fb8
 80013b2:	429a      	cmp	r2, r3
 80013b4:	d088      	beq.n	80012c8 <HAL_ADC_ConfigChannel+0x218>
 80013b6:	f64d 1048 	movw	r0, #55624	; 0xd948
 80013ba:	f640 2174 	movw	r1, #2676	; 0xa74
 80013be:	f6c0 0002 	movt	r0, #2050	; 0x802
 80013c2:	f014 fa51 	bl	8015868 <assert_failed>
 80013c6:	e77f      	b.n	80012c8 <HAL_ADC_ConfigChannel+0x218>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(sConfig->SingleDiff));
 80013c8:	f64d 1048 	movw	r0, #55624	; 0xd948
 80013cc:	f640 2161 	movw	r1, #2657	; 0xa61
 80013d0:	f6c0 0002 	movt	r0, #2050	; 0x802
 80013d4:	f014 fa48 	bl	8015868 <assert_failed>
  assert_param(IS_ADC_OFFSET_NUMBER(sConfig->OffsetNumber));
 80013d8:	6923      	ldr	r3, [r4, #16]
 80013da:	2b04      	cmp	r3, #4
 80013dc:	f67f aeb3 	bls.w	8001146 <HAL_ADC_ConfigChannel+0x96>
 80013e0:	f64d 1048 	movw	r0, #55624	; 0xd948
 80013e4:	f640 2162 	movw	r1, #2658	; 0xa62
 80013e8:	f6c0 0002 	movt	r0, #2050	; 0x802
 80013ec:	f014 fa3c 	bl	8015868 <assert_failed>
  if (hadc->Init.OversamplingMode == ENABLE)
 80013f0:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 80013f4:	6961      	ldr	r1, [r4, #20]
 80013f6:	2b01      	cmp	r3, #1
 80013f8:	682a      	ldr	r2, [r5, #0]
 80013fa:	f47f aeab 	bne.w	8001154 <HAL_ADC_ConfigChannel+0xa4>
  if((DBGMCU->IDCODE & 0x30000000UL) == 0x10000000UL) /* Rev.Y */
 80013fe:	f44f 5680 	mov.w	r6, #4096	; 0x1000
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
 8001402:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8001404:	f6c5 4600 	movt	r6, #23552	; 0x5c00
 8001408:	1c58      	adds	r0, r3, #1
 800140a:	6833      	ldr	r3, [r6, #0]
 800140c:	f003 5340 	and.w	r3, r3, #805306368	; 0x30000000
 8001410:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8001414:	fbb1 f1f0 	udiv	r1, r1, r0
 8001418:	f040 8138 	bne.w	800168c <HAL_ADC_ConfigChannel+0x5dc>
      return (uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES));
 800141c:	68d2      	ldr	r2, [r2, #12]
 800141e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8001422:	0852      	lsrs	r2, r2, #1
 8001424:	f002 020e 	and.w	r2, r2, #14
 8001428:	40d3      	lsrs	r3, r2
 800142a:	4299      	cmp	r1, r3
 800142c:	f200 821c 	bhi.w	8001868 <HAL_ADC_ConfigChannel+0x7b8>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
 8001430:	6923      	ldr	r3, [r4, #16]
 8001432:	2b04      	cmp	r3, #4
 8001434:	f43f aea3 	beq.w	800117e <HAL_ADC_ConfigChannel+0xce>
 8001438:	f64d 1048 	movw	r0, #55624	; 0xd948
 800143c:	f640 216f 	movw	r1, #2671	; 0xa6f
 8001440:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001444:	f014 fa10 	bl	8015868 <assert_failed>
  if (sConfig->SingleDiff != ADC_DIFFERENTIAL_ENDED)
 8001448:	2300      	movs	r3, #0
 800144a:	68e2      	ldr	r2, [r4, #12]
 800144c:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
 8001450:	429a      	cmp	r2, r3
 8001452:	f47f ae9b 	bne.w	800118c <HAL_ADC_ConfigChannel+0xdc>
    if (hadc->Instance == ADC1)
 8001456:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800145a:	682b      	ldr	r3, [r5, #0]
 800145c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001460:	4293      	cmp	r3, r2
 8001462:	f000 820a 	beq.w	800187a <HAL_ADC_ConfigChannel+0x7ca>
    if (hadc->Instance == ADC2)
 8001466:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 800146a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800146e:	4293      	cmp	r3, r2
 8001470:	f000 8114 	beq.w	800169c <HAL_ADC_ConfigChannel+0x5ec>
    if (hadc->Instance == ADC3)
 8001474:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8001478:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800147c:	4293      	cmp	r3, r2
 800147e:	f47f af23 	bne.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
      assert_param(IS_ADC3_DIFF_CHANNEL(sConfig->Channel));
 8001482:	2302      	movs	r3, #2
 8001484:	2104      	movs	r1, #4
 8001486:	6822      	ldr	r2, [r4, #0]
 8001488:	2008      	movs	r0, #8
 800148a:	f2c0 4330 	movt	r3, #1072	; 0x430
 800148e:	f6c0 0160 	movt	r1, #2144	; 0x860
 8001492:	f6c0 4090 	movt	r0, #3216	; 0xc90
 8001496:	2620      	movs	r6, #32
 8001498:	429a      	cmp	r2, r3
 800149a:	bf18      	it	ne
 800149c:	428a      	cmpne	r2, r1
 800149e:	f04f 0110 	mov.w	r1, #16
 80014a2:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
 80014a6:	bf14      	ite	ne
 80014a8:	2301      	movne	r3, #1
 80014aa:	2300      	moveq	r3, #0
 80014ac:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
 80014b0:	4282      	cmp	r2, r0
 80014b2:	bf0c      	ite	eq
 80014b4:	2300      	moveq	r3, #0
 80014b6:	f003 0301 	andne.w	r3, r3, #1
 80014ba:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80014be:	428a      	cmp	r2, r1
 80014c0:	bf0c      	ite	eq
 80014c2:	2300      	moveq	r3, #0
 80014c4:	f003 0301 	andne.w	r3, r3, #1
 80014c8:	f6c2 2000 	movt	r0, #10752	; 0x2a00
 80014cc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80014d0:	42b2      	cmp	r2, r6
 80014d2:	bf0c      	ite	eq
 80014d4:	2300      	moveq	r3, #0
 80014d6:	f003 0301 	andne.w	r3, r3, #1
 80014da:	f6c2 6130 	movt	r1, #11824	; 0x2e30
 80014de:	4282      	cmp	r2, r0
 80014e0:	bf0c      	ite	eq
 80014e2:	2300      	moveq	r3, #0
 80014e4:	f003 0301 	andne.w	r3, r3, #1
 80014e8:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80014ec:	428a      	cmp	r2, r1
 80014ee:	bf0c      	ite	eq
 80014f0:	2300      	moveq	r3, #0
 80014f2:	f003 0301 	andne.w	r3, r3, #1
 80014f6:	f2c3 6090 	movt	r0, #13968	; 0x3690
 80014fa:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80014fe:	4282      	cmp	r2, r0
 8001500:	bf0c      	ite	eq
 8001502:	2300      	moveq	r3, #0
 8001504:	f003 0301 	andne.w	r3, r3, #1
 8001508:	f6c3 21c0 	movt	r1, #15040	; 0x3ac0
 800150c:	428a      	cmp	r2, r1
 800150e:	bf0c      	ite	eq
 8001510:	2300      	moveq	r3, #0
 8001512:	f003 0301 	andne.w	r3, r3, #1
 8001516:	2b00      	cmp	r3, #0
 8001518:	f43f aed6 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 800151c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8001520:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
 8001524:	429a      	cmp	r2, r3
 8001526:	f43f aecf 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 800152a:	f64d 1048 	movw	r0, #55624	; 0xd948
 800152e:	f640 2184 	movw	r1, #2692	; 0xa84
 8001532:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001536:	f014 f997 	bl	8015868 <assert_failed>
 800153a:	e6c5      	b.n	80012c8 <HAL_ADC_ConfigChannel+0x218>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
 800153c:	68d3      	ldr	r3, [r2, #12]
 800153e:	f003 031c 	and.w	r3, r3, #28
 8001542:	2b1c      	cmp	r3, #28
 8001544:	f47f ae11 	bne.w	800116a <HAL_ADC_ConfigChannel+0xba>
 8001548:	23ff      	movs	r3, #255	; 0xff
 800154a:	e615      	b.n	8001178 <HAL_ADC_ConfigChannel+0xc8>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 800154c:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001550:	f640 215e 	movw	r1, #2654	; 0xa5e
 8001554:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001558:	f014 f986 	bl	8015868 <assert_failed>
 800155c:	e5c2      	b.n	80010e4 <HAL_ADC_ConfigChannel+0x34>
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset));
 800155e:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001562:	f640 216a 	movw	r1, #2666	; 0xa6a
 8001566:	f6c0 0002 	movt	r0, #2050	; 0x802
 800156a:	f014 f97d 	bl	8015868 <assert_failed>
  assert_param(!((sConfig->OffsetNumber != ADC_OFFSET_NONE) && (hadc->Init.OversamplingMode == ENABLE)));
 800156e:	6923      	ldr	r3, [r4, #16]
 8001570:	2b04      	cmp	r3, #4
 8001572:	f43f ae04 	beq.w	800117e <HAL_ADC_ConfigChannel+0xce>
 8001576:	f895 3038 	ldrb.w	r3, [r5, #56]	; 0x38
 800157a:	2b01      	cmp	r3, #1
 800157c:	f47f adff 	bne.w	800117e <HAL_ADC_ConfigChannel+0xce>
 8001580:	e75a      	b.n	8001438 <HAL_ADC_ConfigChannel+0x388>
      LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 8001582:	6821      	ldr	r1, [r4, #0]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8001584:	3314      	adds	r3, #20
  MODIFY_REG(*preg,
 8001586:	2207      	movs	r2, #7
 8001588:	68a7      	ldr	r7, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800158a:	0dc8      	lsrs	r0, r1, #23
  MODIFY_REG(*preg,
 800158c:	f3c1 5104 	ubfx	r1, r1, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8001590:	f000 0004 	and.w	r0, r0, #4
  MODIFY_REG(*preg,
 8001594:	fa02 fc01 	lsl.w	ip, r2, r1
 8001598:	fa07 f101 	lsl.w	r1, r7, r1
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800159c:	f44f 5780 	mov.w	r7, #4096	; 0x1000
 80015a0:	58c2      	ldr	r2, [r0, r3]
 80015a2:	f6c5 4700 	movt	r7, #23552	; 0x5c00
 80015a6:	ea22 020c 	bic.w	r2, r2, ip
 80015aa:	430a      	orrs	r2, r1
 80015ac:	50c2      	str	r2, [r0, r3]
 80015ae:	683b      	ldr	r3, [r7, #0]
 80015b0:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 80015b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 80015b8:	f000 810b 	beq.w	80017d2 <HAL_ADC_ConfigChannel+0x722>
 80015bc:	682b      	ldr	r3, [r5, #0]
 80015be:	6962      	ldr	r2, [r4, #20]
 80015c0:	68d9      	ldr	r1, [r3, #12]
 80015c2:	f011 0f10 	tst.w	r1, #16
 80015c6:	68d9      	ldr	r1, [r3, #12]
 80015c8:	f040 81cf 	bne.w	800196a <HAL_ADC_ConfigChannel+0x8ba>
 80015cc:	f3c1 0182 	ubfx	r1, r1, #2, #3
 80015d0:	0049      	lsls	r1, r1, #1
 80015d2:	fa02 f101 	lsl.w	r1, r2, r1
      if (sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80015d6:	6920      	ldr	r0, [r4, #16]
 80015d8:	6822      	ldr	r2, [r4, #0]
 80015da:	2804      	cmp	r0, #4
 80015dc:	f000 81a9 	beq.w	8001932 <HAL_ADC_ConfigChannel+0x882>
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80015e0:	3360      	adds	r3, #96	; 0x60
  MODIFY_REG(*preg,
 80015e2:	f002 42f8 	and.w	r2, r2, #2080374784	; 0x7c000000
 80015e6:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 80015ea:	430a      	orrs	r2, r1
 80015ec:	f007 4100 	and.w	r1, r7, #2147483648	; 0x80000000
 80015f0:	430a      	orrs	r2, r1
 80015f2:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetSignedSaturation));
 80015f6:	7e63      	ldrb	r3, [r4, #25]
 80015f8:	2b01      	cmp	r3, #1
 80015fa:	d908      	bls.n	800160e <HAL_ADC_ConfigChannel+0x55e>
 80015fc:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001600:	f640 21b2 	movw	r1, #2738	; 0xab2
 8001604:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001608:	f014 f92e 	bl	8015868 <assert_failed>
 800160c:	7e63      	ldrb	r3, [r4, #25]
        LL_ADC_SetOffsetSignedSaturation(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetSignedSaturation == ENABLE) ? LL_ADC_OFFSET_SIGNED_SATURATION_ENABLE : LL_ADC_OFFSET_SIGNED_SATURATION_DISABLE);
 800160e:	682a      	ldr	r2, [r5, #0]
 8001610:	2b01      	cmp	r3, #1
 8001612:	6921      	ldr	r1, [r4, #16]
   register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 8001614:	f102 0260 	add.w	r2, r2, #96	; 0x60
 8001618:	bf14      	ite	ne
 800161a:	2000      	movne	r0, #0
 800161c:	f04f 4000 	moveq.w	r0, #2147483648	; 0x80000000
   MODIFY_REG(*preg, ADC_OFR1_SSATE, OffsetSignedSaturation);
 8001620:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 8001624:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001628:	4303      	orrs	r3, r0
 800162a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
        assert_param(IS_FUNCTIONAL_STATE(sConfig->OffsetRightShift));
 800162e:	7e23      	ldrb	r3, [r4, #24]
 8001630:	2b01      	cmp	r3, #1
 8001632:	d908      	bls.n	8001646 <HAL_ADC_ConfigChannel+0x596>
 8001634:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001638:	f640 21b6 	movw	r1, #2742	; 0xab6
 800163c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001640:	f014 f912 	bl	8015868 <assert_failed>
 8001644:	7e23      	ldrb	r3, [r4, #24]
        LL_ADC_SetDataRightShift(hadc->Instance, sConfig->OffsetNumber, (sConfig->OffsetRightShift == ENABLE) ? LL_ADC_OFFSET_RSHIFT_ENABLE : LL_ADC_OFFSET_RSHIFT_DISABLE);
 8001646:	2b01      	cmp	r3, #1
 8001648:	682a      	ldr	r2, [r5, #0]
 800164a:	6921      	ldr	r1, [r4, #16]
 800164c:	d104      	bne.n	8001658 <HAL_ADC_ConfigChannel+0x5a8>
 800164e:	f001 011f 	and.w	r1, r1, #31
 8001652:	f44f 6600 	mov.w	r6, #2048	; 0x800
 8001656:	408e      	lsls	r6, r1
  MODIFY_REG(ADCx->CFGR2, (ADC_CFGR2_RSHIFT1 | ADC_CFGR2_RSHIFT2 | ADC_CFGR2_RSHIFT3 | ADC_CFGR2_RSHIFT4), RigthShift << (Offsety & 0x1FUL));
 8001658:	6913      	ldr	r3, [r2, #16]
 800165a:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
 800165e:	431e      	orrs	r6, r3
 8001660:	6116      	str	r6, [r2, #16]
 8001662:	682b      	ldr	r3, [r5, #0]
 8001664:	e664      	b.n	8001330 <HAL_ADC_ConfigChannel+0x280>
  assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
 8001666:	f64d 1048 	movw	r0, #55624	; 0xd948
 800166a:	f44f 6126 	mov.w	r1, #2656	; 0xa60
 800166e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001672:	f014 f8f9 	bl	8015868 <assert_failed>
 8001676:	e557      	b.n	8001128 <HAL_ADC_ConfigChannel+0x78>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8001678:	689a      	ldr	r2, [r3, #8]
 800167a:	e659      	b.n	8001330 <HAL_ADC_ConfigChannel+0x280>
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800167c:	fa93 f3a3 	rbit	r3, r3
    hadc->Instance->PCSEL |= (1UL << (__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) & 0x1FUL));
 8001680:	fab3 f383 	clz	r3, r3
 8001684:	f003 031f 	and.w	r3, r3, #31
 8001688:	4098      	lsls	r0, r3
 800168a:	e632      	b.n	80012f2 <HAL_ADC_ConfigChannel+0x242>
    if ((uint32_t)(READ_BIT(ADCx->CFGR, ADC_CFGR_RES)) == 0x0000001CUL)
 800168c:	68d3      	ldr	r3, [r2, #12]
 800168e:	f003 031c 	and.w	r3, r3, #28
 8001692:	2b1c      	cmp	r3, #28
 8001694:	f47f aec2 	bne.w	800141c <HAL_ADC_ConfigChannel+0x36c>
 8001698:	23ff      	movs	r3, #255	; 0xff
 800169a:	e6c6      	b.n	800142a <HAL_ADC_ConfigChannel+0x37a>
      assert_param(IS_ADC2_DIFF_CHANNEL(sConfig->Channel));
 800169c:	2302      	movs	r3, #2
 800169e:	2104      	movs	r1, #4
 80016a0:	6822      	ldr	r2, [r4, #0]
 80016a2:	2008      	movs	r0, #8
 80016a4:	f2c0 4330 	movt	r3, #1072	; 0x430
 80016a8:	f6c0 0160 	movt	r1, #2144	; 0x860
 80016ac:	f6c0 4090 	movt	r0, #3216	; 0xc90
 80016b0:	2620      	movs	r6, #32
 80016b2:	429a      	cmp	r2, r3
 80016b4:	bf18      	it	ne
 80016b6:	428a      	cmpne	r2, r1
 80016b8:	f04f 0110 	mov.w	r1, #16
 80016bc:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
 80016c0:	bf14      	ite	ne
 80016c2:	2301      	movne	r3, #1
 80016c4:	2300      	moveq	r3, #0
 80016c6:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
 80016ca:	4282      	cmp	r2, r0
 80016cc:	bf0c      	ite	eq
 80016ce:	2300      	moveq	r3, #0
 80016d0:	f003 0301 	andne.w	r3, r3, #1
 80016d4:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80016d8:	428a      	cmp	r2, r1
 80016da:	bf0c      	ite	eq
 80016dc:	2300      	moveq	r3, #0
 80016de:	f003 0301 	andne.w	r3, r3, #1
 80016e2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80016e6:	f6c2 6030 	movt	r0, #11824	; 0x2e30
 80016ea:	f6c2 2100 	movt	r1, #10752	; 0x2a00
 80016ee:	42b2      	cmp	r2, r6
 80016f0:	bf0c      	ite	eq
 80016f2:	2300      	moveq	r3, #0
 80016f4:	f003 0301 	andne.w	r3, r3, #1
 80016f8:	428a      	cmp	r2, r1
 80016fa:	bf0c      	ite	eq
 80016fc:	2300      	moveq	r3, #0
 80016fe:	f003 0301 	andne.w	r3, r3, #1
 8001702:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8001706:	4282      	cmp	r2, r0
 8001708:	bf0c      	ite	eq
 800170a:	2300      	moveq	r3, #0
 800170c:	f003 0301 	andne.w	r3, r3, #1
 8001710:	f2c3 2160 	movt	r1, #12896	; 0x3260
 8001714:	428a      	cmp	r2, r1
 8001716:	bf0c      	ite	eq
 8001718:	2300      	moveq	r3, #0
 800171a:	f003 0301 	andne.w	r3, r3, #1
 800171e:	2b00      	cmp	r3, #0
 8001720:	f43f add2 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 8001724:	2300      	movs	r3, #0
 8001726:	f6c4 3384 	movt	r3, #19332	; 0x4b84
 800172a:	429a      	cmp	r2, r3
 800172c:	f43f adcc 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 8001730:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001734:	f640 217e 	movw	r1, #2686	; 0xa7e
 8001738:	f6c0 0002 	movt	r0, #2050	; 0x802
 800173c:	f014 f894 	bl	8015868 <assert_failed>
 8001740:	682b      	ldr	r3, [r5, #0]
 8001742:	e697      	b.n	8001474 <HAL_ADC_ConfigChannel+0x3c4>
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 8001744:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001748:	6828      	ldr	r0, [r5, #0]
 800174a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800174e:	4298      	cmp	r0, r3
 8001750:	f000 813e 	beq.w	80019d0 <HAL_ADC_ConfigChannel+0x920>
 8001754:	f44f 5304 	mov.w	r3, #8448	; 0x2100
 8001758:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800175c:	4298      	cmp	r0, r3
 800175e:	f000 8137 	beq.w	80019d0 <HAL_ADC_ConfigChannel+0x920>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001762:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001766:	f44f 46c0 	mov.w	r6, #24576	; 0x6000
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800176a:	f6c5 0302 	movt	r3, #22530	; 0x5802
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800176e:	f6c5 0602 	movt	r6, #22530	; 0x5802
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001772:	689c      	ldr	r4, [r3, #8]
 8001774:	4619      	mov	r1, r3
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001776:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001778:	f004 76e0 	and.w	r6, r4, #29360128	; 0x1c00000
 800177c:	43db      	mvns	r3, r3
 800177e:	f003 0301 	and.w	r3, r3, #1
        if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8001782:	2b00      	cmp	r3, #0
 8001784:	f000 8145 	beq.w	8001a12 <HAL_ADC_ConfigChannel+0x962>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8001788:	2300      	movs	r3, #0
 800178a:	f6cc 3384 	movt	r3, #52100	; 0xcb84
 800178e:	429a      	cmp	r2, r3
 8001790:	f000 8162 	beq.w	8001a58 <HAL_ADC_ConfigChannel+0x9a8>
          else if ((sConfig->Channel == ADC_CHANNEL_VBAT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VBAT) == 0UL))
 8001794:	2300      	movs	r3, #0
 8001796:	f2cc 7352 	movt	r3, #51026	; 0xc752
 800179a:	429a      	cmp	r2, r3
 800179c:	f000 8187 	beq.w	8001aae <HAL_ADC_ConfigChannel+0x9fe>
          else if ((sConfig->Channel == ADC_CHANNEL_VREFINT) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_VREFINT) == 0UL))
 80017a0:	2300      	movs	r3, #0
 80017a2:	f6cc 73b8 	movt	r3, #53176	; 0xcfb8
 80017a6:	429a      	cmp	r2, r3
 80017a8:	f47f ade3 	bne.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_VREFINT_INSTANCE(hadc))
 80017ac:	0263      	lsls	r3, r4, #9
 80017ae:	f53f ade0 	bmi.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
 80017b2:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80017b6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80017ba:	4298      	cmp	r0, r3
 80017bc:	f47f add9 	bne.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80017c0:	688a      	ldr	r2, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VREFINT | tmp_config_internal_channel);
 80017c2:	f446 0380 	orr.w	r3, r6, #4194304	; 0x400000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80017c6:	2000      	movs	r0, #0
 80017c8:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 80017cc:	4313      	orrs	r3, r2
 80017ce:	608b      	str	r3, [r1, #8]
 80017d0:	e5e7      	b.n	80013a2 <HAL_ADC_ConfigChannel+0x2f2>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 80017d2:	682b      	ldr	r3, [r5, #0]
 80017d4:	6962      	ldr	r2, [r4, #20]
 80017d6:	68d9      	ldr	r1, [r3, #12]
 80017d8:	f3c1 0182 	ubfx	r1, r1, #2, #3
 80017dc:	0049      	lsls	r1, r1, #1
 80017de:	fa02 f101 	lsl.w	r1, r2, r1
 80017e2:	e6f8      	b.n	80015d6 <HAL_ADC_ConfigChannel+0x526>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80017e4:	6822      	ldr	r2, [r4, #0]
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 80017e6:	6829      	ldr	r1, [r5, #0]
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 80017e8:	f3c2 0313 	ubfx	r3, r2, #0, #20
 80017ec:	2b00      	cmp	r3, #0
 80017ee:	f000 80c2 	beq.w	8001976 <HAL_ADC_ConfigChannel+0x8c6>
 80017f2:	fa92 f3a2 	rbit	r3, r2
 80017f6:	fab3 f383 	clz	r3, r3
 80017fa:	3301      	adds	r3, #1
 80017fc:	f003 031f 	and.w	r3, r3, #31
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8001800:	2b09      	cmp	r3, #9
 8001802:	f200 810c 	bhi.w	8001a1e <HAL_ADC_ConfigChannel+0x96e>
 8001806:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 800180a:	fab3 f383 	clz	r3, r3
 800180e:	fa92 f0a2 	rbit	r0, r2
 8001812:	2601      	movs	r6, #1
 8001814:	fab0 f080 	clz	r0, r0
 8001818:	3301      	adds	r3, #1
 800181a:	4430      	add	r0, r6
 800181c:	069b      	lsls	r3, r3, #26
 800181e:	f000 001f 	and.w	r0, r0, #31
 8001822:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 8001826:	fa06 f000 	lsl.w	r0, r6, r0
 800182a:	4303      	orrs	r3, r0
 800182c:	fa92 f2a2 	rbit	r2, r2
 8001830:	fab2 f282 	clz	r2, r2
 8001834:	4432      	add	r2, r6
 8001836:	f002 021f 	and.w	r2, r2, #31
 800183a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800183e:	0512      	lsls	r2, r2, #20
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8001840:	431a      	orrs	r2, r3
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8001842:	3114      	adds	r1, #20
  MODIFY_REG(*preg,
 8001844:	2707      	movs	r7, #7
 8001846:	68a3      	ldr	r3, [r4, #8]
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 8001848:	0dd6      	lsrs	r6, r2, #23
  MODIFY_REG(*preg,
 800184a:	f3c2 5204 	ubfx	r2, r2, #20, #5
  register __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, ((Channel & ADC_CHANNEL_SMPRX_REGOFFSET_MASK) >> ADC_SMPRX_REGOFFSET_POS));
 800184e:	f006 0604 	and.w	r6, r6, #4
  MODIFY_REG(*preg,
 8001852:	4097      	lsls	r7, r2
 8001854:	4093      	lsls	r3, r2
 8001856:	5870      	ldr	r0, [r6, r1]
 8001858:	ea20 0207 	bic.w	r2, r0, r7
 800185c:	431a      	orrs	r2, r3
 800185e:	5072      	str	r2, [r6, r1]
 8001860:	e583      	b.n	800136a <HAL_ADC_ConfigChannel+0x2ba>
  __HAL_LOCK(hadc);
 8001862:	2002      	movs	r0, #2
}
 8001864:	b003      	add	sp, #12
 8001866:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_RANGE(ADC_GET_RESOLUTION(hadc), sConfig->Offset/(hadc->Init.Oversampling.Ratio+1U)));
 8001868:	f64d 1048 	movw	r0, #55624	; 0xd948
 800186c:	f640 2166 	movw	r1, #2662	; 0xa66
 8001870:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001874:	f013 fff8 	bl	8015868 <assert_failed>
 8001878:	e679      	b.n	800156e <HAL_ADC_ConfigChannel+0x4be>
      assert_param(IS_ADC1_DIFF_CHANNEL(sConfig->Channel));
 800187a:	2302      	movs	r3, #2
 800187c:	2104      	movs	r1, #4
 800187e:	6822      	ldr	r2, [r4, #0]
 8001880:	2008      	movs	r0, #8
 8001882:	f2c0 4330 	movt	r3, #1072	; 0x430
 8001886:	f6c0 0160 	movt	r1, #2144	; 0x860
 800188a:	f6c0 4090 	movt	r0, #3216	; 0xc90
 800188e:	2620      	movs	r6, #32
 8001890:	429a      	cmp	r2, r3
 8001892:	bf18      	it	ne
 8001894:	428a      	cmpne	r2, r1
 8001896:	f04f 0110 	mov.w	r1, #16
 800189a:	f2c1 46f0 	movt	r6, #5360	; 0x14f0
 800189e:	bf14      	ite	ne
 80018a0:	2301      	movne	r3, #1
 80018a2:	2300      	moveq	r3, #0
 80018a4:	f2c1 01c0 	movt	r1, #4288	; 0x10c0
 80018a8:	4282      	cmp	r2, r0
 80018aa:	bf0c      	ite	eq
 80018ac:	2300      	moveq	r3, #0
 80018ae:	f003 0301 	andne.w	r3, r3, #1
 80018b2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80018b6:	428a      	cmp	r2, r1
 80018b8:	bf0c      	ite	eq
 80018ba:	2300      	moveq	r3, #0
 80018bc:	f003 0301 	andne.w	r3, r3, #1
 80018c0:	f6c2 2000 	movt	r0, #10752	; 0x2a00
 80018c4:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80018c8:	42b2      	cmp	r2, r6
 80018ca:	bf0c      	ite	eq
 80018cc:	2300      	moveq	r3, #0
 80018ce:	f003 0301 	andne.w	r3, r3, #1
 80018d2:	f6c2 6130 	movt	r1, #11824	; 0x2e30
 80018d6:	4282      	cmp	r2, r0
 80018d8:	bf0c      	ite	eq
 80018da:	2300      	moveq	r3, #0
 80018dc:	f003 0301 	andne.w	r3, r3, #1
 80018e0:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80018e4:	428a      	cmp	r2, r1
 80018e6:	bf0c      	ite	eq
 80018e8:	2300      	moveq	r3, #0
 80018ea:	f003 0301 	andne.w	r3, r3, #1
 80018ee:	f2c3 2060 	movt	r0, #12896	; 0x3260
 80018f2:	2100      	movs	r1, #0
 80018f4:	4282      	cmp	r2, r0
 80018f6:	bf0c      	ite	eq
 80018f8:	2300      	moveq	r3, #0
 80018fa:	f003 0301 	andne.w	r3, r3, #1
 80018fe:	f2c4 3121 	movt	r1, #17185	; 0x4321
 8001902:	428a      	cmp	r2, r1
 8001904:	bf0c      	ite	eq
 8001906:	2300      	moveq	r3, #0
 8001908:	f003 0301 	andne.w	r3, r3, #1
 800190c:	2b00      	cmp	r3, #0
 800190e:	f43f acdb 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 8001912:	2300      	movs	r3, #0
 8001914:	f6c4 3384 	movt	r3, #19332	; 0x4b84
 8001918:	429a      	cmp	r2, r3
 800191a:	f43f acd5 	beq.w	80012c8 <HAL_ADC_ConfigChannel+0x218>
 800191e:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001922:	f640 217a 	movw	r1, #2682	; 0xa7a
 8001926:	f6c0 0002 	movt	r0, #2050	; 0x802
 800192a:	f013 ff9d 	bl	8015868 <assert_failed>
 800192e:	682b      	ldr	r3, [r5, #0]
 8001930:	e599      	b.n	8001466 <HAL_ADC_ConfigChannel+0x3b6>
          if (((hadc->Instance->OFR1) & ADC_OFR1_OFFSET1_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8001932:	6e19      	ldr	r1, [r3, #96]	; 0x60
 8001934:	0692      	lsls	r2, r2, #26
 8001936:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 800193a:	4291      	cmp	r1, r2
 800193c:	d040      	beq.n	80019c0 <HAL_ADC_ConfigChannel+0x910>
          if (((hadc->Instance->OFR2) & ADC_OFR2_OFFSET2_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 800193e:	6e59      	ldr	r1, [r3, #100]	; 0x64
 8001940:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 8001944:	4291      	cmp	r1, r2
 8001946:	d033      	beq.n	80019b0 <HAL_ADC_ConfigChannel+0x900>
          if (((hadc->Instance->OFR3) & ADC_OFR3_OFFSET3_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8001948:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800194a:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 800194e:	4291      	cmp	r1, r2
 8001950:	d026      	beq.n	80019a0 <HAL_ADC_ConfigChannel+0x8f0>
          if (((hadc->Instance->OFR4) & ADC_OFR4_OFFSET4_CH) == ADC_OFR_CHANNEL(sConfig->Channel))
 8001952:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8001954:	f001 41f8 	and.w	r1, r1, #2080374784	; 0x7c000000
 8001958:	4291      	cmp	r1, r2
 800195a:	f47f ace9 	bne.w	8001330 <HAL_ADC_ConfigChannel+0x280>
            CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_SSATE);
 800195e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8001960:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8001964:	66da      	str	r2, [r3, #108]	; 0x6c
 8001966:	682b      	ldr	r3, [r5, #0]
 8001968:	e4e2      	b.n	8001330 <HAL_ADC_ConfigChannel+0x280>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, (uint32_t)sConfig->Offset);
 800196a:	0849      	lsrs	r1, r1, #1
 800196c:	f001 0108 	and.w	r1, r1, #8
 8001970:	fa02 f101 	lsl.w	r1, r2, r1
 8001974:	e62f      	b.n	80015d6 <HAL_ADC_ConfigChannel+0x526>
 8001976:	2601      	movs	r6, #1
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001978:	0e92      	lsrs	r2, r2, #26
 800197a:	4432      	add	r2, r6
 800197c:	f002 001f 	and.w	r0, r2, #31
 8001980:	0693      	lsls	r3, r2, #26
 8001982:	4086      	lsls	r6, r0
 8001984:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
        LL_ADC_SetChannelSamplingTime(hadc->Instance,
 8001988:	2809      	cmp	r0, #9
 800198a:	eb00 0240 	add.w	r2, r0, r0, lsl #1
 800198e:	ea43 0306 	orr.w	r3, r3, r6
 8001992:	f67f af54 	bls.w	800183e <HAL_ADC_ConfigChannel+0x78e>
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001996:	3a1e      	subs	r2, #30
 8001998:	0512      	lsls	r2, r2, #20
 800199a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800199e:	e74f      	b.n	8001840 <HAL_ADC_ConfigChannel+0x790>
            CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_SSATE);
 80019a0:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 80019a2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80019a6:	669a      	str	r2, [r3, #104]	; 0x68
 80019a8:	6822      	ldr	r2, [r4, #0]
 80019aa:	682b      	ldr	r3, [r5, #0]
 80019ac:	0692      	lsls	r2, r2, #26
 80019ae:	e7d0      	b.n	8001952 <HAL_ADC_ConfigChannel+0x8a2>
            CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_SSATE);
 80019b0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80019b2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80019b6:	665a      	str	r2, [r3, #100]	; 0x64
 80019b8:	6822      	ldr	r2, [r4, #0]
 80019ba:	682b      	ldr	r3, [r5, #0]
 80019bc:	0692      	lsls	r2, r2, #26
 80019be:	e7c3      	b.n	8001948 <HAL_ADC_ConfigChannel+0x898>
            CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_SSATE);
 80019c0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80019c2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 80019c6:	661a      	str	r2, [r3, #96]	; 0x60
 80019c8:	6822      	ldr	r2, [r4, #0]
 80019ca:	682b      	ldr	r3, [r5, #0]
 80019cc:	0692      	lsls	r2, r2, #26
 80019ce:	e7b6      	b.n	800193e <HAL_ADC_ConfigChannel+0x88e>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80019d0:	f44f 530c 	mov.w	r3, #8960	; 0x2300
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80019d4:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 80019d8:	f44f 5604 	mov.w	r6, #8448	; 0x2100
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80019dc:	f2c4 0302 	movt	r3, #16386	; 0x4002
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80019e0:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80019e4:	f2c4 0602 	movt	r6, #16386	; 0x4002
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80019e8:	689c      	ldr	r4, [r3, #8]
        tmp_config_internal_channel = LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance));
 80019ea:	4619      	mov	r1, r3
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 80019ec:	68bf      	ldr	r7, [r7, #8]
 80019ee:	68b3      	ldr	r3, [r6, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80019f0:	f004 76e0 	and.w	r6, r4, #29360128	; 0x1c00000
 80019f4:	433b      	orrs	r3, r7
 80019f6:	43db      	mvns	r3, r3
 80019f8:	f003 0301 	and.w	r3, r3, #1
 80019fc:	e6c1      	b.n	8001782 <HAL_ADC_ConfigChannel+0x6d2>
  assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
 80019fe:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001a02:	f640 215f 	movw	r1, #2655	; 0xa5f
 8001a06:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001a0a:	f013 ff2d 	bl	8015868 <assert_failed>
 8001a0e:	f7ff bb87 	b.w	8001120 <HAL_ADC_ConfigChannel+0x70>
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001a12:	6d6b      	ldr	r3, [r5, #84]	; 0x54
          tmp_hal_status = HAL_ERROR;
 8001a14:	2001      	movs	r0, #1
          SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001a16:	f043 0320 	orr.w	r3, r3, #32
 8001a1a:	656b      	str	r3, [r5, #84]	; 0x54
 8001a1c:	e4c1      	b.n	80013a2 <HAL_ADC_ConfigChannel+0x2f2>
 8001a1e:	fa92 f3a2 	rbit	r3, r2
                                      (uint32_t)(__LL_ADC_DECIMAL_NB_TO_CHANNEL((__LL_ADC_CHANNEL_TO_DECIMAL_NB((uint32_t)sConfig->Channel) + 1UL) & 0x1FUL)),
 8001a22:	fab3 f383 	clz	r3, r3
 8001a26:	fa92 f0a2 	rbit	r0, r2
 8001a2a:	2601      	movs	r6, #1
 8001a2c:	fab0 f080 	clz	r0, r0
 8001a30:	3301      	adds	r3, #1
 8001a32:	4430      	add	r0, r6
 8001a34:	069b      	lsls	r3, r3, #26
 8001a36:	f000 001f 	and.w	r0, r0, #31
 8001a3a:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 8001a3e:	fa06 f000 	lsl.w	r0, r6, r0
 8001a42:	4303      	orrs	r3, r0
 8001a44:	fa92 f2a2 	rbit	r2, r2
 8001a48:	fab2 f282 	clz	r2, r2
 8001a4c:	4432      	add	r2, r6
 8001a4e:	f002 021f 	and.w	r2, r2, #31
 8001a52:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8001a56:	e79e      	b.n	8001996 <HAL_ADC_ConfigChannel+0x8e6>
          if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) && ((tmp_config_internal_channel & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0UL))
 8001a58:	0224      	lsls	r4, r4, #8
 8001a5a:	f53f ac8a 	bmi.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc))
 8001a5e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001a62:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8001a66:	4298      	cmp	r0, r3
 8001a68:	f47f ac83 	bne.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8001a6c:	f240 23b0 	movw	r3, #688	; 0x2b0
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001a70:	6888      	ldr	r0, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_TEMPSENSOR | tmp_config_internal_channel);
 8001a72:	f446 0200 	orr.w	r2, r6, #8388608	; 0x800000
              wait_loop_index = ((LL_ADC_DELAY_TEMPSENSOR_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8001a76:	f642 5463 	movw	r4, #11619	; 0x2d63
 8001a7a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8001a7e:	f020 70e0 	bic.w	r0, r0, #29360128	; 0x1c00000
 8001a82:	f2c0 543e 	movt	r4, #1342	; 0x53e
 8001a86:	681b      	ldr	r3, [r3, #0]
 8001a88:	4302      	orrs	r2, r0
 8001a8a:	099b      	lsrs	r3, r3, #6
 8001a8c:	608a      	str	r2, [r1, #8]
 8001a8e:	fba4 2303 	umull	r2, r3, r4, r3
 8001a92:	099b      	lsrs	r3, r3, #6
 8001a94:	005b      	lsls	r3, r3, #1
 8001a96:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
 8001a98:	9b01      	ldr	r3, [sp, #4]
 8001a9a:	2b00      	cmp	r3, #0
 8001a9c:	f43f ac69 	beq.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
                wait_loop_index--;
 8001aa0:	9b01      	ldr	r3, [sp, #4]
 8001aa2:	3b01      	subs	r3, #1
 8001aa4:	9301      	str	r3, [sp, #4]
              while(wait_loop_index != 0UL)
 8001aa6:	9b01      	ldr	r3, [sp, #4]
 8001aa8:	2b00      	cmp	r3, #0
 8001aaa:	d1f9      	bne.n	8001aa0 <HAL_ADC_ConfigChannel+0x9f0>
 8001aac:	e461      	b.n	8001372 <HAL_ADC_ConfigChannel+0x2c2>
            if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 8001aae:	01e2      	lsls	r2, r4, #7
 8001ab0:	f53f ac5f 	bmi.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
 8001ab4:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001ab8:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8001abc:	4298      	cmp	r0, r3
 8001abe:	f47f ac58 	bne.w	8001372 <HAL_ADC_ConfigChannel+0x2c2>
 8001ac2:	688a      	ldr	r2, [r1, #8]
              LL_ADC_SetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance), LL_ADC_PATH_INTERNAL_VBAT | tmp_config_internal_channel);
 8001ac4:	f046 7380 	orr.w	r3, r6, #16777216	; 0x1000000
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8001ac8:	2000      	movs	r0, #0
 8001aca:	f022 72e0 	bic.w	r2, r2, #29360128	; 0x1c00000
 8001ace:	4313      	orrs	r3, r2
 8001ad0:	608b      	str	r3, [r1, #8]
 8001ad2:	e466      	b.n	80013a2 <HAL_ADC_ConfigChannel+0x2f2>

08001ad4 <ADC_Disable>:
{
 8001ad4:	b538      	push	{r3, r4, r5, lr}
  const uint32_t tmp_adc_is_disable_on_going = LL_ADC_IsDisableOngoing(hadc->Instance);
 8001ad6:	6803      	ldr	r3, [r0, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADDIS) == (ADC_CR_ADDIS)) ? 1UL : 0UL);
 8001ad8:	6899      	ldr	r1, [r3, #8]
 8001ada:	0789      	lsls	r1, r1, #30
 8001adc:	d502      	bpl.n	8001ae4 <ADC_Disable+0x10>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001ade:	689b      	ldr	r3, [r3, #8]
  return HAL_OK;
 8001ae0:	2000      	movs	r0, #0
}
 8001ae2:	bd38      	pop	{r3, r4, r5, pc}
 8001ae4:	6899      	ldr	r1, [r3, #8]
 8001ae6:	07ca      	lsls	r2, r1, #31
 8001ae8:	d527      	bpl.n	8001b3a <ADC_Disable+0x66>
    if ((hadc->Instance->CR & (ADC_CR_JADSTART | ADC_CR_ADSTART | ADC_CR_ADEN)) == ADC_CR_ADEN)
 8001aea:	6899      	ldr	r1, [r3, #8]
 8001aec:	4604      	mov	r4, r0
 8001aee:	f001 010d 	and.w	r1, r1, #13
 8001af2:	2901      	cmp	r1, #1
 8001af4:	d008      	beq.n	8001b08 <ADC_Disable+0x34>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001af6:	6d63      	ldr	r3, [r4, #84]	; 0x54
        return HAL_ERROR;
 8001af8:	2001      	movs	r0, #1
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001afa:	f043 0310 	orr.w	r3, r3, #16
 8001afe:	6563      	str	r3, [r4, #84]	; 0x54
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001b00:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8001b02:	4303      	orrs	r3, r0
 8001b04:	65a3      	str	r3, [r4, #88]	; 0x58
}
 8001b06:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 8001b08:	f64f 72c0 	movw	r2, #65472	; 0xffc0
 8001b0c:	6898      	ldr	r0, [r3, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8001b0e:	2103      	movs	r1, #3
 8001b10:	f6c7 72ff 	movt	r2, #32767	; 0x7fff
 8001b14:	4002      	ands	r2, r0
 8001b16:	f042 0202 	orr.w	r2, r2, #2
 8001b1a:	609a      	str	r2, [r3, #8]
 8001b1c:	6823      	ldr	r3, [r4, #0]
 8001b1e:	6019      	str	r1, [r3, #0]
    tickstart = HAL_GetTick();
 8001b20:	f7fe ff8c 	bl	8000a3c <HAL_GetTick>
 8001b24:	4605      	mov	r5, r0
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8001b26:	e004      	b.n	8001b32 <ADC_Disable+0x5e>
      if ((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8001b28:	f7fe ff88 	bl	8000a3c <HAL_GetTick>
 8001b2c:	1b40      	subs	r0, r0, r5
 8001b2e:	2802      	cmp	r0, #2
 8001b30:	d8e1      	bhi.n	8001af6 <ADC_Disable+0x22>
    while ((hadc->Instance->CR & ADC_CR_ADEN) != 0UL)
 8001b32:	6823      	ldr	r3, [r4, #0]
 8001b34:	689b      	ldr	r3, [r3, #8]
 8001b36:	07db      	lsls	r3, r3, #31
 8001b38:	d4f6      	bmi.n	8001b28 <ADC_Disable+0x54>
  return HAL_OK;
 8001b3a:	2000      	movs	r0, #0
}
 8001b3c:	bd38      	pop	{r3, r4, r5, pc}
 8001b3e:	bf00      	nop

08001b40 <ADC_ConfigureBoostMode>:
  *         stopped.
  * @param  hadc ADC handle
  * @retval None.
  */
void ADC_ConfigureBoostMode(ADC_HandleTypeDef* hadc)
{
 8001b40:	b538      	push	{r3, r4, r5, lr}
  uint32_t freq;
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 8001b42:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8001b46:	6802      	ldr	r2, [r0, #0]
{
 8001b48:	4605      	mov	r5, r0
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 8001b4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b4e:	429a      	cmp	r2, r3
 8001b50:	d030      	beq.n	8001bb4 <ADC_ConfigureBoostMode+0x74>
 8001b52:	f44f 5304 	mov.w	r3, #8448	; 0x2100
 8001b56:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001b5a:	429a      	cmp	r2, r3
 8001b5c:	d02a      	beq.n	8001bb4 <ADC_ConfigureBoostMode+0x74>
 8001b5e:	f44f 43c6 	mov.w	r3, #25344	; 0x6300
 8001b62:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8001b66:	689b      	ldr	r3, [r3, #8]
 8001b68:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8001b6c:	bf14      	ite	ne
 8001b6e:	2301      	movne	r3, #1
 8001b70:	2300      	moveq	r3, #0
 8001b72:	b35b      	cbz	r3, 8001bcc <ADC_ConfigureBoostMode+0x8c>
  {
    freq = HAL_RCC_GetHCLKFreq();
 8001b74:	f008 f938 	bl	8009de8 <HAL_RCC_GetHCLKFreq>
    switch(hadc->Init.ClockPrescaler)
 8001b78:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCC_GetHCLKFreq();
 8001b7a:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
 8001b7c:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 8001b80:	d072      	beq.n	8001c68 <ADC_ConfigureBoostMode+0x128>
 8001b82:	f5b3 3f40 	cmp.w	r3, #196608	; 0x30000
 8001b86:	f000 8082 	beq.w	8001c8e <ADC_ConfigureBoostMode+0x14e>
 8001b8a:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001b8e:	d06b      	beq.n	8001c68 <ADC_ConfigureBoostMode+0x128>
  else /* if(freq > 25000000UL) */
  {
    MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
  }
#else
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 8001b90:	f7fe ff6e 	bl	8000a70 <HAL_GetREVID>
 8001b94:	f241 0303 	movw	r3, #4099	; 0x1003
 8001b98:	4298      	cmp	r0, r3
 8001b9a:	d838      	bhi.n	8001c0e <ADC_ConfigureBoostMode+0xce>
  {
    if(freq > 20000000UL)
 8001b9c:	f44f 5234 	mov.w	r2, #11520	; 0x2d00
 8001ba0:	682b      	ldr	r3, [r5, #0]
 8001ba2:	f2c0 1231 	movt	r2, #305	; 0x131
 8001ba6:	4294      	cmp	r4, r2
 8001ba8:	d92b      	bls.n	8001c02 <ADC_ConfigureBoostMode+0xc2>
    {
      SET_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8001baa:	689a      	ldr	r2, [r3, #8]
 8001bac:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001bb0:	609a      	str	r2, [r3, #8]
    {
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
    }
  }
#endif /* ADC_VER_V5_3 */
}
 8001bb2:	bd38      	pop	{r3, r4, r5, pc}
  if(ADC_IS_SYNCHRONOUS_CLOCK_MODE(hadc))
 8001bb4:	f44f 530c 	mov.w	r3, #8960	; 0x2300
 8001bb8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8001bbc:	689b      	ldr	r3, [r3, #8]
 8001bbe:	f413 3f40 	tst.w	r3, #196608	; 0x30000
 8001bc2:	bf14      	ite	ne
 8001bc4:	2301      	movne	r3, #1
 8001bc6:	2300      	moveq	r3, #0
 8001bc8:	2b00      	cmp	r3, #0
 8001bca:	d1d3      	bne.n	8001b74 <ADC_ConfigureBoostMode+0x34>
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8001bcc:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8001bd0:	f009 fcd8 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
    switch(hadc->Init.ClockPrescaler)
 8001bd4:	686b      	ldr	r3, [r5, #4]
    freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC);
 8001bd6:	4604      	mov	r4, r0
    switch(hadc->Init.ClockPrescaler)
 8001bd8:	f5b3 1fc0 	cmp.w	r3, #1572864	; 0x180000
 8001bdc:	d052      	beq.n	8001c84 <ADC_ConfigureBoostMode+0x144>
 8001bde:	d947      	bls.n	8001c70 <ADC_ConfigureBoostMode+0x130>
 8001be0:	f5b3 1f10 	cmp.w	r3, #2359296	; 0x240000
 8001be4:	d057      	beq.n	8001c96 <ADC_ConfigureBoostMode+0x156>
 8001be6:	d930      	bls.n	8001c4a <ADC_ConfigureBoostMode+0x10a>
 8001be8:	f5b3 1f20 	cmp.w	r3, #2621440	; 0x280000
 8001bec:	d051      	beq.n	8001c92 <ADC_ConfigureBoostMode+0x152>
 8001bee:	f5b3 1f30 	cmp.w	r3, #2883584	; 0x2c0000
 8001bf2:	d1cd      	bne.n	8001b90 <ADC_ConfigureBoostMode+0x50>
  if(HAL_GetREVID() <= REV_ID_Y) /* STM32H7 silicon Rev.Y */
 8001bf4:	f7fe ff3c 	bl	8000a70 <HAL_GetREVID>
 8001bf8:	f241 0303 	movw	r3, #4099	; 0x1003
 8001bfc:	4298      	cmp	r0, r3
 8001bfe:	d805      	bhi.n	8001c0c <ADC_ConfigureBoostMode+0xcc>
 8001c00:	682b      	ldr	r3, [r5, #0]
      CLEAR_BIT(hadc->Instance->CR, ADC_CR_BOOST_0);
 8001c02:	689a      	ldr	r2, [r3, #8]
 8001c04:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001c08:	609a      	str	r2, [r3, #8]
}
 8001c0a:	bd38      	pop	{r3, r4, r5, pc}
        freq /= 256UL;
 8001c0c:	0a24      	lsrs	r4, r4, #8
    if (freq <= 6250000UL)
 8001c0e:	f645 6310 	movw	r3, #24080	; 0x5e10
    freq /= 2U; /* divider by 2 for Rev.V */
 8001c12:	0864      	lsrs	r4, r4, #1
 8001c14:	682a      	ldr	r2, [r5, #0]
    if (freq <= 6250000UL)
 8001c16:	f2c0 035f 	movt	r3, #95	; 0x5f
 8001c1a:	429c      	cmp	r4, r3
 8001c1c:	d910      	bls.n	8001c40 <ADC_ConfigureBoostMode+0x100>
    else if(freq <= 12500000UL)
 8001c1e:	f64b 4320 	movw	r3, #48160	; 0xbc20
 8001c22:	f2c0 03be 	movt	r3, #190	; 0xbe
 8001c26:	429c      	cmp	r4, r3
 8001c28:	d917      	bls.n	8001c5a <ADC_ConfigureBoostMode+0x11a>
    else if(freq <= 25000000UL)
 8001c2a:	f647 0340 	movw	r3, #30784	; 0x7840
 8001c2e:	f2c0 137d 	movt	r3, #381	; 0x17d
 8001c32:	429c      	cmp	r4, r3
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 8001c34:	6893      	ldr	r3, [r2, #8]
    else if(freq <= 25000000UL)
 8001c36:	d932      	bls.n	8001c9e <ADC_ConfigureBoostMode+0x15e>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1 | ADC_CR_BOOST_0);
 8001c38:	f443 7340 	orr.w	r3, r3, #768	; 0x300
 8001c3c:	6093      	str	r3, [r2, #8]
}
 8001c3e:	bd38      	pop	{r3, r4, r5, pc}
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, 0UL);
 8001c40:	6893      	ldr	r3, [r2, #8]
 8001c42:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001c46:	6093      	str	r3, [r2, #8]
}
 8001c48:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
 8001c4a:	f5b3 1fe0 	cmp.w	r3, #1835008	; 0x1c0000
 8001c4e:	d024      	beq.n	8001c9a <ADC_ConfigureBoostMode+0x15a>
 8001c50:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 8001c54:	d19c      	bne.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= 32UL;
 8001c56:	0944      	lsrs	r4, r0, #5
        break;
 8001c58:	e79a      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_0);
 8001c5a:	6893      	ldr	r3, [r2, #8]
 8001c5c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001c60:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001c64:	6093      	str	r3, [r2, #8]
}
 8001c66:	bd38      	pop	{r3, r4, r5, pc}
        freq /= (hadc->Init.ClockPrescaler >> ADC_CCR_CKMODE_Pos);
 8001c68:	0c1b      	lsrs	r3, r3, #16
 8001c6a:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
 8001c6e:	e78f      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
    switch(hadc->Init.ClockPrescaler)
 8001c70:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8001c74:	d006      	beq.n	8001c84 <ADC_ConfigureBoostMode+0x144>
 8001c76:	d818      	bhi.n	8001caa <ADC_ConfigureBoostMode+0x16a>
 8001c78:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001c7c:	d002      	beq.n	8001c84 <ADC_ConfigureBoostMode+0x144>
 8001c7e:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 8001c82:	d185      	bne.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= ((hadc->Init.ClockPrescaler >> ADC_CCR_PRESC_Pos) << 1UL);
 8001c84:	0c9b      	lsrs	r3, r3, #18
 8001c86:	005b      	lsls	r3, r3, #1
 8001c88:	fbb4 f4f3 	udiv	r4, r4, r3
        break;
 8001c8c:	e780      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= 4UL;
 8001c8e:	0884      	lsrs	r4, r0, #2
        break;
 8001c90:	e77e      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= 128UL;
 8001c92:	09c4      	lsrs	r4, r0, #7
        break;
 8001c94:	e77c      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= 64UL;
 8001c96:	0984      	lsrs	r4, r0, #6
        break;
 8001c98:	e77a      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
        freq /= 16UL;
 8001c9a:	0904      	lsrs	r4, r0, #4
      break;
 8001c9c:	e778      	b.n	8001b90 <ADC_ConfigureBoostMode+0x50>
      MODIFY_REG(hadc->Instance->CR, ADC_CR_BOOST, ADC_CR_BOOST_1);
 8001c9e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001ca2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001ca6:	6093      	str	r3, [r2, #8]
}
 8001ca8:	bd38      	pop	{r3, r4, r5, pc}
    switch(hadc->Init.ClockPrescaler)
 8001caa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8001cae:	d0e9      	beq.n	8001c84 <ADC_ConfigureBoostMode+0x144>
 8001cb0:	f5b3 1fa0 	cmp.w	r3, #1310720	; 0x140000
 8001cb4:	f47f af6c 	bne.w	8001b90 <ADC_ConfigureBoostMode+0x50>
 8001cb8:	e7e4      	b.n	8001c84 <ADC_ConfigureBoostMode+0x144>
 8001cba:	bf00      	nop

08001cbc <HAL_ADC_Init>:
{
 8001cbc:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint32_t wait_loop_index = 0UL;
 8001cbe:	2300      	movs	r3, #0
{
 8001cc0:	b083      	sub	sp, #12
  __IO uint32_t wait_loop_index = 0UL;
 8001cc2:	9301      	str	r3, [sp, #4]
  if (hadc == NULL)
 8001cc4:	2800      	cmp	r0, #0
 8001cc6:	f000 81d7 	beq.w	8002078 <HAL_ADC_Init+0x3bc>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8001cca:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001cce:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8001cd2:	6803      	ldr	r3, [r0, #0]
 8001cd4:	4604      	mov	r4, r0
 8001cd6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8001cda:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001cde:	428b      	cmp	r3, r1
 8001ce0:	bf18      	it	ne
 8001ce2:	4293      	cmpne	r3, r2
 8001ce4:	d006      	beq.n	8001cf4 <HAL_ADC_Init+0x38>
 8001ce6:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8001cea:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8001cee:	4293      	cmp	r3, r2
 8001cf0:	f040 81d6 	bne.w	80020a0 <HAL_ADC_Init+0x3e4>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 8001cf4:	6862      	ldr	r2, [r4, #4]
 8001cf6:	f422 2300 	bic.w	r3, r2, #524288	; 0x80000
 8001cfa:	f422 3540 	bic.w	r5, r2, #196608	; 0x30000
 8001cfe:	f422 1080 	bic.w	r0, r2, #1048576	; 0x100000
 8001d02:	f422 2180 	bic.w	r1, r2, #262144	; 0x40000
 8001d06:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001d0a:	bf18      	it	ne
 8001d0c:	2d00      	cmpne	r5, #0
 8001d0e:	bf14      	ite	ne
 8001d10:	2301      	movne	r3, #1
 8001d12:	2300      	moveq	r3, #0
 8001d14:	f5b2 1fe0 	cmp.w	r2, #1835008	; 0x1c0000
 8001d18:	bf0c      	ite	eq
 8001d1a:	2300      	moveq	r3, #0
 8001d1c:	f003 0301 	andne.w	r3, r3, #1
 8001d20:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 8001d24:	bf0c      	ite	eq
 8001d26:	2300      	moveq	r3, #0
 8001d28:	f003 0301 	andne.w	r3, r3, #1
 8001d2c:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 8001d30:	bf0c      	ite	eq
 8001d32:	2300      	moveq	r3, #0
 8001d34:	f003 0301 	andne.w	r3, r3, #1
 8001d38:	b12b      	cbz	r3, 8001d46 <HAL_ADC_Init+0x8a>
 8001d3a:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8001d3e:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 8001d42:	f040 8221 	bne.w	8002188 <HAL_ADC_Init+0x4cc>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 8001d46:	68a2      	ldr	r2, [r4, #8]
 8001d48:	2a10      	cmp	r2, #16
 8001d4a:	f200 81a0 	bhi.w	800208e <HAL_ADC_Init+0x3d2>
 8001d4e:	f241 1311 	movw	r3, #4369	; 0x1111
 8001d52:	f2c0 0301 	movt	r3, #1
 8001d56:	40d3      	lsrs	r3, r2
 8001d58:	07de      	lsls	r6, r3, #31
 8001d5a:	f140 8198 	bpl.w	800208e <HAL_ADC_Init+0x3d2>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8001d5e:	68e3      	ldr	r3, [r4, #12]
 8001d60:	2b01      	cmp	r3, #1
 8001d62:	f200 80ff 	bhi.w	8001f64 <HAL_ADC_Init+0x2a8>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001d66:	7d63      	ldrb	r3, [r4, #21]
 8001d68:	2b01      	cmp	r3, #1
 8001d6a:	f200 80e5 	bhi.w	8001f38 <HAL_ADC_Init+0x27c>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
 8001d6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001d70:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8001d74:	f040 80ed 	bne.w	8001f52 <HAL_ADC_Init+0x296>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
 8001d78:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001d7a:	f5b2 6fd0 	cmp.w	r2, #1664	; 0x680
 8001d7e:	bf18      	it	ne
 8001d80:	f5b2 6fb8 	cmpne.w	r2, #1472	; 0x5c0
 8001d84:	f022 0040 	bic.w	r0, r2, #64	; 0x40
 8001d88:	f022 0180 	bic.w	r1, r2, #128	; 0x80
 8001d8c:	f422 7590 	bic.w	r5, r2, #288	; 0x120
 8001d90:	bf14      	ite	ne
 8001d92:	2301      	movne	r3, #1
 8001d94:	2300      	moveq	r3, #0
 8001d96:	f5b0 6f84 	cmp.w	r0, #1056	; 0x420
 8001d9a:	bf0c      	ite	eq
 8001d9c:	2300      	moveq	r3, #0
 8001d9e:	f003 0301 	andne.w	r3, r3, #1
 8001da2:	f422 7080 	bic.w	r0, r2, #256	; 0x100
 8001da6:	f5b1 6f88 	cmp.w	r1, #1088	; 0x440
 8001daa:	bf0c      	ite	eq
 8001dac:	2300      	moveq	r3, #0
 8001dae:	f003 0301 	andne.w	r3, r3, #1
 8001db2:	f022 0160 	bic.w	r1, r2, #96	; 0x60
 8001db6:	f5b5 6f90 	cmp.w	r5, #1152	; 0x480
 8001dba:	bf0c      	ite	eq
 8001dbc:	2300      	moveq	r3, #0
 8001dbe:	f003 0301 	andne.w	r3, r3, #1
 8001dc2:	f5b0 6f9c 	cmp.w	r0, #1248	; 0x4e0
 8001dc6:	bf0c      	ite	eq
 8001dc8:	2300      	moveq	r3, #0
 8001dca:	f003 0301 	andne.w	r3, r3, #1
 8001dce:	f5b1 6fa0 	cmp.w	r1, #1280	; 0x500
 8001dd2:	bf0c      	ite	eq
 8001dd4:	2300      	moveq	r3, #0
 8001dd6:	f003 0301 	andne.w	r3, r3, #1
 8001dda:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
 8001dde:	bf0c      	ite	eq
 8001de0:	2300      	moveq	r3, #0
 8001de2:	f003 0301 	andne.w	r3, r3, #1
 8001de6:	b11b      	cbz	r3, 8001df0 <HAL_ADC_Init+0x134>
 8001de8:	f432 6380 	bics.w	r3, r2, #1024	; 0x400
 8001dec:	f040 81d5 	bne.w	800219a <HAL_ADC_Init+0x4de>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
 8001df0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001df2:	2b03      	cmp	r3, #3
 8001df4:	f200 8194 	bhi.w	8002120 <HAL_ADC_Init+0x464>
  assert_param(IS_ADC_EOC_SELECTION(hadc->Init.EOCSelection));
 8001df8:	6923      	ldr	r3, [r4, #16]
 8001dfa:	2b04      	cmp	r3, #4
 8001dfc:	d009      	beq.n	8001e12 <HAL_ADC_Init+0x156>
 8001dfe:	2b08      	cmp	r3, #8
 8001e00:	d007      	beq.n	8001e12 <HAL_ADC_Init+0x156>
 8001e02:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001e06:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8001e0a:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001e0e:	f013 fd2b 	bl	8015868 <assert_failed>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 8001e12:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001e14:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 8001e18:	f040 80b1 	bne.w	8001f7e <HAL_ADC_Init+0x2c2>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001e1c:	7d23      	ldrb	r3, [r4, #20]
 8001e1e:	2b01      	cmp	r3, #1
 8001e20:	d87c      	bhi.n	8001f1c <HAL_ADC_Init+0x260>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001e22:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001e26:	2b01      	cmp	r3, #1
 8001e28:	d86c      	bhi.n	8001f04 <HAL_ADC_Init+0x248>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8001e2a:	68e3      	ldr	r3, [r4, #12]
 8001e2c:	2b00      	cmp	r3, #0
 8001e2e:	d14d      	bne.n	8001ecc <HAL_ADC_Init+0x210>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
 8001e30:	7f23      	ldrb	r3, [r4, #28]
 8001e32:	2b01      	cmp	r3, #1
 8001e34:	d05a      	beq.n	8001eec <HAL_ADC_Init+0x230>
  if (hadc->State == HAL_ADC_STATE_RESET)
 8001e36:	6d65      	ldr	r5, [r4, #84]	; 0x54
 8001e38:	2d00      	cmp	r5, #0
 8001e3a:	f000 8121 	beq.w	8002080 <HAL_ADC_Init+0x3c4>
  if (LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0UL)
 8001e3e:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD)) ? 1UL : 0UL);
 8001e40:	689a      	ldr	r2, [r3, #8]
 8001e42:	0095      	lsls	r5, r2, #2
 8001e44:	d507      	bpl.n	8001e56 <HAL_ADC_Init+0x19a>
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8001e46:	f64f 72c0 	movw	r2, #65472	; 0xffc0
 8001e4a:	6899      	ldr	r1, [r3, #8]
 8001e4c:	f6c5 72ff 	movt	r2, #24575	; 0x5fff
 8001e50:	400a      	ands	r2, r1
 8001e52:	609a      	str	r2, [r3, #8]
 8001e54:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001e56:	689a      	ldr	r2, [r3, #8]
 8001e58:	00d0      	lsls	r0, r2, #3
 8001e5a:	d41f      	bmi.n	8001e9c <HAL_ADC_Init+0x1e0>
    wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US / 10UL) * (SystemCoreClock / (100000UL * 2UL)));
 8001e5c:	f240 20b0 	movw	r0, #688	; 0x2b0
 8001e60:	f642 5563 	movw	r5, #11619	; 0x2d63
  MODIFY_REG(ADCx->CR,
 8001e64:	f64f 71c0 	movw	r1, #65472	; 0xffc0
 8001e68:	689e      	ldr	r6, [r3, #8]
 8001e6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8001e6e:	f2c0 553e 	movt	r5, #1342	; 0x53e
 8001e72:	f6c6 71ff 	movt	r1, #28671	; 0x6fff
 8001e76:	6802      	ldr	r2, [r0, #0]
 8001e78:	4031      	ands	r1, r6
 8001e7a:	0992      	lsrs	r2, r2, #6
 8001e7c:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8001e80:	fba5 0202 	umull	r0, r2, r5, r2
 8001e84:	6099      	str	r1, [r3, #8]
 8001e86:	0992      	lsrs	r2, r2, #6
 8001e88:	9201      	str	r2, [sp, #4]
    while (wait_loop_index != 0UL)
 8001e8a:	9b01      	ldr	r3, [sp, #4]
 8001e8c:	b12b      	cbz	r3, 8001e9a <HAL_ADC_Init+0x1de>
      wait_loop_index--;
 8001e8e:	9b01      	ldr	r3, [sp, #4]
 8001e90:	3b01      	subs	r3, #1
 8001e92:	9301      	str	r3, [sp, #4]
    while (wait_loop_index != 0UL)
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	2b00      	cmp	r3, #0
 8001e98:	d1f9      	bne.n	8001e8e <HAL_ADC_Init+0x1d2>
 8001e9a:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN)) ? 1UL : 0UL);
 8001e9c:	689a      	ldr	r2, [r3, #8]
 8001e9e:	00d1      	lsls	r1, r2, #3
 8001ea0:	f100 80e8 	bmi.w	8002074 <HAL_ADC_Init+0x3b8>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ea4:	6d62      	ldr	r2, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8001ea6:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ea8:	f042 0210 	orr.w	r2, r2, #16
 8001eac:	6562      	str	r2, [r4, #84]	; 0x54
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001eae:	6da2      	ldr	r2, [r4, #88]	; 0x58
 8001eb0:	432a      	orrs	r2, r5
 8001eb2:	65a2      	str	r2, [r4, #88]	; 0x58
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8001eb4:	689a      	ldr	r2, [r3, #8]
 8001eb6:	0752      	lsls	r2, r2, #29
 8001eb8:	d56e      	bpl.n	8001f98 <HAL_ADC_Init+0x2dc>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001eba:	6d63      	ldr	r3, [r4, #84]	; 0x54
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ebc:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8001ebe:	2501      	movs	r5, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ec0:	f043 0310 	orr.w	r3, r3, #16
}
 8001ec4:	4628      	mov	r0, r5
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001ec6:	6563      	str	r3, [r4, #84]	; 0x54
}
 8001ec8:	b003      	add	sp, #12
 8001eca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
 8001ecc:	69a3      	ldr	r3, [r4, #24]
 8001ece:	3b01      	subs	r3, #1
 8001ed0:	2b0f      	cmp	r3, #15
 8001ed2:	f200 811c 	bhi.w	800210e <HAL_ADC_Init+0x452>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 8001ed6:	7f23      	ldrb	r3, [r4, #28]
 8001ed8:	2b01      	cmp	r3, #1
 8001eda:	f200 80ea 	bhi.w	80020b2 <HAL_ADC_Init+0x3f6>
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8001ede:	2b01      	cmp	r3, #1
 8001ee0:	d1a9      	bne.n	8001e36 <HAL_ADC_Init+0x17a>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
 8001ee2:	6a23      	ldr	r3, [r4, #32]
 8001ee4:	3b01      	subs	r3, #1
 8001ee6:	2b07      	cmp	r3, #7
 8001ee8:	f200 8132 	bhi.w	8002150 <HAL_ADC_Init+0x494>
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
 8001eec:	7d63      	ldrb	r3, [r4, #21]
 8001eee:	2b01      	cmp	r3, #1
 8001ef0:	d1a1      	bne.n	8001e36 <HAL_ADC_Init+0x17a>
 8001ef2:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001ef6:	f240 11bf 	movw	r1, #447	; 0x1bf
 8001efa:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001efe:	f013 fcb3 	bl	8015868 <assert_failed>
 8001f02:	e798      	b.n	8001e36 <HAL_ADC_Init+0x17a>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001f04:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f08:	f240 11b1 	movw	r1, #433	; 0x1b1
 8001f0c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f10:	f013 fcaa 	bl	8015868 <assert_failed>
  if (hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
 8001f14:	68e3      	ldr	r3, [r4, #12]
 8001f16:	2b00      	cmp	r3, #0
 8001f18:	d08a      	beq.n	8001e30 <HAL_ADC_Init+0x174>
 8001f1a:	e7d7      	b.n	8001ecc <HAL_ADC_Init+0x210>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001f1c:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f20:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 8001f24:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f28:	f013 fc9e 	bl	8015868 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.OversamplingMode));
 8001f2c:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 8001f30:	2b01      	cmp	r3, #1
 8001f32:	f67f af7a 	bls.w	8001e2a <HAL_ADC_Init+0x16e>
 8001f36:	e7e5      	b.n	8001f04 <HAL_ADC_Init+0x248>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001f38:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f3c:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
 8001f40:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f44:	f013 fc90 	bl	8015868 <assert_failed>
  assert_param(IS_ADC_EXTTRIG_EDGE(hadc->Init.ExternalTrigConvEdge));
 8001f48:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001f4a:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 8001f4e:	f43f af13 	beq.w	8001d78 <HAL_ADC_Init+0xbc>
 8001f52:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f56:	f240 11ab 	movw	r1, #427	; 0x1ab
 8001f5a:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f5e:	f013 fc83 	bl	8015868 <assert_failed>
 8001f62:	e709      	b.n	8001d78 <HAL_ADC_Init+0xbc>
  assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
 8001f64:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f68:	f240 11a9 	movw	r1, #425	; 0x1a9
 8001f6c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f70:	f013 fc7a 	bl	8015868 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
 8001f74:	7d63      	ldrb	r3, [r4, #21]
 8001f76:	2b01      	cmp	r3, #1
 8001f78:	f67f aef9 	bls.w	8001d6e <HAL_ADC_Init+0xb2>
 8001f7c:	e7dc      	b.n	8001f38 <HAL_ADC_Init+0x27c>
  assert_param(IS_ADC_OVERRUN(hadc->Init.Overrun));
 8001f7e:	f64d 1048 	movw	r0, #55624	; 0xd948
 8001f82:	f240 11af 	movw	r1, #431	; 0x1af
 8001f86:	f6c0 0002 	movt	r0, #2050	; 0x802
 8001f8a:	f013 fc6d 	bl	8015868 <assert_failed>
  assert_param(IS_FUNCTIONAL_STATE(hadc->Init.LowPowerAutoWait));
 8001f8e:	7d23      	ldrb	r3, [r4, #20]
 8001f90:	2b01      	cmp	r3, #1
 8001f92:	f67f af46 	bls.w	8001e22 <HAL_ADC_Init+0x166>
 8001f96:	e7c1      	b.n	8001f1c <HAL_ADC_Init+0x260>
  if (((hadc->State & HAL_ADC_STATE_ERROR_INTERNAL) == 0UL)
 8001f98:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001f9a:	06d7      	lsls	r7, r2, #27
 8001f9c:	d48e      	bmi.n	8001ebc <HAL_ADC_Init+0x200>
    ADC_STATE_CLR_SET(hadc->State,
 8001f9e:	6d62      	ldr	r2, [r4, #84]	; 0x54
 8001fa0:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8001fa4:	f042 0202 	orr.w	r2, r2, #2
 8001fa8:	6562      	str	r2, [r4, #84]	; 0x54
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8001faa:	689a      	ldr	r2, [r3, #8]
 8001fac:	07d6      	lsls	r6, r2, #31
 8001fae:	d41e      	bmi.n	8001fee <HAL_ADC_Init+0x332>
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8001fb0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8001fb4:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001fb8:	4293      	cmp	r3, r2
 8001fba:	f000 80d2 	beq.w	8002162 <HAL_ADC_Init+0x4a6>
 8001fbe:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8001fc2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8001fc6:	4293      	cmp	r3, r2
 8001fc8:	f000 80cb 	beq.w	8002162 <HAL_ADC_Init+0x4a6>
 8001fcc:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8001fd0:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8001fd4:	689b      	ldr	r3, [r3, #8]
 8001fd6:	07d9      	lsls	r1, r3, #31
 8001fd8:	d409      	bmi.n	8001fee <HAL_ADC_Init+0x332>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 8001fda:	f44f 42c6 	mov.w	r2, #25344	; 0x6300
 8001fde:	f6c5 0202 	movt	r2, #22530	; 0x5802
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001fe2:	6893      	ldr	r3, [r2, #8]
 8001fe4:	6861      	ldr	r1, [r4, #4]
 8001fe6:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8001fea:	430b      	orrs	r3, r1
 8001fec:	6093      	str	r3, [r2, #8]
    if((HAL_GetREVID() > REV_ID_Y) && (ADC_RESOLUTION_8B == hadc->Init.Resolution))
 8001fee:	f7fe fd3f 	bl	8000a70 <HAL_GetREVID>
 8001ff2:	f241 0303 	movw	r3, #4099	; 0x1003
 8001ff6:	4298      	cmp	r0, r3
 8001ff8:	f240 809b 	bls.w	8002132 <HAL_ADC_Init+0x476>
 8001ffc:	68a2      	ldr	r2, [r4, #8]
 8001ffe:	7d61      	ldrb	r1, [r4, #21]
 8002000:	7f20      	ldrb	r0, [r4, #28]
 8002002:	2a10      	cmp	r2, #16
 8002004:	ea4f 3141 	mov.w	r1, r1, lsl #13
 8002008:	6b26      	ldr	r6, [r4, #48]	; 0x30
 800200a:	ea4f 4300 	mov.w	r3, r0, lsl #16
 800200e:	f000 810d 	beq.w	800222c <HAL_ADC_Init+0x570>
                  hadc->Init.Overrun                                                    |
 8002012:	430a      	orrs	r2, r1
 8002014:	4332      	orrs	r2, r6
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 8002016:	431a      	orrs	r2, r3
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8002018:	2801      	cmp	r0, #1
 800201a:	d103      	bne.n	8002024 <HAL_ADC_Init+0x368>
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 800201c:	6a23      	ldr	r3, [r4, #32]
 800201e:	3b01      	subs	r3, #1
 8002020:	ea42 4243 	orr.w	r2, r2, r3, lsl #17
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8002024:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002026:	b123      	cbz	r3, 8002032 <HAL_ADC_Init+0x376>
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002028:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                  | hadc->Init.ExternalTrigConvEdge
 800202c:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800202e:	430b      	orrs	r3, r1
      tmpCFGR |= ((hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8002030:	431a      	orrs	r2, r3
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR);
 8002032:	6821      	ldr	r1, [r4, #0]
 8002034:	f24c 0303 	movw	r3, #49155	; 0xc003
 8002038:	68c8      	ldr	r0, [r1, #12]
 800203a:	f6cf 73f0 	movt	r3, #65520	; 0xfff0
 800203e:	4003      	ands	r3, r0
 8002040:	4313      	orrs	r3, r2
 8002042:	60cb      	str	r3, [r1, #12]
    tmp_adc_is_conversion_on_going_regular = LL_ADC_REG_IsConversionOngoing(hadc->Instance);
 8002044:	6823      	ldr	r3, [r4, #0]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8002046:	689a      	ldr	r2, [r3, #8]
 8002048:	f012 0f04 	tst.w	r2, #4
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 800204c:	689a      	ldr	r2, [r3, #8]
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 800204e:	d101      	bne.n	8002054 <HAL_ADC_Init+0x398>
  return ((READ_BIT(ADCx->CR, ADC_CR_JADSTART) == (ADC_CR_JADSTART)) ? 1UL : 0UL);
 8002050:	0712      	lsls	r2, r2, #28
 8002052:	d53b      	bpl.n	80020cc <HAL_ADC_Init+0x410>
    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8002054:	68e2      	ldr	r2, [r4, #12]
 8002056:	2a01      	cmp	r2, #1
 8002058:	d072      	beq.n	8002140 <HAL_ADC_Init+0x484>
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 800205a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800205c:	f022 020f 	bic.w	r2, r2, #15
 8002060:	631a      	str	r2, [r3, #48]	; 0x30
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8002062:	6d63      	ldr	r3, [r4, #84]	; 0x54
}
 8002064:	4628      	mov	r0, r5
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 8002066:	f023 0303 	bic.w	r3, r3, #3
 800206a:	f043 0301 	orr.w	r3, r3, #1
 800206e:	6563      	str	r3, [r4, #84]	; 0x54
}
 8002070:	b003      	add	sp, #12
 8002072:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8002074:	2500      	movs	r5, #0
 8002076:	e71d      	b.n	8001eb4 <HAL_ADC_Init+0x1f8>
    return HAL_ERROR;
 8002078:	2501      	movs	r5, #1
}
 800207a:	4628      	mov	r0, r5
 800207c:	b003      	add	sp, #12
 800207e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    HAL_ADC_MspInit(hadc);
 8002080:	4620      	mov	r0, r4
 8002082:	f010 fbf5 	bl	8012870 <HAL_ADC_MspInit>
    ADC_CLEAR_ERRORCODE(hadc);
 8002086:	65a5      	str	r5, [r4, #88]	; 0x58
    hadc->Lock = HAL_UNLOCKED;
 8002088:	f884 5050 	strb.w	r5, [r4, #80]	; 0x50
 800208c:	e6d7      	b.n	8001e3e <HAL_ADC_Init+0x182>
  assert_param(IS_ADC_RESOLUTION(hadc->Init.Resolution));
 800208e:	f64d 1048 	movw	r0, #55624	; 0xd948
 8002092:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 8002096:	f6c0 0002 	movt	r0, #2050	; 0x802
 800209a:	f013 fbe5 	bl	8015868 <assert_failed>
 800209e:	e65e      	b.n	8001d5e <HAL_ADC_Init+0xa2>
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80020a0:	f64d 1048 	movw	r0, #55624	; 0xd948
 80020a4:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 80020a8:	f6c0 0002 	movt	r0, #2050	; 0x802
 80020ac:	f013 fbdc 	bl	8015868 <assert_failed>
 80020b0:	e620      	b.n	8001cf4 <HAL_ADC_Init+0x38>
    assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
 80020b2:	f64d 1048 	movw	r0, #55624	; 0xd948
 80020b6:	f44f 71db 	mov.w	r1, #438	; 0x1b6
 80020ba:	f6c0 0002 	movt	r0, #2050	; 0x802
 80020be:	f013 fbd3 	bl	8015868 <assert_failed>
 80020c2:	7f23      	ldrb	r3, [r4, #28]
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 80020c4:	2b01      	cmp	r3, #1
 80020c6:	f47f aeb6 	bne.w	8001e36 <HAL_ADC_Init+0x17a>
 80020ca:	e70a      	b.n	8001ee2 <HAL_ADC_Init+0x226>
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80020cc:	f64b 72fc 	movw	r2, #49148	; 0xbffc
 80020d0:	68de      	ldr	r6, [r3, #12]
                 ADC_CFGR_AUTOWAIT((uint32_t)hadc->Init.LowPowerAutoWait)        |
 80020d2:	7d20      	ldrb	r0, [r4, #20]
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);
 80020d4:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 80020d8:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 80020da:	4032      	ands	r2, r6
 80020dc:	ea42 3280 	orr.w	r2, r2, r0, lsl #14
 80020e0:	430a      	orrs	r2, r1
 80020e2:	60da      	str	r2, [r3, #12]
      if (hadc->Init.OversamplingMode == ENABLE)
 80020e4:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 80020e8:	2b01      	cmp	r3, #1
 80020ea:	d05f      	beq.n	80021ac <HAL_ADC_Init+0x4f0>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 80020ec:	6822      	ldr	r2, [r4, #0]
 80020ee:	6913      	ldr	r3, [r2, #16]
 80020f0:	f023 0301 	bic.w	r3, r3, #1
 80020f4:	6113      	str	r3, [r2, #16]
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 80020f6:	6822      	ldr	r2, [r4, #0]
      ADC_ConfigureBoostMode(hadc);
 80020f8:	4620      	mov	r0, r4
      MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_LSHIFT, hadc->Init.LeftBitShift);
 80020fa:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80020fc:	6913      	ldr	r3, [r2, #16]
 80020fe:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
 8002102:	430b      	orrs	r3, r1
 8002104:	6113      	str	r3, [r2, #16]
      ADC_ConfigureBoostMode(hadc);
 8002106:	f7ff fd1b 	bl	8001b40 <ADC_ConfigureBoostMode>
 800210a:	6823      	ldr	r3, [r4, #0]
 800210c:	e7a2      	b.n	8002054 <HAL_ADC_Init+0x398>
    assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
 800210e:	f64d 1048 	movw	r0, #55624	; 0xd948
 8002112:	f240 11b5 	movw	r1, #437	; 0x1b5
 8002116:	f6c0 0002 	movt	r0, #2050	; 0x802
 800211a:	f013 fba5 	bl	8015868 <assert_failed>
 800211e:	e6da      	b.n	8001ed6 <HAL_ADC_Init+0x21a>
  assert_param(IS_ADC_CONVERSIONDATAMGT(hadc->Init.ConversionDataManagement));
 8002120:	f64d 1048 	movw	r0, #55624	; 0xd948
 8002124:	f240 11ad 	movw	r1, #429	; 0x1ad
 8002128:	f6c0 0002 	movt	r0, #2050	; 0x802
 800212c:	f013 fb9c 	bl	8015868 <assert_failed>
 8002130:	e662      	b.n	8001df8 <HAL_ADC_Init+0x13c>
 8002132:	7d62      	ldrb	r2, [r4, #21]
 8002134:	7f20      	ldrb	r0, [r4, #28]
 8002136:	0351      	lsls	r1, r2, #13
 8002138:	6b26      	ldr	r6, [r4, #48]	; 0x30
 800213a:	68a2      	ldr	r2, [r4, #8]
 800213c:	0403      	lsls	r3, r0, #16
 800213e:	e768      	b.n	8002012 <HAL_ADC_Init+0x356>
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8002140:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8002142:	69a2      	ldr	r2, [r4, #24]
 8002144:	f021 010f 	bic.w	r1, r1, #15
 8002148:	3a01      	subs	r2, #1
 800214a:	430a      	orrs	r2, r1
 800214c:	631a      	str	r2, [r3, #48]	; 0x30
 800214e:	e788      	b.n	8002062 <HAL_ADC_Init+0x3a6>
      assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
 8002150:	f64d 1048 	movw	r0, #55624	; 0xd948
 8002154:	f44f 71dd 	mov.w	r1, #442	; 0x1ba
 8002158:	f6c0 0002 	movt	r0, #2050	; 0x802
 800215c:	f013 fb84 	bl	8015868 <assert_failed>
 8002160:	e666      	b.n	8001e30 <HAL_ADC_Init+0x174>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 8002162:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002166:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 800216a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800216e:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002172:	6899      	ldr	r1, [r3, #8]
 8002174:	6893      	ldr	r3, [r2, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002176:	430b      	orrs	r3, r1
 8002178:	07d8      	lsls	r0, r3, #31
 800217a:	f53f af38 	bmi.w	8001fee <HAL_ADC_Init+0x332>
        LL_ADC_SetCommonClock(__LL_ADC_COMMON_INSTANCE(hadc->Instance), hadc->Init.ClockPrescaler);
 800217e:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 8002182:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002186:	e72c      	b.n	8001fe2 <HAL_ADC_Init+0x326>
  assert_param(IS_ADC_CLOCKPRESCALER(hadc->Init.ClockPrescaler));
 8002188:	f64d 1048 	movw	r0, #55624	; 0xd948
 800218c:	f240 11a7 	movw	r1, #423	; 0x1a7
 8002190:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002194:	f013 fb68 	bl	8015868 <assert_failed>
 8002198:	e5d5      	b.n	8001d46 <HAL_ADC_Init+0x8a>
  assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
 800219a:	f64d 1048 	movw	r0, #55624	; 0xd948
 800219e:	f44f 71d6 	mov.w	r1, #428	; 0x1ac
 80021a2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80021a6:	f013 fb5f 	bl	8015868 <assert_failed>
 80021aa:	e621      	b.n	8001df0 <HAL_ADC_Init+0x134>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
 80021ac:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80021ae:	3b01      	subs	r3, #1
 80021b0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80021b4:	d251      	bcs.n	800225a <HAL_ADC_Init+0x59e>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
 80021b6:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80021b8:	f032 0160 	bics.w	r1, r2, #96	; 0x60
 80021bc:	bf14      	ite	ne
 80021be:	2301      	movne	r3, #1
 80021c0:	2300      	moveq	r3, #0
 80021c2:	2980      	cmp	r1, #128	; 0x80
 80021c4:	bf0c      	ite	eq
 80021c6:	2300      	moveq	r3, #0
 80021c8:	f003 0301 	andne.w	r3, r3, #1
 80021cc:	b113      	cbz	r3, 80021d4 <HAL_ADC_Init+0x518>
 80021ce:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80021d2:	d14b      	bne.n	800226c <HAL_ADC_Init+0x5b0>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
 80021d4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80021d6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 80021da:	d135      	bne.n	8002248 <HAL_ADC_Init+0x58c>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
 80021dc:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80021de:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 80021e2:	2b01      	cmp	r3, #1
 80021e4:	d127      	bne.n	8002236 <HAL_ADC_Init+0x57a>
      if ((hadc->Init.ExternalTrigConv == ADC_SOFTWARE_START)
 80021e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021e8:	6c66      	ldr	r6, [r4, #68]	; 0x44
 80021ea:	b10b      	cbz	r3, 80021f0 <HAL_ADC_Init+0x534>
            || (hadc->Init.ExternalTrigConvEdge == ADC_EXTERNALTRIGCONVEDGE_NONE))
 80021ec:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80021ee:	b94b      	cbnz	r3, 8002204 <HAL_ADC_Init+0x548>
          assert_param((hadc->Init.Oversampling.TriggeredMode == ADC_TRIGGEREDMODE_SINGLE_TRIGGER));
 80021f0:	b146      	cbz	r6, 8002204 <HAL_ADC_Init+0x548>
 80021f2:	f64d 1048 	movw	r0, #55624	; 0xd948
 80021f6:	f240 218b 	movw	r1, #651	; 0x28b
 80021fa:	f6c0 0002 	movt	r0, #2050	; 0x802
 80021fe:	f013 fb33 	bl	8015868 <assert_failed>
 8002202:	6c66      	ldr	r6, [r4, #68]	; 0x44
       MODIFY_REG(hadc->Instance->CFGR2, ADC_CFGR2_FIELDS,
 8002204:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8002206:	f64f 021e 	movw	r2, #63518	; 0xf81e
 800220a:	6820      	ldr	r0, [r4, #0]
 800220c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800220e:	f6cf 4200 	movt	r2, #64512	; 0xfc00
 8002212:	6907      	ldr	r7, [r0, #16]
 8002214:	430b      	orrs	r3, r1
 8002216:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002218:	403a      	ands	r2, r7
 800221a:	f043 0301 	orr.w	r3, r3, #1
 800221e:	3901      	subs	r1, #1
 8002220:	4313      	orrs	r3, r2
 8002222:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8002226:	4333      	orrs	r3, r6
 8002228:	6103      	str	r3, [r0, #16]
 800222a:	e764      	b.n	80020f6 <HAL_ADC_Init+0x43a>
      tmpCFGR  = (ADC_CFGR_CONTINUOUS((uint32_t)hadc->Init.ContinuousConvMode)          |
 800222c:	f046 021c 	orr.w	r2, r6, #28
 8002230:	430a      	orrs	r2, r1
 8002232:	431a      	orrs	r2, r3
 8002234:	e6f0      	b.n	8002018 <HAL_ADC_Init+0x35c>
        assert_param(IS_ADC_REGOVERSAMPLING_MODE(hadc->Init.Oversampling.OversamplingStopReset));
 8002236:	f64d 1048 	movw	r0, #55624	; 0xd948
 800223a:	f240 2185 	movw	r1, #645	; 0x285
 800223e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002242:	f013 fb11 	bl	8015868 <assert_failed>
 8002246:	e7ce      	b.n	80021e6 <HAL_ADC_Init+0x52a>
        assert_param(IS_ADC_TRIGGERED_OVERSAMPLING_MODE(hadc->Init.Oversampling.TriggeredMode));
 8002248:	f64d 1048 	movw	r0, #55624	; 0xd948
 800224c:	f44f 7121 	mov.w	r1, #644	; 0x284
 8002250:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002254:	f013 fb08 	bl	8015868 <assert_failed>
 8002258:	e7c0      	b.n	80021dc <HAL_ADC_Init+0x520>
        assert_param(IS_ADC_OVERSAMPLING_RATIO(hadc->Init.Oversampling.Ratio));
 800225a:	f64d 1048 	movw	r0, #55624	; 0xd948
 800225e:	f240 2182 	movw	r1, #642	; 0x282
 8002262:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002266:	f013 faff 	bl	8015868 <assert_failed>
 800226a:	e7a4      	b.n	80021b6 <HAL_ADC_Init+0x4fa>
        assert_param(IS_ADC_RIGHT_BIT_SHIFT(hadc->Init.Oversampling.RightBitShift));
 800226c:	f64d 1048 	movw	r0, #55624	; 0xd948
 8002270:	f240 2183 	movw	r1, #643	; 0x283
 8002274:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002278:	f013 faf6 	bl	8015868 <assert_failed>
 800227c:	e7aa      	b.n	80021d4 <HAL_ADC_Init+0x518>
 800227e:	bf00      	nop

08002280 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef *hadc, uint32_t CalibrationMode, uint32_t SingleDiff)
{
 8002280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002282:	4604      	mov	r4, r0
  HAL_StatusTypeDef tmp_hal_status;
  __IO uint32_t wait_loop_index = 0UL;

  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 8002284:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 8002288:	f44f 5004 	mov.w	r0, #8448	; 0x2100
{
 800228c:	b083      	sub	sp, #12
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 800228e:	6823      	ldr	r3, [r4, #0]
 8002290:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8002294:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __IO uint32_t wait_loop_index = 0UL;
 8002298:	f04f 0c00 	mov.w	ip, #0
{
 800229c:	460d      	mov	r5, r1
 800229e:	4616      	mov	r6, r2
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80022a0:	42bb      	cmp	r3, r7
 80022a2:	bf18      	it	ne
 80022a4:	4283      	cmpne	r3, r0
  __IO uint32_t wait_loop_index = 0UL;
 80022a6:	f8cd c004 	str.w	ip, [sp, #4]
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 80022aa:	d005      	beq.n	80022b8 <HAL_ADCEx_Calibration_Start+0x38>
 80022ac:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 80022b0:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80022b4:	4293      	cmp	r3, r2
 80022b6:	d159      	bne.n	800236c <HAL_ADCEx_Calibration_Start+0xec>
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
 80022b8:	f240 73ff 	movw	r3, #2047	; 0x7ff
 80022bc:	429e      	cmp	r6, r3
 80022be:	d004      	beq.n	80022ca <HAL_ADCEx_Calibration_Start+0x4a>
 80022c0:	2300      	movs	r3, #0
 80022c2:	f2c4 73ff 	movt	r3, #18431	; 0x47ff
 80022c6:	429e      	cmp	r6, r3
 80022c8:	d142      	bne.n	8002350 <HAL_ADCEx_Calibration_Start+0xd0>

  /* Process locked */
  __HAL_LOCK(hadc);
 80022ca:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 80022ce:	2b01      	cmp	r3, #1
 80022d0:	d049      	beq.n	8002366 <HAL_ADCEx_Calibration_Start+0xe6>
 80022d2:	2301      	movs	r3, #1

  /* Calibration prerequisite: ADC must be disabled. */

  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 80022d4:	4620      	mov	r0, r4
  __HAL_LOCK(hadc);
 80022d6:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  tmp_hal_status = ADC_Disable(hadc);
 80022da:	f7ff fbfb 	bl	8001ad4 <ADC_Disable>

  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
 80022de:	bb70      	cbnz	r0, 800233e <HAL_ADCEx_Calibration_Start+0xbe>
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 80022e0:	f64e 61fd 	movw	r1, #61181	; 0xeefd
 80022e4:	6d62      	ldr	r2, [r4, #84]	; 0x54
  MODIFY_REG(ADCx->CR,
 80022e6:	f405 3380 	and.w	r3, r5, #65536	; 0x10000
                      HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
                      HAL_ADC_STATE_BUSY_INTERNAL);

    /* Start ADC calibration in mode single-ended or differential */
    LL_ADC_StartCalibration(hadc->Instance , CalibrationMode, SingleDiff );
 80022ea:	6827      	ldr	r7, [r4, #0]
    ADC_STATE_CLR_SET(hadc->State,
 80022ec:	f6cf 71ff 	movt	r1, #65535	; 0xffff
 80022f0:	f64f 75c0 	movw	r5, #65472	; 0xffc0
 80022f4:	f006 4680 	and.w	r6, r6, #1073741824	; 0x40000000
 80022f8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80022fc:	4011      	ands	r1, r2
 80022fe:	f6c3 75fe 	movt	r5, #16382	; 0x3ffe
 8002302:	4333      	orrs	r3, r6

    /* Wait for calibration completion */
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
    {
      wait_loop_index++;
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8002304:	f24f 72ff 	movw	r2, #63487	; 0xf7ff
    ADC_STATE_CLR_SET(hadc->State,
 8002308:	f041 0102 	orr.w	r1, r1, #2
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 800230c:	f2c2 52c3 	movt	r2, #9667	; 0x25c3
    ADC_STATE_CLR_SET(hadc->State,
 8002310:	6561      	str	r1, [r4, #84]	; 0x54
 8002312:	68b9      	ldr	r1, [r7, #8]
 8002314:	400d      	ands	r5, r1
 8002316:	432b      	orrs	r3, r5
 8002318:	60bb      	str	r3, [r7, #8]
    while (LL_ADC_IsCalibrationOnGoing(hadc->Instance) != 0UL)
 800231a:	6821      	ldr	r1, [r4, #0]
 800231c:	e005      	b.n	800232a <HAL_ADCEx_Calibration_Start+0xaa>
      wait_loop_index++;
 800231e:	9b01      	ldr	r3, [sp, #4]
 8002320:	3301      	adds	r3, #1
 8002322:	9301      	str	r3, [sp, #4]
      if (wait_loop_index >= ADC_CALIBRATION_TIMEOUT)
 8002324:	9b01      	ldr	r3, [sp, #4]
 8002326:	4293      	cmp	r3, r2
 8002328:	d828      	bhi.n	800237c <HAL_ADCEx_Calibration_Start+0xfc>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADCAL) == (ADC_CR_ADCAL)) ? 1UL : 0UL);
 800232a:	688b      	ldr	r3, [r1, #8]
 800232c:	2b00      	cmp	r3, #0
 800232e:	dbf6      	blt.n	800231e <HAL_ADCEx_Calibration_Start+0x9e>
        return HAL_ERROR;
      }
    }

    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8002330:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002332:	f023 0303 	bic.w	r3, r3, #3
 8002336:	f043 0301 	orr.w	r3, r3, #1
 800233a:	6563      	str	r3, [r4, #84]	; 0x54
 800233c:	e003      	b.n	8002346 <HAL_ADCEx_Calibration_Start+0xc6>
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800233e:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8002340:	f043 0310 	orr.w	r3, r3, #16
 8002344:	6563      	str	r3, [r4, #84]	; 0x54
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }

  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8002346:	2300      	movs	r3, #0
 8002348:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50

  /* Return function status */
  return tmp_hal_status;
}
 800234c:	b003      	add	sp, #12
 800234e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
 8002350:	f64d 1080 	movw	r0, #55680	; 0xd980
 8002354:	218f      	movs	r1, #143	; 0x8f
 8002356:	f6c0 0002 	movt	r0, #2050	; 0x802
 800235a:	f013 fa85 	bl	8015868 <assert_failed>
  __HAL_LOCK(hadc);
 800235e:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8002362:	2b01      	cmp	r3, #1
 8002364:	d1b5      	bne.n	80022d2 <HAL_ADCEx_Calibration_Start+0x52>
 8002366:	2002      	movs	r0, #2
}
 8002368:	b003      	add	sp, #12
 800236a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
 800236c:	f64d 1080 	movw	r0, #55680	; 0xd980
 8002370:	218e      	movs	r1, #142	; 0x8e
 8002372:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002376:	f013 fa77 	bl	8015868 <assert_failed>
 800237a:	e79d      	b.n	80022b8 <HAL_ADCEx_Calibration_Start+0x38>
        ADC_STATE_CLR_SET(hadc->State,
 800237c:	6d63      	ldr	r3, [r4, #84]	; 0x54
        __HAL_UNLOCK(hadc);
 800237e:	2200      	movs	r2, #0
        return HAL_ERROR;
 8002380:	2001      	movs	r0, #1
        ADC_STATE_CLR_SET(hadc->State,
 8002382:	f023 0312 	bic.w	r3, r3, #18
        __HAL_UNLOCK(hadc);
 8002386:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
        ADC_STATE_CLR_SET(hadc->State,
 800238a:	f043 0310 	orr.w	r3, r3, #16
 800238e:	6563      	str	r3, [r4, #84]	; 0x54
}
 8002390:	b003      	add	sp, #12
 8002392:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002394 <HAL_ADCEx_InjectedConvCpltCallback>:
  UNUSED(hadc);

  /* NOTE : This function should not be modified. When the callback is needed,
            function HAL_ADCEx_InjectedConvCpltCallback must be implemented in the user file.
  */
}
 8002394:	4770      	bx	lr
 8002396:	bf00      	nop

08002398 <HAL_ADCEx_InjectedQueueOverflowCallback>:
 8002398:	4770      	bx	lr
 800239a:	bf00      	nop

0800239c <HAL_ADCEx_LevelOutOfWindow2Callback>:
 800239c:	4770      	bx	lr
 800239e:	bf00      	nop

080023a0 <HAL_ADCEx_LevelOutOfWindow3Callback>:
 80023a0:	4770      	bx	lr
 80023a2:	bf00      	nop

080023a4 <HAL_ADCEx_EndOfSamplingCallback>:
 80023a4:	4770      	bx	lr
 80023a6:	bf00      	nop

080023a8 <HAL_ADCEx_MultiModeConfigChannel>:
  ADC_Common_TypeDef *tmpADC_Common;
  ADC_HandleTypeDef  tmphadcSlave;
  uint32_t tmphadcSlave_conversion_on_going;

  /* Check the parameters */
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 80023a8:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
 80023ac:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 80023ae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80023b2:	6802      	ldr	r2, [r0, #0]
{
 80023b4:	4604      	mov	r4, r0
 80023b6:	460d      	mov	r5, r1
  assert_param(IS_ADC_MULTIMODE_MASTER_INSTANCE(hadc->Instance));
 80023b8:	429a      	cmp	r2, r3
 80023ba:	d007      	beq.n	80023cc <HAL_ADCEx_MultiModeConfigChannel+0x24>
 80023bc:	f64d 1080 	movw	r0, #55680	; 0xd980
 80023c0:	f640 01bd 	movw	r1, #2237	; 0x8bd
 80023c4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80023c8:	f013 fa4e 	bl	8015868 <assert_failed>
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
 80023cc:	682b      	ldr	r3, [r5, #0]
 80023ce:	2b09      	cmp	r3, #9
 80023d0:	d93a      	bls.n	8002448 <HAL_ADCEx_MultiModeConfigChannel+0xa0>
 80023d2:	f64d 1080 	movw	r0, #55680	; 0xd980
 80023d6:	f640 01be 	movw	r1, #2238	; 0x8be
 80023da:	f6c0 0002 	movt	r0, #2050	; 0x802
 80023de:	f013 fa43 	bl	8015868 <assert_failed>
 80023e2:	682b      	ldr	r3, [r5, #0]
  if (multimode->Mode != ADC_MODE_INDEPENDENT)
 80023e4:	b1d3      	cbz	r3, 800241c <HAL_ADCEx_MultiModeConfigChannel+0x74>
  {
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
 80023e6:	686b      	ldr	r3, [r5, #4]
 80023e8:	f433 4200 	bics.w	r2, r3, #32768	; 0x8000
 80023ec:	d002      	beq.n	80023f4 <HAL_ADCEx_MultiModeConfigChannel+0x4c>
 80023ee:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 80023f2:	d16f      	bne.n	80024d4 <HAL_ADCEx_MultiModeConfigChannel+0x12c>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
 80023f4:	68ab      	ldr	r3, [r5, #8]
 80023f6:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80023fa:	bf18      	it	ne
 80023fc:	f5b3 6fe0 	cmpne.w	r3, #1792	; 0x700
 8002400:	bf14      	ite	ne
 8002402:	2201      	movne	r2, #1
 8002404:	2200      	moveq	r2, #0
 8002406:	f433 7140 	bics.w	r1, r3, #768	; 0x300
 800240a:	bf08      	it	eq
 800240c:	2200      	moveq	r2, #0
 800240e:	b12a      	cbz	r2, 800241c <HAL_ADCEx_MultiModeConfigChannel+0x74>
 8002410:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002414:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8002418:	f040 80a8 	bne.w	800256c <HAL_ADCEx_MultiModeConfigChannel+0x1c4>
  }

  /* Process locked */
  __HAL_LOCK(hadc);
 800241c:	f894 3050 	ldrb.w	r3, [r4, #80]	; 0x50
 8002420:	2b01      	cmp	r3, #1
 8002422:	d060      	beq.n	80024e6 <HAL_ADCEx_MultiModeConfigChannel+0x13e>

  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8002424:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002428:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(hadc);
 800242a:	2001      	movs	r0, #1
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 800242c:	f2c4 0302 	movt	r3, #16386	; 0x4002
  __HAL_LOCK(hadc);
 8002430:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50
  ADC_MULTI_SLAVE(hadc, &tmphadcSlave);
 8002434:	429a      	cmp	r2, r3
 8002436:	d00d      	beq.n	8002454 <HAL_ADCEx_MultiModeConfigChannel+0xac>

  if (tmphadcSlave.Instance == NULL)
  {
    /* Update ADC state machine to error */
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002438:	6d63      	ldr	r3, [r4, #84]	; 0x54

    /* Process unlocked */
    __HAL_UNLOCK(hadc);
 800243a:	2200      	movs	r2, #0
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 800243c:	f043 0320 	orr.w	r3, r3, #32
    __HAL_UNLOCK(hadc);
 8002440:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002444:	6563      	str	r3, [r4, #84]	; 0x54
  /* Process unlocked */
  __HAL_UNLOCK(hadc);

  /* Return function status */
  return tmp_hal_status;
}
 8002446:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_ADC_MULTIMODE(multimode->Mode));
 8002448:	f240 22ef 	movw	r2, #751	; 0x2ef
 800244c:	40da      	lsrs	r2, r3
 800244e:	07d6      	lsls	r6, r2, #31
 8002450:	d4c8      	bmi.n	80023e4 <HAL_ADCEx_MultiModeConfigChannel+0x3c>
 8002452:	e7be      	b.n	80023d2 <HAL_ADCEx_MultiModeConfigChannel+0x2a>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART)) ? 1UL : 0UL);
 8002454:	f44f 5304 	mov.w	r3, #8448	; 0x2100
 8002458:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800245c:	6899      	ldr	r1, [r3, #8]
 800245e:	0749      	lsls	r1, r1, #29
 8002460:	d509      	bpl.n	8002476 <HAL_ADCEx_MultiModeConfigChannel+0xce>
 8002462:	6893      	ldr	r3, [r2, #8]
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002464:	6d63      	ldr	r3, [r4, #84]	; 0x54
    tmp_hal_status = HAL_ERROR;
 8002466:	2001      	movs	r0, #1
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8002468:	f043 0320 	orr.w	r3, r3, #32
 800246c:	6563      	str	r3, [r4, #84]	; 0x54
  __HAL_UNLOCK(hadc);
 800246e:	2300      	movs	r3, #0
 8002470:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
}
 8002474:	bd70      	pop	{r4, r5, r6, pc}
 8002476:	6891      	ldr	r1, [r2, #8]
 8002478:	0748      	lsls	r0, r1, #29
 800247a:	d4f3      	bmi.n	8002464 <HAL_ADCEx_MultiModeConfigChannel+0xbc>
    if (multimode->Mode != ADC_MODE_INDEPENDENT)
 800247c:	6829      	ldr	r1, [r5, #0]
 800247e:	b3a1      	cbz	r1, 80024ea <HAL_ADCEx_MultiModeConfigChannel+0x142>
    MODIFY_REG(tmpADC_Common->CCR, ADC_CCR_DAMDF, multimode->DualModeData);
 8002480:	f44f 500c 	mov.w	r0, #8960	; 0x2300
 8002484:	686e      	ldr	r6, [r5, #4]
 8002486:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800248a:	6881      	ldr	r1, [r0, #8]
 800248c:	f421 4140 	bic.w	r1, r1, #49152	; 0xc000
 8002490:	4331      	orrs	r1, r6
 8002492:	6081      	str	r1, [r0, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 8002494:	6821      	ldr	r1, [r4, #0]
 8002496:	4291      	cmp	r1, r2
 8002498:	d059      	beq.n	800254e <HAL_ADCEx_MultiModeConfigChannel+0x1a6>
 800249a:	4299      	cmp	r1, r3
 800249c:	d057      	beq.n	800254e <HAL_ADCEx_MultiModeConfigChannel+0x1a6>
  return ((READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN)) ? 1UL : 0UL);
 800249e:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 80024a2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80024a6:	689b      	ldr	r3, [r3, #8]
 80024a8:	43db      	mvns	r3, r3
 80024aa:	f003 0301 	and.w	r3, r3, #1
 80024ae:	2b00      	cmp	r3, #0
 80024b0:	d065      	beq.n	800257e <HAL_ADCEx_MultiModeConfigChannel+0x1d6>
        MODIFY_REG(tmpADC_Common->CCR,
 80024b2:	f44f 510c 	mov.w	r1, #8960	; 0x2300
 80024b6:	f24f 02e0 	movw	r2, #61664	; 0xf0e0
 80024ba:	68a8      	ldr	r0, [r5, #8]
 80024bc:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80024c0:	682b      	ldr	r3, [r5, #0]
 80024c2:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 80024c6:	688d      	ldr	r5, [r1, #8]
 80024c8:	4303      	orrs	r3, r0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 80024ca:	2000      	movs	r0, #0
        MODIFY_REG(tmpADC_Common->CCR,
 80024cc:	402a      	ands	r2, r5
 80024ce:	4313      	orrs	r3, r2
 80024d0:	608b      	str	r3, [r1, #8]
 80024d2:	e7cc      	b.n	800246e <HAL_ADCEx_MultiModeConfigChannel+0xc6>
    assert_param(IS_ADC_DUAL_DATA_MODE(multimode->DualModeData));
 80024d4:	f64d 1080 	movw	r0, #55680	; 0xd980
 80024d8:	f640 01c1 	movw	r1, #2241	; 0x8c1
 80024dc:	f6c0 0002 	movt	r0, #2050	; 0x802
 80024e0:	f013 f9c2 	bl	8015868 <assert_failed>
 80024e4:	e786      	b.n	80023f4 <HAL_ADCEx_MultiModeConfigChannel+0x4c>
  __HAL_LOCK(hadc);
 80024e6:	2002      	movs	r0, #2
}
 80024e8:	bd70      	pop	{r4, r5, r6, pc}
      CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DAMDF);
 80024ea:	f44f 510c 	mov.w	r1, #8960	; 0x2300
 80024ee:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80024f2:	6888      	ldr	r0, [r1, #8]
 80024f4:	f420 4040 	bic.w	r0, r0, #49152	; 0xc000
 80024f8:	6088      	str	r0, [r1, #8]
      if (__LL_ADC_IS_ENABLED_ALL_COMMON_INSTANCE(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) == 0UL)
 80024fa:	6821      	ldr	r1, [r4, #0]
 80024fc:	4291      	cmp	r1, r2
 80024fe:	d017      	beq.n	8002530 <HAL_ADCEx_MultiModeConfigChannel+0x188>
 8002500:	4299      	cmp	r1, r3
 8002502:	d015      	beq.n	8002530 <HAL_ADCEx_MultiModeConfigChannel+0x188>
 8002504:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 8002508:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800250c:	689b      	ldr	r3, [r3, #8]
 800250e:	43db      	mvns	r3, r3
 8002510:	f003 0301 	and.w	r3, r3, #1
 8002514:	b39b      	cbz	r3, 800257e <HAL_ADCEx_MultiModeConfigChannel+0x1d6>
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8002516:	f44f 520c 	mov.w	r2, #8960	; 0x2300
 800251a:	f24f 03e0 	movw	r3, #61664	; 0xf0e0
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800251e:	2000      	movs	r0, #0
        CLEAR_BIT(tmpADC_Common->CCR, ADC_CCR_DUAL | ADC_CCR_DELAY);
 8002520:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002524:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8002528:	6891      	ldr	r1, [r2, #8]
 800252a:	400b      	ands	r3, r1
 800252c:	6093      	str	r3, [r2, #8]
 800252e:	e79e      	b.n	800246e <HAL_ADCEx_MultiModeConfigChannel+0xc6>
 8002530:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002534:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8002538:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800253c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8002540:	6899      	ldr	r1, [r3, #8]
 8002542:	6893      	ldr	r3, [r2, #8]
 8002544:	430b      	orrs	r3, r1
 8002546:	43db      	mvns	r3, r3
 8002548:	f003 0301 	and.w	r3, r3, #1
 800254c:	e7e2      	b.n	8002514 <HAL_ADCEx_MultiModeConfigChannel+0x16c>
 800254e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8002552:	f44f 5204 	mov.w	r2, #8448	; 0x2100
 8002556:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800255a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 800255e:	6899      	ldr	r1, [r3, #8]
 8002560:	6893      	ldr	r3, [r2, #8]
 8002562:	430b      	orrs	r3, r1
 8002564:	43db      	mvns	r3, r3
 8002566:	f003 0301 	and.w	r3, r3, #1
 800256a:	e7a0      	b.n	80024ae <HAL_ADCEx_MultiModeConfigChannel+0x106>
    assert_param(IS_ADC_SAMPLING_DELAY(multimode->TwoSamplingDelay));
 800256c:	f64d 1080 	movw	r0, #55680	; 0xd980
 8002570:	f640 01c2 	movw	r1, #2242	; 0x8c2
 8002574:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002578:	f013 f976 	bl	8015868 <assert_failed>
 800257c:	e74e      	b.n	800241c <HAL_ADCEx_MultiModeConfigChannel+0x74>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800257e:	2000      	movs	r0, #0
 8002580:	e775      	b.n	800246e <HAL_ADCEx_MultiModeConfigChannel+0xc6>
 8002582:	bf00      	nop

08002584 <HAL_NVIC_SetPriorityGrouping>:
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 8002584:	1ec3      	subs	r3, r0, #3
 8002586:	2b04      	cmp	r3, #4
{
 8002588:	b510      	push	{r4, lr}
 800258a:	4604      	mov	r4, r0
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
 800258c:	d906      	bls.n	800259c <HAL_NVIC_SetPriorityGrouping+0x18>
 800258e:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002592:	2192      	movs	r1, #146	; 0x92
 8002594:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002598:	f013 f966 	bl	8015868 <assert_failed>
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800259c:	f44f 426d 	mov.w	r2, #60672	; 0xed00
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80025a0:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 80025a4:	2300      	movs	r3, #0
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80025a6:	0224      	lsls	r4, r4, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80025a8:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80025ac:	f2c0 53fa 	movt	r3, #1530	; 0x5fa
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80025b0:	f404 64e0 	and.w	r4, r4, #1792	; 0x700
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80025b4:	68d1      	ldr	r1, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80025b6:	4001      	ands	r1, r0
 80025b8:	430b      	orrs	r3, r1
  reg_value  =  (reg_value                                   |
 80025ba:	431c      	orrs	r4, r3
  SCB->AIRCR =  reg_value;
 80025bc:	60d4      	str	r4, [r2, #12]

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 80025be:	bd10      	pop	{r4, pc}

080025c0 <HAL_NVIC_SetPriority>:
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80025c0:	2a0f      	cmp	r2, #15
{
 80025c2:	b570      	push	{r4, r5, r6, lr}
 80025c4:	4616      	mov	r6, r2
 80025c6:	4605      	mov	r5, r0
 80025c8:	460c      	mov	r4, r1
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 80025ca:	d841      	bhi.n	8002650 <HAL_NVIC_SetPriority+0x90>
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 80025cc:	2c0f      	cmp	r4, #15
 80025ce:	d837      	bhi.n	8002640 <HAL_NVIC_SetPriority+0x80>
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 80025d0:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 80025d4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 80025d8:	68db      	ldr	r3, [r3, #12]
 80025da:	f3c3 2302 	ubfx	r3, r3, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80025de:	f1c3 0107 	rsb	r1, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80025e2:	1d1a      	adds	r2, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 80025e4:	2904      	cmp	r1, #4
 80025e6:	bf28      	it	cs
 80025e8:	2104      	movcs	r1, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80025ea:	2a06      	cmp	r2, #6
 80025ec:	d91c      	bls.n	8002628 <HAL_NVIC_SetPriority+0x68>
 80025ee:	3b03      	subs	r3, #3
 80025f0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80025f4:	409a      	lsls	r2, r3
 80025f6:	ea26 0602 	bic.w	r6, r6, r2

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80025fa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  if ((int32_t)(IRQn) >= 0)
 80025fe:	2d00      	cmp	r5, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8002600:	fa02 f201 	lsl.w	r2, r2, r1
 8002604:	ea24 0202 	bic.w	r2, r4, r2
 8002608:	fa02 f203 	lsl.w	r2, r2, r3
 800260c:	ea42 0206 	orr.w	r2, r2, r6
 8002610:	ea4f 1202 	mov.w	r2, r2, lsl #4
 8002614:	b2d2      	uxtb	r2, r2
  if ((int32_t)(IRQn) >= 0)
 8002616:	db0a      	blt.n	800262e <HAL_NVIC_SetPriority+0x6e>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8002618:	f44f 4361 	mov.w	r3, #57600	; 0xe100
 800261c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002620:	442b      	add	r3, r5
 8002622:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8002626:	bd70      	pop	{r4, r5, r6, pc}
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8002628:	2600      	movs	r6, #0
 800262a:	4633      	mov	r3, r6
 800262c:	e7e5      	b.n	80025fa <HAL_NVIC_SetPriority+0x3a>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800262e:	f64e 43fc 	movw	r3, #60668	; 0xecfc
 8002632:	f005 050f 	and.w	r5, r5, #15
 8002636:	f2ce 0300 	movt	r3, #57344	; 0xe000
 800263a:	442b      	add	r3, r5
 800263c:	761a      	strb	r2, [r3, #24]
 800263e:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
 8002640:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002644:	21ab      	movs	r1, #171	; 0xab
 8002646:	f6c0 0002 	movt	r0, #2050	; 0x802
 800264a:	f013 f90d 	bl	8015868 <assert_failed>
 800264e:	e7bf      	b.n	80025d0 <HAL_NVIC_SetPriority+0x10>
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
 8002650:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002654:	21aa      	movs	r1, #170	; 0xaa
 8002656:	f6c0 0002 	movt	r0, #2050	; 0x802
 800265a:	f013 f905 	bl	8015868 <assert_failed>
 800265e:	e7b5      	b.n	80025cc <HAL_NVIC_SetPriority+0xc>

08002660 <HAL_NVIC_EnableIRQ>:
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 8002660:	2800      	cmp	r0, #0
 8002662:	db0b      	blt.n	800267c <HAL_NVIC_EnableIRQ+0x1c>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002664:	f000 011f 	and.w	r1, r0, #31
 8002668:	2301      	movs	r3, #1
 800266a:	f44f 4261 	mov.w	r2, #57600	; 0xe100
 800266e:	0940      	lsrs	r0, r0, #5
 8002670:	408b      	lsls	r3, r1
 8002672:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8002676:	f842 3020 	str.w	r3, [r2, r0, lsl #2]

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 800267a:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800267c:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002680:	21be      	movs	r1, #190	; 0xbe
 8002682:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002686:	f013 b8ef 	b.w	8015868 <assert_failed>
 800268a:	bf00      	nop

0800268c <HAL_NVIC_DisableIRQ>:
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 800268c:	2800      	cmp	r0, #0
 800268e:	db11      	blt.n	80026b4 <HAL_NVIC_DisableIRQ+0x28>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8002690:	0943      	lsrs	r3, r0, #5
 8002692:	2201      	movs	r2, #1
 8002694:	f000 001f 	and.w	r0, r0, #31
 8002698:	f44f 4161 	mov.w	r1, #57600	; 0xe100
 800269c:	3320      	adds	r3, #32
 800269e:	fa02 f000 	lsl.w	r0, r2, r0
 80026a2:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80026a6:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
 80026aa:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80026ae:	f3bf 8f6f 	isb	sy

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
}
 80026b2:	4770      	bx	lr
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
 80026b4:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 80026b8:	21ce      	movs	r1, #206	; 0xce
 80026ba:	f6c0 0002 	movt	r0, #2050	; 0x802
 80026be:	f013 b8d3 	b.w	8015868 <assert_failed>
 80026c2:	bf00      	nop

080026c4 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80026c4:	3801      	subs	r0, #1
 80026c6:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80026ca:	d213      	bcs.n	80026f4 <HAL_SYSTICK_Config+0x30>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80026cc:	f24e 0310 	movw	r3, #57360	; 0xe010
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80026d0:	f44f 416d 	mov.w	r1, #60672	; 0xed00
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80026d4:	2200      	movs	r2, #0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80026d6:	f2ce 0300 	movt	r3, #57344	; 0xe000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80026da:	f2ce 0100 	movt	r1, #57344	; 0xe000
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status   - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 80026de:	b430      	push	{r4, r5}
 80026e0:	25f0      	movs	r5, #240	; 0xf0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80026e2:	2407      	movs	r4, #7
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80026e4:	6058      	str	r0, [r3, #4]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80026e6:	4610      	mov	r0, r2
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80026e8:	f881 5023 	strb.w	r5, [r1, #35]	; 0x23
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80026ec:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80026ee:	601c      	str	r4, [r3, #0]
   return SysTick_Config(TicksNumb);
}
 80026f0:	bc30      	pop	{r4, r5}
 80026f2:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80026f4:	2001      	movs	r0, #1
 80026f6:	4770      	bx	lr

080026f8 <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
 80026f8:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 80026fc:	f44f 436d 	mov.w	r3, #60672	; 0xed00

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 8002700:	f64e 5190 	movw	r1, #60816	; 0xed90
 8002704:	2000      	movs	r0, #0
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8002706:	f2ce 0300 	movt	r3, #57344	; 0xe000
  MPU->CTRL = 0;
 800270a:	f2ce 0100 	movt	r1, #57344	; 0xe000
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 800270e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002710:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002714:	625a      	str	r2, [r3, #36]	; 0x24
  MPU->CTRL = 0;
 8002716:	6048      	str	r0, [r1, #4]
}
 8002718:	4770      	bx	lr
 800271a:	bf00      	nop

0800271c <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800271c:	f64e 5290 	movw	r2, #60816	; 0xed90

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8002720:	f44f 436d 	mov.w	r3, #60672	; 0xed00
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8002724:	f040 0001 	orr.w	r0, r0, #1
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8002728:	f2ce 0300 	movt	r3, #57344	; 0xe000
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 800272c:	f2ce 0200 	movt	r2, #57344	; 0xe000
 8002730:	6050      	str	r0, [r2, #4]
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8002732:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8002734:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002738:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 800273a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800273e:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 8002742:	4770      	bx	lr

08002744 <HAL_MPU_ConfigRegion>:
  * @param  MPU_Init Pointer to a MPU_Region_InitTypeDef structure that contains
  *                  the initialization and configuration information.
  * @retval None
  */
void HAL_MPU_ConfigRegion(MPU_Region_InitTypeDef *MPU_Init)
{
 8002744:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 8002746:	7843      	ldrb	r3, [r0, #1]
{
 8002748:	4604      	mov	r4, r0
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800274a:	2b0f      	cmp	r3, #15
 800274c:	f200 8087 	bhi.w	800285e <HAL_MPU_ConfigRegion+0x11a>
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));
 8002750:	7823      	ldrb	r3, [r4, #0]
 8002752:	2b01      	cmp	r3, #1
 8002754:	d907      	bls.n	8002766 <HAL_MPU_ConfigRegion+0x22>
 8002756:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 800275a:	f44f 7197 	mov.w	r1, #302	; 0x12e
 800275e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002762:	f013 f881 	bl	8015868 <assert_failed>

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8002766:	f64e 5390 	movw	r3, #60816	; 0xed90
 800276a:	7862      	ldrb	r2, [r4, #1]
 800276c:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8002770:	609a      	str	r2, [r3, #8]

  if ((MPU_Init->Enable) != 0UL)
 8002772:	7822      	ldrb	r2, [r4, #0]
 8002774:	2a00      	cmp	r2, #0
 8002776:	d03e      	beq.n	80027f6 <HAL_MPU_ConfigRegion+0xb2>
  {
    /* Check the parameters */
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 8002778:	7b23      	ldrb	r3, [r4, #12]
 800277a:	2b01      	cmp	r3, #1
 800277c:	d83e      	bhi.n	80027fc <HAL_MPU_ConfigRegion+0xb8>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 800277e:	7ae3      	ldrb	r3, [r4, #11]
 8002780:	1f5a      	subs	r2, r3, #5
 8002782:	2a01      	cmp	r2, #1
 8002784:	d902      	bls.n	800278c <HAL_MPU_ConfigRegion+0x48>
 8002786:	2b03      	cmp	r3, #3
 8002788:	f200 8088 	bhi.w	800289c <HAL_MPU_ConfigRegion+0x158>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 800278c:	7aa3      	ldrb	r3, [r4, #10]
 800278e:	2b02      	cmp	r3, #2
 8002790:	d877      	bhi.n	8002882 <HAL_MPU_ConfigRegion+0x13e>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8002792:	7b63      	ldrb	r3, [r4, #13]
 8002794:	2b01      	cmp	r3, #1
 8002796:	d856      	bhi.n	8002846 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8002798:	7ba3      	ldrb	r3, [r4, #14]
 800279a:	2b01      	cmp	r3, #1
 800279c:	d847      	bhi.n	800282e <HAL_MPU_ConfigRegion+0xea>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 800279e:	7be3      	ldrb	r3, [r4, #15]
 80027a0:	2b01      	cmp	r3, #1
 80027a2:	d838      	bhi.n	8002816 <HAL_MPU_ConfigRegion+0xd2>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 80027a4:	7a63      	ldrb	r3, [r4, #9]
 80027a6:	2bff      	cmp	r3, #255	; 0xff
 80027a8:	f000 8085 	beq.w	80028b6 <HAL_MPU_ConfigRegion+0x172>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 80027ac:	7a23      	ldrb	r3, [r4, #8]
 80027ae:	3b04      	subs	r3, #4
 80027b0:	2b1b      	cmp	r3, #27
 80027b2:	d85d      	bhi.n	8002870 <HAL_MPU_ConfigRegion+0x12c>

    MPU->RBAR = MPU_Init->BaseAddress;
 80027b4:	f64e 5290 	movw	r2, #60816	; 0xed90
 80027b8:	6863      	ldr	r3, [r4, #4]
 80027ba:	f2ce 0200 	movt	r2, #57344	; 0xe000
 80027be:	60d3      	str	r3, [r2, #12]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80027c0:	7ae3      	ldrb	r3, [r4, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80027c2:	7b21      	ldrb	r1, [r4, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 80027c4:	061b      	lsls	r3, r3, #24
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
                ((uint32_t)MPU_Init->Enable                  << MPU_RASR_ENABLE_Pos);
 80027c6:	7825      	ldrb	r5, [r4, #0]
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 80027c8:	7aa0      	ldrb	r0, [r4, #10]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80027ca:	ea43 7301 	orr.w	r3, r3, r1, lsl #28
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 80027ce:	7b61      	ldrb	r1, [r4, #13]
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 80027d0:	7ba6      	ldrb	r6, [r4, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80027d2:	432b      	orrs	r3, r5
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 80027d4:	7be5      	ldrb	r5, [r4, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80027d6:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 80027da:	7a60      	ldrb	r0, [r4, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 80027dc:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
 80027e0:	7a21      	ldrb	r1, [r4, #8]
 80027e2:	ea43 4346 	orr.w	r3, r3, r6, lsl #17
 80027e6:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 80027ea:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80027ee:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 80027f2:	6113      	str	r3, [r2, #16]
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 80027f4:	bd70      	pop	{r4, r5, r6, pc}
    MPU->RBAR = 0x00;
 80027f6:	60da      	str	r2, [r3, #12]
    MPU->RASR = 0x00;
 80027f8:	611a      	str	r2, [r3, #16]
}
 80027fa:	bd70      	pop	{r4, r5, r6, pc}
    assert_param(IS_MPU_INSTRUCTION_ACCESS(MPU_Init->DisableExec));
 80027fc:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002800:	f44f 719b 	mov.w	r1, #310	; 0x136
 8002804:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002808:	f013 f82e 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 800280c:	7ae3      	ldrb	r3, [r4, #11]
 800280e:	1f5a      	subs	r2, r3, #5
 8002810:	2a01      	cmp	r2, #1
 8002812:	d8b8      	bhi.n	8002786 <HAL_MPU_ConfigRegion+0x42>
 8002814:	e7ba      	b.n	800278c <HAL_MPU_ConfigRegion+0x48>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 8002816:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 800281a:	f240 113b 	movw	r1, #315	; 0x13b
 800281e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002822:	f013 f821 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 8002826:	7a63      	ldrb	r3, [r4, #9]
 8002828:	2bff      	cmp	r3, #255	; 0xff
 800282a:	d1bf      	bne.n	80027ac <HAL_MPU_ConfigRegion+0x68>
 800282c:	e043      	b.n	80028b6 <HAL_MPU_ConfigRegion+0x172>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 800282e:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002832:	f44f 719d 	mov.w	r1, #314	; 0x13a
 8002836:	f6c0 0002 	movt	r0, #2050	; 0x802
 800283a:	f013 f815 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
 800283e:	7be3      	ldrb	r3, [r4, #15]
 8002840:	2b01      	cmp	r3, #1
 8002842:	d9af      	bls.n	80027a4 <HAL_MPU_ConfigRegion+0x60>
 8002844:	e7e7      	b.n	8002816 <HAL_MPU_ConfigRegion+0xd2>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8002846:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 800284a:	f240 1139 	movw	r1, #313	; 0x139
 800284e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002852:	f013 f809 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
 8002856:	7ba3      	ldrb	r3, [r4, #14]
 8002858:	2b01      	cmp	r3, #1
 800285a:	d9a0      	bls.n	800279e <HAL_MPU_ConfigRegion+0x5a>
 800285c:	e7e7      	b.n	800282e <HAL_MPU_ConfigRegion+0xea>
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
 800285e:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002862:	f240 112d 	movw	r1, #301	; 0x12d
 8002866:	f6c0 0002 	movt	r0, #2050	; 0x802
 800286a:	f012 fffd 	bl	8015868 <assert_failed>
 800286e:	e76f      	b.n	8002750 <HAL_MPU_ConfigRegion+0xc>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 8002870:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002874:	f240 113d 	movw	r1, #317	; 0x13d
 8002878:	f6c0 0002 	movt	r0, #2050	; 0x802
 800287c:	f012 fff4 	bl	8015868 <assert_failed>
 8002880:	e798      	b.n	80027b4 <HAL_MPU_ConfigRegion+0x70>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 8002882:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 8002886:	f44f 719c 	mov.w	r1, #312	; 0x138
 800288a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800288e:	f012 ffeb 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_ACCESS_SHAREABLE(MPU_Init->IsShareable));
 8002892:	7b63      	ldrb	r3, [r4, #13]
 8002894:	2b01      	cmp	r3, #1
 8002896:	f67f af7f 	bls.w	8002798 <HAL_MPU_ConfigRegion+0x54>
 800289a:	e7d4      	b.n	8002846 <HAL_MPU_ConfigRegion+0x102>
    assert_param(IS_MPU_REGION_PERMISSION_ATTRIBUTE(MPU_Init->AccessPermission));
 800289c:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 80028a0:	f240 1137 	movw	r1, #311	; 0x137
 80028a4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80028a8:	f012 ffde 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_TEX_LEVEL(MPU_Init->TypeExtField));
 80028ac:	7aa3      	ldrb	r3, [r4, #10]
 80028ae:	2b02      	cmp	r3, #2
 80028b0:	f67f af6f 	bls.w	8002792 <HAL_MPU_ConfigRegion+0x4e>
 80028b4:	e7e5      	b.n	8002882 <HAL_MPU_ConfigRegion+0x13e>
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
 80028b6:	f64d 10bc 	movw	r0, #55740	; 0xd9bc
 80028ba:	f44f 719e 	mov.w	r1, #316	; 0x13c
 80028be:	f6c0 0002 	movt	r0, #2050	; 0x802
 80028c2:	f012 ffd1 	bl	8015868 <assert_failed>
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));
 80028c6:	7a23      	ldrb	r3, [r4, #8]
 80028c8:	3b04      	subs	r3, #4
 80028ca:	2b1b      	cmp	r3, #27
 80028cc:	f67f af72 	bls.w	80027b4 <HAL_MPU_ConfigRegion+0x70>
 80028d0:	e7ce      	b.n	8002870 <HAL_MPU_ConfigRegion+0x12c>
 80028d2:	bf00      	nop

080028d4 <DMA_CalcBaseAndBitshift>:
  * @param  hdma:       pointer to a DMA_HandleTypeDef structure that contains
  *                     the configuration information for the specified DMA Stream.
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
 80028d4:	b430      	push	{r4, r5}
 80028d6:	4601      	mov	r1, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80028d8:	2310      	movs	r3, #16
 80028da:	2428      	movs	r4, #40	; 0x28
 80028dc:	2040      	movs	r0, #64	; 0x40
 80028de:	680a      	ldr	r2, [r1, #0]
 80028e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80028e4:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80028e8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80028ec:	2558      	movs	r5, #88	; 0x58
 80028ee:	42a2      	cmp	r2, r4
 80028f0:	bf18      	it	ne
 80028f2:	429a      	cmpne	r2, r3
 80028f4:	f04f 0470 	mov.w	r4, #112	; 0x70
 80028f8:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80028fc:	bf0c      	ite	eq
 80028fe:	2301      	moveq	r3, #1
 8002900:	2300      	movne	r3, #0
 8002902:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8002906:	4282      	cmp	r2, r0
 8002908:	bf08      	it	eq
 800290a:	f043 0301 	orreq.w	r3, r3, #1
 800290e:	2088      	movs	r0, #136	; 0x88
 8002910:	42aa      	cmp	r2, r5
 8002912:	bf08      	it	eq
 8002914:	f043 0301 	orreq.w	r3, r3, #1
 8002918:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800291c:	25a0      	movs	r5, #160	; 0xa0
 800291e:	42a2      	cmp	r2, r4
 8002920:	bf08      	it	eq
 8002922:	f043 0301 	orreq.w	r3, r3, #1
 8002926:	24b8      	movs	r4, #184	; 0xb8
 8002928:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800292c:	4282      	cmp	r2, r0
 800292e:	bf08      	it	eq
 8002930:	f043 0301 	orreq.w	r3, r3, #1
 8002934:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8002938:	f44f 6082 	mov.w	r0, #1040	; 0x410
 800293c:	42aa      	cmp	r2, r5
 800293e:	bf08      	it	eq
 8002940:	f043 0301 	orreq.w	r3, r3, #1
 8002944:	f44f 6585 	mov.w	r5, #1064	; 0x428
 8002948:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800294c:	42a2      	cmp	r2, r4
 800294e:	bf08      	it	eq
 8002950:	f043 0301 	orreq.w	r3, r3, #1
 8002954:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8002958:	f44f 6488 	mov.w	r4, #1088	; 0x440
 800295c:	4282      	cmp	r2, r0
 800295e:	bf08      	it	eq
 8002960:	f043 0301 	orreq.w	r3, r3, #1
 8002964:	f44f 608b 	mov.w	r0, #1112	; 0x458
 8002968:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800296c:	42aa      	cmp	r2, r5
 800296e:	bf08      	it	eq
 8002970:	f043 0301 	orreq.w	r3, r3, #1
 8002974:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002978:	f44f 658e 	mov.w	r5, #1136	; 0x470
 800297c:	42a2      	cmp	r2, r4
 800297e:	bf08      	it	eq
 8002980:	f043 0301 	orreq.w	r3, r3, #1
 8002984:	f44f 6491 	mov.w	r4, #1160	; 0x488
 8002988:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800298c:	4282      	cmp	r2, r0
 800298e:	bf08      	it	eq
 8002990:	f043 0301 	orreq.w	r3, r3, #1
 8002994:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8002998:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 800299c:	42aa      	cmp	r2, r5
 800299e:	bf08      	it	eq
 80029a0:	f043 0301 	orreq.w	r3, r3, #1
 80029a4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80029a8:	42a2      	cmp	r2, r4
 80029aa:	bf08      	it	eq
 80029ac:	f043 0301 	orreq.w	r3, r3, #1
 80029b0:	4282      	cmp	r2, r0
 80029b2:	bf08      	it	eq
 80029b4:	f043 0301 	orreq.w	r3, r3, #1
 80029b8:	b92b      	cbnz	r3, 80029c6 <DMA_CalcBaseAndBitshift+0xf2>
 80029ba:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 80029be:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80029c2:	429a      	cmp	r2, r3
 80029c4:	d11b      	bne.n	80029fe <DMA_CalcBaseAndBitshift+0x12a>
  {
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80029c6:	b2d3      	uxtb	r3, r2
 80029c8:	f64a 25ab 	movw	r5, #43691	; 0xaaab
 80029cc:	f44f 407c 	mov.w	r0, #64512	; 0xfc00

    /* lookup table for necessary bitshift of flags within status registers */
    static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80029d0:	f64d 2430 	movw	r4, #55856	; 0xda30
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80029d4:	3b10      	subs	r3, #16
 80029d6:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
 80029da:	f6cf 70ff 	movt	r0, #65535	; 0xffff
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80029de:	f6c0 0402 	movt	r4, #2050	; 0x802
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80029e2:	fba5 5303 	umull	r5, r3, r5, r3
 80029e6:	4010      	ands	r0, r2
 80029e8:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80029ea:	f003 0207 	and.w	r2, r3, #7

    if (stream_number > 3U)
 80029ee:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80029f0:	5ca2      	ldrb	r2, [r4, r2]
    {
      /* return pointer to HISR and HIFCR */
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 80029f2:	bf88      	it	hi
 80029f4:	3004      	addhi	r0, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80029f6:	65ca      	str	r2, [r1, #92]	; 0x5c
    }
    else
    {
      /* return pointer to LISR and LIFCR */
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 80029f8:	6588      	str	r0, [r1, #88]	; 0x58
    /* return pointer to ISR and IFCR */
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
  }

  return hdma->StreamBaseAddress;
}
 80029fa:	bc30      	pop	{r4, r5}
 80029fc:	4770      	bx	lr
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 80029fe:	f022 00ff 	bic.w	r0, r2, #255	; 0xff
 8002a02:	6588      	str	r0, [r1, #88]	; 0x58
 8002a04:	e7f9      	b.n	80029fa <DMA_CalcBaseAndBitshift+0x126>
 8002a06:	bf00      	nop

08002a08 <HAL_DMA_Init>:
{
 8002a08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002a0c:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8002a0e:	f7fe f815 	bl	8000a3c <HAL_GetTick>
  if(hdma == NULL)
 8002a12:	2d00      	cmp	r5, #0
 8002a14:	f000 835c 	beq.w	80030d0 <HAL_DMA_Init+0x6c8>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 8002a18:	2310      	movs	r3, #16
 8002a1a:	2128      	movs	r1, #40	; 0x28
 8002a1c:	682a      	ldr	r2, [r5, #0]
 8002a1e:	4604      	mov	r4, r0
 8002a20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002a24:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002a28:	2040      	movs	r0, #64	; 0x40
 8002a2a:	2670      	movs	r6, #112	; 0x70
 8002a2c:	429a      	cmp	r2, r3
 8002a2e:	bf18      	it	ne
 8002a30:	428a      	cmpne	r2, r1
 8002a32:	f04f 0158 	mov.w	r1, #88	; 0x58
 8002a36:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002a3a:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002a3e:	bf14      	ite	ne
 8002a40:	2301      	movne	r3, #1
 8002a42:	2300      	moveq	r3, #0
 8002a44:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002a48:	4282      	cmp	r2, r0
 8002a4a:	bf0c      	ite	eq
 8002a4c:	2300      	moveq	r3, #0
 8002a4e:	f003 0301 	andne.w	r3, r3, #1
 8002a52:	20a0      	movs	r0, #160	; 0xa0
 8002a54:	428a      	cmp	r2, r1
 8002a56:	bf0c      	ite	eq
 8002a58:	2300      	moveq	r3, #0
 8002a5a:	f003 0301 	andne.w	r3, r3, #1
 8002a5e:	2188      	movs	r1, #136	; 0x88
 8002a60:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002a64:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002a68:	42b2      	cmp	r2, r6
 8002a6a:	bf0c      	ite	eq
 8002a6c:	2300      	moveq	r3, #0
 8002a6e:	f003 0301 	andne.w	r3, r3, #1
 8002a72:	f44f 6682 	mov.w	r6, #1040	; 0x410
 8002a76:	428a      	cmp	r2, r1
 8002a78:	bf0c      	ite	eq
 8002a7a:	2300      	moveq	r3, #0
 8002a7c:	f003 0301 	andne.w	r3, r3, #1
 8002a80:	21b8      	movs	r1, #184	; 0xb8
 8002a82:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002a86:	4282      	cmp	r2, r0
 8002a88:	bf0c      	ite	eq
 8002a8a:	2300      	moveq	r3, #0
 8002a8c:	f003 0301 	andne.w	r3, r3, #1
 8002a90:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002a94:	f44f 6088 	mov.w	r0, #1088	; 0x440
 8002a98:	428a      	cmp	r2, r1
 8002a9a:	bf0c      	ite	eq
 8002a9c:	2300      	moveq	r3, #0
 8002a9e:	f003 0301 	andne.w	r3, r3, #1
 8002aa2:	f44f 6185 	mov.w	r1, #1064	; 0x428
 8002aa6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002aaa:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002aae:	42b2      	cmp	r2, r6
 8002ab0:	bf0c      	ite	eq
 8002ab2:	2300      	moveq	r3, #0
 8002ab4:	f003 0301 	andne.w	r3, r3, #1
 8002ab8:	f44f 668e 	mov.w	r6, #1136	; 0x470
 8002abc:	428a      	cmp	r2, r1
 8002abe:	bf0c      	ite	eq
 8002ac0:	2300      	moveq	r3, #0
 8002ac2:	f003 0301 	andne.w	r3, r3, #1
 8002ac6:	f44f 618b 	mov.w	r1, #1112	; 0x458
 8002aca:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002ace:	4282      	cmp	r2, r0
 8002ad0:	bf0c      	ite	eq
 8002ad2:	2300      	moveq	r3, #0
 8002ad4:	f003 0301 	andne.w	r3, r3, #1
 8002ad8:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002adc:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 8002ae0:	428a      	cmp	r2, r1
 8002ae2:	bf0c      	ite	eq
 8002ae4:	2300      	moveq	r3, #0
 8002ae6:	f003 0301 	andne.w	r3, r3, #1
 8002aea:	f44f 6191 	mov.w	r1, #1160	; 0x488
 8002aee:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002af2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002af6:	42b2      	cmp	r2, r6
 8002af8:	bf0c      	ite	eq
 8002afa:	2300      	moveq	r3, #0
 8002afc:	f003 0301 	andne.w	r3, r3, #1
 8002b00:	f245 4608 	movw	r6, #21512	; 0x5408
 8002b04:	428a      	cmp	r2, r1
 8002b06:	bf0c      	ite	eq
 8002b08:	2300      	moveq	r3, #0
 8002b0a:	f003 0301 	andne.w	r3, r3, #1
 8002b0e:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
 8002b12:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8002b16:	4282      	cmp	r2, r0
 8002b18:	bf0c      	ite	eq
 8002b1a:	2300      	moveq	r3, #0
 8002b1c:	f003 0301 	andne.w	r3, r3, #1
 8002b20:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002b24:	f245 4030 	movw	r0, #21552	; 0x5430
 8002b28:	428a      	cmp	r2, r1
 8002b2a:	bf0c      	ite	eq
 8002b2c:	2300      	moveq	r3, #0
 8002b2e:	f003 0301 	andne.w	r3, r3, #1
 8002b32:	f245 411c 	movw	r1, #21532	; 0x541c
 8002b36:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8002b3a:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8002b3e:	42b2      	cmp	r2, r6
 8002b40:	bf0c      	ite	eq
 8002b42:	2300      	moveq	r3, #0
 8002b44:	f003 0301 	andne.w	r3, r3, #1
 8002b48:	f245 4658 	movw	r6, #21592	; 0x5458
 8002b4c:	428a      	cmp	r2, r1
 8002b4e:	bf0c      	ite	eq
 8002b50:	2300      	moveq	r3, #0
 8002b52:	f003 0301 	andne.w	r3, r3, #1
 8002b56:	f245 4144 	movw	r1, #21572	; 0x5444
 8002b5a:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8002b5e:	4282      	cmp	r2, r0
 8002b60:	bf0c      	ite	eq
 8002b62:	2300      	moveq	r3, #0
 8002b64:	f003 0301 	andne.w	r3, r3, #1
 8002b68:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8002b6c:	f245 406c 	movw	r0, #21612	; 0x546c
 8002b70:	428a      	cmp	r2, r1
 8002b72:	bf0c      	ite	eq
 8002b74:	2300      	moveq	r3, #0
 8002b76:	f003 0301 	andne.w	r3, r3, #1
 8002b7a:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 8002b7e:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8002b82:	42b2      	cmp	r2, r6
 8002b84:	bf0c      	ite	eq
 8002b86:	2300      	moveq	r3, #0
 8002b88:	f003 0301 	andne.w	r3, r3, #1
 8002b8c:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8002b90:	4282      	cmp	r2, r0
 8002b92:	bf0c      	ite	eq
 8002b94:	2300      	moveq	r3, #0
 8002b96:	f003 0301 	andne.w	r3, r3, #1
 8002b9a:	428a      	cmp	r2, r1
 8002b9c:	bf0c      	ite	eq
 8002b9e:	2300      	moveq	r3, #0
 8002ba0:	f003 0301 	andne.w	r3, r3, #1
 8002ba4:	b133      	cbz	r3, 8002bb4 <HAL_DMA_Init+0x1ac>
 8002ba6:	f245 4394 	movw	r3, #21652	; 0x5494
 8002baa:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8002bae:	429a      	cmp	r2, r3
 8002bb0:	f040 840e 	bne.w	80033d0 <HAL_DMA_Init+0x9c8>
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 8002bb4:	68ab      	ldr	r3, [r5, #8]
 8002bb6:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 8002bba:	d002      	beq.n	8002bc2 <HAL_DMA_Init+0x1ba>
 8002bbc:	2b80      	cmp	r3, #128	; 0x80
 8002bbe:	f040 828a 	bne.w	80030d6 <HAL_DMA_Init+0x6ce>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8002bc2:	68eb      	ldr	r3, [r5, #12]
 8002bc4:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 8002bc8:	f040 8136 	bne.w	8002e38 <HAL_DMA_Init+0x430>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8002bcc:	692b      	ldr	r3, [r5, #16]
 8002bce:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 8002bd2:	f040 8124 	bne.w	8002e1e <HAL_DMA_Init+0x416>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8002bd6:	696b      	ldr	r3, [r5, #20]
 8002bd8:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 8002bdc:	d003      	beq.n	8002be6 <HAL_DMA_Init+0x1de>
 8002bde:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8002be2:	f040 8285 	bne.w	80030f0 <HAL_DMA_Init+0x6e8>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 8002be6:	69ab      	ldr	r3, [r5, #24]
 8002be8:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
 8002bec:	d003      	beq.n	8002bf6 <HAL_DMA_Init+0x1ee>
 8002bee:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 8002bf2:	f040 828a 	bne.w	800310a <HAL_DMA_Init+0x702>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 8002bf6:	69ea      	ldr	r2, [r5, #28]
 8002bf8:	f032 0320 	bics.w	r3, r2, #32
 8002bfc:	f422 2100 	bic.w	r1, r2, #524288	; 0x80000
 8002c00:	bf14      	ite	ne
 8002c02:	2301      	movne	r3, #1
 8002c04:	2300      	moveq	r3, #0
 8002c06:	f5b1 2f80 	cmp.w	r1, #262144	; 0x40000
 8002c0a:	bf0c      	ite	eq
 8002c0c:	2300      	moveq	r3, #0
 8002c0e:	f003 0301 	andne.w	r3, r3, #1
 8002c12:	b11b      	cbz	r3, 8002c1c <HAL_DMA_Init+0x214>
 8002c14:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 8002c18:	f040 827f 	bne.w	800311a <HAL_DMA_Init+0x712>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 8002c1c:	6a2b      	ldr	r3, [r5, #32]
 8002c1e:	f433 3340 	bics.w	r3, r3, #196608	; 0x30000
 8002c22:	f040 829c 	bne.w	800315e <HAL_DMA_Init+0x756>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8002c26:	2310      	movs	r3, #16
 8002c28:	2128      	movs	r1, #40	; 0x28
 8002c2a:	682a      	ldr	r2, [r5, #0]
 8002c2c:	2040      	movs	r0, #64	; 0x40
 8002c2e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002c32:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002c36:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002c3a:	2670      	movs	r6, #112	; 0x70
 8002c3c:	428a      	cmp	r2, r1
 8002c3e:	bf18      	it	ne
 8002c40:	429a      	cmpne	r2, r3
 8002c42:	f04f 0158 	mov.w	r1, #88	; 0x58
 8002c46:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002c4a:	bf0c      	ite	eq
 8002c4c:	2301      	moveq	r3, #1
 8002c4e:	2300      	movne	r3, #0
 8002c50:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002c54:	4282      	cmp	r2, r0
 8002c56:	bf08      	it	eq
 8002c58:	f043 0301 	orreq.w	r3, r3, #1
 8002c5c:	20a0      	movs	r0, #160	; 0xa0
 8002c5e:	428a      	cmp	r2, r1
 8002c60:	bf08      	it	eq
 8002c62:	f043 0301 	orreq.w	r3, r3, #1
 8002c66:	2188      	movs	r1, #136	; 0x88
 8002c68:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002c6c:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002c70:	42b2      	cmp	r2, r6
 8002c72:	bf08      	it	eq
 8002c74:	f043 0301 	orreq.w	r3, r3, #1
 8002c78:	f44f 6682 	mov.w	r6, #1040	; 0x410
 8002c7c:	428a      	cmp	r2, r1
 8002c7e:	bf08      	it	eq
 8002c80:	f043 0301 	orreq.w	r3, r3, #1
 8002c84:	21b8      	movs	r1, #184	; 0xb8
 8002c86:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002c8a:	4282      	cmp	r2, r0
 8002c8c:	bf08      	it	eq
 8002c8e:	f043 0301 	orreq.w	r3, r3, #1
 8002c92:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002c96:	f44f 6088 	mov.w	r0, #1088	; 0x440
 8002c9a:	428a      	cmp	r2, r1
 8002c9c:	bf08      	it	eq
 8002c9e:	f043 0301 	orreq.w	r3, r3, #1
 8002ca2:	f44f 6185 	mov.w	r1, #1064	; 0x428
 8002ca6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002caa:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002cae:	42b2      	cmp	r2, r6
 8002cb0:	bf08      	it	eq
 8002cb2:	f043 0301 	orreq.w	r3, r3, #1
 8002cb6:	f44f 668e 	mov.w	r6, #1136	; 0x470
 8002cba:	428a      	cmp	r2, r1
 8002cbc:	bf08      	it	eq
 8002cbe:	f043 0301 	orreq.w	r3, r3, #1
 8002cc2:	f44f 618b 	mov.w	r1, #1112	; 0x458
 8002cc6:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002cca:	4282      	cmp	r2, r0
 8002ccc:	bf08      	it	eq
 8002cce:	f043 0301 	orreq.w	r3, r3, #1
 8002cd2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002cd6:	f44f 6091 	mov.w	r0, #1160	; 0x488
 8002cda:	428a      	cmp	r2, r1
 8002cdc:	bf08      	it	eq
 8002cde:	f043 0301 	orreq.w	r3, r3, #1
 8002ce2:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 8002ce6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002cea:	42b2      	cmp	r2, r6
 8002cec:	bf08      	it	eq
 8002cee:	f043 0301 	orreq.w	r3, r3, #1
 8002cf2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002cf6:	4282      	cmp	r2, r0
 8002cf8:	bf08      	it	eq
 8002cfa:	f043 0301 	orreq.w	r3, r3, #1
 8002cfe:	428a      	cmp	r2, r1
 8002d00:	bf08      	it	eq
 8002d02:	f043 0301 	orreq.w	r3, r3, #1
 8002d06:	b933      	cbnz	r3, 8002d16 <HAL_DMA_Init+0x30e>
 8002d08:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8002d0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002d10:	429a      	cmp	r2, r3
 8002d12:	f040 82b0 	bne.w	8003276 <HAL_DMA_Init+0x86e>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
 8002d16:	686b      	ldr	r3, [r5, #4]
 8002d18:	2b73      	cmp	r3, #115	; 0x73
 8002d1a:	f200 809a 	bhi.w	8002e52 <HAL_DMA_Init+0x44a>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 8002d1e:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002d20:	f033 0204 	bics.w	r2, r3, #4
 8002d24:	f040 80a1 	bne.w	8002e6a <HAL_DMA_Init+0x462>
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 8002d28:	b16b      	cbz	r3, 8002d46 <HAL_DMA_Init+0x33e>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 8002d2a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8002d2c:	2b03      	cmp	r3, #3
 8002d2e:	f200 820e 	bhi.w	800314e <HAL_DMA_Init+0x746>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 8002d32:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002d34:	f033 73c0 	bics.w	r3, r3, #25165824	; 0x1800000
 8002d38:	f040 8272 	bne.w	8003220 <HAL_DMA_Init+0x818>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
 8002d3c:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8002d3e:	f433 03c0 	bics.w	r3, r3, #6291456	; 0x600000
 8002d42:	f040 81f2 	bne.w	800312a <HAL_DMA_Init+0x722>
    __HAL_DMA_DISABLE(hdma);
 8002d46:	682a      	ldr	r2, [r5, #0]
    __HAL_UNLOCK(hdma);
 8002d48:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_BUSY;
 8002d4a:	2102      	movs	r1, #2
    __HAL_UNLOCK(hdma);
 8002d4c:	f885 0034 	strb.w	r0, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
 8002d50:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    __HAL_DMA_DISABLE(hdma);
 8002d54:	6813      	ldr	r3, [r2, #0]
 8002d56:	f023 0301 	bic.w	r3, r3, #1
 8002d5a:	6013      	str	r3, [r2, #0]
 8002d5c:	e005      	b.n	8002d6a <HAL_DMA_Init+0x362>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8002d5e:	f7fd fe6d 	bl	8000a3c <HAL_GetTick>
 8002d62:	1b00      	subs	r0, r0, r4
 8002d64:	2805      	cmp	r0, #5
 8002d66:	f200 81ab 	bhi.w	80030c0 <HAL_DMA_Init+0x6b8>
    while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 8002d6a:	682b      	ldr	r3, [r5, #0]
 8002d6c:	681a      	ldr	r2, [r3, #0]
 8002d6e:	07d0      	lsls	r0, r2, #31
 8002d70:	d4f5      	bmi.n	8002d5e <HAL_DMA_Init+0x356>
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002d72:	e9d5 2403 	ldrd	r2, r4, [r5, #12]
    registerValue |=  hdma->Init.Direction           |
 8002d76:	68a9      	ldr	r1, [r5, #8]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002d78:	f248 003f 	movw	r0, #32831	; 0x803f
    registerValue |=  hdma->Init.Direction           |
 8002d7c:	430a      	orrs	r2, r1
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002d7e:	6969      	ldr	r1, [r5, #20]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002d80:	f6cf 6010 	movt	r0, #65040	; 0xfe10
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002d84:	4322      	orrs	r2, r4
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002d86:	69ac      	ldr	r4, [r5, #24]
            hdma->Init.PeriphInc           | hdma->Init.MemInc           |
 8002d88:	430a      	orrs	r2, r1
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002d8a:	69e9      	ldr	r1, [r5, #28]
 8002d8c:	4322      	orrs	r2, r4
            hdma->Init.Mode                | hdma->Init.Priority;
 8002d8e:	6a2c      	ldr	r4, [r5, #32]
            hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8002d90:	430a      	orrs	r2, r1
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->CR;
 8002d92:	6819      	ldr	r1, [r3, #0]
    registerValue &= ((uint32_t)~(DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8002d94:	4008      	ands	r0, r1
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002d96:	6a69      	ldr	r1, [r5, #36]	; 0x24
            hdma->Init.Mode                | hdma->Init.Priority;
 8002d98:	4322      	orrs	r2, r4
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002d9a:	2904      	cmp	r1, #4
    registerValue |=  hdma->Init.Direction           |
 8002d9c:	ea42 0200 	orr.w	r2, r2, r0
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002da0:	d103      	bne.n	8002daa <HAL_DMA_Init+0x3a2>
      registerValue |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8002da2:	e9d5 100b 	ldrd	r1, r0, [r5, #44]	; 0x2c
 8002da6:	4301      	orrs	r1, r0
 8002da8:	430a      	orrs	r2, r1
    if((DBGMCU->IDCODE & 0xFFFF0000U) >= 0x20000000U)
 8002daa:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 8002dae:	2100      	movs	r1, #0
 8002db0:	f6c5 4000 	movt	r0, #23552	; 0x5c00
 8002db4:	f6cf 71ff 	movt	r1, #65535	; 0xffff
 8002db8:	6800      	ldr	r0, [r0, #0]
 8002dba:	4001      	ands	r1, r0
 8002dbc:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 8002dc0:	d30a      	bcc.n	8002dd8 <HAL_DMA_Init+0x3d0>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 8002dc2:	6868      	ldr	r0, [r5, #4]
 8002dc4:	f1a0 0429 	sub.w	r4, r0, #41	; 0x29
 8002dc8:	2c1f      	cmp	r4, #31
 8002dca:	f240 81b6 	bls.w	800313a <HAL_DMA_Init+0x732>
 8002dce:	384f      	subs	r0, #79	; 0x4f
 8002dd0:	2803      	cmp	r0, #3
 8002dd2:	d801      	bhi.n	8002dd8 <HAL_DMA_Init+0x3d0>
        registerValue |= DMA_SxCR_TRBUFF;
 8002dd4:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR = registerValue;
 8002dd8:	601a      	str	r2, [r3, #0]
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 8002dda:	6829      	ldr	r1, [r5, #0]
    registerValue |= hdma->Init.FIFOMode;
 8002ddc:	6a6a      	ldr	r2, [r5, #36]	; 0x24
    registerValue = ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR;
 8002dde:	694b      	ldr	r3, [r1, #20]
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002de0:	2a04      	cmp	r2, #4
    registerValue &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8002de2:	f023 0307 	bic.w	r3, r3, #7
    registerValue |= hdma->Init.FIFOMode;
 8002de6:	ea43 0302 	orr.w	r3, r3, r2
    if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8002dea:	d150      	bne.n	8002e8e <HAL_DMA_Init+0x486>
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8002dec:	e9d5 200a 	ldrd	r2, r0, [r5, #40]	; 0x28
      registerValue |= hdma->Init.FIFOThreshold;
 8002df0:	4313      	orrs	r3, r2
      if(hdma->Init.MemBurst != DMA_MBURST_SINGLE)
 8002df2:	2800      	cmp	r0, #0
 8002df4:	d04b      	beq.n	8002e8e <HAL_DMA_Init+0x486>
static HAL_StatusTypeDef DMA_CheckFifoParam(DMA_HandleTypeDef *hdma)
{
  HAL_StatusTypeDef status = HAL_OK;

  /* Memory Data size equal to Byte */
  if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8002df6:	69ac      	ldr	r4, [r5, #24]
 8002df8:	2c00      	cmp	r4, #0
 8002dfa:	d042      	beq.n	8002e82 <HAL_DMA_Init+0x47a>
        break;
    }
  }

  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8002dfc:	f5b4 5f00 	cmp.w	r4, #8192	; 0x2000
 8002e00:	f000 82ba 	beq.w	8003378 <HAL_DMA_Init+0x970>
  }

  /* Memory Data size equal to Word */
  else
  {
    switch (hdma->Init.FIFOThreshold)
 8002e04:	2a02      	cmp	r2, #2
 8002e06:	d903      	bls.n	8002e10 <HAL_DMA_Init+0x408>
 8002e08:	2a03      	cmp	r2, #3
 8002e0a:	d140      	bne.n	8002e8e <HAL_DMA_Init+0x486>
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;

      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8002e0c:	01c2      	lsls	r2, r0, #7
 8002e0e:	d53e      	bpl.n	8002e8e <HAL_DMA_Init+0x486>
          hdma->State = HAL_DMA_STATE_READY;
 8002e10:	2301      	movs	r3, #1
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002e12:	2240      	movs	r2, #64	; 0x40
          return HAL_ERROR;
 8002e14:	4618      	mov	r0, r3
          hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8002e16:	656a      	str	r2, [r5, #84]	; 0x54
          hdma->State = HAL_DMA_STATE_READY;
 8002e18:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
          return HAL_ERROR;
 8002e1c:	e14e      	b.n	80030bc <HAL_DMA_Init+0x6b4>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8002e1e:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8002e22:	21e4      	movs	r1, #228	; 0xe4
 8002e24:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002e28:	f012 fd1e 	bl	8015868 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 8002e2c:	696b      	ldr	r3, [r5, #20]
 8002e2e:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 8002e32:	f47f aed4 	bne.w	8002bde <HAL_DMA_Init+0x1d6>
 8002e36:	e6d6      	b.n	8002be6 <HAL_DMA_Init+0x1de>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 8002e38:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8002e3c:	21e3      	movs	r1, #227	; 0xe3
 8002e3e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002e42:	f012 fd11 	bl	8015868 <assert_failed>
  assert_param(IS_DMA_MEMORY_INC_STATE(hdma->Init.MemInc));
 8002e46:	692b      	ldr	r3, [r5, #16]
 8002e48:	f433 6380 	bics.w	r3, r3, #1024	; 0x400
 8002e4c:	f43f aec3 	beq.w	8002bd6 <HAL_DMA_Init+0x1ce>
 8002e50:	e7e5      	b.n	8002e1e <HAL_DMA_Init+0x416>
    assert_param(IS_DMA_REQUEST(hdma->Init.Request));
 8002e52:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8002e56:	21ec      	movs	r1, #236	; 0xec
 8002e58:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002e5c:	f012 fd04 	bl	8015868 <assert_failed>
    assert_param(IS_DMA_FIFO_MODE_STATE(hdma->Init.FIFOMode));
 8002e60:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002e62:	f033 0204 	bics.w	r2, r3, #4
 8002e66:	f43f af5f 	beq.w	8002d28 <HAL_DMA_Init+0x320>
 8002e6a:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8002e6e:	21ed      	movs	r1, #237	; 0xed
 8002e70:	f6c0 0002 	movt	r0, #2050	; 0x802
 8002e74:	f012 fcf8 	bl	8015868 <assert_failed>
 8002e78:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if(hdma->Init.FIFOMode != DMA_FIFOMODE_DISABLE)
 8002e7a:	2b00      	cmp	r3, #0
 8002e7c:	f43f af63 	beq.w	8002d46 <HAL_DMA_Init+0x33e>
 8002e80:	e753      	b.n	8002d2a <HAL_DMA_Init+0x322>
    switch (hdma->Init.FIFOThreshold)
 8002e82:	2a01      	cmp	r2, #1
 8002e84:	f000 8273 	beq.w	800336e <HAL_DMA_Init+0x966>
 8002e88:	d3c0      	bcc.n	8002e0c <HAL_DMA_Init+0x404>
 8002e8a:	2a02      	cmp	r2, #2
 8002e8c:	d0be      	beq.n	8002e0c <HAL_DMA_Init+0x404>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR = registerValue;
 8002e8e:	614b      	str	r3, [r1, #20]
    regs_dma = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8002e90:	4628      	mov	r0, r5
 8002e92:	f7ff fd1f 	bl	80028d4 <DMA_CalcBaseAndBitshift>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8002e96:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8002e98:	233f      	movs	r3, #63	; 0x3f
 8002e9a:	f002 021f 	and.w	r2, r2, #31
 8002e9e:	4093      	lsls	r3, r2
 8002ea0:	6083      	str	r3, [r0, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8002ea2:	2310      	movs	r3, #16
 8002ea4:	2028      	movs	r0, #40	; 0x28
 8002ea6:	682a      	ldr	r2, [r5, #0]
 8002ea8:	2740      	movs	r7, #64	; 0x40
 8002eaa:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002eae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002eb2:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8002eb6:	2658      	movs	r6, #88	; 0x58
 8002eb8:	4282      	cmp	r2, r0
 8002eba:	bf18      	it	ne
 8002ebc:	429a      	cmpne	r2, r3
 8002ebe:	f04f 0470 	mov.w	r4, #112	; 0x70
 8002ec2:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002ec6:	f04f 0188 	mov.w	r1, #136	; 0x88
 8002eca:	bf0c      	ite	eq
 8002ecc:	2001      	moveq	r0, #1
 8002ece:	2000      	movne	r0, #0
 8002ed0:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8002ed4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8002ed8:	42ba      	cmp	r2, r7
 8002eda:	bf08      	it	eq
 8002edc:	f040 0001 	orreq.w	r0, r0, #1
 8002ee0:	f04f 0ea0 	mov.w	lr, #160	; 0xa0
 8002ee4:	f04f 0cb8 	mov.w	ip, #184	; 0xb8
 8002ee8:	f44f 6782 	mov.w	r7, #1040	; 0x410
 8002eec:	42b2      	cmp	r2, r6
 8002eee:	bf08      	it	eq
 8002ef0:	f040 0001 	orreq.w	r0, r0, #1
 8002ef4:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8002ef8:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8002efc:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8002f00:	42a2      	cmp	r2, r4
 8002f02:	bf08      	it	eq
 8002f04:	f040 0001 	orreq.w	r0, r0, #1
 8002f08:	f44f 6685 	mov.w	r6, #1064	; 0x428
 8002f0c:	f44f 6488 	mov.w	r4, #1088	; 0x440
 8002f10:	f44f 638b 	mov.w	r3, #1112	; 0x458
 8002f14:	428a      	cmp	r2, r1
 8002f16:	bf14      	ite	ne
 8002f18:	4601      	movne	r1, r0
 8002f1a:	f040 0101 	orreq.w	r1, r0, #1
 8002f1e:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8002f22:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8002f26:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8002f2a:	4572      	cmp	r2, lr
 8002f2c:	bf08      	it	eq
 8002f2e:	f041 0101 	orreq.w	r1, r1, #1
 8002f32:	f44f 608e 	mov.w	r0, #1136	; 0x470
 8002f36:	f44f 6991 	mov.w	r9, #1160	; 0x488
 8002f3a:	f245 4e08 	movw	lr, #21512	; 0x5408
 8002f3e:	4562      	cmp	r2, ip
 8002f40:	bf08      	it	eq
 8002f42:	f041 0101 	orreq.w	r1, r1, #1
 8002f46:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8002f4a:	f44f 6894 	mov.w	r8, #1184	; 0x4a0
 8002f4e:	f2c4 0902 	movt	r9, #16386	; 0x4002
 8002f52:	42ba      	cmp	r2, r7
 8002f54:	bf08      	it	eq
 8002f56:	f041 0101 	orreq.w	r1, r1, #1
 8002f5a:	f6c5 0e02 	movt	lr, #22530	; 0x5802
 8002f5e:	f245 471c 	movw	r7, #21532	; 0x541c
 8002f62:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8002f66:	42b2      	cmp	r2, r6
 8002f68:	bf08      	it	eq
 8002f6a:	f041 0101 	orreq.w	r1, r1, #1
 8002f6e:	f44f 6c97 	mov.w	ip, #1208	; 0x4b8
 8002f72:	f6c5 0702 	movt	r7, #22530	; 0x5802
 8002f76:	f245 4630 	movw	r6, #21552	; 0x5430
 8002f7a:	42a2      	cmp	r2, r4
 8002f7c:	bf08      	it	eq
 8002f7e:	f041 0101 	orreq.w	r1, r1, #1
 8002f82:	eba2 0e0e 	sub.w	lr, r2, lr
 8002f86:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8002f8a:	1bd7      	subs	r7, r2, r7
 8002f8c:	429a      	cmp	r2, r3
 8002f8e:	bf14      	ite	ne
 8002f90:	460b      	movne	r3, r1
 8002f92:	f041 0301 	orreq.w	r3, r1, #1
 8002f96:	fabe fe8e 	clz	lr, lr
 8002f9a:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8002f9e:	f245 4444 	movw	r4, #21572	; 0x5444
 8002fa2:	4282      	cmp	r2, r0
 8002fa4:	bf08      	it	eq
 8002fa6:	f043 0301 	orreq.w	r3, r3, #1
 8002faa:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 8002fae:	fab7 f787 	clz	r7, r7
 8002fb2:	1b96      	subs	r6, r2, r6
 8002fb4:	454a      	cmp	r2, r9
 8002fb6:	bf08      	it	eq
 8002fb8:	f043 0301 	orreq.w	r3, r3, #1
 8002fbc:	f245 4058 	movw	r0, #21592	; 0x5458
 8002fc0:	f6c5 0402 	movt	r4, #22530	; 0x5802
 8002fc4:	097f      	lsrs	r7, r7, #5
 8002fc6:	4542      	cmp	r2, r8
 8002fc8:	bf08      	it	eq
 8002fca:	f043 0301 	orreq.w	r3, r3, #1
 8002fce:	fab6 f686 	clz	r6, r6
 8002fd2:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8002fd6:	f245 416c 	movw	r1, #21612	; 0x546c
 8002fda:	4562      	cmp	r2, ip
 8002fdc:	bf08      	it	eq
 8002fde:	f043 0301 	orreq.w	r3, r3, #1
 8002fe2:	1b14      	subs	r4, r2, r4
 8002fe4:	0976      	lsrs	r6, r6, #5
 8002fe6:	1a10      	subs	r0, r2, r0
 8002fe8:	ea4e 0303 	orr.w	r3, lr, r3
 8002fec:	fab4 f484 	clz	r4, r4
 8002ff0:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8002ff4:	f44f 4ca9 	mov.w	ip, #21632	; 0x5480
 8002ff8:	433b      	orrs	r3, r7
 8002ffa:	0964      	lsrs	r4, r4, #5
 8002ffc:	fab0 f080 	clz	r0, r0
 8003000:	1a51      	subs	r1, r2, r1
 8003002:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8003006:	4333      	orrs	r3, r6
 8003008:	0940      	lsrs	r0, r0, #5
 800300a:	fab1 f181 	clz	r1, r1
 800300e:	f245 4894 	movw	r8, #21652	; 0x5494
 8003012:	eba2 0c0c 	sub.w	ip, r2, ip
 8003016:	4323      	orrs	r3, r4
 8003018:	0949      	lsrs	r1, r1, #5
 800301a:	f6c5 0802 	movt	r8, #22530	; 0x5802
 800301e:	fabc fc8c 	clz	ip, ip
 8003022:	4303      	orrs	r3, r0
 8003024:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 8003028:	eba2 0808 	sub.w	r8, r2, r8
 800302c:	430b      	orrs	r3, r1
 800302e:	fab8 f888 	clz	r8, r8
 8003032:	ea5c 0303 	orrs.w	r3, ip, r3
 8003036:	ea4f 1858 	mov.w	r8, r8, lsr #5
 800303a:	d102      	bne.n	8003042 <HAL_DMA_Init+0x63a>
 800303c:	f1b8 0f00 	cmp.w	r8, #0
 8003040:	d037      	beq.n	80030b2 <HAL_DMA_Init+0x6aa>
static void DMA_CalcDMAMUXChannelBaseAndMask(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number;
  uint32_t stream_baseaddress = (uint32_t)((uint32_t*)hdma->Instance);

  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8003042:	ea47 070e 	orr.w	r7, r7, lr
 8003046:	b2d3      	uxtb	r3, r2
 8003048:	433e      	orrs	r6, r7
 800304a:	4334      	orrs	r4, r6
 800304c:	4320      	orrs	r0, r4
 800304e:	4301      	orrs	r1, r0
 8003050:	ea5c 0101 	orrs.w	r1, ip, r1
 8003054:	d103      	bne.n	800305e <HAL_DMA_Init+0x656>
 8003056:	f1b8 0f00 	cmp.w	r8, #0
 800305a:	f000 80e9 	beq.w	8003230 <HAL_DMA_Init+0x828>
  {
    /* BDMA Channels are connected to DMAMUX2 channels */
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800305e:	f64c 44cd 	movw	r4, #52429	; 0xcccd
 8003062:	3b08      	subs	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003064:	f44f 4216 	mov.w	r2, #38400	; 0x9600
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003068:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800306a:	f6cc 44cc 	movt	r4, #52428	; 0xcccc
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 800306e:	f44f 40b1 	mov.w	r0, #22656	; 0x5880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003072:	f2c1 6200 	movt	r2, #5632	; 0x1600
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003076:	fba4 4303 	umull	r4, r3, r4, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 800307a:	f6c5 0002 	movt	r0, #22530	; 0x5802
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 800307e:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003080:	6668      	str	r0, [r5, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003082:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003084:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003088:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800308a:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800308e:	662a      	str	r2, [r5, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003090:	66ab      	str	r3, [r5, #104]	; 0x68
    if(hdma->Init.Direction == DMA_MEMORY_TO_MEMORY)
 8003092:	68ab      	ldr	r3, [r5, #8]
 8003094:	2b80      	cmp	r3, #128	; 0x80
 8003096:	d06a      	beq.n	800316e <HAL_DMA_Init+0x766>
 8003098:	792b      	ldrb	r3, [r5, #4]
    hdma->DMAmuxChannel->CCR = (hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID);
 800309a:	6013      	str	r3, [r2, #0]
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800309c:	e9d5 3219 	ldrd	r3, r2, [r5, #100]	; 0x64
 80030a0:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 80030a2:	6868      	ldr	r0, [r5, #4]
 80030a4:	1e41      	subs	r1, r0, #1
 80030a6:	2907      	cmp	r1, #7
 80030a8:	d965      	bls.n	8003176 <HAL_DMA_Init+0x76e>
      hdma->DMAmuxRequestGen = 0U;
 80030aa:	2300      	movs	r3, #0
      hdma->DMAmuxRequestGenStatus = 0U;
 80030ac:	e9c5 331b 	strd	r3, r3, [r5, #108]	; 0x6c
      hdma->DMAmuxRequestGenStatusMask = 0U;
 80030b0:	676b      	str	r3, [r5, #116]	; 0x74
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80030b2:	2000      	movs	r0, #0
  hdma->State = HAL_DMA_STATE_READY;
 80030b4:	2301      	movs	r3, #1
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 80030b6:	6568      	str	r0, [r5, #84]	; 0x54
  hdma->State = HAL_DMA_STATE_READY;
 80030b8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
 80030bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80030c0:	2220      	movs	r2, #32
        hdma->State = HAL_DMA_STATE_ERROR;
 80030c2:	2303      	movs	r3, #3
        return HAL_ERROR;
 80030c4:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80030c6:	656a      	str	r2, [r5, #84]	; 0x54
        hdma->State = HAL_DMA_STATE_ERROR;
 80030c8:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
}
 80030cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return HAL_ERROR;
 80030d0:	2001      	movs	r0, #1
}
 80030d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_DMA_DIRECTION(hdma->Init.Direction));
 80030d6:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 80030da:	21e2      	movs	r1, #226	; 0xe2
 80030dc:	f6c0 0002 	movt	r0, #2050	; 0x802
 80030e0:	f012 fbc2 	bl	8015868 <assert_failed>
  assert_param(IS_DMA_PERIPHERAL_INC_STATE(hdma->Init.PeriphInc));
 80030e4:	68eb      	ldr	r3, [r5, #12]
 80030e6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 80030ea:	f43f ad6f 	beq.w	8002bcc <HAL_DMA_Init+0x1c4>
 80030ee:	e6a3      	b.n	8002e38 <HAL_DMA_Init+0x430>
  assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(hdma->Init.PeriphDataAlignment));
 80030f0:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 80030f4:	21e5      	movs	r1, #229	; 0xe5
 80030f6:	f6c0 0002 	movt	r0, #2050	; 0x802
 80030fa:	f012 fbb5 	bl	8015868 <assert_failed>
  assert_param(IS_DMA_MEMORY_DATA_SIZE(hdma->Init.MemDataAlignment));
 80030fe:	69ab      	ldr	r3, [r5, #24]
 8003100:	f433 5200 	bics.w	r2, r3, #8192	; 0x2000
 8003104:	f47f ad73 	bne.w	8002bee <HAL_DMA_Init+0x1e6>
 8003108:	e575      	b.n	8002bf6 <HAL_DMA_Init+0x1ee>
 800310a:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 800310e:	21e6      	movs	r1, #230	; 0xe6
 8003110:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003114:	f012 fba8 	bl	8015868 <assert_failed>
 8003118:	e56d      	b.n	8002bf6 <HAL_DMA_Init+0x1ee>
  assert_param(IS_DMA_MODE(hdma->Init.Mode));
 800311a:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 800311e:	21e7      	movs	r1, #231	; 0xe7
 8003120:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003124:	f012 fba0 	bl	8015868 <assert_failed>
 8003128:	e578      	b.n	8002c1c <HAL_DMA_Init+0x214>
      assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
 800312a:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 800312e:	21f4      	movs	r1, #244	; 0xf4
 8003130:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003134:	f012 fb98 	bl	8015868 <assert_failed>
 8003138:	e605      	b.n	8002d46 <HAL_DMA_Init+0x33e>
      if(IS_DMA_UART_USART_REQUEST(hdma->Init.Request) != 0U)
 800313a:	213f      	movs	r1, #63	; 0x3f
 800313c:	f2cc 31c0 	movt	r1, #50112	; 0xc3c0
 8003140:	40e1      	lsrs	r1, r4
 8003142:	07c9      	lsls	r1, r1, #31
 8003144:	f57f ae43 	bpl.w	8002dce <HAL_DMA_Init+0x3c6>
        registerValue |= DMA_SxCR_TRBUFF;
 8003148:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800314c:	e644      	b.n	8002dd8 <HAL_DMA_Init+0x3d0>
      assert_param(IS_DMA_FIFO_THRESHOLD(hdma->Init.FIFOThreshold));
 800314e:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8003152:	21f2      	movs	r1, #242	; 0xf2
 8003154:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003158:	f012 fb86 	bl	8015868 <assert_failed>
 800315c:	e5e9      	b.n	8002d32 <HAL_DMA_Init+0x32a>
  assert_param(IS_DMA_PRIORITY(hdma->Init.Priority));
 800315e:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8003162:	21e8      	movs	r1, #232	; 0xe8
 8003164:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003168:	f012 fb7e 	bl	8015868 <assert_failed>
 800316c:	e55b      	b.n	8002c26 <HAL_DMA_Init+0x21e>
      hdma->Init.Request = DMA_REQUEST_MEM2MEM;
 800316e:	2100      	movs	r1, #0
 8003170:	460b      	mov	r3, r1
 8003172:	6069      	str	r1, [r5, #4]
 8003174:	e791      	b.n	800309a <HAL_DMA_Init+0x692>
{
  uint32_t request =  hdma->Init.Request & DMAMUX_CxCR_DMAREQ_ID;

  if((request >= DMA_REQUEST_GENERATOR0) && (request <= DMA_REQUEST_GENERATOR7))
  {
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 8003176:	f245 4308 	movw	r3, #21512	; 0x5408
 800317a:	f245 441c 	movw	r4, #21532	; 0x541c
 800317e:	682a      	ldr	r2, [r5, #0]
 8003180:	f245 4630 	movw	r6, #21552	; 0x5430
 8003184:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003188:	f6c5 0402 	movt	r4, #22530	; 0x5802
 800318c:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8003190:	f245 4758 	movw	r7, #21592	; 0x5458
 8003194:	42a2      	cmp	r2, r4
 8003196:	bf18      	it	ne
 8003198:	429a      	cmpne	r2, r3
 800319a:	f245 4444 	movw	r4, #21572	; 0x5444
 800319e:	f6c5 0702 	movt	r7, #22530	; 0x5802
 80031a2:	bf0c      	ite	eq
 80031a4:	2301      	moveq	r3, #1
 80031a6:	2300      	movne	r3, #0
 80031a8:	f6c5 0402 	movt	r4, #22530	; 0x5802
 80031ac:	42b2      	cmp	r2, r6
 80031ae:	bf08      	it	eq
 80031b0:	f043 0301 	orreq.w	r3, r3, #1
 80031b4:	f245 466c 	movw	r6, #21612	; 0x546c
 80031b8:	42a2      	cmp	r2, r4
 80031ba:	bf08      	it	eq
 80031bc:	f043 0301 	orreq.w	r3, r3, #1
 80031c0:	f6c5 0602 	movt	r6, #22530	; 0x5802
 80031c4:	f44f 44a9 	mov.w	r4, #21632	; 0x5480
 80031c8:	42ba      	cmp	r2, r7
 80031ca:	bf08      	it	eq
 80031cc:	f043 0301 	orreq.w	r3, r3, #1
 80031d0:	f6c5 0402 	movt	r4, #22530	; 0x5802
 80031d4:	42b2      	cmp	r2, r6
 80031d6:	bf08      	it	eq
 80031d8:	f043 0301 	orreq.w	r3, r3, #1
 80031dc:	42a2      	cmp	r2, r4
 80031de:	bf08      	it	eq
 80031e0:	f043 0301 	orreq.w	r3, r3, #1
 80031e4:	b933      	cbnz	r3, 80031f4 <HAL_DMA_Init+0x7ec>
 80031e6:	f245 4394 	movw	r3, #21652	; 0x5494
 80031ea:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80031ee:	429a      	cmp	r2, r3
 80031f0:	f040 80d0 	bne.w	8003394 <HAL_DMA_Init+0x98c>
    {
      /* BDMA Channels are connected to DMAMUX2 request generator blocks */
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80031f4:	f249 633f 	movw	r3, #38463	; 0x963f

      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 80031f8:	f645 1440 	movw	r4, #22848	; 0x5940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80031fc:	f2c1 6300 	movt	r3, #5632	; 0x1600
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 8003200:	f6c5 0402 	movt	r4, #22530	; 0x5802
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 8003204:	4403      	add	r3, r0
 8003206:	009b      	lsls	r3, r3, #2
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));

      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
    }

    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 8003208:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
 800320a:	2000      	movs	r0, #0
 800320c:	672c      	str	r4, [r5, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 800320e:	fa02 f101 	lsl.w	r1, r2, r1
 8003212:	66eb      	str	r3, [r5, #108]	; 0x6c
 8003214:	6769      	str	r1, [r5, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
 8003216:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003218:	e9d5 321c 	ldrd	r3, r2, [r5, #112]	; 0x70
 800321c:	605a      	str	r2, [r3, #4]
 800321e:	e748      	b.n	80030b2 <HAL_DMA_Init+0x6aa>
      assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
 8003220:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8003224:	21f3      	movs	r1, #243	; 0xf3
 8003226:	f6c0 0002 	movt	r0, #2050	; 0x802
 800322a:	f012 fb1d 	bl	8015868 <assert_failed>
 800322e:	e585      	b.n	8002d3c <HAL_DMA_Init+0x334>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003230:	f64f 31f0 	movw	r1, #64496	; 0xfbf0
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003234:	f64a 20ab 	movw	r0, #43691	; 0xaaab
 8003238:	3b10      	subs	r3, #16
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800323a:	f6cb 71fd 	movt	r1, #49149	; 0xbffd
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800323e:	f6ca 20aa 	movt	r0, #43690	; 0xaaaa
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003242:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003244:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003248:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800324a:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800324e:	d800      	bhi.n	8003252 <HAL_DMA_Init+0x84a>
      stream_number += 8U;
 8003250:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003252:	f44f 4202 	mov.w	r2, #33280	; 0x8200
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003256:	f003 041f 	and.w	r4, r3, #31
 800325a:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800325c:	f44f 6008 	mov.w	r0, #2176	; 0x880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003260:	f2c1 0200 	movt	r2, #4096	; 0x1000
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003264:	40a1      	lsls	r1, r4
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8003266:	f2c4 0002 	movt	r0, #16386	; 0x4002
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800326a:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800326c:	66a9      	str	r1, [r5, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800326e:	0092      	lsls	r2, r2, #2
 8003270:	e9c5 2018 	strd	r2, r0, [r5, #96]	; 0x60
 8003274:	e70d      	b.n	8003092 <HAL_DMA_Init+0x68a>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8003276:	f245 4308 	movw	r3, #21512	; 0x5408
 800327a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800327e:	429a      	cmp	r2, r3
 8003280:	d032      	beq.n	80032e8 <HAL_DMA_Init+0x8e0>
 8003282:	f245 431c 	movw	r3, #21532	; 0x541c
 8003286:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800328a:	429a      	cmp	r2, r3
 800328c:	d02c      	beq.n	80032e8 <HAL_DMA_Init+0x8e0>
 800328e:	f245 4330 	movw	r3, #21552	; 0x5430
 8003292:	f245 4144 	movw	r1, #21572	; 0x5444
 8003296:	f245 4458 	movw	r4, #21592	; 0x5458
 800329a:	f245 406c 	movw	r0, #21612	; 0x546c
 800329e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80032a2:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80032a6:	f6c5 0402 	movt	r4, #22530	; 0x5802
 80032aa:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80032ae:	428a      	cmp	r2, r1
 80032b0:	bf18      	it	ne
 80032b2:	429a      	cmpne	r2, r3
 80032b4:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 80032b8:	bf0c      	ite	eq
 80032ba:	2301      	moveq	r3, #1
 80032bc:	2300      	movne	r3, #0
 80032be:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80032c2:	42a2      	cmp	r2, r4
 80032c4:	bf08      	it	eq
 80032c6:	f043 0301 	orreq.w	r3, r3, #1
 80032ca:	4282      	cmp	r2, r0
 80032cc:	bf08      	it	eq
 80032ce:	f043 0301 	orreq.w	r3, r3, #1
 80032d2:	428a      	cmp	r2, r1
 80032d4:	bf08      	it	eq
 80032d6:	f043 0301 	orreq.w	r3, r3, #1
 80032da:	b92b      	cbnz	r3, 80032e8 <HAL_DMA_Init+0x8e0>
 80032dc:	f245 4394 	movw	r3, #21652	; 0x5494
 80032e0:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80032e4:	429a      	cmp	r2, r3
 80032e6:	d16c      	bne.n	80033c2 <HAL_DMA_Init+0x9ba>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
 80032e8:	686b      	ldr	r3, [r5, #4]
 80032ea:	2b11      	cmp	r3, #17
 80032ec:	d85f      	bhi.n	80033ae <HAL_DMA_Init+0x9a6>
    hdma->State = HAL_DMA_STATE_BUSY;
 80032ee:	2102      	movs	r1, #2
    __HAL_UNLOCK(hdma);
 80032f0:	2400      	movs	r4, #0
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 80032f2:	200f      	movs	r0, #15
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80032f4:	68ab      	ldr	r3, [r5, #8]
    __HAL_UNLOCK(hdma);
 80032f6:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_BUSY;
 80032fa:	f885 1035 	strb.w	r1, [r5, #53]	; 0x35
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 80032fe:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
    registerValue = ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR;
 8003302:	6811      	ldr	r1, [r2, #0]
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 8003304:	2b40      	cmp	r3, #64	; 0x40
    registerValue &= ((uint32_t)~(BDMA_CCR_PL    | BDMA_CCR_MSIZE   | BDMA_CCR_PSIZE  | \
 8003306:	ea00 0001 	and.w	r0, r0, r1
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800330a:	d04e      	beq.n	80033aa <HAL_DMA_Init+0x9a2>
 800330c:	2b80      	cmp	r3, #128	; 0x80
 800330e:	bf08      	it	eq
 8003310:	f44f 4480 	moveq.w	r4, #16384	; 0x4000
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 8003314:	692b      	ldr	r3, [r5, #16]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 8003316:	f64a 31f8 	movw	r1, #44024	; 0xabf8
                      DMA_TO_BDMA_PERIPHERAL_INC(hdma->Init.PeriphInc)       |
 800331a:	68ee      	ldr	r6, [r5, #12]
                      DMA_TO_BDMA_MEMORY_INC(hdma->Init.MemInc)              |
 800331c:	08db      	lsrs	r3, r3, #3
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800331e:	f2ca 71fd 	movt	r1, #43005	; 0xa7fd
 8003322:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_PDATA_SIZE(hdma->Init.PeriphDataAlignment) |
 8003326:	696e      	ldr	r6, [r5, #20]
 8003328:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MDATA_SIZE(hdma->Init.MemDataAlignment)    |
 800332c:	69ae      	ldr	r6, [r5, #24]
 800332e:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_MODE(hdma->Init.Mode)                      |
 8003332:	69ee      	ldr	r6, [r5, #28]
 8003334:	ea43 03d6 	orr.w	r3, r3, r6, lsr #3
                      DMA_TO_BDMA_PRIORITY(hdma->Init.Priority);
 8003338:	6a2e      	ldr	r6, [r5, #32]
 800333a:	ea43 1316 	orr.w	r3, r3, r6, lsr #4
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800333e:	f64c 46cd 	movw	r6, #52429	; 0xcccd
 8003342:	4303      	orrs	r3, r0
 8003344:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8003348:	4628      	mov	r0, r5
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 800334a:	4323      	orrs	r3, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR = registerValue;
 800334c:	6013      	str	r3, [r2, #0]
    hdma->StreamIndex = (((uint32_t)((uint32_t*)hdma->Instance) - (uint32_t)BDMA_Channel0) / ((uint32_t)BDMA_Channel1 - (uint32_t)BDMA_Channel0)) << 2U;
 800334e:	682b      	ldr	r3, [r5, #0]
 8003350:	4419      	add	r1, r3
 8003352:	fba6 2301 	umull	r2, r3, r6, r1
 8003356:	091b      	lsrs	r3, r3, #4
 8003358:	009b      	lsls	r3, r3, #2
 800335a:	65eb      	str	r3, [r5, #92]	; 0x5c
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 800335c:	f7ff faba 	bl	80028d4 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 8003360:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8003362:	2301      	movs	r3, #1
 8003364:	f002 021f 	and.w	r2, r2, #31
 8003368:	4093      	lsls	r3, r2
 800336a:	6043      	str	r3, [r0, #4]
 800336c:	e599      	b.n	8002ea2 <HAL_DMA_Init+0x49a>
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 800336e:	f1b0 7fc0 	cmp.w	r0, #25165824	; 0x1800000
 8003372:	f47f ad8c 	bne.w	8002e8e <HAL_DMA_Init+0x486>
 8003376:	e54b      	b.n	8002e10 <HAL_DMA_Init+0x408>
    switch (hdma->Init.FIFOThreshold)
 8003378:	2a03      	cmp	r2, #3
 800337a:	f63f ad88 	bhi.w	8002e8e <HAL_DMA_Init+0x486>
 800337e:	a401      	add	r4, pc, #4	; (adr r4, 8003384 <HAL_DMA_Init+0x97c>)
 8003380:	f854 f022 	ldr.w	pc, [r4, r2, lsl #2]
 8003384:	08002e11 	.word	0x08002e11
 8003388:	08002e0d 	.word	0x08002e0d
 800338c:	08002e11 	.word	0x08002e11
 8003390:	0800336f 	.word	0x0800336f
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003394:	f248 233f 	movw	r3, #33343	; 0x823f
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8003398:	f44f 6414 	mov.w	r4, #2368	; 0x940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 800339c:	f2c1 0300 	movt	r3, #4096	; 0x1000
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 80033a0:	f2c4 0402 	movt	r4, #16386	; 0x4002
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 80033a4:	4403      	add	r3, r0
 80033a6:	009b      	lsls	r3, r3, #2
 80033a8:	e72e      	b.n	8003208 <HAL_DMA_Init+0x800>
    registerValue |=  DMA_TO_BDMA_DIRECTION(hdma->Init.Direction)            |
 80033aa:	2410      	movs	r4, #16
 80033ac:	e7b2      	b.n	8003314 <HAL_DMA_Init+0x90c>
      assert_param(IS_BDMA_REQUEST(hdma->Init.Request));
 80033ae:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 80033b2:	f44f 71b3 	mov.w	r1, #358	; 0x166
 80033b6:	f6c0 0002 	movt	r0, #2050	; 0x802
 80033ba:	f012 fa55 	bl	8015868 <assert_failed>
 80033be:	682a      	ldr	r2, [r5, #0]
 80033c0:	e795      	b.n	80032ee <HAL_DMA_Init+0x8e6>
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80033c2:	2240      	movs	r2, #64	; 0x40
    hdma->State     = HAL_DMA_STATE_ERROR;
 80033c4:	2303      	movs	r3, #3
    return HAL_ERROR;
 80033c6:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 80033c8:	656a      	str	r2, [r5, #84]	; 0x54
    hdma->State     = HAL_DMA_STATE_ERROR;
 80033ca:	f885 3035 	strb.w	r3, [r5, #53]	; 0x35
    return HAL_ERROR;
 80033ce:	e675      	b.n	80030bc <HAL_DMA_Init+0x6b4>
  assert_param(IS_DMA_ALL_INSTANCE(hdma->Instance));
 80033d0:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 80033d4:	21e1      	movs	r1, #225	; 0xe1
 80033d6:	f6c0 0002 	movt	r0, #2050	; 0x802
 80033da:	f012 fa45 	bl	8015868 <assert_failed>
 80033de:	f7ff bbe9 	b.w	8002bb4 <HAL_DMA_Init+0x1ac>
 80033e2:	bf00      	nop

080033e4 <HAL_DMA_DeInit>:
  if(hdma == NULL)
 80033e4:	2800      	cmp	r0, #0
 80033e6:	f000 82b2 	beq.w	800394e <HAL_DMA_DeInit+0x56a>
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80033ea:	2140      	movs	r1, #64	; 0x40
{
 80033ec:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_DMA_DISABLE(hdma);
 80033f0:	6802      	ldr	r2, [r0, #0]
 80033f2:	4604      	mov	r4, r0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80033f4:	2028      	movs	r0, #40	; 0x28
 80033f6:	f2c4 0102 	movt	r1, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
 80033fa:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80033fc:	2558      	movs	r5, #88	; 0x58
 80033fe:	f2c4 0002 	movt	r0, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
 8003402:	f023 0301 	bic.w	r3, r3, #1
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003406:	f2c4 0502 	movt	r5, #16386	; 0x4002
  __HAL_DMA_DISABLE(hdma);
 800340a:	6013      	str	r3, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800340c:	2310      	movs	r3, #16
 800340e:	6822      	ldr	r2, [r4, #0]
 8003410:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003414:	4282      	cmp	r2, r0
 8003416:	bf18      	it	ne
 8003418:	429a      	cmpne	r2, r3
 800341a:	f04f 0070 	mov.w	r0, #112	; 0x70
 800341e:	bf0c      	ite	eq
 8003420:	2301      	moveq	r3, #1
 8003422:	2300      	movne	r3, #0
 8003424:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003428:	428a      	cmp	r2, r1
 800342a:	bf08      	it	eq
 800342c:	f043 0301 	orreq.w	r3, r3, #1
 8003430:	2188      	movs	r1, #136	; 0x88
 8003432:	42aa      	cmp	r2, r5
 8003434:	bf08      	it	eq
 8003436:	f043 0301 	orreq.w	r3, r3, #1
 800343a:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800343e:	25a0      	movs	r5, #160	; 0xa0
 8003440:	4282      	cmp	r2, r0
 8003442:	bf08      	it	eq
 8003444:	f043 0301 	orreq.w	r3, r3, #1
 8003448:	20b8      	movs	r0, #184	; 0xb8
 800344a:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800344e:	428a      	cmp	r2, r1
 8003450:	bf08      	it	eq
 8003452:	f043 0301 	orreq.w	r3, r3, #1
 8003456:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800345a:	f44f 6182 	mov.w	r1, #1040	; 0x410
 800345e:	42aa      	cmp	r2, r5
 8003460:	bf08      	it	eq
 8003462:	f043 0301 	orreq.w	r3, r3, #1
 8003466:	f44f 6585 	mov.w	r5, #1064	; 0x428
 800346a:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800346e:	4282      	cmp	r2, r0
 8003470:	bf08      	it	eq
 8003472:	f043 0301 	orreq.w	r3, r3, #1
 8003476:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800347a:	f44f 6088 	mov.w	r0, #1088	; 0x440
 800347e:	428a      	cmp	r2, r1
 8003480:	bf08      	it	eq
 8003482:	f043 0301 	orreq.w	r3, r3, #1
 8003486:	f44f 618b 	mov.w	r1, #1112	; 0x458
 800348a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800348e:	42aa      	cmp	r2, r5
 8003490:	bf08      	it	eq
 8003492:	f043 0301 	orreq.w	r3, r3, #1
 8003496:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800349a:	f44f 658e 	mov.w	r5, #1136	; 0x470
 800349e:	4282      	cmp	r2, r0
 80034a0:	bf08      	it	eq
 80034a2:	f043 0301 	orreq.w	r3, r3, #1
 80034a6:	f44f 6091 	mov.w	r0, #1160	; 0x488
 80034aa:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80034ae:	428a      	cmp	r2, r1
 80034b0:	bf08      	it	eq
 80034b2:	f043 0301 	orreq.w	r3, r3, #1
 80034b6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80034ba:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 80034be:	42aa      	cmp	r2, r5
 80034c0:	bf08      	it	eq
 80034c2:	f043 0301 	orreq.w	r3, r3, #1
 80034c6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80034ca:	4282      	cmp	r2, r0
 80034cc:	bf08      	it	eq
 80034ce:	f043 0301 	orreq.w	r3, r3, #1
 80034d2:	428a      	cmp	r2, r1
 80034d4:	bf08      	it	eq
 80034d6:	f043 0301 	orreq.w	r3, r3, #1
 80034da:	b933      	cbnz	r3, 80034ea <HAL_DMA_DeInit+0x106>
 80034dc:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 80034e0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80034e4:	429a      	cmp	r2, r3
 80034e6:	f040 8234 	bne.w	8003952 <HAL_DMA_DeInit+0x56e>
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 80034ea:	2100      	movs	r1, #0
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 80034ec:	2021      	movs	r0, #33	; 0x21
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80034ee:	2310      	movs	r3, #16
 80034f0:	2728      	movs	r7, #40	; 0x28
    ((DMA_Stream_TypeDef   *)hdma->Instance)->CR   = 0U;
 80034f2:	6011      	str	r1, [r2, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80034f4:	2640      	movs	r6, #64	; 0x40
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
 80034f6:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80034f8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80034fc:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8003500:	f2c4 0602 	movt	r6, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->NDTR = 0U;
 8003504:	6051      	str	r1, [r2, #4]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003506:	2558      	movs	r5, #88	; 0x58
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
 8003508:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800350a:	f2c4 0502 	movt	r5, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->PAR  = 0U;
 800350e:	6091      	str	r1, [r2, #8]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M0AR = 0U;
 8003510:	6822      	ldr	r2, [r4, #0]
 8003512:	60d1      	str	r1, [r2, #12]
    ((DMA_Stream_TypeDef   *)hdma->Instance)->M1AR = 0U;
 8003514:	6822      	ldr	r2, [r4, #0]
 8003516:	6111      	str	r1, [r2, #16]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003518:	2188      	movs	r1, #136	; 0x88
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 800351a:	6822      	ldr	r2, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800351c:	f2c4 0102 	movt	r1, #16386	; 0x4002
    ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR  = (uint32_t)0x00000021U;
 8003520:	6150      	str	r0, [r2, #20]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003522:	2070      	movs	r0, #112	; 0x70
 8003524:	6822      	ldr	r2, [r4, #0]
 8003526:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800352a:	42ba      	cmp	r2, r7
 800352c:	bf18      	it	ne
 800352e:	429a      	cmpne	r2, r3
 8003530:	bf0c      	ite	eq
 8003532:	2301      	moveq	r3, #1
 8003534:	2300      	movne	r3, #0
 8003536:	42b2      	cmp	r2, r6
 8003538:	bf08      	it	eq
 800353a:	f043 0301 	orreq.w	r3, r3, #1
 800353e:	42aa      	cmp	r2, r5
 8003540:	bf08      	it	eq
 8003542:	f043 0301 	orreq.w	r3, r3, #1
 8003546:	25a0      	movs	r5, #160	; 0xa0
 8003548:	4282      	cmp	r2, r0
 800354a:	bf08      	it	eq
 800354c:	f043 0301 	orreq.w	r3, r3, #1
 8003550:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003554:	20b8      	movs	r0, #184	; 0xb8
 8003556:	428a      	cmp	r2, r1
 8003558:	bf08      	it	eq
 800355a:	f043 0301 	orreq.w	r3, r3, #1
 800355e:	f44f 6182 	mov.w	r1, #1040	; 0x410
 8003562:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003566:	42aa      	cmp	r2, r5
 8003568:	bf08      	it	eq
 800356a:	f043 0301 	orreq.w	r3, r3, #1
 800356e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8003572:	f44f 6585 	mov.w	r5, #1064	; 0x428
 8003576:	4282      	cmp	r2, r0
 8003578:	bf08      	it	eq
 800357a:	f043 0301 	orreq.w	r3, r3, #1
 800357e:	f44f 6088 	mov.w	r0, #1088	; 0x440
 8003582:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003586:	428a      	cmp	r2, r1
 8003588:	bf08      	it	eq
 800358a:	f043 0301 	orreq.w	r3, r3, #1
 800358e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003592:	f44f 618b 	mov.w	r1, #1112	; 0x458
 8003596:	42aa      	cmp	r2, r5
 8003598:	bf08      	it	eq
 800359a:	f043 0301 	orreq.w	r3, r3, #1
 800359e:	f44f 658e 	mov.w	r5, #1136	; 0x470
 80035a2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80035a6:	4282      	cmp	r2, r0
 80035a8:	bf08      	it	eq
 80035aa:	f043 0301 	orreq.w	r3, r3, #1
 80035ae:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80035b2:	f44f 6091 	mov.w	r0, #1160	; 0x488
 80035b6:	428a      	cmp	r2, r1
 80035b8:	bf08      	it	eq
 80035ba:	f043 0301 	orreq.w	r3, r3, #1
 80035be:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 80035c2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80035c6:	42aa      	cmp	r2, r5
 80035c8:	bf08      	it	eq
 80035ca:	f043 0301 	orreq.w	r3, r3, #1
 80035ce:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80035d2:	4282      	cmp	r2, r0
 80035d4:	bf08      	it	eq
 80035d6:	f043 0301 	orreq.w	r3, r3, #1
 80035da:	428a      	cmp	r2, r1
 80035dc:	bf08      	it	eq
 80035de:	f043 0301 	orreq.w	r3, r3, #1
 80035e2:	b933      	cbnz	r3, 80035f2 <HAL_DMA_DeInit+0x20e>
 80035e4:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 80035e8:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80035ec:	429a      	cmp	r2, r3
 80035ee:	f040 8201 	bne.w	80039f4 <HAL_DMA_DeInit+0x610>
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 80035f2:	b2d3      	uxtb	r3, r2
 80035f4:	f64a 25ab 	movw	r5, #43691	; 0xaaab
 80035f8:	f44f 417c 	mov.w	r1, #64512	; 0xfc00
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 80035fc:	f64d 2030 	movw	r0, #55856	; 0xda30
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003600:	3b10      	subs	r3, #16
 8003602:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
 8003606:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800360a:	f6c0 0002 	movt	r0, #2050	; 0x802
    uint32_t stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800360e:	fba5 5303 	umull	r5, r3, r5, r3
 8003612:	4011      	ands	r1, r2
 8003614:	091b      	lsrs	r3, r3, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8003616:	f003 0207 	and.w	r2, r3, #7
    if (stream_number > 3U)
 800361a:	2b03      	cmp	r3, #3
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 800361c:	5c82      	ldrb	r2, [r0, r2]
      hdma->StreamBaseAddress = (((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU)) + 4U);
 800361e:	bf88      	it	hi
 8003620:	3104      	addhi	r1, #4
    hdma->StreamIndex = flagBitshiftOffset[stream_number & 0x7U];
 8003622:	65e2      	str	r2, [r4, #92]	; 0x5c
      hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0x3FFU));
 8003624:	65a1      	str	r1, [r4, #88]	; 0x58
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8003626:	f002 021f 	and.w	r2, r2, #31
 800362a:	233f      	movs	r3, #63	; 0x3f
 800362c:	fa03 f202 	lsl.w	r2, r3, r2
 8003630:	608a      	str	r2, [r1, #8]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003632:	2310      	movs	r3, #16
 8003634:	2028      	movs	r0, #40	; 0x28
 8003636:	6822      	ldr	r2, [r4, #0]
 8003638:	2740      	movs	r7, #64	; 0x40
 800363a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800363e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003642:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8003646:	2658      	movs	r6, #88	; 0x58
 8003648:	4282      	cmp	r2, r0
 800364a:	bf18      	it	ne
 800364c:	429a      	cmpne	r2, r3
 800364e:	f04f 0570 	mov.w	r5, #112	; 0x70
 8003652:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8003656:	f04f 0188 	mov.w	r1, #136	; 0x88
 800365a:	bf0c      	ite	eq
 800365c:	2001      	moveq	r0, #1
 800365e:	2000      	movne	r0, #0
 8003660:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003664:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8003668:	42ba      	cmp	r2, r7
 800366a:	bf08      	it	eq
 800366c:	f040 0001 	orreq.w	r0, r0, #1
 8003670:	f04f 0ca0 	mov.w	ip, #160	; 0xa0
 8003674:	27b8      	movs	r7, #184	; 0xb8
 8003676:	f44f 638b 	mov.w	r3, #1112	; 0x458
 800367a:	42b2      	cmp	r2, r6
 800367c:	bf08      	it	eq
 800367e:	f040 0001 	orreq.w	r0, r0, #1
 8003682:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003686:	f2c4 0702 	movt	r7, #16386	; 0x4002
 800368a:	f44f 6682 	mov.w	r6, #1040	; 0x410
 800368e:	42aa      	cmp	r2, r5
 8003690:	bf08      	it	eq
 8003692:	f040 0001 	orreq.w	r0, r0, #1
 8003696:	f44f 6585 	mov.w	r5, #1064	; 0x428
 800369a:	f2c4 0602 	movt	r6, #16386	; 0x4002
 800369e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80036a2:	428a      	cmp	r2, r1
 80036a4:	bf14      	ite	ne
 80036a6:	4601      	movne	r1, r0
 80036a8:	f040 0101 	orreq.w	r1, r0, #1
 80036ac:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80036b0:	f44f 6088 	mov.w	r0, #1088	; 0x440
 80036b4:	f44f 6a8e 	mov.w	sl, #1136	; 0x470
 80036b8:	4562      	cmp	r2, ip
 80036ba:	bf08      	it	eq
 80036bc:	f041 0101 	orreq.w	r1, r1, #1
 80036c0:	f44f 6991 	mov.w	r9, #1160	; 0x488
 80036c4:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80036c8:	f2c4 0a02 	movt	sl, #16386	; 0x4002
 80036cc:	42ba      	cmp	r2, r7
 80036ce:	bf08      	it	eq
 80036d0:	f041 0101 	orreq.w	r1, r1, #1
 80036d4:	f245 4e08 	movw	lr, #21512	; 0x5408
 80036d8:	f44f 6894 	mov.w	r8, #1184	; 0x4a0
 80036dc:	f2c4 0902 	movt	r9, #16386	; 0x4002
 80036e0:	42b2      	cmp	r2, r6
 80036e2:	bf08      	it	eq
 80036e4:	f041 0101 	orreq.w	r1, r1, #1
 80036e8:	f245 471c 	movw	r7, #21532	; 0x541c
 80036ec:	f6c5 0e02 	movt	lr, #22530	; 0x5802
 80036f0:	f2c4 0802 	movt	r8, #16386	; 0x4002
 80036f4:	42aa      	cmp	r2, r5
 80036f6:	bf08      	it	eq
 80036f8:	f041 0101 	orreq.w	r1, r1, #1
 80036fc:	f44f 6c97 	mov.w	ip, #1208	; 0x4b8
 8003700:	f6c5 0702 	movt	r7, #22530	; 0x5802
 8003704:	f245 4630 	movw	r6, #21552	; 0x5430
 8003708:	4282      	cmp	r2, r0
 800370a:	bf08      	it	eq
 800370c:	f041 0101 	orreq.w	r1, r1, #1
 8003710:	eba2 0e0e 	sub.w	lr, r2, lr
 8003714:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003718:	1bd7      	subs	r7, r2, r7
 800371a:	429a      	cmp	r2, r3
 800371c:	bf14      	ite	ne
 800371e:	460b      	movne	r3, r1
 8003720:	f041 0301 	orreq.w	r3, r1, #1
 8003724:	fabe fe8e 	clz	lr, lr
 8003728:	f6c5 0602 	movt	r6, #22530	; 0x5802
 800372c:	f245 4544 	movw	r5, #21572	; 0x5444
 8003730:	4552      	cmp	r2, sl
 8003732:	bf08      	it	eq
 8003734:	f043 0301 	orreq.w	r3, r3, #1
 8003738:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 800373c:	fab7 f787 	clz	r7, r7
 8003740:	1b96      	subs	r6, r2, r6
 8003742:	454a      	cmp	r2, r9
 8003744:	bf08      	it	eq
 8003746:	f043 0301 	orreq.w	r3, r3, #1
 800374a:	f245 4058 	movw	r0, #21592	; 0x5458
 800374e:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003752:	097f      	lsrs	r7, r7, #5
 8003754:	4542      	cmp	r2, r8
 8003756:	bf08      	it	eq
 8003758:	f043 0301 	orreq.w	r3, r3, #1
 800375c:	fab6 f686 	clz	r6, r6
 8003760:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8003764:	f245 416c 	movw	r1, #21612	; 0x546c
 8003768:	4562      	cmp	r2, ip
 800376a:	bf08      	it	eq
 800376c:	f043 0301 	orreq.w	r3, r3, #1
 8003770:	1b55      	subs	r5, r2, r5
 8003772:	0976      	lsrs	r6, r6, #5
 8003774:	1a10      	subs	r0, r2, r0
 8003776:	ea4e 0303 	orr.w	r3, lr, r3
 800377a:	fab5 f585 	clz	r5, r5
 800377e:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8003782:	f44f 4ca9 	mov.w	ip, #21632	; 0x5480
 8003786:	433b      	orrs	r3, r7
 8003788:	096d      	lsrs	r5, r5, #5
 800378a:	fab0 f080 	clz	r0, r0
 800378e:	1a51      	subs	r1, r2, r1
 8003790:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8003794:	4333      	orrs	r3, r6
 8003796:	0940      	lsrs	r0, r0, #5
 8003798:	fab1 f181 	clz	r1, r1
 800379c:	f245 4894 	movw	r8, #21652	; 0x5494
 80037a0:	eba2 0c0c 	sub.w	ip, r2, ip
 80037a4:	432b      	orrs	r3, r5
 80037a6:	0949      	lsrs	r1, r1, #5
 80037a8:	f6c5 0802 	movt	r8, #22530	; 0x5802
 80037ac:	fabc fc8c 	clz	ip, ip
 80037b0:	4303      	orrs	r3, r0
 80037b2:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 80037b6:	eba2 0808 	sub.w	r8, r2, r8
 80037ba:	430b      	orrs	r3, r1
 80037bc:	fab8 f888 	clz	r8, r8
 80037c0:	ea5c 0303 	orrs.w	r3, ip, r3
 80037c4:	ea4f 1858 	mov.w	r8, r8, lsr #5
 80037c8:	d102      	bne.n	80037d0 <HAL_DMA_DeInit+0x3ec>
 80037ca:	f1b8 0f00 	cmp.w	r8, #0
 80037ce:	d037      	beq.n	8003840 <HAL_DMA_DeInit+0x45c>
  if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 80037d0:	ea47 070e 	orr.w	r7, r7, lr
 80037d4:	fa5f f982 	uxtb.w	r9, r2
 80037d8:	433e      	orrs	r6, r7
 80037da:	4335      	orrs	r5, r6
 80037dc:	4328      	orrs	r0, r5
 80037de:	4301      	orrs	r1, r0
 80037e0:	ea5c 0301 	orrs.w	r3, ip, r1
 80037e4:	d103      	bne.n	80037ee <HAL_DMA_DeInit+0x40a>
 80037e6:	f1b8 0f00 	cmp.w	r8, #0
 80037ea:	f000 808c 	beq.w	8003906 <HAL_DMA_DeInit+0x522>
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 80037ee:	f64c 45cd 	movw	r5, #52429	; 0xcccd
 80037f2:	f1a9 0308 	sub.w	r3, r9, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 80037f6:	f44f 4216 	mov.w	r2, #38400	; 0x9600
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 80037fa:	2101      	movs	r1, #1
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 80037fc:	f6cc 45cc 	movt	r5, #52428	; 0xcccc
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003800:	f44f 40b1 	mov.w	r0, #22656	; 0x5880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003804:	f2c1 6200 	movt	r2, #5632	; 0x1600
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003808:	fba5 5303 	umull	r5, r3, r5, r3
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 800380c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 8U) / 20U;
 8003810:	091b      	lsrs	r3, r3, #4
    hdma->DMAmuxChannelStatus = DMAMUX2_ChannelStatus;
 8003812:	6660      	str	r0, [r4, #100]	; 0x64
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003814:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003816:	f003 031f 	and.w	r3, r3, #31
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 800381a:	0092      	lsls	r2, r2, #2
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800381c:	fa01 f303 	lsl.w	r3, r1, r3
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_Channel0) + (stream_number * 4U)));
 8003820:	6622      	str	r2, [r4, #96]	; 0x60
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003822:	66a3      	str	r3, [r4, #104]	; 0x68
    if(hdma->DMAmuxChannel != 0U)
 8003824:	b122      	cbz	r2, 8003830 <HAL_DMA_DeInit+0x44c>
      hdma->DMAmuxChannel->CCR = 0U;
 8003826:	2300      	movs	r3, #0
 8003828:	6013      	str	r3, [r2, #0]
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 800382a:	e9d4 3219 	ldrd	r3, r2, [r4, #100]	; 0x64
 800382e:	605a      	str	r2, [r3, #4]
    if((hdma->Init.Request >= DMA_REQUEST_GENERATOR0) && (hdma->Init.Request <= DMA_REQUEST_GENERATOR7))
 8003830:	6860      	ldr	r0, [r4, #4]
 8003832:	1e41      	subs	r1, r0, #1
 8003834:	2907      	cmp	r1, #7
 8003836:	d912      	bls.n	800385e <HAL_DMA_DeInit+0x47a>
    hdma->DMAmuxRequestGen = 0U;
 8003838:	2300      	movs	r3, #0
    hdma->DMAmuxRequestGenStatus = 0U;
 800383a:	e9c4 331b 	strd	r3, r3, [r4, #108]	; 0x6c
    hdma->DMAmuxRequestGenStatusMask = 0U;
 800383e:	6763      	str	r3, [r4, #116]	; 0x74
  hdma->XferCpltCallback       = NULL;
 8003840:	2300      	movs	r3, #0
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003842:	6563      	str	r3, [r4, #84]	; 0x54
  return HAL_OK;
 8003844:	4618      	mov	r0, r3
  hdma->State = HAL_DMA_STATE_RESET;
 8003846:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  __HAL_UNLOCK(hdma);
 800384a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  hdma->XferHalfCpltCallback   = NULL;
 800384e:	e9c4 330f 	strd	r3, r3, [r4, #60]	; 0x3c
  hdma->XferM1HalfCpltCallback = NULL;
 8003852:	e9c4 3311 	strd	r3, r3, [r4, #68]	; 0x44
  hdma->XferAbortCallback      = NULL;
 8003856:	e9c4 3313 	strd	r3, r3, [r4, #76]	; 0x4c
}
 800385a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if(IS_BDMA_CHANNEL_DMAMUX_INSTANCE(hdma->Instance) != 0U)
 800385e:	f245 4308 	movw	r3, #21512	; 0x5408
 8003862:	f245 451c 	movw	r5, #21532	; 0x541c
 8003866:	6822      	ldr	r2, [r4, #0]
 8003868:	f245 4630 	movw	r6, #21552	; 0x5430
 800386c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003870:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003874:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8003878:	f245 4758 	movw	r7, #21592	; 0x5458
 800387c:	42aa      	cmp	r2, r5
 800387e:	bf18      	it	ne
 8003880:	429a      	cmpne	r2, r3
 8003882:	f245 4544 	movw	r5, #21572	; 0x5444
 8003886:	f6c5 0702 	movt	r7, #22530	; 0x5802
 800388a:	bf0c      	ite	eq
 800388c:	2301      	moveq	r3, #1
 800388e:	2300      	movne	r3, #0
 8003890:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003894:	42b2      	cmp	r2, r6
 8003896:	bf08      	it	eq
 8003898:	f043 0301 	orreq.w	r3, r3, #1
 800389c:	f245 466c 	movw	r6, #21612	; 0x546c
 80038a0:	42aa      	cmp	r2, r5
 80038a2:	bf08      	it	eq
 80038a4:	f043 0301 	orreq.w	r3, r3, #1
 80038a8:	f6c5 0602 	movt	r6, #22530	; 0x5802
 80038ac:	f44f 45a9 	mov.w	r5, #21632	; 0x5480
 80038b0:	42ba      	cmp	r2, r7
 80038b2:	bf08      	it	eq
 80038b4:	f043 0301 	orreq.w	r3, r3, #1
 80038b8:	f6c5 0502 	movt	r5, #22530	; 0x5802
 80038bc:	42b2      	cmp	r2, r6
 80038be:	bf08      	it	eq
 80038c0:	f043 0301 	orreq.w	r3, r3, #1
 80038c4:	42aa      	cmp	r2, r5
 80038c6:	bf08      	it	eq
 80038c8:	f043 0301 	orreq.w	r3, r3, #1
 80038cc:	b933      	cbnz	r3, 80038dc <HAL_DMA_DeInit+0x4f8>
 80038ce:	f245 4394 	movw	r3, #21652	; 0x5494
 80038d2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80038d6:	429a      	cmp	r2, r3
 80038d8:	f040 8094 	bne.w	8003a04 <HAL_DMA_DeInit+0x620>
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80038dc:	f249 633f 	movw	r3, #38463	; 0x963f
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 80038e0:	f645 1540 	movw	r5, #22848	; 0x5940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80038e4:	f2c1 6300 	movt	r3, #5632	; 0x1600
      hdma->DMAmuxRequestGenStatus = DMAMUX2_RequestGenStatus;
 80038e8:	f6c5 0502 	movt	r5, #22530	; 0x5802
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX2_RequestGenerator0) + ((request - 1U) * 4U)));
 80038ec:	4403      	add	r3, r0
 80038ee:	009b      	lsls	r3, r3, #2
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 80038f0:	2201      	movs	r2, #1
      hdma->DMAmuxRequestGen->RGCR = 0U;
 80038f2:	2000      	movs	r0, #0
 80038f4:	6725      	str	r5, [r4, #112]	; 0x70
    hdma->DMAmuxRequestGenStatusMask = 1UL << (request - 1U);
 80038f6:	fa02 f101 	lsl.w	r1, r2, r1
 80038fa:	6761      	str	r1, [r4, #116]	; 0x74
      hdma->DMAmuxRequestGen->RGCR = 0U;
 80038fc:	6018      	str	r0, [r3, #0]
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80038fe:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
 8003902:	605a      	str	r2, [r3, #4]
 8003904:	e798      	b.n	8003838 <HAL_DMA_DeInit+0x454>
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003906:	f64f 31f0 	movw	r1, #64496	; 0xfbf0
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800390a:	f64a 20ab 	movw	r0, #43691	; 0xaaab
 800390e:	f1a9 0310 	sub.w	r3, r9, #16
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003912:	f6cb 71fd 	movt	r1, #49149	; 0xbffd
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003916:	f6ca 20aa 	movt	r0, #43690	; 0xaaaa
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 800391a:	4411      	add	r1, r2
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 800391c:	fba0 0303 	umull	r0, r3, r0, r3
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003920:	29a8      	cmp	r1, #168	; 0xa8
    stream_number = (((uint32_t)((uint32_t*)hdma->Instance) & 0xFFU) - 16U) / 24U;
 8003922:	ea4f 1313 	mov.w	r3, r3, lsr #4
    if((stream_baseaddress <= ((uint32_t)DMA2_Stream7) ) && \
 8003926:	d800      	bhi.n	800392a <HAL_DMA_DeInit+0x546>
      stream_number += 8U;
 8003928:	3308      	adds	r3, #8
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 800392a:	f44f 4202 	mov.w	r2, #33280	; 0x8200
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800392e:	f003 051f 	and.w	r5, r3, #31
 8003932:	2101      	movs	r1, #1
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 8003934:	f44f 6008 	mov.w	r0, #2176	; 0x880
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003938:	f2c1 0200 	movt	r2, #4096	; 0x1000
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 800393c:	40a9      	lsls	r1, r5
    hdma->DMAmuxChannelStatus = DMAMUX1_ChannelStatus;
 800393e:	f2c4 0002 	movt	r0, #16386	; 0x4002
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003942:	441a      	add	r2, r3
    hdma->DMAmuxChannelStatusMask = 1UL << (stream_number & 0x1FU);
 8003944:	66a1      	str	r1, [r4, #104]	; 0x68
    hdma->DMAmuxChannel = (DMAMUX_Channel_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_Channel0) + (stream_number * 4U)));
 8003946:	0092      	lsls	r2, r2, #2
 8003948:	e9c4 2018 	strd	r2, r0, [r4, #96]	; 0x60
 800394c:	e76a      	b.n	8003824 <HAL_DMA_DeInit+0x440>
    return HAL_ERROR;
 800394e:	2001      	movs	r0, #1
}
 8003950:	4770      	bx	lr
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 8003952:	f245 4308 	movw	r3, #21512	; 0x5408
 8003956:	f245 451c 	movw	r5, #21532	; 0x541c
 800395a:	f245 4030 	movw	r0, #21552	; 0x5430
 800395e:	f245 4144 	movw	r1, #21572	; 0x5444
 8003962:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003966:	f6c5 0502 	movt	r5, #22530	; 0x5802
 800396a:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800396e:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8003972:	42aa      	cmp	r2, r5
 8003974:	bf18      	it	ne
 8003976:	429a      	cmpne	r2, r3
 8003978:	f245 4558 	movw	r5, #21592	; 0x5458
 800397c:	bf0c      	ite	eq
 800397e:	2301      	moveq	r3, #1
 8003980:	2300      	movne	r3, #0
 8003982:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003986:	4282      	cmp	r2, r0
 8003988:	bf08      	it	eq
 800398a:	f043 0301 	orreq.w	r3, r3, #1
 800398e:	f245 406c 	movw	r0, #21612	; 0x546c
 8003992:	428a      	cmp	r2, r1
 8003994:	bf08      	it	eq
 8003996:	f043 0301 	orreq.w	r3, r3, #1
 800399a:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800399e:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 80039a2:	42aa      	cmp	r2, r5
 80039a4:	bf08      	it	eq
 80039a6:	f043 0301 	orreq.w	r3, r3, #1
 80039aa:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80039ae:	4282      	cmp	r2, r0
 80039b0:	bf08      	it	eq
 80039b2:	f043 0301 	orreq.w	r3, r3, #1
 80039b6:	428a      	cmp	r2, r1
 80039b8:	bf08      	it	eq
 80039ba:	f043 0301 	orreq.w	r3, r3, #1
 80039be:	b92b      	cbnz	r3, 80039cc <HAL_DMA_DeInit+0x5e8>
 80039c0:	f245 4394 	movw	r3, #21652	; 0x5494
 80039c4:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80039c8:	429a      	cmp	r2, r3
 80039ca:	d118      	bne.n	80039fe <HAL_DMA_DeInit+0x61a>
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 80039cc:	2300      	movs	r3, #0
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80039ce:	4620      	mov	r0, r4
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CCR  = 0U;
 80039d0:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = 0U;
 80039d2:	6822      	ldr	r2, [r4, #0]
 80039d4:	6053      	str	r3, [r2, #4]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR  = 0U;
 80039d6:	6822      	ldr	r2, [r4, #0]
 80039d8:	6093      	str	r3, [r2, #8]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = 0U;
 80039da:	6822      	ldr	r2, [r4, #0]
 80039dc:	60d3      	str	r3, [r2, #12]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CM1AR = 0U;
 80039de:	6822      	ldr	r2, [r4, #0]
 80039e0:	6113      	str	r3, [r2, #16]
    regs_bdma = (BDMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 80039e2:	f7fe ff77 	bl	80028d4 <DMA_CalcBaseAndBitshift>
    regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80039e6:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80039e8:	2301      	movs	r3, #1
 80039ea:	f002 021f 	and.w	r2, r2, #31
 80039ee:	4093      	lsls	r3, r2
 80039f0:	6043      	str	r3, [r0, #4]
 80039f2:	e61e      	b.n	8003632 <HAL_DMA_DeInit+0x24e>
    hdma->StreamBaseAddress = ((uint32_t)((uint32_t*)hdma->Instance) & (uint32_t)(~0xFFU));
 80039f4:	f022 01ff 	bic.w	r1, r2, #255	; 0xff
 80039f8:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80039fa:	65a1      	str	r1, [r4, #88]	; 0x58
 80039fc:	e613      	b.n	8003626 <HAL_DMA_DeInit+0x242>
    return HAL_ERROR;
 80039fe:	2001      	movs	r0, #1
}
 8003a00:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003a04:	f248 233f 	movw	r3, #33343	; 0x823f
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8003a08:	f44f 6514 	mov.w	r5, #2368	; 0x940
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003a0c:	f2c1 0300 	movt	r3, #4096	; 0x1000
      hdma->DMAmuxRequestGenStatus = DMAMUX1_RequestGenStatus;
 8003a10:	f2c4 0502 	movt	r5, #16386	; 0x4002
      hdma->DMAmuxRequestGen = (DMAMUX_RequestGen_TypeDef *)((uint32_t)(((uint32_t)DMAMUX1_RequestGenerator0) + ((request - 1U) * 4U)));
 8003a14:	4403      	add	r3, r0
 8003a16:	009b      	lsls	r3, r3, #2
 8003a18:	e76a      	b.n	80038f0 <HAL_DMA_DeInit+0x50c>
 8003a1a:	bf00      	nop

08003a1c <HAL_DMA_Start_IT>:
{
 8003a1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003a1e:	461d      	mov	r5, r3
 8003a20:	460e      	mov	r6, r1
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003a22:	f64f 73fe 	movw	r3, #65534	; 0xfffe
{
 8003a26:	4604      	mov	r4, r0
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003a28:	1e69      	subs	r1, r5, #1
{
 8003a2a:	4617      	mov	r7, r2
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003a2c:	4299      	cmp	r1, r3
 8003a2e:	d813      	bhi.n	8003a58 <HAL_DMA_Start_IT+0x3c>
  if(hdma == NULL)
 8003a30:	b1e4      	cbz	r4, 8003a6c <HAL_DMA_Start_IT+0x50>
  __HAL_LOCK(hdma);
 8003a32:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 8003a36:	2b01      	cmp	r3, #1
 8003a38:	f000 8346 	beq.w	80040c8 <HAL_DMA_Start_IT+0x6ac>
 8003a3c:	2001      	movs	r0, #1
  if(HAL_DMA_STATE_READY == hdma->State)
 8003a3e:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8003a42:	4283      	cmp	r3, r0
  __HAL_LOCK(hdma);
 8003a44:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
  if(HAL_DMA_STATE_READY == hdma->State)
 8003a48:	d012      	beq.n	8003a70 <HAL_DMA_Start_IT+0x54>
    __HAL_UNLOCK(hdma);
 8003a4a:	2200      	movs	r2, #0
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8003a4c:	f44f 6300 	mov.w	r3, #2048	; 0x800
    __HAL_UNLOCK(hdma);
 8003a50:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8003a54:	6563      	str	r3, [r4, #84]	; 0x54
}
 8003a56:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_DMA_BUFFER_SIZE(DataLength));
 8003a58:	f64d 10f8 	movw	r0, #55800	; 0xd9f8
 8003a5c:	f240 21a7 	movw	r1, #679	; 0x2a7
 8003a60:	f6c0 0002 	movt	r0, #2050	; 0x802
 8003a64:	f011 ff00 	bl	8015868 <assert_failed>
  if(hdma == NULL)
 8003a68:	2c00      	cmp	r4, #0
 8003a6a:	d1e2      	bne.n	8003a32 <HAL_DMA_Start_IT+0x16>
    return HAL_ERROR;
 8003a6c:	2001      	movs	r0, #1
}
 8003a6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_DMA_DISABLE(hdma);
 8003a70:	6822      	ldr	r2, [r4, #0]
    hdma->State = HAL_DMA_STATE_BUSY;
 8003a72:	2002      	movs	r0, #2
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003a74:	2100      	movs	r1, #0
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a76:	f04f 0c70 	mov.w	ip, #112	; 0x70
    hdma->State = HAL_DMA_STATE_BUSY;
 8003a7a:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a7e:	2010      	movs	r0, #16
    hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8003a80:	6561      	str	r1, [r4, #84]	; 0x54
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a82:	f2c4 0c02 	movt	ip, #16386	; 0x4002
    __HAL_DMA_DISABLE(hdma);
 8003a86:	6813      	ldr	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a88:	f2c4 0002 	movt	r0, #16386	; 0x4002
    __HAL_DMA_DISABLE(hdma);
 8003a8c:	f023 0301 	bic.w	r3, r3, #1
 8003a90:	6013      	str	r3, [r2, #0]
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003a92:	2328      	movs	r3, #40	; 0x28
 8003a94:	6821      	ldr	r1, [r4, #0]
 8003a96:	2240      	movs	r2, #64	; 0x40
 8003a98:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003a9c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003aa0:	4299      	cmp	r1, r3
 8003aa2:	bf18      	it	ne
 8003aa4:	4281      	cmpne	r1, r0
 8003aa6:	f04f 0358 	mov.w	r3, #88	; 0x58
 8003aaa:	bf0c      	ite	eq
 8003aac:	2001      	moveq	r0, #1
 8003aae:	2000      	movne	r0, #0
 8003ab0:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003ab4:	4291      	cmp	r1, r2
 8003ab6:	bf08      	it	eq
 8003ab8:	f040 0001 	orreq.w	r0, r0, #1
 8003abc:	22a0      	movs	r2, #160	; 0xa0
 8003abe:	4299      	cmp	r1, r3
 8003ac0:	bf08      	it	eq
 8003ac2:	f040 0001 	orreq.w	r0, r0, #1
 8003ac6:	2388      	movs	r3, #136	; 0x88
 8003ac8:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003acc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003ad0:	4561      	cmp	r1, ip
 8003ad2:	bf08      	it	eq
 8003ad4:	f040 0001 	orreq.w	r0, r0, #1
 8003ad8:	f44f 6c82 	mov.w	ip, #1040	; 0x410
 8003adc:	4299      	cmp	r1, r3
 8003ade:	bf08      	it	eq
 8003ae0:	f040 0001 	orreq.w	r0, r0, #1
 8003ae4:	23b8      	movs	r3, #184	; 0xb8
 8003ae6:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003aea:	4291      	cmp	r1, r2
 8003aec:	bf08      	it	eq
 8003aee:	f040 0001 	orreq.w	r0, r0, #1
 8003af2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003af6:	f44f 6288 	mov.w	r2, #1088	; 0x440
 8003afa:	4299      	cmp	r1, r3
 8003afc:	bf08      	it	eq
 8003afe:	f040 0001 	orreq.w	r0, r0, #1
 8003b02:	f44f 6385 	mov.w	r3, #1064	; 0x428
 8003b06:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003b0a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003b0e:	4561      	cmp	r1, ip
 8003b10:	bf08      	it	eq
 8003b12:	f040 0001 	orreq.w	r0, r0, #1
 8003b16:	f44f 6c8e 	mov.w	ip, #1136	; 0x470
 8003b1a:	4299      	cmp	r1, r3
 8003b1c:	bf08      	it	eq
 8003b1e:	f040 0001 	orreq.w	r0, r0, #1
 8003b22:	f44f 638b 	mov.w	r3, #1112	; 0x458
 8003b26:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003b2a:	4291      	cmp	r1, r2
 8003b2c:	bf08      	it	eq
 8003b2e:	f040 0001 	orreq.w	r0, r0, #1
 8003b32:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003b36:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
 8003b3a:	4299      	cmp	r1, r3
 8003b3c:	bf08      	it	eq
 8003b3e:	f040 0001 	orreq.w	r0, r0, #1
 8003b42:	f44f 6391 	mov.w	r3, #1160	; 0x488
 8003b46:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003b4a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003b4e:	4561      	cmp	r1, ip
 8003b50:	bf08      	it	eq
 8003b52:	f040 0001 	orreq.w	r0, r0, #1
 8003b56:	f245 4c08 	movw	ip, #21512	; 0x5408
 8003b5a:	4299      	cmp	r1, r3
 8003b5c:	bf08      	it	eq
 8003b5e:	f040 0001 	orreq.w	r0, r0, #1
 8003b62:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8003b66:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8003b6a:	4291      	cmp	r1, r2
 8003b6c:	bf08      	it	eq
 8003b6e:	f040 0001 	orreq.w	r0, r0, #1
 8003b72:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003b76:	f245 4230 	movw	r2, #21552	; 0x5430
 8003b7a:	4299      	cmp	r1, r3
 8003b7c:	bf08      	it	eq
 8003b7e:	f040 0001 	orreq.w	r0, r0, #1
 8003b82:	f245 431c 	movw	r3, #21532	; 0x541c
 8003b86:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8003b8a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003b8e:	4561      	cmp	r1, ip
 8003b90:	bf08      	it	eq
 8003b92:	f040 0001 	orreq.w	r0, r0, #1
 8003b96:	f245 4c58 	movw	ip, #21592	; 0x5458
 8003b9a:	4299      	cmp	r1, r3
 8003b9c:	bf08      	it	eq
 8003b9e:	f040 0001 	orreq.w	r0, r0, #1
 8003ba2:	f245 4344 	movw	r3, #21572	; 0x5444
 8003ba6:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8003baa:	4291      	cmp	r1, r2
 8003bac:	bf08      	it	eq
 8003bae:	f040 0001 	orreq.w	r0, r0, #1
 8003bb2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003bb6:	f245 426c 	movw	r2, #21612	; 0x546c
 8003bba:	4299      	cmp	r1, r3
 8003bbc:	bf08      	it	eq
 8003bbe:	f040 0001 	orreq.w	r0, r0, #1
 8003bc2:	f44f 43a9 	mov.w	r3, #21632	; 0x5480
 8003bc6:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8003bca:	4561      	cmp	r1, ip
 8003bcc:	bf08      	it	eq
 8003bce:	f040 0001 	orreq.w	r0, r0, #1
 8003bd2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003bd6:	4291      	cmp	r1, r2
 8003bd8:	bf08      	it	eq
 8003bda:	f040 0001 	orreq.w	r0, r0, #1
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8003bde:	6da2      	ldr	r2, [r4, #88]	; 0x58
  if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003be0:	4299      	cmp	r1, r3
 8003be2:	bf08      	it	eq
 8003be4:	f040 0001 	orreq.w	r0, r0, #1
 8003be8:	b928      	cbnz	r0, 8003bf6 <HAL_DMA_Start_IT+0x1da>
 8003bea:	f245 4394 	movw	r3, #21652	; 0x5494
 8003bee:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003bf2:	4299      	cmp	r1, r3
 8003bf4:	d108      	bne.n	8003c08 <HAL_DMA_Start_IT+0x1ec>
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8003bf6:	e9d4 3119 	ldrd	r3, r1, [r4, #100]	; 0x64
 8003bfa:	6059      	str	r1, [r3, #4]
    if(hdma->DMAmuxRequestGen != 0U)
 8003bfc:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003bfe:	b113      	cbz	r3, 8003c06 <HAL_DMA_Start_IT+0x1ea>
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 8003c00:	e9d4 311c 	ldrd	r3, r1, [r4, #112]	; 0x70
 8003c04:	6059      	str	r1, [r3, #4]
 8003c06:	6821      	ldr	r1, [r4, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003c08:	2310      	movs	r3, #16
 8003c0a:	2028      	movs	r0, #40	; 0x28
 8003c0c:	f04f 0c40 	mov.w	ip, #64	; 0x40
 8003c10:	f04f 0e70 	mov.w	lr, #112	; 0x70
 8003c14:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003c18:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003c1c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003c20:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8003c24:	4281      	cmp	r1, r0
 8003c26:	bf18      	it	ne
 8003c28:	4299      	cmpne	r1, r3
 8003c2a:	f04f 0058 	mov.w	r0, #88	; 0x58
 8003c2e:	bf0c      	ite	eq
 8003c30:	2301      	moveq	r3, #1
 8003c32:	2300      	movne	r3, #0
 8003c34:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003c38:	4561      	cmp	r1, ip
 8003c3a:	bf08      	it	eq
 8003c3c:	f043 0301 	orreq.w	r3, r3, #1
 8003c40:	f04f 0ca0 	mov.w	ip, #160	; 0xa0
 8003c44:	4281      	cmp	r1, r0
 8003c46:	bf08      	it	eq
 8003c48:	f043 0301 	orreq.w	r3, r3, #1
 8003c4c:	2088      	movs	r0, #136	; 0x88
 8003c4e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003c52:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003c56:	4571      	cmp	r1, lr
 8003c58:	bf08      	it	eq
 8003c5a:	f043 0301 	orreq.w	r3, r3, #1
 8003c5e:	f44f 6e82 	mov.w	lr, #1040	; 0x410
 8003c62:	4281      	cmp	r1, r0
 8003c64:	bf08      	it	eq
 8003c66:	f043 0301 	orreq.w	r3, r3, #1
 8003c6a:	20b8      	movs	r0, #184	; 0xb8
 8003c6c:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8003c70:	4561      	cmp	r1, ip
 8003c72:	bf08      	it	eq
 8003c74:	f043 0301 	orreq.w	r3, r3, #1
 8003c78:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003c7c:	f44f 6c88 	mov.w	ip, #1088	; 0x440
 8003c80:	4281      	cmp	r1, r0
 8003c82:	bf08      	it	eq
 8003c84:	f043 0301 	orreq.w	r3, r3, #1
 8003c88:	f44f 6085 	mov.w	r0, #1064	; 0x428
 8003c8c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003c90:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003c94:	4571      	cmp	r1, lr
 8003c96:	bf08      	it	eq
 8003c98:	f043 0301 	orreq.w	r3, r3, #1
 8003c9c:	f44f 6e8e 	mov.w	lr, #1136	; 0x470
 8003ca0:	4281      	cmp	r1, r0
 8003ca2:	bf08      	it	eq
 8003ca4:	f043 0301 	orreq.w	r3, r3, #1
 8003ca8:	f44f 608b 	mov.w	r0, #1112	; 0x458
 8003cac:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8003cb0:	4561      	cmp	r1, ip
 8003cb2:	bf08      	it	eq
 8003cb4:	f043 0301 	orreq.w	r3, r3, #1
 8003cb8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003cbc:	f44f 6c91 	mov.w	ip, #1160	; 0x488
 8003cc0:	4281      	cmp	r1, r0
 8003cc2:	bf08      	it	eq
 8003cc4:	f043 0301 	orreq.w	r3, r3, #1
 8003cc8:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 8003ccc:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8003cd0:	4571      	cmp	r1, lr
 8003cd2:	bf08      	it	eq
 8003cd4:	f043 0301 	orreq.w	r3, r3, #1
 8003cd8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003cdc:	4561      	cmp	r1, ip
 8003cde:	bf08      	it	eq
 8003ce0:	f043 0301 	orreq.w	r3, r3, #1
 8003ce4:	4281      	cmp	r1, r0
 8003ce6:	bf08      	it	eq
 8003ce8:	f043 0301 	orreq.w	r3, r3, #1
 8003cec:	b933      	cbnz	r3, 8003cfc <HAL_DMA_Start_IT+0x2e0>
 8003cee:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8003cf2:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003cf6:	4299      	cmp	r1, r3
 8003cf8:	f040 81e8 	bne.w	80040cc <HAL_DMA_Start_IT+0x6b0>
    regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8003cfc:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8003cfe:	233f      	movs	r3, #63	; 0x3f
 8003d00:	f001 011f 	and.w	r1, r1, #31
 8003d04:	408b      	lsls	r3, r1
 8003d06:	6093      	str	r3, [r2, #8]
    ((DMA_Stream_TypeDef *)hdma->Instance)->CR &= (uint32_t)(~DMA_SxCR_DBM);
 8003d08:	6822      	ldr	r2, [r4, #0]
 8003d0a:	6813      	ldr	r3, [r2, #0]
 8003d0c:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8003d10:	6013      	str	r3, [r2, #0]
    ((BDMA_Channel_TypeDef *)hdma->Instance)->CNDTR = DataLength;
 8003d12:	6823      	ldr	r3, [r4, #0]
 8003d14:	605d      	str	r5, [r3, #4]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003d16:	68a3      	ldr	r3, [r4, #8]
 8003d18:	2b40      	cmp	r3, #64	; 0x40
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 8003d1a:	6823      	ldr	r3, [r4, #0]
    if((hdma->Init.Direction) == DMA_MEMORY_TO_PERIPH)
 8003d1c:	f000 81cf 	beq.w	80040be <HAL_DMA_Start_IT+0x6a2>
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = SrcAddress;
 8003d20:	609e      	str	r6, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = DstAddress;
 8003d22:	6823      	ldr	r3, [r4, #0]
 8003d24:	60df      	str	r7, [r3, #12]
 8003d26:	6821      	ldr	r1, [r4, #0]
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8003d28:	2310      	movs	r3, #16
 8003d2a:	2028      	movs	r0, #40	; 0x28
 8003d2c:	2240      	movs	r2, #64	; 0x40
 8003d2e:	2558      	movs	r5, #88	; 0x58
 8003d30:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003d34:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003d38:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003d3c:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003d40:	4281      	cmp	r1, r0
 8003d42:	bf18      	it	ne
 8003d44:	4299      	cmpne	r1, r3
 8003d46:	f04f 0070 	mov.w	r0, #112	; 0x70
 8003d4a:	bf0c      	ite	eq
 8003d4c:	2301      	moveq	r3, #1
 8003d4e:	2300      	movne	r3, #0
 8003d50:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003d54:	4291      	cmp	r1, r2
 8003d56:	bf08      	it	eq
 8003d58:	f043 0301 	orreq.w	r3, r3, #1
 8003d5c:	2288      	movs	r2, #136	; 0x88
 8003d5e:	42a9      	cmp	r1, r5
 8003d60:	bf08      	it	eq
 8003d62:	f043 0301 	orreq.w	r3, r3, #1
 8003d66:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003d6a:	25a0      	movs	r5, #160	; 0xa0
 8003d6c:	4281      	cmp	r1, r0
 8003d6e:	bf08      	it	eq
 8003d70:	f043 0301 	orreq.w	r3, r3, #1
 8003d74:	20b8      	movs	r0, #184	; 0xb8
 8003d76:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003d7a:	4291      	cmp	r1, r2
 8003d7c:	bf08      	it	eq
 8003d7e:	f043 0301 	orreq.w	r3, r3, #1
 8003d82:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003d86:	f44f 6282 	mov.w	r2, #1040	; 0x410
 8003d8a:	42a9      	cmp	r1, r5
 8003d8c:	bf08      	it	eq
 8003d8e:	f043 0301 	orreq.w	r3, r3, #1
 8003d92:	f44f 6585 	mov.w	r5, #1064	; 0x428
 8003d96:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003d9a:	4281      	cmp	r1, r0
 8003d9c:	bf08      	it	eq
 8003d9e:	f043 0301 	orreq.w	r3, r3, #1
 8003da2:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003da6:	f44f 6088 	mov.w	r0, #1088	; 0x440
 8003daa:	4291      	cmp	r1, r2
 8003dac:	bf08      	it	eq
 8003dae:	f043 0301 	orreq.w	r3, r3, #1
 8003db2:	f44f 628b 	mov.w	r2, #1112	; 0x458
 8003db6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003dba:	42a9      	cmp	r1, r5
 8003dbc:	bf08      	it	eq
 8003dbe:	f043 0301 	orreq.w	r3, r3, #1
 8003dc2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003dc6:	f44f 658e 	mov.w	r5, #1136	; 0x470
 8003dca:	4281      	cmp	r1, r0
 8003dcc:	bf08      	it	eq
 8003dce:	f043 0301 	orreq.w	r3, r3, #1
 8003dd2:	f44f 6091 	mov.w	r0, #1160	; 0x488
 8003dd6:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003dda:	4291      	cmp	r1, r2
 8003ddc:	bf08      	it	eq
 8003dde:	f043 0301 	orreq.w	r3, r3, #1
 8003de2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003de6:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
 8003dea:	42a9      	cmp	r1, r5
 8003dec:	bf08      	it	eq
 8003dee:	f043 0301 	orreq.w	r3, r3, #1
 8003df2:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003df6:	4281      	cmp	r1, r0
 8003df8:	bf08      	it	eq
 8003dfa:	f043 0301 	orreq.w	r3, r3, #1
 8003dfe:	4291      	cmp	r1, r2
 8003e00:	bf08      	it	eq
 8003e02:	f043 0301 	orreq.w	r3, r3, #1
 8003e06:	b933      	cbnz	r3, 8003e16 <HAL_DMA_Start_IT+0x3fa>
 8003e08:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8003e0c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003e10:	4299      	cmp	r1, r3
 8003e12:	f040 81a5 	bne.w	8004160 <HAL_DMA_Start_IT+0x744>
      MODIFY_REG(((DMA_Stream_TypeDef   *)hdma->Instance)->CR, (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT), (DMA_IT_TC | DMA_IT_TE | DMA_IT_DME));
 8003e16:	680b      	ldr	r3, [r1, #0]
 8003e18:	f023 031e 	bic.w	r3, r3, #30
 8003e1c:	f043 0316 	orr.w	r3, r3, #22
 8003e20:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 8003e22:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8003e24:	b123      	cbz	r3, 8003e30 <HAL_DMA_Start_IT+0x414>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  |= DMA_IT_HT;
 8003e26:	6822      	ldr	r2, [r4, #0]
 8003e28:	6813      	ldr	r3, [r2, #0]
 8003e2a:	f043 0308 	orr.w	r3, r3, #8
 8003e2e:	6013      	str	r3, [r2, #0]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8003e30:	2310      	movs	r3, #16
 8003e32:	2228      	movs	r2, #40	; 0x28
 8003e34:	6821      	ldr	r1, [r4, #0]
 8003e36:	2540      	movs	r5, #64	; 0x40
 8003e38:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003e3c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003e40:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003e44:	2058      	movs	r0, #88	; 0x58
 8003e46:	4291      	cmp	r1, r2
 8003e48:	bf18      	it	ne
 8003e4a:	4299      	cmpne	r1, r3
 8003e4c:	f04f 0270 	mov.w	r2, #112	; 0x70
 8003e50:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003e54:	bf0c      	ite	eq
 8003e56:	2301      	moveq	r3, #1
 8003e58:	2300      	movne	r3, #0
 8003e5a:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003e5e:	42a9      	cmp	r1, r5
 8003e60:	bf08      	it	eq
 8003e62:	f043 0301 	orreq.w	r3, r3, #1
 8003e66:	2588      	movs	r5, #136	; 0x88
 8003e68:	4281      	cmp	r1, r0
 8003e6a:	bf08      	it	eq
 8003e6c:	f043 0301 	orreq.w	r3, r3, #1
 8003e70:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003e74:	20a0      	movs	r0, #160	; 0xa0
 8003e76:	4291      	cmp	r1, r2
 8003e78:	bf08      	it	eq
 8003e7a:	f043 0301 	orreq.w	r3, r3, #1
 8003e7e:	22b8      	movs	r2, #184	; 0xb8
 8003e80:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003e84:	42a9      	cmp	r1, r5
 8003e86:	bf08      	it	eq
 8003e88:	f043 0301 	orreq.w	r3, r3, #1
 8003e8c:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003e90:	f44f 6582 	mov.w	r5, #1040	; 0x410
 8003e94:	4281      	cmp	r1, r0
 8003e96:	bf08      	it	eq
 8003e98:	f043 0301 	orreq.w	r3, r3, #1
 8003e9c:	f44f 6085 	mov.w	r0, #1064	; 0x428
 8003ea0:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003ea4:	4291      	cmp	r1, r2
 8003ea6:	bf08      	it	eq
 8003ea8:	f043 0301 	orreq.w	r3, r3, #1
 8003eac:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003eb0:	f44f 6288 	mov.w	r2, #1088	; 0x440
 8003eb4:	42a9      	cmp	r1, r5
 8003eb6:	bf08      	it	eq
 8003eb8:	f043 0301 	orreq.w	r3, r3, #1
 8003ebc:	f44f 658b 	mov.w	r5, #1112	; 0x458
 8003ec0:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003ec4:	4281      	cmp	r1, r0
 8003ec6:	bf08      	it	eq
 8003ec8:	f043 0301 	orreq.w	r3, r3, #1
 8003ecc:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003ed0:	f44f 608e 	mov.w	r0, #1136	; 0x470
 8003ed4:	4291      	cmp	r1, r2
 8003ed6:	bf08      	it	eq
 8003ed8:	f043 0301 	orreq.w	r3, r3, #1
 8003edc:	f44f 6291 	mov.w	r2, #1160	; 0x488
 8003ee0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003ee4:	42a9      	cmp	r1, r5
 8003ee6:	bf08      	it	eq
 8003ee8:	f043 0301 	orreq.w	r3, r3, #1
 8003eec:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003ef0:	f44f 6594 	mov.w	r5, #1184	; 0x4a0
 8003ef4:	4281      	cmp	r1, r0
 8003ef6:	bf08      	it	eq
 8003ef8:	f043 0301 	orreq.w	r3, r3, #1
 8003efc:	f44f 6097 	mov.w	r0, #1208	; 0x4b8
 8003f00:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003f04:	4291      	cmp	r1, r2
 8003f06:	bf08      	it	eq
 8003f08:	f043 0301 	orreq.w	r3, r3, #1
 8003f0c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003f10:	f245 4208 	movw	r2, #21512	; 0x5408
 8003f14:	42a9      	cmp	r1, r5
 8003f16:	bf08      	it	eq
 8003f18:	f043 0301 	orreq.w	r3, r3, #1
 8003f1c:	f245 451c 	movw	r5, #21532	; 0x541c
 8003f20:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8003f24:	4281      	cmp	r1, r0
 8003f26:	bf08      	it	eq
 8003f28:	f043 0301 	orreq.w	r3, r3, #1
 8003f2c:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003f30:	f245 4030 	movw	r0, #21552	; 0x5430
 8003f34:	4291      	cmp	r1, r2
 8003f36:	bf08      	it	eq
 8003f38:	f043 0301 	orreq.w	r3, r3, #1
 8003f3c:	f245 4244 	movw	r2, #21572	; 0x5444
 8003f40:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8003f44:	42a9      	cmp	r1, r5
 8003f46:	bf08      	it	eq
 8003f48:	f043 0301 	orreq.w	r3, r3, #1
 8003f4c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8003f50:	f245 4558 	movw	r5, #21592	; 0x5458
 8003f54:	4281      	cmp	r1, r0
 8003f56:	bf08      	it	eq
 8003f58:	f043 0301 	orreq.w	r3, r3, #1
 8003f5c:	f245 406c 	movw	r0, #21612	; 0x546c
 8003f60:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8003f64:	4291      	cmp	r1, r2
 8003f66:	bf08      	it	eq
 8003f68:	f043 0301 	orreq.w	r3, r3, #1
 8003f6c:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8003f70:	f44f 42a9 	mov.w	r2, #21632	; 0x5480
 8003f74:	42a9      	cmp	r1, r5
 8003f76:	bf08      	it	eq
 8003f78:	f043 0301 	orreq.w	r3, r3, #1
 8003f7c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8003f80:	4281      	cmp	r1, r0
 8003f82:	bf08      	it	eq
 8003f84:	f043 0301 	orreq.w	r3, r3, #1
 8003f88:	4291      	cmp	r1, r2
 8003f8a:	bf08      	it	eq
 8003f8c:	f043 0301 	orreq.w	r3, r3, #1
 8003f90:	b92b      	cbnz	r3, 8003f9e <HAL_DMA_Start_IT+0x582>
 8003f92:	f245 4394 	movw	r3, #21652	; 0x5494
 8003f96:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8003f9a:	4299      	cmp	r1, r3
 8003f9c:	d10e      	bne.n	8003fbc <HAL_DMA_Start_IT+0x5a0>
      if((hdma->DMAmuxChannel->CCR & DMAMUX_CxCR_SE) != 0U)
 8003f9e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8003fa0:	681a      	ldr	r2, [r3, #0]
 8003fa2:	03d2      	lsls	r2, r2, #15
 8003fa4:	d503      	bpl.n	8003fae <HAL_DMA_Start_IT+0x592>
        hdma->DMAmuxChannel->CCR |= DMAMUX_CxCR_SOIE;
 8003fa6:	681a      	ldr	r2, [r3, #0]
 8003fa8:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003fac:	601a      	str	r2, [r3, #0]
      if(hdma->DMAmuxRequestGen != 0U)
 8003fae:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8003fb0:	b11b      	cbz	r3, 8003fba <HAL_DMA_Start_IT+0x59e>
        hdma->DMAmuxRequestGen->RGCR |= DMAMUX_RGxCR_OIE;
 8003fb2:	681a      	ldr	r2, [r3, #0]
 8003fb4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003fb8:	601a      	str	r2, [r3, #0]
 8003fba:	6821      	ldr	r1, [r4, #0]
    __HAL_DMA_ENABLE(hdma);
 8003fbc:	2310      	movs	r3, #16
 8003fbe:	2028      	movs	r0, #40	; 0x28
 8003fc0:	2240      	movs	r2, #64	; 0x40
 8003fc2:	2558      	movs	r5, #88	; 0x58
 8003fc4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8003fc8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003fcc:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8003fd0:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8003fd4:	4281      	cmp	r1, r0
 8003fd6:	bf18      	it	ne
 8003fd8:	4299      	cmpne	r1, r3
 8003fda:	f04f 0470 	mov.w	r4, #112	; 0x70
 8003fde:	f04f 0088 	mov.w	r0, #136	; 0x88
 8003fe2:	bf0c      	ite	eq
 8003fe4:	2301      	moveq	r3, #1
 8003fe6:	2300      	movne	r3, #0
 8003fe8:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8003fec:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8003ff0:	4291      	cmp	r1, r2
 8003ff2:	bf08      	it	eq
 8003ff4:	f043 0301 	orreq.w	r3, r3, #1
 8003ff8:	22a0      	movs	r2, #160	; 0xa0
 8003ffa:	42a9      	cmp	r1, r5
 8003ffc:	bf08      	it	eq
 8003ffe:	f043 0301 	orreq.w	r3, r3, #1
 8004002:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004006:	25b8      	movs	r5, #184	; 0xb8
 8004008:	42a1      	cmp	r1, r4
 800400a:	bf08      	it	eq
 800400c:	f043 0301 	orreq.w	r3, r3, #1
 8004010:	f44f 6482 	mov.w	r4, #1040	; 0x410
 8004014:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8004018:	4281      	cmp	r1, r0
 800401a:	bf08      	it	eq
 800401c:	f043 0301 	orreq.w	r3, r3, #1
 8004020:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004024:	f44f 6085 	mov.w	r0, #1064	; 0x428
 8004028:	4291      	cmp	r1, r2
 800402a:	bf08      	it	eq
 800402c:	f043 0301 	orreq.w	r3, r3, #1
 8004030:	f44f 6288 	mov.w	r2, #1088	; 0x440
 8004034:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004038:	42a9      	cmp	r1, r5
 800403a:	bf08      	it	eq
 800403c:	f043 0301 	orreq.w	r3, r3, #1
 8004040:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004044:	f44f 658b 	mov.w	r5, #1112	; 0x458
 8004048:	42a1      	cmp	r1, r4
 800404a:	bf08      	it	eq
 800404c:	f043 0301 	orreq.w	r3, r3, #1
 8004050:	f44f 648e 	mov.w	r4, #1136	; 0x470
 8004054:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8004058:	4281      	cmp	r1, r0
 800405a:	bf08      	it	eq
 800405c:	f043 0301 	orreq.w	r3, r3, #1
 8004060:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004064:	f44f 6091 	mov.w	r0, #1160	; 0x488
 8004068:	4291      	cmp	r1, r2
 800406a:	bf08      	it	eq
 800406c:	f043 0301 	orreq.w	r3, r3, #1
 8004070:	f44f 6294 	mov.w	r2, #1184	; 0x4a0
 8004074:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004078:	42a9      	cmp	r1, r5
 800407a:	bf08      	it	eq
 800407c:	f043 0301 	orreq.w	r3, r3, #1
 8004080:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004084:	42a1      	cmp	r1, r4
 8004086:	bf08      	it	eq
 8004088:	f043 0301 	orreq.w	r3, r3, #1
 800408c:	4281      	cmp	r1, r0
 800408e:	bf08      	it	eq
 8004090:	f043 0301 	orreq.w	r3, r3, #1
 8004094:	4291      	cmp	r1, r2
 8004096:	bf08      	it	eq
 8004098:	f043 0301 	orreq.w	r3, r3, #1
 800409c:	b94b      	cbnz	r3, 80040b2 <HAL_DMA_Start_IT+0x696>
 800409e:	f44f 6097 	mov.w	r0, #1208	; 0x4b8
 80040a2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80040a6:	1a08      	subs	r0, r1, r0
 80040a8:	fab0 f080 	clz	r0, r0
 80040ac:	0940      	lsrs	r0, r0, #5
 80040ae:	2800      	cmp	r0, #0
 80040b0:	d051      	beq.n	8004156 <HAL_DMA_Start_IT+0x73a>
 80040b2:	680b      	ldr	r3, [r1, #0]
  HAL_StatusTypeDef status = HAL_OK;
 80040b4:	2000      	movs	r0, #0
    __HAL_DMA_ENABLE(hdma);
 80040b6:	f043 0301 	orr.w	r3, r3, #1
 80040ba:	600b      	str	r3, [r1, #0]
}
 80040bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CPAR = DstAddress;
 80040be:	609f      	str	r7, [r3, #8]
      ((BDMA_Channel_TypeDef *)hdma->Instance)->CM0AR = SrcAddress;
 80040c0:	6823      	ldr	r3, [r4, #0]
 80040c2:	60de      	str	r6, [r3, #12]
 80040c4:	6821      	ldr	r1, [r4, #0]
 80040c6:	e62f      	b.n	8003d28 <HAL_DMA_Start_IT+0x30c>
  __HAL_LOCK(hdma);
 80040c8:	2002      	movs	r0, #2
}
 80040ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U) /* BDMA instance(s) */
 80040cc:	f245 4308 	movw	r3, #21512	; 0x5408
 80040d0:	f245 401c 	movw	r0, #21532	; 0x541c
 80040d4:	f245 4c30 	movw	ip, #21552	; 0x5430
 80040d8:	f245 4e58 	movw	lr, #21592	; 0x5458
 80040dc:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80040e0:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80040e4:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 80040e8:	f6c5 0e02 	movt	lr, #22530	; 0x5802
 80040ec:	4281      	cmp	r1, r0
 80040ee:	bf18      	it	ne
 80040f0:	4299      	cmpne	r1, r3
 80040f2:	f245 4044 	movw	r0, #21572	; 0x5444
 80040f6:	bf0c      	ite	eq
 80040f8:	2301      	moveq	r3, #1
 80040fa:	2300      	movne	r3, #0
 80040fc:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8004100:	4561      	cmp	r1, ip
 8004102:	bf08      	it	eq
 8004104:	f043 0301 	orreq.w	r3, r3, #1
 8004108:	f245 4c6c 	movw	ip, #21612	; 0x546c
 800410c:	4281      	cmp	r1, r0
 800410e:	bf08      	it	eq
 8004110:	f043 0301 	orreq.w	r3, r3, #1
 8004114:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8004118:	f44f 40a9 	mov.w	r0, #21632	; 0x5480
 800411c:	4571      	cmp	r1, lr
 800411e:	bf08      	it	eq
 8004120:	f043 0301 	orreq.w	r3, r3, #1
 8004124:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8004128:	4561      	cmp	r1, ip
 800412a:	bf08      	it	eq
 800412c:	f043 0301 	orreq.w	r3, r3, #1
 8004130:	4281      	cmp	r1, r0
 8004132:	bf08      	it	eq
 8004134:	f043 0301 	orreq.w	r3, r3, #1
 8004138:	b933      	cbnz	r3, 8004148 <HAL_DMA_Start_IT+0x72c>
 800413a:	f245 4394 	movw	r3, #21652	; 0x5494
 800413e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8004142:	4299      	cmp	r1, r3
 8004144:	f47f adf0 	bne.w	8003d28 <HAL_DMA_Start_IT+0x30c>
    regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 8004148:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800414a:	2301      	movs	r3, #1
 800414c:	f001 011f 	and.w	r1, r1, #31
 8004150:	408b      	lsls	r3, r1
 8004152:	6053      	str	r3, [r2, #4]
 8004154:	e5dd      	b.n	8003d12 <HAL_DMA_Start_IT+0x2f6>
    __HAL_DMA_ENABLE(hdma);
 8004156:	680b      	ldr	r3, [r1, #0]
 8004158:	f043 0301 	orr.w	r3, r3, #1
 800415c:	600b      	str	r3, [r1, #0]
}
 800415e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      MODIFY_REG(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR, (BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE), (BDMA_CCR_TCIE | BDMA_CCR_TEIE));
 8004160:	680b      	ldr	r3, [r1, #0]
 8004162:	f023 030e 	bic.w	r3, r3, #14
 8004166:	f043 030a 	orr.w	r3, r3, #10
 800416a:	600b      	str	r3, [r1, #0]
      if(hdma->XferHalfCpltCallback != NULL)
 800416c:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800416e:	2b00      	cmp	r3, #0
 8004170:	f43f ae5e 	beq.w	8003e30 <HAL_DMA_Start_IT+0x414>
        ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  |= BDMA_CCR_HTIE;
 8004174:	6822      	ldr	r2, [r4, #0]
 8004176:	6813      	ldr	r3, [r2, #0]
 8004178:	f043 0304 	orr.w	r3, r3, #4
 800417c:	6013      	str	r3, [r2, #0]
 800417e:	e657      	b.n	8003e30 <HAL_DMA_Start_IT+0x414>

08004180 <HAL_DMA_Abort>:
{
 8004180:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004182:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
 8004184:	f7fc fc5a 	bl	8000a3c <HAL_GetTick>
  if(hdma == NULL)
 8004188:	2e00      	cmp	r6, #0
 800418a:	f000 82a3 	beq.w	80046d4 <HAL_DMA_Abort+0x554>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800418e:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 8004192:	2b02      	cmp	r3, #2
 8004194:	d006      	beq.n	80041a4 <HAL_DMA_Abort+0x24>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8004196:	2280      	movs	r2, #128	; 0x80
    __HAL_UNLOCK(hdma);
 8004198:	2300      	movs	r3, #0
    return HAL_ERROR;
 800419a:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 800419c:	6572      	str	r2, [r6, #84]	; 0x54
    __HAL_UNLOCK(hdma);
 800419e:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34
}
 80041a2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 80041a4:	2310      	movs	r3, #16
 80041a6:	2128      	movs	r1, #40	; 0x28
 80041a8:	6832      	ldr	r2, [r6, #0]
 80041aa:	4604      	mov	r4, r0
 80041ac:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80041b0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80041b4:	2040      	movs	r0, #64	; 0x40
 80041b6:	2570      	movs	r5, #112	; 0x70
 80041b8:	428a      	cmp	r2, r1
 80041ba:	bf18      	it	ne
 80041bc:	429a      	cmpne	r2, r3
 80041be:	f04f 0158 	mov.w	r1, #88	; 0x58
 80041c2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80041c6:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80041ca:	bf0c      	ite	eq
 80041cc:	2301      	moveq	r3, #1
 80041ce:	2300      	movne	r3, #0
 80041d0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80041d4:	4282      	cmp	r2, r0
 80041d6:	bf08      	it	eq
 80041d8:	f043 0301 	orreq.w	r3, r3, #1
 80041dc:	20a0      	movs	r0, #160	; 0xa0
 80041de:	428a      	cmp	r2, r1
 80041e0:	bf08      	it	eq
 80041e2:	f043 0301 	orreq.w	r3, r3, #1
 80041e6:	2188      	movs	r1, #136	; 0x88
 80041e8:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80041ec:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80041f0:	42aa      	cmp	r2, r5
 80041f2:	bf08      	it	eq
 80041f4:	f043 0301 	orreq.w	r3, r3, #1
 80041f8:	f44f 6582 	mov.w	r5, #1040	; 0x410
 80041fc:	428a      	cmp	r2, r1
 80041fe:	bf08      	it	eq
 8004200:	f043 0301 	orreq.w	r3, r3, #1
 8004204:	21b8      	movs	r1, #184	; 0xb8
 8004206:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800420a:	4282      	cmp	r2, r0
 800420c:	bf08      	it	eq
 800420e:	f043 0301 	orreq.w	r3, r3, #1
 8004212:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004216:	f44f 6088 	mov.w	r0, #1088	; 0x440
 800421a:	428a      	cmp	r2, r1
 800421c:	bf08      	it	eq
 800421e:	f043 0301 	orreq.w	r3, r3, #1
 8004222:	f44f 6185 	mov.w	r1, #1064	; 0x428
 8004226:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800422a:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800422e:	42aa      	cmp	r2, r5
 8004230:	bf08      	it	eq
 8004232:	f043 0301 	orreq.w	r3, r3, #1
 8004236:	f44f 658e 	mov.w	r5, #1136	; 0x470
 800423a:	428a      	cmp	r2, r1
 800423c:	bf08      	it	eq
 800423e:	f043 0301 	orreq.w	r3, r3, #1
 8004242:	f44f 618b 	mov.w	r1, #1112	; 0x458
 8004246:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800424a:	4282      	cmp	r2, r0
 800424c:	bf08      	it	eq
 800424e:	f043 0301 	orreq.w	r3, r3, #1
 8004252:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004256:	f44f 6091 	mov.w	r0, #1160	; 0x488
 800425a:	428a      	cmp	r2, r1
 800425c:	bf08      	it	eq
 800425e:	f043 0301 	orreq.w	r3, r3, #1
 8004262:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 8004266:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800426a:	42aa      	cmp	r2, r5
 800426c:	bf08      	it	eq
 800426e:	f043 0301 	orreq.w	r3, r3, #1
 8004272:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004276:	4282      	cmp	r2, r0
 8004278:	bf08      	it	eq
 800427a:	f043 0301 	orreq.w	r3, r3, #1
 800427e:	428a      	cmp	r2, r1
 8004280:	bf08      	it	eq
 8004282:	f043 0301 	orreq.w	r3, r3, #1
 8004286:	b933      	cbnz	r3, 8004296 <HAL_DMA_Abort+0x116>
 8004288:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 800428c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004290:	429a      	cmp	r2, r3
 8004292:	f040 822b 	bne.w	80046ec <HAL_DMA_Abort+0x56c>
      ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME | DMA_IT_HT);
 8004296:	6813      	ldr	r3, [r2, #0]
 8004298:	f023 031e 	bic.w	r3, r3, #30
 800429c:	6013      	str	r3, [r2, #0]
      ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 800429e:	6832      	ldr	r2, [r6, #0]
 80042a0:	6953      	ldr	r3, [r2, #20]
 80042a2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80042a6:	6153      	str	r3, [r2, #20]
      enableRegister = (__IO uint32_t *)(&(((DMA_Stream_TypeDef   *)hdma->Instance)->CR));
 80042a8:	6832      	ldr	r2, [r6, #0]
 80042aa:	4615      	mov	r5, r2
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 80042ac:	2310      	movs	r3, #16
 80042ae:	2128      	movs	r1, #40	; 0x28
 80042b0:	2040      	movs	r0, #64	; 0x40
 80042b2:	2770      	movs	r7, #112	; 0x70
 80042b4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80042b8:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80042bc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80042c0:	f2c4 0702 	movt	r7, #16386	; 0x4002
 80042c4:	428a      	cmp	r2, r1
 80042c6:	bf18      	it	ne
 80042c8:	429a      	cmpne	r2, r3
 80042ca:	f04f 0158 	mov.w	r1, #88	; 0x58
 80042ce:	bf0c      	ite	eq
 80042d0:	2301      	moveq	r3, #1
 80042d2:	2300      	movne	r3, #0
 80042d4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80042d8:	4282      	cmp	r2, r0
 80042da:	bf08      	it	eq
 80042dc:	f043 0301 	orreq.w	r3, r3, #1
 80042e0:	20a0      	movs	r0, #160	; 0xa0
 80042e2:	428a      	cmp	r2, r1
 80042e4:	bf08      	it	eq
 80042e6:	f043 0301 	orreq.w	r3, r3, #1
 80042ea:	2188      	movs	r1, #136	; 0x88
 80042ec:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80042f0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80042f4:	42ba      	cmp	r2, r7
 80042f6:	bf08      	it	eq
 80042f8:	f043 0301 	orreq.w	r3, r3, #1
 80042fc:	f44f 6782 	mov.w	r7, #1040	; 0x410
 8004300:	428a      	cmp	r2, r1
 8004302:	bf08      	it	eq
 8004304:	f043 0301 	orreq.w	r3, r3, #1
 8004308:	21b8      	movs	r1, #184	; 0xb8
 800430a:	f2c4 0702 	movt	r7, #16386	; 0x4002
 800430e:	4282      	cmp	r2, r0
 8004310:	bf08      	it	eq
 8004312:	f043 0301 	orreq.w	r3, r3, #1
 8004316:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800431a:	f44f 6088 	mov.w	r0, #1088	; 0x440
 800431e:	428a      	cmp	r2, r1
 8004320:	bf08      	it	eq
 8004322:	f043 0301 	orreq.w	r3, r3, #1
 8004326:	f44f 6185 	mov.w	r1, #1064	; 0x428
 800432a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800432e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004332:	42ba      	cmp	r2, r7
 8004334:	bf08      	it	eq
 8004336:	f043 0301 	orreq.w	r3, r3, #1
 800433a:	f44f 678e 	mov.w	r7, #1136	; 0x470
 800433e:	428a      	cmp	r2, r1
 8004340:	bf08      	it	eq
 8004342:	f043 0301 	orreq.w	r3, r3, #1
 8004346:	f44f 618b 	mov.w	r1, #1112	; 0x458
 800434a:	f2c4 0702 	movt	r7, #16386	; 0x4002
 800434e:	4282      	cmp	r2, r0
 8004350:	bf08      	it	eq
 8004352:	f043 0301 	orreq.w	r3, r3, #1
 8004356:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800435a:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 800435e:	428a      	cmp	r2, r1
 8004360:	bf08      	it	eq
 8004362:	f043 0301 	orreq.w	r3, r3, #1
 8004366:	f44f 6191 	mov.w	r1, #1160	; 0x488
 800436a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800436e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004372:	42ba      	cmp	r2, r7
 8004374:	bf08      	it	eq
 8004376:	f043 0301 	orreq.w	r3, r3, #1
 800437a:	f245 4708 	movw	r7, #21512	; 0x5408
 800437e:	428a      	cmp	r2, r1
 8004380:	bf08      	it	eq
 8004382:	f043 0301 	orreq.w	r3, r3, #1
 8004386:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
 800438a:	f6c5 0702 	movt	r7, #22530	; 0x5802
 800438e:	4282      	cmp	r2, r0
 8004390:	bf08      	it	eq
 8004392:	f043 0301 	orreq.w	r3, r3, #1
 8004396:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800439a:	f245 4030 	movw	r0, #21552	; 0x5430
 800439e:	428a      	cmp	r2, r1
 80043a0:	bf08      	it	eq
 80043a2:	f043 0301 	orreq.w	r3, r3, #1
 80043a6:	f245 411c 	movw	r1, #21532	; 0x541c
 80043aa:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80043ae:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80043b2:	42ba      	cmp	r2, r7
 80043b4:	bf08      	it	eq
 80043b6:	f043 0301 	orreq.w	r3, r3, #1
 80043ba:	f245 4758 	movw	r7, #21592	; 0x5458
 80043be:	428a      	cmp	r2, r1
 80043c0:	bf08      	it	eq
 80043c2:	f043 0301 	orreq.w	r3, r3, #1
 80043c6:	f245 4144 	movw	r1, #21572	; 0x5444
 80043ca:	f6c5 0702 	movt	r7, #22530	; 0x5802
 80043ce:	4282      	cmp	r2, r0
 80043d0:	bf08      	it	eq
 80043d2:	f043 0301 	orreq.w	r3, r3, #1
 80043d6:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80043da:	f245 406c 	movw	r0, #21612	; 0x546c
 80043de:	428a      	cmp	r2, r1
 80043e0:	bf08      	it	eq
 80043e2:	f043 0301 	orreq.w	r3, r3, #1
 80043e6:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 80043ea:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80043ee:	42ba      	cmp	r2, r7
 80043f0:	bf08      	it	eq
 80043f2:	f043 0301 	orreq.w	r3, r3, #1
 80043f6:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80043fa:	4282      	cmp	r2, r0
 80043fc:	bf08      	it	eq
 80043fe:	f043 0301 	orreq.w	r3, r3, #1
 8004402:	428a      	cmp	r2, r1
 8004404:	bf08      	it	eq
 8004406:	f043 0301 	orreq.w	r3, r3, #1
 800440a:	b92b      	cbnz	r3, 8004418 <HAL_DMA_Abort+0x298>
 800440c:	f245 4394 	movw	r3, #21652	; 0x5494
 8004410:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8004414:	429a      	cmp	r2, r3
 8004416:	d105      	bne.n	8004424 <HAL_DMA_Abort+0x2a4>
      hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 8004418:	6e32      	ldr	r2, [r6, #96]	; 0x60
 800441a:	6813      	ldr	r3, [r2, #0]
 800441c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8004420:	6013      	str	r3, [r2, #0]
 8004422:	6832      	ldr	r2, [r6, #0]
    __HAL_DMA_DISABLE(hdma);
 8004424:	6813      	ldr	r3, [r2, #0]
 8004426:	f023 0301 	bic.w	r3, r3, #1
 800442a:	6013      	str	r3, [r2, #0]
 800442c:	e005      	b.n	800443a <HAL_DMA_Abort+0x2ba>
      if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 800442e:	f7fc fb05 	bl	8000a3c <HAL_GetTick>
 8004432:	1b00      	subs	r0, r0, r4
 8004434:	2805      	cmp	r0, #5
 8004436:	f200 814f 	bhi.w	80046d8 <HAL_DMA_Abort+0x558>
    while(((*enableRegister) & DMA_SxCR_EN) != 0U)
 800443a:	682b      	ldr	r3, [r5, #0]
 800443c:	07db      	lsls	r3, r3, #31
 800443e:	d4f6      	bmi.n	800442e <HAL_DMA_Abort+0x2ae>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8004440:	2310      	movs	r3, #16
 8004442:	2428      	movs	r4, #40	; 0x28
 8004444:	6832      	ldr	r2, [r6, #0]
 8004446:	2040      	movs	r0, #64	; 0x40
 8004448:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800444c:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004450:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004454:	2158      	movs	r1, #88	; 0x58
 8004456:	42a2      	cmp	r2, r4
 8004458:	bf18      	it	ne
 800445a:	429a      	cmpne	r2, r3
 800445c:	f04f 0470 	mov.w	r4, #112	; 0x70
 8004460:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004464:	bf0c      	ite	eq
 8004466:	2301      	moveq	r3, #1
 8004468:	2300      	movne	r3, #0
 800446a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800446e:	4282      	cmp	r2, r0
 8004470:	bf08      	it	eq
 8004472:	f043 0301 	orreq.w	r3, r3, #1
 8004476:	2088      	movs	r0, #136	; 0x88
 8004478:	428a      	cmp	r2, r1
 800447a:	bf08      	it	eq
 800447c:	f043 0301 	orreq.w	r3, r3, #1
 8004480:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004484:	21a0      	movs	r1, #160	; 0xa0
 8004486:	42a2      	cmp	r2, r4
 8004488:	bf08      	it	eq
 800448a:	f043 0301 	orreq.w	r3, r3, #1
 800448e:	24b8      	movs	r4, #184	; 0xb8
 8004490:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004494:	4282      	cmp	r2, r0
 8004496:	bf08      	it	eq
 8004498:	f043 0301 	orreq.w	r3, r3, #1
 800449c:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80044a0:	f44f 6082 	mov.w	r0, #1040	; 0x410
 80044a4:	428a      	cmp	r2, r1
 80044a6:	bf08      	it	eq
 80044a8:	f043 0301 	orreq.w	r3, r3, #1
 80044ac:	f44f 6185 	mov.w	r1, #1064	; 0x428
 80044b0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80044b4:	42a2      	cmp	r2, r4
 80044b6:	bf08      	it	eq
 80044b8:	f043 0301 	orreq.w	r3, r3, #1
 80044bc:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80044c0:	f44f 6488 	mov.w	r4, #1088	; 0x440
 80044c4:	4282      	cmp	r2, r0
 80044c6:	bf08      	it	eq
 80044c8:	f043 0301 	orreq.w	r3, r3, #1
 80044cc:	f44f 608b 	mov.w	r0, #1112	; 0x458
 80044d0:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80044d4:	428a      	cmp	r2, r1
 80044d6:	bf08      	it	eq
 80044d8:	f043 0301 	orreq.w	r3, r3, #1
 80044dc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80044e0:	f44f 618e 	mov.w	r1, #1136	; 0x470
 80044e4:	42a2      	cmp	r2, r4
 80044e6:	bf08      	it	eq
 80044e8:	f043 0301 	orreq.w	r3, r3, #1
 80044ec:	f44f 6491 	mov.w	r4, #1160	; 0x488
 80044f0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80044f4:	4282      	cmp	r2, r0
 80044f6:	bf08      	it	eq
 80044f8:	f043 0301 	orreq.w	r3, r3, #1
 80044fc:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004500:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 8004504:	428a      	cmp	r2, r1
 8004506:	bf08      	it	eq
 8004508:	f043 0301 	orreq.w	r3, r3, #1
 800450c:	6df1      	ldr	r1, [r6, #92]	; 0x5c
 800450e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004512:	42a2      	cmp	r2, r4
 8004514:	bf08      	it	eq
 8004516:	f043 0301 	orreq.w	r3, r3, #1
 800451a:	f001 011f 	and.w	r1, r1, #31
 800451e:	6db4      	ldr	r4, [r6, #88]	; 0x58
 8004520:	4282      	cmp	r2, r0
 8004522:	bf08      	it	eq
 8004524:	f043 0301 	orreq.w	r3, r3, #1
 8004528:	b933      	cbnz	r3, 8004538 <HAL_DMA_Abort+0x3b8>
 800452a:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 800452e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004532:	429a      	cmp	r2, r3
 8004534:	f040 80e1 	bne.w	80046fa <HAL_DMA_Abort+0x57a>
      regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8004538:	233f      	movs	r3, #63	; 0x3f
 800453a:	fa03 f101 	lsl.w	r1, r3, r1
 800453e:	60a1      	str	r1, [r4, #8]
    if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004540:	2310      	movs	r3, #16
 8004542:	2128      	movs	r1, #40	; 0x28
 8004544:	6832      	ldr	r2, [r6, #0]
 8004546:	2440      	movs	r4, #64	; 0x40
 8004548:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800454c:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004550:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004554:	2058      	movs	r0, #88	; 0x58
 8004556:	428a      	cmp	r2, r1
 8004558:	bf18      	it	ne
 800455a:	429a      	cmpne	r2, r3
 800455c:	f04f 0170 	mov.w	r1, #112	; 0x70
 8004560:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004564:	bf0c      	ite	eq
 8004566:	2301      	moveq	r3, #1
 8004568:	2300      	movne	r3, #0
 800456a:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800456e:	42a2      	cmp	r2, r4
 8004570:	bf08      	it	eq
 8004572:	f043 0301 	orreq.w	r3, r3, #1
 8004576:	2488      	movs	r4, #136	; 0x88
 8004578:	4282      	cmp	r2, r0
 800457a:	bf08      	it	eq
 800457c:	f043 0301 	orreq.w	r3, r3, #1
 8004580:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004584:	20a0      	movs	r0, #160	; 0xa0
 8004586:	428a      	cmp	r2, r1
 8004588:	bf08      	it	eq
 800458a:	f043 0301 	orreq.w	r3, r3, #1
 800458e:	21b8      	movs	r1, #184	; 0xb8
 8004590:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004594:	42a2      	cmp	r2, r4
 8004596:	bf08      	it	eq
 8004598:	f043 0301 	orreq.w	r3, r3, #1
 800459c:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80045a0:	f44f 6482 	mov.w	r4, #1040	; 0x410
 80045a4:	4282      	cmp	r2, r0
 80045a6:	bf08      	it	eq
 80045a8:	f043 0301 	orreq.w	r3, r3, #1
 80045ac:	f44f 6085 	mov.w	r0, #1064	; 0x428
 80045b0:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80045b4:	428a      	cmp	r2, r1
 80045b6:	bf08      	it	eq
 80045b8:	f043 0301 	orreq.w	r3, r3, #1
 80045bc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80045c0:	f44f 6188 	mov.w	r1, #1088	; 0x440
 80045c4:	42a2      	cmp	r2, r4
 80045c6:	bf08      	it	eq
 80045c8:	f043 0301 	orreq.w	r3, r3, #1
 80045cc:	f44f 648b 	mov.w	r4, #1112	; 0x458
 80045d0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80045d4:	4282      	cmp	r2, r0
 80045d6:	bf08      	it	eq
 80045d8:	f043 0301 	orreq.w	r3, r3, #1
 80045dc:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80045e0:	f44f 608e 	mov.w	r0, #1136	; 0x470
 80045e4:	428a      	cmp	r2, r1
 80045e6:	bf08      	it	eq
 80045e8:	f043 0301 	orreq.w	r3, r3, #1
 80045ec:	f44f 6191 	mov.w	r1, #1160	; 0x488
 80045f0:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80045f4:	42a2      	cmp	r2, r4
 80045f6:	bf08      	it	eq
 80045f8:	f043 0301 	orreq.w	r3, r3, #1
 80045fc:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004600:	f44f 6494 	mov.w	r4, #1184	; 0x4a0
 8004604:	4282      	cmp	r2, r0
 8004606:	bf08      	it	eq
 8004608:	f043 0301 	orreq.w	r3, r3, #1
 800460c:	f44f 6097 	mov.w	r0, #1208	; 0x4b8
 8004610:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004614:	428a      	cmp	r2, r1
 8004616:	bf08      	it	eq
 8004618:	f043 0301 	orreq.w	r3, r3, #1
 800461c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004620:	f245 4108 	movw	r1, #21512	; 0x5408
 8004624:	42a2      	cmp	r2, r4
 8004626:	bf08      	it	eq
 8004628:	f043 0301 	orreq.w	r3, r3, #1
 800462c:	f245 441c 	movw	r4, #21532	; 0x541c
 8004630:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8004634:	4282      	cmp	r2, r0
 8004636:	bf08      	it	eq
 8004638:	f043 0301 	orreq.w	r3, r3, #1
 800463c:	f6c5 0402 	movt	r4, #22530	; 0x5802
 8004640:	f245 4030 	movw	r0, #21552	; 0x5430
 8004644:	428a      	cmp	r2, r1
 8004646:	bf08      	it	eq
 8004648:	f043 0301 	orreq.w	r3, r3, #1
 800464c:	f245 4144 	movw	r1, #21572	; 0x5444
 8004650:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8004654:	42a2      	cmp	r2, r4
 8004656:	bf08      	it	eq
 8004658:	f043 0301 	orreq.w	r3, r3, #1
 800465c:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8004660:	f245 4458 	movw	r4, #21592	; 0x5458
 8004664:	4282      	cmp	r2, r0
 8004666:	bf08      	it	eq
 8004668:	f043 0301 	orreq.w	r3, r3, #1
 800466c:	f245 406c 	movw	r0, #21612	; 0x546c
 8004670:	f6c5 0402 	movt	r4, #22530	; 0x5802
 8004674:	428a      	cmp	r2, r1
 8004676:	bf08      	it	eq
 8004678:	f043 0301 	orreq.w	r3, r3, #1
 800467c:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8004680:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 8004684:	42a2      	cmp	r2, r4
 8004686:	bf08      	it	eq
 8004688:	f043 0301 	orreq.w	r3, r3, #1
 800468c:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8004690:	4282      	cmp	r2, r0
 8004692:	bf08      	it	eq
 8004694:	f043 0301 	orreq.w	r3, r3, #1
 8004698:	428a      	cmp	r2, r1
 800469a:	bf08      	it	eq
 800469c:	f043 0301 	orreq.w	r3, r3, #1
 80046a0:	b92b      	cbnz	r3, 80046ae <HAL_DMA_Abort+0x52e>
 80046a2:	f245 4394 	movw	r3, #21652	; 0x5494
 80046a6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80046aa:	429a      	cmp	r2, r3
 80046ac:	d10b      	bne.n	80046c6 <HAL_DMA_Abort+0x546>
      hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80046ae:	e9d6 3219 	ldrd	r3, r2, [r6, #100]	; 0x64
 80046b2:	605a      	str	r2, [r3, #4]
      if(hdma->DMAmuxRequestGen != 0U)
 80046b4:	6ef3      	ldr	r3, [r6, #108]	; 0x6c
 80046b6:	b133      	cbz	r3, 80046c6 <HAL_DMA_Abort+0x546>
        hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 80046b8:	681a      	ldr	r2, [r3, #0]
 80046ba:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80046be:	601a      	str	r2, [r3, #0]
        hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80046c0:	e9d6 321c 	ldrd	r3, r2, [r6, #112]	; 0x70
 80046c4:	605a      	str	r2, [r3, #4]
    __HAL_UNLOCK(hdma);
 80046c6:	2000      	movs	r0, #0
    hdma->State = HAL_DMA_STATE_READY;
 80046c8:	2301      	movs	r3, #1
    __HAL_UNLOCK(hdma);
 80046ca:	f886 0034 	strb.w	r0, [r6, #52]	; 0x34
    hdma->State = HAL_DMA_STATE_READY;
 80046ce:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
}
 80046d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 80046d4:	2001      	movs	r0, #1
}
 80046d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80046d8:	2120      	movs	r1, #32
        __HAL_UNLOCK(hdma);
 80046da:	2200      	movs	r2, #0
        hdma->State = HAL_DMA_STATE_ERROR;
 80046dc:	2303      	movs	r3, #3
        return HAL_ERROR;
 80046de:	2001      	movs	r0, #1
        hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 80046e0:	6571      	str	r1, [r6, #84]	; 0x54
        __HAL_UNLOCK(hdma);
 80046e2:	f886 2034 	strb.w	r2, [r6, #52]	; 0x34
        hdma->State = HAL_DMA_STATE_ERROR;
 80046e6:	f886 3035 	strb.w	r3, [r6, #53]	; 0x35
}
 80046ea:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 80046ec:	6813      	ldr	r3, [r2, #0]
 80046ee:	f023 030e 	bic.w	r3, r3, #14
 80046f2:	6013      	str	r3, [r2, #0]
      enableRegister = (__IO uint32_t *)(&(((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR));
 80046f4:	6832      	ldr	r2, [r6, #0]
 80046f6:	4615      	mov	r5, r2
 80046f8:	e5d8      	b.n	80042ac <HAL_DMA_Abort+0x12c>
      regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80046fa:	2301      	movs	r3, #1
 80046fc:	fa03 f101 	lsl.w	r1, r3, r1
 8004700:	6061      	str	r1, [r4, #4]
 8004702:	e71d      	b.n	8004540 <HAL_DMA_Abort+0x3c0>

08004704 <HAL_DMA_Abort_IT>:
  if(hdma == NULL)
 8004704:	2800      	cmp	r0, #0
 8004706:	f000 809d 	beq.w	8004844 <HAL_DMA_Abort_IT+0x140>
  if(hdma->State != HAL_DMA_STATE_BUSY)
 800470a:	f890 2035 	ldrb.w	r2, [r0, #53]	; 0x35
 800470e:	4603      	mov	r3, r0
 8004710:	2a02      	cmp	r2, #2
 8004712:	d003      	beq.n	800471c <HAL_DMA_Abort_IT+0x18>
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8004714:	2280      	movs	r2, #128	; 0x80
    return HAL_ERROR;
 8004716:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8004718:	655a      	str	r2, [r3, #84]	; 0x54
    return HAL_ERROR;
 800471a:	4770      	bx	lr
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800471c:	2110      	movs	r1, #16
{
 800471e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 8004722:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004726:	6802      	ldr	r2, [r0, #0]
{
 8004728:	b087      	sub	sp, #28
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800472a:	428a      	cmp	r2, r1
 800472c:	d07f      	beq.n	800482e <HAL_DMA_Abort_IT+0x12a>
 800472e:	2028      	movs	r0, #40	; 0x28
 8004730:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004734:	4282      	cmp	r2, r0
 8004736:	d07a      	beq.n	800482e <HAL_DMA_Abort_IT+0x12a>
 8004738:	f04f 0858 	mov.w	r8, #88	; 0x58
 800473c:	f04f 0940 	mov.w	r9, #64	; 0x40
 8004740:	f04f 0e70 	mov.w	lr, #112	; 0x70
 8004744:	f04f 0c88 	mov.w	ip, #136	; 0x88
 8004748:	f2c4 0802 	movt	r8, #16386	; 0x4002
 800474c:	f2c4 0902 	movt	r9, #16386	; 0x4002
 8004750:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004754:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004758:	454a      	cmp	r2, r9
 800475a:	bf18      	it	ne
 800475c:	4542      	cmpne	r2, r8
 800475e:	f04f 07a0 	mov.w	r7, #160	; 0xa0
 8004762:	f44f 6582 	mov.w	r5, #1040	; 0x410
 8004766:	f44f 6b88 	mov.w	fp, #1088	; 0x440
 800476a:	bf0c      	ite	eq
 800476c:	f04f 0a01 	moveq.w	sl, #1
 8004770:	f04f 0a00 	movne.w	sl, #0
 8004774:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8004778:	24b8      	movs	r4, #184	; 0xb8
 800477a:	4572      	cmp	r2, lr
 800477c:	bf08      	it	eq
 800477e:	f04a 0a01 	orreq.w	sl, sl, #1
 8004782:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8004786:	f44f 6685 	mov.w	r6, #1064	; 0x428
 800478a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800478e:	4562      	cmp	r2, ip
 8004790:	bf08      	it	eq
 8004792:	f04a 0a01 	orreq.w	sl, sl, #1
 8004796:	9502      	str	r5, [sp, #8]
 8004798:	f2c4 0602 	movt	r6, #16386	; 0x4002
 800479c:	465d      	mov	r5, fp
 800479e:	42ba      	cmp	r2, r7
 80047a0:	bf08      	it	eq
 80047a2:	f04a 0a01 	orreq.w	sl, sl, #1
 80047a6:	f44f 6b8b 	mov.w	fp, #1112	; 0x458
 80047aa:	9603      	str	r6, [sp, #12]
 80047ac:	462e      	mov	r6, r5
 80047ae:	42a2      	cmp	r2, r4
 80047b0:	bf08      	it	eq
 80047b2:	f04a 0a01 	orreq.w	sl, sl, #1
 80047b6:	9d02      	ldr	r5, [sp, #8]
 80047b8:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80047bc:	f2c4 0b02 	movt	fp, #16386	; 0x4002
 80047c0:	42aa      	cmp	r2, r5
 80047c2:	bf08      	it	eq
 80047c4:	f04a 0a01 	orreq.w	sl, sl, #1
 80047c8:	f44f 6591 	mov.w	r5, #1160	; 0x488
 80047cc:	9604      	str	r6, [sp, #16]
 80047ce:	f44f 668e 	mov.w	r6, #1136	; 0x470
 80047d2:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80047d6:	9405      	str	r4, [sp, #20]
 80047d8:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80047dc:	f44f 6494 	mov.w	r4, #1184	; 0x4a0
 80047e0:	9501      	str	r5, [sp, #4]
 80047e2:	9d03      	ldr	r5, [sp, #12]
 80047e4:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80047e8:	42aa      	cmp	r2, r5
 80047ea:	bf08      	it	eq
 80047ec:	f04a 0a01 	orreq.w	sl, sl, #1
 80047f0:	9d04      	ldr	r5, [sp, #16]
 80047f2:	42aa      	cmp	r2, r5
 80047f4:	bf08      	it	eq
 80047f6:	f04a 0a01 	orreq.w	sl, sl, #1
 80047fa:	9d01      	ldr	r5, [sp, #4]
 80047fc:	455a      	cmp	r2, fp
 80047fe:	bf08      	it	eq
 8004800:	f04a 0a01 	orreq.w	sl, sl, #1
 8004804:	42b2      	cmp	r2, r6
 8004806:	bf08      	it	eq
 8004808:	f04a 0a01 	orreq.w	sl, sl, #1
 800480c:	42aa      	cmp	r2, r5
 800480e:	bf08      	it	eq
 8004810:	f04a 0a01 	orreq.w	sl, sl, #1
 8004814:	42a2      	cmp	r2, r4
 8004816:	bf08      	it	eq
 8004818:	f04a 0a01 	orreq.w	sl, sl, #1
 800481c:	f1ba 0f00 	cmp.w	sl, #0
 8004820:	d105      	bne.n	800482e <HAL_DMA_Abort_IT+0x12a>
 8004822:	f44f 6a97 	mov.w	sl, #1208	; 0x4b8
 8004826:	f2c4 0a02 	movt	sl, #16386	; 0x4002
 800482a:	4552      	cmp	r2, sl
 800482c:	d10c      	bne.n	8004848 <HAL_DMA_Abort_IT+0x144>
      hdma->State = HAL_DMA_STATE_ABORT;
 800482e:	2104      	movs	r1, #4
  return HAL_OK;
 8004830:	2000      	movs	r0, #0
      hdma->State = HAL_DMA_STATE_ABORT;
 8004832:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      __HAL_DMA_DISABLE(hdma);
 8004836:	6813      	ldr	r3, [r2, #0]
 8004838:	f023 0301 	bic.w	r3, r3, #1
 800483c:	6013      	str	r3, [r2, #0]
}
 800483e:	b007      	add	sp, #28
 8004840:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return HAL_ERROR;
 8004844:	2001      	movs	r0, #1
}
 8004846:	4770      	bx	lr
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 8004848:	6815      	ldr	r5, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800484a:	2028      	movs	r0, #40	; 0x28
 800484c:	2458      	movs	r4, #88	; 0x58
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800484e:	f025 050e 	bic.w	r5, r5, #14
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004852:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004856:	f2c4 0402 	movt	r4, #16386	; 0x4002
      ((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR  &= ~(BDMA_CCR_TCIE | BDMA_CCR_HTIE | BDMA_CCR_TEIE);
 800485a:	6015      	str	r5, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800485c:	2540      	movs	r5, #64	; 0x40
      __HAL_DMA_DISABLE(hdma);
 800485e:	681a      	ldr	r2, [r3, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 8004860:	f2c4 0502 	movt	r5, #16386	; 0x4002
      __HAL_DMA_DISABLE(hdma);
 8004864:	6811      	ldr	r1, [r2, #0]
 8004866:	f021 0101 	bic.w	r1, r1, #1
 800486a:	6011      	str	r1, [r2, #0]
      if(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance) != 0U) /* No DMAMUX available for BDMA1 */
 800486c:	2210      	movs	r2, #16
 800486e:	6819      	ldr	r1, [r3, #0]
 8004870:	f2c4 0202 	movt	r2, #16386	; 0x4002
 8004874:	4281      	cmp	r1, r0
 8004876:	bf18      	it	ne
 8004878:	4291      	cmpne	r1, r2
 800487a:	f04f 0070 	mov.w	r0, #112	; 0x70
 800487e:	bf0c      	ite	eq
 8004880:	2201      	moveq	r2, #1
 8004882:	2200      	movne	r2, #0
 8004884:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004888:	42a9      	cmp	r1, r5
 800488a:	bf08      	it	eq
 800488c:	f042 0201 	orreq.w	r2, r2, #1
 8004890:	2588      	movs	r5, #136	; 0x88
 8004892:	42a1      	cmp	r1, r4
 8004894:	bf08      	it	eq
 8004896:	f042 0201 	orreq.w	r2, r2, #1
 800489a:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800489e:	24a0      	movs	r4, #160	; 0xa0
 80048a0:	4281      	cmp	r1, r0
 80048a2:	bf08      	it	eq
 80048a4:	f042 0201 	orreq.w	r2, r2, #1
 80048a8:	20b8      	movs	r0, #184	; 0xb8
 80048aa:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80048ae:	42a9      	cmp	r1, r5
 80048b0:	bf08      	it	eq
 80048b2:	f042 0201 	orreq.w	r2, r2, #1
 80048b6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80048ba:	f44f 6582 	mov.w	r5, #1040	; 0x410
 80048be:	42a1      	cmp	r1, r4
 80048c0:	bf08      	it	eq
 80048c2:	f042 0201 	orreq.w	r2, r2, #1
 80048c6:	f44f 6485 	mov.w	r4, #1064	; 0x428
 80048ca:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80048ce:	4281      	cmp	r1, r0
 80048d0:	bf08      	it	eq
 80048d2:	f042 0201 	orreq.w	r2, r2, #1
 80048d6:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80048da:	f44f 6088 	mov.w	r0, #1088	; 0x440
 80048de:	42a9      	cmp	r1, r5
 80048e0:	bf08      	it	eq
 80048e2:	f042 0201 	orreq.w	r2, r2, #1
 80048e6:	f44f 658b 	mov.w	r5, #1112	; 0x458
 80048ea:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80048ee:	42a1      	cmp	r1, r4
 80048f0:	bf08      	it	eq
 80048f2:	f042 0201 	orreq.w	r2, r2, #1
 80048f6:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80048fa:	f44f 648e 	mov.w	r4, #1136	; 0x470
 80048fe:	4281      	cmp	r1, r0
 8004900:	bf08      	it	eq
 8004902:	f042 0201 	orreq.w	r2, r2, #1
 8004906:	f44f 6091 	mov.w	r0, #1160	; 0x488
 800490a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800490e:	42a9      	cmp	r1, r5
 8004910:	bf08      	it	eq
 8004912:	f042 0201 	orreq.w	r2, r2, #1
 8004916:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800491a:	f44f 6594 	mov.w	r5, #1184	; 0x4a0
 800491e:	42a1      	cmp	r1, r4
 8004920:	bf08      	it	eq
 8004922:	f042 0201 	orreq.w	r2, r2, #1
 8004926:	f44f 6497 	mov.w	r4, #1208	; 0x4b8
 800492a:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800492e:	4281      	cmp	r1, r0
 8004930:	bf08      	it	eq
 8004932:	f042 0201 	orreq.w	r2, r2, #1
 8004936:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800493a:	f245 4008 	movw	r0, #21512	; 0x5408
 800493e:	42a9      	cmp	r1, r5
 8004940:	bf08      	it	eq
 8004942:	f042 0201 	orreq.w	r2, r2, #1
 8004946:	f245 451c 	movw	r5, #21532	; 0x541c
 800494a:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800494e:	42a1      	cmp	r1, r4
 8004950:	bf08      	it	eq
 8004952:	f042 0201 	orreq.w	r2, r2, #1
 8004956:	f6c5 0502 	movt	r5, #22530	; 0x5802
 800495a:	f245 4430 	movw	r4, #21552	; 0x5430
 800495e:	4281      	cmp	r1, r0
 8004960:	bf08      	it	eq
 8004962:	f042 0201 	orreq.w	r2, r2, #1
 8004966:	f245 4044 	movw	r0, #21572	; 0x5444
 800496a:	f6c5 0402 	movt	r4, #22530	; 0x5802
 800496e:	42a9      	cmp	r1, r5
 8004970:	bf08      	it	eq
 8004972:	f042 0201 	orreq.w	r2, r2, #1
 8004976:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800497a:	f245 4558 	movw	r5, #21592	; 0x5458
 800497e:	42a1      	cmp	r1, r4
 8004980:	bf08      	it	eq
 8004982:	f042 0201 	orreq.w	r2, r2, #1
 8004986:	f245 446c 	movw	r4, #21612	; 0x546c
 800498a:	f6c5 0502 	movt	r5, #22530	; 0x5802
 800498e:	4281      	cmp	r1, r0
 8004990:	bf08      	it	eq
 8004992:	f042 0201 	orreq.w	r2, r2, #1
 8004996:	f6c5 0402 	movt	r4, #22530	; 0x5802
 800499a:	f44f 40a9 	mov.w	r0, #21632	; 0x5480
 800499e:	42a9      	cmp	r1, r5
 80049a0:	bf08      	it	eq
 80049a2:	f042 0201 	orreq.w	r2, r2, #1
 80049a6:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80049aa:	42a1      	cmp	r1, r4
 80049ac:	bf08      	it	eq
 80049ae:	f042 0201 	orreq.w	r2, r2, #1
 80049b2:	4281      	cmp	r1, r0
 80049b4:	bf08      	it	eq
 80049b6:	f042 0201 	orreq.w	r2, r2, #1
 80049ba:	b92a      	cbnz	r2, 80049c8 <HAL_DMA_Abort_IT+0x2c4>
 80049bc:	f245 4294 	movw	r2, #21652	; 0x5494
 80049c0:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80049c4:	4291      	cmp	r1, r2
 80049c6:	d117      	bne.n	80049f8 <HAL_DMA_Abort_IT+0x2f4>
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80049c8:	6e18      	ldr	r0, [r3, #96]	; 0x60
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80049ca:	2201      	movs	r2, #1
        hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80049cc:	6801      	ldr	r1, [r0, #0]
 80049ce:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 80049d2:	6001      	str	r1, [r0, #0]
        regs_bdma = (BDMA_Base_Registers *)hdma->StreamBaseAddress;
 80049d4:	e9d3 0116 	ldrd	r0, r1, [r3, #88]	; 0x58
        regs_bdma->IFCR = ((BDMA_IFCR_CGIF0) << (hdma->StreamIndex & 0x1FU));
 80049d8:	f001 011f 	and.w	r1, r1, #31
 80049dc:	408a      	lsls	r2, r1
 80049de:	6042      	str	r2, [r0, #4]
        hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 80049e0:	e9d3 2119 	ldrd	r2, r1, [r3, #100]	; 0x64
 80049e4:	6051      	str	r1, [r2, #4]
        if(hdma->DMAmuxRequestGen != 0U)
 80049e6:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 80049e8:	b132      	cbz	r2, 80049f8 <HAL_DMA_Abort_IT+0x2f4>
          hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 80049ea:	6811      	ldr	r1, [r2, #0]
 80049ec:	f421 7180 	bic.w	r1, r1, #256	; 0x100
 80049f0:	6011      	str	r1, [r2, #0]
          hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 80049f2:	e9d3 211c 	ldrd	r2, r1, [r3, #112]	; 0x70
 80049f6:	6051      	str	r1, [r2, #4]
      __HAL_UNLOCK(hdma);
 80049f8:	2400      	movs	r4, #0
      hdma->State = HAL_DMA_STATE_READY;
 80049fa:	2101      	movs	r1, #1
      if(hdma->XferAbortCallback != NULL)
 80049fc:	6d1a      	ldr	r2, [r3, #80]	; 0x50
      __HAL_UNLOCK(hdma);
 80049fe:	f883 4034 	strb.w	r4, [r3, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 8004a02:	f883 1035 	strb.w	r1, [r3, #53]	; 0x35
      if(hdma->XferAbortCallback != NULL)
 8004a06:	b11a      	cbz	r2, 8004a10 <HAL_DMA_Abort_IT+0x30c>
 8004a08:	4618      	mov	r0, r3
        hdma->XferAbortCallback(hdma);
 8004a0a:	4790      	blx	r2
  return HAL_OK;
 8004a0c:	4620      	mov	r0, r4
 8004a0e:	e716      	b.n	800483e <HAL_DMA_Abort_IT+0x13a>
 8004a10:	4610      	mov	r0, r2
 8004a12:	e714      	b.n	800483e <HAL_DMA_Abort_IT+0x13a>

08004a14 <HAL_DMA_IRQHandler>:
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a14:	2110      	movs	r1, #16
  uint32_t timeout = SystemCoreClock / 9600U;
 8004a16:	f240 23b0 	movw	r3, #688	; 0x2b0
  __IO uint32_t count = 0U;
 8004a1a:	2200      	movs	r2, #0
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a1c:	f2c4 0102 	movt	r1, #16386	; 0x4002
  uint32_t timeout = SystemCoreClock / 9600U;
 8004a20:	f2c2 0300 	movt	r3, #8192	; 0x2000
{
 8004a24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a28:	6804      	ldr	r4, [r0, #0]
{
 8004a2a:	b082      	sub	sp, #8
  DMA_Base_Registers  *regs_dma  = (DMA_Base_Registers *)hdma->StreamBaseAddress;
 8004a2c:	6d85      	ldr	r5, [r0, #88]	; 0x58
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a2e:	428c      	cmp	r4, r1
  __IO uint32_t count = 0U;
 8004a30:	9201      	str	r2, [sp, #4]
  uint32_t timeout = SystemCoreClock / 9600U;
 8004a32:	681e      	ldr	r6, [r3, #0]
  tmpisr_dma  = regs_dma->ISR;
 8004a34:	682f      	ldr	r7, [r5, #0]
  tmpisr_bdma = regs_bdma->ISR;
 8004a36:	682a      	ldr	r2, [r5, #0]
  if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U)  /* DMA1 or DMA2 instance */
 8004a38:	d06f      	beq.n	8004b1a <HAL_DMA_IRQHandler+0x106>
 8004a3a:	2328      	movs	r3, #40	; 0x28
 8004a3c:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004a40:	429c      	cmp	r4, r3
 8004a42:	d06a      	beq.n	8004b1a <HAL_DMA_IRQHandler+0x106>
 8004a44:	2358      	movs	r3, #88	; 0x58
 8004a46:	2140      	movs	r1, #64	; 0x40
 8004a48:	f04f 0c70 	mov.w	ip, #112	; 0x70
 8004a4c:	f04f 0ea0 	mov.w	lr, #160	; 0xa0
 8004a50:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004a54:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004a58:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004a5c:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004a60:	428c      	cmp	r4, r1
 8004a62:	bf18      	it	ne
 8004a64:	429c      	cmpne	r4, r3
 8004a66:	f04f 0188 	mov.w	r1, #136	; 0x88
 8004a6a:	bf0c      	ite	eq
 8004a6c:	2301      	moveq	r3, #1
 8004a6e:	2300      	movne	r3, #0
 8004a70:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004a74:	4564      	cmp	r4, ip
 8004a76:	bf08      	it	eq
 8004a78:	f043 0301 	orreq.w	r3, r3, #1
 8004a7c:	f44f 6c82 	mov.w	ip, #1040	; 0x410
 8004a80:	428c      	cmp	r4, r1
 8004a82:	bf08      	it	eq
 8004a84:	f043 0301 	orreq.w	r3, r3, #1
 8004a88:	21b8      	movs	r1, #184	; 0xb8
 8004a8a:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004a8e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004a92:	4574      	cmp	r4, lr
 8004a94:	bf08      	it	eq
 8004a96:	f043 0301 	orreq.w	r3, r3, #1
 8004a9a:	f44f 6e88 	mov.w	lr, #1088	; 0x440
 8004a9e:	428c      	cmp	r4, r1
 8004aa0:	bf08      	it	eq
 8004aa2:	f043 0301 	orreq.w	r3, r3, #1
 8004aa6:	f44f 6185 	mov.w	r1, #1064	; 0x428
 8004aaa:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004aae:	4564      	cmp	r4, ip
 8004ab0:	bf08      	it	eq
 8004ab2:	f043 0301 	orreq.w	r3, r3, #1
 8004ab6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004aba:	f44f 6c8b 	mov.w	ip, #1112	; 0x458
 8004abe:	428c      	cmp	r4, r1
 8004ac0:	bf08      	it	eq
 8004ac2:	f043 0301 	orreq.w	r3, r3, #1
 8004ac6:	f44f 618e 	mov.w	r1, #1136	; 0x470
 8004aca:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004ace:	4574      	cmp	r4, lr
 8004ad0:	bf08      	it	eq
 8004ad2:	f043 0301 	orreq.w	r3, r3, #1
 8004ad6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004ada:	4564      	cmp	r4, ip
 8004adc:	bf08      	it	eq
 8004ade:	f043 0301 	orreq.w	r3, r3, #1
 8004ae2:	f44f 6c91 	mov.w	ip, #1160	; 0x488
 8004ae6:	428c      	cmp	r4, r1
 8004ae8:	bf08      	it	eq
 8004aea:	f043 0301 	orreq.w	r3, r3, #1
 8004aee:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004af2:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 8004af6:	4564      	cmp	r4, ip
 8004af8:	bf08      	it	eq
 8004afa:	f043 0301 	orreq.w	r3, r3, #1
 8004afe:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8004b02:	428c      	cmp	r4, r1
 8004b04:	bf08      	it	eq
 8004b06:	f043 0301 	orreq.w	r3, r3, #1
 8004b0a:	b933      	cbnz	r3, 8004b1a <HAL_DMA_IRQHandler+0x106>
 8004b0c:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8004b10:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b14:	429c      	cmp	r4, r3
 8004b16:	f040 82a3 	bne.w	8005060 <HAL_DMA_IRQHandler+0x64c>
    if ((tmpisr_dma & (DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004b1a:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8004b1c:	2308      	movs	r3, #8
 8004b1e:	f001 021f 	and.w	r2, r1, #31
 8004b22:	4093      	lsls	r3, r2
 8004b24:	423b      	tst	r3, r7
 8004b26:	f040 8280 	bne.w	800502a <HAL_DMA_IRQHandler+0x616>
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004b2a:	fa27 f302 	lsr.w	r3, r7, r2
 8004b2e:	07dc      	lsls	r4, r3, #31
 8004b30:	f140 8088 	bpl.w	8004c44 <HAL_DMA_IRQHandler+0x230>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 8004b34:	2310      	movs	r3, #16
 8004b36:	2428      	movs	r4, #40	; 0x28
 8004b38:	6801      	ldr	r1, [r0, #0]
 8004b3a:	f04f 0c40 	mov.w	ip, #64	; 0x40
 8004b3e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004b42:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004b46:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004b4a:	f04f 0e70 	mov.w	lr, #112	; 0x70
 8004b4e:	42a1      	cmp	r1, r4
 8004b50:	bf18      	it	ne
 8004b52:	4299      	cmpne	r1, r3
 8004b54:	f04f 0458 	mov.w	r4, #88	; 0x58
 8004b58:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004b5c:	bf0c      	ite	eq
 8004b5e:	2301      	moveq	r3, #1
 8004b60:	2300      	movne	r3, #0
 8004b62:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004b66:	4561      	cmp	r1, ip
 8004b68:	bf08      	it	eq
 8004b6a:	f043 0301 	orreq.w	r3, r3, #1
 8004b6e:	f04f 0ca0 	mov.w	ip, #160	; 0xa0
 8004b72:	42a1      	cmp	r1, r4
 8004b74:	bf08      	it	eq
 8004b76:	f043 0301 	orreq.w	r3, r3, #1
 8004b7a:	2488      	movs	r4, #136	; 0x88
 8004b7c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004b80:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004b84:	4571      	cmp	r1, lr
 8004b86:	bf08      	it	eq
 8004b88:	f043 0301 	orreq.w	r3, r3, #1
 8004b8c:	f44f 6e82 	mov.w	lr, #1040	; 0x410
 8004b90:	42a1      	cmp	r1, r4
 8004b92:	bf08      	it	eq
 8004b94:	f043 0301 	orreq.w	r3, r3, #1
 8004b98:	24b8      	movs	r4, #184	; 0xb8
 8004b9a:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004b9e:	4561      	cmp	r1, ip
 8004ba0:	bf08      	it	eq
 8004ba2:	f043 0301 	orreq.w	r3, r3, #1
 8004ba6:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004baa:	f44f 6c88 	mov.w	ip, #1088	; 0x440
 8004bae:	42a1      	cmp	r1, r4
 8004bb0:	bf08      	it	eq
 8004bb2:	f043 0301 	orreq.w	r3, r3, #1
 8004bb6:	f44f 6485 	mov.w	r4, #1064	; 0x428
 8004bba:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004bbe:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004bc2:	4571      	cmp	r1, lr
 8004bc4:	bf08      	it	eq
 8004bc6:	f043 0301 	orreq.w	r3, r3, #1
 8004bca:	f44f 6e8e 	mov.w	lr, #1136	; 0x470
 8004bce:	42a1      	cmp	r1, r4
 8004bd0:	bf08      	it	eq
 8004bd2:	f043 0301 	orreq.w	r3, r3, #1
 8004bd6:	f44f 648b 	mov.w	r4, #1112	; 0x458
 8004bda:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004bde:	4561      	cmp	r1, ip
 8004be0:	bf08      	it	eq
 8004be2:	f043 0301 	orreq.w	r3, r3, #1
 8004be6:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004bea:	f44f 6c91 	mov.w	ip, #1160	; 0x488
 8004bee:	42a1      	cmp	r1, r4
 8004bf0:	bf08      	it	eq
 8004bf2:	f043 0301 	orreq.w	r3, r3, #1
 8004bf6:	f44f 6494 	mov.w	r4, #1184	; 0x4a0
 8004bfa:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004bfe:	4571      	cmp	r1, lr
 8004c00:	bf08      	it	eq
 8004c02:	f043 0301 	orreq.w	r3, r3, #1
 8004c06:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8004c0a:	4561      	cmp	r1, ip
 8004c0c:	bf08      	it	eq
 8004c0e:	f043 0301 	orreq.w	r3, r3, #1
 8004c12:	42a1      	cmp	r1, r4
 8004c14:	bf08      	it	eq
 8004c16:	f043 0301 	orreq.w	r3, r3, #1
 8004c1a:	b933      	cbnz	r3, 8004c2a <HAL_DMA_IRQHandler+0x216>
 8004c1c:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8004c20:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004c24:	4299      	cmp	r1, r3
 8004c26:	f040 82ea 	bne.w	80051fe <HAL_DMA_IRQHandler+0x7ea>
 8004c2a:	694b      	ldr	r3, [r1, #20]
 8004c2c:	0619      	lsls	r1, r3, #24
 8004c2e:	d509      	bpl.n	8004c44 <HAL_DMA_IRQHandler+0x230>
        regs_dma->IFCR = DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004c30:	2101      	movs	r1, #1
 8004c32:	4091      	lsls	r1, r2
 8004c34:	60a9      	str	r1, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_FE;
 8004c36:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8004c38:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8004c3a:	f043 0302 	orr.w	r3, r3, #2
 8004c3e:	f001 021f 	and.w	r2, r1, #31
 8004c42:	6543      	str	r3, [r0, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004c44:	2404      	movs	r4, #4
 8004c46:	4094      	lsls	r4, r2
 8004c48:	423c      	tst	r4, r7
 8004c4a:	f000 8089 	beq.w	8004d60 <HAL_DMA_IRQHandler+0x34c>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 8004c4e:	2310      	movs	r3, #16
 8004c50:	f04f 0c28 	mov.w	ip, #40	; 0x28
 8004c54:	6801      	ldr	r1, [r0, #0]
 8004c56:	f04f 0e40 	mov.w	lr, #64	; 0x40
 8004c5a:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004c5e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004c62:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004c66:	f04f 0870 	mov.w	r8, #112	; 0x70
 8004c6a:	4561      	cmp	r1, ip
 8004c6c:	bf18      	it	ne
 8004c6e:	4299      	cmpne	r1, r3
 8004c70:	f04f 0c58 	mov.w	ip, #88	; 0x58
 8004c74:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004c78:	bf0c      	ite	eq
 8004c7a:	2301      	moveq	r3, #1
 8004c7c:	2300      	movne	r3, #0
 8004c7e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004c82:	4571      	cmp	r1, lr
 8004c84:	bf08      	it	eq
 8004c86:	f043 0301 	orreq.w	r3, r3, #1
 8004c8a:	f04f 0ea0 	mov.w	lr, #160	; 0xa0
 8004c8e:	4561      	cmp	r1, ip
 8004c90:	bf08      	it	eq
 8004c92:	f043 0301 	orreq.w	r3, r3, #1
 8004c96:	f04f 0c88 	mov.w	ip, #136	; 0x88
 8004c9a:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004c9e:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004ca2:	4541      	cmp	r1, r8
 8004ca4:	bf08      	it	eq
 8004ca6:	f043 0301 	orreq.w	r3, r3, #1
 8004caa:	f44f 6882 	mov.w	r8, #1040	; 0x410
 8004cae:	4561      	cmp	r1, ip
 8004cb0:	bf08      	it	eq
 8004cb2:	f043 0301 	orreq.w	r3, r3, #1
 8004cb6:	f04f 0cb8 	mov.w	ip, #184	; 0xb8
 8004cba:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004cbe:	4571      	cmp	r1, lr
 8004cc0:	bf08      	it	eq
 8004cc2:	f043 0301 	orreq.w	r3, r3, #1
 8004cc6:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004cca:	f44f 6e88 	mov.w	lr, #1088	; 0x440
 8004cce:	4561      	cmp	r1, ip
 8004cd0:	bf08      	it	eq
 8004cd2:	f043 0301 	orreq.w	r3, r3, #1
 8004cd6:	f44f 6c85 	mov.w	ip, #1064	; 0x428
 8004cda:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004cde:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004ce2:	4541      	cmp	r1, r8
 8004ce4:	bf08      	it	eq
 8004ce6:	f043 0301 	orreq.w	r3, r3, #1
 8004cea:	f44f 688e 	mov.w	r8, #1136	; 0x470
 8004cee:	4561      	cmp	r1, ip
 8004cf0:	bf08      	it	eq
 8004cf2:	f043 0301 	orreq.w	r3, r3, #1
 8004cf6:	f44f 6c8b 	mov.w	ip, #1112	; 0x458
 8004cfa:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004cfe:	4571      	cmp	r1, lr
 8004d00:	bf08      	it	eq
 8004d02:	f043 0301 	orreq.w	r3, r3, #1
 8004d06:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004d0a:	f44f 6e91 	mov.w	lr, #1160	; 0x488
 8004d0e:	4561      	cmp	r1, ip
 8004d10:	bf08      	it	eq
 8004d12:	f043 0301 	orreq.w	r3, r3, #1
 8004d16:	f44f 6c94 	mov.w	ip, #1184	; 0x4a0
 8004d1a:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004d1e:	4541      	cmp	r1, r8
 8004d20:	bf08      	it	eq
 8004d22:	f043 0301 	orreq.w	r3, r3, #1
 8004d26:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004d2a:	4571      	cmp	r1, lr
 8004d2c:	bf08      	it	eq
 8004d2e:	f043 0301 	orreq.w	r3, r3, #1
 8004d32:	4561      	cmp	r1, ip
 8004d34:	bf08      	it	eq
 8004d36:	f043 0301 	orreq.w	r3, r3, #1
 8004d3a:	b933      	cbnz	r3, 8004d4a <HAL_DMA_IRQHandler+0x336>
 8004d3c:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8004d40:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004d44:	4299      	cmp	r1, r3
 8004d46:	f040 8258 	bne.w	80051fa <HAL_DMA_IRQHandler+0x7e6>
 8004d4a:	680b      	ldr	r3, [r1, #0]
 8004d4c:	079b      	lsls	r3, r3, #30
 8004d4e:	d507      	bpl.n	8004d60 <HAL_DMA_IRQHandler+0x34c>
        regs_dma->IFCR = DMA_FLAG_DMEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004d50:	60ac      	str	r4, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_DME;
 8004d52:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8004d54:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 8004d56:	f043 0304 	orr.w	r3, r3, #4
 8004d5a:	f001 021f 	and.w	r2, r1, #31
 8004d5e:	6543      	str	r3, [r0, #84]	; 0x54
 8004d60:	4604      	mov	r4, r0
    if ((tmpisr_dma & (DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004d62:	2010      	movs	r0, #16
 8004d64:	4090      	lsls	r0, r2
 8004d66:	4238      	tst	r0, r7
 8004d68:	f000 8098 	beq.w	8004e9c <HAL_DMA_IRQHandler+0x488>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 8004d6c:	2310      	movs	r3, #16
 8004d6e:	f04f 0c28 	mov.w	ip, #40	; 0x28
 8004d72:	6821      	ldr	r1, [r4, #0]
 8004d74:	f04f 0e40 	mov.w	lr, #64	; 0x40
 8004d78:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004d7c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004d80:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004d84:	f04f 0870 	mov.w	r8, #112	; 0x70
 8004d88:	4561      	cmp	r1, ip
 8004d8a:	bf18      	it	ne
 8004d8c:	4299      	cmpne	r1, r3
 8004d8e:	f04f 0c58 	mov.w	ip, #88	; 0x58
 8004d92:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004d96:	bf0c      	ite	eq
 8004d98:	2301      	moveq	r3, #1
 8004d9a:	2300      	movne	r3, #0
 8004d9c:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004da0:	4571      	cmp	r1, lr
 8004da2:	bf08      	it	eq
 8004da4:	f043 0301 	orreq.w	r3, r3, #1
 8004da8:	f04f 0ea0 	mov.w	lr, #160	; 0xa0
 8004dac:	4561      	cmp	r1, ip
 8004dae:	bf08      	it	eq
 8004db0:	f043 0301 	orreq.w	r3, r3, #1
 8004db4:	f04f 0c88 	mov.w	ip, #136	; 0x88
 8004db8:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004dbc:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004dc0:	4541      	cmp	r1, r8
 8004dc2:	bf08      	it	eq
 8004dc4:	f043 0301 	orreq.w	r3, r3, #1
 8004dc8:	f44f 6882 	mov.w	r8, #1040	; 0x410
 8004dcc:	4561      	cmp	r1, ip
 8004dce:	bf08      	it	eq
 8004dd0:	f043 0301 	orreq.w	r3, r3, #1
 8004dd4:	f04f 0cb8 	mov.w	ip, #184	; 0xb8
 8004dd8:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004ddc:	4571      	cmp	r1, lr
 8004dde:	bf08      	it	eq
 8004de0:	f043 0301 	orreq.w	r3, r3, #1
 8004de4:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004de8:	f44f 6e88 	mov.w	lr, #1088	; 0x440
 8004dec:	4561      	cmp	r1, ip
 8004dee:	bf08      	it	eq
 8004df0:	f043 0301 	orreq.w	r3, r3, #1
 8004df4:	f44f 6c85 	mov.w	ip, #1064	; 0x428
 8004df8:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004dfc:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004e00:	4541      	cmp	r1, r8
 8004e02:	bf08      	it	eq
 8004e04:	f043 0301 	orreq.w	r3, r3, #1
 8004e08:	f44f 688e 	mov.w	r8, #1136	; 0x470
 8004e0c:	4561      	cmp	r1, ip
 8004e0e:	bf08      	it	eq
 8004e10:	f043 0301 	orreq.w	r3, r3, #1
 8004e14:	f44f 6c8b 	mov.w	ip, #1112	; 0x458
 8004e18:	f2c4 0802 	movt	r8, #16386	; 0x4002
 8004e1c:	4571      	cmp	r1, lr
 8004e1e:	bf08      	it	eq
 8004e20:	f043 0301 	orreq.w	r3, r3, #1
 8004e24:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004e28:	f44f 6e91 	mov.w	lr, #1160	; 0x488
 8004e2c:	4561      	cmp	r1, ip
 8004e2e:	bf08      	it	eq
 8004e30:	f043 0301 	orreq.w	r3, r3, #1
 8004e34:	f44f 6c94 	mov.w	ip, #1184	; 0x4a0
 8004e38:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8004e3c:	4541      	cmp	r1, r8
 8004e3e:	bf08      	it	eq
 8004e40:	f043 0301 	orreq.w	r3, r3, #1
 8004e44:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004e48:	4571      	cmp	r1, lr
 8004e4a:	bf08      	it	eq
 8004e4c:	f043 0301 	orreq.w	r3, r3, #1
 8004e50:	4561      	cmp	r1, ip
 8004e52:	bf08      	it	eq
 8004e54:	f043 0301 	orreq.w	r3, r3, #1
 8004e58:	b933      	cbnz	r3, 8004e68 <HAL_DMA_IRQHandler+0x454>
 8004e5a:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8004e5e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004e62:	4299      	cmp	r1, r3
 8004e64:	f040 81c5 	bne.w	80051f2 <HAL_DMA_IRQHandler+0x7de>
 8004e68:	680b      	ldr	r3, [r1, #0]
 8004e6a:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 8004e6e:	b1ab      	cbz	r3, 8004e9c <HAL_DMA_IRQHandler+0x488>
        regs_dma->IFCR = DMA_FLAG_HTIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004e70:	60a8      	str	r0, [r5, #8]
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8004e72:	6823      	ldr	r3, [r4, #0]
 8004e74:	681a      	ldr	r2, [r3, #0]
 8004e76:	0350      	lsls	r0, r2, #13
 8004e78:	f100 8146 	bmi.w	8005108 <HAL_DMA_IRQHandler+0x6f4>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8004e7c:	681a      	ldr	r2, [r3, #0]
 8004e7e:	05d2      	lsls	r2, r2, #23
 8004e80:	d403      	bmi.n	8004e8a <HAL_DMA_IRQHandler+0x476>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8004e82:	681a      	ldr	r2, [r3, #0]
 8004e84:	f022 0208 	bic.w	r2, r2, #8
 8004e88:	601a      	str	r2, [r3, #0]
          if(hdma->XferHalfCpltCallback != NULL)
 8004e8a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8004e8c:	2b00      	cmp	r3, #0
 8004e8e:	f000 8143 	beq.w	8005118 <HAL_DMA_IRQHandler+0x704>
            hdma->XferHalfCpltCallback(hdma);
 8004e92:	4620      	mov	r0, r4
 8004e94:	4798      	blx	r3
 8004e96:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 8004e98:	f001 021f 	and.w	r2, r1, #31
    if ((tmpisr_dma & (DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8004e9c:	2120      	movs	r1, #32
 8004e9e:	4091      	lsls	r1, r2
 8004ea0:	4239      	tst	r1, r7
 8004ea2:	f000 8090 	beq.w	8004fc6 <HAL_DMA_IRQHandler+0x5b2>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 8004ea6:	2310      	movs	r3, #16
 8004ea8:	2028      	movs	r0, #40	; 0x28
 8004eaa:	6822      	ldr	r2, [r4, #0]
 8004eac:	2740      	movs	r7, #64	; 0x40
 8004eae:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004eb2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004eb6:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8004eba:	f04f 0c70 	mov.w	ip, #112	; 0x70
 8004ebe:	4282      	cmp	r2, r0
 8004ec0:	bf18      	it	ne
 8004ec2:	429a      	cmpne	r2, r3
 8004ec4:	f04f 0058 	mov.w	r0, #88	; 0x58
 8004ec8:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004ecc:	bf0c      	ite	eq
 8004ece:	2301      	moveq	r3, #1
 8004ed0:	2300      	movne	r3, #0
 8004ed2:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004ed6:	42ba      	cmp	r2, r7
 8004ed8:	bf08      	it	eq
 8004eda:	f043 0301 	orreq.w	r3, r3, #1
 8004ede:	27a0      	movs	r7, #160	; 0xa0
 8004ee0:	4282      	cmp	r2, r0
 8004ee2:	bf08      	it	eq
 8004ee4:	f043 0301 	orreq.w	r3, r3, #1
 8004ee8:	2088      	movs	r0, #136	; 0x88
 8004eea:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8004eee:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004ef2:	4562      	cmp	r2, ip
 8004ef4:	bf08      	it	eq
 8004ef6:	f043 0301 	orreq.w	r3, r3, #1
 8004efa:	f44f 6c82 	mov.w	ip, #1040	; 0x410
 8004efe:	4282      	cmp	r2, r0
 8004f00:	bf08      	it	eq
 8004f02:	f043 0301 	orreq.w	r3, r3, #1
 8004f06:	20b8      	movs	r0, #184	; 0xb8
 8004f08:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004f0c:	42ba      	cmp	r2, r7
 8004f0e:	bf08      	it	eq
 8004f10:	f043 0301 	orreq.w	r3, r3, #1
 8004f14:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004f18:	f44f 6788 	mov.w	r7, #1088	; 0x440
 8004f1c:	4282      	cmp	r2, r0
 8004f1e:	bf08      	it	eq
 8004f20:	f043 0301 	orreq.w	r3, r3, #1
 8004f24:	f44f 6085 	mov.w	r0, #1064	; 0x428
 8004f28:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8004f2c:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004f30:	4562      	cmp	r2, ip
 8004f32:	bf08      	it	eq
 8004f34:	f043 0301 	orreq.w	r3, r3, #1
 8004f38:	f44f 6c8e 	mov.w	ip, #1136	; 0x470
 8004f3c:	4282      	cmp	r2, r0
 8004f3e:	bf08      	it	eq
 8004f40:	f043 0301 	orreq.w	r3, r3, #1
 8004f44:	f44f 608b 	mov.w	r0, #1112	; 0x458
 8004f48:	f2c4 0c02 	movt	ip, #16386	; 0x4002
 8004f4c:	42ba      	cmp	r2, r7
 8004f4e:	bf08      	it	eq
 8004f50:	f043 0301 	orreq.w	r3, r3, #1
 8004f54:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004f58:	f44f 6791 	mov.w	r7, #1160	; 0x488
 8004f5c:	4282      	cmp	r2, r0
 8004f5e:	bf08      	it	eq
 8004f60:	f043 0301 	orreq.w	r3, r3, #1
 8004f64:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 8004f68:	f2c4 0702 	movt	r7, #16386	; 0x4002
 8004f6c:	4562      	cmp	r2, ip
 8004f6e:	bf08      	it	eq
 8004f70:	f043 0301 	orreq.w	r3, r3, #1
 8004f74:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8004f78:	42ba      	cmp	r2, r7
 8004f7a:	bf08      	it	eq
 8004f7c:	f043 0301 	orreq.w	r3, r3, #1
 8004f80:	4282      	cmp	r2, r0
 8004f82:	bf08      	it	eq
 8004f84:	f043 0301 	orreq.w	r3, r3, #1
 8004f88:	b933      	cbnz	r3, 8004f98 <HAL_DMA_IRQHandler+0x584>
 8004f8a:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8004f8e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8004f92:	429a      	cmp	r2, r3
 8004f94:	f040 8135 	bne.w	8005202 <HAL_DMA_IRQHandler+0x7ee>
 8004f98:	6813      	ldr	r3, [r2, #0]
 8004f9a:	f3c3 1300 	ubfx	r3, r3, #4, #1
 8004f9e:	b193      	cbz	r3, 8004fc6 <HAL_DMA_IRQHandler+0x5b2>
        regs_dma->IFCR = DMA_FLAG_TCIF0_4 << (hdma->StreamIndex & 0x1FU);
 8004fa0:	60a9      	str	r1, [r5, #8]
        if(HAL_DMA_STATE_ABORT == hdma->State)
 8004fa2:	f894 3035 	ldrb.w	r3, [r4, #53]	; 0x35
 8004fa6:	2b04      	cmp	r3, #4
 8004fa8:	f000 80ba 	beq.w	8005120 <HAL_DMA_IRQHandler+0x70c>
        if(((((DMA_Stream_TypeDef   *)hdma->Instance)->CR) & (uint32_t)(DMA_SxCR_DBM)) != 0U)
 8004fac:	6823      	ldr	r3, [r4, #0]
 8004fae:	681a      	ldr	r2, [r3, #0]
 8004fb0:	0357      	lsls	r7, r2, #13
 8004fb2:	f140 80d7 	bpl.w	8005164 <HAL_DMA_IRQHandler+0x750>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8004fb6:	681b      	ldr	r3, [r3, #0]
 8004fb8:	031d      	lsls	r5, r3, #12
 8004fba:	f140 80e2 	bpl.w	8005182 <HAL_DMA_IRQHandler+0x76e>
          if(hdma->XferCpltCallback != NULL)
 8004fbe:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8004fc0:	b10b      	cbz	r3, 8004fc6 <HAL_DMA_IRQHandler+0x5b2>
            hdma->XferCpltCallback(hdma);
 8004fc2:	4620      	mov	r0, r4
 8004fc4:	4798      	blx	r3
    if(hdma->ErrorCode != HAL_DMA_ERROR_NONE)
 8004fc6:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8004fc8:	2b00      	cmp	r3, #0
 8004fca:	f000 809a 	beq.w	8005102 <HAL_DMA_IRQHandler+0x6ee>
      if((hdma->ErrorCode & HAL_DMA_ERROR_TE) != 0U)
 8004fce:	6d63      	ldr	r3, [r4, #84]	; 0x54
 8004fd0:	07d8      	lsls	r0, r3, #31
 8004fd2:	d522      	bpl.n	800501a <HAL_DMA_IRQHandler+0x606>
        __HAL_DMA_DISABLE(hdma);
 8004fd4:	6822      	ldr	r2, [r4, #0]
        hdma->State = HAL_DMA_STATE_ABORT;
 8004fd6:	2004      	movs	r0, #4
 8004fd8:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
        __HAL_DMA_DISABLE(hdma);
 8004fdc:	6813      	ldr	r3, [r2, #0]
 8004fde:	f023 0301 	bic.w	r3, r3, #1
 8004fe2:	6013      	str	r3, [r2, #0]
  uint32_t timeout = SystemCoreClock / 9600U;
 8004fe4:	f248 13b5 	movw	r3, #33205	; 0x81b5
 8004fe8:	6822      	ldr	r2, [r4, #0]
 8004fea:	f6c1 334e 	movt	r3, #6990	; 0x1b4e
 8004fee:	fba3 3606 	umull	r3, r6, r3, r6
 8004ff2:	0ab6      	lsrs	r6, r6, #10
 8004ff4:	e002      	b.n	8004ffc <HAL_DMA_IRQHandler+0x5e8>
        while((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U);
 8004ff6:	6813      	ldr	r3, [r2, #0]
 8004ff8:	07d9      	lsls	r1, r3, #31
 8004ffa:	d504      	bpl.n	8005006 <HAL_DMA_IRQHandler+0x5f2>
          if (++count > timeout)
 8004ffc:	9b01      	ldr	r3, [sp, #4]
 8004ffe:	3301      	adds	r3, #1
 8005000:	42b3      	cmp	r3, r6
 8005002:	9301      	str	r3, [sp, #4]
 8005004:	d9f7      	bls.n	8004ff6 <HAL_DMA_IRQHandler+0x5e2>
        __HAL_UNLOCK(hdma);
 8005006:	2300      	movs	r3, #0
 8005008:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_EN) != 0U)
 800500c:	6813      	ldr	r3, [r2, #0]
 800500e:	07db      	lsls	r3, r3, #31
          hdma->State = HAL_DMA_STATE_ERROR;
 8005010:	bf4c      	ite	mi
 8005012:	2303      	movmi	r3, #3
          hdma->State = HAL_DMA_STATE_READY;
 8005014:	2301      	movpl	r3, #1
 8005016:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
      if(hdma->XferErrorCallback != NULL)
 800501a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800501c:	2b00      	cmp	r3, #0
 800501e:	d070      	beq.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
        hdma->XferErrorCallback(hdma);
 8005020:	4620      	mov	r0, r4
}
 8005022:	b002      	add	sp, #8
 8005024:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hdma->XferErrorCallback(hdma);
 8005028:	4718      	bx	r3
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TE) != 0U)
 800502a:	6823      	ldr	r3, [r4, #0]
 800502c:	075b      	lsls	r3, r3, #29
 800502e:	f57f ad7c 	bpl.w	8004b2a <HAL_DMA_IRQHandler+0x116>
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8005032:	6822      	ldr	r2, [r4, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 8005034:	2308      	movs	r3, #8
        ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TE);
 8005036:	f022 0204 	bic.w	r2, r2, #4
 800503a:	6022      	str	r2, [r4, #0]
        regs_dma->IFCR = DMA_FLAG_TEIF0_4 << (hdma->StreamIndex & 0x1FU);
 800503c:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
 800503e:	f002 021f 	and.w	r2, r2, #31
 8005042:	4093      	lsls	r3, r2
 8005044:	60ab      	str	r3, [r5, #8]
        hdma->ErrorCode |= HAL_DMA_ERROR_TE;
 8005046:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8005048:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 800504a:	f043 0301 	orr.w	r3, r3, #1
 800504e:	f001 021f 	and.w	r2, r1, #31
 8005052:	6543      	str	r3, [r0, #84]	; 0x54
    if ((tmpisr_dma & (DMA_FLAG_FEIF0_4 << (hdma->StreamIndex & 0x1FU))) != 0U)
 8005054:	fa27 f302 	lsr.w	r3, r7, r2
 8005058:	07dc      	lsls	r4, r3, #31
 800505a:	f57f adf3 	bpl.w	8004c44 <HAL_DMA_IRQHandler+0x230>
 800505e:	e569      	b.n	8004b34 <HAL_DMA_IRQHandler+0x120>
  else if(IS_BDMA_CHANNEL_INSTANCE(hdma->Instance) != 0U)  /* BDMA instance(s) */
 8005060:	f245 4308 	movw	r3, #21512	; 0x5408
 8005064:	f245 411c 	movw	r1, #21532	; 0x541c
 8005068:	f245 4630 	movw	r6, #21552	; 0x5430
 800506c:	f245 4758 	movw	r7, #21592	; 0x5458
 8005070:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005074:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8005078:	f6c5 0602 	movt	r6, #22530	; 0x5802
 800507c:	f6c5 0702 	movt	r7, #22530	; 0x5802
 8005080:	428c      	cmp	r4, r1
 8005082:	bf18      	it	ne
 8005084:	429c      	cmpne	r4, r3
 8005086:	f245 4144 	movw	r1, #21572	; 0x5444
 800508a:	bf0c      	ite	eq
 800508c:	2301      	moveq	r3, #1
 800508e:	2300      	movne	r3, #0
 8005090:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8005094:	42b4      	cmp	r4, r6
 8005096:	bf08      	it	eq
 8005098:	f043 0301 	orreq.w	r3, r3, #1
 800509c:	f245 466c 	movw	r6, #21612	; 0x546c
 80050a0:	428c      	cmp	r4, r1
 80050a2:	bf08      	it	eq
 80050a4:	f043 0301 	orreq.w	r3, r3, #1
 80050a8:	f6c5 0602 	movt	r6, #22530	; 0x5802
 80050ac:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 80050b0:	42bc      	cmp	r4, r7
 80050b2:	bf08      	it	eq
 80050b4:	f043 0301 	orreq.w	r3, r3, #1
 80050b8:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80050bc:	42b4      	cmp	r4, r6
 80050be:	bf08      	it	eq
 80050c0:	f043 0301 	orreq.w	r3, r3, #1
 80050c4:	428c      	cmp	r4, r1
 80050c6:	bf08      	it	eq
 80050c8:	f043 0301 	orreq.w	r3, r3, #1
 80050cc:	b92b      	cbnz	r3, 80050da <HAL_DMA_IRQHandler+0x6c6>
 80050ce:	f245 4394 	movw	r3, #21652	; 0x5494
 80050d2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80050d6:	429c      	cmp	r4, r3
 80050d8:	d113      	bne.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 80050da:	6dc1      	ldr	r1, [r0, #92]	; 0x5c
 80050dc:	2604      	movs	r6, #4
    ccr_reg = (((BDMA_Channel_TypeDef   *)hdma->Instance)->CCR);
 80050de:	6823      	ldr	r3, [r4, #0]
    if (((tmpisr_bdma & (BDMA_FLAG_HT0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_HTIE) != 0U))
 80050e0:	f001 011f 	and.w	r1, r1, #31
 80050e4:	408e      	lsls	r6, r1
 80050e6:	4216      	tst	r6, r2
 80050e8:	d054      	beq.n	8005194 <HAL_DMA_IRQHandler+0x780>
 80050ea:	075f      	lsls	r7, r3, #29
 80050ec:	d552      	bpl.n	8005194 <HAL_DMA_IRQHandler+0x780>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80050ee:	0419      	lsls	r1, r3, #16
      regs_bdma->IFCR = (BDMA_ISR_HTIF0 << (hdma->StreamIndex & 0x1FU));
 80050f0:	606e      	str	r6, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80050f2:	f140 808a 	bpl.w	800520a <HAL_DMA_IRQHandler+0x7f6>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 80050f6:	03da      	lsls	r2, r3, #15
 80050f8:	f100 8105 	bmi.w	8005306 <HAL_DMA_IRQHandler+0x8f2>
          if(hdma->XferM1HalfCpltCallback != NULL)
 80050fc:	6c83      	ldr	r3, [r0, #72]	; 0x48
 80050fe:	2b00      	cmp	r3, #0
 8005100:	d18f      	bne.n	8005022 <HAL_DMA_IRQHandler+0x60e>
}
 8005102:	b002      	add	sp, #8
 8005104:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CT) == 0U)
 8005108:	681b      	ldr	r3, [r3, #0]
 800510a:	0319      	lsls	r1, r3, #12
 800510c:	f57f aebd 	bpl.w	8004e8a <HAL_DMA_IRQHandler+0x476>
            if(hdma->XferM1HalfCpltCallback != NULL)
 8005110:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8005112:	2b00      	cmp	r3, #0
 8005114:	f47f aebd 	bne.w	8004e92 <HAL_DMA_IRQHandler+0x47e>
 8005118:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800511a:	f002 021f 	and.w	r2, r2, #31
 800511e:	e6bd      	b.n	8004e9c <HAL_DMA_IRQHandler+0x488>
          ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC | DMA_IT_TE | DMA_IT_DME);
 8005120:	6822      	ldr	r2, [r4, #0]
 8005122:	6813      	ldr	r3, [r2, #0]
 8005124:	f023 0316 	bic.w	r3, r3, #22
 8005128:	6013      	str	r3, [r2, #0]
          ((DMA_Stream_TypeDef   *)hdma->Instance)->FCR &= ~(DMA_IT_FE);
 800512a:	6822      	ldr	r2, [r4, #0]
 800512c:	6953      	ldr	r3, [r2, #20]
 800512e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8005132:	6153      	str	r3, [r2, #20]
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 8005134:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005136:	b34b      	cbz	r3, 800518c <HAL_DMA_IRQHandler+0x778>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_HT);
 8005138:	6822      	ldr	r2, [r4, #0]
 800513a:	6813      	ldr	r3, [r2, #0]
 800513c:	f023 0308 	bic.w	r3, r3, #8
 8005140:	6013      	str	r3, [r2, #0]
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 8005142:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8005144:	233f      	movs	r3, #63	; 0x3f
          __HAL_UNLOCK(hdma);
 8005146:	2000      	movs	r0, #0
          hdma->State = HAL_DMA_STATE_READY;
 8005148:	2101      	movs	r1, #1
          regs_dma->IFCR = 0x3FUL << (hdma->StreamIndex & 0x1FU);
 800514a:	f002 021f 	and.w	r2, r2, #31
 800514e:	4093      	lsls	r3, r2
 8005150:	60ab      	str	r3, [r5, #8]
          if(hdma->XferAbortCallback != NULL)
 8005152:	6d23      	ldr	r3, [r4, #80]	; 0x50
          __HAL_UNLOCK(hdma);
 8005154:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8005158:	f884 1035 	strb.w	r1, [r4, #53]	; 0x35
          if(hdma->XferAbortCallback != NULL)
 800515c:	2b00      	cmp	r3, #0
 800515e:	f47f af5f 	bne.w	8005020 <HAL_DMA_IRQHandler+0x60c>
 8005162:	e7ce      	b.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
          if((((DMA_Stream_TypeDef   *)hdma->Instance)->CR & DMA_SxCR_CIRC) == 0U)
 8005164:	681a      	ldr	r2, [r3, #0]
 8005166:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 800516a:	f47f af28 	bne.w	8004fbe <HAL_DMA_IRQHandler+0x5aa>
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 800516e:	6819      	ldr	r1, [r3, #0]
            hdma->State = HAL_DMA_STATE_READY;
 8005170:	2001      	movs	r0, #1
            ((DMA_Stream_TypeDef   *)hdma->Instance)->CR  &= ~(DMA_IT_TC);
 8005172:	f021 0110 	bic.w	r1, r1, #16
 8005176:	6019      	str	r1, [r3, #0]
            __HAL_UNLOCK(hdma);
 8005178:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
            hdma->State = HAL_DMA_STATE_READY;
 800517c:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
 8005180:	e71d      	b.n	8004fbe <HAL_DMA_IRQHandler+0x5aa>
            if(hdma->XferM1CpltCallback != NULL)
 8005182:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8005184:	2b00      	cmp	r3, #0
 8005186:	f47f af1c 	bne.w	8004fc2 <HAL_DMA_IRQHandler+0x5ae>
 800518a:	e71c      	b.n	8004fc6 <HAL_DMA_IRQHandler+0x5b2>
          if((hdma->XferHalfCpltCallback != NULL) || (hdma->XferM1HalfCpltCallback != NULL))
 800518c:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800518e:	2b00      	cmp	r3, #0
 8005190:	d1d2      	bne.n	8005138 <HAL_DMA_IRQHandler+0x724>
 8005192:	e7d6      	b.n	8005142 <HAL_DMA_IRQHandler+0x72e>
    else if (((tmpisr_bdma & (BDMA_FLAG_TC0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TCIE) != 0U))
 8005194:	2602      	movs	r6, #2
 8005196:	408e      	lsls	r6, r1
 8005198:	4216      	tst	r6, r2
 800519a:	d00d      	beq.n	80051b8 <HAL_DMA_IRQHandler+0x7a4>
 800519c:	079f      	lsls	r7, r3, #30
 800519e:	d50b      	bpl.n	80051b8 <HAL_DMA_IRQHandler+0x7a4>
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80051a0:	041c      	lsls	r4, r3, #16
      regs_bdma->IFCR = (BDMA_ISR_TCIF0) << (hdma->StreamIndex & 0x1FU);
 80051a2:	606e      	str	r6, [r5, #4]
      if((ccr_reg & BDMA_CCR_DBM) != 0U)
 80051a4:	f140 80b4 	bpl.w	8005310 <HAL_DMA_IRQHandler+0x8fc>
        if((ccr_reg & BDMA_CCR_CT) == 0U)
 80051a8:	03d9      	lsls	r1, r3, #15
 80051aa:	f100 8135 	bmi.w	8005418 <HAL_DMA_IRQHandler+0xa04>
          if(hdma->XferM1CpltCallback != NULL)
 80051ae:	6c43      	ldr	r3, [r0, #68]	; 0x44
 80051b0:	2b00      	cmp	r3, #0
 80051b2:	f47f af36 	bne.w	8005022 <HAL_DMA_IRQHandler+0x60e>
 80051b6:	e7a4      	b.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
    else if (((tmpisr_bdma & (BDMA_FLAG_TE0 << (hdma->StreamIndex & 0x1FU))) != 0U) && ((ccr_reg & BDMA_CCR_TEIE) != 0U))
 80051b8:	2608      	movs	r6, #8
 80051ba:	fa06 f101 	lsl.w	r1, r6, r1
 80051be:	4211      	tst	r1, r2
 80051c0:	d09f      	beq.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
 80051c2:	071b      	lsls	r3, r3, #28
 80051c4:	d59d      	bpl.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80051c6:	6823      	ldr	r3, [r4, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80051c8:	2201      	movs	r2, #1
      __HAL_UNLOCK(hdma);
 80051ca:	2100      	movs	r1, #0
      __HAL_DMA_DISABLE_IT(hdma, (DMA_IT_TC | DMA_IT_HT | DMA_IT_TE));
 80051cc:	f023 030e 	bic.w	r3, r3, #14
 80051d0:	6023      	str	r3, [r4, #0]
      regs_bdma->IFCR = (BDMA_ISR_GIF0) << (hdma->StreamIndex & 0x1FU);
 80051d2:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80051d4:	f003 031f 	and.w	r3, r3, #31
 80051d8:	fa02 f303 	lsl.w	r3, r2, r3
 80051dc:	606b      	str	r3, [r5, #4]
      if (hdma->XferErrorCallback != NULL)
 80051de:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
      hdma->ErrorCode = HAL_DMA_ERROR_TE;
 80051e0:	6542      	str	r2, [r0, #84]	; 0x54
      __HAL_UNLOCK(hdma);
 80051e2:	f880 1034 	strb.w	r1, [r0, #52]	; 0x34
      hdma->State = HAL_DMA_STATE_READY;
 80051e6:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35
      if (hdma->XferErrorCallback != NULL)
 80051ea:	2b00      	cmp	r3, #0
 80051ec:	f47f af19 	bne.w	8005022 <HAL_DMA_IRQHandler+0x60e>
 80051f0:	e787      	b.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_HT) != 0U)
 80051f2:	680b      	ldr	r3, [r1, #0]
 80051f4:	f3c3 0380 	ubfx	r3, r3, #2, #1
 80051f8:	e639      	b.n	8004e6e <HAL_DMA_IRQHandler+0x45a>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_DME) != 0U)
 80051fa:	680b      	ldr	r3, [r1, #0]
 80051fc:	e5b0      	b.n	8004d60 <HAL_DMA_IRQHandler+0x34c>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_FE) != 0U)
 80051fe:	680b      	ldr	r3, [r1, #0]
 8005200:	e520      	b.n	8004c44 <HAL_DMA_IRQHandler+0x230>
      if(__HAL_DMA_GET_IT_SOURCE(hdma, DMA_IT_TC) != 0U)
 8005202:	6813      	ldr	r3, [r2, #0]
 8005204:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8005208:	e6c9      	b.n	8004f9e <HAL_DMA_IRQHandler+0x58a>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 800520a:	069b      	lsls	r3, r3, #26
 800520c:	d47b      	bmi.n	8005306 <HAL_DMA_IRQHandler+0x8f2>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 800520e:	2310      	movs	r3, #16
 8005210:	2428      	movs	r4, #40	; 0x28
 8005212:	6802      	ldr	r2, [r0, #0]
 8005214:	2140      	movs	r1, #64	; 0x40
 8005216:	f2c4 0302 	movt	r3, #16386	; 0x4002
 800521a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800521e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005222:	2558      	movs	r5, #88	; 0x58
 8005224:	42a2      	cmp	r2, r4
 8005226:	bf18      	it	ne
 8005228:	429a      	cmpne	r2, r3
 800522a:	f04f 0470 	mov.w	r4, #112	; 0x70
 800522e:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8005232:	bf0c      	ite	eq
 8005234:	2301      	moveq	r3, #1
 8005236:	2300      	movne	r3, #0
 8005238:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800523c:	428a      	cmp	r2, r1
 800523e:	bf08      	it	eq
 8005240:	f043 0301 	orreq.w	r3, r3, #1
 8005244:	2188      	movs	r1, #136	; 0x88
 8005246:	42aa      	cmp	r2, r5
 8005248:	bf08      	it	eq
 800524a:	f043 0301 	orreq.w	r3, r3, #1
 800524e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005252:	25a0      	movs	r5, #160	; 0xa0
 8005254:	42a2      	cmp	r2, r4
 8005256:	bf08      	it	eq
 8005258:	f043 0301 	orreq.w	r3, r3, #1
 800525c:	24b8      	movs	r4, #184	; 0xb8
 800525e:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8005262:	428a      	cmp	r2, r1
 8005264:	bf08      	it	eq
 8005266:	f043 0301 	orreq.w	r3, r3, #1
 800526a:	f2c4 0402 	movt	r4, #16386	; 0x4002
 800526e:	f44f 6182 	mov.w	r1, #1040	; 0x410
 8005272:	42aa      	cmp	r2, r5
 8005274:	bf08      	it	eq
 8005276:	f043 0301 	orreq.w	r3, r3, #1
 800527a:	f44f 6585 	mov.w	r5, #1064	; 0x428
 800527e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005282:	42a2      	cmp	r2, r4
 8005284:	bf08      	it	eq
 8005286:	f043 0301 	orreq.w	r3, r3, #1
 800528a:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800528e:	f44f 6488 	mov.w	r4, #1088	; 0x440
 8005292:	428a      	cmp	r2, r1
 8005294:	bf08      	it	eq
 8005296:	f043 0301 	orreq.w	r3, r3, #1
 800529a:	f44f 618b 	mov.w	r1, #1112	; 0x458
 800529e:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80052a2:	42aa      	cmp	r2, r5
 80052a4:	bf08      	it	eq
 80052a6:	f043 0301 	orreq.w	r3, r3, #1
 80052aa:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80052ae:	f44f 658e 	mov.w	r5, #1136	; 0x470
 80052b2:	42a2      	cmp	r2, r4
 80052b4:	bf08      	it	eq
 80052b6:	f043 0301 	orreq.w	r3, r3, #1
 80052ba:	f44f 6491 	mov.w	r4, #1160	; 0x488
 80052be:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80052c2:	428a      	cmp	r2, r1
 80052c4:	bf08      	it	eq
 80052c6:	f043 0301 	orreq.w	r3, r3, #1
 80052ca:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80052ce:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 80052d2:	42aa      	cmp	r2, r5
 80052d4:	bf08      	it	eq
 80052d6:	f043 0301 	orreq.w	r3, r3, #1
 80052da:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80052de:	42a2      	cmp	r2, r4
 80052e0:	bf08      	it	eq
 80052e2:	f043 0301 	orreq.w	r3, r3, #1
 80052e6:	428a      	cmp	r2, r1
 80052e8:	bf08      	it	eq
 80052ea:	f043 0301 	orreq.w	r3, r3, #1
 80052ee:	b933      	cbnz	r3, 80052fe <HAL_DMA_IRQHandler+0x8ea>
 80052f0:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 80052f4:	f2c4 0302 	movt	r3, #16386	; 0x4002
 80052f8:	429a      	cmp	r2, r3
 80052fa:	f040 8092 	bne.w	8005422 <HAL_DMA_IRQHandler+0xa0e>
 80052fe:	6813      	ldr	r3, [r2, #0]
 8005300:	f023 0308 	bic.w	r3, r3, #8
 8005304:	6013      	str	r3, [r2, #0]
       if(hdma->XferHalfCpltCallback != NULL)
 8005306:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005308:	2b00      	cmp	r3, #0
 800530a:	f47f ae8a 	bne.w	8005022 <HAL_DMA_IRQHandler+0x60e>
 800530e:	e6f8      	b.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
        if((ccr_reg & BDMA_CCR_CIRC) == 0U)
 8005310:	069a      	lsls	r2, r3, #26
 8005312:	f100 8081 	bmi.w	8005418 <HAL_DMA_IRQHandler+0xa04>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 8005316:	2310      	movs	r3, #16
 8005318:	2428      	movs	r4, #40	; 0x28
 800531a:	6802      	ldr	r2, [r0, #0]
 800531c:	2140      	movs	r1, #64	; 0x40
 800531e:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005322:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8005326:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800532a:	2558      	movs	r5, #88	; 0x58
 800532c:	42a2      	cmp	r2, r4
 800532e:	bf18      	it	ne
 8005330:	429a      	cmpne	r2, r3
 8005332:	f04f 0470 	mov.w	r4, #112	; 0x70
 8005336:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800533a:	bf0c      	ite	eq
 800533c:	2301      	moveq	r3, #1
 800533e:	2300      	movne	r3, #0
 8005340:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8005344:	428a      	cmp	r2, r1
 8005346:	bf08      	it	eq
 8005348:	f043 0301 	orreq.w	r3, r3, #1
 800534c:	2188      	movs	r1, #136	; 0x88
 800534e:	42aa      	cmp	r2, r5
 8005350:	bf08      	it	eq
 8005352:	f043 0301 	orreq.w	r3, r3, #1
 8005356:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800535a:	25a0      	movs	r5, #160	; 0xa0
 800535c:	42a2      	cmp	r2, r4
 800535e:	bf08      	it	eq
 8005360:	f043 0301 	orreq.w	r3, r3, #1
 8005364:	24b8      	movs	r4, #184	; 0xb8
 8005366:	f2c4 0502 	movt	r5, #16386	; 0x4002
 800536a:	428a      	cmp	r2, r1
 800536c:	bf08      	it	eq
 800536e:	f043 0301 	orreq.w	r3, r3, #1
 8005372:	f2c4 0402 	movt	r4, #16386	; 0x4002
 8005376:	f44f 6182 	mov.w	r1, #1040	; 0x410
 800537a:	42aa      	cmp	r2, r5
 800537c:	bf08      	it	eq
 800537e:	f043 0301 	orreq.w	r3, r3, #1
 8005382:	f44f 6585 	mov.w	r5, #1064	; 0x428
 8005386:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800538a:	42a2      	cmp	r2, r4
 800538c:	bf08      	it	eq
 800538e:	f043 0301 	orreq.w	r3, r3, #1
 8005392:	f2c4 0502 	movt	r5, #16386	; 0x4002
 8005396:	f44f 6488 	mov.w	r4, #1088	; 0x440
 800539a:	428a      	cmp	r2, r1
 800539c:	bf08      	it	eq
 800539e:	f043 0301 	orreq.w	r3, r3, #1
 80053a2:	f44f 618b 	mov.w	r1, #1112	; 0x458
 80053a6:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80053aa:	42aa      	cmp	r2, r5
 80053ac:	bf08      	it	eq
 80053ae:	f043 0301 	orreq.w	r3, r3, #1
 80053b2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80053b6:	f44f 658e 	mov.w	r5, #1136	; 0x470
 80053ba:	42a2      	cmp	r2, r4
 80053bc:	bf08      	it	eq
 80053be:	f043 0301 	orreq.w	r3, r3, #1
 80053c2:	f44f 6491 	mov.w	r4, #1160	; 0x488
 80053c6:	f2c4 0502 	movt	r5, #16386	; 0x4002
 80053ca:	428a      	cmp	r2, r1
 80053cc:	bf08      	it	eq
 80053ce:	f043 0301 	orreq.w	r3, r3, #1
 80053d2:	f2c4 0402 	movt	r4, #16386	; 0x4002
 80053d6:	f44f 6194 	mov.w	r1, #1184	; 0x4a0
 80053da:	42aa      	cmp	r2, r5
 80053dc:	bf08      	it	eq
 80053de:	f043 0301 	orreq.w	r3, r3, #1
 80053e2:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80053e6:	42a2      	cmp	r2, r4
 80053e8:	bf08      	it	eq
 80053ea:	f043 0301 	orreq.w	r3, r3, #1
 80053ee:	428a      	cmp	r2, r1
 80053f0:	bf08      	it	eq
 80053f2:	f043 0301 	orreq.w	r3, r3, #1
 80053f6:	b92b      	cbnz	r3, 8005404 <HAL_DMA_IRQHandler+0x9f0>
 80053f8:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 80053fc:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005400:	429a      	cmp	r2, r3
 8005402:	d113      	bne.n	800542c <HAL_DMA_IRQHandler+0xa18>
 8005404:	6813      	ldr	r3, [r2, #0]
 8005406:	f023 0314 	bic.w	r3, r3, #20
 800540a:	6013      	str	r3, [r2, #0]
          __HAL_UNLOCK(hdma);
 800540c:	2200      	movs	r2, #0
          hdma->State = HAL_DMA_STATE_READY;
 800540e:	2301      	movs	r3, #1
          __HAL_UNLOCK(hdma);
 8005410:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
          hdma->State = HAL_DMA_STATE_READY;
 8005414:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
        if(hdma->XferCpltCallback != NULL)
 8005418:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 800541a:	2b00      	cmp	r3, #0
 800541c:	f47f ae01 	bne.w	8005022 <HAL_DMA_IRQHandler+0x60e>
 8005420:	e66f      	b.n	8005102 <HAL_DMA_IRQHandler+0x6ee>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_HT);
 8005422:	6813      	ldr	r3, [r2, #0]
 8005424:	f023 0304 	bic.w	r3, r3, #4
 8005428:	6013      	str	r3, [r2, #0]
 800542a:	e76c      	b.n	8005306 <HAL_DMA_IRQHandler+0x8f2>
          __HAL_DMA_DISABLE_IT(hdma, DMA_IT_TE | DMA_IT_TC);
 800542c:	6813      	ldr	r3, [r2, #0]
 800542e:	f023 030a 	bic.w	r3, r3, #10
 8005432:	6013      	str	r3, [r2, #0]
 8005434:	e7ea      	b.n	800540c <HAL_DMA_IRQHandler+0x9f8>
 8005436:	bf00      	nop

08005438 <HAL_DMA_GetState>:
  return hdma->State;
 8005438:	f890 0035 	ldrb.w	r0, [r0, #53]	; 0x35
}
 800543c:	4770      	bx	lr
 800543e:	bf00      	nop

08005440 <HAL_DMA_GetError>:
  return hdma->ErrorCode;
 8005440:	6d40      	ldr	r0, [r0, #84]	; 0x54
}
 8005442:	4770      	bx	lr

08005444 <HAL_DMAEx_ConfigMuxSync>:
  *                     the configuration information for the specified DMA Stream.
  * @param  pSyncConfig : pointer to HAL_DMA_MuxSyncConfigTypeDef : contains the DMAMUX synchronization parameters
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMAEx_ConfigMuxSync(DMA_HandleTypeDef *hdma, HAL_DMA_MuxSyncConfigTypeDef *pSyncConfig)
{
 8005444:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005446:	4605      	mov	r5, r0
  uint32_t syncSignalID = 0;
  uint32_t syncPolarity = 0;

  /* Check the parameters */
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 8005448:	2310      	movs	r3, #16
 800544a:	2628      	movs	r6, #40	; 0x28
 800544c:	2040      	movs	r0, #64	; 0x40
 800544e:	682a      	ldr	r2, [r5, #0]
 8005450:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005454:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8005458:	f2c4 0002 	movt	r0, #16386	; 0x4002
{
 800545c:	460c      	mov	r4, r1
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 800545e:	2158      	movs	r1, #88	; 0x58
 8005460:	429a      	cmp	r2, r3
 8005462:	bf18      	it	ne
 8005464:	42b2      	cmpne	r2, r6
 8005466:	f04f 0670 	mov.w	r6, #112	; 0x70
 800546a:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800546e:	bf14      	ite	ne
 8005470:	2301      	movne	r3, #1
 8005472:	2300      	moveq	r3, #0
 8005474:	f2c4 0602 	movt	r6, #16386	; 0x4002
 8005478:	4282      	cmp	r2, r0
 800547a:	bf0c      	ite	eq
 800547c:	2300      	moveq	r3, #0
 800547e:	f003 0301 	andne.w	r3, r3, #1
 8005482:	20a0      	movs	r0, #160	; 0xa0
 8005484:	428a      	cmp	r2, r1
 8005486:	bf0c      	ite	eq
 8005488:	2300      	moveq	r3, #0
 800548a:	f003 0301 	andne.w	r3, r3, #1
 800548e:	2188      	movs	r1, #136	; 0x88
 8005490:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8005494:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005498:	42b2      	cmp	r2, r6
 800549a:	bf0c      	ite	eq
 800549c:	2300      	moveq	r3, #0
 800549e:	f003 0301 	andne.w	r3, r3, #1
 80054a2:	f44f 6682 	mov.w	r6, #1040	; 0x410
 80054a6:	428a      	cmp	r2, r1
 80054a8:	bf0c      	ite	eq
 80054aa:	2300      	moveq	r3, #0
 80054ac:	f003 0301 	andne.w	r3, r3, #1
 80054b0:	21b8      	movs	r1, #184	; 0xb8
 80054b2:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80054b6:	4282      	cmp	r2, r0
 80054b8:	bf0c      	ite	eq
 80054ba:	2300      	moveq	r3, #0
 80054bc:	f003 0301 	andne.w	r3, r3, #1
 80054c0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80054c4:	f44f 6088 	mov.w	r0, #1088	; 0x440
 80054c8:	428a      	cmp	r2, r1
 80054ca:	bf0c      	ite	eq
 80054cc:	2300      	moveq	r3, #0
 80054ce:	f003 0301 	andne.w	r3, r3, #1
 80054d2:	f44f 6185 	mov.w	r1, #1064	; 0x428
 80054d6:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80054da:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80054de:	42b2      	cmp	r2, r6
 80054e0:	bf0c      	ite	eq
 80054e2:	2300      	moveq	r3, #0
 80054e4:	f003 0301 	andne.w	r3, r3, #1
 80054e8:	f44f 668e 	mov.w	r6, #1136	; 0x470
 80054ec:	428a      	cmp	r2, r1
 80054ee:	bf0c      	ite	eq
 80054f0:	2300      	moveq	r3, #0
 80054f2:	f003 0301 	andne.w	r3, r3, #1
 80054f6:	f44f 618b 	mov.w	r1, #1112	; 0x458
 80054fa:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80054fe:	4282      	cmp	r2, r0
 8005500:	bf0c      	ite	eq
 8005502:	2300      	moveq	r3, #0
 8005504:	f003 0301 	andne.w	r3, r3, #1
 8005508:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800550c:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 8005510:	428a      	cmp	r2, r1
 8005512:	bf0c      	ite	eq
 8005514:	2300      	moveq	r3, #0
 8005516:	f003 0301 	andne.w	r3, r3, #1
 800551a:	f44f 6191 	mov.w	r1, #1160	; 0x488
 800551e:	f2c4 0002 	movt	r0, #16386	; 0x4002
 8005522:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005526:	42b2      	cmp	r2, r6
 8005528:	bf0c      	ite	eq
 800552a:	2300      	moveq	r3, #0
 800552c:	f003 0301 	andne.w	r3, r3, #1
 8005530:	f245 4608 	movw	r6, #21512	; 0x5408
 8005534:	428a      	cmp	r2, r1
 8005536:	bf0c      	ite	eq
 8005538:	2300      	moveq	r3, #0
 800553a:	f003 0301 	andne.w	r3, r3, #1
 800553e:	f44f 6197 	mov.w	r1, #1208	; 0x4b8
 8005542:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8005546:	4282      	cmp	r2, r0
 8005548:	bf0c      	ite	eq
 800554a:	2300      	moveq	r3, #0
 800554c:	f003 0301 	andne.w	r3, r3, #1
 8005550:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005554:	f245 4030 	movw	r0, #21552	; 0x5430
 8005558:	428a      	cmp	r2, r1
 800555a:	bf0c      	ite	eq
 800555c:	2300      	moveq	r3, #0
 800555e:	f003 0301 	andne.w	r3, r3, #1
 8005562:	f245 411c 	movw	r1, #21532	; 0x541c
 8005566:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800556a:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800556e:	42b2      	cmp	r2, r6
 8005570:	bf0c      	ite	eq
 8005572:	2300      	moveq	r3, #0
 8005574:	f003 0301 	andne.w	r3, r3, #1
 8005578:	f245 4658 	movw	r6, #21592	; 0x5458
 800557c:	428a      	cmp	r2, r1
 800557e:	bf0c      	ite	eq
 8005580:	2300      	moveq	r3, #0
 8005582:	f003 0301 	andne.w	r3, r3, #1
 8005586:	f245 4144 	movw	r1, #21572	; 0x5444
 800558a:	f6c5 0602 	movt	r6, #22530	; 0x5802
 800558e:	4282      	cmp	r2, r0
 8005590:	bf0c      	ite	eq
 8005592:	2300      	moveq	r3, #0
 8005594:	f003 0301 	andne.w	r3, r3, #1
 8005598:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800559c:	f245 406c 	movw	r0, #21612	; 0x546c
 80055a0:	428a      	cmp	r2, r1
 80055a2:	bf0c      	ite	eq
 80055a4:	2300      	moveq	r3, #0
 80055a6:	f003 0301 	andne.w	r3, r3, #1
 80055aa:	f44f 41a9 	mov.w	r1, #21632	; 0x5480
 80055ae:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80055b2:	42b2      	cmp	r2, r6
 80055b4:	bf0c      	ite	eq
 80055b6:	2300      	moveq	r3, #0
 80055b8:	f003 0301 	andne.w	r3, r3, #1
 80055bc:	f6c5 0102 	movt	r1, #22530	; 0x5802
 80055c0:	4282      	cmp	r2, r0
 80055c2:	bf0c      	ite	eq
 80055c4:	2300      	moveq	r3, #0
 80055c6:	f003 0301 	andne.w	r3, r3, #1
 80055ca:	428a      	cmp	r2, r1
 80055cc:	bf0c      	ite	eq
 80055ce:	2300      	moveq	r3, #0
 80055d0:	f003 0301 	andne.w	r3, r3, #1
 80055d4:	b133      	cbz	r3, 80055e4 <HAL_DMAEx_ConfigMuxSync+0x1a0>
 80055d6:	f245 4394 	movw	r3, #21652	; 0x5494
 80055da:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80055de:	429a      	cmp	r2, r3
 80055e0:	f040 80f9 	bne.w	80057d6 <HAL_DMAEx_ConfigMuxSync+0x392>
  assert_param(IS_DMAMUX_SYNC_STATE(pSyncConfig->SyncEnable));
 80055e4:	7a23      	ldrb	r3, [r4, #8]
 80055e6:	2b01      	cmp	r3, #1
 80055e8:	d907      	bls.n	80055fa <HAL_DMAEx_ConfigMuxSync+0x1b6>
 80055ea:	f64d 2038 	movw	r0, #55864	; 0xda38
 80055ee:	f44f 71ca 	mov.w	r1, #404	; 0x194
 80055f2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80055f6:	f010 f937 	bl	8015868 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_EVENT(pSyncConfig->EventEnable));
 80055fa:	7a63      	ldrb	r3, [r4, #9]
 80055fc:	2b01      	cmp	r3, #1
 80055fe:	d907      	bls.n	8005610 <HAL_DMAEx_ConfigMuxSync+0x1cc>
 8005600:	f64d 2038 	movw	r0, #55864	; 0xda38
 8005604:	f240 1195 	movw	r1, #405	; 0x195
 8005608:	f6c0 0002 	movt	r0, #2050	; 0x802
 800560c:	f010 f92c 	bl	8015868 <assert_failed>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
 8005610:	68e3      	ldr	r3, [r4, #12]
 8005612:	3b01      	subs	r3, #1
 8005614:	2b1f      	cmp	r3, #31
 8005616:	f200 80b4 	bhi.w	8005782 <HAL_DMAEx_ConfigMuxSync+0x33e>

  if(pSyncConfig->SyncEnable == ENABLE)
 800561a:	7a23      	ldrb	r3, [r4, #8]
 800561c:	2b01      	cmp	r3, #1
 800561e:	d02f      	beq.n	8005680 <HAL_DMAEx_ConfigMuxSync+0x23c>
  uint32_t syncPolarity = 0;
 8005620:	2200      	movs	r2, #0
  uint32_t syncSignalID = 0;
 8005622:	4611      	mov	r1, r2
    syncSignalID = pSyncConfig->SyncSignalID;
    syncPolarity = pSyncConfig->SyncPolarity;
  }

  /*Check if the DMA state is ready */
  if(hdma->State == HAL_DMA_STATE_READY)
 8005624:	f895 3035 	ldrb.w	r3, [r5, #53]	; 0x35
 8005628:	b2db      	uxtb	r3, r3
 800562a:	2b01      	cmp	r3, #1
 800562c:	d004      	beq.n	8005638 <HAL_DMAEx_ConfigMuxSync+0x1f4>
    return HAL_OK;
  }
  else
  {
    /* Set the error code to busy */
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 800562e:	f44f 6300 	mov.w	r3, #2048	; 0x800

    /* Return error status */
    return HAL_ERROR;
 8005632:	2001      	movs	r0, #1
    hdma->ErrorCode = HAL_DMA_ERROR_BUSY;
 8005634:	656b      	str	r3, [r5, #84]	; 0x54
  }
}
 8005636:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    __HAL_LOCK(hdma);
 8005638:	f895 0034 	ldrb.w	r0, [r5, #52]	; 0x34
 800563c:	2801      	cmp	r0, #1
 800563e:	f000 80b3 	beq.w	80057a8 <HAL_DMAEx_ConfigMuxSync+0x364>
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 8005642:	6e2f      	ldr	r7, [r5, #96]	; 0x60
    __HAL_UNLOCK(hdma);
 8005644:	2600      	movs	r6, #0
    __HAL_LOCK(hdma);
 8005646:	f885 3034 	strb.w	r3, [r5, #52]	; 0x34
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 800564a:	683b      	ldr	r3, [r7, #0]
    return HAL_OK;
 800564c:	4630      	mov	r0, r6
    CLEAR_BIT(hdma->DMAmuxChannel->CCR,(DMAMUX_CxCR_SE | DMAMUX_CxCR_EGE));
 800564e:	f423 3381 	bic.w	r3, r3, #66048	; 0x10200
 8005652:	603b      	str	r3, [r7, #0]
    MODIFY_REG( hdma->DMAmuxChannel->CCR, \
 8005654:	68e7      	ldr	r7, [r4, #12]
 8005656:	7a23      	ldrb	r3, [r4, #8]
 8005658:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 800565c:	6e2f      	ldr	r7, [r5, #96]	; 0x60
 800565e:	041b      	lsls	r3, r3, #16
 8005660:	f894 e009 	ldrb.w	lr, [r4, #9]
 8005664:	683c      	ldr	r4, [r7, #0]
 8005666:	ea43 43cc 	orr.w	r3, r3, ip, lsl #19
 800566a:	b2e4      	uxtb	r4, r4
 800566c:	ea43 234e 	orr.w	r3, r3, lr, lsl #9
 8005670:	4323      	orrs	r3, r4
 8005672:	4313      	orrs	r3, r2
 8005674:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8005678:	603b      	str	r3, [r7, #0]
    __HAL_UNLOCK(hdma);
 800567a:	f885 6034 	strb.w	r6, [r5, #52]	; 0x34
}
 800567e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
 8005680:	6863      	ldr	r3, [r4, #4]
 8005682:	f433 23c0 	bics.w	r3, r3, #393216	; 0x60000
 8005686:	f040 8091 	bne.w	80057ac <HAL_DMAEx_ConfigMuxSync+0x368>
    if(IS_DMA_STREAM_INSTANCE(hdma->Instance) != 0U) /* DMA1 or DMA2 instance */
 800568a:	2310      	movs	r3, #16
 800568c:	2128      	movs	r1, #40	; 0x28
 800568e:	682a      	ldr	r2, [r5, #0]
 8005690:	2040      	movs	r0, #64	; 0x40
 8005692:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005696:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800569a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800569e:	2670      	movs	r6, #112	; 0x70
 80056a0:	428a      	cmp	r2, r1
 80056a2:	bf18      	it	ne
 80056a4:	429a      	cmpne	r2, r3
 80056a6:	f04f 0158 	mov.w	r1, #88	; 0x58
 80056aa:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80056ae:	bf0c      	ite	eq
 80056b0:	2301      	moveq	r3, #1
 80056b2:	2300      	movne	r3, #0
 80056b4:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80056b8:	4282      	cmp	r2, r0
 80056ba:	bf08      	it	eq
 80056bc:	f043 0301 	orreq.w	r3, r3, #1
 80056c0:	20a0      	movs	r0, #160	; 0xa0
 80056c2:	428a      	cmp	r2, r1
 80056c4:	bf08      	it	eq
 80056c6:	f043 0301 	orreq.w	r3, r3, #1
 80056ca:	2188      	movs	r1, #136	; 0x88
 80056cc:	f2c4 0002 	movt	r0, #16386	; 0x4002
 80056d0:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80056d4:	42b2      	cmp	r2, r6
 80056d6:	bf08      	it	eq
 80056d8:	f043 0301 	orreq.w	r3, r3, #1
 80056dc:	f44f 6682 	mov.w	r6, #1040	; 0x410
 80056e0:	428a      	cmp	r2, r1
 80056e2:	bf08      	it	eq
 80056e4:	f043 0301 	orreq.w	r3, r3, #1
 80056e8:	21b8      	movs	r1, #184	; 0xb8
 80056ea:	f2c4 0602 	movt	r6, #16386	; 0x4002
 80056ee:	4282      	cmp	r2, r0
 80056f0:	bf08      	it	eq
 80056f2:	f043 0301 	orreq.w	r3, r3, #1
 80056f6:	f2c4 0102 	movt	r1, #16386	; 0x4002
 80056fa:	f44f 6088 	mov.w	r0, #1088	; 0x440
 80056fe:	428a      	cmp	r2, r1
 8005700:	bf08      	it	eq
 8005702:	f043 0301 	orreq.w	r3, r3, #1
 8005706:	f44f 6185 	mov.w	r1, #1064	; 0x428
 800570a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800570e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005712:	42b2      	cmp	r2, r6
 8005714:	bf08      	it	eq
 8005716:	f043 0301 	orreq.w	r3, r3, #1
 800571a:	f44f 668e 	mov.w	r6, #1136	; 0x470
 800571e:	428a      	cmp	r2, r1
 8005720:	bf08      	it	eq
 8005722:	f043 0301 	orreq.w	r3, r3, #1
 8005726:	f44f 618b 	mov.w	r1, #1112	; 0x458
 800572a:	f2c4 0602 	movt	r6, #16386	; 0x4002
 800572e:	4282      	cmp	r2, r0
 8005730:	bf08      	it	eq
 8005732:	f043 0301 	orreq.w	r3, r3, #1
 8005736:	f2c4 0102 	movt	r1, #16386	; 0x4002
 800573a:	f44f 6094 	mov.w	r0, #1184	; 0x4a0
 800573e:	428a      	cmp	r2, r1
 8005740:	bf08      	it	eq
 8005742:	f043 0301 	orreq.w	r3, r3, #1
 8005746:	f44f 6191 	mov.w	r1, #1160	; 0x488
 800574a:	f2c4 0002 	movt	r0, #16386	; 0x4002
 800574e:	f2c4 0102 	movt	r1, #16386	; 0x4002
 8005752:	42b2      	cmp	r2, r6
 8005754:	bf08      	it	eq
 8005756:	f043 0301 	orreq.w	r3, r3, #1
 800575a:	428a      	cmp	r2, r1
 800575c:	bf08      	it	eq
 800575e:	f043 0301 	orreq.w	r3, r3, #1
 8005762:	6821      	ldr	r1, [r4, #0]
 8005764:	4282      	cmp	r2, r0
 8005766:	bf08      	it	eq
 8005768:	f043 0301 	orreq.w	r3, r3, #1
 800576c:	b92b      	cbnz	r3, 800577a <HAL_DMAEx_ConfigMuxSync+0x336>
 800576e:	f44f 6397 	mov.w	r3, #1208	; 0x4b8
 8005772:	f2c4 0302 	movt	r3, #16386	; 0x4002
 8005776:	429a      	cmp	r2, r3
 8005778:	d121      	bne.n	80057be <HAL_DMAEx_ConfigMuxSync+0x37a>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 800577a:	2907      	cmp	r1, #7
 800577c:	d80a      	bhi.n	8005794 <HAL_DMAEx_ConfigMuxSync+0x350>
    syncPolarity = pSyncConfig->SyncPolarity;
 800577e:	6862      	ldr	r2, [r4, #4]
 8005780:	e750      	b.n	8005624 <HAL_DMAEx_ConfigMuxSync+0x1e0>
  assert_param(IS_DMAMUX_SYNC_REQUEST_NUMBER(pSyncConfig->RequestNumber));
 8005782:	f64d 2038 	movw	r0, #55864	; 0xda38
 8005786:	f44f 71cb 	mov.w	r1, #406	; 0x196
 800578a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800578e:	f010 f86b 	bl	8015868 <assert_failed>
 8005792:	e742      	b.n	800561a <HAL_DMAEx_ConfigMuxSync+0x1d6>
      assert_param(IS_DMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 8005794:	f64d 2038 	movw	r0, #55864	; 0xda38
 8005798:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 800579c:	f6c0 0002 	movt	r0, #2050	; 0x802
 80057a0:	f010 f862 	bl	8015868 <assert_failed>
 80057a4:	6821      	ldr	r1, [r4, #0]
 80057a6:	e7ea      	b.n	800577e <HAL_DMAEx_ConfigMuxSync+0x33a>
    __HAL_LOCK(hdma);
 80057a8:	2002      	movs	r0, #2
}
 80057aa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_DMAMUX_SYNC_POLARITY(pSyncConfig->SyncPolarity));
 80057ac:	f64d 2038 	movw	r0, #55864	; 0xda38
 80057b0:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 80057b4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80057b8:	f010 f856 	bl	8015868 <assert_failed>
 80057bc:	e765      	b.n	800568a <HAL_DMAEx_ConfigMuxSync+0x246>
      assert_param(IS_BDMA_DMAMUX_SYNC_SIGNAL_ID(pSyncConfig->SyncSignalID));
 80057be:	290f      	cmp	r1, #15
 80057c0:	d9dd      	bls.n	800577e <HAL_DMAEx_ConfigMuxSync+0x33a>
 80057c2:	f64d 2038 	movw	r0, #55864	; 0xda38
 80057c6:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
 80057ca:	f6c0 0002 	movt	r0, #2050	; 0x802
 80057ce:	f010 f84b 	bl	8015868 <assert_failed>
 80057d2:	6821      	ldr	r1, [r4, #0]
 80057d4:	e7d3      	b.n	800577e <HAL_DMAEx_ConfigMuxSync+0x33a>
  assert_param(IS_DMA_DMAMUX_ALL_INSTANCE(hdma->Instance));
 80057d6:	f64d 2038 	movw	r0, #55864	; 0xda38
 80057da:	f240 1193 	movw	r1, #403	; 0x193
 80057de:	f6c0 0002 	movt	r0, #2050	; 0x802
 80057e2:	f010 f841 	bl	8015868 <assert_failed>
 80057e6:	e6fd      	b.n	80055e4 <HAL_DMAEx_ConfigMuxSync+0x1a0>

080057e8 <HAL_DMAEx_MUX_IRQHandler>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.
  * @retval None
  */
void HAL_DMAEx_MUX_IRQHandler(DMA_HandleTypeDef *hdma)
{
 80057e8:	b510      	push	{r4, lr}
  /* Check for DMAMUX Synchronization overrun */
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
 80057ea:	e9d0 2319 	ldrd	r2, r3, [r0, #100]	; 0x64
{
 80057ee:	4604      	mov	r4, r0
  if((hdma->DMAmuxChannelStatus->CSR & hdma->DMAmuxChannelStatusMask) != 0U)
 80057f0:	6812      	ldr	r2, [r2, #0]
 80057f2:	421a      	tst	r2, r3
 80057f4:	d00e      	beq.n	8005814 <HAL_DMAEx_MUX_IRQHandler+0x2c>
  {
    /* Disable the synchro overrun interrupt */
    hdma->DMAmuxChannel->CCR &= ~DMAMUX_CxCR_SOIE;
 80057f6:	6e02      	ldr	r2, [r0, #96]	; 0x60
 80057f8:	6813      	ldr	r3, [r2, #0]
 80057fa:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80057fe:	6013      	str	r3, [r2, #0]

    /* Clear the DMAMUX synchro overrun flag */
    hdma->DMAmuxChannelStatus->CFR = hdma->DMAmuxChannelStatusMask;
 8005800:	e9d0 3219 	ldrd	r3, r2, [r0, #100]	; 0x64
 8005804:	605a      	str	r2, [r3, #4]

    /* Update error code */
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
 8005806:	6d43      	ldr	r3, [r0, #84]	; 0x54

    if(hdma->XferErrorCallback != NULL)
 8005808:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
    hdma->ErrorCode |= HAL_DMA_ERROR_SYNC;
 800580a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800580e:	6543      	str	r3, [r0, #84]	; 0x54
    if(hdma->XferErrorCallback != NULL)
 8005810:	b102      	cbz	r2, 8005814 <HAL_DMAEx_MUX_IRQHandler+0x2c>
    {
      /* Transfer error callback */
      hdma->XferErrorCallback(hdma);
 8005812:	4790      	blx	r2
    }
  }

  if(hdma->DMAmuxRequestGen != 0)
 8005814:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 8005816:	b1ab      	cbz	r3, 8005844 <HAL_DMAEx_MUX_IRQHandler+0x5c>
  {
   /* if using a DMAMUX request generator block Check for DMAMUX request generator overrun */
    if((hdma->DMAmuxRequestGenStatus->RGSR & hdma->DMAmuxRequestGenStatusMask) != 0U)
 8005818:	e9d4 121c 	ldrd	r1, r2, [r4, #112]	; 0x70
 800581c:	6809      	ldr	r1, [r1, #0]
 800581e:	4211      	tst	r1, r2
 8005820:	d010      	beq.n	8005844 <HAL_DMAEx_MUX_IRQHandler+0x5c>
    {
      /* Disable the request gen overrun interrupt */
      hdma->DMAmuxRequestGen->RGCR &= ~DMAMUX_RGxCR_OIE;
 8005822:	681a      	ldr	r2, [r3, #0]
 8005824:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8005828:	601a      	str	r2, [r3, #0]

      /* Clear the DMAMUX request generator overrun flag */
      hdma->DMAmuxRequestGenStatus->RGCFR = hdma->DMAmuxRequestGenStatusMask;
 800582a:	e9d4 321c 	ldrd	r3, r2, [r4, #112]	; 0x70
 800582e:	605a      	str	r2, [r3, #4]

      /* Update error code */
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
 8005830:	6d63      	ldr	r3, [r4, #84]	; 0x54

      if(hdma->XferErrorCallback != NULL)
 8005832:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
      hdma->ErrorCode |= HAL_DMA_ERROR_REQGEN;
 8005834:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8005838:	6563      	str	r3, [r4, #84]	; 0x54
      if(hdma->XferErrorCallback != NULL)
 800583a:	b11a      	cbz	r2, 8005844 <HAL_DMAEx_MUX_IRQHandler+0x5c>
      {
        /* Transfer error callback */
        hdma->XferErrorCallback(hdma);
 800583c:	4620      	mov	r0, r4
      }
    }
  }
}
 800583e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        hdma->XferErrorCallback(hdma);
 8005842:	4710      	bx	r2
}
 8005844:	bd10      	pop	{r4, pc}
 8005846:	bf00      	nop

08005848 <FLASH_WaitForLastOperation.constprop.3>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout maximum flash operation timeout
  * @param  Bank flash FLASH_BANK_1 or FLASH_BANK_2
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout, uint32_t Bank)
 8005848:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800584a:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on QW flag to be reset.
     Even if the FLASH operation fails, the QW flag will be reset and an error
     flag will be set */

  uint32_t bsyflag, errorflag;
  uint32_t tickstart = HAL_GetTick();
 800584c:	f7fb f8f6 	bl	8000a3c <HAL_GetTick>
 8005850:	4606      	mov	r6, r0

  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8005852:	1e6b      	subs	r3, r5, #1
 8005854:	2b01      	cmp	r3, #1
 8005856:	d811      	bhi.n	800587c <FLASH_WaitForLastOperation.constprop.3+0x34>

  /* Select bsyflag depending on Bank */
  if(Bank == FLASH_BANK_1)
 8005858:	2d01      	cmp	r5, #1
 800585a:	d117      	bne.n	800588c <FLASH_WaitForLastOperation.constprop.3+0x44>
  else
  {
    bsyflag = FLASH_FLAG_QW_BANK2;
  }

  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800585c:	f44f 5400 	mov.w	r4, #8192	; 0x2000
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8005860:	f24c 3550 	movw	r5, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005864:	f2c5 2400 	movt	r4, #20992	; 0x5200
 8005868:	6923      	ldr	r3, [r4, #16]
 800586a:	075b      	lsls	r3, r3, #29
 800586c:	d548      	bpl.n	8005900 <FLASH_WaitForLastOperation.constprop.3+0xb8>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 800586e:	f7fb f8e5 	bl	8000a3c <HAL_GetTick>
 8005872:	1b80      	subs	r0, r0, r6
 8005874:	42a8      	cmp	r0, r5
 8005876:	d9f7      	bls.n	8005868 <FLASH_WaitForLastOperation.constprop.3+0x20>
      {
        return HAL_TIMEOUT;
 8005878:	2003      	movs	r0, #3
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
    }
  }

  return HAL_OK;
}
 800587a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 800587c:	f64d 2074 	movw	r0, #55924	; 0xda74
 8005880:	f240 3192 	movw	r1, #914	; 0x392
 8005884:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005888:	f00f ffee 	bl	8015868 <assert_failed>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 800588c:	f44f 5400 	mov.w	r4, #8192	; 0x2000
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8005890:	f24c 3750 	movw	r7, #50000	; 0xc350
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005894:	f2c5 2400 	movt	r4, #20992	; 0x5200
 8005898:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 800589c:	075a      	lsls	r2, r3, #29
 800589e:	d508      	bpl.n	80058b2 <FLASH_WaitForLastOperation.constprop.3+0x6a>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 80058a0:	f7fb f8cc 	bl	8000a3c <HAL_GetTick>
 80058a4:	1b80      	subs	r0, r0, r6
 80058a6:	42b8      	cmp	r0, r7
 80058a8:	d8e6      	bhi.n	8005878 <FLASH_WaitForLastOperation.constprop.3+0x30>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 80058aa:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 80058ae:	075a      	lsls	r2, r3, #29
 80058b0:	d4f6      	bmi.n	80058a0 <FLASH_WaitForLastOperation.constprop.3+0x58>
  if (Bank == FLASH_BANK_1)
 80058b2:	2d01      	cmp	r5, #1
 80058b4:	d024      	beq.n	8005900 <FLASH_WaitForLastOperation.constprop.3+0xb8>
  if((errorflag & 0x7DFFFFFFU) != 0U)
 80058b6:	2300      	movs	r3, #0
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 80058b8:	f8d4 2110 	ldr.w	r2, [r4, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
 80058bc:	f2c1 53ee 	movt	r3, #5614	; 0x15ee
 80058c0:	ea12 0003 	ands.w	r0, r2, r3
 80058c4:	d010      	beq.n	80058e8 <FLASH_WaitForLastOperation.constprop.3+0xa0>
    pFlash.ErrorCode |= errorflag;
 80058c6:	f240 6164 	movw	r1, #1636	; 0x664
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 80058ca:	2500      	movs	r5, #0
    return HAL_ERROR;
 80058cc:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
 80058ce:	f2c2 0100 	movt	r1, #8192	; 0x2000
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 80058d2:	f2c1 75ee 	movt	r5, #6126	; 0x17ee
    pFlash.ErrorCode |= errorflag;
 80058d6:	698b      	ldr	r3, [r1, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 80058d8:	402a      	ands	r2, r5
    pFlash.ErrorCode |= errorflag;
 80058da:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80058de:	4313      	orrs	r3, r2
 80058e0:	618b      	str	r3, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 80058e2:	f8c4 2114 	str.w	r2, [r4, #276]	; 0x114
}
 80058e6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 80058e8:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
 80058ec:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 80058f0:	d004      	beq.n	80058fc <FLASH_WaitForLastOperation.constprop.3+0xb4>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 80058f2:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80058f6:	f8c4 3114 	str.w	r3, [r4, #276]	; 0x114
}
 80058fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  return HAL_OK;
 80058fc:	4618      	mov	r0, r3
}
 80058fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005900:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005904:	2000      	movs	r0, #0
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005906:	f2c5 2200 	movt	r2, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
 800590a:	f2c1 50ee 	movt	r0, #5614	; 0x15ee
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 800590e:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005910:	4018      	ands	r0, r3
 8005912:	d107      	bne.n	8005924 <FLASH_WaitForLastOperation.constprop.3+0xdc>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 8005914:	6913      	ldr	r3, [r2, #16]
 8005916:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 800591a:	d0ef      	beq.n	80058fc <FLASH_WaitForLastOperation.constprop.3+0xb4>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 800591c:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005920:	6153      	str	r3, [r2, #20]
}
 8005922:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005924:	2400      	movs	r4, #0
    pFlash.ErrorCode |= errorflag;
 8005926:	f240 6164 	movw	r1, #1636	; 0x664
    return HAL_ERROR;
 800592a:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
 800592c:	f2c2 0100 	movt	r1, #8192	; 0x2000
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005930:	f2c1 74ee 	movt	r4, #6126	; 0x17ee
 8005934:	4023      	ands	r3, r4
    pFlash.ErrorCode |= errorflag;
 8005936:	698c      	ldr	r4, [r1, #24]
 8005938:	431c      	orrs	r4, r3
 800593a:	618c      	str	r4, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 800593c:	6153      	str	r3, [r2, #20]
}
 800593e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005940 <HAL_FLASH_Program>:
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
 8005940:	2801      	cmp	r0, #1
{
 8005942:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005946:	460d      	mov	r5, r1
 8005948:	4616      	mov	r6, r2
  assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
 800594a:	d006      	beq.n	800595a <HAL_FLASH_Program+0x1a>
 800594c:	f64d 2074 	movw	r0, #55924	; 0xda74
 8005950:	219b      	movs	r1, #155	; 0x9b
 8005952:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005956:	f00f ff87 	bl	8015868 <assert_failed>
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
 800595a:	f105 4778 	add.w	r7, r5, #4160749568	; 0xf8000000
 800595e:	f5b7 1f00 	cmp.w	r7, #2097152	; 0x200000
 8005962:	d25c      	bcs.n	8005a1e <HAL_FLASH_Program+0xde>
  __HAL_LOCK(&pFlash);
 8005964:	f240 6464 	movw	r4, #1636	; 0x664
 8005968:	f2c2 0400 	movt	r4, #8192	; 0x2000
 800596c:	7d23      	ldrb	r3, [r4, #20]
 800596e:	2b01      	cmp	r3, #1
 8005970:	d063      	beq.n	8005a3a <HAL_FLASH_Program+0xfa>
 8005972:	f04f 0801 	mov.w	r8, #1
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 8005976:	f5b7 1f80 	cmp.w	r7, #1048576	; 0x100000
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800597a:	f04f 0300 	mov.w	r3, #0
  __HAL_LOCK(&pFlash);
 800597e:	f884 8014 	strb.w	r8, [r4, #20]
  if(IS_FLASH_PROGRAM_ADDRESS_BANK1(FlashAddress))
 8005982:	d33d      	bcc.n	8005a00 <HAL_FLASH_Program+0xc0>
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8005984:	2002      	movs	r0, #2
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005986:	61a3      	str	r3, [r4, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8005988:	f7ff ff5e 	bl	8005848 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
 800598c:	2800      	cmp	r0, #0
 800598e:	d133      	bne.n	80059f8 <HAL_FLASH_Program+0xb8>
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 8005990:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    bank = FLASH_BANK_2;
 8005994:	f04f 0802 	mov.w	r8, #2
      SET_BIT(FLASH->CR2, FLASH_CR_PG);
 8005998:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800599c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 80059a0:	ea42 0208 	orr.w	r2, r2, r8
 80059a4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
 80059a8:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 80059ac:	f3bf 8f4f 	dsb	sy
        *dest_addr = *src_addr;
 80059b0:	6833      	ldr	r3, [r6, #0]
 80059b2:	602b      	str	r3, [r5, #0]
 80059b4:	6873      	ldr	r3, [r6, #4]
 80059b6:	606b      	str	r3, [r5, #4]
 80059b8:	68b3      	ldr	r3, [r6, #8]
 80059ba:	60ab      	str	r3, [r5, #8]
 80059bc:	68f3      	ldr	r3, [r6, #12]
 80059be:	60eb      	str	r3, [r5, #12]
 80059c0:	6933      	ldr	r3, [r6, #16]
 80059c2:	612b      	str	r3, [r5, #16]
 80059c4:	6973      	ldr	r3, [r6, #20]
 80059c6:	616b      	str	r3, [r5, #20]
 80059c8:	69b3      	ldr	r3, [r6, #24]
 80059ca:	61ab      	str	r3, [r5, #24]
 80059cc:	69f3      	ldr	r3, [r6, #28]
 80059ce:	61eb      	str	r3, [r5, #28]
  __ASM volatile ("isb 0xF":::"memory");
 80059d0:	f3bf 8f6f 	isb	sy
  __ASM volatile ("dsb 0xF":::"memory");
 80059d4:	f3bf 8f4f 	dsb	sy
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 80059d8:	4640      	mov	r0, r8
 80059da:	f7ff ff35 	bl	8005848 <FLASH_WaitForLastOperation.constprop.3>
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 80059de:	f44f 5300 	mov.w	r3, #8192	; 0x2000
      if(bank == FLASH_BANK_1)
 80059e2:	f1b8 0f01 	cmp.w	r8, #1
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 80059e6:	f2c5 2300 	movt	r3, #20992	; 0x5200
      if(bank == FLASH_BANK_1)
 80059ea:	d029      	beq.n	8005a40 <HAL_FLASH_Program+0x100>
        CLEAR_BIT(FLASH->CR2, FLASH_CR_PG);
 80059ec:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 80059f0:	f022 0202 	bic.w	r2, r2, #2
 80059f4:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
  __HAL_UNLOCK(&pFlash);
 80059f8:	2300      	movs	r3, #0
 80059fa:	7523      	strb	r3, [r4, #20]
}
 80059fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8005a00:	4640      	mov	r0, r8
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005a02:	61a3      	str	r3, [r4, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, bank);
 8005a04:	f7ff ff20 	bl	8005848 <FLASH_WaitForLastOperation.constprop.3>
  if(status == HAL_OK)
 8005a08:	2800      	cmp	r0, #0
 8005a0a:	d1f5      	bne.n	80059f8 <HAL_FLASH_Program+0xb8>
        SET_BIT(FLASH->CR1, FLASH_CR_PG);
 8005a0c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005a10:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005a14:	68da      	ldr	r2, [r3, #12]
 8005a16:	f042 0202 	orr.w	r2, r2, #2
 8005a1a:	60da      	str	r2, [r3, #12]
 8005a1c:	e7c4      	b.n	80059a8 <HAL_FLASH_Program+0x68>
  __HAL_LOCK(&pFlash);
 8005a1e:	f240 6464 	movw	r4, #1636	; 0x664
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
 8005a22:	f64d 2074 	movw	r0, #55924	; 0xda74
 8005a26:	219c      	movs	r1, #156	; 0x9c
  __HAL_LOCK(&pFlash);
 8005a28:	f2c2 0400 	movt	r4, #8192	; 0x2000
  assert_param(IS_FLASH_PROGRAM_ADDRESS(FlashAddress));
 8005a2c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005a30:	f00f ff1a 	bl	8015868 <assert_failed>
  __HAL_LOCK(&pFlash);
 8005a34:	7d23      	ldrb	r3, [r4, #20]
 8005a36:	2b01      	cmp	r3, #1
 8005a38:	d19b      	bne.n	8005972 <HAL_FLASH_Program+0x32>
 8005a3a:	2002      	movs	r0, #2
}
 8005a3c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        CLEAR_BIT(FLASH->CR1, FLASH_CR_PG);
 8005a40:	68da      	ldr	r2, [r3, #12]
 8005a42:	f022 0202 	bic.w	r2, r2, #2
 8005a46:	60da      	str	r2, [r3, #12]
 8005a48:	e7d6      	b.n	80059f8 <HAL_FLASH_Program+0xb8>
 8005a4a:	bf00      	nop

08005a4c <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 8005a4c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005a50:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005a54:	68da      	ldr	r2, [r3, #12]
 8005a56:	07d2      	lsls	r2, r2, #31
 8005a58:	d50c      	bpl.n	8005a74 <HAL_FLASH_Unlock+0x28>
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 8005a5a:	f240 1123 	movw	r1, #291	; 0x123
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 8005a5e:	f648 12ab 	movw	r2, #35243	; 0x89ab
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 8005a62:	f2c4 5167 	movt	r1, #17767	; 0x4567
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 8005a66:	f6cc 52ef 	movt	r2, #52719	; 0xcdef
    WRITE_REG(FLASH->KEYR1, FLASH_KEY1);
 8005a6a:	6059      	str	r1, [r3, #4]
    WRITE_REG(FLASH->KEYR1, FLASH_KEY2);
 8005a6c:	605a      	str	r2, [r3, #4]
    if (READ_BIT(FLASH->CR1, FLASH_CR_LOCK) != 0U)
 8005a6e:	68db      	ldr	r3, [r3, #12]
 8005a70:	07db      	lsls	r3, r3, #31
 8005a72:	d41a      	bmi.n	8005aaa <HAL_FLASH_Unlock+0x5e>
  if(READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 8005a74:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005a78:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005a7c:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
 8005a80:	f010 0001 	ands.w	r0, r0, #1
 8005a84:	d010      	beq.n	8005aa8 <HAL_FLASH_Unlock+0x5c>
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 8005a86:	f240 1123 	movw	r1, #291	; 0x123
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 8005a8a:	f648 12ab 	movw	r2, #35243	; 0x89ab
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 8005a8e:	f2c4 5167 	movt	r1, #17767	; 0x4567
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 8005a92:	f6cc 52ef 	movt	r2, #52719	; 0xcdef
    WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
 8005a96:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
    WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
 8005a9a:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    if (READ_BIT(FLASH->CR2, FLASH_CR_LOCK) != 0U)
 8005a9e:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
      return HAL_ERROR;
 8005aa2:	f000 0001 	and.w	r0, r0, #1
 8005aa6:	4770      	bx	lr
 8005aa8:	4770      	bx	lr
 8005aaa:	2001      	movs	r0, #1
}
 8005aac:	4770      	bx	lr
 8005aae:	bf00      	nop

08005ab0 <FLASH_WaitForLastOperation>:
{
 8005ab0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005ab4:	460d      	mov	r5, r1
 8005ab6:	4606      	mov	r6, r0
  uint32_t tickstart = HAL_GetTick();
 8005ab8:	f7fa ffc0 	bl	8000a3c <HAL_GetTick>
 8005abc:	4680      	mov	r8, r0
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8005abe:	1e6b      	subs	r3, r5, #1
 8005ac0:	2b01      	cmp	r3, #1
 8005ac2:	d872      	bhi.n	8005baa <FLASH_WaitForLastOperation+0xfa>
    bsyflag = FLASH_FLAG_QW_BANK2;
 8005ac4:	2404      	movs	r4, #4
 8005ac6:	2d01      	cmp	r5, #1
 8005ac8:	f2c8 0400 	movt	r4, #32768	; 0x8000
 8005acc:	bf08      	it	eq
 8005ace:	2404      	moveq	r4, #4
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005ad0:	f44f 5700 	mov.w	r7, #8192	; 0x2000
 8005ad4:	f2c5 2700 	movt	r7, #20992	; 0x5200
 8005ad8:	2c04      	cmp	r4, #4
 8005ada:	d03b      	beq.n	8005b54 <FLASH_WaitForLastOperation+0xa4>
 8005adc:	1c70      	adds	r0, r6, #1
 8005ade:	d129      	bne.n	8005b34 <FLASH_WaitForLastOperation+0x84>
 8005ae0:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8005ae4:	f2c5 2200 	movt	r2, #20992	; 0x5200
 8005ae8:	f8d2 3110 	ldr.w	r3, [r2, #272]	; 0x110
 8005aec:	ea24 0303 	bic.w	r3, r4, r3
 8005af0:	0759      	lsls	r1, r3, #29
 8005af2:	d5f9      	bpl.n	8005ae8 <FLASH_WaitForLastOperation+0x38>
  if (Bank == FLASH_BANK_1)
 8005af4:	2d01      	cmp	r5, #1
 8005af6:	d038      	beq.n	8005b6a <FLASH_WaitForLastOperation+0xba>
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005af8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005afc:	2300      	movs	r3, #0
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005afe:	f2c5 2100 	movt	r1, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005b02:	f2c1 53ee 	movt	r3, #5614	; 0x15ee
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005b06:	f8d1 2110 	ldr.w	r2, [r1, #272]	; 0x110
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005b0a:	ea12 0003 	ands.w	r0, r2, r3
 8005b0e:	d03e      	beq.n	8005b8e <FLASH_WaitForLastOperation+0xde>
    pFlash.ErrorCode |= errorflag;
 8005b10:	f240 6464 	movw	r4, #1636	; 0x664
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005b14:	2500      	movs	r5, #0
    return HAL_ERROR;
 8005b16:	2001      	movs	r0, #1
    pFlash.ErrorCode |= errorflag;
 8005b18:	f2c2 0400 	movt	r4, #8192	; 0x2000
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005b1c:	f2c1 75ee 	movt	r5, #6126	; 0x17ee
    pFlash.ErrorCode |= errorflag;
 8005b20:	69a3      	ldr	r3, [r4, #24]
    errorflag = (FLASH->SR2 & FLASH_FLAG_ALL_ERRORS_BANK2) | 0x80000000U;
 8005b22:	402a      	ands	r2, r5
    pFlash.ErrorCode |= errorflag;
 8005b24:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8005b28:	4313      	orrs	r3, r2
 8005b2a:	61a3      	str	r3, [r4, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8005b2c:	f8c1 2114 	str.w	r2, [r1, #276]	; 0x114
}
 8005b30:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005b34:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8005b38:	ea24 0303 	bic.w	r3, r4, r3
 8005b3c:	075b      	lsls	r3, r3, #29
 8005b3e:	d4d9      	bmi.n	8005af4 <FLASH_WaitForLastOperation+0x44>
      if(((HAL_GetTick() - tickstart) > Timeout) || (Timeout == 0U))
 8005b40:	f7fa ff7c 	bl	8000a3c <HAL_GetTick>
 8005b44:	eba0 0008 	sub.w	r0, r0, r8
 8005b48:	42b0      	cmp	r0, r6
 8005b4a:	d801      	bhi.n	8005b50 <FLASH_WaitForLastOperation+0xa0>
 8005b4c:	2e00      	cmp	r6, #0
 8005b4e:	d1c3      	bne.n	8005ad8 <FLASH_WaitForLastOperation+0x28>
        return HAL_TIMEOUT;
 8005b50:	2003      	movs	r0, #3
 8005b52:	e7ed      	b.n	8005b30 <FLASH_WaitForLastOperation+0x80>
 8005b54:	1c70      	adds	r0, r6, #1
 8005b56:	d134      	bne.n	8005bc2 <FLASH_WaitForLastOperation+0x112>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005b58:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8005b5c:	f2c5 2200 	movt	r2, #20992	; 0x5200
 8005b60:	6913      	ldr	r3, [r2, #16]
 8005b62:	0759      	lsls	r1, r3, #29
 8005b64:	d4fc      	bmi.n	8005b60 <FLASH_WaitForLastOperation+0xb0>
  if (Bank == FLASH_BANK_1)
 8005b66:	2d01      	cmp	r5, #1
 8005b68:	d1c6      	bne.n	8005af8 <FLASH_WaitForLastOperation+0x48>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005b6a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005b6e:	2000      	movs	r0, #0
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005b70:	f2c5 2200 	movt	r2, #20992	; 0x5200
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005b74:	f2c1 50ee 	movt	r0, #5614	; 0x15ee
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005b78:	6913      	ldr	r3, [r2, #16]
  if((errorflag & 0x7DFFFFFFU) != 0U)
 8005b7a:	4018      	ands	r0, r3
 8005b7c:	d125      	bne.n	8005bca <FLASH_WaitForLastOperation+0x11a>
    if (__HAL_FLASH_GET_FLAG_BANK1(FLASH_FLAG_EOP_BANK1))
 8005b7e:	6915      	ldr	r5, [r2, #16]
 8005b80:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
 8005b84:	d00e      	beq.n	8005ba4 <FLASH_WaitForLastOperation+0xf4>
      __HAL_FLASH_CLEAR_FLAG_BANK1(FLASH_FLAG_EOP_BANK1);
 8005b86:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b8a:	6153      	str	r3, [r2, #20]
 8005b8c:	e7d0      	b.n	8005b30 <FLASH_WaitForLastOperation+0x80>
    if (__HAL_FLASH_GET_FLAG_BANK2(FLASH_FLAG_EOP_BANK2))
 8005b8e:	f8d1 5110 	ldr.w	r5, [r1, #272]	; 0x110
 8005b92:	f415 3580 	ands.w	r5, r5, #65536	; 0x10000
 8005b96:	d005      	beq.n	8005ba4 <FLASH_WaitForLastOperation+0xf4>
      __HAL_FLASH_CLEAR_FLAG_BANK2(FLASH_FLAG_EOP_BANK2);
 8005b98:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8005b9c:	f8c1 3114 	str.w	r3, [r1, #276]	; 0x114
}
 8005ba0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  return HAL_OK;
 8005ba4:	4628      	mov	r0, r5
}
 8005ba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8005baa:	f64d 2074 	movw	r0, #55924	; 0xda74
    bsyflag = FLASH_FLAG_QW_BANK2;
 8005bae:	2404      	movs	r4, #4
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8005bb0:	f240 3192 	movw	r1, #914	; 0x392
 8005bb4:	f6c0 0002 	movt	r0, #2050	; 0x802
    bsyflag = FLASH_FLAG_QW_BANK2;
 8005bb8:	f2c8 0400 	movt	r4, #32768	; 0x8000
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Bank));
 8005bbc:	f00f fe54 	bl	8015868 <assert_failed>
 8005bc0:	e786      	b.n	8005ad0 <FLASH_WaitForLastOperation+0x20>
  while(__HAL_FLASH_GET_FLAG(bsyflag))
 8005bc2:	693b      	ldr	r3, [r7, #16]
 8005bc4:	075b      	lsls	r3, r3, #29
 8005bc6:	d4bb      	bmi.n	8005b40 <FLASH_WaitForLastOperation+0x90>
 8005bc8:	e794      	b.n	8005af4 <FLASH_WaitForLastOperation+0x44>
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005bca:	2400      	movs	r4, #0
    pFlash.ErrorCode |= errorflag;
 8005bcc:	f240 6164 	movw	r1, #1636	; 0x664
    return HAL_ERROR;
 8005bd0:	4628      	mov	r0, r5
    pFlash.ErrorCode |= errorflag;
 8005bd2:	f2c2 0100 	movt	r1, #8192	; 0x2000
    errorflag = FLASH->SR1 & FLASH_FLAG_ALL_ERRORS_BANK1;
 8005bd6:	f2c1 74ee 	movt	r4, #6126	; 0x17ee
 8005bda:	4023      	ands	r3, r4
    pFlash.ErrorCode |= errorflag;
 8005bdc:	698c      	ldr	r4, [r1, #24]
 8005bde:	431c      	orrs	r4, r3
 8005be0:	618c      	str	r4, [r1, #24]
    __HAL_FLASH_CLEAR_FLAG(errorflag);
 8005be2:	6153      	str	r3, [r2, #20]
}
 8005be4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08005be8 <FLASH_MassErase>:
  *            @arg FLASH_BANK_BOTH: Bank1 and Bank2 to be erased
  *
  * @retval HAL Status
  */
static void FLASH_MassErase(uint32_t VoltageRange, uint32_t Banks)
{
 8005be8:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
#if defined (FLASH_CR_PSIZE)
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8005bea:	f030 0330 	bics.w	r3, r0, #48	; 0x30
{
 8005bee:	4605      	mov	r5, r0
 8005bf0:	460c      	mov	r4, r1
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8005bf2:	d007      	beq.n	8005c04 <FLASH_MassErase+0x1c>
 8005bf4:	f64d 20b0 	movw	r0, #55984	; 0xdab0
 8005bf8:	f44f 7144 	mov.w	r1, #784	; 0x310
 8005bfc:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005c00:	f00f fe32 	bl	8015868 <assert_failed>
#else
  UNUSED(VoltageRange);
#endif /* FLASH_CR_PSIZE */
  assert_param(IS_FLASH_BANK(Banks));
 8005c04:	1e63      	subs	r3, r4, #1
 8005c06:	2b02      	cmp	r3, #2
 8005c08:	d82c      	bhi.n	8005c64 <FLASH_MassErase+0x7c>

  /* Flash Mass Erase */
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 8005c0a:	f004 0303 	and.w	r3, r4, #3
 8005c0e:	2b03      	cmp	r3, #3
 8005c10:	d034      	beq.n	8005c7c <FLASH_MassErase+0x94>
    FLASH->OPTCR |= FLASH_OPTCR_MER;
  }
  else
  {
    /* Proceed to erase Flash Bank  */
    if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005c12:	07e2      	lsls	r2, r4, #31
 8005c14:	d50e      	bpl.n	8005c34 <FLASH_MassErase+0x4c>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank1 */
      FLASH->CR1 &= (~FLASH_CR_PSIZE);
 8005c16:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005c1a:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005c1e:	68da      	ldr	r2, [r3, #12]
 8005c20:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8005c24:	60da      	str	r2, [r3, #12]
      FLASH->CR1 |=  VoltageRange;
 8005c26:	68da      	ldr	r2, [r3, #12]
 8005c28:	432a      	orrs	r2, r5
 8005c2a:	60da      	str	r2, [r3, #12]
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank1 */
      FLASH->CR1 |= (FLASH_CR_BER | FLASH_CR_START);
 8005c2c:	68da      	ldr	r2, [r3, #12]
 8005c2e:	f042 0288 	orr.w	r2, r2, #136	; 0x88
 8005c32:	60da      	str	r2, [r3, #12]
    }
    if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005c34:	07a3      	lsls	r3, r4, #30
 8005c36:	d514      	bpl.n	8005c62 <FLASH_MassErase+0x7a>
    {
#if defined (FLASH_CR_PSIZE)
      /* Set Program/erase VoltageRange for Bank2 */
      FLASH->CR2 &= (~FLASH_CR_PSIZE);
 8005c38:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005c3c:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005c40:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8005c44:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8005c48:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
      FLASH->CR2 |= VoltageRange;
 8005c4c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8005c50:	4315      	orrs	r5, r2
 8005c52:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
#endif /* FLASH_CR_PSIZE */

      /* Erase Bank2 */
      FLASH->CR2 |= (FLASH_CR_BER | FLASH_CR_START);
 8005c56:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8005c5a:	f042 0288 	orr.w	r2, r2, #136	; 0x88
 8005c5e:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    }
  }
}
 8005c62:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_FLASH_BANK(Banks));
 8005c64:	f64d 20b0 	movw	r0, #55984	; 0xdab0
 8005c68:	f44f 7145 	mov.w	r1, #788	; 0x314
 8005c6c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005c70:	f00f fdfa 	bl	8015868 <assert_failed>
  if((Banks & FLASH_BANK_BOTH) == FLASH_BANK_BOTH)
 8005c74:	f004 0303 	and.w	r3, r4, #3
 8005c78:	2b03      	cmp	r3, #3
 8005c7a:	d1ca      	bne.n	8005c12 <FLASH_MassErase+0x2a>
    FLASH->CR1 &= (~FLASH_CR_PSIZE);
 8005c7c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8005c80:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8005c84:	68da      	ldr	r2, [r3, #12]
 8005c86:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8005c8a:	60da      	str	r2, [r3, #12]
    FLASH->CR2 &= (~FLASH_CR_PSIZE);
 8005c8c:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8005c90:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8005c94:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
    FLASH->CR1 |= VoltageRange;
 8005c98:	68da      	ldr	r2, [r3, #12]
 8005c9a:	432a      	orrs	r2, r5
 8005c9c:	60da      	str	r2, [r3, #12]
    FLASH->CR2 |= VoltageRange;
 8005c9e:	f8d3 210c 	ldr.w	r2, [r3, #268]	; 0x10c
 8005ca2:	4315      	orrs	r5, r2
 8005ca4:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
    FLASH->OPTCR |= FLASH_OPTCR_MER;
 8005ca8:	699a      	ldr	r2, [r3, #24]
 8005caa:	f042 0210 	orr.w	r2, r2, #16
 8005cae:	619a      	str	r2, [r3, #24]
}
 8005cb0:	bd38      	pop	{r3, r4, r5, pc}
 8005cb2:	bf00      	nop

08005cb4 <HAL_FLASHEx_Erase>:
{
 8005cb4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8005cb8:	6803      	ldr	r3, [r0, #0]
{
 8005cba:	b083      	sub	sp, #12
 8005cbc:	4604      	mov	r4, r0
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8005cbe:	2b01      	cmp	r3, #1
{
 8005cc0:	9100      	str	r1, [sp, #0]
  assert_param(IS_FLASH_TYPEERASE(pEraseInit->TypeErase));
 8005cc2:	d906      	bls.n	8005cd2 <HAL_FLASHEx_Erase+0x1e>
 8005cc4:	f64d 20b0 	movw	r0, #55984	; 0xdab0
 8005cc8:	21ac      	movs	r1, #172	; 0xac
 8005cca:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005cce:	f00f fdcb 	bl	8015868 <assert_failed>
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
 8005cd2:	6863      	ldr	r3, [r4, #4]
 8005cd4:	3b01      	subs	r3, #1
 8005cd6:	2b02      	cmp	r3, #2
 8005cd8:	f200 80a8 	bhi.w	8005e2c <HAL_FLASHEx_Erase+0x178>
  __HAL_LOCK(&pFlash);
 8005cdc:	f240 6764 	movw	r7, #1636	; 0x664
 8005ce0:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8005ce4:	7d3b      	ldrb	r3, [r7, #20]
 8005ce6:	2b01      	cmp	r3, #1
 8005ce8:	f000 80af 	beq.w	8005e4a <HAL_FLASHEx_Erase+0x196>
 8005cec:	2501      	movs	r5, #1
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005cee:	2300      	movs	r3, #0
  __HAL_LOCK(&pFlash);
 8005cf0:	753d      	strb	r5, [r7, #20]
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8005cf2:	61bb      	str	r3, [r7, #24]
  if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005cf4:	6862      	ldr	r2, [r4, #4]
 8005cf6:	07d0      	lsls	r0, r2, #31
 8005cf8:	f100 80ac 	bmi.w	8005e54 <HAL_FLASHEx_Erase+0x1a0>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005cfc:	0793      	lsls	r3, r2, #30
 8005cfe:	d50c      	bpl.n	8005d1a <HAL_FLASHEx_Erase+0x66>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005d00:	2102      	movs	r1, #2
 8005d02:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005d06:	f7ff fed3 	bl	8005ab0 <FLASH_WaitForLastOperation>
  if(status == HAL_OK)
 8005d0a:	b130      	cbz	r0, 8005d1a <HAL_FLASHEx_Erase+0x66>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005d0c:	2301      	movs	r3, #1
  __HAL_UNLOCK(&pFlash);
 8005d0e:	2200      	movs	r2, #0
}
 8005d10:	4618      	mov	r0, r3
  __HAL_UNLOCK(&pFlash);
 8005d12:	753a      	strb	r2, [r7, #20]
}
 8005d14:	b003      	add	sp, #12
 8005d16:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8005d1a:	6825      	ldr	r5, [r4, #0]
 8005d1c:	2d01      	cmp	r5, #1
 8005d1e:	f000 80af 	beq.w	8005e80 <HAL_FLASHEx_Erase+0x1cc>
      *SectorError = 0xFFFFFFFFU;
 8005d22:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8005d26:	9a00      	ldr	r2, [sp, #0]
 8005d28:	6013      	str	r3, [r2, #0]
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 8005d2a:	e9d4 6302 	ldrd	r6, r3, [r4, #8]
 8005d2e:	4433      	add	r3, r6
 8005d30:	42b3      	cmp	r3, r6
 8005d32:	f240 80a3 	bls.w	8005e7c <HAL_FLASHEx_Erase+0x1c8>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005d36:	f64f 03fb 	movw	r3, #63739	; 0xf8fb
  *
  * @retval None
  */
void FLASH_Erase_Sector(uint32_t Sector, uint32_t Banks, uint32_t VoltageRange)
{
  assert_param(IS_FLASH_SECTOR(Sector));
 8005d3a:	f64d 29b0 	movw	r9, #55984	; 0xdab0

  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank1 */
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 8005d3e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 8005d42:	ea4f 2806 	mov.w	r8, r6, lsl #8
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005d46:	f6cf 73ff 	movt	r3, #65535	; 0xffff
  assert_param(IS_FLASH_SECTOR(Sector));
 8005d4a:	f6c0 0902 	movt	r9, #2050	; 0x802
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 8005d4e:	f2c5 2500 	movt	r5, #20992	; 0x5200
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005d52:	9301      	str	r3, [sp, #4]
 8005d54:	e03f      	b.n	8005dd6 <HAL_FLASHEx_Erase+0x122>
  assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));
 8005d56:	f10a 31ff 	add.w	r1, sl, #4294967295	; 0xffffffff
 8005d5a:	2901      	cmp	r1, #1
 8005d5c:	d904      	bls.n	8005d68 <HAL_FLASHEx_Erase+0xb4>
 8005d5e:	f240 3157 	movw	r1, #855	; 0x357
 8005d62:	4648      	mov	r0, r9
 8005d64:	f00f fd80 	bl	8015868 <assert_failed>
  assert_param(IS_VOLTAGERANGE(VoltageRange));
 8005d68:	f03b 0330 	bics.w	r3, fp, #48	; 0x30
 8005d6c:	d004      	beq.n	8005d78 <HAL_FLASHEx_Erase+0xc4>
 8005d6e:	f240 3159 	movw	r1, #857	; 0x359
 8005d72:	4648      	mov	r0, r9
 8005d74:	f00f fd78 	bl	8015868 <assert_failed>
  if((Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005d78:	f01a 0f01 	tst.w	sl, #1
 8005d7c:	d00b      	beq.n	8005d96 <HAL_FLASHEx_Erase+0xe2>
    FLASH->CR1 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 8005d7e:	68e9      	ldr	r1, [r5, #12]
 8005d80:	f421 61e6 	bic.w	r1, r1, #1840	; 0x730
 8005d84:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | VoltageRange | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 8005d86:	68e9      	ldr	r1, [r5, #12]
 8005d88:	f041 0184 	orr.w	r1, r1, #132	; 0x84
 8005d8c:	ea41 010b 	orr.w	r1, r1, fp
 8005d90:	ea41 0108 	orr.w	r1, r1, r8
 8005d94:	60e9      	str	r1, [r5, #12]

    FLASH->CR1 |= (FLASH_CR_SER | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
#endif /* FLASH_CR_PSIZE */
  }

  if((Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005d96:	f01a 0f02 	tst.w	sl, #2
 8005d9a:	d00f      	beq.n	8005dbc <HAL_FLASHEx_Erase+0x108>
  {
#if defined (FLASH_CR_PSIZE)
    /* Reset Program/erase VoltageRange and Sector Number for Bank2 */
    FLASH->CR2 &= ~(FLASH_CR_PSIZE | FLASH_CR_SNB);
 8005d9c:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
 8005da0:	f423 63e6 	bic.w	r3, r3, #1840	; 0x730
 8005da4:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c

    FLASH->CR2 |= (FLASH_CR_SER | VoltageRange  | (Sector << FLASH_CR_SNB_Pos) | FLASH_CR_START);
 8005da8:	f8d5 310c 	ldr.w	r3, [r5, #268]	; 0x10c
 8005dac:	f043 0384 	orr.w	r3, r3, #132	; 0x84
 8005db0:	ea43 030b 	orr.w	r3, r3, fp
 8005db4:	ea43 0308 	orr.w	r3, r3, r8
 8005db8:	f8c5 310c 	str.w	r3, [r5, #268]	; 0x10c
        if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005dbc:	6863      	ldr	r3, [r4, #4]
 8005dbe:	07da      	lsls	r2, r3, #31
 8005dc0:	d415      	bmi.n	8005dee <HAL_FLASHEx_Erase+0x13a>
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005dc2:	0798      	lsls	r0, r3, #30
 8005dc4:	d425      	bmi.n	8005e12 <HAL_FLASHEx_Erase+0x15e>
      for(sector_index = pEraseInit->Sector; sector_index < (pEraseInit->NbSectors + pEraseInit->Sector); sector_index++)
 8005dc6:	68e3      	ldr	r3, [r4, #12]
 8005dc8:	3601      	adds	r6, #1
 8005dca:	68a2      	ldr	r2, [r4, #8]
 8005dcc:	f508 7880 	add.w	r8, r8, #256	; 0x100
 8005dd0:	4413      	add	r3, r2
 8005dd2:	42b3      	cmp	r3, r6
 8005dd4:	d952      	bls.n	8005e7c <HAL_FLASHEx_Erase+0x1c8>
  assert_param(IS_FLASH_SECTOR(Sector));
 8005dd6:	2e07      	cmp	r6, #7
        FLASH_Erase_Sector(sector_index, pEraseInit->Banks, pEraseInit->VoltageRange);
 8005dd8:	f8d4 a004 	ldr.w	sl, [r4, #4]
 8005ddc:	f8d4 b010 	ldr.w	fp, [r4, #16]
  assert_param(IS_FLASH_SECTOR(Sector));
 8005de0:	d9b9      	bls.n	8005d56 <HAL_FLASHEx_Erase+0xa2>
 8005de2:	f240 3156 	movw	r1, #854	; 0x356
 8005de6:	4648      	mov	r0, r9
 8005de8:	f00f fd3e 	bl	8015868 <assert_failed>
 8005dec:	e7b3      	b.n	8005d56 <HAL_FLASHEx_Erase+0xa2>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 8005dee:	2101      	movs	r1, #1
 8005df0:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005df4:	f7ff fe5c 	bl	8005ab0 <FLASH_WaitForLastOperation>
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005df8:	9901      	ldr	r1, [sp, #4]
 8005dfa:	68ea      	ldr	r2, [r5, #12]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1);
 8005dfc:	4603      	mov	r3, r0
          FLASH->CR1 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005dfe:	400a      	ands	r2, r1
 8005e00:	60ea      	str	r2, [r5, #12]
        if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005e02:	6862      	ldr	r2, [r4, #4]
 8005e04:	0791      	lsls	r1, r2, #30
 8005e06:	d404      	bmi.n	8005e12 <HAL_FLASHEx_Erase+0x15e>
        if(status != HAL_OK)
 8005e08:	2b00      	cmp	r3, #0
 8005e0a:	d0dc      	beq.n	8005dc6 <HAL_FLASHEx_Erase+0x112>
          *SectorError = sector_index;
 8005e0c:	9a00      	ldr	r2, [sp, #0]
 8005e0e:	6016      	str	r6, [r2, #0]
          break;
 8005e10:	e77d      	b.n	8005d0e <HAL_FLASHEx_Erase+0x5a>
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 8005e12:	2102      	movs	r1, #2
 8005e14:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005e18:	f7ff fe4a 	bl	8005ab0 <FLASH_WaitForLastOperation>
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005e1c:	f8d5 210c 	ldr.w	r2, [r5, #268]	; 0x10c
 8005e20:	9901      	ldr	r1, [sp, #4]
          status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2);
 8005e22:	4603      	mov	r3, r0
          FLASH->CR2 &= (~(FLASH_CR_SER | FLASH_CR_SNB));
 8005e24:	400a      	ands	r2, r1
 8005e26:	f8c5 210c 	str.w	r2, [r5, #268]	; 0x10c
 8005e2a:	e7ed      	b.n	8005e08 <HAL_FLASHEx_Erase+0x154>
  __HAL_LOCK(&pFlash);
 8005e2c:	f240 6764 	movw	r7, #1636	; 0x664
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
 8005e30:	f64d 20b0 	movw	r0, #55984	; 0xdab0
 8005e34:	21ad      	movs	r1, #173	; 0xad
  __HAL_LOCK(&pFlash);
 8005e36:	f2c2 0700 	movt	r7, #8192	; 0x2000
  assert_param(IS_FLASH_BANK(pEraseInit->Banks));
 8005e3a:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005e3e:	f00f fd13 	bl	8015868 <assert_failed>
  __HAL_LOCK(&pFlash);
 8005e42:	7d3b      	ldrb	r3, [r7, #20]
 8005e44:	2b01      	cmp	r3, #1
 8005e46:	f47f af51 	bne.w	8005cec <HAL_FLASHEx_Erase+0x38>
 8005e4a:	2302      	movs	r3, #2
}
 8005e4c:	4618      	mov	r0, r3
 8005e4e:	b003      	add	sp, #12
 8005e50:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 8005e54:	4629      	mov	r1, r5
 8005e56:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005e5a:	f7ff fe29 	bl	8005ab0 <FLASH_WaitForLastOperation>
 8005e5e:	b158      	cbz	r0, 8005e78 <HAL_FLASHEx_Erase+0x1c4>
  if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005e60:	6863      	ldr	r3, [r4, #4]
 8005e62:	079a      	lsls	r2, r3, #30
 8005e64:	f57f af52 	bpl.w	8005d0c <HAL_FLASHEx_Erase+0x58>
    if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005e68:	2102      	movs	r1, #2
 8005e6a:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005e6e:	9500      	str	r5, [sp, #0]
 8005e70:	f7ff fe1e 	bl	8005ab0 <FLASH_WaitForLastOperation>
 8005e74:	9b00      	ldr	r3, [sp, #0]
 8005e76:	e74a      	b.n	8005d0e <HAL_FLASHEx_Erase+0x5a>
 8005e78:	6862      	ldr	r2, [r4, #4]
 8005e7a:	e73f      	b.n	8005cfc <HAL_FLASHEx_Erase+0x48>
 8005e7c:	2300      	movs	r3, #0
 8005e7e:	e746      	b.n	8005d0e <HAL_FLASHEx_Erase+0x5a>
      FLASH_MassErase(pEraseInit->VoltageRange, pEraseInit->Banks);
 8005e80:	6861      	ldr	r1, [r4, #4]
 8005e82:	6920      	ldr	r0, [r4, #16]
 8005e84:	f7ff feb0 	bl	8005be8 <FLASH_MassErase>
      if((pEraseInit->Banks & FLASH_BANK_1) == FLASH_BANK_1)
 8005e88:	6862      	ldr	r2, [r4, #4]
 8005e8a:	f012 0301 	ands.w	r3, r2, #1
 8005e8e:	d117      	bne.n	8005ec0 <HAL_FLASHEx_Erase+0x20c>
      if((pEraseInit->Banks & FLASH_BANK_2) == FLASH_BANK_2)
 8005e90:	0791      	lsls	r1, r2, #30
 8005e92:	f57f af3c 	bpl.w	8005d0e <HAL_FLASHEx_Erase+0x5a>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_2) != HAL_OK)
 8005e96:	2102      	movs	r1, #2
 8005e98:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005e9c:	9300      	str	r3, [sp, #0]
 8005e9e:	f7ff fe07 	bl	8005ab0 <FLASH_WaitForLastOperation>
        FLASH->CR2 &= (~FLASH_CR_BER);
 8005ea2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
          status = HAL_ERROR;
 8005ea6:	2800      	cmp	r0, #0
 8005ea8:	9b00      	ldr	r3, [sp, #0]
        FLASH->CR2 &= (~FLASH_CR_BER);
 8005eaa:	f2c5 2200 	movt	r2, #20992	; 0x5200
          status = HAL_ERROR;
 8005eae:	bf18      	it	ne
 8005eb0:	2301      	movne	r3, #1
        FLASH->CR2 &= (~FLASH_CR_BER);
 8005eb2:	f8d2 110c 	ldr.w	r1, [r2, #268]	; 0x10c
 8005eb6:	f021 0108 	bic.w	r1, r1, #8
 8005eba:	f8c2 110c 	str.w	r1, [r2, #268]	; 0x10c
 8005ebe:	e726      	b.n	8005d0e <HAL_FLASHEx_Erase+0x5a>
        if(FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE, FLASH_BANK_1) != HAL_OK)
 8005ec0:	4629      	mov	r1, r5
 8005ec2:	f24c 3050 	movw	r0, #50000	; 0xc350
 8005ec6:	f7ff fdf3 	bl	8005ab0 <FLASH_WaitForLastOperation>
        FLASH->CR1 &= (~FLASH_CR_BER);
 8005eca:	f44f 5200 	mov.w	r2, #8192	; 0x2000
          status = HAL_ERROR;
 8005ece:	1c03      	adds	r3, r0, #0
        FLASH->CR1 &= (~FLASH_CR_BER);
 8005ed0:	f2c5 2200 	movt	r2, #20992	; 0x5200
          status = HAL_ERROR;
 8005ed4:	bf18      	it	ne
 8005ed6:	2301      	movne	r3, #1
        FLASH->CR1 &= (~FLASH_CR_BER);
 8005ed8:	68d1      	ldr	r1, [r2, #12]
 8005eda:	f021 0108 	bic.w	r1, r1, #8
 8005ede:	60d1      	str	r1, [r2, #12]
 8005ee0:	6862      	ldr	r2, [r4, #4]
 8005ee2:	e7d5      	b.n	8005e90 <HAL_FLASHEx_Erase+0x1dc>

08005ee4 <HAL_GPIO_Init>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8005ee4:	2200      	movs	r2, #0
 8005ee6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005eea:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8005eee:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005ef2:	4290      	cmp	r0, r2
 8005ef4:	bf18      	it	ne
 8005ef6:	4298      	cmpne	r0, r3
{
 8005ef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8005efc:	bf18      	it	ne
 8005efe:	2301      	movne	r3, #1
{
 8005f00:	b08b      	sub	sp, #44	; 0x2c
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8005f02:	bf08      	it	eq
 8005f04:	2300      	moveq	r3, #0
{
 8005f06:	4607      	mov	r7, r0
 8005f08:	4689      	mov	r9, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8005f0a:	9301      	str	r3, [sp, #4]
 8005f0c:	d03c      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f0e:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8005f12:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f16:	4298      	cmp	r0, r3
 8005f18:	d036      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f1a:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8005f1e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f22:	4298      	cmp	r0, r3
 8005f24:	d030      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f26:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8005f2a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f2e:	4298      	cmp	r0, r3
 8005f30:	d02a      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f32:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 8005f36:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f3a:	4298      	cmp	r0, r3
 8005f3c:	d024      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f3e:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8005f42:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f46:	4298      	cmp	r0, r3
 8005f48:	d01e      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f4a:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8005f4e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f52:	4298      	cmp	r0, r3
 8005f54:	d018      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f56:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8005f5a:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8005f5e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8005f62:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f66:	4290      	cmp	r0, r2
 8005f68:	bf18      	it	ne
 8005f6a:	4298      	cmpne	r0, r3
 8005f6c:	d00c      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f6e:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8005f72:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8005f76:	4298      	cmp	r0, r3
 8005f78:	d006      	beq.n	8005f88 <HAL_GPIO_Init+0xa4>
 8005f7a:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8005f7e:	21bb      	movs	r1, #187	; 0xbb
 8005f80:	f6c0 0002 	movt	r0, #2050	; 0x802
 8005f84:	f00f fc70 	bl	8015868 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 8005f88:	f8d9 2000 	ldr.w	r2, [r9]
 8005f8c:	b293      	uxth	r3, r2
 8005f8e:	2b00      	cmp	r3, #0
 8005f90:	f000 8184 	beq.w	800629c <HAL_GPIO_Init+0x3b8>
 8005f94:	2300      	movs	r3, #0
 8005f96:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 8005f9a:	4013      	ands	r3, r2
 8005f9c:	2b00      	cmp	r3, #0
 8005f9e:	f040 817d 	bne.w	800629c <HAL_GPIO_Init+0x3b8>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8005fa2:	2300      	movs	r3, #0
 8005fa4:	f8d9 2004 	ldr.w	r2, [r9, #4]
 8005fa8:	4618      	mov	r0, r3
 8005faa:	4619      	mov	r1, r3
 8005fac:	f2c1 1321 	movt	r3, #4385	; 0x1121
 8005fb0:	f1a2 0411 	sub.w	r4, r2, #17
 8005fb4:	f2c1 1022 	movt	r0, #4386	; 0x1122
 8005fb8:	f2c1 1111 	movt	r1, #4369	; 0x1111
 8005fbc:	429a      	cmp	r2, r3
 8005fbe:	bf18      	it	ne
 8005fc0:	2a03      	cmpne	r2, #3
 8005fc2:	bf8c      	ite	hi
 8005fc4:	2301      	movhi	r3, #1
 8005fc6:	2300      	movls	r3, #0
 8005fc8:	4282      	cmp	r2, r0
 8005fca:	bf0c      	ite	eq
 8005fcc:	2300      	moveq	r3, #0
 8005fce:	f003 0301 	andne.w	r3, r3, #1
 8005fd2:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8005fd6:	2c01      	cmp	r4, #1
 8005fd8:	bf94      	ite	ls
 8005fda:	2300      	movls	r3, #0
 8005fdc:	f003 0301 	andhi.w	r3, r3, #1
 8005fe0:	428a      	cmp	r2, r1
 8005fe2:	bf0c      	ite	eq
 8005fe4:	2300      	moveq	r3, #0
 8005fe6:	f003 0301 	andne.w	r3, r3, #1
 8005fea:	b12b      	cbz	r3, 8005ff8 <HAL_GPIO_Init+0x114>
 8005fec:	2300      	movs	r3, #0
 8005fee:	f2c1 1312 	movt	r3, #4370	; 0x1112
 8005ff2:	429a      	cmp	r2, r3
 8005ff4:	f040 81ae 	bne.w	8006354 <HAL_GPIO_Init+0x470>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8005ff8:	f8d9 3008 	ldr.w	r3, [r9, #8]
 8005ffc:	2b02      	cmp	r3, #2
 8005ffe:	f200 8188 	bhi.w	8006312 <HAL_GPIO_Init+0x42e>

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8006002:	f8d9 1000 	ldr.w	r1, [r9]
 8006006:	2900      	cmp	r1, #0
 8006008:	f000 8145 	beq.w	8006296 <HAL_GPIO_Init+0x3b2>

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800600c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8006010:	f44f 5810 	mov.w	r8, #9216	; 0x2400
 8006014:	f44f 5220 	mov.w	r2, #10240	; 0x2800
 8006018:	f44f 6e00 	mov.w	lr, #2048	; 0x800
 800601c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8006020:	f6c5 0802 	movt	r8, #22530	; 0x5802
 8006024:	f44f 6c40 	mov.w	ip, #3072	; 0xc00
 8006028:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800602c:	429f      	cmp	r7, r3
 800602e:	bf18      	it	ne
 8006030:	4547      	cmpne	r7, r8
 8006032:	f44f 5680 	mov.w	r6, #4096	; 0x1000
 8006036:	f44f 55a0 	mov.w	r5, #5120	; 0x1400
 800603a:	f6c5 0e02 	movt	lr, #22530	; 0x5802
 800603e:	bf14      	ite	ne
 8006040:	2301      	movne	r3, #1
 8006042:	2300      	moveq	r3, #0
 8006044:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 8006048:	f6c5 0502 	movt	r5, #22530	; 0x5802
 800604c:	4297      	cmp	r7, r2
 800604e:	bf0c      	ite	eq
 8006050:	2300      	moveq	r3, #0
 8006052:	f003 0301 	andne.w	r3, r3, #1
 8006056:	f44f 54c0 	mov.w	r4, #6144	; 0x1800
 800605a:	4577      	cmp	r7, lr
 800605c:	bf18      	it	ne
 800605e:	4567      	cmpne	r7, ip
 8006060:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 8006064:	f6c5 0602 	movt	r6, #22530	; 0x5802
 8006068:	9307      	str	r3, [sp, #28]
 800606a:	f6c5 0002 	movt	r0, #22530	; 0x5802
 800606e:	bf14      	ite	ne
 8006070:	2301      	movne	r3, #1
 8006072:	2300      	moveq	r3, #0
 8006074:	f6c5 0402 	movt	r4, #22530	; 0x5802
 8006078:	42b7      	cmp	r7, r6
 800607a:	bf18      	it	ne
 800607c:	42af      	cmpne	r7, r5
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800607e:	f44f 4b88 	mov.w	fp, #17408	; 0x4400
 8006082:	f44f 6280 	mov.w	r2, #1024	; 0x400
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 8006086:	9303      	str	r3, [sp, #12]
 8006088:	bf14      	ite	ne
 800608a:	2501      	movne	r5, #1
 800608c:	2500      	moveq	r5, #0

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800608e:	2300      	movs	r3, #0
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 8006090:	42a7      	cmp	r7, r4
 8006092:	bf18      	it	ne
 8006094:	4287      	cmpne	r7, r0
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006096:	f6c5 0b02 	movt	fp, #22530	; 0x5802
 800609a:	f6c5 0200 	movt	r2, #22528	; 0x5800
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800609e:	bf14      	ite	ne
 80060a0:	2001      	movne	r0, #1
 80060a2:	2000      	moveq	r0, #0
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80060a4:	f6c5 0302 	movt	r3, #22530	; 0x5802
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 80060a8:	f04f 0800 	mov.w	r8, #0
 80060ac:	9504      	str	r5, [sp, #16]
 80060ae:	9006      	str	r0, [sp, #24]
 80060b0:	9302      	str	r3, [sp, #8]
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 80060b2:	2401      	movs	r4, #1
 80060b4:	fa04 f408 	lsl.w	r4, r4, r8
    if (iocurrent != 0x00U)
 80060b8:	ea14 0a01 	ands.w	sl, r4, r1
 80060bc:	f000 80e5 	beq.w	800628a <HAL_GPIO_Init+0x3a6>
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 80060c0:	f8d9 1004 	ldr.w	r1, [r9, #4]
 80060c4:	ea4f 0648 	mov.w	r6, r8, lsl #1
 80060c8:	2503      	movs	r5, #3
 80060ca:	f021 0110 	bic.w	r1, r1, #16
 80060ce:	40b5      	lsls	r5, r6
 80060d0:	3901      	subs	r1, #1
 80060d2:	43ed      	mvns	r5, r5
          (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 80060d4:	2901      	cmp	r1, #1
 80060d6:	d814      	bhi.n	8006102 <HAL_GPIO_Init+0x21e>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 80060d8:	f8d9 100c 	ldr.w	r1, [r9, #12]
 80060dc:	2903      	cmp	r1, #3
 80060de:	f200 80e5 	bhi.w	80062ac <HAL_GPIO_Init+0x3c8>
        temp = GPIOx->OSPEEDR;
 80060e2:	68b8      	ldr	r0, [r7, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 80060e4:	40b1      	lsls	r1, r6
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80060e6:	4028      	ands	r0, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 80060e8:	4301      	orrs	r1, r0
        GPIOx->OSPEEDR = temp;
 80060ea:	60b9      	str	r1, [r7, #8]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80060ec:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = GPIOx->OTYPER;
 80060f0:	6878      	ldr	r0, [r7, #4]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80060f2:	f3c1 1100 	ubfx	r1, r1, #4, #1
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 80060f6:	ea20 0004 	bic.w	r0, r0, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80060fa:	fa01 f408 	lsl.w	r4, r1, r8
 80060fe:	4304      	orrs	r4, r0
        GPIOx->OTYPER = temp;
 8006100:	607c      	str	r4, [r7, #4]
      temp = GPIOx->PUPDR;
 8006102:	68f8      	ldr	r0, [r7, #12]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8006104:	f8d9 1008 	ldr.w	r1, [r9, #8]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8006108:	4028      	ands	r0, r5
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 800610a:	40b1      	lsls	r1, r6
 800610c:	4301      	orrs	r1, r0
      GPIOx->PUPDR = temp;
 800610e:	60f9      	str	r1, [r7, #12]
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8006110:	f8d9 1004 	ldr.w	r1, [r9, #4]
 8006114:	f021 0010 	bic.w	r0, r1, #16
 8006118:	2802      	cmp	r0, #2
 800611a:	d11e      	bne.n	800615a <HAL_GPIO_Init+0x276>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 800611c:	9b01      	ldr	r3, [sp, #4]
 800611e:	b11b      	cbz	r3, 8006128 <HAL_GPIO_Init+0x244>
 8006120:	9b03      	ldr	r3, [sp, #12]
 8006122:	2b00      	cmp	r3, #0
 8006124:	f040 80ce 	bne.w	80062c4 <HAL_GPIO_Init+0x3e0>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 8006128:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800612c:	2b0f      	cmp	r3, #15
 800612e:	f200 80e4 	bhi.w	80062fa <HAL_GPIO_Init+0x416>
        temp = GPIOx->AFR[position >> 3U];
 8006132:	ea4f 00d8 	mov.w	r0, r8, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8006136:	f008 0107 	and.w	r1, r8, #7
 800613a:	f04f 0c0f 	mov.w	ip, #15
 800613e:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8006142:	0089      	lsls	r1, r1, #2
        temp = GPIOx->AFR[position >> 3U];
 8006144:	6a04      	ldr	r4, [r0, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8006146:	fa0c fc01 	lsl.w	ip, ip, r1
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 800614a:	fa03 f101 	lsl.w	r1, r3, r1
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 800614e:	ea24 040c 	bic.w	r4, r4, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8006152:	4321      	orrs	r1, r4
        GPIOx->AFR[position >> 3U] = temp;
 8006154:	6201      	str	r1, [r0, #32]
 8006156:	f8d9 1004 	ldr.w	r1, [r9, #4]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800615a:	f001 0103 	and.w	r1, r1, #3
      temp = GPIOx->MODER;
 800615e:	6838      	ldr	r0, [r7, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8006160:	fa01 f606 	lsl.w	r6, r1, r6
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8006164:	4005      	ands	r5, r0
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8006166:	4335      	orrs	r5, r6
      GPIOx->MODER = temp;
 8006168:	603d      	str	r5, [r7, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800616a:	f8d9 1004 	ldr.w	r1, [r9, #4]
 800616e:	00ce      	lsls	r6, r1, #3
 8006170:	f140 8089 	bpl.w	8006286 <HAL_GPIO_Init+0x3a2>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006174:	f8db 50f4 	ldr.w	r5, [fp, #244]	; 0xf4
 8006178:	f028 0403 	bic.w	r4, r8, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 800617c:	f008 0103 	and.w	r1, r8, #3
 8006180:	200f      	movs	r0, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006182:	f045 0502 	orr.w	r5, r5, #2
 8006186:	4414      	add	r4, r2
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006188:	0089      	lsls	r1, r1, #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800618a:	f8cb 50f4 	str.w	r5, [fp, #244]	; 0xf4
 800618e:	f8db 50f4 	ldr.w	r5, [fp, #244]	; 0xf4
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8006192:	4088      	lsls	r0, r1
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8006194:	9b02      	ldr	r3, [sp, #8]
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8006196:	f005 0502 	and.w	r5, r5, #2
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800619a:	429f      	cmp	r7, r3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 800619c:	9509      	str	r5, [sp, #36]	; 0x24
 800619e:	9d09      	ldr	r5, [sp, #36]	; 0x24
        temp = SYSCFG->EXTICR[position >> 2U];
 80061a0:	68a5      	ldr	r5, [r4, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80061a2:	ea25 0000 	bic.w	r0, r5, r0
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80061a6:	d036      	beq.n	8006216 <HAL_GPIO_Init+0x332>
 80061a8:	9b01      	ldr	r3, [sp, #4]
 80061aa:	2b00      	cmp	r3, #0
 80061ac:	f000 80b9 	beq.w	8006322 <HAL_GPIO_Init+0x43e>
 80061b0:	f44f 6500 	mov.w	r5, #2048	; 0x800
 80061b4:	f6c5 0502 	movt	r5, #22530	; 0x5802
 80061b8:	42af      	cmp	r7, r5
 80061ba:	f000 8099 	beq.w	80062f0 <HAL_GPIO_Init+0x40c>
 80061be:	9b03      	ldr	r3, [sp, #12]
 80061c0:	2b00      	cmp	r3, #0
 80061c2:	f000 80b8 	beq.w	8006336 <HAL_GPIO_Init+0x452>
 80061c6:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 80061ca:	f6c5 0502 	movt	r5, #22530	; 0x5802
 80061ce:	42af      	cmp	r7, r5
 80061d0:	f000 80b6 	beq.w	8006340 <HAL_GPIO_Init+0x45c>
 80061d4:	9b04      	ldr	r3, [sp, #16]
 80061d6:	2b00      	cmp	r3, #0
 80061d8:	f000 80a8 	beq.w	800632c <HAL_GPIO_Init+0x448>
 80061dc:	f44f 55c0 	mov.w	r5, #6144	; 0x1800
 80061e0:	f6c5 0502 	movt	r5, #22530	; 0x5802
 80061e4:	42af      	cmp	r7, r5
 80061e6:	f000 80b0 	beq.w	800634a <HAL_GPIO_Init+0x466>
 80061ea:	9b06      	ldr	r3, [sp, #24]
 80061ec:	2b00      	cmp	r3, #0
 80061ee:	f000 80b9 	beq.w	8006364 <HAL_GPIO_Init+0x480>
 80061f2:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 80061f6:	f6c5 0502 	movt	r5, #22530	; 0x5802
 80061fa:	42af      	cmp	r7, r5
 80061fc:	f000 80b7 	beq.w	800636e <HAL_GPIO_Init+0x48a>
 8006200:	f44f 5510 	mov.w	r5, #9216	; 0x2400
 8006204:	f6c5 0502 	movt	r5, #22530	; 0x5802
 8006208:	42af      	cmp	r7, r5
 800620a:	bf0c      	ite	eq
 800620c:	2509      	moveq	r5, #9
 800620e:	250a      	movne	r5, #10
 8006210:	fa05 f101 	lsl.w	r1, r5, r1
 8006214:	4308      	orrs	r0, r1
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8006216:	2580      	movs	r5, #128	; 0x80
        SYSCFG->EXTICR[position >> 2U] = temp;
 8006218:	60a0      	str	r0, [r4, #8]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800621a:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp &= ~(iocurrent);
 800621e:	ea6f 040a 	mvn.w	r4, sl
        temp = EXTI_CurrentCPU->IMR1;
 8006222:	f6c5 0500 	movt	r5, #22528	; 0x5800
 8006226:	6828      	ldr	r0, [r5, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8006228:	03cd      	lsls	r5, r1, #15
        {
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->IMR1 = temp;
 800622a:	f04f 0180 	mov.w	r1, #128	; 0x80
          temp |= iocurrent;
        }
        EXTI_CurrentCPU->EMR1 = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 800622e:	f04f 45b0 	mov.w	r5, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 8006232:	bf54      	ite	pl
 8006234:	4020      	andpl	r0, r4
          temp |= iocurrent;
 8006236:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI_CurrentCPU->IMR1 = temp;
 800623a:	f6c5 0100 	movt	r1, #22528	; 0x5800
 800623e:	6008      	str	r0, [r1, #0]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8006240:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI_CurrentCPU->EMR1;
 8006244:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8006246:	0380      	lsls	r0, r0, #14
        EXTI_CurrentCPU->EMR1 = temp;
 8006248:	f04f 0080 	mov.w	r0, #128	; 0x80
        temp &= ~(iocurrent);
 800624c:	bf54      	ite	pl
 800624e:	4021      	andpl	r1, r4
          temp |= iocurrent;
 8006250:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI_CurrentCPU->EMR1 = temp;
 8006254:	f6c5 0000 	movt	r0, #22528	; 0x5800
 8006258:	6041      	str	r1, [r0, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800625a:	f8d9 1004 	ldr.w	r1, [r9, #4]
        temp = EXTI->RTSR1;
 800625e:	6828      	ldr	r0, [r5, #0]
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8006260:	02c9      	lsls	r1, r1, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 8006262:	f04f 41b0 	mov.w	r1, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 8006266:	bf54      	ite	pl
 8006268:	4020      	andpl	r0, r4
          temp |= iocurrent;
 800626a:	ea4a 0000 	orrmi.w	r0, sl, r0
        EXTI->RTSR1 = temp;
 800626e:	6008      	str	r0, [r1, #0]

        temp = EXTI->FTSR1;
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8006270:	f8d9 0004 	ldr.w	r0, [r9, #4]
        temp = EXTI->FTSR1;
 8006274:	6849      	ldr	r1, [r1, #4]
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8006276:	0283      	lsls	r3, r0, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 8006278:	f04f 40b0 	mov.w	r0, #1476395008	; 0x58000000
        temp &= ~(iocurrent);
 800627c:	bf54      	ite	pl
 800627e:	4021      	andpl	r1, r4
          temp |= iocurrent;
 8006280:	ea4a 0101 	orrmi.w	r1, sl, r1
        EXTI->FTSR1 = temp;
 8006284:	6041      	str	r1, [r0, #4]
 8006286:	f8d9 1000 	ldr.w	r1, [r9]
      }
    }

    position++;
 800628a:	f108 0801 	add.w	r8, r8, #1
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 800628e:	fa31 f308 	lsrs.w	r3, r1, r8
 8006292:	f47f af0e 	bne.w	80060b2 <HAL_GPIO_Init+0x1ce>
  }
}
 8006296:	b00b      	add	sp, #44	; 0x2c
 8006298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
 800629c:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 80062a0:	21bc      	movs	r1, #188	; 0xbc
 80062a2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80062a6:	f00f fadf 	bl	8015868 <assert_failed>
 80062aa:	e67a      	b.n	8005fa2 <HAL_GPIO_Init+0xbe>
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
 80062ac:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 80062b0:	21ce      	movs	r1, #206	; 0xce
 80062b2:	9205      	str	r2, [sp, #20]
 80062b4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80062b8:	f00f fad6 	bl	8015868 <assert_failed>
 80062bc:	f8d9 100c 	ldr.w	r1, [r9, #12]
 80062c0:	9a05      	ldr	r2, [sp, #20]
 80062c2:	e70e      	b.n	80060e2 <HAL_GPIO_Init+0x1fe>
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
 80062c4:	9b04      	ldr	r3, [sp, #16]
 80062c6:	2b00      	cmp	r3, #0
 80062c8:	f43f af2e 	beq.w	8006128 <HAL_GPIO_Init+0x244>
 80062cc:	9b06      	ldr	r3, [sp, #24]
 80062ce:	2b00      	cmp	r3, #0
 80062d0:	f43f af2a 	beq.w	8006128 <HAL_GPIO_Init+0x244>
 80062d4:	9b07      	ldr	r3, [sp, #28]
 80062d6:	2b00      	cmp	r3, #0
 80062d8:	f43f af26 	beq.w	8006128 <HAL_GPIO_Init+0x244>
 80062dc:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 80062e0:	21e6      	movs	r1, #230	; 0xe6
 80062e2:	9205      	str	r2, [sp, #20]
 80062e4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80062e8:	f00f fabe 	bl	8015868 <assert_failed>
 80062ec:	9a05      	ldr	r2, [sp, #20]
 80062ee:	e71b      	b.n	8006128 <HAL_GPIO_Init+0x244>
 80062f0:	2502      	movs	r5, #2
 80062f2:	fa05 f101 	lsl.w	r1, r5, r1
 80062f6:	4308      	orrs	r0, r1
 80062f8:	e78d      	b.n	8006216 <HAL_GPIO_Init+0x332>
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
 80062fa:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 80062fe:	21e7      	movs	r1, #231	; 0xe7
 8006300:	9205      	str	r2, [sp, #20]
 8006302:	f6c0 0002 	movt	r0, #2050	; 0x802
 8006306:	f00f faaf 	bl	8015868 <assert_failed>
 800630a:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800630e:	9a05      	ldr	r2, [sp, #20]
 8006310:	e70f      	b.n	8006132 <HAL_GPIO_Init+0x24e>
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));
 8006312:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006316:	21be      	movs	r1, #190	; 0xbe
 8006318:	f6c0 0002 	movt	r0, #2050	; 0x802
 800631c:	f00f faa4 	bl	8015868 <assert_failed>
 8006320:	e66f      	b.n	8006002 <HAL_GPIO_Init+0x11e>
 8006322:	2501      	movs	r5, #1
 8006324:	fa05 f101 	lsl.w	r1, r5, r1
 8006328:	4308      	orrs	r0, r1
 800632a:	e774      	b.n	8006216 <HAL_GPIO_Init+0x332>
 800632c:	2505      	movs	r5, #5
 800632e:	fa05 f101 	lsl.w	r1, r5, r1
 8006332:	4308      	orrs	r0, r1
 8006334:	e76f      	b.n	8006216 <HAL_GPIO_Init+0x332>
 8006336:	2503      	movs	r5, #3
 8006338:	fa05 f101 	lsl.w	r1, r5, r1
 800633c:	4308      	orrs	r0, r1
 800633e:	e76a      	b.n	8006216 <HAL_GPIO_Init+0x332>
 8006340:	2504      	movs	r5, #4
 8006342:	fa05 f101 	lsl.w	r1, r5, r1
 8006346:	4308      	orrs	r0, r1
 8006348:	e765      	b.n	8006216 <HAL_GPIO_Init+0x332>
 800634a:	2506      	movs	r5, #6
 800634c:	fa05 f101 	lsl.w	r1, r5, r1
 8006350:	4308      	orrs	r0, r1
 8006352:	e760      	b.n	8006216 <HAL_GPIO_Init+0x332>
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
 8006354:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006358:	21bd      	movs	r1, #189	; 0xbd
 800635a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800635e:	f00f fa83 	bl	8015868 <assert_failed>
 8006362:	e649      	b.n	8005ff8 <HAL_GPIO_Init+0x114>
 8006364:	2507      	movs	r5, #7
 8006366:	fa05 f101 	lsl.w	r1, r5, r1
 800636a:	4308      	orrs	r0, r1
 800636c:	e753      	b.n	8006216 <HAL_GPIO_Init+0x332>
 800636e:	2508      	movs	r5, #8
 8006370:	fa05 f101 	lsl.w	r1, r5, r1
 8006374:	4308      	orrs	r0, r1
 8006376:	e74e      	b.n	8006216 <HAL_GPIO_Init+0x332>

08006378 <HAL_GPIO_DeInit>:
#else
  EXTI_CurrentCPU = EXTI_D1; /* EXTI for CM7 CPU */
#endif

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8006378:	2200      	movs	r2, #0
 800637a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800637e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8006382:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8006386:	4290      	cmp	r0, r2
 8006388:	bf18      	it	ne
 800638a:	4298      	cmpne	r0, r3
{
 800638c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8006390:	bf18      	it	ne
 8006392:	2301      	movne	r3, #1
{
 8006394:	b089      	sub	sp, #36	; 0x24
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 8006396:	bf08      	it	eq
 8006398:	2300      	moveq	r3, #0
{
 800639a:	4604      	mov	r4, r0
 800639c:	460d      	mov	r5, r1
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
 800639e:	9302      	str	r3, [sp, #8]
 80063a0:	d03d      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063a2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80063a6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063aa:	4298      	cmp	r0, r3
 80063ac:	d037      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063ae:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 80063b2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063b6:	4298      	cmp	r0, r3
 80063b8:	d031      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063ba:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 80063be:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063c2:	4298      	cmp	r0, r3
 80063c4:	d02b      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063c6:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 80063ca:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063ce:	4298      	cmp	r0, r3
 80063d0:	d025      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063d2:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 80063d6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063da:	4298      	cmp	r0, r3
 80063dc:	d01f      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063de:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80063e2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063e6:	4298      	cmp	r0, r3
 80063e8:	d019      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 80063ea:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80063ee:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 80063f2:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80063f6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80063fa:	4290      	cmp	r0, r2
 80063fc:	bf18      	it	ne
 80063fe:	4298      	cmpne	r0, r3
 8006400:	d00d      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 8006402:	f44f 5320 	mov.w	r3, #10240	; 0x2800
 8006406:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800640a:	4298      	cmp	r0, r3
 800640c:	d007      	beq.n	800641e <HAL_GPIO_DeInit+0xa6>
 800640e:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006412:	f240 113f 	movw	r1, #319	; 0x13f
 8006416:	f6c0 0002 	movt	r0, #2050	; 0x802
 800641a:	f00f fa25 	bl	8015868 <assert_failed>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800641e:	b2ab      	uxth	r3, r5
 8006420:	2b00      	cmp	r3, #0
 8006422:	d072      	beq.n	800650a <HAL_GPIO_DeInit+0x192>
 8006424:	2300      	movs	r3, #0
 8006426:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800642a:	402b      	ands	r3, r5
 800642c:	2b00      	cmp	r3, #0
 800642e:	d16c      	bne.n	800650a <HAL_GPIO_DeInit+0x192>
    {
      /*------------------------- EXTI Mode Configuration --------------------*/
      /* Clear the External Interrupt or Event for the current IO */
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8006430:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8006434:	f44f 6a80 	mov.w	sl, #1024	; 0x400
 8006438:	f04f 0900 	mov.w	r9, #0
      {
        /* Clear EXTI line configuration for Current CPU */
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 800643c:	f04f 0880 	mov.w	r8, #128	; 0x80
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8006440:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8006444:	f44f 6b00 	mov.w	fp, #2048	; 0x800
 8006448:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800644c:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 8006450:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 8006454:	f44f 56e0 	mov.w	r6, #7168	; 0x1c00
 8006458:	9303      	str	r3, [sp, #12]
 800645a:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800645e:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8006462:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8006466:	f6c5 0602 	movt	r6, #22530	; 0x5802
 800646a:	f6c5 0a00 	movt	sl, #22528	; 0x5800
 800646e:	f6c5 0902 	movt	r9, #22530	; 0x5802
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 8006472:	f6c5 0800 	movt	r8, #22528	; 0x5800
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8006476:	f6c5 0b02 	movt	fp, #22530	; 0x5802
{
 800647a:	2300      	movs	r3, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 800647c:	9204      	str	r2, [sp, #16]
 800647e:	9105      	str	r1, [sp, #20]
 8006480:	9006      	str	r0, [sp, #24]
 8006482:	9607      	str	r6, [sp, #28]
    iocurrent = GPIO_Pin & (1UL << position) ;
 8006484:	f04f 0c01 	mov.w	ip, #1
 8006488:	fa0c f103 	lsl.w	r1, ip, r3
    if (iocurrent != 0x00U)
 800648c:	ea11 0205 	ands.w	r2, r1, r5
 8006490:	9201      	str	r2, [sp, #4]
 8006492:	f000 808c 	beq.w	80065ae <HAL_GPIO_DeInit+0x236>
 8006496:	f023 0603 	bic.w	r6, r3, #3
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 800649a:	f003 0203 	and.w	r2, r3, #3
 800649e:	270f      	movs	r7, #15
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80064a0:	454c      	cmp	r4, r9
 80064a2:	4456      	add	r6, sl
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 80064a4:	ea4f 0282 	mov.w	r2, r2, lsl #2
      tmp = SYSCFG->EXTICR[position >> 2U];
 80064a8:	f8d6 e008 	ldr.w	lr, [r6, #8]
      tmp &= (0x0FUL << (4U * (position & 0x03U)));
 80064ac:	fa07 f702 	lsl.w	r7, r7, r2
 80064b0:	ea07 0e0e 	and.w	lr, r7, lr
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 80064b4:	d036      	beq.n	8006524 <HAL_GPIO_DeInit+0x1ac>
 80064b6:	9802      	ldr	r0, [sp, #8]
 80064b8:	b320      	cbz	r0, 8006504 <HAL_GPIO_DeInit+0x18c>
 80064ba:	455c      	cmp	r4, fp
 80064bc:	f000 8084 	beq.w	80065c8 <HAL_GPIO_DeInit+0x250>
 80064c0:	9803      	ldr	r0, [sp, #12]
 80064c2:	4284      	cmp	r4, r0
 80064c4:	f000 8085 	beq.w	80065d2 <HAL_GPIO_DeInit+0x25a>
 80064c8:	9804      	ldr	r0, [sp, #16]
 80064ca:	4284      	cmp	r4, r0
 80064cc:	d077      	beq.n	80065be <HAL_GPIO_DeInit+0x246>
 80064ce:	9805      	ldr	r0, [sp, #20]
 80064d0:	4284      	cmp	r4, r0
 80064d2:	f000 8088 	beq.w	80065e6 <HAL_GPIO_DeInit+0x26e>
 80064d6:	9806      	ldr	r0, [sp, #24]
 80064d8:	4284      	cmp	r4, r0
 80064da:	f000 8089 	beq.w	80065f0 <HAL_GPIO_DeInit+0x278>
 80064de:	9807      	ldr	r0, [sp, #28]
 80064e0:	4284      	cmp	r4, r0
 80064e2:	d07b      	beq.n	80065dc <HAL_GPIO_DeInit+0x264>
 80064e4:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
 80064e8:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 80064ec:	4564      	cmp	r4, ip
 80064ee:	f000 8084 	beq.w	80065fa <HAL_GPIO_DeInit+0x282>
 80064f2:	f44f 5c10 	mov.w	ip, #9216	; 0x2400
 80064f6:	f6c5 0c02 	movt	ip, #22530	; 0x5802
 80064fa:	4564      	cmp	r4, ip
 80064fc:	f000 8082 	beq.w	8006604 <HAL_GPIO_DeInit+0x28c>
 8006500:	f04f 0c0a 	mov.w	ip, #10
 8006504:	fa0c fc02 	lsl.w	ip, ip, r2
 8006508:	e00e      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800650a:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 800650e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8006512:	f6c0 0002 	movt	r0, #2050	; 0x802
 8006516:	f00f f9a7 	bl	8015868 <assert_failed>
  while ((GPIO_Pin >> position) != 0x00U)
 800651a:	2d00      	cmp	r5, #0
 800651c:	d188      	bne.n	8006430 <HAL_GPIO_DeInit+0xb8>
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
    }

    position++;
  }
}
 800651e:	b009      	add	sp, #36	; 0x24
 8006520:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006524:	f04f 0c00 	mov.w	ip, #0
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U))))
 8006528:	45e6      	cmp	lr, ip
 800652a:	d11e      	bne.n	800656a <HAL_GPIO_DeInit+0x1f2>
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 800652c:	9a01      	ldr	r2, [sp, #4]
 800652e:	f8d8 c000 	ldr.w	ip, [r8]
 8006532:	43d0      	mvns	r0, r2
        EXTI->RTSR1 &= ~(iocurrent);
 8006534:	f04f 42b0 	mov.w	r2, #1476395008	; 0x58000000
        EXTI_CurrentCPU->IMR1 &= ~(iocurrent);
 8006538:	ea0c 0c00 	and.w	ip, ip, r0
 800653c:	f8c8 c000 	str.w	ip, [r8]
        EXTI_CurrentCPU->EMR1 &= ~(iocurrent);
 8006540:	f8d8 c004 	ldr.w	ip, [r8, #4]
 8006544:	ea00 0c0c 	and.w	ip, r0, ip
 8006548:	f8c8 c004 	str.w	ip, [r8, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 800654c:	f8d2 c000 	ldr.w	ip, [r2]
 8006550:	ea00 0c0c 	and.w	ip, r0, ip
 8006554:	f8c2 c000 	str.w	ip, [r2]
        EXTI->FTSR1 &= ~(iocurrent);
 8006558:	f8d2 c004 	ldr.w	ip, [r2, #4]
 800655c:	ea00 000c 	and.w	r0, r0, ip
 8006560:	6050      	str	r0, [r2, #4]
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 8006562:	68b2      	ldr	r2, [r6, #8]
 8006564:	ea22 0707 	bic.w	r7, r2, r7
 8006568:	60b7      	str	r7, [r6, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800656a:	2603      	movs	r6, #3
 800656c:	005a      	lsls	r2, r3, #1
 800656e:	f8d4 c000 	ldr.w	ip, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006572:	270f      	movs	r7, #15
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8006574:	fa06 f202 	lsl.w	r2, r6, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006578:	fa23 f006 	lsr.w	r0, r3, r6
 800657c:	f003 0607 	and.w	r6, r3, #7
 8006580:	eb04 0080 	add.w	r0, r4, r0, lsl #2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 8006584:	ea4c 0c02 	orr.w	ip, ip, r2
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006588:	00b6      	lsls	r6, r6, #2
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800658a:	43d2      	mvns	r2, r2
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2U));
 800658c:	f8c4 c000 	str.w	ip, [r4]
      GPIOx->AFR[position >> 3U] &= ~(0xFU << ((position & 0x07U) * 4U)) ;
 8006590:	40b7      	lsls	r7, r6
 8006592:	6a06      	ldr	r6, [r0, #32]
 8006594:	ea26 0607 	bic.w	r6, r6, r7
 8006598:	6206      	str	r6, [r0, #32]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800659a:	68e0      	ldr	r0, [r4, #12]
 800659c:	4010      	ands	r0, r2
 800659e:	60e0      	str	r0, [r4, #12]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80065a0:	6860      	ldr	r0, [r4, #4]
 80065a2:	ea20 0101 	bic.w	r1, r0, r1
 80065a6:	6061      	str	r1, [r4, #4]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 80065a8:	68a1      	ldr	r1, [r4, #8]
 80065aa:	400a      	ands	r2, r1
 80065ac:	60a2      	str	r2, [r4, #8]
    position++;
 80065ae:	3301      	adds	r3, #1
  while ((GPIO_Pin >> position) != 0x00U)
 80065b0:	fa35 f203 	lsrs.w	r2, r5, r3
 80065b4:	f47f af66 	bne.w	8006484 <HAL_GPIO_DeInit+0x10c>
}
 80065b8:	b009      	add	sp, #36	; 0x24
 80065ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80065be:	f04f 0c04 	mov.w	ip, #4
 80065c2:	fa0c fc02 	lsl.w	ip, ip, r2
 80065c6:	e7af      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065c8:	f04f 0c02 	mov.w	ip, #2
 80065cc:	fa0c fc02 	lsl.w	ip, ip, r2
 80065d0:	e7aa      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065d2:	f04f 0c03 	mov.w	ip, #3
 80065d6:	fa0c fc02 	lsl.w	ip, ip, r2
 80065da:	e7a5      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065dc:	f04f 0c07 	mov.w	ip, #7
 80065e0:	fa0c fc02 	lsl.w	ip, ip, r2
 80065e4:	e7a0      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065e6:	f04f 0c05 	mov.w	ip, #5
 80065ea:	fa0c fc02 	lsl.w	ip, ip, r2
 80065ee:	e79b      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065f0:	f04f 0c06 	mov.w	ip, #6
 80065f4:	fa0c fc02 	lsl.w	ip, ip, r2
 80065f8:	e796      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 80065fa:	f04f 0c08 	mov.w	ip, #8
 80065fe:	fa0c fc02 	lsl.w	ip, ip, r2
 8006602:	e791      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 8006604:	f04f 0c09 	mov.w	ip, #9
 8006608:	fa0c fc02 	lsl.w	ip, ip, r2
 800660c:	e78c      	b.n	8006528 <HAL_GPIO_DeInit+0x1b0>
 800660e:	bf00      	nop

08006610 <HAL_GPIO_ReadPin>:
  * @param  GPIO_Pin: specifies the port bit to read.
  *         This parameter can be GPIO_PIN_x where x can be (0..15).
  * @retval The input port pin value.
  */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8006610:	b538      	push	{r3, r4, r5, lr}
 8006612:	4605      	mov	r5, r0
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8006614:	460c      	mov	r4, r1
 8006616:	b129      	cbz	r1, 8006624 <HAL_GPIO_ReadPin+0x14>

  if ((GPIOx->IDR & GPIO_Pin) != 0x00U)
 8006618:	692b      	ldr	r3, [r5, #16]
 800661a:	421c      	tst	r4, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 800661c:	bf14      	ite	ne
 800661e:	2001      	movne	r0, #1
 8006620:	2000      	moveq	r0, #0
 8006622:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8006624:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006628:	f240 118d 	movw	r1, #397	; 0x18d
 800662c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8006630:	f00f f91a 	bl	8015868 <assert_failed>
 8006634:	e7f0      	b.n	8006618 <HAL_GPIO_ReadPin+0x8>
 8006636:	bf00      	nop

08006638 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8006638:	b570      	push	{r4, r5, r6, lr}
 800663a:	4606      	mov	r6, r0
 800663c:	4615      	mov	r5, r2
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 800663e:	460c      	mov	r4, r1
 8006640:	b179      	cbz	r1, 8006662 <HAL_GPIO_WritePin+0x2a>
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 8006642:	2d01      	cmp	r5, #1
 8006644:	d803      	bhi.n	800664e <HAL_GPIO_WritePin+0x16>

  if (PinState != GPIO_PIN_RESET)
 8006646:	b905      	cbnz	r5, 800664a <HAL_GPIO_WritePin+0x12>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8006648:	0424      	lsls	r4, r4, #16
 800664a:	61b4      	str	r4, [r6, #24]
  }
}
 800664c:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN_ACTION(PinState));
 800664e:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006652:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 8006656:	f6c0 0002 	movt	r0, #2050	; 0x802
 800665a:	f00f f905 	bl	8015868 <assert_failed>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 800665e:	61b4      	str	r4, [r6, #24]
}
 8006660:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_GPIO_PIN(GPIO_Pin));
 8006662:	f64d 20f0 	movw	r0, #56048	; 0xdaf0
 8006666:	f240 11ad 	movw	r1, #429	; 0x1ad
 800666a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800666e:	f00f f8fb 	bl	8015868 <assert_failed>
 8006672:	e7e6      	b.n	8006642 <HAL_GPIO_WritePin+0xa>

08006674 <HAL_HCD_HC_Init>:
                                  uint8_t epnum,
                                  uint8_t dev_address,
                                  uint8_t speed,
                                  uint8_t ep_type,
                                  uint16_t mps)
{
 8006674:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  HAL_StatusTypeDef status;

  __HAL_LOCK(hhcd);
 8006678:	f890 42b8 	ldrb.w	r4, [r0, #696]	; 0x2b8
{
 800667c:	b085      	sub	sp, #20
  __HAL_LOCK(hhcd);
 800667e:	2c01      	cmp	r4, #1
{
 8006680:	f89d c038 	ldrb.w	ip, [sp, #56]	; 0x38
 8006684:	f89d e03c 	ldrb.w	lr, [sp, #60]	; 0x3c
 8006688:	f8bd 9040 	ldrh.w	r9, [sp, #64]	; 0x40
  __HAL_LOCK(hhcd);
 800668c:	d029      	beq.n	80066e2 <HAL_HCD_HC_Init+0x6e>
 800668e:	4605      	mov	r5, r0
  hhcd->hc[ch_num].do_ping = 0U;
 8006690:	eb01 0481 	add.w	r4, r1, r1, lsl #2
  __HAL_LOCK(hhcd);
 8006694:	f04f 0801 	mov.w	r8, #1
  hhcd->hc[ch_num].max_packet = mps;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].ep_type = ep_type;
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;

  if ((epnum & 0x80U) == 0x80U)
 8006698:	09d0      	lsrs	r0, r2, #7
  hhcd->hc[ch_num].do_ping = 0U;
 800669a:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 800669e:	f002 0a7f 	and.w	sl, r2, #127	; 0x7f
  __HAL_LOCK(hhcd);
 80066a2:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8
  hhcd->hc[ch_num].do_ping = 0U;
 80066a6:	f04f 0800 	mov.w	r8, #0
  hhcd->hc[ch_num].dev_addr = dev_address;
 80066aa:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
  hhcd->hc[ch_num].max_packet = mps;
 80066ae:	f8a4 9040 	strh.w	r9, [r4, #64]	; 0x40
  hhcd->hc[ch_num].ch_num = ch_num;
 80066b2:	f884 1039 	strb.w	r1, [r4, #57]	; 0x39
  hhcd->hc[ch_num].ep_type = ep_type;
 80066b6:	f884 e03f 	strb.w	lr, [r4, #63]	; 0x3f
  else
  {
    hhcd->hc[ch_num].ep_is_in = 0U;
  }

  hhcd->hc[ch_num].speed = speed;
 80066ba:	f884 c03c 	strb.w	ip, [r4, #60]	; 0x3c
  hhcd->hc[ch_num].ep_num = epnum & 0x7FU;
 80066be:	f884 a03a 	strb.w	sl, [r4, #58]	; 0x3a
 80066c2:	f884 003b 	strb.w	r0, [r4, #59]	; 0x3b
  hhcd->hc[ch_num].do_ping = 0U;
 80066c6:	f884 803d 	strb.w	r8, [r4, #61]	; 0x3d

  status =  USB_HC_Init(hhcd->Instance,
 80066ca:	6828      	ldr	r0, [r5, #0]
 80066cc:	f8cd c000 	str.w	ip, [sp]
 80066d0:	e9cd e901 	strd	lr, r9, [sp, #4]
 80066d4:	f00a f8b4 	bl	8010840 <USB_HC_Init>
                        epnum,
                        dev_address,
                        speed,
                        ep_type,
                        mps);
  __HAL_UNLOCK(hhcd);
 80066d8:	f885 82b8 	strb.w	r8, [r5, #696]	; 0x2b8

  return status;
}
 80066dc:	b005      	add	sp, #20
 80066de:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  __HAL_LOCK(hhcd);
 80066e2:	2002      	movs	r0, #2
}
 80066e4:	b005      	add	sp, #20
 80066e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80066ea:	bf00      	nop

080066ec <HAL_HCD_HC_Halt>:
  */
HAL_StatusTypeDef HAL_HCD_HC_Halt(HCD_HandleTypeDef *hhcd, uint8_t ch_num)
{
  HAL_StatusTypeDef status = HAL_OK;

  __HAL_LOCK(hhcd);
 80066ec:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 80066f0:	2b01      	cmp	r3, #1
 80066f2:	d00b      	beq.n	800670c <HAL_HCD_HC_Halt+0x20>
 80066f4:	2301      	movs	r3, #1
{
 80066f6:	b510      	push	{r4, lr}
 80066f8:	4604      	mov	r4, r0
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 80066fa:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 80066fc:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006700:	f00a f9fc 	bl	8010afc <USB_HC_Halt>
  __HAL_UNLOCK(hhcd);
 8006704:	2000      	movs	r0, #0
 8006706:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8

  return status;
}
 800670a:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 800670c:	2002      	movs	r0, #2
}
 800670e:	4770      	bx	lr

08006710 <HAL_HCD_Init>:
  if (hhcd == NULL)
 8006710:	2800      	cmp	r0, #0
 8006712:	d05d      	beq.n	80067d0 <HAL_HCD_Init+0xc0>
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 8006714:	2300      	movs	r3, #0
{
 8006716:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 800671a:	f2c4 0308 	movt	r3, #16392	; 0x4008
 800671e:	6804      	ldr	r4, [r0, #0]
{
 8006720:	b08a      	sub	sp, #40	; 0x28
 8006722:	4607      	mov	r7, r0
  assert_param(IS_HCD_ALL_INSTANCE(hhcd->Instance));
 8006724:	429c      	cmp	r4, r3
 8006726:	d00c      	beq.n	8006742 <HAL_HCD_Init+0x32>
 8006728:	2300      	movs	r3, #0
 800672a:	f2c4 0304 	movt	r3, #16388	; 0x4004
 800672e:	429c      	cmp	r4, r3
 8006730:	d007      	beq.n	8006742 <HAL_HCD_Init+0x32>
 8006732:	f64d 302c 	movw	r0, #56108	; 0xdb2c
 8006736:	217a      	movs	r1, #122	; 0x7a
 8006738:	f6c0 0002 	movt	r0, #2050	; 0x802
 800673c:	f00f f894 	bl	8015868 <assert_failed>
 8006740:	683c      	ldr	r4, [r7, #0]
  if (hhcd->State == HAL_HCD_STATE_RESET)
 8006742:	f897 32b9 	ldrb.w	r3, [r7, #697]	; 0x2b9
 8006746:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800674a:	2b00      	cmp	r3, #0
 800674c:	d039      	beq.n	80067c2 <HAL_HCD_Init+0xb2>
 800674e:	4620      	mov	r0, r4
  hhcd->State = HAL_HCD_STATE_BUSY;
 8006750:	2303      	movs	r3, #3
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8006752:	466d      	mov	r5, sp
 8006754:	f107 0804 	add.w	r8, r7, #4
  hhcd->State = HAL_HCD_STATE_BUSY;
 8006758:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
  if ((USBx->CID & (0x1U << 8)) == 0U)
 800675c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 800675e:	463c      	mov	r4, r7
  if ((USBx->CID & (0x1U << 8)) == 0U)
 8006760:	f413 7380 	ands.w	r3, r3, #256	; 0x100
    hhcd->Init.dma_enable = 0U;
 8006764:	bf08      	it	eq
 8006766:	613b      	streq	r3, [r7, #16]
  __HAL_HCD_DISABLE(hhcd);
 8006768:	f009 ff1a 	bl	80105a0 <USB_DisableGlobalInt>
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 800676c:	f854 6b10 	ldr.w	r6, [r4], #16
 8006770:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006772:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8006774:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8006776:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 8006778:	e894 0003 	ldmia.w	r4, {r0, r1}
 800677c:	e885 0003 	stmia.w	r5, {r0, r1}
 8006780:	4630      	mov	r0, r6
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 8006782:	463e      	mov	r6, r7
 8006784:	466d      	mov	r5, sp
  (void)USB_CoreInit(hhcd->Instance, hhcd->Init);
 8006786:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 800678a:	f009 fe8b 	bl	80104a4 <USB_CoreInit>
  (void)USB_SetCurrentMode(hhcd->Instance, USB_HOST_MODE);
 800678e:	2101      	movs	r1, #1
 8006790:	6838      	ldr	r0, [r7, #0]
 8006792:	f009 ff0d 	bl	80105b0 <USB_SetCurrentMode>
  (void)USB_HostInit(hhcd->Instance, hhcd->Init);
 8006796:	f856 cb10 	ldr.w	ip, [r6], #16
 800679a:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 800679c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 800679e:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80067a0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80067a2:	e894 0003 	ldmia.w	r4, {r0, r1}
 80067a6:	e885 0003 	stmia.w	r5, {r0, r1}
 80067aa:	4660      	mov	r0, ip
 80067ac:	e898 000e 	ldmia.w	r8, {r1, r2, r3}
 80067b0:	f009 ff32 	bl	8010618 <USB_HostInit>
  hhcd->State = HAL_HCD_STATE_READY;
 80067b4:	2301      	movs	r3, #1
  return HAL_OK;
 80067b6:	2000      	movs	r0, #0
  hhcd->State = HAL_HCD_STATE_READY;
 80067b8:	f887 32b9 	strb.w	r3, [r7, #697]	; 0x2b9
}
 80067bc:	b00a      	add	sp, #40	; 0x28
 80067be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_HCD_MspInit(hhcd);
 80067c2:	4638      	mov	r0, r7
    hhcd->Lock = HAL_UNLOCKED;
 80067c4:	f887 22b8 	strb.w	r2, [r7, #696]	; 0x2b8
    HAL_HCD_MspInit(hhcd);
 80067c8:	f01b f884 	bl	80218d4 <HAL_HCD_MspInit>
 80067cc:	6838      	ldr	r0, [r7, #0]
 80067ce:	e7bf      	b.n	8006750 <HAL_HCD_Init+0x40>
    return HAL_ERROR;
 80067d0:	2001      	movs	r0, #1
}
 80067d2:	4770      	bx	lr

080067d4 <HAL_HCD_HC_SubmitRequest>:
                                           uint8_t ep_type,
                                           uint8_t token,
                                           uint8_t *pbuff,
                                           uint16_t length,
                                           uint8_t do_ping)
{
 80067d4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80067d6:	460c      	mov	r4, r1
  hhcd->hc[ch_num].ep_is_in = direction;
 80067d8:	0089      	lsls	r1, r1, #2
{
 80067da:	f89d c014 	ldrb.w	ip, [sp, #20]
  hhcd->hc[ch_num].ep_is_in = direction;
 80067de:	190d      	adds	r5, r1, r4
{
 80067e0:	9f06      	ldr	r7, [sp, #24]
 80067e2:	f8bd 601c 	ldrh.w	r6, [sp, #28]
  hhcd->hc[ch_num].ep_is_in = direction;
 80067e6:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
{
 80067ea:	f89d e020 	ldrb.w	lr, [sp, #32]
  hhcd->hc[ch_num].ep_is_in = direction;
 80067ee:	f885 203b 	strb.w	r2, [r5, #59]	; 0x3b
  hhcd->hc[ch_num].ep_type  = ep_type;
 80067f2:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f

  if (token == 0U)
 80067f6:	f1bc 0f00 	cmp.w	ip, #0
 80067fa:	d137      	bne.n	800686c <HAL_HCD_HC_SubmitRequest+0x98>
  {
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
    hhcd->hc[ch_num].do_ping = do_ping;
 80067fc:	f885 e03d 	strb.w	lr, [r5, #61]	; 0x3d
    hhcd->hc[ch_num].data_pid = HC_PID_SETUP;
 8006800:	f04f 0e03 	mov.w	lr, #3
 8006804:	190d      	adds	r5, r1, r4
 8006806:	eb00 05c5 	add.w	r5, r0, r5, lsl #3
 800680a:	f885 e042 	strb.w	lr, [r5, #66]	; 0x42
  {
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
  }

  /* Manage Data Toggle */
  switch (ep_type)
 800680e:	2b03      	cmp	r3, #3
 8006810:	d815      	bhi.n	800683e <HAL_HCD_HC_SubmitRequest+0x6a>
 8006812:	e8df f003 	tbb	[pc, r3]
 8006816:	3902      	.short	0x3902
 8006818:	2e2e      	.short	0x2e2e
  {
    case EP_TYPE_CTRL:
      if ((token == 1U) && (direction == 0U)) /*send data */
 800681a:	f1bc 0f01 	cmp.w	ip, #1
 800681e:	d10e      	bne.n	800683e <HAL_HCD_HC_SubmitRequest+0x6a>
 8006820:	b96a      	cbnz	r2, 800683e <HAL_HCD_HC_SubmitRequest+0x6a>
      {
        if (length == 0U)
        {
          /* For Status OUT stage, Length==0, Status Out PID = 1 */
          hhcd->hc[ch_num].toggle_out = 1U;
 8006822:	190b      	adds	r3, r1, r4
        if (length == 0U)
 8006824:	2e00      	cmp	r6, #0
 8006826:	d13e      	bne.n	80068a6 <HAL_HCD_HC_SubmitRequest+0xd2>
          hhcd->hc[ch_num].toggle_out = 1U;
 8006828:	2201      	movs	r2, #1
 800682a:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800682e:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
          hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
        }
        else
        {
          /* Put the PID 1 */
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8006832:	190b      	adds	r3, r1, r4
 8006834:	2202      	movs	r2, #2
 8006836:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 800683a:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42

    default:
      break;
  }

  hhcd->hc[ch_num].xfer_buff = pbuff;
 800683e:	190b      	adds	r3, r1, r4
  hhcd->hc[ch_num].urb_state = URB_IDLE;
  hhcd->hc[ch_num].xfer_count = 0U;
  hhcd->hc[ch_num].ch_num = ch_num;
  hhcd->hc[ch_num].state = HC_IDLE;

  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8006840:	2128      	movs	r1, #40	; 0x28
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8006842:	2200      	movs	r2, #0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 8006844:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8006848:	fb01 0104 	mla	r1, r1, r4, r0
  hhcd->hc[ch_num].xfer_buff = pbuff;
 800684c:	645f      	str	r7, [r3, #68]	; 0x44
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 800684e:	3138      	adds	r1, #56	; 0x38
  hhcd->hc[ch_num].xfer_len  = length;
 8006850:	649e      	str	r6, [r3, #72]	; 0x48
  hhcd->hc[ch_num].ch_num = ch_num;
 8006852:	f883 4039 	strb.w	r4, [r3, #57]	; 0x39
  hhcd->hc[ch_num].urb_state = URB_IDLE;
 8006856:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
  hhcd->hc[ch_num].xfer_count = 0U;
 800685a:	64da      	str	r2, [r3, #76]	; 0x4c
  hhcd->hc[ch_num].state = HC_IDLE;
 800685c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8006860:	7c02      	ldrb	r2, [r0, #16]
 8006862:	6800      	ldr	r0, [r0, #0]
}
 8006864:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  return USB_HC_StartXfer(hhcd->Instance, &hhcd->hc[ch_num], (uint8_t)hhcd->Init.dma_enable);
 8006868:	f00a b886 	b.w	8010978 <USB_HC_StartXfer>
    hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800686c:	f04f 0e02 	mov.w	lr, #2
 8006870:	e7c8      	b.n	8006804 <HAL_HCD_HC_SubmitRequest+0x30>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 8006872:	190b      	adds	r3, r1, r4
 8006874:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
      if (direction == 0U)
 8006878:	b96a      	cbnz	r2, 8006896 <HAL_HCD_HC_SubmitRequest+0xc2>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 800687a:	f893 5051 	ldrb.w	r5, [r3, #81]	; 0x51
 800687e:	b13d      	cbz	r5, 8006890 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 8006880:	2202      	movs	r2, #2
 8006882:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 8006886:	e7da      	b.n	800683e <HAL_HCD_HC_SubmitRequest+0x6a>
      hhcd->hc[ch_num].data_pid = HC_PID_DATA0;
 8006888:	190b      	adds	r3, r1, r4
 800688a:	2200      	movs	r2, #0
 800688c:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 8006890:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
      break;
 8006894:	e7d3      	b.n	800683e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_in == 0U)
 8006896:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 800689a:	2a00      	cmp	r2, #0
 800689c:	d0f8      	beq.n	8006890 <HAL_HCD_HC_SubmitRequest+0xbc>
          hhcd->hc[ch_num].data_pid = HC_PID_DATA1;
 800689e:	2202      	movs	r2, #2
 80068a0:	f883 2042 	strb.w	r2, [r3, #66]	; 0x42
 80068a4:	e7cb      	b.n	800683e <HAL_HCD_HC_SubmitRequest+0x6a>
        if (hhcd->hc[ch_num].toggle_out == 0U)
 80068a6:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 80068aa:	f893 2051 	ldrb.w	r2, [r3, #81]	; 0x51
 80068ae:	2a00      	cmp	r2, #0
 80068b0:	d0ee      	beq.n	8006890 <HAL_HCD_HC_SubmitRequest+0xbc>
 80068b2:	e7be      	b.n	8006832 <HAL_HCD_HC_SubmitRequest+0x5e>

080068b4 <HAL_HCD_IRQHandler>:




void HAL_HCD_IRQHandler(HCD_HandleTypeDef *hhcd)
{
 80068b4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 80068b8:	6805      	ldr	r5, [r0, #0]
{
 80068ba:	b085      	sub	sp, #20
 80068bc:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i, interrupt;


  /* Ensure that we are in device mode */
  if (USB_GetMode(hhcd->Instance) == USB_OTG_MODE_HOST)
 80068be:	4628      	mov	r0, r5
 80068c0:	f009 fea6 	bl	8010610 <USB_GetMode>
 80068c4:	2801      	cmp	r0, #1
 80068c6:	d002      	beq.n	80068ce <HAL_HCD_IRQHandler+0x1a>
      HCD_RXQLVL_IRQHandler(hhcd);

      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
    }
  }
}
 80068c8:	b005      	add	sp, #20
 80068ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (__HAL_HCD_IS_INVALID_INTERRUPT(hhcd))
 80068ce:	6820      	ldr	r0, [r4, #0]
 80068d0:	f009 fe9a 	bl	8010608 <USB_ReadInterrupts>
 80068d4:	2800      	cmp	r0, #0
 80068d6:	d0f7      	beq.n	80068c8 <HAL_HCD_IRQHandler+0x14>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT))
 80068d8:	6820      	ldr	r0, [r4, #0]
 80068da:	f009 fe95 	bl	8010608 <USB_ReadInterrupts>
 80068de:	0286      	lsls	r6, r0, #10
 80068e0:	d503      	bpl.n	80068ea <HAL_HCD_IRQHandler+0x36>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PXFR_INCOMPISOOUT);
 80068e2:	6823      	ldr	r3, [r4, #0]
 80068e4:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
 80068e8:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR))
 80068ea:	6820      	ldr	r0, [r4, #0]
 80068ec:	f009 fe8c 	bl	8010608 <USB_ReadInterrupts>
 80068f0:	02c0      	lsls	r0, r0, #11
 80068f2:	d503      	bpl.n	80068fc <HAL_HCD_IRQHandler+0x48>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_IISOIXFR);
 80068f4:	6823      	ldr	r3, [r4, #0]
 80068f6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80068fa:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE))
 80068fc:	6820      	ldr	r0, [r4, #0]
 80068fe:	f009 fe83 	bl	8010608 <USB_ReadInterrupts>
 8006902:	0141      	lsls	r1, r0, #5
 8006904:	d503      	bpl.n	800690e <HAL_HCD_IRQHandler+0x5a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_PTXFE);
 8006906:	6823      	ldr	r3, [r4, #0]
 8006908:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800690c:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_MMIS))
 800690e:	6820      	ldr	r0, [r4, #0]
 8006910:	f009 fe7a 	bl	8010608 <USB_ReadInterrupts>
 8006914:	0782      	lsls	r2, r0, #30
 8006916:	d502      	bpl.n	800691e <HAL_HCD_IRQHandler+0x6a>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_MMIS);
 8006918:	6823      	ldr	r3, [r4, #0]
 800691a:	2202      	movs	r2, #2
 800691c:	615a      	str	r2, [r3, #20]
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT))
 800691e:	6820      	ldr	r0, [r4, #0]
 8006920:	f009 fe72 	bl	8010608 <USB_ReadInterrupts>
 8006924:	0083      	lsls	r3, r0, #2
 8006926:	d453      	bmi.n	80069d0 <HAL_HCD_IRQHandler+0x11c>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HPRTINT))
 8006928:	6820      	ldr	r0, [r4, #0]
 800692a:	f009 fe6d 	bl	8010608 <USB_ReadInterrupts>
 800692e:	01c6      	lsls	r6, r0, #7
 8006930:	f100 80da 	bmi.w	8006ae8 <HAL_HCD_IRQHandler+0x234>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_SOF))
 8006934:	6820      	ldr	r0, [r4, #0]
 8006936:	f009 fe67 	bl	8010608 <USB_ReadInterrupts>
 800693a:	0700      	lsls	r0, r0, #28
 800693c:	f100 80cd 	bmi.w	8006ada <HAL_HCD_IRQHandler+0x226>
    if (__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_HCINT))
 8006940:	6820      	ldr	r0, [r4, #0]
 8006942:	f009 fe61 	bl	8010608 <USB_ReadInterrupts>
 8006946:	0181      	lsls	r1, r0, #6
 8006948:	d452      	bmi.n	80069f0 <HAL_HCD_IRQHandler+0x13c>
    if ((__HAL_HCD_GET_FLAG(hhcd, USB_OTG_GINTSTS_RXFLVL)) != 0U)
 800694a:	6820      	ldr	r0, [r4, #0]
 800694c:	f009 fe5c 	bl	8010608 <USB_ReadInterrupts>
 8006950:	06c3      	lsls	r3, r0, #27
 8006952:	d5b9      	bpl.n	80068c8 <HAL_HCD_IRQHandler+0x14>
      USB_MASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 8006954:	6822      	ldr	r2, [r4, #0]
 8006956:	6993      	ldr	r3, [r2, #24]
 8006958:	f023 0310 	bic.w	r3, r3, #16
 800695c:	6193      	str	r3, [r2, #24]
  * @param  hhcd HCD handle
  * @retval none
  */
static void HCD_RXQLVL_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
 800695e:	6825      	ldr	r5, [r4, #0]
  uint32_t pktcnt;
  uint32_t temp;
  uint32_t tmpreg;
  uint32_t ch_num;

  temp = hhcd->Instance->GRXSTSP;
 8006960:	6a2e      	ldr	r6, [r5, #32]
  ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
  pktsts = (temp & USB_OTG_GRXSTSP_PKTSTS) >> 17;
 8006962:	f3c6 4243 	ubfx	r2, r6, #17, #4
  pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;

  switch (pktsts)
 8006966:	2a02      	cmp	r2, #2
 8006968:	d12d      	bne.n	80069c6 <HAL_HCD_IRQHandler+0x112>
  pktcnt = (temp & USB_OTG_GRXSTSP_BCNT) >> 4;
 800696a:	f3c6 180a 	ubfx	r8, r6, #4, #11
  {
    case GRXSTS_PKTSTS_IN:
      /* Read the data into the host buffer. */
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 800696e:	f1b8 0f00 	cmp.w	r8, #0
 8006972:	d028      	beq.n	80069c6 <HAL_HCD_IRQHandler+0x112>
  ch_num = temp & USB_OTG_GRXSTSP_EPNUM;
 8006974:	f006 060f 	and.w	r6, r6, #15
      if ((pktcnt > 0U) && (hhcd->hc[ch_num].xfer_buff != (void *)0))
 8006978:	eb06 0786 	add.w	r7, r6, r6, lsl #2
 800697c:	eb04 07c7 	add.w	r7, r4, r7, lsl #3
 8006980:	6c79      	ldr	r1, [r7, #68]	; 0x44
 8006982:	b301      	cbz	r1, 80069c6 <HAL_HCD_IRQHandler+0x112>
      {
        (void)USB_ReadPacket(hhcd->Instance, hhcd->hc[ch_num].xfer_buff, (uint16_t)pktcnt);
 8006984:	4642      	mov	r2, r8
 8006986:	4628      	mov	r0, r5
 8006988:	f009 fe2a 	bl	80105e0 <USB_ReadPacket>

        /*manage multiple Xfer */
        hhcd->hc[ch_num].xfer_buff += pktcnt;
        hhcd->hc[ch_num].xfer_count  += pktcnt;

        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 800698c:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8006990:	6c78      	ldr	r0, [r7, #68]	; 0x44
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8006992:	0173      	lsls	r3, r6, #5
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 8006994:	6cf9      	ldr	r1, [r7, #76]	; 0x4c
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 8006996:	2200      	movs	r2, #0
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 8006998:	4440      	add	r0, r8
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 800699a:	18ee      	adds	r6, r5, r3
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 800699c:	4441      	add	r1, r8
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 800699e:	f6c1 72f8 	movt	r2, #8184	; 0x1ff8
        hhcd->hc[ch_num].xfer_buff += pktcnt;
 80069a2:	6478      	str	r0, [r7, #68]	; 0x44
        hhcd->hc[ch_num].xfer_count  += pktcnt;
 80069a4:	64f9      	str	r1, [r7, #76]	; 0x4c
        if ((USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_PKTCNT) > 0U)
 80069a6:	6931      	ldr	r1, [r6, #16]
 80069a8:	400a      	ands	r2, r1
 80069aa:	b15a      	cbz	r2, 80069c4 <HAL_HCD_IRQHandler+0x110>
        {
          /* re-activate the channel when more packets are expected */
          tmpreg = USBx_HC(ch_num)->HCCHAR;
 80069ac:	58ea      	ldr	r2, [r5, r3]
          tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 80069ae:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
          tmpreg |= USB_OTG_HCCHAR_CHENA;
 80069b2:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
          USBx_HC(ch_num)->HCCHAR = tmpreg;
 80069b6:	50ea      	str	r2, [r5, r3]
          hhcd->hc[ch_num].toggle_in ^= 1U;
 80069b8:	f897 3050 	ldrb.w	r3, [r7, #80]	; 0x50
 80069bc:	f083 0301 	eor.w	r3, r3, #1
 80069c0:	f887 3050 	strb.w	r3, [r7, #80]	; 0x50
 80069c4:	6825      	ldr	r5, [r4, #0]
      USB_UNMASK_INTERRUPT(hhcd->Instance, USB_OTG_GINTSTS_RXFLVL);
 80069c6:	69ab      	ldr	r3, [r5, #24]
 80069c8:	f043 0310 	orr.w	r3, r3, #16
 80069cc:	61ab      	str	r3, [r5, #24]
 80069ce:	e77b      	b.n	80068c8 <HAL_HCD_IRQHandler+0x14>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_DISCINT);
 80069d0:	6823      	ldr	r3, [r4, #0]
 80069d2:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
 80069d6:	615a      	str	r2, [r3, #20]
      if ((USBx_HPRT0 & USB_OTG_HPRT_PCSTS) == 0U)
 80069d8:	f8d5 3440 	ldr.w	r3, [r5, #1088]	; 0x440
 80069dc:	07df      	lsls	r7, r3, #31
 80069de:	d4a3      	bmi.n	8006928 <HAL_HCD_IRQHandler+0x74>
        HAL_HCD_Disconnect_Callback(hhcd);
 80069e0:	4620      	mov	r0, r4
 80069e2:	f01a ffc5 	bl	8021970 <HAL_HCD_Disconnect_Callback>
        (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 80069e6:	2101      	movs	r1, #1
 80069e8:	6820      	ldr	r0, [r4, #0]
 80069ea:	f009 feab 	bl	8010744 <USB_InitFSLSPClkSel>
 80069ee:	e79b      	b.n	8006928 <HAL_HCD_IRQHandler+0x74>
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 80069f0:	6820      	ldr	r0, [r4, #0]
 80069f2:	f00a f87d 	bl	8010af0 <USB_HC_ReadInterrupt>
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 80069f6:	68a1      	ldr	r1, [r4, #8]
      interrupt = USB_HC_ReadInterrupt(hhcd->Instance);
 80069f8:	4681      	mov	r9, r0
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 80069fa:	2900      	cmp	r1, #0
 80069fc:	f000 80ae 	beq.w	8006b5c <HAL_HCD_IRQHandler+0x2a8>
 8006a00:	f505 65a0 	add.w	r5, r5, #1280	; 0x500
 8006a04:	6820      	ldr	r0, [r4, #0]
 8006a06:	2600      	movs	r6, #0
 8006a08:	e03d      	b.n	8006a86 <HAL_HCD_IRQHandler+0x1d2>
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8006a0a:	075b      	lsls	r3, r3, #29
 8006a0c:	f140 80ab 	bpl.w	8006b66 <HAL_HCD_IRQHandler+0x2b2>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8006a10:	2304      	movs	r3, #4
 8006a12:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006a14:	68fb      	ldr	r3, [r7, #12]
 8006a16:	f043 0302 	orr.w	r3, r3, #2
 8006a1a:	60fb      	str	r3, [r7, #12]
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8006a1c:	68bb      	ldr	r3, [r7, #8]
 8006a1e:	059b      	lsls	r3, r3, #22
 8006a20:	f100 80dd 	bmi.w	8006bde <HAL_HCD_IRQHandler+0x32a>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8006a24:	68bb      	ldr	r3, [r7, #8]
 8006a26:	07d8      	lsls	r0, r3, #31
 8006a28:	f140 80ac 	bpl.w	8006b84 <HAL_HCD_IRQHandler+0x2d0>
    if (hhcd->Init.dma_enable != 0U)
 8006a2c:	6923      	ldr	r3, [r4, #16]
 8006a2e:	2b00      	cmp	r3, #0
 8006a30:	f040 8135 	bne.w	8006c9e <HAL_HCD_IRQHandler+0x3ea>
 8006a34:	ea4f 0388 	mov.w	r3, r8, lsl #2
    hhcd->hc[ch_num].state = HC_XFRC;
 8006a38:	eb03 0c08 	add.w	ip, r3, r8
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006a3c:	2200      	movs	r2, #0
    hhcd->hc[ch_num].state = HC_XFRC;
 8006a3e:	f04f 0e01 	mov.w	lr, #1
 8006a42:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006a46:	f8cc 2058 	str.w	r2, [ip, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_XFRC;
 8006a4a:	f88c e05d 	strb.w	lr, [ip, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8006a4e:	f8c7 e008 	str.w	lr, [r7, #8]
    if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8006a52:	f89c 203f 	ldrb.w	r2, [ip, #63]	; 0x3f
 8006a56:	f012 0ffd 	tst.w	r2, #253	; 0xfd
 8006a5a:	f000 815b 	beq.w	8006d14 <HAL_HCD_IRQHandler+0x460>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8006a5e:	2a03      	cmp	r2, #3
 8006a60:	f000 81ca 	beq.w	8006df8 <HAL_HCD_IRQHandler+0x544>
    else if (hhcd->hc[ch_num].ep_type == EP_TYPE_ISOC)
 8006a64:	2a01      	cmp	r2, #1
 8006a66:	f000 81d7 	beq.w	8006e18 <HAL_HCD_IRQHandler+0x564>
    hhcd->hc[ch_num].toggle_in ^= 1U;
 8006a6a:	4443      	add	r3, r8
 8006a6c:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8006a70:	f893 2050 	ldrb.w	r2, [r3, #80]	; 0x50
 8006a74:	f082 0201 	eor.w	r2, r2, #1
 8006a78:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
 8006a7c:	68a1      	ldr	r1, [r4, #8]
 8006a7e:	6820      	ldr	r0, [r4, #0]
      for (i = 0U; i < hhcd->Init.Host_channels; i++)
 8006a80:	3601      	adds	r6, #1
 8006a82:	428e      	cmp	r6, r1
 8006a84:	d26b      	bcs.n	8006b5e <HAL_HCD_IRQHandler+0x2aa>
        if ((interrupt & (1UL << (i & 0xFU))) != 0U)
 8006a86:	f006 030f 	and.w	r3, r6, #15
 8006a8a:	fa29 f303 	lsr.w	r3, r9, r3
 8006a8e:	07da      	lsls	r2, r3, #31
 8006a90:	d5f6      	bpl.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
 8006a92:	fa5f f886 	uxtb.w	r8, r6
 8006a96:	f500 6aa0 	add.w	sl, r0, #1280	; 0x500
 8006a9a:	0173      	lsls	r3, r6, #5
 8006a9c:	ea4f 1b48 	mov.w	fp, r8, lsl #5
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8006aa0:	58eb      	ldr	r3, [r5, r3]
 8006aa2:	eb0b 070a 	add.w	r7, fp, sl
 8006aa6:	f413 4f00 	tst.w	r3, #32768	; 0x8000
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8006aaa:	68bb      	ldr	r3, [r7, #8]
          if ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_EPDIR) == USB_OTG_HCCHAR_EPDIR)
 8006aac:	d1ad      	bne.n	8006a0a <HAL_HCD_IRQHandler+0x156>
  if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_AHBERR) == USB_OTG_HCINT_AHBERR)
 8006aae:	f013 0304 	ands.w	r3, r3, #4
 8006ab2:	d15e      	bne.n	8006b72 <HAL_HCD_IRQHandler+0x2be>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 8006ab4:	68ba      	ldr	r2, [r7, #8]
 8006ab6:	f012 0220 	ands.w	r2, r2, #32
 8006aba:	f000 809e 	beq.w	8006bfa <HAL_HCD_IRQHandler+0x346>
    if (hhcd->hc[ch_num].do_ping == 1U)
 8006abe:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8006ac2:	2120      	movs	r1, #32
    if (hhcd->hc[ch_num].do_ping == 1U)
 8006ac4:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8006ac8:	60b9      	str	r1, [r7, #8]
    if (hhcd->hc[ch_num].do_ping == 1U)
 8006aca:	f892 103d 	ldrb.w	r1, [r2, #61]	; 0x3d
 8006ace:	2901      	cmp	r1, #1
 8006ad0:	f000 816a 	beq.w	8006da8 <HAL_HCD_IRQHandler+0x4f4>
 8006ad4:	68a1      	ldr	r1, [r4, #8]
 8006ad6:	6820      	ldr	r0, [r4, #0]
 8006ad8:	e7d2      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
      HAL_HCD_SOF_Callback(hhcd);
 8006ada:	4620      	mov	r0, r4
 8006adc:	f01a ff40 	bl	8021960 <HAL_HCD_SOF_Callback>
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_SOF);
 8006ae0:	6823      	ldr	r3, [r4, #0]
 8006ae2:	2208      	movs	r2, #8
 8006ae4:	615a      	str	r2, [r3, #20]
 8006ae6:	e72b      	b.n	8006940 <HAL_HCD_IRQHandler+0x8c>
  * @retval None
  */
static void HCD_Port_IRQHandler(HCD_HandleTypeDef *hhcd)
{
  USB_OTG_GlobalTypeDef *USBx = hhcd->Instance;
  uint32_t USBx_BASE = (uint32_t)USBx;
 8006ae8:	6826      	ldr	r6, [r4, #0]
  __IO uint32_t hprt0, hprt0_dup;

  /* Handle Host Port Interrupts */
  hprt0 = USBx_HPRT0;
 8006aea:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 8006aee:	9302      	str	r3, [sp, #8]
  hprt0_dup = USBx_HPRT0;
 8006af0:	f8d6 3440 	ldr.w	r3, [r6, #1088]	; 0x440
 8006af4:	9303      	str	r3, [sp, #12]

  hprt0_dup &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET | \
 8006af6:	9b03      	ldr	r3, [sp, #12]
 8006af8:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 8006afc:	9303      	str	r3, [sp, #12]
                 USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  /* Check whether Port Connect detected */
  if ((hprt0 & USB_OTG_HPRT_PCDET) == USB_OTG_HPRT_PCDET)
 8006afe:	9b02      	ldr	r3, [sp, #8]
 8006b00:	0798      	lsls	r0, r3, #30
 8006b02:	d507      	bpl.n	8006b14 <HAL_HCD_IRQHandler+0x260>
  {
    if ((hprt0 & USB_OTG_HPRT_PCSTS) == USB_OTG_HPRT_PCSTS)
 8006b04:	9b02      	ldr	r3, [sp, #8]
 8006b06:	07d9      	lsls	r1, r3, #31
 8006b08:	f100 80fc 	bmi.w	8006d04 <HAL_HCD_IRQHandler+0x450>
      hhcd->ConnectCallback(hhcd);
#else
      HAL_HCD_Connect_Callback(hhcd);
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
    hprt0_dup  |= USB_OTG_HPRT_PCDET;
 8006b0c:	9b03      	ldr	r3, [sp, #12]
 8006b0e:	f043 0302 	orr.w	r3, r3, #2
 8006b12:	9303      	str	r3, [sp, #12]
  }

  /* Check whether Port Enable Changed */
  if ((hprt0 & USB_OTG_HPRT_PENCHNG) == USB_OTG_HPRT_PENCHNG)
 8006b14:	9b02      	ldr	r3, [sp, #8]
 8006b16:	071a      	lsls	r2, r3, #28
 8006b18:	d515      	bpl.n	8006b46 <HAL_HCD_IRQHandler+0x292>
  {
    hprt0_dup |= USB_OTG_HPRT_PENCHNG;
 8006b1a:	9b03      	ldr	r3, [sp, #12]
 8006b1c:	f043 0308 	orr.w	r3, r3, #8
 8006b20:	9303      	str	r3, [sp, #12]

    if ((hprt0 & USB_OTG_HPRT_PENA) == USB_OTG_HPRT_PENA)
 8006b22:	9b02      	ldr	r3, [sp, #8]
 8006b24:	075b      	lsls	r3, r3, #29
 8006b26:	f140 80f1 	bpl.w	8006d0c <HAL_HCD_IRQHandler+0x458>
    {
      if (hhcd->Init.phy_itface  == USB_OTG_EMBEDDED_PHY)
 8006b2a:	69a1      	ldr	r1, [r4, #24]
 8006b2c:	2902      	cmp	r1, #2
 8006b2e:	f000 8101 	beq.w	8006d34 <HAL_HCD_IRQHandler+0x480>
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
        }
      }
      else
      {
        if (hhcd->Init.speed == HCD_SPEED_FULL)
 8006b32:	68e3      	ldr	r3, [r4, #12]
 8006b34:	2b01      	cmp	r3, #1
 8006b36:	d103      	bne.n	8006b40 <HAL_HCD_IRQHandler+0x28c>
        {
          USBx_HOST->HFIR = 60000U;
 8006b38:	f64e 2260 	movw	r2, #60000	; 0xea60
 8006b3c:	f8c6 2404 	str.w	r2, [r6, #1028]	; 0x404
        }
      }
#if (USE_HAL_HCD_REGISTER_CALLBACKS == 1U)
      hhcd->PortEnabledCallback(hhcd);
#else
      HAL_HCD_PortEnabled_Callback(hhcd);
 8006b40:	4620      	mov	r0, r4
 8006b42:	f01a ff1b 	bl	802197c <HAL_HCD_PortEnabled_Callback>
#endif /* USE_HAL_HCD_REGISTER_CALLBACKS */
    }
  }

  /* Check for an overcurrent */
  if ((hprt0 & USB_OTG_HPRT_POCCHNG) == USB_OTG_HPRT_POCCHNG)
 8006b46:	9b02      	ldr	r3, [sp, #8]
 8006b48:	069f      	lsls	r7, r3, #26
 8006b4a:	d503      	bpl.n	8006b54 <HAL_HCD_IRQHandler+0x2a0>
  {
    hprt0_dup |= USB_OTG_HPRT_POCCHNG;
 8006b4c:	9b03      	ldr	r3, [sp, #12]
 8006b4e:	f043 0320 	orr.w	r3, r3, #32
 8006b52:	9303      	str	r3, [sp, #12]
  }

  /* Clear Port Interrupts */
  USBx_HPRT0 = hprt0_dup;
 8006b54:	9b03      	ldr	r3, [sp, #12]
 8006b56:	f8c6 3440 	str.w	r3, [r6, #1088]	; 0x440
 8006b5a:	e6eb      	b.n	8006934 <HAL_HCD_IRQHandler+0x80>
 8006b5c:	6820      	ldr	r0, [r4, #0]
      __HAL_HCD_CLEAR_FLAG(hhcd, USB_OTG_GINTSTS_HCINT);
 8006b5e:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8006b62:	6143      	str	r3, [r0, #20]
 8006b64:	e6f1      	b.n	800694a <HAL_HCD_IRQHandler+0x96>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_ACK) == USB_OTG_HCINT_ACK)
 8006b66:	68bb      	ldr	r3, [r7, #8]
 8006b68:	0698      	lsls	r0, r3, #26
 8006b6a:	d57c      	bpl.n	8006c66 <HAL_HCD_IRQHandler+0x3b2>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_ACK);
 8006b6c:	2320      	movs	r3, #32
 8006b6e:	60bb      	str	r3, [r7, #8]
 8006b70:	e754      	b.n	8006a1c <HAL_HCD_IRQHandler+0x168>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_AHBERR);
 8006b72:	2304      	movs	r3, #4
 8006b74:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006b76:	68fb      	ldr	r3, [r7, #12]
 8006b78:	f043 0302 	orr.w	r3, r3, #2
 8006b7c:	60fb      	str	r3, [r7, #12]
 8006b7e:	68a1      	ldr	r1, [r4, #8]
 8006b80:	6820      	ldr	r0, [r4, #0]
 8006b82:	e77d      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 8006b84:	68bb      	ldr	r3, [r7, #8]
 8006b86:	0799      	lsls	r1, r3, #30
 8006b88:	f140 8096 	bpl.w	8006cb8 <HAL_HCD_IRQHandler+0x404>
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006b8c:	ea4f 0388 	mov.w	r3, r8, lsl #2
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006b90:	68f9      	ldr	r1, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006b92:	eb03 0208 	add.w	r2, r3, r8
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006b96:	f021 0102 	bic.w	r1, r1, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006b9a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006b9e:	60f9      	str	r1, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006ba0:	f892 105d 	ldrb.w	r1, [r2, #93]	; 0x5d
 8006ba4:	2901      	cmp	r1, #1
 8006ba6:	f000 80c2 	beq.w	8006d2e <HAL_HCD_IRQHandler+0x47a>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8006baa:	2905      	cmp	r1, #5
 8006bac:	f000 80bf 	beq.w	8006d2e <HAL_HCD_IRQHandler+0x47a>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8006bb0:	2906      	cmp	r1, #6
 8006bb2:	f000 814f 	beq.w	8006e54 <HAL_HCD_IRQHandler+0x5a0>
 8006bb6:	2908      	cmp	r1, #8
 8006bb8:	f000 814c 	beq.w	8006e54 <HAL_HCD_IRQHandler+0x5a0>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8006bbc:	2903      	cmp	r1, #3
 8006bbe:	f000 81ac 	beq.w	8006f1a <HAL_HCD_IRQHandler+0x666>
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006bc2:	4443      	add	r3, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8006bc4:	2202      	movs	r2, #2
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006bc6:	4641      	mov	r1, r8
 8006bc8:	4620      	mov	r0, r4
 8006bca:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8006bce:	60ba      	str	r2, [r7, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006bd0:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 8006bd4:	f01a fed0 	bl	8021978 <HAL_HCD_HC_NotifyURBChange_Callback>
 8006bd8:	68a1      	ldr	r1, [r4, #8]
 8006bda:	6820      	ldr	r0, [r4, #0]
 8006bdc:	e750      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006bde:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006be0:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006be2:	f043 0302 	orr.w	r3, r3, #2
 8006be6:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006be8:	6820      	ldr	r0, [r4, #0]
 8006bea:	f009 ff87 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_FRMOR);
 8006bee:	f44f 7300 	mov.w	r3, #512	; 0x200
 8006bf2:	60bb      	str	r3, [r7, #8]
 8006bf4:	68a1      	ldr	r1, [r4, #8]
 8006bf6:	6820      	ldr	r0, [r4, #0]
 8006bf8:	e742      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NYET) == USB_OTG_HCINT_NYET)
 8006bfa:	68bb      	ldr	r3, [r7, #8]
 8006bfc:	065b      	lsls	r3, r3, #25
 8006bfe:	f100 80ba 	bmi.w	8006d76 <HAL_HCD_IRQHandler+0x4c2>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_FRMOR) == USB_OTG_HCINT_FRMOR)
 8006c02:	68bb      	ldr	r3, [r7, #8]
 8006c04:	f413 7300 	ands.w	r3, r3, #512	; 0x200
 8006c08:	d1e9      	bne.n	8006bde <HAL_HCD_IRQHandler+0x32a>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_XFRC) == USB_OTG_HCINT_XFRC)
 8006c0a:	68ba      	ldr	r2, [r7, #8]
 8006c0c:	07d2      	lsls	r2, r2, #31
 8006c0e:	f100 810c 	bmi.w	8006e2a <HAL_HCD_IRQHandler+0x576>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8006c12:	68bb      	ldr	r3, [r7, #8]
 8006c14:	f013 0308 	ands.w	r3, r3, #8
 8006c18:	f040 8164 	bne.w	8006ee4 <HAL_HCD_IRQHandler+0x630>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8006c1c:	68ba      	ldr	r2, [r7, #8]
 8006c1e:	06d2      	lsls	r2, r2, #27
 8006c20:	f140 8134 	bpl.w	8006e8c <HAL_HCD_IRQHandler+0x5d8>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006c24:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    hhcd->hc[ch_num].state = HC_NAK;
 8006c28:	2103      	movs	r1, #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006c2a:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8006c2e:	6593      	str	r3, [r2, #88]	; 0x58
    if (hhcd->hc[ch_num].do_ping == 0U)
 8006c30:	f892 303d 	ldrb.w	r3, [r2, #61]	; 0x3d
    hhcd->hc[ch_num].state = HC_NAK;
 8006c34:	f882 105d 	strb.w	r1, [r2, #93]	; 0x5d
    if (hhcd->hc[ch_num].do_ping == 0U)
 8006c38:	b943      	cbnz	r3, 8006c4c <HAL_HCD_IRQHandler+0x398>
      if (hhcd->hc[ch_num].speed == HCD_SPEED_HIGH)
 8006c3a:	2328      	movs	r3, #40	; 0x28
 8006c3c:	fb03 4308 	mla	r3, r3, r8, r4
 8006c40:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
 8006c44:	b912      	cbnz	r2, 8006c4c <HAL_HCD_IRQHandler+0x398>
        hhcd->hc[ch_num].do_ping = 1U;
 8006c46:	2201      	movs	r2, #1
 8006c48:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006c4c:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006c4e:	4641      	mov	r1, r8
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006c50:	f043 0302 	orr.w	r3, r3, #2
 8006c54:	60fb      	str	r3, [r7, #12]
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006c56:	6820      	ldr	r0, [r4, #0]
 8006c58:	f009 ff50 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006c5c:	2310      	movs	r3, #16
 8006c5e:	60bb      	str	r3, [r7, #8]
 8006c60:	68a1      	ldr	r1, [r4, #8]
 8006c62:	6820      	ldr	r0, [r4, #0]
 8006c64:	e70c      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_STALL) == USB_OTG_HCINT_STALL)
 8006c66:	68bb      	ldr	r3, [r7, #8]
 8006c68:	0719      	lsls	r1, r3, #28
 8006c6a:	d46e      	bmi.n	8006d4a <HAL_HCD_IRQHandler+0x496>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8006c6c:	68bb      	ldr	r3, [r7, #8]
 8006c6e:	055a      	lsls	r2, r3, #21
 8006c70:	f57f aed4 	bpl.w	8006a1c <HAL_HCD_IRQHandler+0x168>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006c74:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006c76:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006c78:	f043 0302 	orr.w	r3, r3, #2
 8006c7c:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006c7e:	6820      	ldr	r0, [r4, #0]
 8006c80:	f009 ff3c 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006c84:	2210      	movs	r2, #16
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006c86:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8006c8a:	2108      	movs	r1, #8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006c8c:	60ba      	str	r2, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8006c8e:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006c92:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
 8006c96:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8006c9a:	60ba      	str	r2, [r7, #8]
 8006c9c:	e6be      	b.n	8006a1c <HAL_HCD_IRQHandler+0x168>
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8006c9e:	ea4f 0388 	mov.w	r3, r8, lsl #2
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8006ca2:	6938      	ldr	r0, [r7, #16]
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8006ca4:	eb03 0208 	add.w	r2, r3, r8
                                    (USBx_HC(ch_num)->HCTSIZ & USB_OTG_HCTSIZ_XFRSIZ);
 8006ca8:	f3c0 0012 	ubfx	r0, r0, #0, #19
      hhcd->hc[ch_num].xfer_count = hhcd->hc[ch_num].xfer_len - \
 8006cac:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8006cb0:	6c91      	ldr	r1, [r2, #72]	; 0x48
 8006cb2:	1a09      	subs	r1, r1, r0
 8006cb4:	64d1      	str	r1, [r2, #76]	; 0x4c
 8006cb6:	e6bf      	b.n	8006a38 <HAL_HCD_IRQHandler+0x184>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8006cb8:	68bb      	ldr	r3, [r7, #8]
 8006cba:	f013 0380 	ands.w	r3, r3, #128	; 0x80
 8006cbe:	f040 8084 	bne.w	8006dca <HAL_HCD_IRQHandler+0x516>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_NAK) == USB_OTG_HCINT_NAK)
 8006cc2:	68ba      	ldr	r2, [r7, #8]
 8006cc4:	06d2      	lsls	r2, r2, #27
 8006cc6:	f57f af05 	bpl.w	8006ad4 <HAL_HCD_IRQHandler+0x220>
    if (hhcd->hc[ch_num].ep_type == EP_TYPE_INTR)
 8006cca:	eb08 0188 	add.w	r1, r8, r8, lsl #2
 8006cce:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 8006cd2:	f891 203f 	ldrb.w	r2, [r1, #63]	; 0x3f
 8006cd6:	2a03      	cmp	r2, #3
 8006cd8:	f000 8125 	beq.w	8006f26 <HAL_HCD_IRQHandler+0x672>
    else if ((hhcd->hc[ch_num].ep_type == EP_TYPE_CTRL) ||
 8006cdc:	f012 02fd 	ands.w	r2, r2, #253	; 0xfd
 8006ce0:	d1bc      	bne.n	8006c5c <HAL_HCD_IRQHandler+0x3a8>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8006ce2:	658a      	str	r2, [r1, #88]	; 0x58
      __HAL_HCD_MASK_NAK_HC_INT(ch_num);
 8006ce4:	68fb      	ldr	r3, [r7, #12]
 8006ce6:	f023 0310 	bic.w	r3, r3, #16
 8006cea:	60fb      	str	r3, [r7, #12]
      if (hhcd->Init.dma_enable == 0U)
 8006cec:	6923      	ldr	r3, [r4, #16]
 8006cee:	2b00      	cmp	r3, #0
 8006cf0:	d1b4      	bne.n	8006c5c <HAL_HCD_IRQHandler+0x3a8>
        hhcd->hc[ch_num].state = HC_NAK;
 8006cf2:	2328      	movs	r3, #40	; 0x28
 8006cf4:	2203      	movs	r2, #3
        (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006cf6:	4641      	mov	r1, r8
        hhcd->hc[ch_num].state = HC_NAK;
 8006cf8:	fb03 4308 	mla	r3, r3, r8, r4
 8006cfc:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
        __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d00:	68fb      	ldr	r3, [r7, #12]
 8006d02:	e7a5      	b.n	8006c50 <HAL_HCD_IRQHandler+0x39c>
      HAL_HCD_Connect_Callback(hhcd);
 8006d04:	4620      	mov	r0, r4
 8006d06:	f01a fe2f 	bl	8021968 <HAL_HCD_Connect_Callback>
 8006d0a:	e6ff      	b.n	8006b0c <HAL_HCD_IRQHandler+0x258>
      HAL_HCD_PortDisabled_Callback(hhcd);
 8006d0c:	4620      	mov	r0, r4
 8006d0e:	f01a fe39 	bl	8021984 <HAL_HCD_PortDisabled_Callback>
 8006d12:	e718      	b.n	8006b46 <HAL_HCD_IRQHandler+0x292>
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d14:	68fa      	ldr	r2, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d16:	4641      	mov	r1, r8
 8006d18:	9301      	str	r3, [sp, #4]
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d1a:	f042 0202 	orr.w	r2, r2, #2
 8006d1e:	60fa      	str	r2, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d20:	6820      	ldr	r0, [r4, #0]
 8006d22:	f009 feeb 	bl	8010afc <USB_HC_Halt>
      __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006d26:	2210      	movs	r2, #16
 8006d28:	9b01      	ldr	r3, [sp, #4]
 8006d2a:	60ba      	str	r2, [r7, #8]
 8006d2c:	e69d      	b.n	8006a6a <HAL_HCD_IRQHandler+0x1b6>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8006d2e:	f882 105c 	strb.w	r1, [r2, #92]	; 0x5c
 8006d32:	e746      	b.n	8006bc2 <HAL_HCD_IRQHandler+0x30e>
        if ((hprt0 & USB_OTG_HPRT_PSPD) == (HPRT0_PRTSPD_LOW_SPEED << 17))
 8006d34:	9b02      	ldr	r3, [sp, #8]
 8006d36:	6820      	ldr	r0, [r4, #0]
 8006d38:	f403 23c0 	and.w	r3, r3, #393216	; 0x60000
 8006d3c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
          (void)USB_InitFSLSPClkSel(hhcd->Instance, HCFG_48_MHZ);
 8006d40:	bf18      	it	ne
 8006d42:	2101      	movne	r1, #1
 8006d44:	f009 fcfe 	bl	8010744 <USB_InitFSLSPClkSel>
 8006d48:	e6fa      	b.n	8006b40 <HAL_HCD_IRQHandler+0x28c>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d4a:	68fa      	ldr	r2, [r7, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8006d4c:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8006d50:	2105      	movs	r1, #5
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006d52:	2010      	movs	r0, #16
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d54:	f042 0202 	orr.w	r2, r2, #2
    hhcd->hc[ch_num].state = HC_STALL;
 8006d58:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8006d5c:	f04f 0c08 	mov.w	ip, #8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d60:	60fa      	str	r2, [r7, #12]
    hhcd->hc[ch_num].state = HC_STALL;
 8006d62:	f883 105d 	strb.w	r1, [r3, #93]	; 0x5d
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d66:	4641      	mov	r1, r8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006d68:	60b8      	str	r0, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8006d6a:	f8c7 c008 	str.w	ip, [r7, #8]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d6e:	6820      	ldr	r0, [r4, #0]
 8006d70:	f009 fec4 	bl	8010afc <USB_HC_Halt>
 8006d74:	e652      	b.n	8006a1c <HAL_HCD_IRQHandler+0x168>
    hhcd->hc[ch_num].state = HC_NYET;
 8006d76:	eb08 0388 	add.w	r3, r8, r8, lsl #2
 8006d7a:	f04f 0c04 	mov.w	ip, #4
    hhcd->hc[ch_num].do_ping = 1U;
 8006d7e:	2001      	movs	r0, #1
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d80:	4641      	mov	r1, r8
    hhcd->hc[ch_num].state = HC_NYET;
 8006d82:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006d86:	659a      	str	r2, [r3, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_NYET;
 8006d88:	f883 c05d 	strb.w	ip, [r3, #93]	; 0x5d
    hhcd->hc[ch_num].do_ping = 1U;
 8006d8c:	f883 003d 	strb.w	r0, [r3, #61]	; 0x3d
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006d90:	68fb      	ldr	r3, [r7, #12]
 8006d92:	f043 0302 	orr.w	r3, r3, #2
 8006d96:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006d98:	6820      	ldr	r0, [r4, #0]
 8006d9a:	f009 feaf 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NYET);
 8006d9e:	2340      	movs	r3, #64	; 0x40
 8006da0:	60bb      	str	r3, [r7, #8]
 8006da2:	68a1      	ldr	r1, [r4, #8]
 8006da4:	6820      	ldr	r0, [r4, #0]
 8006da6:	e66b      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
      hhcd->hc[ch_num].do_ping = 0U;
 8006da8:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006dac:	f04f 0302 	mov.w	r3, #2
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006db0:	4641      	mov	r1, r8
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006db2:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006db6:	68fb      	ldr	r3, [r7, #12]
 8006db8:	f043 0302 	orr.w	r3, r3, #2
 8006dbc:	60fb      	str	r3, [r7, #12]
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006dbe:	6820      	ldr	r0, [r4, #0]
 8006dc0:	f009 fe9c 	bl	8010afc <USB_HC_Halt>
 8006dc4:	68a1      	ldr	r1, [r4, #8]
 8006dc6:	6820      	ldr	r0, [r4, #0]
 8006dc8:	e65a      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006dca:	68fa      	ldr	r2, [r7, #12]
    hhcd->hc[ch_num].ErrCnt++;
 8006dcc:	eb08 0388 	add.w	r3, r8, r8, lsl #2
    hhcd->hc[ch_num].state = HC_XACTERR;
 8006dd0:	2006      	movs	r0, #6
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006dd2:	4641      	mov	r1, r8
    hhcd->hc[ch_num].ErrCnt++;
 8006dd4:	eb04 03c3 	add.w	r3, r4, r3, lsl #3
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006dd8:	f042 0202 	orr.w	r2, r2, #2
 8006ddc:	60fa      	str	r2, [r7, #12]
    hhcd->hc[ch_num].ErrCnt++;
 8006dde:	6d9a      	ldr	r2, [r3, #88]	; 0x58
    hhcd->hc[ch_num].state = HC_XACTERR;
 8006de0:	f883 005d 	strb.w	r0, [r3, #93]	; 0x5d
    hhcd->hc[ch_num].ErrCnt++;
 8006de4:	3201      	adds	r2, #1
 8006de6:	659a      	str	r2, [r3, #88]	; 0x58
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006de8:	6820      	ldr	r0, [r4, #0]
 8006dea:	f009 fe87 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8006dee:	2380      	movs	r3, #128	; 0x80
 8006df0:	60bb      	str	r3, [r7, #8]
 8006df2:	68a1      	ldr	r1, [r4, #8]
 8006df4:	6820      	ldr	r0, [r4, #0]
 8006df6:	e643      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8006df8:	f85b 000a 	ldr.w	r0, [fp, sl]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006dfc:	4672      	mov	r2, lr
 8006dfe:	4641      	mov	r1, r8
 8006e00:	9301      	str	r3, [sp, #4]
      USBx_HC(ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM;
 8006e02:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
 8006e06:	f84b 000a 	str.w	r0, [fp, sl]
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006e0a:	4620      	mov	r0, r4
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8006e0c:	f88c e05c 	strb.w	lr, [ip, #92]	; 0x5c
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006e10:	f01a fdb2 	bl	8021978 <HAL_HCD_HC_NotifyURBChange_Callback>
 8006e14:	9b01      	ldr	r3, [sp, #4]
 8006e16:	e628      	b.n	8006a6a <HAL_HCD_IRQHandler+0x1b6>
      hhcd->hc[ch_num].urb_state = URB_DONE;
 8006e18:	f88c 205c 	strb.w	r2, [ip, #92]	; 0x5c
      HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006e1c:	4641      	mov	r1, r8
 8006e1e:	4620      	mov	r0, r4
 8006e20:	9301      	str	r3, [sp, #4]
 8006e22:	f01a fda9 	bl	8021978 <HAL_HCD_HC_NotifyURBChange_Callback>
 8006e26:	9b01      	ldr	r3, [sp, #4]
 8006e28:	e61f      	b.n	8006a6a <HAL_HCD_IRQHandler+0x1b6>
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006e2a:	eb08 0288 	add.w	r2, r8, r8, lsl #2
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006e2e:	4641      	mov	r1, r8
    hhcd->hc[ch_num].ErrCnt = 0U;
 8006e30:	eb04 08c2 	add.w	r8, r4, r2, lsl #3
 8006e34:	f8c8 3058 	str.w	r3, [r8, #88]	; 0x58
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006e38:	68fb      	ldr	r3, [r7, #12]
 8006e3a:	f043 0302 	orr.w	r3, r3, #2
 8006e3e:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006e40:	6820      	ldr	r0, [r4, #0]
 8006e42:	f009 fe5b 	bl	8010afc <USB_HC_Halt>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_XFRC);
 8006e46:	2301      	movs	r3, #1
 8006e48:	60bb      	str	r3, [r7, #8]
    hhcd->hc[ch_num].state = HC_XFRC;
 8006e4a:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d
 8006e4e:	68a1      	ldr	r1, [r4, #8]
 8006e50:	6820      	ldr	r0, [r4, #0]
 8006e52:	e615      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
      hhcd->hc[ch_num].ErrCnt++;
 8006e54:	eb03 0208 	add.w	r2, r3, r8
 8006e58:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8006e5c:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8006e5e:	3201      	adds	r2, #1
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 8006e60:	2a03      	cmp	r2, #3
 8006e62:	d853      	bhi.n	8006f0c <HAL_HCD_IRQHandler+0x658>
      hhcd->hc[ch_num].ErrCnt++;
 8006e64:	2128      	movs	r1, #40	; 0x28
 8006e66:	fb01 4008 	mla	r0, r1, r8, r4
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8006e6a:	2102      	movs	r1, #2
      hhcd->hc[ch_num].ErrCnt++;
 8006e6c:	6582      	str	r2, [r0, #88]	; 0x58
 8006e6e:	eb03 0208 	add.w	r2, r3, r8
 8006e72:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006e76:	f882 105c 	strb.w	r1, [r2, #92]	; 0x5c
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 8006e7a:	f85b 200a 	ldr.w	r2, [fp, sl]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8006e7e:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8006e82:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 8006e86:	f84b 200a 	str.w	r2, [fp, sl]
 8006e8a:	e69a      	b.n	8006bc2 <HAL_HCD_IRQHandler+0x30e>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_TXERR) == USB_OTG_HCINT_TXERR)
 8006e8c:	68bb      	ldr	r3, [r7, #8]
 8006e8e:	061a      	lsls	r2, r3, #24
 8006e90:	d44f      	bmi.n	8006f32 <HAL_HCD_IRQHandler+0x67e>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_DTERR) == USB_OTG_HCINT_DTERR)
 8006e92:	68bb      	ldr	r3, [r7, #8]
 8006e94:	055b      	lsls	r3, r3, #21
 8006e96:	d45f      	bmi.n	8006f58 <HAL_HCD_IRQHandler+0x6a4>
  else if ((USBx_HC(ch_num)->HCINT & USB_OTG_HCINT_CHH) == USB_OTG_HCINT_CHH)
 8006e98:	68bb      	ldr	r3, [r7, #8]
 8006e9a:	079a      	lsls	r2, r3, #30
 8006e9c:	f57f adf0 	bpl.w	8006a80 <HAL_HCD_IRQHandler+0x1cc>
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006ea0:	68fb      	ldr	r3, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006ea2:	2228      	movs	r2, #40	; 0x28
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006ea4:	f023 0302 	bic.w	r3, r3, #2
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006ea8:	fb02 4208 	mla	r2, r2, r8, r4
    __HAL_HCD_MASK_HALT_HC_INT(ch_num);
 8006eac:	60fb      	str	r3, [r7, #12]
    if (hhcd->hc[ch_num].state == HC_XFRC)
 8006eae:	f892 305d 	ldrb.w	r3, [r2, #93]	; 0x5d
 8006eb2:	2b01      	cmp	r3, #1
 8006eb4:	d06b      	beq.n	8006f8e <HAL_HCD_IRQHandler+0x6da>
    else if (hhcd->hc[ch_num].state == HC_NAK)
 8006eb6:	2b03      	cmp	r3, #3
 8006eb8:	d064      	beq.n	8006f84 <HAL_HCD_IRQHandler+0x6d0>
    else if (hhcd->hc[ch_num].state == HC_NYET)
 8006eba:	2b04      	cmp	r3, #4
 8006ebc:	d062      	beq.n	8006f84 <HAL_HCD_IRQHandler+0x6d0>
    else if (hhcd->hc[ch_num].state == HC_STALL)
 8006ebe:	2b05      	cmp	r3, #5
 8006ec0:	f000 808c 	beq.w	8006fdc <HAL_HCD_IRQHandler+0x728>
    else if ((hhcd->hc[ch_num].state == HC_XACTERR) ||
 8006ec4:	2b06      	cmp	r3, #6
 8006ec6:	d070      	beq.n	8006faa <HAL_HCD_IRQHandler+0x6f6>
 8006ec8:	2b08      	cmp	r3, #8
 8006eca:	d06e      	beq.n	8006faa <HAL_HCD_IRQHandler+0x6f6>
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006ecc:	2328      	movs	r3, #40	; 0x28
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8006ece:	2202      	movs	r2, #2
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006ed0:	4641      	mov	r1, r8
 8006ed2:	4620      	mov	r0, r4
 8006ed4:	fb03 4308 	mla	r3, r3, r8, r4
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_CHH);
 8006ed8:	60ba      	str	r2, [r7, #8]
    HAL_HCD_HC_NotifyURBChange_Callback(hhcd, (uint8_t)ch_num, hhcd->hc[ch_num].urb_state);
 8006eda:	f893 205c 	ldrb.w	r2, [r3, #92]	; 0x5c
 8006ede:	f01a fd4b 	bl	8021978 <HAL_HCD_HC_NotifyURBChange_Callback>
 8006ee2:	e5f7      	b.n	8006ad4 <HAL_HCD_IRQHandler+0x220>
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8006ee4:	2308      	movs	r3, #8
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006ee6:	4641      	mov	r1, r8
    hhcd->hc[ch_num].state = HC_STALL;
 8006ee8:	eb08 0888 	add.w	r8, r8, r8, lsl #2
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_STALL);
 8006eec:	60bb      	str	r3, [r7, #8]
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006eee:	68fb      	ldr	r3, [r7, #12]
 8006ef0:	f043 0302 	orr.w	r3, r3, #2
 8006ef4:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006ef6:	6820      	ldr	r0, [r4, #0]
 8006ef8:	f009 fe00 	bl	8010afc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_STALL;
 8006efc:	2205      	movs	r2, #5
 8006efe:	eb04 03c8 	add.w	r3, r4, r8, lsl #3
 8006f02:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
 8006f06:	68a1      	ldr	r1, [r4, #8]
 8006f08:	6820      	ldr	r0, [r4, #0]
 8006f0a:	e5b9      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8006f0c:	2228      	movs	r2, #40	; 0x28
 8006f0e:	2000      	movs	r0, #0
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8006f10:	2104      	movs	r1, #4
        hhcd->hc[ch_num].ErrCnt = 0U;
 8006f12:	fb02 4208 	mla	r2, r2, r8, r4
 8006f16:	6590      	str	r0, [r2, #88]	; 0x58
 8006f18:	e7a9      	b.n	8006e6e <HAL_HCD_IRQHandler+0x5ba>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006f1a:	2228      	movs	r2, #40	; 0x28
 8006f1c:	f04f 0102 	mov.w	r1, #2
 8006f20:	fb02 4208 	mla	r2, r2, r8, r4
 8006f24:	e7a7      	b.n	8006e76 <HAL_HCD_IRQHandler+0x5c2>
      hhcd->hc[ch_num].ErrCnt = 0U;
 8006f26:	2228      	movs	r2, #40	; 0x28
      (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006f28:	4641      	mov	r1, r8
      hhcd->hc[ch_num].ErrCnt = 0U;
 8006f2a:	fb02 4208 	mla	r2, r2, r8, r4
 8006f2e:	6593      	str	r3, [r2, #88]	; 0x58
 8006f30:	e6e6      	b.n	8006d00 <HAL_HCD_IRQHandler+0x44c>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006f32:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006f34:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006f36:	f043 0302 	orr.w	r3, r3, #2
 8006f3a:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006f3c:	6820      	ldr	r0, [r4, #0]
 8006f3e:	f009 fddd 	bl	8010afc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_XACTERR;
 8006f42:	2328      	movs	r3, #40	; 0x28
 8006f44:	2206      	movs	r2, #6
 8006f46:	fb03 4808 	mla	r8, r3, r8, r4
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8006f4a:	2380      	movs	r3, #128	; 0x80
    hhcd->hc[ch_num].state = HC_XACTERR;
 8006f4c:	f888 205d 	strb.w	r2, [r8, #93]	; 0x5d
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_TXERR);
 8006f50:	60bb      	str	r3, [r7, #8]
 8006f52:	68a1      	ldr	r1, [r4, #8]
 8006f54:	6820      	ldr	r0, [r4, #0]
 8006f56:	e593      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006f58:	68fb      	ldr	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006f5a:	4641      	mov	r1, r8
    __HAL_HCD_UNMASK_HALT_HC_INT(ch_num);
 8006f5c:	f043 0302 	orr.w	r3, r3, #2
 8006f60:	60fb      	str	r3, [r7, #12]
    (void)USB_HC_Halt(hhcd->Instance, (uint8_t)ch_num);
 8006f62:	6820      	ldr	r0, [r4, #0]
 8006f64:	f009 fdca 	bl	8010afc <USB_HC_Halt>
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006f68:	2328      	movs	r3, #40	; 0x28
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006f6a:	2110      	movs	r1, #16
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8006f6c:	f44f 6280 	mov.w	r2, #1024	; 0x400
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006f70:	fb03 4808 	mla	r8, r3, r8, r4
 8006f74:	2308      	movs	r3, #8
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_NAK);
 8006f76:	60b9      	str	r1, [r7, #8]
    __HAL_HCD_CLEAR_HC_INT(ch_num, USB_OTG_HCINT_DTERR);
 8006f78:	60ba      	str	r2, [r7, #8]
    hhcd->hc[ch_num].state = HC_DATATGLERR;
 8006f7a:	f888 305d 	strb.w	r3, [r8, #93]	; 0x5d
 8006f7e:	68a1      	ldr	r1, [r4, #8]
 8006f80:	6820      	ldr	r0, [r4, #0]
 8006f82:	e57d      	b.n	8006a80 <HAL_HCD_IRQHandler+0x1cc>
      hhcd->hc[ch_num].urb_state  = URB_NOTREADY;
 8006f84:	f04f 0302 	mov.w	r3, #2
 8006f88:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
 8006f8c:	e79e      	b.n	8006ecc <HAL_HCD_IRQHandler+0x618>
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8006f8e:	f892 103f 	ldrb.w	r1, [r2, #63]	; 0x3f
      hhcd->hc[ch_num].urb_state  = URB_DONE;
 8006f92:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      if ((hhcd->hc[ch_num].ep_type == EP_TYPE_BULK) ||
 8006f96:	1e8b      	subs	r3, r1, #2
 8006f98:	2b01      	cmp	r3, #1
 8006f9a:	d897      	bhi.n	8006ecc <HAL_HCD_IRQHandler+0x618>
        hhcd->hc[ch_num].toggle_out ^= 1U;
 8006f9c:	f892 3051 	ldrb.w	r3, [r2, #81]	; 0x51
 8006fa0:	f083 0301 	eor.w	r3, r3, #1
 8006fa4:	f882 3051 	strb.w	r3, [r2, #81]	; 0x51
 8006fa8:	e790      	b.n	8006ecc <HAL_HCD_IRQHandler+0x618>
      hhcd->hc[ch_num].ErrCnt++;
 8006faa:	2328      	movs	r3, #40	; 0x28
 8006fac:	fb03 4208 	mla	r2, r3, r8, r4
 8006fb0:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8006fb2:	3301      	adds	r3, #1
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 8006fb4:	2b03      	cmp	r3, #3
      hhcd->hc[ch_num].ErrCnt++;
 8006fb6:	6593      	str	r3, [r2, #88]	; 0x58
      if (hhcd->hc[ch_num].ErrCnt > 3U)
 8006fb8:	d913      	bls.n	8006fe2 <HAL_HCD_IRQHandler+0x72e>
        hhcd->hc[ch_num].ErrCnt = 0U;
 8006fba:	2100      	movs	r1, #0
        hhcd->hc[ch_num].urb_state = URB_ERROR;
 8006fbc:	2304      	movs	r3, #4
        hhcd->hc[ch_num].ErrCnt = 0U;
 8006fbe:	6591      	str	r1, [r2, #88]	; 0x58
 8006fc0:	2228      	movs	r2, #40	; 0x28
 8006fc2:	fb02 4208 	mla	r2, r2, r8, r4
 8006fc6:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
      tmpreg = USBx_HC(ch_num)->HCCHAR;
 8006fca:	f85b 300a 	ldr.w	r3, [fp, sl]
      tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8006fce:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
      tmpreg |= USB_OTG_HCCHAR_CHENA;
 8006fd2:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
      USBx_HC(ch_num)->HCCHAR = tmpreg;
 8006fd6:	f84b 300a 	str.w	r3, [fp, sl]
 8006fda:	e777      	b.n	8006ecc <HAL_HCD_IRQHandler+0x618>
      hhcd->hc[ch_num].urb_state  = URB_STALL;
 8006fdc:	f882 305c 	strb.w	r3, [r2, #92]	; 0x5c
 8006fe0:	e774      	b.n	8006ecc <HAL_HCD_IRQHandler+0x618>
        hhcd->hc[ch_num].urb_state = URB_NOTREADY;
 8006fe2:	2302      	movs	r3, #2
 8006fe4:	e7ec      	b.n	8006fc0 <HAL_HCD_IRQHandler+0x70c>
 8006fe6:	bf00      	nop

08006fe8 <HAL_HCD_Start>:
{
 8006fe8:	b538      	push	{r3, r4, r5, lr}
  __HAL_LOCK(hhcd);
 8006fea:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 8006fee:	2b01      	cmp	r3, #1
 8006ff0:	d00e      	beq.n	8007010 <HAL_HCD_Start+0x28>
 8006ff2:	4604      	mov	r4, r0
 8006ff4:	2501      	movs	r5, #1
  __HAL_HCD_ENABLE(hhcd);
 8006ff6:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 8006ff8:	f884 52b8 	strb.w	r5, [r4, #696]	; 0x2b8
  __HAL_HCD_ENABLE(hhcd);
 8006ffc:	f009 fac8 	bl	8010590 <USB_EnableGlobalInt>
  (void)USB_DriveVbus(hhcd->Instance, 1U);
 8007000:	4629      	mov	r1, r5
 8007002:	6820      	ldr	r0, [r4, #0]
 8007004:	f009 fbe6 	bl	80107d4 <USB_DriveVbus>
  __HAL_UNLOCK(hhcd);
 8007008:	2000      	movs	r0, #0
 800700a:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8
}
 800700e:	bd38      	pop	{r3, r4, r5, pc}
  __HAL_LOCK(hhcd);
 8007010:	2002      	movs	r0, #2
}
 8007012:	bd38      	pop	{r3, r4, r5, pc}

08007014 <HAL_HCD_Stop>:
  __HAL_LOCK(hhcd);
 8007014:	f890 32b8 	ldrb.w	r3, [r0, #696]	; 0x2b8
 8007018:	2b01      	cmp	r3, #1
 800701a:	d00b      	beq.n	8007034 <HAL_HCD_Stop+0x20>
 800701c:	2301      	movs	r3, #1
{
 800701e:	b510      	push	{r4, lr}
 8007020:	4604      	mov	r4, r0
  (void)USB_StopHost(hhcd->Instance);
 8007022:	6800      	ldr	r0, [r0, #0]
  __HAL_LOCK(hhcd);
 8007024:	f884 32b8 	strb.w	r3, [r4, #696]	; 0x2b8
  (void)USB_StopHost(hhcd->Instance);
 8007028:	f009 fdc0 	bl	8010bac <USB_StopHost>
  __HAL_UNLOCK(hhcd);
 800702c:	2000      	movs	r0, #0
 800702e:	f884 02b8 	strb.w	r0, [r4, #696]	; 0x2b8
}
 8007032:	bd10      	pop	{r4, pc}
  __HAL_LOCK(hhcd);
 8007034:	2002      	movs	r0, #2
}
 8007036:	4770      	bx	lr

08007038 <HAL_HCD_ResetPort>:
  return (USB_ResetPort(hhcd->Instance));
 8007038:	6800      	ldr	r0, [r0, #0]
 800703a:	f009 bbab 	b.w	8010794 <USB_ResetPort>
 800703e:	bf00      	nop

08007040 <HAL_HCD_HC_GetURBState>:
  return hhcd->hc[chnum].urb_state;
 8007040:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8007044:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
 8007048:	f891 005c 	ldrb.w	r0, [r1, #92]	; 0x5c
 800704c:	4770      	bx	lr
 800704e:	bf00      	nop

08007050 <HAL_HCD_HC_GetXferCount>:
  return hhcd->hc[chnum].xfer_count;
 8007050:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8007054:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
}
 8007058:	6cc8      	ldr	r0, [r1, #76]	; 0x4c
 800705a:	4770      	bx	lr

0800705c <HAL_HCD_GetCurrentFrame>:
  return (USB_GetCurrentFrame(hhcd->Instance));
 800705c:	6800      	ldr	r0, [r0, #0]
 800705e:	f009 bbe9 	b.w	8010834 <USB_GetCurrentFrame>
 8007062:	bf00      	nop

08007064 <HAL_HCD_GetCurrentSpeed>:
  return (USB_GetHostSpeed(hhcd->Instance));
 8007064:	6800      	ldr	r0, [r0, #0]
 8007066:	f009 bbd9 	b.w	801081c <USB_GetHostSpeed>
 800706a:	bf00      	nop

0800706c <I2C_WaitOnTXISFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXISFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
 800706c:	b570      	push	{r4, r5, r6, lr}
 800706e:	4604      	mov	r4, r0
 8007070:	460d      	mov	r5, r1
 8007072:	4616      	mov	r6, r2
 8007074:	1c6b      	adds	r3, r5, #1
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8007076:	6822      	ldr	r2, [r4, #0]
 8007078:	d131      	bne.n	80070de <I2C_WaitOnTXISFlagUntilTimeout+0x72>
 800707a:	6993      	ldr	r3, [r2, #24]
 800707c:	0798      	lsls	r0, r3, #30
 800707e:	d431      	bmi.n	80070e4 <I2C_WaitOnTXISFlagUntilTimeout+0x78>
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007080:	6993      	ldr	r3, [r2, #24]
 8007082:	06d9      	lsls	r1, r3, #27
 8007084:	d5f9      	bpl.n	800707a <I2C_WaitOnTXISFlagUntilTimeout+0xe>
  {
    /* Wait until STOP Flag is reset */
    /* AutoEnd should be initiate after AF */
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007086:	6993      	ldr	r3, [r2, #24]
 8007088:	069d      	lsls	r5, r3, #26
 800708a:	d5fc      	bpl.n	8007086 <I2C_WaitOnTXISFlagUntilTimeout+0x1a>
        }
      }
    }

    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800708c:	2310      	movs	r3, #16

    /* Clear STOP Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800708e:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007090:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007092:	6823      	ldr	r3, [r4, #0]
 8007094:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007096:	6823      	ldr	r3, [r4, #0]
 8007098:	699a      	ldr	r2, [r3, #24]
 800709a:	0791      	lsls	r1, r2, #30
 800709c:	d502      	bpl.n	80070a4 <I2C_WaitOnTXISFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
 800709e:	2200      	movs	r2, #0
 80070a0:	629a      	str	r2, [r3, #40]	; 0x28
 80070a2:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80070a4:	699a      	ldr	r2, [r3, #24]
 80070a6:	07d2      	lsls	r2, r2, #31
 80070a8:	d404      	bmi.n	80070b4 <I2C_WaitOnTXISFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80070aa:	699a      	ldr	r2, [r3, #24]
 80070ac:	f042 0201 	orr.w	r2, r2, #1
 80070b0:	619a      	str	r2, [r3, #24]
 80070b2:	6823      	ldr	r3, [r4, #0]

    /* Flush TX register */
    I2C_Flush_TXDR(hi2c);

    /* Clear Configuration Register 2 */
    I2C_RESET_CR2(hi2c);
 80070b4:	f44f 4568 	mov.w	r5, #59392	; 0xe800
 80070b8:	685a      	ldr	r2, [r3, #4]

    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80070ba:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80070bc:	2620      	movs	r6, #32
    I2C_RESET_CR2(hi2c);
 80070be:	f6cf 6500 	movt	r5, #65024	; 0xfe00
      return HAL_ERROR;
 80070c2:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 80070c4:	402a      	ands	r2, r5
 80070c6:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80070c8:	6c63      	ldr	r3, [r4, #68]	; 0x44

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80070ca:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80070ce:	f043 0304 	orr.w	r3, r3, #4
 80070d2:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 80070d4:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 80070d8:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 80070dc:	bd70      	pop	{r4, r5, r6, pc}
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80070de:	6993      	ldr	r3, [r2, #24]
 80070e0:	079b      	lsls	r3, r3, #30
 80070e2:	d501      	bpl.n	80070e8 <I2C_WaitOnTXISFlagUntilTimeout+0x7c>
  return HAL_OK;
 80070e4:	2000      	movs	r0, #0
}
 80070e6:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80070e8:	6993      	ldr	r3, [r2, #24]
 80070ea:	06db      	lsls	r3, r3, #27
 80070ec:	d407      	bmi.n	80070fe <I2C_WaitOnTXISFlagUntilTimeout+0x92>
 80070ee:	e00a      	b.n	8007106 <I2C_WaitOnTXISFlagUntilTimeout+0x9a>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80070f0:	f7f9 fca4 	bl	8000a3c <HAL_GetTick>
 80070f4:	1b80      	subs	r0, r0, r6
 80070f6:	4285      	cmp	r5, r0
 80070f8:	d30c      	bcc.n	8007114 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
 80070fa:	b15d      	cbz	r5, 8007114 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
 80070fc:	6822      	ldr	r2, [r4, #0]
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80070fe:	6993      	ldr	r3, [r2, #24]
 8007100:	0698      	lsls	r0, r3, #26
 8007102:	d5f5      	bpl.n	80070f0 <I2C_WaitOnTXISFlagUntilTimeout+0x84>
 8007104:	e7c2      	b.n	800708c <I2C_WaitOnTXISFlagUntilTimeout+0x20>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007106:	f7f9 fc99 	bl	8000a3c <HAL_GetTick>
 800710a:	1b80      	subs	r0, r0, r6
 800710c:	42a8      	cmp	r0, r5
 800710e:	d801      	bhi.n	8007114 <I2C_WaitOnTXISFlagUntilTimeout+0xa8>
 8007110:	2d00      	cmp	r5, #0
 8007112:	d1af      	bne.n	8007074 <I2C_WaitOnTXISFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007114:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007116:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007118:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 800711a:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800711c:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 800711e:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8007122:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8007124:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8007128:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 800712c:	bd70      	pop	{r4, r5, r6, pc}
 800712e:	bf00      	nop

08007130 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8007130:	b570      	push	{r4, r5, r6, lr}
 8007132:	4604      	mov	r4, r0
 8007134:	460d      	mov	r5, r1
 8007136:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8007138:	6822      	ldr	r2, [r4, #0]
 800713a:	6993      	ldr	r3, [r2, #24]
 800713c:	069b      	lsls	r3, r3, #26
 800713e:	d450      	bmi.n	80071e2 <I2C_WaitOnSTOPFlagUntilTimeout+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8007140:	6993      	ldr	r3, [r2, #24]
 8007142:	06d9      	lsls	r1, r3, #27
 8007144:	d52d      	bpl.n	80071a2 <I2C_WaitOnSTOPFlagUntilTimeout+0x72>
 8007146:	1c6b      	adds	r3, r5, #1
 8007148:	d13f      	bne.n	80071ca <I2C_WaitOnSTOPFlagUntilTimeout+0x9a>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800714a:	6993      	ldr	r3, [r2, #24]
 800714c:	069d      	lsls	r5, r3, #26
 800714e:	d5fc      	bpl.n	800714a <I2C_WaitOnSTOPFlagUntilTimeout+0x1a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007150:	2310      	movs	r3, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007152:	2120      	movs	r1, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007154:	61d3      	str	r3, [r2, #28]
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007156:	6823      	ldr	r3, [r4, #0]
 8007158:	61d9      	str	r1, [r3, #28]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800715a:	6823      	ldr	r3, [r4, #0]
 800715c:	699a      	ldr	r2, [r3, #24]
 800715e:	0791      	lsls	r1, r2, #30
 8007160:	d502      	bpl.n	8007168 <I2C_WaitOnSTOPFlagUntilTimeout+0x38>
    hi2c->Instance->TXDR = 0x00U;
 8007162:	2200      	movs	r2, #0
 8007164:	629a      	str	r2, [r3, #40]	; 0x28
 8007166:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007168:	699a      	ldr	r2, [r3, #24]
 800716a:	07d2      	lsls	r2, r2, #31
 800716c:	d404      	bmi.n	8007178 <I2C_WaitOnSTOPFlagUntilTimeout+0x48>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800716e:	699a      	ldr	r2, [r3, #24]
 8007170:	f042 0201 	orr.w	r2, r2, #1
 8007174:	619a      	str	r2, [r3, #24]
 8007176:	6823      	ldr	r3, [r4, #0]
    I2C_RESET_CR2(hi2c);
 8007178:	f44f 4568 	mov.w	r5, #59392	; 0xe800
 800717c:	685a      	ldr	r2, [r3, #4]
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800717e:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8007180:	2620      	movs	r6, #32
    I2C_RESET_CR2(hi2c);
 8007182:	f6cf 6500 	movt	r5, #65024	; 0xfe00
      return HAL_ERROR;
 8007186:	2001      	movs	r0, #1
    I2C_RESET_CR2(hi2c);
 8007188:	402a      	ands	r2, r5
 800718a:	605a      	str	r2, [r3, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800718c:	6c63      	ldr	r3, [r4, #68]	; 0x44
    __HAL_UNLOCK(hi2c);
 800718e:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007192:	f043 0304 	orr.w	r3, r3, #4
 8007196:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8007198:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800719c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
}
 80071a0:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80071a2:	f7f9 fc4b 	bl	8000a3c <HAL_GetTick>
 80071a6:	1b80      	subs	r0, r0, r6
 80071a8:	42a8      	cmp	r0, r5
 80071aa:	d801      	bhi.n	80071b0 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
 80071ac:	2d00      	cmp	r5, #0
 80071ae:	d1c3      	bne.n	8007138 <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80071b0:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80071b2:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80071b4:	2200      	movs	r2, #0
        __HAL_UNLOCK(hi2c);
 80071b6:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80071b8:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 80071ba:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80071be:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80071c0:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80071c4:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80071c8:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 80071ca:	6993      	ldr	r3, [r2, #24]
 80071cc:	0698      	lsls	r0, r3, #26
 80071ce:	d4bf      	bmi.n	8007150 <I2C_WaitOnSTOPFlagUntilTimeout+0x20>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80071d0:	f7f9 fc34 	bl	8000a3c <HAL_GetTick>
 80071d4:	1b80      	subs	r0, r0, r6
 80071d6:	4285      	cmp	r5, r0
 80071d8:	d3ea      	bcc.n	80071b0 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
 80071da:	2d00      	cmp	r5, #0
 80071dc:	d0e8      	beq.n	80071b0 <I2C_WaitOnSTOPFlagUntilTimeout+0x80>
 80071de:	6822      	ldr	r2, [r4, #0]
 80071e0:	e7b1      	b.n	8007146 <I2C_WaitOnSTOPFlagUntilTimeout+0x16>
  return HAL_OK;
 80071e2:	2000      	movs	r0, #0
}
 80071e4:	bd70      	pop	{r4, r5, r6, pc}
 80071e6:	bf00      	nop

080071e8 <HAL_I2C_Init>:
  if (hi2c == NULL)
 80071e8:	2800      	cmp	r0, #0
 80071ea:	f000 80fb 	beq.w	80073e4 <HAL_I2C_Init+0x1fc>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80071ee:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
{
 80071f2:	b538      	push	{r3, r4, r5, lr}
 80071f4:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80071f6:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 80071fa:	f44f 40b0 	mov.w	r0, #22528	; 0x5800
 80071fe:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8007202:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007206:	6822      	ldr	r2, [r4, #0]
 8007208:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800720c:	429a      	cmp	r2, r3
 800720e:	bf18      	it	ne
 8007210:	4282      	cmpne	r2, r0
 8007212:	bf14      	ite	ne
 8007214:	2301      	movne	r3, #1
 8007216:	2300      	moveq	r3, #0
 8007218:	428a      	cmp	r2, r1
 800721a:	bf0c      	ite	eq
 800721c:	2300      	moveq	r3, #0
 800721e:	f003 0301 	andne.w	r3, r3, #1
 8007222:	b133      	cbz	r3, 8007232 <HAL_I2C_Init+0x4a>
 8007224:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8007228:	f6c5 0300 	movt	r3, #22528	; 0x5800
 800722c:	429a      	cmp	r2, r3
 800722e:	f040 80db 	bne.w	80073e8 <HAL_I2C_Init+0x200>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 8007232:	68a3      	ldr	r3, [r4, #8]
 8007234:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8007238:	d27a      	bcs.n	8007330 <HAL_I2C_Init+0x148>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 800723a:	68e3      	ldr	r3, [r4, #12]
 800723c:	3b01      	subs	r3, #1
 800723e:	2b01      	cmp	r3, #1
 8007240:	d864      	bhi.n	800730c <HAL_I2C_Init+0x124>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8007242:	6923      	ldr	r3, [r4, #16]
 8007244:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 8007248:	f040 808d 	bne.w	8007366 <HAL_I2C_Init+0x17e>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800724c:	6963      	ldr	r3, [r4, #20]
 800724e:	2bff      	cmp	r3, #255	; 0xff
 8007250:	d87c      	bhi.n	800734c <HAL_I2C_Init+0x164>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 8007252:	69a3      	ldr	r3, [r4, #24]
 8007254:	2b07      	cmp	r3, #7
 8007256:	f200 80b7 	bhi.w	80073c8 <HAL_I2C_Init+0x1e0>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 800725a:	69e3      	ldr	r3, [r4, #28]
 800725c:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 8007260:	f040 80a4 	bne.w	80073ac <HAL_I2C_Init+0x1c4>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 8007264:	6a23      	ldr	r3, [r4, #32]
 8007266:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800726a:	f040 808f 	bne.w	800738c <HAL_I2C_Init+0x1a4>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800726e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007272:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8007276:	2b00      	cmp	r3, #0
 8007278:	f000 8082 	beq.w	8007380 <HAL_I2C_Init+0x198>
  __HAL_I2C_DISABLE(hi2c);
 800727c:	6822      	ldr	r2, [r4, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 800727e:	2324      	movs	r3, #36	; 0x24
 8007280:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8007284:	6813      	ldr	r3, [r2, #0]
 8007286:	f023 0301 	bic.w	r3, r3, #1
 800728a:	6013      	str	r3, [r2, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800728c:	e9d4 2300 	ldrd	r2, r3, [r4]
 8007290:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8007294:	6113      	str	r3, [r2, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8007296:	6822      	ldr	r2, [r4, #0]
 8007298:	6893      	ldr	r3, [r2, #8]
 800729a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 800729e:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80072a0:	68e3      	ldr	r3, [r4, #12]
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80072a2:	6822      	ldr	r2, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 80072a4:	2b01      	cmp	r3, #1
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 80072a6:	68a3      	ldr	r3, [r4, #8]
 80072a8:	bf0c      	ite	eq
 80072aa:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80072ae:	f443 4304 	orrne.w	r3, r3, #33792	; 0x8400
 80072b2:	6093      	str	r3, [r2, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80072b4:	68e3      	ldr	r3, [r4, #12]
 80072b6:	6825      	ldr	r5, [r4, #0]
 80072b8:	2b02      	cmp	r3, #2
 80072ba:	d034      	beq.n	8007326 <HAL_I2C_Init+0x13e>
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80072bc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80072c0:	6868      	ldr	r0, [r5, #4]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80072c2:	2200      	movs	r2, #0
  hi2c->State = HAL_I2C_STATE_READY;
 80072c4:	2120      	movs	r1, #32
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80072c6:	f2c0 2300 	movt	r3, #512	; 0x200
 80072ca:	4303      	orrs	r3, r0
  return HAL_OK;
 80072cc:	4610      	mov	r0, r2
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 80072ce:	606b      	str	r3, [r5, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 80072d0:	6825      	ldr	r5, [r4, #0]
 80072d2:	68eb      	ldr	r3, [r5, #12]
 80072d4:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 80072d8:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 80072da:	e9d4 3504 	ldrd	r3, r5, [r4, #16]
 80072de:	432b      	orrs	r3, r5
 80072e0:	69a5      	ldr	r5, [r4, #24]
 80072e2:	ea43 2305 	orr.w	r3, r3, r5, lsl #8
 80072e6:	6825      	ldr	r5, [r4, #0]
 80072e8:	60eb      	str	r3, [r5, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 80072ea:	e9d4 3507 	ldrd	r3, r5, [r4, #28]
 80072ee:	432b      	orrs	r3, r5
 80072f0:	6825      	ldr	r5, [r4, #0]
 80072f2:	602b      	str	r3, [r5, #0]
  __HAL_I2C_ENABLE(hi2c);
 80072f4:	6825      	ldr	r5, [r4, #0]
 80072f6:	682b      	ldr	r3, [r5, #0]
 80072f8:	f043 0301 	orr.w	r3, r3, #1
 80072fc:	602b      	str	r3, [r5, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80072fe:	6462      	str	r2, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8007300:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8007304:	6322      	str	r2, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007306:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 800730a:	bd38      	pop	{r3, r4, r5, pc}
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 800730c:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007310:	f240 11e3 	movw	r1, #483	; 0x1e3
 8007314:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007318:	f00e faa6 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 800731c:	6923      	ldr	r3, [r4, #16]
 800731e:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 8007322:	d093      	beq.n	800724c <HAL_I2C_Init+0x64>
 8007324:	e01f      	b.n	8007366 <HAL_I2C_Init+0x17e>
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8007326:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800732a:	606b      	str	r3, [r5, #4]
 800732c:	6825      	ldr	r5, [r4, #0]
 800732e:	e7c5      	b.n	80072bc <HAL_I2C_Init+0xd4>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 8007330:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007334:	f44f 71f1 	mov.w	r1, #482	; 0x1e2
 8007338:	f6c0 0002 	movt	r0, #2050	; 0x802
 800733c:	f00e fa94 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_ADDRESSING_MODE(hi2c->Init.AddressingMode));
 8007340:	68e3      	ldr	r3, [r4, #12]
 8007342:	3b01      	subs	r3, #1
 8007344:	2b01      	cmp	r3, #1
 8007346:	f67f af7c 	bls.w	8007242 <HAL_I2C_Init+0x5a>
 800734a:	e7df      	b.n	800730c <HAL_I2C_Init+0x124>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 800734c:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007350:	f240 11e5 	movw	r1, #485	; 0x1e5
 8007354:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007358:	f00e fa86 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 800735c:	69a3      	ldr	r3, [r4, #24]
 800735e:	2b07      	cmp	r3, #7
 8007360:	f67f af7b 	bls.w	800725a <HAL_I2C_Init+0x72>
 8007364:	e030      	b.n	80073c8 <HAL_I2C_Init+0x1e0>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
 8007366:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800736a:	f44f 71f2 	mov.w	r1, #484	; 0x1e4
 800736e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007372:	f00e fa79 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
 8007376:	6963      	ldr	r3, [r4, #20]
 8007378:	2bff      	cmp	r3, #255	; 0xff
 800737a:	f67f af6a 	bls.w	8007252 <HAL_I2C_Init+0x6a>
 800737e:	e7e5      	b.n	800734c <HAL_I2C_Init+0x164>
    hi2c->Lock = HAL_UNLOCKED;
 8007380:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8007384:	4620      	mov	r0, r4
 8007386:	f00d fead 	bl	80150e4 <HAL_I2C_MspInit>
 800738a:	e777      	b.n	800727c <HAL_I2C_Init+0x94>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 800738c:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007390:	f44f 71f4 	mov.w	r1, #488	; 0x1e8
 8007394:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007398:	f00e fa66 	bl	8015868 <assert_failed>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 800739c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80073a0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80073a4:	2b00      	cmp	r3, #0
 80073a6:	f47f af69 	bne.w	800727c <HAL_I2C_Init+0x94>
 80073aa:	e7e9      	b.n	8007380 <HAL_I2C_Init+0x198>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 80073ac:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80073b0:	f240 11e7 	movw	r1, #487	; 0x1e7
 80073b4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80073b8:	f00e fa56 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));
 80073bc:	6a23      	ldr	r3, [r4, #32]
 80073be:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 80073c2:	f43f af54 	beq.w	800726e <HAL_I2C_Init+0x86>
 80073c6:	e7e1      	b.n	800738c <HAL_I2C_Init+0x1a4>
  assert_param(IS_I2C_OWN_ADDRESS2_MASK(hi2c->Init.OwnAddress2Masks));
 80073c8:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80073cc:	f44f 71f3 	mov.w	r1, #486	; 0x1e6
 80073d0:	f6c0 0002 	movt	r0, #2050	; 0x802
 80073d4:	f00e fa48 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
 80073d8:	69e3      	ldr	r3, [r4, #28]
 80073da:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 80073de:	f43f af41 	beq.w	8007264 <HAL_I2C_Init+0x7c>
 80073e2:	e7e3      	b.n	80073ac <HAL_I2C_Init+0x1c4>
    return HAL_ERROR;
 80073e4:	2001      	movs	r0, #1
}
 80073e6:	4770      	bx	lr
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80073e8:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80073ec:	f240 11e1 	movw	r1, #481	; 0x1e1
 80073f0:	f6c0 0002 	movt	r0, #2050	; 0x802
 80073f4:	f00e fa38 	bl	8015868 <assert_failed>
  assert_param(IS_I2C_OWN_ADDRESS1(hi2c->Init.OwnAddress1));
 80073f8:	68a3      	ldr	r3, [r4, #8]
 80073fa:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80073fe:	f4ff af1c 	bcc.w	800723a <HAL_I2C_Init+0x52>
 8007402:	e795      	b.n	8007330 <HAL_I2C_Init+0x148>

08007404 <HAL_I2C_Master_Transmit>:
{
 8007404:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8007408:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
{
 800740c:	9e08      	ldr	r6, [sp, #32]
  if (hi2c->State == HAL_I2C_STATE_READY)
 800740e:	2c20      	cmp	r4, #32
 8007410:	f040 80c6 	bne.w	80075a0 <HAL_I2C_Master_Transmit+0x19c>
    __HAL_LOCK(hi2c);
 8007414:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 8007418:	2c01      	cmp	r4, #1
 800741a:	f000 80c1 	beq.w	80075a0 <HAL_I2C_Master_Transmit+0x19c>
 800741e:	4698      	mov	r8, r3
 8007420:	2301      	movs	r3, #1
 8007422:	4691      	mov	r9, r2
 8007424:	460f      	mov	r7, r1
 8007426:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
 800742a:	4604      	mov	r4, r0
    tickstart = HAL_GetTick();
 800742c:	f7f9 fb06 	bl	8000a3c <HAL_GetTick>
 8007430:	4605      	mov	r5, r0
 8007432:	e005      	b.n	8007440 <HAL_I2C_Master_Transmit+0x3c>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8007434:	f7f9 fb02 	bl	8000a3c <HAL_GetTick>
 8007438:	1b40      	subs	r0, r0, r5
 800743a:	2819      	cmp	r0, #25
 800743c:	f200 80d1 	bhi.w	80075e2 <HAL_I2C_Master_Transmit+0x1de>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007440:	6823      	ldr	r3, [r4, #0]
 8007442:	6998      	ldr	r0, [r3, #24]
 8007444:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 8007448:	d1f4      	bne.n	8007434 <HAL_I2C_Master_Transmit+0x30>
 800744a:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
 800744e:	f44f 41a8 	mov.w	r1, #21504	; 0x5400
 8007452:	f44f 4cb0 	mov.w	ip, #22528	; 0x5800
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8007456:	f04f 0e21 	mov.w	lr, #33	; 0x21
 800745a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800745e:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8007462:	f2c4 0c00 	movt	ip, #16384	; 0x4000
 8007466:	f884 e041 	strb.w	lr, [r4, #65]	; 0x41
 800746a:	4293      	cmp	r3, r2
 800746c:	bf18      	it	ne
 800746e:	428b      	cmpne	r3, r1
 8007470:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8007474:	f04f 0e10 	mov.w	lr, #16
    hi2c->pBuffPtr  = pData;
 8007478:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
 800747c:	bf14      	ite	ne
 800747e:	2201      	movne	r2, #1
 8007480:	2200      	moveq	r2, #0
 8007482:	f6c5 0100 	movt	r1, #22528	; 0x5800
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8007486:	f884 e042 	strb.w	lr, [r4, #66]	; 0x42
 800748a:	4563      	cmp	r3, ip
 800748c:	bf0c      	ite	eq
 800748e:	2200      	moveq	r2, #0
 8007490:	f002 0201 	andne.w	r2, r2, #1
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8007494:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8007496:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
 800749a:	428b      	cmp	r3, r1
 800749c:	bf0c      	ite	eq
 800749e:	2200      	moveq	r2, #0
 80074a0:	f002 0201 	andne.w	r2, r2, #1
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80074a4:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
    hi2c->XferISR   = NULL;
 80074a6:	6360      	str	r0, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80074a8:	29ff      	cmp	r1, #255	; 0xff
 80074aa:	d87c      	bhi.n	80075a6 <HAL_I2C_Master_Transmit+0x1a2>
      hi2c->XferSize = hi2c->XferCount;
 80074ac:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 80074ae:	b289      	uxth	r1, r1
 80074b0:	8521      	strh	r1, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 80074b2:	fa5f f881 	uxtb.w	r8, r1
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80074b6:	2a00      	cmp	r2, #0
 80074b8:	f040 80e1 	bne.w	800767e <HAL_I2C_Master_Transmit+0x27a>
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80074bc:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 80074c0:	f3c7 0709 	ubfx	r7, r7, #0, #10
 80074c4:	f44f 4018 	mov.w	r0, #38912	; 0x9800
 80074c8:	6859      	ldr	r1, [r3, #4]
 80074ca:	f2c8 2200 	movt	r2, #33280	; 0x8200
 80074ce:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 80074d2:	433a      	orrs	r2, r7
 80074d4:	4001      	ands	r1, r0
 80074d6:	ea42 4208 	orr.w	r2, r2, r8, lsl #16
 80074da:	430a      	orrs	r2, r1
 80074dc:	605a      	str	r2, [r3, #4]
 80074de:	f04f 0800 	mov.w	r8, #0
 80074e2:	f44f 49a8 	mov.w	r9, #21504	; 0x5400
 80074e6:	f2c0 18ff 	movt	r8, #511	; 0x1ff
 80074ea:	f2c4 0900 	movt	r9, #16384	; 0x4000
 80074ee:	ea47 0808 	orr.w	r8, r7, r8
    while (hi2c->XferCount > 0U)
 80074f2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80074f4:	462a      	mov	r2, r5
 80074f6:	4631      	mov	r1, r6
 80074f8:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 80074fa:	b29b      	uxth	r3, r3
 80074fc:	2b00      	cmp	r3, #0
 80074fe:	f000 8094 	beq.w	800762a <HAL_I2C_Master_Transmit+0x226>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8007502:	f7ff fdb3 	bl	800706c <I2C_WaitOnTXISFlagUntilTimeout>
 8007506:	2800      	cmp	r0, #0
 8007508:	f040 808c 	bne.w	8007624 <HAL_I2C_Master_Transmit+0x220>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 800750c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800750e:	6823      	ldr	r3, [r4, #0]
 8007510:	7812      	ldrb	r2, [r2, #0]
 8007512:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8007514:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007516:	8d23      	ldrh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007518:	3901      	subs	r1, #1
      hi2c->pBuffPtr++;
 800751a:	6a62      	ldr	r2, [r4, #36]	; 0x24
      hi2c->XferSize--;
 800751c:	3b01      	subs	r3, #1
      hi2c->XferCount--;
 800751e:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
 8007520:	3201      	adds	r2, #1
      hi2c->XferSize--;
 8007522:	b29b      	uxth	r3, r3
      hi2c->XferCount--;
 8007524:	8561      	strh	r1, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8007526:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007528:	8523      	strh	r3, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800752a:	b289      	uxth	r1, r1
      hi2c->pBuffPtr++;
 800752c:	6262      	str	r2, [r4, #36]	; 0x24
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800752e:	2b00      	cmp	r3, #0
 8007530:	d1df      	bne.n	80074f2 <HAL_I2C_Master_Transmit+0xee>
 8007532:	2900      	cmp	r1, #0
 8007534:	d0dd      	beq.n	80074f2 <HAL_I2C_Master_Transmit+0xee>
 8007536:	1c70      	adds	r0, r6, #1
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8007538:	6822      	ldr	r2, [r4, #0]
 800753a:	d148      	bne.n	80075ce <HAL_I2C_Master_Transmit+0x1ca>
 800753c:	6993      	ldr	r3, [r2, #24]
 800753e:	0619      	lsls	r1, r3, #24
 8007540:	d5fc      	bpl.n	800753c <HAL_I2C_Master_Transmit+0x138>
 8007542:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8007546:	f44f 40b0 	mov.w	r0, #22528	; 0x5800
 800754a:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800754e:	f8b4 c02a 	ldrh.w	ip, [r4, #42]	; 0x2a
 8007552:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8007556:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800755a:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800755e:	454a      	cmp	r2, r9
 8007560:	bf18      	it	ne
 8007562:	429a      	cmpne	r2, r3
 8007564:	bf14      	ite	ne
 8007566:	2301      	movne	r3, #1
 8007568:	2300      	moveq	r3, #0
 800756a:	4282      	cmp	r2, r0
 800756c:	bf0c      	ite	eq
 800756e:	2300      	moveq	r3, #0
 8007570:	f003 0301 	andne.w	r3, r3, #1
 8007574:	428a      	cmp	r2, r1
 8007576:	bf0c      	ite	eq
 8007578:	2300      	moveq	r3, #0
 800757a:	f003 0301 	andne.w	r3, r3, #1
 800757e:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 8007582:	d93c      	bls.n	80075fe <HAL_I2C_Master_Transmit+0x1fa>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8007584:	21ff      	movs	r1, #255	; 0xff
 8007586:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007588:	2b00      	cmp	r3, #0
 800758a:	d164      	bne.n	8007656 <HAL_I2C_Master_Transmit+0x252>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800758c:	f44f 411c 	mov.w	r1, #39936	; 0x9c00
 8007590:	6853      	ldr	r3, [r2, #4]
 8007592:	f6cf 4100 	movt	r1, #64512	; 0xfc00
 8007596:	400b      	ands	r3, r1
 8007598:	ea43 0308 	orr.w	r3, r3, r8
 800759c:	6053      	str	r3, [r2, #4]
 800759e:	e7a8      	b.n	80074f2 <HAL_I2C_Master_Transmit+0xee>
    return HAL_BUSY;
 80075a0:	2002      	movs	r0, #2
}
 80075a2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80075a6:	21ff      	movs	r1, #255	; 0xff
 80075a8:	8521      	strh	r1, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80075aa:	2a00      	cmp	r2, #0
 80075ac:	d171      	bne.n	8007692 <HAL_I2C_Master_Transmit+0x28e>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80075ae:	f44f 4018 	mov.w	r0, #38912	; 0x9800
 80075b2:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80075b6:	685a      	ldr	r2, [r3, #4]
 80075b8:	f3c7 0709 	ubfx	r7, r7, #0, #10
 80075bc:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 80075c0:	f2c8 11ff 	movt	r1, #33279	; 0x81ff
 80075c4:	4002      	ands	r2, r0
 80075c6:	4339      	orrs	r1, r7
 80075c8:	430a      	orrs	r2, r1
 80075ca:	605a      	str	r2, [r3, #4]
 80075cc:	e787      	b.n	80074de <HAL_I2C_Master_Transmit+0xda>
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80075ce:	6993      	ldr	r3, [r2, #24]
 80075d0:	061b      	lsls	r3, r3, #24
 80075d2:	d4b6      	bmi.n	8007542 <HAL_I2C_Master_Transmit+0x13e>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80075d4:	f7f9 fa32 	bl	8000a3c <HAL_GetTick>
 80075d8:	1b40      	subs	r0, r0, r5
 80075da:	4286      	cmp	r6, r0
 80075dc:	d301      	bcc.n	80075e2 <HAL_I2C_Master_Transmit+0x1de>
 80075de:	2e00      	cmp	r6, #0
 80075e0:	d1a9      	bne.n	8007536 <HAL_I2C_Master_Transmit+0x132>
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80075e2:	6c63      	ldr	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80075e4:	2120      	movs	r1, #32
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80075e6:	2200      	movs	r2, #0
          return HAL_ERROR;
 80075e8:	2001      	movs	r0, #1
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80075ea:	430b      	orrs	r3, r1
        __HAL_UNLOCK(hi2c);
 80075ec:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80075f0:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80075f2:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80075f6:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
}
 80075fa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
          hi2c->XferSize = hi2c->XferCount;
 80075fe:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
 8007600:	b289      	uxth	r1, r1
 8007602:	8521      	strh	r1, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8007604:	fa5f fa81 	uxtb.w	sl, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007608:	bb7b      	cbnz	r3, 800766a <HAL_I2C_Master_Transmit+0x266>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800760a:	f44f 401c 	mov.w	r0, #39936	; 0x9c00
 800760e:	6851      	ldr	r1, [r2, #4]
 8007610:	ea47 430a 	orr.w	r3, r7, sl, lsl #16
 8007614:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 8007618:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800761c:	4001      	ands	r1, r0
 800761e:	430b      	orrs	r3, r1
 8007620:	6053      	str	r3, [r2, #4]
 8007622:	e766      	b.n	80074f2 <HAL_I2C_Master_Transmit+0xee>
        return HAL_ERROR;
 8007624:	2001      	movs	r0, #1
}
 8007626:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800762a:	f7ff fd81 	bl	8007130 <I2C_WaitOnSTOPFlagUntilTimeout>
 800762e:	2800      	cmp	r0, #0
 8007630:	d1f8      	bne.n	8007624 <HAL_I2C_Master_Transmit+0x220>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007632:	6823      	ldr	r3, [r4, #0]
 8007634:	2220      	movs	r2, #32
    I2C_RESET_CR2(hi2c);
 8007636:	f44f 4568 	mov.w	r5, #59392	; 0xe800
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800763a:	61da      	str	r2, [r3, #28]
    I2C_RESET_CR2(hi2c);
 800763c:	6821      	ldr	r1, [r4, #0]
 800763e:	f6cf 6500 	movt	r5, #65024	; 0xfe00
 8007642:	684b      	ldr	r3, [r1, #4]
 8007644:	402b      	ands	r3, r5
 8007646:	604b      	str	r3, [r1, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8007648:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800764c:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8007650:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8007654:	e7a5      	b.n	80075a2 <HAL_I2C_Master_Transmit+0x19e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007656:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800765a:	f641 1131 	movw	r1, #6449	; 0x1931
 800765e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007662:	f00e f901 	bl	8015868 <assert_failed>
 8007666:	6822      	ldr	r2, [r4, #0]
 8007668:	e790      	b.n	800758c <HAL_I2C_Master_Transmit+0x188>
 800766a:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800766e:	f641 1131 	movw	r1, #6449	; 0x1931
 8007672:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007676:	f00e f8f7 	bl	8015868 <assert_failed>
 800767a:	6822      	ldr	r2, [r4, #0]
 800767c:	e7c5      	b.n	800760a <HAL_I2C_Master_Transmit+0x206>
 800767e:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007682:	f641 1131 	movw	r1, #6449	; 0x1931
 8007686:	f6c0 0002 	movt	r0, #2050	; 0x802
 800768a:	f00e f8ed 	bl	8015868 <assert_failed>
 800768e:	6823      	ldr	r3, [r4, #0]
 8007690:	e714      	b.n	80074bc <HAL_I2C_Master_Transmit+0xb8>
 8007692:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8007696:	f641 1131 	movw	r1, #6449	; 0x1931
 800769a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800769e:	f00e f8e3 	bl	8015868 <assert_failed>
 80076a2:	6823      	ldr	r3, [r4, #0]
 80076a4:	e783      	b.n	80075ae <HAL_I2C_Master_Transmit+0x1aa>
 80076a6:	bf00      	nop

080076a8 <HAL_I2C_Master_Transmit_DMA>:
{
 80076a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80076ac:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 80076b0:	2c20      	cmp	r4, #32
 80076b2:	d152      	bne.n	800775a <HAL_I2C_Master_Transmit_DMA+0xb2>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BUSY) == SET)
 80076b4:	6807      	ldr	r7, [r0, #0]
 80076b6:	69bd      	ldr	r5, [r7, #24]
 80076b8:	f415 4500 	ands.w	r5, r5, #32768	; 0x8000
 80076bc:	d14d      	bne.n	800775a <HAL_I2C_Master_Transmit_DMA+0xb2>
    __HAL_LOCK(hi2c);
 80076be:	f890 4040 	ldrb.w	r4, [r0, #64]	; 0x40
 80076c2:	2c01      	cmp	r4, #1
 80076c4:	d049      	beq.n	800775a <HAL_I2C_Master_Transmit_DMA+0xb2>
 80076c6:	460e      	mov	r6, r1
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80076c8:	2100      	movs	r1, #0
 80076ca:	4604      	mov	r4, r0
    hi2c->pBuffPtr    = pData;
 80076cc:	6242      	str	r2, [r0, #36]	; 0x24
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 80076ce:	f04f 0c21 	mov.w	ip, #33	; 0x21
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 80076d2:	2010      	movs	r0, #16
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80076d4:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hi2c->XferISR     = I2C_Master_ISR_DMA;
 80076d8:	f248 7831 	movw	r8, #34609	; 0x8731
    hi2c->State       = HAL_I2C_STATE_BUSY_TX;
 80076dc:	f884 c041 	strb.w	ip, [r4, #65]	; 0x41
    hi2c->Mode        = HAL_I2C_MODE_MASTER;
 80076e0:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    hi2c->XferISR     = I2C_Master_ISR_DMA;
 80076e4:	f6c0 0800 	movt	r8, #2048	; 0x800
    hi2c->ErrorCode   = HAL_I2C_ERROR_NONE;
 80076e8:	6465      	str	r5, [r4, #68]	; 0x44
    __HAL_LOCK(hi2c);
 80076ea:	2001      	movs	r0, #1
    hi2c->XferCount   = Size;
 80076ec:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80076ee:	62e1      	str	r1, [r4, #44]	; 0x2c
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80076f0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->XferISR     = I2C_Master_ISR_DMA;
 80076f2:	f8c4 8034 	str.w	r8, [r4, #52]	; 0x34
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80076f6:	2bff      	cmp	r3, #255	; 0xff
    __HAL_LOCK(hi2c);
 80076f8:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80076fc:	d931      	bls.n	8007762 <HAL_I2C_Master_Transmit_DMA+0xba>
 80076fe:	23ff      	movs	r3, #255	; 0xff
      xfermode = I2C_RELOAD_MODE;
 8007700:	f04f 7980 	mov.w	r9, #16777216	; 0x1000000
 8007704:	8523      	strh	r3, [r4, #40]	; 0x28
      if (hi2c->hdmatx != NULL)
 8007706:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8007708:	2b00      	cmp	r3, #0
 800770a:	d076      	beq.n	80077fa <HAL_I2C_Master_Transmit_DMA+0x152>
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 800770c:	f248 1505 	movw	r5, #33029	; 0x8105
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8007710:	f648 30d1 	movw	r0, #35793	; 0x8bd1
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
 8007714:	2700      	movs	r7, #0
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 8007716:	4611      	mov	r1, r2
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 8007718:	f6c0 0500 	movt	r5, #2048	; 0x800
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 800771c:	f6c0 0000 	movt	r0, #2048	; 0x800
        hi2c->hdmatx->XferCpltCallback = I2C_DMAMasterTransmitCplt;
 8007720:	63dd      	str	r5, [r3, #60]	; 0x3c
        hi2c->hdmatx->XferErrorCallback = I2C_DMAError;
 8007722:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8007724:	64d8      	str	r0, [r3, #76]	; 0x4c
        hi2c->hdmatx->XferHalfCpltCallback = NULL;
 8007726:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8007728:	641f      	str	r7, [r3, #64]	; 0x40
        hi2c->hdmatx->XferAbortCallback = NULL;
 800772a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800772c:	651f      	str	r7, [r3, #80]	; 0x50
        dmaxferstatus = HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)pData, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize);
 800772e:	6822      	ldr	r2, [r4, #0]
 8007730:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8007732:	3228      	adds	r2, #40	; 0x28
 8007734:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007736:	f7fc f971 	bl	8003a1c <HAL_DMA_Start_IT>
      if (dmaxferstatus == HAL_OK)
 800773a:	4605      	mov	r5, r0
 800773c:	2800      	cmp	r0, #0
 800773e:	d076      	beq.n	800782e <HAL_I2C_Master_Transmit_DMA+0x186>
        hi2c->State     = HAL_I2C_STATE_READY;
 8007740:	2320      	movs	r3, #32
        __HAL_UNLOCK(hi2c);
 8007742:	f884 7040 	strb.w	r7, [r4, #64]	; 0x40
        return HAL_ERROR;
 8007746:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
 8007748:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
 800774c:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA;
 8007750:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007752:	f043 0310 	orr.w	r3, r3, #16
 8007756:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 8007758:	e000      	b.n	800775c <HAL_I2C_Master_Transmit_DMA+0xb4>
    return HAL_BUSY;
 800775a:	2502      	movs	r5, #2
}
 800775c:	4628      	mov	r0, r5
 800775e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      hi2c->XferSize = hi2c->XferCount;
 8007762:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007764:	b29b      	uxth	r3, r3
 8007766:	8523      	strh	r3, [r4, #40]	; 0x28
    if (hi2c->XferSize > 0U)
 8007768:	2b00      	cmp	r3, #0
 800776a:	d153      	bne.n	8007814 <HAL_I2C_Master_Transmit_DMA+0x16c>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800776c:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 8007770:	f44f 42b0 	mov.w	r2, #22528	; 0x5800
 8007774:	f44f 41b8 	mov.w	r1, #23552	; 0x5c00
 8007778:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800777c:	f2c4 0200 	movt	r2, #16384	; 0x4000
 8007780:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8007784:	429f      	cmp	r7, r3
 8007786:	bf18      	it	ne
 8007788:	4297      	cmpne	r7, r2
      hi2c->XferISR = I2C_Master_ISR_IT;
 800778a:	f248 4231 	movw	r2, #33841	; 0x8431
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800778e:	bf14      	ite	ne
 8007790:	2301      	movne	r3, #1
 8007792:	2300      	moveq	r3, #0
      hi2c->XferISR = I2C_Master_ISR_IT;
 8007794:	f6c0 0200 	movt	r2, #2048	; 0x800
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8007798:	428f      	cmp	r7, r1
 800779a:	bf0c      	ite	eq
 800779c:	2300      	moveq	r3, #0
 800779e:	f003 0301 	andne.w	r3, r3, #1
      hi2c->XferISR = I2C_Master_ISR_IT;
 80077a2:	6362      	str	r2, [r4, #52]	; 0x34
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80077a4:	b12b      	cbz	r3, 80077b2 <HAL_I2C_Master_Transmit_DMA+0x10a>
 80077a6:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80077aa:	f6c5 0300 	movt	r3, #22528	; 0x5800
 80077ae:	429f      	cmp	r7, r3
 80077b0:	d133      	bne.n	800781a <HAL_I2C_Master_Transmit_DMA+0x172>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80077b2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80077b6:	f44f 4018 	mov.w	r0, #38912	; 0x9800
 80077ba:	687a      	ldr	r2, [r7, #4]
 80077bc:	f3c6 0109 	ubfx	r1, r6, #0, #10
 80077c0:	f2c8 2300 	movt	r3, #33280	; 0x8200
 80077c4:	f6cf 4000 	movt	r0, #64512	; 0xfc00
 80077c8:	430b      	orrs	r3, r1
 80077ca:	4002      	ands	r2, r0
      __HAL_UNLOCK(hi2c);
 80077cc:	2100      	movs	r1, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80077ce:	4313      	orrs	r3, r2
 80077d0:	607b      	str	r3, [r7, #4]
  */
static void I2C_Enable_IRQ(I2C_HandleTypeDef *hi2c, uint16_t InterruptRequest)
{
  uint32_t tmpisr = 0U;

  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80077d2:	6b62      	ldr	r2, [r4, #52]	; 0x34
      __HAL_UNLOCK(hi2c);
 80077d4:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80077d8:	4542      	cmp	r2, r8
 80077da:	d007      	beq.n	80077ec <HAL_I2C_Master_Transmit_DMA+0x144>
 80077dc:	f647 7341 	movw	r3, #32577	; 0x7f41
 80077e0:	f6c0 0300 	movt	r3, #2048	; 0x800
 80077e4:	429a      	cmp	r2, r3
 80077e6:	d001      	beq.n	80077ec <HAL_I2C_Master_Transmit_DMA+0x144>
 80077e8:	21f2      	movs	r1, #242	; 0xf2
 80077ea:	e000      	b.n	80077ee <HAL_I2C_Master_Transmit_DMA+0x146>
 80077ec:	2100      	movs	r1, #0
  }

  /* Enable interrupts only at the end */
  /* to avoid the risk of I2C interrupt handle execution before */
  /* all interrupts requested done */
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 80077ee:	6822      	ldr	r2, [r4, #0]
    return HAL_OK;
 80077f0:	2500      	movs	r5, #0
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 80077f2:	6813      	ldr	r3, [r2, #0]
 80077f4:	430b      	orrs	r3, r1
 80077f6:	6013      	str	r3, [r2, #0]
 80077f8:	e7b0      	b.n	800775c <HAL_I2C_Master_Transmit_DMA+0xb4>
        hi2c->State     = HAL_I2C_STATE_READY;
 80077fa:	2220      	movs	r2, #32
        __HAL_UNLOCK(hi2c);
 80077fc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
        return HAL_ERROR;
 8007800:	2501      	movs	r5, #1
        hi2c->State     = HAL_I2C_STATE_READY;
 8007802:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
        hi2c->Mode      = HAL_I2C_MODE_NONE;
 8007806:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
        hi2c->ErrorCode |= HAL_I2C_ERROR_DMA_PARAM;
 800780a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800780c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8007810:	6463      	str	r3, [r4, #68]	; 0x44
        return HAL_ERROR;
 8007812:	e7a3      	b.n	800775c <HAL_I2C_Master_Transmit_DMA+0xb4>
      xfermode = I2C_AUTOEND_MODE;
 8007814:	f04f 7900 	mov.w	r9, #33554432	; 0x2000000
 8007818:	e775      	b.n	8007706 <HAL_I2C_Master_Transmit_DMA+0x5e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800781a:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800781e:	f641 1131 	movw	r1, #6449	; 0x1931
 8007822:	f6c0 0002 	movt	r0, #2050	; 0x802
 8007826:	f00e f81f 	bl	8015868 <assert_failed>
 800782a:	6827      	ldr	r7, [r4, #0]
 800782c:	e7c1      	b.n	80077b2 <HAL_I2C_Master_Transmit_DMA+0x10a>
 800782e:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 8007832:	f44f 41b0 	mov.w	r1, #22528	; 0x5800
 8007836:	6820      	ldr	r0, [r4, #0]
 8007838:	f44f 42b8 	mov.w	r2, #23552	; 0x5c00
 800783c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8007840:	f2c4 0100 	movt	r1, #16384	; 0x4000
 8007844:	f2c4 0200 	movt	r2, #16384	; 0x4000
        I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, xfermode, I2C_GENERATE_START_WRITE);
 8007848:	f894 7028 	ldrb.w	r7, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800784c:	4298      	cmp	r0, r3
 800784e:	bf18      	it	ne
 8007850:	4288      	cmpne	r0, r1
 8007852:	bf14      	ite	ne
 8007854:	2301      	movne	r3, #1
 8007856:	2300      	moveq	r3, #0
 8007858:	4290      	cmp	r0, r2
 800785a:	bf0c      	ite	eq
 800785c:	2200      	moveq	r2, #0
 800785e:	f003 0201 	andne.w	r2, r3, #1
 8007862:	b12a      	cbz	r2, 8007870 <HAL_I2C_Master_Transmit_DMA+0x1c8>
 8007864:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8007868:	f6c5 0300 	movt	r3, #22528	; 0x5800
 800786c:	4298      	cmp	r0, r3
 800786e:	d134      	bne.n	80078da <HAL_I2C_Master_Transmit_DMA+0x232>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8007870:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8007874:	f44f 4c18 	mov.w	ip, #38912	; 0x9800
 8007878:	6842      	ldr	r2, [r0, #4]
 800787a:	f3c6 0109 	ubfx	r1, r6, #0, #10
 800787e:	f2c8 0300 	movt	r3, #32768	; 0x8000
 8007882:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
        __HAL_UNLOCK(hi2c);
 8007886:	2600      	movs	r6, #0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8007888:	430b      	orrs	r3, r1
 800788a:	ea02 020c 	and.w	r2, r2, ip
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 800788e:	f647 7141 	movw	r1, #32577	; 0x7f41
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8007892:	4313      	orrs	r3, r2
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8007894:	f6c0 0100 	movt	r1, #2048	; 0x800
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8007898:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 800789c:	ea43 0309 	orr.w	r3, r3, r9
 80078a0:	6043      	str	r3, [r0, #4]
        hi2c->XferCount -= hi2c->XferSize;
 80078a2:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
 80078a4:	8d20      	ldrh	r0, [r4, #40]	; 0x28
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80078a6:	6b63      	ldr	r3, [r4, #52]	; 0x34
        hi2c->XferCount -= hi2c->XferSize;
 80078a8:	1a12      	subs	r2, r2, r0
        __HAL_UNLOCK(hi2c);
 80078aa:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80078ae:	428b      	cmp	r3, r1
        hi2c->XferCount -= hi2c->XferSize;
 80078b0:	b292      	uxth	r2, r2
 80078b2:	8562      	strh	r2, [r4, #42]	; 0x2a
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80078b4:	d00f      	beq.n	80078d6 <HAL_I2C_Master_Transmit_DMA+0x22e>
 80078b6:	eba3 0308 	sub.w	r3, r3, r8
 80078ba:	fab3 f383 	clz	r3, r3
 80078be:	095b      	lsrs	r3, r3, #5
 80078c0:	b94b      	cbnz	r3, 80078d6 <HAL_I2C_Master_Transmit_DMA+0x22e>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 80078c2:	6821      	ldr	r1, [r4, #0]
 80078c4:	680a      	ldr	r2, [r1, #0]
 80078c6:	4313      	orrs	r3, r2
 80078c8:	600b      	str	r3, [r1, #0]
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 80078ca:	6822      	ldr	r2, [r4, #0]
 80078cc:	6813      	ldr	r3, [r2, #0]
 80078ce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80078d2:	6013      	str	r3, [r2, #0]
 80078d4:	e742      	b.n	800775c <HAL_I2C_Master_Transmit_DMA+0xb4>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80078d6:	2390      	movs	r3, #144	; 0x90
 80078d8:	e7f3      	b.n	80078c2 <HAL_I2C_Master_Transmit_DMA+0x21a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80078da:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80078de:	f641 1131 	movw	r1, #6449	; 0x1931
 80078e2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80078e6:	f00d ffbf 	bl	8015868 <assert_failed>
 80078ea:	6820      	ldr	r0, [r4, #0]
 80078ec:	e7c0      	b.n	8007870 <HAL_I2C_Master_Transmit_DMA+0x1c8>
 80078ee:	bf00      	nop

080078f0 <HAL_I2C_EV_IRQHandler>:
{
 80078f0:	b410      	push	{r4}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80078f2:	6803      	ldr	r3, [r0, #0]
  if (hi2c->XferISR != NULL)
 80078f4:	6b44      	ldr	r4, [r0, #52]	; 0x34
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80078f6:	6999      	ldr	r1, [r3, #24]
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 80078f8:	681a      	ldr	r2, [r3, #0]
  if (hi2c->XferISR != NULL)
 80078fa:	b11c      	cbz	r4, 8007904 <HAL_I2C_EV_IRQHandler+0x14>
    hi2c->XferISR(hi2c, itflags, itsources);
 80078fc:	4623      	mov	r3, r4
}
 80078fe:	f85d 4b04 	ldr.w	r4, [sp], #4
    hi2c->XferISR(hi2c, itflags, itsources);
 8007902:	4718      	bx	r3
}
 8007904:	f85d 4b04 	ldr.w	r4, [sp], #4
 8007908:	4770      	bx	lr
 800790a:	bf00      	nop

0800790c <HAL_I2C_MasterTxCpltCallback>:
 800790c:	4770      	bx	lr
 800790e:	bf00      	nop

08007910 <HAL_I2C_MasterRxCpltCallback>:
 8007910:	4770      	bx	lr
 8007912:	bf00      	nop

08007914 <HAL_I2C_SlaveTxCpltCallback>:
 8007914:	4770      	bx	lr
 8007916:	bf00      	nop

08007918 <HAL_I2C_SlaveRxCpltCallback>:
 8007918:	4770      	bx	lr
 800791a:	bf00      	nop

0800791c <I2C_ITSlaveSeqCplt>:
{
 800791c:	b538      	push	{r3, r4, r5, lr}
 800791e:	4603      	mov	r3, r0
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007920:	2000      	movs	r0, #0
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8007922:	681a      	ldr	r2, [r3, #0]
 8007924:	6811      	ldr	r1, [r2, #0]
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007926:	f883 0042 	strb.w	r0, [r3, #66]	; 0x42
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 800792a:	0448      	lsls	r0, r1, #17
 800792c:	d50c      	bpl.n	8007948 <I2C_ITSlaveSeqCplt+0x2c>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 800792e:	6811      	ldr	r1, [r2, #0]
 8007930:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
 8007934:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8007936:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 800793a:	2a29      	cmp	r2, #41	; 0x29
 800793c:	d00e      	beq.n	800795c <I2C_ITSlaveSeqCplt+0x40>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX_LISTEN)
 800793e:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8007942:	2a2a      	cmp	r2, #42	; 0x2a
 8007944:	d024      	beq.n	8007990 <I2C_ITSlaveSeqCplt+0x74>
}
 8007946:	bd38      	pop	{r3, r4, r5, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8007948:	0409      	lsls	r1, r1, #16
 800794a:	d5f4      	bpl.n	8007936 <I2C_ITSlaveSeqCplt+0x1a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 800794c:	6811      	ldr	r1, [r2, #0]
 800794e:	f421 4100 	bic.w	r1, r1, #32768	; 0x8000
 8007952:	6011      	str	r1, [r2, #0]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN)
 8007954:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8007958:	2a29      	cmp	r2, #41	; 0x29
 800795a:	d1f0      	bne.n	800793e <I2C_ITSlaveSeqCplt+0x22>
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800795c:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800795e:	2221      	movs	r2, #33	; 0x21
  }

  /* Disable interrupts only at the end */
  /* to avoid a breaking situation like at "t" time */
  /* all disable interrupts request are not done */
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007960:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007962:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007964:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8007968:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 800796a:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800796c:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007970:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007972:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8007976:	2928      	cmp	r1, #40	; 0x28
 8007978:	bf14      	ite	ne
 800797a:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
 800797e:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007982:	400a      	ands	r2, r1
 8007984:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 8007986:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 800798a:	f7ff ffc3 	bl	8007914 <HAL_I2C_SlaveTxCpltCallback>
}
 800798e:	bd38      	pop	{r3, r4, r5, pc}
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007990:	2128      	movs	r1, #40	; 0x28
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8007992:	2222      	movs	r2, #34	; 0x22
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007994:	681c      	ldr	r4, [r3, #0]
    __HAL_UNLOCK(hi2c);
 8007996:	2500      	movs	r5, #0
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007998:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 800799c:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 800799e:	631a      	str	r2, [r3, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80079a0:	f893 1041 	ldrb.w	r1, [r3, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80079a4:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80079a6:	f001 0128 	and.w	r1, r1, #40	; 0x28
 80079aa:	2928      	cmp	r1, #40	; 0x28
 80079ac:	bf14      	ite	ne
 80079ae:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 80079b2:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80079b6:	400a      	ands	r2, r1
 80079b8:	6022      	str	r2, [r4, #0]
    __HAL_UNLOCK(hi2c);
 80079ba:	f883 5040 	strb.w	r5, [r3, #64]	; 0x40
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 80079be:	f7ff ffab 	bl	8007918 <HAL_I2C_SlaveRxCpltCallback>
}
 80079c2:	bd38      	pop	{r3, r4, r5, pc}

080079c4 <HAL_I2C_AddrCallback>:
}
 80079c4:	4770      	bx	lr
 80079c6:	bf00      	nop

080079c8 <I2C_ITAddrCplt.isra.9.part.10>:
static void I2C_ITAddrCplt(I2C_HandleTypeDef *hi2c, uint32_t ITFlags)
 80079c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    transferdirection = I2C_GET_DIR(hi2c);
 80079ca:	6804      	ldr	r4, [r0, #0]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80079cc:	68c3      	ldr	r3, [r0, #12]
    transferdirection = I2C_GET_DIR(hi2c);
 80079ce:	69a1      	ldr	r1, [r4, #24]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80079d0:	69a2      	ldr	r2, [r4, #24]
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80079d2:	2b02      	cmp	r3, #2
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80079d4:	68a6      	ldr	r6, [r4, #8]
    transferdirection = I2C_GET_DIR(hi2c);
 80079d6:	f3c1 4100 	ubfx	r1, r1, #16, #1
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80079da:	ea4f 4212 	mov.w	r2, r2, lsr #16
    ownadd2code       = I2C_GET_OWN_ADDRESS2(hi2c);
 80079de:	68e7      	ldr	r7, [r4, #12]
    slaveaddrcode     = I2C_GET_ADDR_MATCH(hi2c);
 80079e0:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
    if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80079e4:	d10d      	bne.n	8007a02 <I2C_ITAddrCplt.isra.9.part.10+0x3a>
    ownadd1code       = I2C_GET_OWN_ADDRESS1(hi2c);
 80079e6:	f3c6 0609 	ubfx	r6, r6, #0, #10
      if ((slaveaddrcode & SlaveAddr_MSK) == ((ownadd1code >> SlaveAddr_SHIFT) & SlaveAddr_MSK))
 80079ea:	ea82 13d6 	eor.w	r3, r2, r6, lsr #7
 80079ee:	f013 0306 	ands.w	r3, r3, #6
 80079f2:	d110      	bne.n	8007a16 <I2C_ITAddrCplt.isra.9.part.10+0x4e>
        hi2c->AddrEventCount++;
 80079f4:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80079f6:	3201      	adds	r2, #1
 80079f8:	6482      	str	r2, [r0, #72]	; 0x48
        if (hi2c->AddrEventCount == 2U)
 80079fa:	6c82      	ldr	r2, [r0, #72]	; 0x48
 80079fc:	2a02      	cmp	r2, #2
 80079fe:	d016      	beq.n	8007a2e <I2C_ITAddrCplt.isra.9.part.10+0x66>
}
 8007a00:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a02:	6823      	ldr	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
 8007a04:	2600      	movs	r6, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a06:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
 8007a0a:	6023      	str	r3, [r4, #0]
      __HAL_UNLOCK(hi2c);
 8007a0c:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
      HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8007a10:	f7ff ffd8 	bl	80079c4 <HAL_I2C_AddrCallback>
}
 8007a14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a16:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
 8007a18:	2600      	movs	r6, #0
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8007a1a:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007a1e:	f023 03b8 	bic.w	r3, r3, #184	; 0xb8
 8007a22:	6023      	str	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
 8007a24:	f880 6040 	strb.w	r6, [r0, #64]	; 0x40
        HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8007a28:	f7ff ffcc 	bl	80079c4 <HAL_I2C_AddrCallback>
}
 8007a2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8007a2e:	2708      	movs	r7, #8
          hi2c->AddrEventCount = 0U;
 8007a30:	6483      	str	r3, [r0, #72]	; 0x48
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8007a32:	4632      	mov	r2, r6
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8007a34:	61e7      	str	r7, [r4, #28]
          __HAL_UNLOCK(hi2c);
 8007a36:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
          HAL_I2C_AddrCallback(hi2c, transferdirection, slaveaddrcode);
 8007a3a:	f7ff ffc3 	bl	80079c4 <HAL_I2C_AddrCallback>
}
 8007a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08007a40 <HAL_I2C_ListenCpltCallback>:
 8007a40:	4770      	bx	lr
 8007a42:	bf00      	nop

08007a44 <HAL_I2C_MemTxCpltCallback>:
 8007a44:	4770      	bx	lr
 8007a46:	bf00      	nop

08007a48 <HAL_I2C_MemRxCpltCallback>:
 8007a48:	4770      	bx	lr
 8007a4a:	bf00      	nop

08007a4c <HAL_I2C_ErrorCallback>:
 8007a4c:	4770      	bx	lr
 8007a4e:	bf00      	nop

08007a50 <HAL_I2C_AbortCpltCallback>:
 8007a50:	4770      	bx	lr
 8007a52:	bf00      	nop

08007a54 <I2C_DMAAbort>:
{
 8007a54:	b508      	push	{r3, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8007a56:	6b83      	ldr	r3, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
 8007a58:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8007a5a:	b10a      	cbz	r2, 8007a60 <I2C_DMAAbort+0xc>
    hi2c->hdmatx->XferAbortCallback = NULL;
 8007a5c:	2100      	movs	r1, #0
 8007a5e:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->hdmarx != NULL)
 8007a60:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8007a62:	b10a      	cbz	r2, 8007a68 <I2C_DMAAbort+0x14>
    hi2c->hdmarx->XferAbortCallback = NULL;
 8007a64:	2100      	movs	r1, #0
 8007a66:	6511      	str	r1, [r2, #80]	; 0x50
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8007a68:	f893 2041 	ldrb.w	r2, [r3, #65]	; 0x41
 8007a6c:	2a60      	cmp	r2, #96	; 0x60
 8007a6e:	d007      	beq.n	8007a80 <I2C_DMAAbort+0x2c>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007a70:	2200      	movs	r2, #0
    HAL_I2C_ErrorCallback(hi2c);
 8007a72:	4618      	mov	r0, r3
    hi2c->PreviousState = I2C_STATE_NONE;
 8007a74:	631a      	str	r2, [r3, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8007a76:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8007a7a:	f7ff ffe7 	bl	8007a4c <HAL_I2C_ErrorCallback>
}
 8007a7e:	bd08      	pop	{r3, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
 8007a80:	2200      	movs	r2, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8007a82:	2120      	movs	r1, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8007a84:	4618      	mov	r0, r3
    hi2c->State = HAL_I2C_STATE_READY;
 8007a86:	f883 1041 	strb.w	r1, [r3, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007a8a:	f883 2040 	strb.w	r2, [r3, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8007a8e:	631a      	str	r2, [r3, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8007a90:	f7ff ffde 	bl	8007a50 <HAL_I2C_AbortCpltCallback>
}
 8007a94:	bd08      	pop	{r3, pc}
 8007a96:	bf00      	nop

08007a98 <I2C_ITError>:
{
 8007a98:	b570      	push	{r4, r5, r6, lr}
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007a9a:	2500      	movs	r5, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8007a9c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 8007aa0:	4604      	mov	r4, r0
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007aa2:	462a      	mov	r2, r5
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007aa4:	f6cf 75ff 	movt	r5, #65535	; 0xffff
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007aa8:	3b28      	subs	r3, #40	; 0x28
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8007aaa:	f880 2042 	strb.w	r2, [r0, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8007aae:	62c5      	str	r5, [r0, #44]	; 0x2c
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007ab0:	2b02      	cmp	r3, #2
  hi2c->XferCount     = 0U;
 8007ab2:	8542      	strh	r2, [r0, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8007ab4:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8007ab6:	6800      	ldr	r0, [r0, #0]
 8007ab8:	ea41 0102 	orr.w	r1, r1, r2
 8007abc:	6461      	str	r1, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8007abe:	d833      	bhi.n	8007b28 <I2C_ITError+0x90>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ac0:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007ac4:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ac6:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007aca:	f647 5399 	movw	r3, #32153	; 0x7d99
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ace:	4032      	ands	r2, r6
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ad0:	4035      	ands	r5, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007ad2:	f6c0 0300 	movt	r3, #2048	; 0x800
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ad6:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007ad8:	6802      	ldr	r2, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ada:	bf14      	ite	ne
 8007adc:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
 8007ae0:	f06f 0146 	mvneq.w	r1, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007ae4:	42b5      	cmp	r5, r6
 8007ae6:	bf18      	it	ne
 8007ae8:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007aec:	400a      	ands	r2, r1
 8007aee:	6002      	str	r2, [r0, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8007af0:	6363      	str	r3, [r4, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8007af2:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007af6:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8007af8:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8007afa:	b118      	cbz	r0, 8007b04 <I2C_ITError+0x6c>
 8007afc:	2b11      	cmp	r3, #17
 8007afe:	d025      	beq.n	8007b4c <I2C_ITError+0xb4>
 8007b00:	2b21      	cmp	r3, #33	; 0x21
 8007b02:	d023      	beq.n	8007b4c <I2C_ITError+0xb4>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8007b04:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007b06:	b118      	cbz	r0, 8007b10 <I2C_ITError+0x78>
 8007b08:	2b12      	cmp	r3, #18
 8007b0a:	d03a      	beq.n	8007b82 <I2C_ITError+0xea>
 8007b0c:	2b22      	cmp	r3, #34	; 0x22
 8007b0e:	d038      	beq.n	8007b82 <I2C_ITError+0xea>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8007b10:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007b14:	2b60      	cmp	r3, #96	; 0x60
 8007b16:	d05a      	beq.n	8007bce <I2C_ITError+0x136>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007b18:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8007b1a:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 8007b1c:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8007b1e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8007b22:	f7ff ff93 	bl	8007a4c <HAL_I2C_ErrorCallback>
}
 8007b26:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b28:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007b2c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007b30:	6803      	ldr	r3, [r0, #0]
 8007b32:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007b36:	6003      	str	r3, [r0, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8007b38:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007b3c:	2b60      	cmp	r3, #96	; 0x60
 8007b3e:	d002      	beq.n	8007b46 <I2C_ITError+0xae>
      hi2c->State         = HAL_I2C_STATE_READY;
 8007b40:	2320      	movs	r3, #32
 8007b42:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8007b46:	2300      	movs	r3, #0
 8007b48:	6363      	str	r3, [r4, #52]	; 0x34
 8007b4a:	e7d4      	b.n	8007af6 <I2C_ITError+0x5e>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8007b4c:	6823      	ldr	r3, [r4, #0]
 8007b4e:	681a      	ldr	r2, [r3, #0]
 8007b50:	0451      	lsls	r1, r2, #17
 8007b52:	d436      	bmi.n	8007bc2 <I2C_ITError+0x12a>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8007b54:	f7fd fc70 	bl	8005438 <HAL_DMA_GetState>
 8007b58:	2801      	cmp	r0, #1
 8007b5a:	d0d9      	beq.n	8007b10 <I2C_ITError+0x78>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007b5c:	f647 2355 	movw	r3, #31317	; 0x7a55
 8007b60:	6ba1      	ldr	r1, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8007b62:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8007b64:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007b68:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007b6a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8007b6e:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007b70:	f7fc fdc8 	bl	8004704 <HAL_DMA_Abort_IT>
 8007b74:	2800      	cmp	r0, #0
 8007b76:	d0d6      	beq.n	8007b26 <I2C_ITError+0x8e>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007b78:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8007b7a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8007b7e:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007b80:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8007b82:	6823      	ldr	r3, [r4, #0]
 8007b84:	681a      	ldr	r2, [r3, #0]
 8007b86:	0412      	lsls	r2, r2, #16
 8007b88:	d504      	bpl.n	8007b94 <I2C_ITError+0xfc>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8007b8a:	681a      	ldr	r2, [r3, #0]
 8007b8c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8007b90:	601a      	str	r2, [r3, #0]
 8007b92:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8007b94:	f7fd fc50 	bl	8005438 <HAL_DMA_GetState>
 8007b98:	2801      	cmp	r0, #1
 8007b9a:	d0b9      	beq.n	8007b10 <I2C_ITError+0x78>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007b9c:	f647 2355 	movw	r3, #31317	; 0x7a55
 8007ba0:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8007ba2:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8007ba4:	f6c0 0300 	movt	r3, #2048	; 0x800
 8007ba8:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8007baa:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8007bae:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8007bb0:	f7fc fda8 	bl	8004704 <HAL_DMA_Abort_IT>
 8007bb4:	2800      	cmp	r0, #0
 8007bb6:	d0b6      	beq.n	8007b26 <I2C_ITError+0x8e>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007bb8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 8007bba:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8007bbe:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8007bc0:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007bc2:	681a      	ldr	r2, [r3, #0]
 8007bc4:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8007bc8:	601a      	str	r2, [r3, #0]
 8007bca:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8007bcc:	e7c2      	b.n	8007b54 <I2C_ITError+0xbc>
    hi2c->PreviousState = I2C_STATE_NONE;
 8007bce:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8007bd0:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8007bd2:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8007bd4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007bd8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8007bdc:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8007bde:	f7ff ff37 	bl	8007a50 <HAL_I2C_AbortCpltCallback>
}
 8007be2:	bd70      	pop	{r4, r5, r6, pc}

08007be4 <I2C_ITSlaveCplt>:
{
 8007be4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007be6:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007be8:	2020      	movs	r0, #32
{
 8007bea:	460d      	mov	r5, r1
  uint32_t tmpcr1value = READ_REG(hi2c->Instance->CR1);
 8007bec:	6822      	ldr	r2, [r4, #0]
 8007bee:	6816      	ldr	r6, [r2, #0]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8007bf0:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8007bf4:	61d0      	str	r0, [r2, #28]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8007bf6:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007bfa:	6821      	ldr	r1, [r4, #0]
  if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 8007bfc:	2b21      	cmp	r3, #33	; 0x21
 8007bfe:	d16b      	bne.n	8007cd8 <I2C_ITSlaveCplt+0xf4>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007c00:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007c04:	680a      	ldr	r2, [r1, #0]
 8007c06:	f022 02fa 	bic.w	r2, r2, #250	; 0xfa
 8007c0a:	600a      	str	r2, [r1, #0]
 8007c0c:	6821      	ldr	r1, [r4, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_TX;
 8007c0e:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8007c10:	684a      	ldr	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
 8007c12:	f44f 4068 	mov.w	r0, #59392	; 0xe800
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8007c16:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
  I2C_RESET_CR2(hi2c);
 8007c1a:	f6cf 6000 	movt	r0, #65024	; 0xfe00
  hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8007c1e:	604a      	str	r2, [r1, #4]
  I2C_RESET_CR2(hi2c);
 8007c20:	6822      	ldr	r2, [r4, #0]
 8007c22:	6853      	ldr	r3, [r2, #4]
 8007c24:	4003      	ands	r3, r0
 8007c26:	6053      	str	r3, [r2, #4]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007c28:	6823      	ldr	r3, [r4, #0]
 8007c2a:	699a      	ldr	r2, [r3, #24]
 8007c2c:	0791      	lsls	r1, r2, #30
 8007c2e:	d502      	bpl.n	8007c36 <I2C_ITSlaveCplt+0x52>
    hi2c->Instance->TXDR = 0x00U;
 8007c30:	2200      	movs	r2, #0
 8007c32:	629a      	str	r2, [r3, #40]	; 0x28
 8007c34:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007c36:	699a      	ldr	r2, [r3, #24]
 8007c38:	07d2      	lsls	r2, r2, #31
 8007c3a:	d403      	bmi.n	8007c44 <I2C_ITSlaveCplt+0x60>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007c3c:	699a      	ldr	r2, [r3, #24]
 8007c3e:	f042 0201 	orr.w	r2, r2, #1
 8007c42:	619a      	str	r2, [r3, #24]
  if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_TXDMAEN) != RESET)
 8007c44:	0477      	lsls	r7, r6, #17
 8007c46:	d53c      	bpl.n	8007cc2 <I2C_ITSlaveCplt+0xde>
    hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8007c48:	6822      	ldr	r2, [r4, #0]
 8007c4a:	6813      	ldr	r3, [r2, #0]
 8007c4c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8007c50:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmatx != NULL)
 8007c52:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8007c54:	b11a      	cbz	r2, 8007c5e <I2C_ITSlaveCplt+0x7a>
      hi2c->XferCount = (uint16_t)__HAL_DMA_GET_COUNTER(hi2c->hdmarx);
 8007c56:	6812      	ldr	r2, [r2, #0]
 8007c58:	6853      	ldr	r3, [r2, #4]
 8007c5a:	b29b      	uxth	r3, r3
 8007c5c:	8563      	strh	r3, [r4, #42]	; 0x2a
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET)
 8007c5e:	0769      	lsls	r1, r5, #29
 8007c60:	d50b      	bpl.n	8007c7a <I2C_ITSlaveCplt+0x96>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007c62:	6822      	ldr	r2, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
 8007c64:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007c68:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007c6a:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007c6c:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8007c6e:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007c70:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8007c72:	3301      	adds	r3, #1
 8007c74:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007c76:	2a00      	cmp	r2, #0
 8007c78:	d147      	bne.n	8007d0a <I2C_ITSlaveCplt+0x126>
  if (hi2c->XferCount != 0U)
 8007c7a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007c7c:	b29b      	uxth	r3, r3
 8007c7e:	b11b      	cbz	r3, 8007c88 <I2C_ITSlaveCplt+0xa4>
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007c80:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007c82:	f043 0304 	orr.w	r3, r3, #4
 8007c86:	6463      	str	r3, [r4, #68]	; 0x44
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007c88:	2700      	movs	r7, #0
 8007c8a:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8007c8e:	6c66      	ldr	r6, [r4, #68]	; 0x44
  hi2c->XferISR = NULL;
 8007c90:	6367      	str	r7, [r4, #52]	; 0x34
  if (hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
 8007c92:	2e00      	cmp	r6, #0
 8007c94:	d140      	bne.n	8007d18 <I2C_ITSlaveCplt+0x134>
  else if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8007c96:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8007c98:	2500      	movs	r5, #0
 8007c9a:	f513 3f80 	cmn.w	r3, #65536	; 0x10000
 8007c9e:	f6cf 75ff 	movt	r5, #65535	; 0xffff
 8007ca2:	d124      	bne.n	8007cee <I2C_ITSlaveCplt+0x10a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8007ca4:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8007ca8:	4620      	mov	r0, r4
    __HAL_UNLOCK(hi2c);
 8007caa:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8007cae:	2b22      	cmp	r3, #34	; 0x22
    hi2c->State = HAL_I2C_STATE_READY;
 8007cb0:	f04f 0320 	mov.w	r3, #32
 8007cb4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8007cb8:	6326      	str	r6, [r4, #48]	; 0x30
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8007cba:	d068      	beq.n	8007d8e <I2C_ITSlaveCplt+0x1aa>
    HAL_I2C_SlaveTxCpltCallback(hi2c);
 8007cbc:	f7ff fe2a 	bl	8007914 <HAL_I2C_SlaveTxCpltCallback>
}
 8007cc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if (I2C_CHECK_IT_SOURCE(tmpcr1value, I2C_CR1_RXDMAEN) != RESET)
 8007cc2:	0430      	lsls	r0, r6, #16
 8007cc4:	d5cb      	bpl.n	8007c5e <I2C_ITSlaveCplt+0x7a>
    hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8007cc6:	6822      	ldr	r2, [r4, #0]
 8007cc8:	6813      	ldr	r3, [r2, #0]
 8007cca:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007cce:	6013      	str	r3, [r2, #0]
    if (hi2c->hdmarx != NULL)
 8007cd0:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8007cd2:	2a00      	cmp	r2, #0
 8007cd4:	d1bf      	bne.n	8007c56 <I2C_ITSlaveCplt+0x72>
 8007cd6:	e7c2      	b.n	8007c5e <I2C_ITSlaveCplt+0x7a>
  else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 8007cd8:	2b22      	cmp	r3, #34	; 0x22
 8007cda:	d199      	bne.n	8007c10 <I2C_ITSlaveCplt+0x2c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007cdc:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007ce0:	680a      	ldr	r2, [r1, #0]
 8007ce2:	f022 02fc 	bic.w	r2, r2, #252	; 0xfc
 8007ce6:	600a      	str	r2, [r1, #0]
    hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 8007ce8:	6323      	str	r3, [r4, #48]	; 0x30
 8007cea:	6821      	ldr	r1, [r4, #0]
 8007cec:	e790      	b.n	8007c10 <I2C_ITSlaveCplt+0x2c>
    I2C_ITSlaveSeqCplt(hi2c);
 8007cee:	4620      	mov	r0, r4
 8007cf0:	f7ff fe14 	bl	800791c <I2C_ITSlaveSeqCplt>
    hi2c->State = HAL_I2C_STATE_READY;
 8007cf4:	2320      	movs	r3, #32
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007cf6:	62e5      	str	r5, [r4, #44]	; 0x2c
    HAL_I2C_ListenCpltCallback(hi2c);
 8007cf8:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8007cfa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8007cfe:	f884 6040 	strb.w	r6, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8007d02:	6326      	str	r6, [r4, #48]	; 0x30
    HAL_I2C_ListenCpltCallback(hi2c);
 8007d04:	f7ff fe9c 	bl	8007a40 <HAL_I2C_ListenCpltCallback>
}
 8007d08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      hi2c->XferCount--;
 8007d0a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007d0c:	3a01      	subs	r2, #1
      hi2c->XferCount--;
 8007d0e:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007d10:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007d12:	b29b      	uxth	r3, r3
 8007d14:	8563      	strh	r3, [r4, #42]	; 0x2a
 8007d16:	e7b0      	b.n	8007c7a <I2C_ITSlaveCplt+0x96>
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8007d18:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8007d1a:	4620      	mov	r0, r4
 8007d1c:	f7ff febc 	bl	8007a98 <I2C_ITError>
    if (hi2c->State == HAL_I2C_STATE_LISTEN)
 8007d20:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007d24:	2b28      	cmp	r3, #40	; 0x28
 8007d26:	d1cb      	bne.n	8007cc0 <I2C_ITSlaveCplt+0xdc>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007d28:	463a      	mov	r2, r7
  hi2c->State = HAL_I2C_STATE_READY;
 8007d2a:	2120      	movs	r1, #32
  hi2c->XferISR = NULL;
 8007d2c:	6367      	str	r7, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007d2e:	f6cf 72ff 	movt	r2, #65535	; 0xffff
 8007d32:	6823      	ldr	r3, [r4, #0]
 8007d34:	62e2      	str	r2, [r4, #44]	; 0x2c
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007d36:	076a      	lsls	r2, r5, #29
  hi2c->PreviousState = I2C_STATE_NONE;
 8007d38:	6327      	str	r7, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8007d3a:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007d3e:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007d42:	d512      	bpl.n	8007d6a <I2C_ITSlaveCplt+0x186>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007d44:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8007d46:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007d48:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8007d4a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007d4c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8007d4e:	3301      	adds	r3, #1
 8007d50:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007d52:	b1fa      	cbz	r2, 8007d94 <I2C_ITSlaveCplt+0x1b0>
      hi2c->XferCount--;
 8007d54:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007d56:	3a01      	subs	r2, #1
 8007d58:	6823      	ldr	r3, [r4, #0]
      hi2c->XferCount--;
 8007d5a:	3901      	subs	r1, #1
      hi2c->XferSize--;
 8007d5c:	8522      	strh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007d5e:	b28a      	uxth	r2, r1
 8007d60:	8562      	strh	r2, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007d62:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8007d64:	f042 0204 	orr.w	r2, r2, #4
 8007d68:	6462      	str	r2, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d6a:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007d6e:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007d70:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8007d74:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007d76:	681a      	ldr	r2, [r3, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 8007d78:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007d7a:	f022 02fe 	bic.w	r2, r2, #254	; 0xfe
 8007d7e:	601a      	str	r2, [r3, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007d80:	6823      	ldr	r3, [r4, #0]
 8007d82:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8007d84:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 8007d88:	f7ff fe5a 	bl	8007a40 <HAL_I2C_ListenCpltCallback>
}
 8007d8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    HAL_I2C_SlaveRxCpltCallback(hi2c);
 8007d8e:	f7ff fdc3 	bl	8007918 <HAL_I2C_SlaveRxCpltCallback>
}
 8007d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007d94:	6823      	ldr	r3, [r4, #0]
 8007d96:	e7e8      	b.n	8007d6a <I2C_ITSlaveCplt+0x186>

08007d98 <I2C_Slave_ISR_IT>:
{
 8007d98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hi2c);
 8007d9a:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
 8007d9e:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
 8007da0:	2b01      	cmp	r3, #1
 8007da2:	d07f      	beq.n	8007ea4 <I2C_Slave_ISR_IT+0x10c>
 8007da4:	4616      	mov	r6, r2
 8007da6:	2301      	movs	r3, #1
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007da8:	068a      	lsls	r2, r1, #26
 8007daa:	4604      	mov	r4, r0
 8007dac:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
 8007dae:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007db2:	d501      	bpl.n	8007db8 <I2C_Slave_ISR_IT+0x20>
 8007db4:	06b3      	lsls	r3, r6, #26
 8007db6:	d462      	bmi.n	8007e7e <I2C_Slave_ISR_IT+0xe6>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007db8:	06ea      	lsls	r2, r5, #27
 8007dba:	d51b      	bpl.n	8007df4 <I2C_Slave_ISR_IT+0x5c>
 8007dbc:	06f3      	lsls	r3, r6, #27
 8007dbe:	d519      	bpl.n	8007df4 <I2C_Slave_ISR_IT+0x5c>
    if (hi2c->XferCount == 0U)
 8007dc0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007dc2:	6822      	ldr	r2, [r4, #0]
 8007dc4:	b29b      	uxth	r3, r3
 8007dc6:	2b00      	cmp	r3, #0
 8007dc8:	d15e      	bne.n	8007e88 <I2C_Slave_ISR_IT+0xf0>
      if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 8007dca:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8007dce:	2928      	cmp	r1, #40	; 0x28
 8007dd0:	d102      	bne.n	8007dd8 <I2C_Slave_ISR_IT+0x40>
 8007dd2:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 8007dd6:	d07a      	beq.n	8007ece <I2C_Slave_ISR_IT+0x136>
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8007dd8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007ddc:	2b29      	cmp	r3, #41	; 0x29
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007dde:	f04f 0310 	mov.w	r3, #16
 8007de2:	61d3      	str	r3, [r2, #28]
      else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8007de4:	d102      	bne.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007de6:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8007dea:	d161      	bne.n	8007eb0 <I2C_Slave_ISR_IT+0x118>
  __HAL_UNLOCK(hi2c);
 8007dec:	2000      	movs	r0, #0
 8007dee:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8007df2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 8007df4:	076a      	lsls	r2, r5, #29
 8007df6:	d40e      	bmi.n	8007e16 <I2C_Slave_ISR_IT+0x7e>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 8007df8:	0728      	lsls	r0, r5, #28
 8007dfa:	d52a      	bpl.n	8007e52 <I2C_Slave_ISR_IT+0xba>
 8007dfc:	0731      	lsls	r1, r6, #28
 8007dfe:	d528      	bpl.n	8007e52 <I2C_Slave_ISR_IT+0xba>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8007e00:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007e04:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8007e08:	2b28      	cmp	r3, #40	; 0x28
 8007e0a:	f000 8092 	beq.w	8007f32 <I2C_Slave_ISR_IT+0x19a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 8007e0e:	6823      	ldr	r3, [r4, #0]
 8007e10:	2208      	movs	r2, #8
 8007e12:	61da      	str	r2, [r3, #28]
 8007e14:	e7ea      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 8007e16:	0773      	lsls	r3, r6, #29
 8007e18:	d5ee      	bpl.n	8007df8 <I2C_Slave_ISR_IT+0x60>
    if (hi2c->XferCount > 0U)
 8007e1a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e1c:	b29b      	uxth	r3, r3
 8007e1e:	b16b      	cbz	r3, 8007e3c <I2C_Slave_ISR_IT+0xa4>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007e20:	6822      	ldr	r2, [r4, #0]
 8007e22:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007e24:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007e26:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 8007e28:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8007e2a:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8007e2c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007e2e:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8007e30:	3101      	adds	r1, #1
      hi2c->XferCount--;
 8007e32:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007e34:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
 8007e36:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8007e38:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007e3a:	8522      	strh	r2, [r4, #40]	; 0x28
    if ((hi2c->XferCount == 0U) && \
 8007e3c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e3e:	b29b      	uxth	r3, r3
 8007e40:	2b00      	cmp	r3, #0
 8007e42:	d1d3      	bne.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007e44:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8007e48:	d0d0      	beq.n	8007dec <I2C_Slave_ISR_IT+0x54>
        I2C_ITSlaveSeqCplt(hi2c);
 8007e4a:	4620      	mov	r0, r4
 8007e4c:	f7ff fd66 	bl	800791c <I2C_ITSlaveSeqCplt>
 8007e50:	e7cc      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 8007e52:	07aa      	lsls	r2, r5, #30
 8007e54:	d5ca      	bpl.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007e56:	07b3      	lsls	r3, r6, #30
 8007e58:	d5c8      	bpl.n	8007dec <I2C_Slave_ISR_IT+0x54>
    if (hi2c->XferCount > 0U)
 8007e5a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8007e5c:	b29b      	uxth	r3, r3
 8007e5e:	b31b      	cbz	r3, 8007ea8 <I2C_Slave_ISR_IT+0x110>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8007e60:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8007e62:	6823      	ldr	r3, [r4, #0]
 8007e64:	7812      	ldrb	r2, [r2, #0]
 8007e66:	629a      	str	r2, [r3, #40]	; 0x28
      hi2c->XferCount--;
 8007e68:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->pBuffPtr++;
 8007e6a:	6a61      	ldr	r1, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8007e6c:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007e6e:	3b01      	subs	r3, #1
      hi2c->pBuffPtr++;
 8007e70:	3101      	adds	r1, #1
      hi2c->XferCount--;
 8007e72:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8007e74:	3a01      	subs	r2, #1
      hi2c->pBuffPtr++;
 8007e76:	6261      	str	r1, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8007e78:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007e7a:	8522      	strh	r2, [r4, #40]	; 0x28
 8007e7c:	e7b6      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
    I2C_ITSlaveCplt(hi2c, tmpITFlags);
 8007e7e:	f7ff feb1 	bl	8007be4 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007e82:	06ea      	lsls	r2, r5, #27
 8007e84:	d5b6      	bpl.n	8007df4 <I2C_Slave_ISR_IT+0x5c>
 8007e86:	e799      	b.n	8007dbc <I2C_Slave_ISR_IT+0x24>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007e88:	2310      	movs	r3, #16
 8007e8a:	61d3      	str	r3, [r2, #28]
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007e8c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007e8e:	f043 0304 	orr.w	r3, r3, #4
 8007e92:	6463      	str	r3, [r4, #68]	; 0x44
      if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 8007e94:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
 8007e98:	d1a8      	bne.n	8007dec <I2C_Slave_ISR_IT+0x54>
        I2C_ITError(hi2c, hi2c->ErrorCode);
 8007e9a:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8007e9c:	4620      	mov	r0, r4
 8007e9e:	f7ff fdfb 	bl	8007a98 <I2C_ITError>
 8007ea2:	e7a3      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
  __HAL_LOCK(hi2c);
 8007ea4:	2002      	movs	r0, #2
}
 8007ea6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((tmpoptions == I2C_NEXT_FRAME) || (tmpoptions == I2C_FIRST_FRAME))
 8007ea8:	f037 7380 	bics.w	r3, r7, #16777216	; 0x1000000
 8007eac:	d19e      	bne.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007eae:	e7cc      	b.n	8007e4a <I2C_Slave_ISR_IT+0xb2>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8007eb0:	6823      	ldr	r3, [r4, #0]
 8007eb2:	699a      	ldr	r2, [r3, #24]
 8007eb4:	0790      	lsls	r0, r2, #30
 8007eb6:	d502      	bpl.n	8007ebe <I2C_Slave_ISR_IT+0x126>
    hi2c->Instance->TXDR = 0x00U;
 8007eb8:	2200      	movs	r2, #0
 8007eba:	629a      	str	r2, [r3, #40]	; 0x28
 8007ebc:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8007ebe:	699a      	ldr	r2, [r3, #24]
 8007ec0:	07d1      	lsls	r1, r2, #31
 8007ec2:	d4c2      	bmi.n	8007e4a <I2C_Slave_ISR_IT+0xb2>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8007ec4:	699a      	ldr	r2, [r3, #24]
 8007ec6:	f042 0201 	orr.w	r2, r2, #1
 8007eca:	619a      	str	r2, [r3, #24]
 8007ecc:	e7bd      	b.n	8007e4a <I2C_Slave_ISR_IT+0xb2>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007ece:	2100      	movs	r1, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8007ed0:	2020      	movs	r0, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007ed2:	076d      	lsls	r5, r5, #29
  hi2c->XferISR = NULL;
 8007ed4:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007ed6:	f6cf 71ff 	movt	r1, #65535	; 0xffff
 8007eda:	62e1      	str	r1, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8007edc:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8007ede:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007ee2:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007ee6:	d512      	bpl.n	8007f0e <I2C_Slave_ISR_IT+0x176>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007ee8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007eea:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007eec:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8007eee:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007ef0:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8007ef2:	3301      	adds	r3, #1
 8007ef4:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007ef6:	b301      	cbz	r1, 8007f3a <I2C_Slave_ISR_IT+0x1a2>
      hi2c->XferCount--;
 8007ef8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8007efa:	3901      	subs	r1, #1
 8007efc:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
 8007efe:	3b01      	subs	r3, #1
      hi2c->XferSize--;
 8007f00:	8521      	strh	r1, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8007f02:	b29b      	uxth	r3, r3
 8007f04:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8007f06:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8007f08:	f043 0304 	orr.w	r3, r3, #4
 8007f0c:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007f0e:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007f12:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8007f14:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8007f18:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007f1a:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 8007f1c:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8007f1e:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8007f22:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8007f24:	6823      	ldr	r3, [r4, #0]
 8007f26:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8007f28:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 8007f2c:	f7ff fd88 	bl	8007a40 <HAL_I2C_ListenCpltCallback>
 8007f30:	e75c      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007f32:	4620      	mov	r0, r4
 8007f34:	f7ff fd48 	bl	80079c8 <I2C_ITAddrCplt.isra.9.part.10>
 8007f38:	e758      	b.n	8007dec <I2C_Slave_ISR_IT+0x54>
 8007f3a:	6822      	ldr	r2, [r4, #0]
 8007f3c:	e7e7      	b.n	8007f0e <I2C_Slave_ISR_IT+0x176>
 8007f3e:	bf00      	nop

08007f40 <I2C_Slave_ISR_DMA>:
{
 8007f40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_LOCK(hi2c);
 8007f44:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
  uint32_t tmpoptions = hi2c->XferOptions;
 8007f48:	6ac7      	ldr	r7, [r0, #44]	; 0x2c
  __HAL_LOCK(hi2c);
 8007f4a:	2b01      	cmp	r3, #1
 8007f4c:	f000 80ae 	beq.w	80080ac <I2C_Slave_ISR_DMA+0x16c>
 8007f50:	2301      	movs	r3, #1
 8007f52:	4604      	mov	r4, r0
 8007f54:	460e      	mov	r6, r1
 8007f56:	4615      	mov	r5, r2
 8007f58:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8007f5c:	068b      	lsls	r3, r1, #26
 8007f5e:	d501      	bpl.n	8007f64 <I2C_Slave_ISR_DMA+0x24>
 8007f60:	06aa      	lsls	r2, r5, #26
 8007f62:	d47f      	bmi.n	8008064 <I2C_Slave_ISR_DMA+0x124>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8007f64:	06f3      	lsls	r3, r6, #27
 8007f66:	d56f      	bpl.n	8008048 <I2C_Slave_ISR_DMA+0x108>
 8007f68:	06e8      	lsls	r0, r5, #27
 8007f6a:	d56d      	bpl.n	8008048 <I2C_Slave_ISR_DMA+0x108>
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
 8007f6c:	0bab      	lsrs	r3, r5, #14
 8007f6e:	6822      	ldr	r2, [r4, #0]
        (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET))
 8007f70:	0bed      	lsrs	r5, r5, #15
    if ((I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET) ||
 8007f72:	f003 0001 	and.w	r0, r3, #1
 8007f76:	432b      	orrs	r3, r5
 8007f78:	07d9      	lsls	r1, r3, #31
 8007f7a:	d578      	bpl.n	800806e <I2C_Slave_ISR_DMA+0x12e>
 8007f7c:	e9d4 1c0e 	ldrd	r1, ip, [r4, #56]	; 0x38
      if (hi2c->hdmarx != NULL)
 8007f80:	f1bc 0f00 	cmp.w	ip, #0
 8007f84:	d00e      	beq.n	8007fa4 <I2C_Slave_ISR_DMA+0x64>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_RXDMAEN) != RESET)
 8007f86:	07eb      	lsls	r3, r5, #31
 8007f88:	d50c      	bpl.n	8007fa4 <I2C_Slave_ISR_DMA+0x64>
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
 8007f8a:	f8dc 5000 	ldr.w	r5, [ip]
 8007f8e:	f44f 6e91 	mov.w	lr, #1160	; 0x488
 8007f92:	686b      	ldr	r3, [r5, #4]
 8007f94:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8007f98:	fab3 f383 	clz	r3, r3
 8007f9c:	095b      	lsrs	r3, r3, #5
 8007f9e:	2b00      	cmp	r3, #0
 8007fa0:	f040 80a1 	bne.w	80080e6 <I2C_Slave_ISR_DMA+0x1a6>
      if (hi2c->hdmatx != NULL)
 8007fa4:	2900      	cmp	r1, #0
 8007fa6:	f000 8086 	beq.w	80080b6 <I2C_Slave_ISR_DMA+0x176>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
 8007faa:	2800      	cmp	r0, #0
 8007fac:	f000 8083 	beq.w	80080b6 <I2C_Slave_ISR_DMA+0x176>
 8007fb0:	2000      	movs	r0, #0
          if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
 8007fb2:	6809      	ldr	r1, [r1, #0]
 8007fb4:	f44f 6e8e 	mov.w	lr, #1136	; 0x470
 8007fb8:	684b      	ldr	r3, [r1, #4]
 8007fba:	f2c4 0e02 	movt	lr, #16386	; 0x4002
 8007fbe:	fab3 f383 	clz	r3, r3
 8007fc2:	095b      	lsrs	r3, r3, #5
 8007fc4:	2b00      	cmp	r3, #0
 8007fc6:	d074      	beq.n	80080b2 <I2C_Slave_ISR_DMA+0x172>
        if ((hi2c->State == HAL_I2C_STATE_LISTEN) && (tmpoptions == I2C_FIRST_AND_LAST_FRAME)) /* Same action must be done for (tmpoptions == I2C_LAST_FRAME) which removed for Warning[Pa134]: left and right operands are identical */
 8007fc8:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8007fcc:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 8007fd0:	b2db      	uxtb	r3, r3
 8007fd2:	d14f      	bne.n	8008074 <I2C_Slave_ISR_DMA+0x134>
 8007fd4:	2b28      	cmp	r3, #40	; 0x28
 8007fd6:	d14d      	bne.n	8008074 <I2C_Slave_ISR_DMA+0x134>
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007fd8:	2100      	movs	r1, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8007fda:	2020      	movs	r0, #32
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007fdc:	0775      	lsls	r5, r6, #29
  hi2c->PreviousState = I2C_STATE_NONE;
 8007fde:	460b      	mov	r3, r1
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007fe0:	f6cf 71ff 	movt	r1, #65535	; 0xffff
  hi2c->XferISR = NULL;
 8007fe4:	6363      	str	r3, [r4, #52]	; 0x34
  hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8007fe6:	62e1      	str	r1, [r4, #44]	; 0x2c
  hi2c->PreviousState = I2C_STATE_NONE;
 8007fe8:	6323      	str	r3, [r4, #48]	; 0x30
  hi2c->State = HAL_I2C_STATE_READY;
 8007fea:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8007fee:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  if (I2C_CHECK_FLAG(ITFlags, I2C_FLAG_RXNE) != RESET)
 8007ff2:	d513      	bpl.n	800801c <I2C_Slave_ISR_DMA+0xdc>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8007ff4:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8007ff6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8007ff8:	701a      	strb	r2, [r3, #0]
    hi2c->pBuffPtr++;
 8007ffa:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8007ffc:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    hi2c->pBuffPtr++;
 8007ffe:	3301      	adds	r3, #1
 8008000:	6263      	str	r3, [r4, #36]	; 0x24
    if ((hi2c->XferSize > 0U))
 8008002:	2a00      	cmp	r2, #0
 8008004:	d07b      	beq.n	80080fe <I2C_Slave_ISR_DMA+0x1be>
      hi2c->XferCount--;
 8008006:	8d61      	ldrh	r1, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8008008:	1e53      	subs	r3, r2, #1
 800800a:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount--;
 800800c:	3901      	subs	r1, #1
      hi2c->XferSize--;
 800800e:	8523      	strh	r3, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8008010:	b28b      	uxth	r3, r1
 8008012:	8563      	strh	r3, [r4, #42]	; 0x2a
      hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8008014:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8008016:	f043 0304 	orr.w	r3, r3, #4
 800801a:	6463      	str	r3, [r4, #68]	; 0x44
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800801c:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008020:	2510      	movs	r5, #16
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008022:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hi2c);
 8008026:	2100      	movs	r1, #0
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008028:	6813      	ldr	r3, [r2, #0]
  HAL_I2C_ListenCpltCallback(hi2c);
 800802a:	4620      	mov	r0, r4
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800802c:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8008030:	6013      	str	r3, [r2, #0]
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008032:	6823      	ldr	r3, [r4, #0]
 8008034:	61dd      	str	r5, [r3, #28]
  __HAL_UNLOCK(hi2c);
 8008036:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  HAL_I2C_ListenCpltCallback(hi2c);
 800803a:	f7ff fd01 	bl	8007a40 <HAL_I2C_ListenCpltCallback>
  __HAL_UNLOCK(hi2c);
 800803e:	2000      	movs	r0, #0
 8008040:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8008044:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_ADDR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_ADDRI) != RESET))
 8008048:	0732      	lsls	r2, r6, #28
 800804a:	d5f8      	bpl.n	800803e <I2C_Slave_ISR_DMA+0xfe>
 800804c:	072b      	lsls	r3, r5, #28
 800804e:	d5f6      	bpl.n	800803e <I2C_Slave_ISR_DMA+0xfe>
  if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) == (uint32_t)HAL_I2C_STATE_LISTEN)
 8008050:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008054:	f003 0328 	and.w	r3, r3, #40	; 0x28
 8008058:	2b28      	cmp	r3, #40	; 0x28
 800805a:	d04c      	beq.n	80080f6 <I2C_Slave_ISR_DMA+0x1b6>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ADDR);
 800805c:	6823      	ldr	r3, [r4, #0]
 800805e:	2208      	movs	r2, #8
 8008060:	61da      	str	r2, [r3, #28]
 8008062:	e7ec      	b.n	800803e <I2C_Slave_ISR_DMA+0xfe>
    I2C_ITSlaveCplt(hi2c, ITFlags);
 8008064:	f7ff fdbe 	bl	8007be4 <I2C_ITSlaveCplt>
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8008068:	06f3      	lsls	r3, r6, #27
 800806a:	d5ed      	bpl.n	8008048 <I2C_Slave_ISR_DMA+0x108>
 800806c:	e77c      	b.n	8007f68 <I2C_Slave_ISR_DMA+0x28>
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800806e:	2310      	movs	r3, #16
 8008070:	61d3      	str	r3, [r2, #28]
 8008072:	e7e4      	b.n	800803e <I2C_Slave_ISR_DMA+0xfe>
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8008074:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008078:	2b29      	cmp	r3, #41	; 0x29
          __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800807a:	f04f 0310 	mov.w	r3, #16
 800807e:	61d3      	str	r3, [r2, #28]
        else if ((hi2c->State == HAL_I2C_STATE_BUSY_TX_LISTEN) && (tmpoptions != I2C_NO_OPTION_FRAME))
 8008080:	d1dd      	bne.n	800803e <I2C_Slave_ISR_DMA+0xfe>
 8008082:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
 8008086:	d0da      	beq.n	800803e <I2C_Slave_ISR_DMA+0xfe>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8008088:	6823      	ldr	r3, [r4, #0]
 800808a:	699a      	ldr	r2, [r3, #24]
 800808c:	0790      	lsls	r0, r2, #30
 800808e:	d502      	bpl.n	8008096 <I2C_Slave_ISR_DMA+0x156>
    hi2c->Instance->TXDR = 0x00U;
 8008090:	2200      	movs	r2, #0
 8008092:	629a      	str	r2, [r3, #40]	; 0x28
 8008094:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008096:	699a      	ldr	r2, [r3, #24]
 8008098:	07d1      	lsls	r1, r2, #31
 800809a:	d403      	bmi.n	80080a4 <I2C_Slave_ISR_DMA+0x164>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 800809c:	699a      	ldr	r2, [r3, #24]
 800809e:	f042 0201 	orr.w	r2, r2, #1
 80080a2:	619a      	str	r2, [r3, #24]
          I2C_ITSlaveSeqCplt(hi2c);
 80080a4:	4620      	mov	r0, r4
 80080a6:	f7ff fc39 	bl	800791c <I2C_ITSlaveSeqCplt>
 80080aa:	e7c8      	b.n	800803e <I2C_Slave_ISR_DMA+0xfe>
  __HAL_LOCK(hi2c);
 80080ac:	2002      	movs	r0, #2
}
 80080ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (treatdmanack == 1U)
 80080b2:	2800      	cmp	r0, #0
 80080b4:	d188      	bne.n	8007fc8 <I2C_Slave_ISR_DMA+0x88>
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80080b6:	2310      	movs	r3, #16
 80080b8:	61d3      	str	r3, [r2, #28]
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 80080ba:	f037 7280 	bics.w	r2, r7, #16777216	; 0x1000000
        hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80080be:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80080c0:	f043 0304 	orr.w	r3, r3, #4
 80080c4:	6463      	str	r3, [r4, #68]	; 0x44
        tmpstate = hi2c->State;
 80080c6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80080ca:	b2db      	uxtb	r3, r3
        if ((tmpoptions == I2C_FIRST_FRAME) || (tmpoptions == I2C_NEXT_FRAME))
 80080cc:	d1b7      	bne.n	800803e <I2C_Slave_ISR_DMA+0xfe>
          if ((tmpstate == HAL_I2C_STATE_BUSY_TX) || (tmpstate == HAL_I2C_STATE_BUSY_TX_LISTEN))
 80080ce:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
 80080d2:	2b21      	cmp	r3, #33	; 0x21
 80080d4:	d001      	beq.n	80080da <I2C_Slave_ISR_DMA+0x19a>
          else if ((tmpstate == HAL_I2C_STATE_BUSY_RX) || (tmpstate == HAL_I2C_STATE_BUSY_RX_LISTEN))
 80080d6:	2b22      	cmp	r3, #34	; 0x22
 80080d8:	d100      	bne.n	80080dc <I2C_Slave_ISR_DMA+0x19c>
            hi2c->PreviousState = I2C_STATE_SLAVE_BUSY_RX;
 80080da:	6323      	str	r3, [r4, #48]	; 0x30
          I2C_ITError(hi2c, hi2c->ErrorCode);
 80080dc:	6c61      	ldr	r1, [r4, #68]	; 0x44
 80080de:	4620      	mov	r0, r4
 80080e0:	f7ff fcda 	bl	8007a98 <I2C_ITError>
 80080e4:	e7ab      	b.n	800803e <I2C_Slave_ISR_DMA+0xfe>
      if (hi2c->hdmatx != NULL)
 80080e6:	2900      	cmp	r1, #0
 80080e8:	f43f af6e 	beq.w	8007fc8 <I2C_Slave_ISR_DMA+0x88>
        if (I2C_CHECK_IT_SOURCE(ITSources, I2C_CR1_TXDMAEN) != RESET)
 80080ec:	2800      	cmp	r0, #0
 80080ee:	f43f af6b 	beq.w	8007fc8 <I2C_Slave_ISR_DMA+0x88>
            treatdmanack = 1U;
 80080f2:	2001      	movs	r0, #1
 80080f4:	e75d      	b.n	8007fb2 <I2C_Slave_ISR_DMA+0x72>
 80080f6:	4620      	mov	r0, r4
 80080f8:	f7ff fc66 	bl	80079c8 <I2C_ITAddrCplt.isra.9.part.10>
 80080fc:	e79f      	b.n	800803e <I2C_Slave_ISR_DMA+0xfe>
 80080fe:	6822      	ldr	r2, [r4, #0]
 8008100:	e78c      	b.n	800801c <I2C_Slave_ISR_DMA+0xdc>
 8008102:	bf00      	nop

08008104 <I2C_DMAMasterTransmitCplt>:
{
 8008104:	b510      	push	{r4, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8008106:	6b84      	ldr	r4, [r0, #56]	; 0x38
  hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8008108:	6822      	ldr	r2, [r4, #0]
 800810a:	6813      	ldr	r3, [r2, #0]
 800810c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8008110:	6013      	str	r3, [r2, #0]
  if (hi2c->XferCount == 0U)
 8008112:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008114:	b29b      	uxth	r3, r3
 8008116:	b993      	cbnz	r3, 800813e <I2C_DMAMasterTransmitCplt+0x3a>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008118:	f647 7341 	movw	r3, #32577	; 0x7f41
 800811c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800811e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008122:	429a      	cmp	r2, r3
 8008124:	d034      	beq.n	8008190 <I2C_DMAMasterTransmitCplt+0x8c>
 8008126:	f248 7331 	movw	r3, #34609	; 0x8731
 800812a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800812e:	429a      	cmp	r2, r3
 8008130:	d02e      	beq.n	8008190 <I2C_DMAMasterTransmitCplt+0x8c>
      tmpisr |= I2C_IT_STOPI;
 8008132:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8008134:	6822      	ldr	r2, [r4, #0]
 8008136:	6813      	ldr	r3, [r2, #0]
 8008138:	430b      	orrs	r3, r1
 800813a:	6013      	str	r3, [r2, #0]
}
 800813c:	bd10      	pop	{r4, pc}
    hi2c->pBuffPtr += hi2c->XferSize;
 800813e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8008140:	8d22      	ldrh	r2, [r4, #40]	; 0x28
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8008142:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr += hi2c->XferSize;
 8008144:	4411      	add	r1, r2
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8008146:	2bff      	cmp	r3, #255	; 0xff
    hi2c->pBuffPtr += hi2c->XferSize;
 8008148:	6261      	str	r1, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800814a:	d81e      	bhi.n	800818a <I2C_DMAMasterTransmitCplt+0x86>
      hi2c->XferSize = hi2c->XferCount;
 800814c:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
 800814e:	b280      	uxth	r0, r0
 8008150:	4603      	mov	r3, r0
    if (HAL_DMA_Start_IT(hi2c->hdmatx, (uint32_t)hi2c->pBuffPtr, (uint32_t)&hi2c->Instance->TXDR, hi2c->XferSize) != HAL_OK)
 8008152:	6822      	ldr	r2, [r4, #0]
 8008154:	8520      	strh	r0, [r4, #40]	; 0x28
 8008156:	3228      	adds	r2, #40	; 0x28
 8008158:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800815a:	f7fb fc5f 	bl	8003a1c <HAL_DMA_Start_IT>
 800815e:	b9f8      	cbnz	r0, 80081a0 <I2C_DMAMasterTransmitCplt+0x9c>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008160:	f248 7231 	movw	r2, #34609	; 0x8731
 8008164:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8008166:	f6c0 0200 	movt	r2, #2048	; 0x800
 800816a:	4293      	cmp	r3, r2
 800816c:	d012      	beq.n	8008194 <I2C_DMAMasterTransmitCplt+0x90>
 800816e:	f647 7241 	movw	r2, #32577	; 0x7f41
 8008172:	f6c0 0200 	movt	r2, #2048	; 0x800
 8008176:	1a9b      	subs	r3, r3, r2
 8008178:	fab3 f383 	clz	r3, r3
 800817c:	095b      	lsrs	r3, r3, #5
 800817e:	b94b      	cbnz	r3, 8008194 <I2C_DMAMasterTransmitCplt+0x90>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8008180:	6821      	ldr	r1, [r4, #0]
 8008182:	680a      	ldr	r2, [r1, #0]
 8008184:	4313      	orrs	r3, r2
 8008186:	600b      	str	r3, [r1, #0]
}
 8008188:	bd10      	pop	{r4, pc}
 800818a:	23ff      	movs	r3, #255	; 0xff
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800818c:	4618      	mov	r0, r3
 800818e:	e7e0      	b.n	8008152 <I2C_DMAMasterTransmitCplt+0x4e>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008190:	2160      	movs	r1, #96	; 0x60
 8008192:	e7cf      	b.n	8008134 <I2C_DMAMasterTransmitCplt+0x30>
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8008194:	6821      	ldr	r1, [r4, #0]
      tmpisr |= I2C_IT_TCI;
 8008196:	2340      	movs	r3, #64	; 0x40
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 8008198:	680a      	ldr	r2, [r1, #0]
 800819a:	4313      	orrs	r3, r2
 800819c:	600b      	str	r3, [r1, #0]
 800819e:	e7f3      	b.n	8008188 <I2C_DMAMasterTransmitCplt+0x84>
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
 80081a0:	4620      	mov	r0, r4
 80081a2:	2110      	movs	r1, #16
}
 80081a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      I2C_ITError(hi2c, HAL_I2C_ERROR_DMA);
 80081a8:	f7ff bc76 	b.w	8007a98 <I2C_ITError>

080081ac <I2C_ITMasterCplt>:
{
 80081ac:	b570      	push	{r4, r5, r6, lr}
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80081ae:	2220      	movs	r2, #32
 80081b0:	6803      	ldr	r3, [r0, #0]
{
 80081b2:	4604      	mov	r4, r0
  __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80081b4:	61da      	str	r2, [r3, #28]
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80081b6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80081ba:	2b21      	cmp	r3, #33	; 0x21
 80081bc:	f000 80b3 	beq.w	8008326 <I2C_ITMasterCplt+0x17a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 80081c0:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80081c4:	2b22      	cmp	r3, #34	; 0x22
 80081c6:	f000 8098 	beq.w	80082fa <I2C_ITMasterCplt+0x14e>
  I2C_RESET_CR2(hi2c);
 80081ca:	6820      	ldr	r0, [r4, #0]
 80081cc:	f44f 4568 	mov.w	r5, #59392	; 0xe800
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80081d0:	2200      	movs	r2, #0
  I2C_RESET_CR2(hi2c);
 80081d2:	6843      	ldr	r3, [r0, #4]
 80081d4:	f6cf 6500 	movt	r5, #65024	; 0xfe00
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80081d8:	f6cf 72ff 	movt	r2, #65535	; 0xffff
  I2C_RESET_CR2(hi2c);
 80081dc:	402b      	ands	r3, r5
  hi2c->XferISR       = NULL;
 80081de:	2500      	movs	r5, #0
  I2C_RESET_CR2(hi2c);
 80081e0:	6043      	str	r3, [r0, #4]
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
 80081e2:	06cb      	lsls	r3, r1, #27
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 80081e4:	62e2      	str	r2, [r4, #44]	; 0x2c
  hi2c->XferISR       = NULL;
 80081e6:	6365      	str	r5, [r4, #52]	; 0x34
  if (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET)
 80081e8:	d506      	bpl.n	80081f8 <I2C_ITMasterCplt+0x4c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80081ea:	6823      	ldr	r3, [r4, #0]
 80081ec:	2210      	movs	r2, #16
 80081ee:	61da      	str	r2, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 80081f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80081f2:	f043 0304 	orr.w	r3, r3, #4
 80081f6:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
 80081f8:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80081fc:	6823      	ldr	r3, [r4, #0]
 80081fe:	2a60      	cmp	r2, #96	; 0x60
 8008200:	f000 808c 	beq.w	800831c <I2C_ITMasterCplt+0x170>
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8008204:	699a      	ldr	r2, [r3, #24]
 8008206:	0795      	lsls	r5, r2, #30
 8008208:	d502      	bpl.n	8008210 <I2C_ITMasterCplt+0x64>
    hi2c->Instance->TXDR = 0x00U;
 800820a:	2200      	movs	r2, #0
 800820c:	629a      	str	r2, [r3, #40]	; 0x28
 800820e:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008210:	699a      	ldr	r2, [r3, #24]
 8008212:	07d0      	lsls	r0, r2, #31
 8008214:	d403      	bmi.n	800821e <I2C_ITMasterCplt+0x72>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8008216:	699a      	ldr	r2, [r3, #24]
 8008218:	f042 0201 	orr.w	r2, r2, #1
 800821c:	619a      	str	r2, [r3, #24]
  tmperror = hi2c->ErrorCode;
 800821e:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if ((hi2c->State == HAL_I2C_STATE_ABORT) || (tmperror != HAL_I2C_ERROR_NONE))
 8008220:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8008224:	2a60      	cmp	r2, #96	; 0x60
 8008226:	d00e      	beq.n	8008246 <I2C_ITMasterCplt+0x9a>
 8008228:	3300      	adds	r3, #0
 800822a:	bf18      	it	ne
 800822c:	2301      	movne	r3, #1
 800822e:	b953      	cbnz	r3, 8008246 <I2C_ITMasterCplt+0x9a>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8008230:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8008234:	2a21      	cmp	r2, #33	; 0x21
 8008236:	f000 80da 	beq.w	80083ee <I2C_ITMasterCplt+0x242>
  else if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 800823a:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800823e:	2a22      	cmp	r2, #34	; 0x22
 8008240:	f000 8082 	beq.w	8008348 <I2C_ITMasterCplt+0x19c>
}
 8008244:	bd70      	pop	{r4, r5, r6, pc}
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008246:	2000      	movs	r0, #0
    I2C_ITError(hi2c, hi2c->ErrorCode);
 8008248:	6c62      	ldr	r2, [r4, #68]	; 0x44
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 800824a:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 800824e:	4601      	mov	r1, r0
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008250:	f6cf 70ff 	movt	r0, #65535	; 0xffff
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008254:	3b28      	subs	r3, #40	; 0x28
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008256:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 800825a:	62e0      	str	r0, [r4, #44]	; 0x2c
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 800825c:	2b02      	cmp	r3, #2
  hi2c->XferCount     = 0U;
 800825e:	8561      	strh	r1, [r4, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8008260:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8008262:	6821      	ldr	r1, [r4, #0]
 8008264:	ea42 0200 	orr.w	r2, r2, r0
 8008268:	6462      	str	r2, [r4, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 800826a:	d834      	bhi.n	80082d6 <I2C_ITMasterCplt+0x12a>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800826c:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8008270:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008272:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008276:	f647 5399 	movw	r3, #32153	; 0x7d99
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800827a:	4032      	ands	r2, r6
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800827c:	4035      	ands	r5, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 800827e:	f6c0 0300 	movt	r3, #2048	; 0x800
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008282:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008284:	680a      	ldr	r2, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008286:	bf14      	ite	ne
 8008288:	f06f 00f6 	mvnne.w	r0, #246	; 0xf6
 800828c:	f06f 0046 	mvneq.w	r0, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008290:	42b5      	cmp	r5, r6
 8008292:	bf18      	it	ne
 8008294:	f06f 00f6 	mvnne.w	r0, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008298:	4002      	ands	r2, r0
 800829a:	600a      	str	r2, [r1, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 800829c:	6363      	str	r3, [r4, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 800829e:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 80082a2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 80082a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 80082a6:	b118      	cbz	r0, 80082b0 <I2C_ITMasterCplt+0x104>
 80082a8:	2b11      	cmp	r3, #17
 80082aa:	d05d      	beq.n	8008368 <I2C_ITMasterCplt+0x1bc>
 80082ac:	2b21      	cmp	r3, #33	; 0x21
 80082ae:	d05b      	beq.n	8008368 <I2C_ITMasterCplt+0x1bc>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 80082b0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80082b2:	b118      	cbz	r0, 80082bc <I2C_ITMasterCplt+0x110>
 80082b4:	2b12      	cmp	r3, #18
 80082b6:	d078      	beq.n	80083aa <I2C_ITMasterCplt+0x1fe>
 80082b8:	2b22      	cmp	r3, #34	; 0x22
 80082ba:	d076      	beq.n	80083aa <I2C_ITMasterCplt+0x1fe>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 80082bc:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80082c0:	2b60      	cmp	r3, #96	; 0x60
 80082c2:	f000 80a4 	beq.w	800840e <I2C_ITMasterCplt+0x262>
    hi2c->PreviousState = I2C_STATE_NONE;
 80082c6:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 80082c8:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 80082ca:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 80082cc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 80082d0:	f7ff fbbc 	bl	8007a4c <HAL_I2C_ErrorCallback>
}
 80082d4:	bd70      	pop	{r4, r5, r6, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80082d6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80082da:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80082de:	680b      	ldr	r3, [r1, #0]
 80082e0:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 80082e4:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 80082e6:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 80082ea:	2b60      	cmp	r3, #96	; 0x60
 80082ec:	d002      	beq.n	80082f4 <I2C_ITMasterCplt+0x148>
      hi2c->State         = HAL_I2C_STATE_READY;
 80082ee:	2320      	movs	r3, #32
 80082f0:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80082f4:	2300      	movs	r3, #0
 80082f6:	6363      	str	r3, [r4, #52]	; 0x34
 80082f8:	e7d3      	b.n	80082a2 <I2C_ITMasterCplt+0xf6>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80082fa:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80082fe:	2512      	movs	r5, #18
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008300:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008302:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008306:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008308:	2a28      	cmp	r2, #40	; 0x28
 800830a:	bf14      	ite	ne
 800830c:	f06f 02f4 	mvnne.w	r2, #244	; 0xf4
 8008310:	f06f 0244 	mvneq.w	r2, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008314:	4013      	ands	r3, r2
 8008316:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8008318:	6325      	str	r5, [r4, #48]	; 0x30
 800831a:	e756      	b.n	80081ca <I2C_ITMasterCplt+0x1e>
  if ((hi2c->State == HAL_I2C_STATE_ABORT) && (I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET))
 800831c:	074e      	lsls	r6, r1, #29
 800831e:	f57f af71 	bpl.w	8008204 <I2C_ITMasterCplt+0x58>
    tmp = (uint8_t)hi2c->Instance->RXDR;
 8008322:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008324:	e76e      	b.n	8008204 <I2C_ITMasterCplt+0x58>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008326:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800832a:	2511      	movs	r5, #17
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800832c:	6800      	ldr	r0, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800832e:	f002 0228 	and.w	r2, r2, #40	; 0x28
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008332:	6803      	ldr	r3, [r0, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008334:	2a28      	cmp	r2, #40	; 0x28
 8008336:	bf14      	ite	ne
 8008338:	f06f 02f2 	mvnne.w	r2, #242	; 0xf2
 800833c:	f06f 0242 	mvneq.w	r2, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008340:	4013      	ands	r3, r2
 8008342:	6003      	str	r3, [r0, #0]
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8008344:	6325      	str	r5, [r4, #48]	; 0x30
 8008346:	e740      	b.n	80081ca <I2C_ITMasterCplt+0x1e>
    hi2c->State = HAL_I2C_STATE_READY;
 8008348:	2220      	movs	r2, #32
      HAL_I2C_MemRxCpltCallback(hi2c);
 800834a:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
 800834c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 8008350:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 8008354:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8008356:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
 800835a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 800835e:	2a40      	cmp	r2, #64	; 0x40
 8008360:	d063      	beq.n	800842a <I2C_ITMasterCplt+0x27e>
      HAL_I2C_MasterRxCpltCallback(hi2c);
 8008362:	f7ff fad5 	bl	8007910 <HAL_I2C_MasterRxCpltCallback>
}
 8008366:	bd70      	pop	{r4, r5, r6, pc}
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8008368:	6823      	ldr	r3, [r4, #0]
 800836a:	681a      	ldr	r2, [r3, #0]
 800836c:	0451      	lsls	r1, r2, #17
 800836e:	d504      	bpl.n	800837a <I2C_ITMasterCplt+0x1ce>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8008370:	681a      	ldr	r2, [r3, #0]
 8008372:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8008376:	601a      	str	r2, [r3, #0]
 8008378:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 800837a:	f7fd f85d 	bl	8005438 <HAL_DMA_GetState>
 800837e:	2801      	cmp	r0, #1
 8008380:	d09c      	beq.n	80082bc <I2C_ITMasterCplt+0x110>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8008382:	f647 2355 	movw	r3, #31317	; 0x7a55
 8008386:	6ba1      	ldr	r1, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8008388:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 800838a:	f6c0 0300 	movt	r3, #2048	; 0x800
 800838e:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8008390:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8008394:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8008396:	f7fc f9b5 	bl	8004704 <HAL_DMA_Abort_IT>
 800839a:	2800      	cmp	r0, #0
 800839c:	f43f af52 	beq.w	8008244 <I2C_ITMasterCplt+0x98>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80083a0:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 80083a2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 80083a6:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80083a8:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 80083aa:	6823      	ldr	r3, [r4, #0]
 80083ac:	681a      	ldr	r2, [r3, #0]
 80083ae:	0412      	lsls	r2, r2, #16
 80083b0:	d504      	bpl.n	80083bc <I2C_ITMasterCplt+0x210>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 80083b2:	681a      	ldr	r2, [r3, #0]
 80083b4:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80083b8:	601a      	str	r2, [r3, #0]
 80083ba:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 80083bc:	f7fd f83c 	bl	8005438 <HAL_DMA_GetState>
 80083c0:	2801      	cmp	r0, #1
 80083c2:	f43f af7b 	beq.w	80082bc <I2C_ITMasterCplt+0x110>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80083c6:	f647 2355 	movw	r3, #31317	; 0x7a55
 80083ca:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 80083cc:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 80083ce:	f6c0 0300 	movt	r3, #2048	; 0x800
 80083d2:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 80083d4:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 80083d8:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80083da:	f7fc f993 	bl	8004704 <HAL_DMA_Abort_IT>
 80083de:	2800      	cmp	r0, #0
 80083e0:	f43f af30 	beq.w	8008244 <I2C_ITMasterCplt+0x98>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80083e4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 80083e6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 80083ea:	6d03      	ldr	r3, [r0, #80]	; 0x50
 80083ec:	4718      	bx	r3
    hi2c->State = HAL_I2C_STATE_READY;
 80083ee:	2220      	movs	r2, #32
      HAL_I2C_MemTxCpltCallback(hi2c);
 80083f0:	4620      	mov	r0, r4
      __HAL_UNLOCK(hi2c);
 80083f2:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_READY;
 80083f6:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    hi2c->PreviousState = I2C_STATE_NONE;
 80083fa:	6323      	str	r3, [r4, #48]	; 0x30
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 80083fc:	f894 2042 	ldrb.w	r2, [r4, #66]	; 0x42
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8008400:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    if (hi2c->Mode == HAL_I2C_MODE_MEM)
 8008404:	2a40      	cmp	r2, #64	; 0x40
 8008406:	d00d      	beq.n	8008424 <I2C_ITMasterCplt+0x278>
      HAL_I2C_MasterTxCpltCallback(hi2c);
 8008408:	f7ff fa80 	bl	800790c <HAL_I2C_MasterTxCpltCallback>
}
 800840c:	bd70      	pop	{r4, r5, r6, pc}
    hi2c->PreviousState = I2C_STATE_NONE;
 800840e:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8008410:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8008412:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8008414:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8008418:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 800841c:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 800841e:	f7ff fb17 	bl	8007a50 <HAL_I2C_AbortCpltCallback>
}
 8008422:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemTxCpltCallback(hi2c);
 8008424:	f7ff fb0e 	bl	8007a44 <HAL_I2C_MemTxCpltCallback>
}
 8008428:	bd70      	pop	{r4, r5, r6, pc}
      HAL_I2C_MemRxCpltCallback(hi2c);
 800842a:	f7ff fb0d 	bl	8007a48 <HAL_I2C_MemRxCpltCallback>
}
 800842e:	bd70      	pop	{r4, r5, r6, pc}

08008430 <I2C_Master_ISR_IT>:
  __HAL_LOCK(hi2c);
 8008430:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8008434:	2b01      	cmp	r3, #1
 8008436:	f000 80e8 	beq.w	800860a <I2C_Master_ISR_IT+0x1da>
 800843a:	2301      	movs	r3, #1
{
 800843c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8008440:	06cf      	lsls	r7, r1, #27
{
 8008442:	b082      	sub	sp, #8
 8008444:	4604      	mov	r4, r0
 8008446:	460d      	mov	r5, r1
  __HAL_LOCK(hi2c);
 8008448:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 800844c:	d51e      	bpl.n	800848c <I2C_Master_ISR_IT+0x5c>
 800844e:	06d6      	lsls	r6, r2, #27
 8008450:	d51c      	bpl.n	800848c <I2C_Master_ISR_IT+0x5c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008452:	6803      	ldr	r3, [r0, #0]
 8008454:	2110      	movs	r1, #16
 8008456:	61d9      	str	r1, [r3, #28]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8008458:	6c41      	ldr	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 800845a:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800845c:	f041 0104 	orr.w	r1, r1, #4
 8008460:	6441      	str	r1, [r0, #68]	; 0x44
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8008462:	6999      	ldr	r1, [r3, #24]
 8008464:	0788      	lsls	r0, r1, #30
 8008466:	d502      	bpl.n	800846e <I2C_Master_ISR_IT+0x3e>
    hi2c->Instance->TXDR = 0x00U;
 8008468:	2100      	movs	r1, #0
 800846a:	6299      	str	r1, [r3, #40]	; 0x28
 800846c:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800846e:	6999      	ldr	r1, [r3, #24]
 8008470:	07c9      	lsls	r1, r1, #31
 8008472:	f140 8097 	bpl.w	80085a4 <I2C_Master_ISR_IT+0x174>
  if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8008476:	06a9      	lsls	r1, r5, #26
 8008478:	d502      	bpl.n	8008480 <I2C_Master_ISR_IT+0x50>
 800847a:	0693      	lsls	r3, r2, #26
 800847c:	f100 80c7 	bmi.w	800860e <I2C_Master_ISR_IT+0x1de>
  __HAL_UNLOCK(hi2c);
 8008480:	2000      	movs	r0, #0
 8008482:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 8008486:	b002      	add	sp, #8
 8008488:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 800848c:	076f      	lsls	r7, r5, #29
 800848e:	d408      	bmi.n	80084a2 <I2C_Master_ISR_IT+0x72>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TXIS) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TXI) != RESET))
 8008490:	07a8      	lsls	r0, r5, #30
 8008492:	d519      	bpl.n	80084c8 <I2C_Master_ISR_IT+0x98>
 8008494:	0791      	lsls	r1, r2, #30
 8008496:	d517      	bpl.n	80084c8 <I2C_Master_ISR_IT+0x98>
    hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8008498:	6a61      	ldr	r1, [r4, #36]	; 0x24
 800849a:	6823      	ldr	r3, [r4, #0]
 800849c:	7809      	ldrb	r1, [r1, #0]
 800849e:	6299      	str	r1, [r3, #40]	; 0x28
 80084a0:	e007      	b.n	80084b2 <I2C_Master_ISR_IT+0x82>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_RXNE) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_RXI) != RESET))
 80084a2:	0756      	lsls	r6, r2, #29
 80084a4:	d5f4      	bpl.n	8008490 <I2C_Master_ISR_IT+0x60>
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80084a6:	6821      	ldr	r1, [r4, #0]
    tmpITFlags &= ~I2C_FLAG_RXNE;
 80084a8:	f025 0504 	bic.w	r5, r5, #4
    *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 80084ac:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80084ae:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80084b0:	7019      	strb	r1, [r3, #0]
    hi2c->XferCount--;
 80084b2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr++;
 80084b4:	6a60      	ldr	r0, [r4, #36]	; 0x24
    hi2c->XferSize--;
 80084b6:	8d21      	ldrh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
 80084b8:	3b01      	subs	r3, #1
    hi2c->pBuffPtr++;
 80084ba:	3001      	adds	r0, #1
    hi2c->XferCount--;
 80084bc:	b29b      	uxth	r3, r3
    hi2c->XferSize--;
 80084be:	3901      	subs	r1, #1
    hi2c->pBuffPtr++;
 80084c0:	6260      	str	r0, [r4, #36]	; 0x24
    hi2c->XferCount--;
 80084c2:	8563      	strh	r3, [r4, #42]	; 0x2a
    hi2c->XferSize--;
 80084c4:	8521      	strh	r1, [r4, #40]	; 0x28
    hi2c->XferCount--;
 80084c6:	e7d6      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80084c8:	062b      	lsls	r3, r5, #24
 80084ca:	d417      	bmi.n	80084fc <I2C_Master_ISR_IT+0xcc>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80084cc:	066e      	lsls	r6, r5, #25
 80084ce:	d5d2      	bpl.n	8008476 <I2C_Master_ISR_IT+0x46>
 80084d0:	0650      	lsls	r0, r2, #25
 80084d2:	d5d0      	bpl.n	8008476 <I2C_Master_ISR_IT+0x46>
    if (hi2c->XferCount == 0U)
 80084d4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80084d6:	b29b      	uxth	r3, r3
 80084d8:	2b00      	cmp	r3, #0
 80084da:	f040 808f 	bne.w	80085fc <I2C_Master_ISR_IT+0x1cc>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 80084de:	6821      	ldr	r1, [r4, #0]
 80084e0:	684b      	ldr	r3, [r1, #4]
 80084e2:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 80084e6:	d1c6      	bne.n	8008476 <I2C_Master_ISR_IT+0x46>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
 80084e8:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 80084ea:	f510 3f80 	cmn.w	r0, #65536	; 0x10000
 80084ee:	f040 80b1 	bne.w	8008654 <I2C_Master_ISR_IT+0x224>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
 80084f2:	684b      	ldr	r3, [r1, #4]
 80084f4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80084f8:	604b      	str	r3, [r1, #4]
 80084fa:	e7bc      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  else if ((I2C_CHECK_FLAG(tmpITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80084fc:	0657      	lsls	r7, r2, #25
 80084fe:	d5ba      	bpl.n	8008476 <I2C_Master_ISR_IT+0x46>
    if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8008500:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008502:	6821      	ldr	r1, [r4, #0]
 8008504:	b29b      	uxth	r3, r3
 8008506:	2b00      	cmp	r3, #0
 8008508:	d051      	beq.n	80085ae <I2C_Master_ISR_IT+0x17e>
 800850a:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 800850c:	2b00      	cmp	r3, #0
 800850e:	d14e      	bne.n	80085ae <I2C_Master_ISR_IT+0x17e>
 8008510:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 8008514:	f44f 46b0 	mov.w	r6, #22528	; 0x5800
 8008518:	f44f 47b8 	mov.w	r7, #23552	; 0x5c00
 800851c:	f44f 50e0 	mov.w	r0, #7168	; 0x1c00
 8008520:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008524:	f2c4 0600 	movt	r6, #16384	; 0x4000
 8008528:	f2c4 0700 	movt	r7, #16384	; 0x4000
 800852c:	f6c5 0000 	movt	r0, #22528	; 0x5800
 8008530:	4299      	cmp	r1, r3
 8008532:	bf18      	it	ne
 8008534:	42b1      	cmpne	r1, r6
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 8008536:	684e      	ldr	r6, [r1, #4]
 8008538:	bf14      	ite	ne
 800853a:	2301      	movne	r3, #1
 800853c:	2300      	moveq	r3, #0
 800853e:	f3c6 0609 	ubfx	r6, r6, #0, #10
 8008542:	42b9      	cmp	r1, r7
 8008544:	bf0c      	ite	eq
 8008546:	2300      	moveq	r3, #0
 8008548:	f003 0301 	andne.w	r3, r3, #1
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800854c:	8d67      	ldrh	r7, [r4, #42]	; 0x2a
 800854e:	4281      	cmp	r1, r0
 8008550:	bf0c      	ite	eq
 8008552:	2300      	moveq	r3, #0
 8008554:	f003 0301 	andne.w	r3, r3, #1
 8008558:	2fff      	cmp	r7, #255	; 0xff
 800855a:	f200 809c 	bhi.w	8008696 <I2C_Master_ISR_IT+0x266>
        hi2c->XferSize = hi2c->XferCount;
 800855e:	8d60      	ldrh	r0, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8008560:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
 8008562:	b280      	uxth	r0, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8008564:	f517 3f80 	cmn.w	r7, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
 8008568:	8520      	strh	r0, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
 800856a:	b2c7      	uxtb	r7, r0
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 800856c:	f000 80a3 	beq.w	80086b6 <I2C_Master_ISR_IT+0x286>
          I2C_TransferConfig(hi2c, devaddress, (uint8_t)hi2c->XferSize, hi2c->XferOptions, I2C_NO_STARTSTOP);
 8008570:	f8d4 802c 	ldr.w	r8, [r4, #44]	; 0x2c
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008574:	2b00      	cmp	r3, #0
 8008576:	f040 80ad 	bne.w	80086d4 <I2C_Master_ISR_IT+0x2a4>
  assert_param(IS_TRANSFER_MODE(Mode));
 800857a:	f038 7380 	bics.w	r3, r8, #16777216	; 0x1000000
 800857e:	d003      	beq.n	8008588 <I2C_Master_ISR_IT+0x158>
 8008580:	f1b8 7f00 	cmp.w	r8, #33554432	; 0x2000000
 8008584:	f040 80b1 	bne.w	80086ea <I2C_Master_ISR_IT+0x2ba>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8008588:	6823      	ldr	r3, [r4, #0]
 800858a:	f44f 411c 	mov.w	r1, #39936	; 0x9c00
 800858e:	6858      	ldr	r0, [r3, #4]
 8008590:	f6cf 4100 	movt	r1, #64512	; 0xfc00
 8008594:	4008      	ands	r0, r1
 8008596:	ea40 0008 	orr.w	r0, r0, r8
 800859a:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 800859e:	4306      	orrs	r6, r0
 80085a0:	605e      	str	r6, [r3, #4]
 80085a2:	e768      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80085a4:	6999      	ldr	r1, [r3, #24]
 80085a6:	f041 0101 	orr.w	r1, r1, #1
 80085aa:	6199      	str	r1, [r3, #24]
 80085ac:	e763      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 80085ae:	684b      	ldr	r3, [r1, #4]
 80085b0:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 80085b4:	d122      	bne.n	80085fc <I2C_Master_ISR_IT+0x1cc>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80085b6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 80085ba:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80085bc:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 80085c0:	9201      	str	r2, [sp, #4]
 80085c2:	2821      	cmp	r0, #33	; 0x21
 80085c4:	d02d      	beq.n	8008622 <I2C_Master_ISR_IT+0x1f2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80085c6:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 80085c8:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80085cc:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80085ce:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80085d0:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80085d2:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80085d6:	f8d1 c000 	ldr.w	ip, [r1]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80085da:	f007 0728 	and.w	r7, r7, #40	; 0x28
 80085de:	2f28      	cmp	r7, #40	; 0x28
 80085e0:	bf14      	ite	ne
 80085e2:	f06f 06f4 	mvnne.w	r6, #244	; 0xf4
 80085e6:	f06f 0644 	mvneq.w	r6, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80085ea:	ea06 060c 	and.w	r6, r6, ip
 80085ee:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 80085f0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80085f4:	f7ff f98c 	bl	8007910 <HAL_I2C_MasterRxCpltCallback>
 80085f8:	9a01      	ldr	r2, [sp, #4]
 80085fa:	e73c      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
 80085fc:	2140      	movs	r1, #64	; 0x40
 80085fe:	4620      	mov	r0, r4
 8008600:	9201      	str	r2, [sp, #4]
 8008602:	f7ff fa49 	bl	8007a98 <I2C_ITError>
 8008606:	9a01      	ldr	r2, [sp, #4]
 8008608:	e735      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  __HAL_LOCK(hi2c);
 800860a:	2002      	movs	r0, #2
}
 800860c:	4770      	bx	lr
    I2C_ITMasterCplt(hi2c, tmpITFlags);
 800860e:	4620      	mov	r0, r4
 8008610:	4629      	mov	r1, r5
 8008612:	f7ff fdcb 	bl	80081ac <I2C_ITMasterCplt>
  __HAL_UNLOCK(hi2c);
 8008616:	2000      	movs	r0, #0
 8008618:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 800861c:	b002      	add	sp, #8
 800861e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8008622:	2611      	movs	r6, #17
    hi2c->State         = HAL_I2C_STATE_READY;
 8008624:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8008628:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
 800862a:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800862c:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800862e:	f894 6041 	ldrb.w	r6, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008632:	680f      	ldr	r7, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008634:	f006 0628 	and.w	r6, r6, #40	; 0x28
 8008638:	2e28      	cmp	r6, #40	; 0x28
 800863a:	bf14      	ite	ne
 800863c:	f06f 06f2 	mvnne.w	r6, #242	; 0xf2
 8008640:	f06f 0642 	mvneq.w	r6, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008644:	403e      	ands	r6, r7
 8008646:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 8008648:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
 800864c:	f7ff f95e 	bl	800790c <HAL_I2C_MasterTxCpltCallback>
 8008650:	9a01      	ldr	r2, [sp, #4]
 8008652:	e710      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8008654:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 8008658:	2720      	movs	r7, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 800865a:	f894 0041 	ldrb.w	r0, [r4, #65]	; 0x41
 800865e:	9201      	str	r2, [sp, #4]
 8008660:	2821      	cmp	r0, #33	; 0x21
 8008662:	d0de      	beq.n	8008622 <I2C_Master_ISR_IT+0x1f2>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8008664:	2612      	movs	r6, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 8008666:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 800866a:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800866c:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800866e:	6326      	str	r6, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008670:	f894 7041 	ldrb.w	r7, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008674:	680e      	ldr	r6, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008676:	f007 0728 	and.w	r7, r7, #40	; 0x28
 800867a:	2f28      	cmp	r7, #40	; 0x28
 800867c:	bf14      	ite	ne
 800867e:	f06f 07f4 	mvnne.w	r7, #244	; 0xf4
 8008682:	f06f 0744 	mvneq.w	r7, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008686:	403e      	ands	r6, r7
 8008688:	600e      	str	r6, [r1, #0]
    __HAL_UNLOCK(hi2c);
 800868a:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 800868e:	f7ff f93f 	bl	8007910 <HAL_I2C_MasterRxCpltCallback>
 8008692:	9a01      	ldr	r2, [sp, #4]
 8008694:	e6ef      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
        hi2c->XferSize = MAX_NBYTE_SIZE;
 8008696:	20ff      	movs	r0, #255	; 0xff
 8008698:	8520      	strh	r0, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800869a:	bb8b      	cbnz	r3, 8008700 <I2C_Master_ISR_IT+0x2d0>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 800869c:	f44f 471c 	mov.w	r7, #39936	; 0x9c00
 80086a0:	2000      	movs	r0, #0
 80086a2:	684b      	ldr	r3, [r1, #4]
 80086a4:	f6cf 4700 	movt	r7, #64512	; 0xfc00
 80086a8:	f2c0 10ff 	movt	r0, #511	; 0x1ff
 80086ac:	403b      	ands	r3, r7
 80086ae:	4330      	orrs	r0, r6
 80086b0:	4303      	orrs	r3, r0
 80086b2:	604b      	str	r3, [r1, #4]
 80086b4:	e6df      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80086b6:	bb7b      	cbnz	r3, 8008718 <I2C_Master_ISR_IT+0x2e8>
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80086b8:	f44f 4c1c 	mov.w	ip, #39936	; 0x9c00
 80086bc:	6848      	ldr	r0, [r1, #4]
 80086be:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
 80086c2:	f6cf 4c00 	movt	ip, #64512	; 0xfc00
 80086c6:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 80086ca:	ea00 000c 	and.w	r0, r0, ip
 80086ce:	4303      	orrs	r3, r0
 80086d0:	604b      	str	r3, [r1, #4]
 80086d2:	e6d0      	b.n	8008476 <I2C_Master_ISR_IT+0x46>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80086d4:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80086d8:	f641 1131 	movw	r1, #6449	; 0x1931
 80086dc:	9201      	str	r2, [sp, #4]
 80086de:	f6c0 0002 	movt	r0, #2050	; 0x802
 80086e2:	f00d f8c1 	bl	8015868 <assert_failed>
 80086e6:	9a01      	ldr	r2, [sp, #4]
 80086e8:	e747      	b.n	800857a <I2C_Master_ISR_IT+0x14a>
  assert_param(IS_TRANSFER_MODE(Mode));
 80086ea:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80086ee:	f641 1132 	movw	r1, #6450	; 0x1932
 80086f2:	9201      	str	r2, [sp, #4]
 80086f4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80086f8:	f00d f8b6 	bl	8015868 <assert_failed>
 80086fc:	9a01      	ldr	r2, [sp, #4]
 80086fe:	e743      	b.n	8008588 <I2C_Master_ISR_IT+0x158>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008700:	f64d 3064 	movw	r0, #56164	; 0xdb64
 8008704:	f641 1131 	movw	r1, #6449	; 0x1931
 8008708:	9201      	str	r2, [sp, #4]
 800870a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800870e:	f00d f8ab 	bl	8015868 <assert_failed>
 8008712:	6821      	ldr	r1, [r4, #0]
 8008714:	9a01      	ldr	r2, [sp, #4]
 8008716:	e7c1      	b.n	800869c <I2C_Master_ISR_IT+0x26c>
 8008718:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800871c:	f641 1131 	movw	r1, #6449	; 0x1931
 8008720:	9201      	str	r2, [sp, #4]
 8008722:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008726:	f00d f89f 	bl	8015868 <assert_failed>
 800872a:	6821      	ldr	r1, [r4, #0]
 800872c:	9a01      	ldr	r2, [sp, #4]
 800872e:	e7c3      	b.n	80086b8 <I2C_Master_ISR_IT+0x288>

08008730 <I2C_Master_ISR_DMA>:
  __HAL_LOCK(hi2c);
 8008730:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8008734:	2b01      	cmp	r3, #1
 8008736:	f000 80b7 	beq.w	80088a8 <I2C_Master_ISR_DMA+0x178>
 800873a:	2301      	movs	r3, #1
{
 800873c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8008740:	06cd      	lsls	r5, r1, #27
 8008742:	4604      	mov	r4, r0
  __HAL_LOCK(hi2c);
 8008744:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40
  if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_AF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_NACKI) != RESET))
 8008748:	d52f      	bpl.n	80087aa <I2C_Master_ISR_DMA+0x7a>
 800874a:	06d0      	lsls	r0, r2, #27
 800874c:	d52d      	bpl.n	80087aa <I2C_Master_ISR_DMA+0x7a>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800874e:	6822      	ldr	r2, [r4, #0]
 8008750:	2110      	movs	r1, #16
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008752:	f647 7341 	movw	r3, #32577	; 0x7f41
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8008756:	61d1      	str	r1, [r2, #28]
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008758:	f6c0 0300 	movt	r3, #2048	; 0x800
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 800875c:	6c62      	ldr	r2, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 800875e:	6b61      	ldr	r1, [r4, #52]	; 0x34
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8008760:	f042 0204 	orr.w	r2, r2, #4
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008764:	4299      	cmp	r1, r3
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8008766:	6462      	str	r2, [r4, #68]	; 0x44
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 8008768:	f000 809c 	beq.w	80088a4 <I2C_Master_ISR_DMA+0x174>
 800876c:	f248 7331 	movw	r3, #34609	; 0x8731
 8008770:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008774:	4299      	cmp	r1, r3
 8008776:	f000 8095 	beq.w	80088a4 <I2C_Master_ISR_DMA+0x174>
      tmpisr |= I2C_IT_STOPI;
 800877a:	2120      	movs	r1, #32
  __HAL_I2C_ENABLE_IT(hi2c, tmpisr);
 800877c:	6822      	ldr	r2, [r4, #0]
 800877e:	6813      	ldr	r3, [r2, #0]
 8008780:	430b      	orrs	r3, r1
 8008782:	6013      	str	r3, [r2, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8008784:	6823      	ldr	r3, [r4, #0]
 8008786:	699a      	ldr	r2, [r3, #24]
 8008788:	0791      	lsls	r1, r2, #30
 800878a:	d502      	bpl.n	8008792 <I2C_Master_ISR_DMA+0x62>
    hi2c->Instance->TXDR = 0x00U;
 800878c:	2200      	movs	r2, #0
 800878e:	629a      	str	r2, [r3, #40]	; 0x28
 8008790:	6823      	ldr	r3, [r4, #0]
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 8008792:	699a      	ldr	r2, [r3, #24]
 8008794:	07d2      	lsls	r2, r2, #31
 8008796:	d403      	bmi.n	80087a0 <I2C_Master_ISR_DMA+0x70>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8008798:	699a      	ldr	r2, [r3, #24]
 800879a:	f042 0201 	orr.w	r2, r2, #1
 800879e:	619a      	str	r2, [r3, #24]
  __HAL_UNLOCK(hi2c);
 80087a0:	2000      	movs	r0, #0
 80087a2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
}
 80087a6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TCR) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 80087aa:	060f      	lsls	r7, r1, #24
 80087ac:	d55c      	bpl.n	8008868 <I2C_Master_ISR_DMA+0x138>
 80087ae:	0656      	lsls	r6, r2, #25
 80087b0:	d570      	bpl.n	8008894 <I2C_Master_ISR_DMA+0x164>
    __HAL_I2C_DISABLE_IT(hi2c, I2C_IT_TCI);
 80087b2:	6822      	ldr	r2, [r4, #0]
 80087b4:	6813      	ldr	r3, [r2, #0]
 80087b6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80087ba:	6013      	str	r3, [r2, #0]
    if (hi2c->XferCount != 0U)
 80087bc:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80087be:	b29b      	uxth	r3, r3
 80087c0:	2b00      	cmp	r3, #0
 80087c2:	d073      	beq.n	80088ac <I2C_Master_ISR_DMA+0x17c>
 80087c4:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
 80087c8:	f44f 42b0 	mov.w	r2, #22528	; 0x5800
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 80087cc:	6820      	ldr	r0, [r4, #0]
 80087ce:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80087d2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 80087d6:	6846      	ldr	r6, [r0, #4]
 80087d8:	4601      	mov	r1, r0
 80087da:	4298      	cmp	r0, r3
 80087dc:	bf18      	it	ne
 80087de:	4290      	cmpne	r0, r2
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80087e0:	8d67      	ldrh	r7, [r4, #42]	; 0x2a
      devaddress = (uint16_t)(hi2c->Instance->CR2 & I2C_CR2_SADD);
 80087e2:	f3c6 0609 	ubfx	r6, r6, #0, #10
 80087e6:	bf14      	ite	ne
 80087e8:	2301      	movne	r3, #1
 80087ea:	2300      	moveq	r3, #0
      if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80087ec:	2fff      	cmp	r7, #255	; 0xff
 80087ee:	f200 8086 	bhi.w	80088fe <I2C_Master_ISR_DMA+0x1ce>
        hi2c->XferSize = hi2c->XferCount;
 80087f2:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 80087f4:	6ae5      	ldr	r5, [r4, #44]	; 0x2c
        hi2c->XferSize = hi2c->XferCount;
 80087f6:	b292      	uxth	r2, r2
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 80087f8:	f515 3f80 	cmn.w	r5, #65536	; 0x10000
        hi2c->XferSize = hi2c->XferCount;
 80087fc:	8522      	strh	r2, [r4, #40]	; 0x28
 80087fe:	b2d2      	uxtb	r2, r2
        if (hi2c->XferOptions != I2C_NO_OPTION_FRAME)
 8008800:	f000 80d3 	beq.w	80089aa <I2C_Master_ISR_DMA+0x27a>
          xfermode = hi2c->XferOptions;
 8008804:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8008806:	0415      	lsls	r5, r2, #16
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008808:	2b00      	cmp	r3, #0
 800880a:	f040 80dc 	bne.w	80089c6 <I2C_Master_ISR_DMA+0x296>
 800880e:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
 8008812:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 8008816:	bf18      	it	ne
 8008818:	f1b8 0f00 	cmpne.w	r8, #0
 800881c:	bf14      	ite	ne
 800881e:	f04f 0801 	movne.w	r8, #1
 8008822:	f04f 0800 	moveq.w	r8, #0
  assert_param(IS_TRANSFER_MODE(Mode));
 8008826:	f1b8 0f00 	cmp.w	r8, #0
 800882a:	f040 80c2 	bne.w	80089b2 <I2C_Master_ISR_DMA+0x282>
 800882e:	6820      	ldr	r0, [r4, #0]
 8008830:	4601      	mov	r1, r0
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8008832:	f44f 421c 	mov.w	r2, #39936	; 0x9c00
 8008836:	684b      	ldr	r3, [r1, #4]
 8008838:	433d      	orrs	r5, r7
 800883a:	f6cf 4200 	movt	r2, #64512	; 0xfc00
 800883e:	4335      	orrs	r5, r6
 8008840:	4013      	ands	r3, r2
 8008842:	431d      	orrs	r5, r3
 8008844:	604d      	str	r5, [r1, #4]
      hi2c->XferCount -= hi2c->XferSize;
 8008846:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008848:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 800884a:	1a9b      	subs	r3, r3, r2
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 800884c:	6822      	ldr	r2, [r4, #0]
      hi2c->XferCount -= hi2c->XferSize;
 800884e:	b29b      	uxth	r3, r3
 8008850:	8563      	strh	r3, [r4, #42]	; 0x2a
      if (hi2c->State == HAL_I2C_STATE_BUSY_RX)
 8008852:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008856:	2b22      	cmp	r3, #34	; 0x22
        hi2c->Instance->CR1 |= I2C_CR1_RXDMAEN;
 8008858:	6813      	ldr	r3, [r2, #0]
 800885a:	bf0c      	ite	eq
 800885c:	f443 4300 	orreq.w	r3, r3, #32768	; 0x8000
        hi2c->Instance->CR1 |= I2C_CR1_TXDMAEN;
 8008860:	f443 4380 	orrne.w	r3, r3, #16384	; 0x4000
 8008864:	6013      	str	r3, [r2, #0]
 8008866:	e79b      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_TC) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_TCI) != RESET))
 8008868:	064d      	lsls	r5, r1, #25
 800886a:	d513      	bpl.n	8008894 <I2C_Master_ISR_DMA+0x164>
 800886c:	0650      	lsls	r0, r2, #25
 800886e:	d511      	bpl.n	8008894 <I2C_Master_ISR_DMA+0x164>
    if (hi2c->XferCount == 0U)
 8008870:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8008872:	b29b      	uxth	r3, r3
 8008874:	2b00      	cmp	r3, #0
 8008876:	d13d      	bne.n	80088f4 <I2C_Master_ISR_DMA+0x1c4>
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 8008878:	6822      	ldr	r2, [r4, #0]
 800887a:	6853      	ldr	r3, [r2, #4]
 800887c:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 8008880:	d18e      	bne.n	80087a0 <I2C_Master_ISR_DMA+0x70>
        if (hi2c->XferOptions == I2C_NO_OPTION_FRAME)
 8008882:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8008884:	f511 3f80 	cmn.w	r1, #65536	; 0x10000
 8008888:	d170      	bne.n	800896c <I2C_Master_ISR_DMA+0x23c>
          hi2c->Instance->CR2 |= I2C_CR2_STOP;
 800888a:	6853      	ldr	r3, [r2, #4]
 800888c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8008890:	6053      	str	r3, [r2, #4]
 8008892:	e785      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
  else if ((I2C_CHECK_FLAG(ITFlags, I2C_FLAG_STOPF) != RESET) && (I2C_CHECK_IT_SOURCE(ITSources, I2C_IT_STOPI) != RESET))
 8008894:	068b      	lsls	r3, r1, #26
 8008896:	d583      	bpl.n	80087a0 <I2C_Master_ISR_DMA+0x70>
 8008898:	0692      	lsls	r2, r2, #26
 800889a:	d581      	bpl.n	80087a0 <I2C_Master_ISR_DMA+0x70>
    I2C_ITMasterCplt(hi2c, ITFlags);
 800889c:	4620      	mov	r0, r4
 800889e:	f7ff fc85 	bl	80081ac <I2C_ITMasterCplt>
 80088a2:	e77d      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
  if ((hi2c->XferISR == I2C_Master_ISR_DMA) || \
 80088a4:	2160      	movs	r1, #96	; 0x60
 80088a6:	e769      	b.n	800877c <I2C_Master_ISR_DMA+0x4c>
  __HAL_LOCK(hi2c);
 80088a8:	2002      	movs	r0, #2
}
 80088aa:	4770      	bx	lr
      if (I2C_GET_STOP_MODE(hi2c) != I2C_AUTOEND_MODE)
 80088ac:	6822      	ldr	r2, [r4, #0]
 80088ae:	6853      	ldr	r3, [r2, #4]
 80088b0:	f013 7300 	ands.w	r3, r3, #33554432	; 0x2000000
 80088b4:	d11e      	bne.n	80088f4 <I2C_Master_ISR_DMA+0x1c4>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80088b6:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 80088ba:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 80088bc:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 80088c0:	2921      	cmp	r1, #33	; 0x21
 80088c2:	d03b      	beq.n	800893c <I2C_Master_ISR_DMA+0x20c>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80088c4:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 80088c6:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 80088ca:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80088cc:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 80088ce:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80088d0:	f894 5041 	ldrb.w	r5, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80088d4:	6816      	ldr	r6, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 80088d6:	f005 0528 	and.w	r5, r5, #40	; 0x28
 80088da:	2d28      	cmp	r5, #40	; 0x28
 80088dc:	bf14      	ite	ne
 80088de:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 80088e2:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 80088e6:	4031      	ands	r1, r6
 80088e8:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 80088ea:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80088ee:	f7ff f80f 	bl	8007910 <HAL_I2C_MasterRxCpltCallback>
 80088f2:	e755      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
        I2C_ITError(hi2c, HAL_I2C_ERROR_SIZE);
 80088f4:	2140      	movs	r1, #64	; 0x40
 80088f6:	4620      	mov	r0, r4
 80088f8:	f7ff f8ce 	bl	8007a98 <I2C_ITError>
 80088fc:	e750      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
        hi2c->XferSize = MAX_NBYTE_SIZE;
 80088fe:	22ff      	movs	r2, #255	; 0xff
 8008900:	f44f 057f 	mov.w	r5, #16711680	; 0xff0000
        xfermode = I2C_RELOAD_MODE;
 8008904:	f04f 7780 	mov.w	r7, #16777216	; 0x1000000
        hi2c->XferSize = MAX_NBYTE_SIZE;
 8008908:	8522      	strh	r2, [r4, #40]	; 0x28
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 800890a:	2b00      	cmp	r3, #0
 800890c:	d091      	beq.n	8008832 <I2C_Master_ISR_DMA+0x102>
 800890e:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8008912:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8008916:	4298      	cmp	r0, r3
 8008918:	d08a      	beq.n	8008830 <I2C_Master_ISR_DMA+0x100>
 800891a:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
 800891e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008922:	4298      	cmp	r0, r3
 8008924:	d084      	beq.n	8008830 <I2C_Master_ISR_DMA+0x100>
 8008926:	f04f 0800 	mov.w	r8, #0
 800892a:	f64d 3064 	movw	r0, #56164	; 0xdb64
 800892e:	f641 1131 	movw	r1, #6449	; 0x1931
 8008932:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008936:	f00c ff97 	bl	8015868 <assert_failed>
 800893a:	e774      	b.n	8008826 <I2C_Master_ISR_DMA+0xf6>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 800893c:	2111      	movs	r1, #17
    hi2c->State         = HAL_I2C_STATE_READY;
 800893e:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8008942:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterTxCpltCallback(hi2c);
 8008944:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_TX;
 8008946:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008948:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800894c:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800894e:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8008952:	2928      	cmp	r1, #40	; 0x28
 8008954:	bf14      	ite	ne
 8008956:	f06f 01f2 	mvnne.w	r1, #242	; 0xf2
 800895a:	f06f 0142 	mvneq.w	r1, #66	; 0x42
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800895e:	4029      	ands	r1, r5
 8008960:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 8008962:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterTxCpltCallback(hi2c);
 8008966:	f7fe ffd1 	bl	800790c <HAL_I2C_MasterTxCpltCallback>
 800896a:	e719      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
  hi2c->Mode = HAL_I2C_MODE_NONE;
 800896c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->State         = HAL_I2C_STATE_READY;
 8008970:	2520      	movs	r5, #32
  if (hi2c->State == HAL_I2C_STATE_BUSY_TX)
 8008972:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
 8008976:	2921      	cmp	r1, #33	; 0x21
 8008978:	d0e0      	beq.n	800893c <I2C_Master_ISR_DMA+0x20c>
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 800897a:	2112      	movs	r1, #18
    hi2c->State         = HAL_I2C_STATE_READY;
 800897c:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8008980:	6363      	str	r3, [r4, #52]	; 0x34
    HAL_I2C_MasterRxCpltCallback(hi2c);
 8008982:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_MASTER_BUSY_RX;
 8008984:	6321      	str	r1, [r4, #48]	; 0x30
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008986:	f894 1041 	ldrb.w	r1, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800898a:	6815      	ldr	r5, [r2, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 800898c:	f001 0128 	and.w	r1, r1, #40	; 0x28
 8008990:	2928      	cmp	r1, #40	; 0x28
 8008992:	bf14      	ite	ne
 8008994:	f06f 01f4 	mvnne.w	r1, #244	; 0xf4
 8008998:	f06f 0144 	mvneq.w	r1, #68	; 0x44
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 800899c:	4029      	ands	r1, r5
 800899e:	6011      	str	r1, [r2, #0]
    __HAL_UNLOCK(hi2c);
 80089a0:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_MasterRxCpltCallback(hi2c);
 80089a4:	f7fe ffb4 	bl	8007910 <HAL_I2C_MasterRxCpltCallback>
 80089a8:	e6fa      	b.n	80087a0 <I2C_Master_ISR_DMA+0x70>
          xfermode = I2C_AUTOEND_MODE;
 80089aa:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 80089ae:	0415      	lsls	r5, r2, #16
 80089b0:	e7ab      	b.n	800890a <I2C_Master_ISR_DMA+0x1da>
  assert_param(IS_TRANSFER_MODE(Mode));
 80089b2:	f64d 3064 	movw	r0, #56164	; 0xdb64
 80089b6:	f641 1132 	movw	r1, #6450	; 0x1932
 80089ba:	f6c0 0002 	movt	r0, #2050	; 0x802
 80089be:	f00c ff53 	bl	8015868 <assert_failed>
 80089c2:	6821      	ldr	r1, [r4, #0]
 80089c4:	e735      	b.n	8008832 <I2C_Master_ISR_DMA+0x102>
 80089c6:	f027 7880 	bic.w	r8, r7, #16777216	; 0x1000000
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 80089ca:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80089ce:	f1b7 7f00 	cmp.w	r7, #33554432	; 0x2000000
 80089d2:	bf18      	it	ne
 80089d4:	f1b8 0f00 	cmpne.w	r8, #0
 80089d8:	f6c5 0300 	movt	r3, #22528	; 0x5800
 80089dc:	bf14      	ite	ne
 80089de:	f04f 0801 	movne.w	r8, #1
 80089e2:	f04f 0800 	moveq.w	r8, #0
 80089e6:	4298      	cmp	r0, r3
 80089e8:	f43f af1d 	beq.w	8008826 <I2C_Master_ISR_DMA+0xf6>
 80089ec:	f44f 43b8 	mov.w	r3, #23552	; 0x5c00
 80089f0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80089f4:	4298      	cmp	r0, r3
 80089f6:	d198      	bne.n	800892a <I2C_Master_ISR_DMA+0x1fa>
 80089f8:	e715      	b.n	8008826 <I2C_Master_ISR_DMA+0xf6>
 80089fa:	bf00      	nop

080089fc <HAL_I2C_ER_IRQHandler>:
{
 80089fc:	b570      	push	{r4, r5, r6, lr}
  uint32_t itflags   = READ_REG(hi2c->Instance->ISR);
 80089fe:	6803      	ldr	r3, [r0, #0]
 8008a00:	699a      	ldr	r2, [r3, #24]
 8008a02:	461e      	mov	r6, r3
  uint32_t itsources = READ_REG(hi2c->Instance->CR1);
 8008a04:	681c      	ldr	r4, [r3, #0]
 8008a06:	f3c2 2180 	ubfx	r1, r2, #10, #1
 8008a0a:	f3c2 2540 	ubfx	r5, r2, #9, #1
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_BERR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a0e:	05d2      	lsls	r2, r2, #23
 8008a10:	d518      	bpl.n	8008a44 <HAL_I2C_ER_IRQHandler+0x48>
 8008a12:	0622      	lsls	r2, r4, #24
 8008a14:	d51e      	bpl.n	8008a54 <HAL_I2C_ER_IRQHandler+0x58>
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8008a16:	6c42      	ldr	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8008a18:	f44f 7480 	mov.w	r4, #256	; 0x100
    hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
 8008a1c:	f042 0201 	orr.w	r2, r2, #1
 8008a20:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_BERR);
 8008a22:	61dc      	str	r4, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a24:	b139      	cbz	r1, 8008a36 <HAL_I2C_ER_IRQHandler+0x3a>
 8008a26:	6803      	ldr	r3, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8008a28:	6c42      	ldr	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8008a2a:	f44f 6180 	mov.w	r1, #1024	; 0x400
    hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
 8008a2e:	f042 0208 	orr.w	r2, r2, #8
 8008a32:	6442      	str	r2, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_OVR);
 8008a34:	61d9      	str	r1, [r3, #28]
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a36:	2d00      	cmp	r5, #0
 8008a38:	d153      	bne.n	8008ae2 <HAL_I2C_ER_IRQHandler+0xe6>
  tmperror = hi2c->ErrorCode;
 8008a3a:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8008a3c:	f013 0f0b 	tst.w	r3, #11
 8008a40:	d112      	bne.n	8008a68 <HAL_I2C_ER_IRQHandler+0x6c>
}
 8008a42:	bd70      	pop	{r4, r5, r6, pc}
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a44:	b141      	cbz	r1, 8008a58 <HAL_I2C_ER_IRQHandler+0x5c>
 8008a46:	0626      	lsls	r6, r4, #24
 8008a48:	d4ee      	bmi.n	8008a28 <HAL_I2C_ER_IRQHandler+0x2c>
  tmperror = hi2c->ErrorCode;
 8008a4a:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8008a4c:	f013 0f0b 	tst.w	r3, #11
 8008a50:	d0f7      	beq.n	8008a42 <HAL_I2C_ER_IRQHandler+0x46>
 8008a52:	e009      	b.n	8008a68 <HAL_I2C_ER_IRQHandler+0x6c>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_OVR) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a54:	2900      	cmp	r1, #0
 8008a56:	d1f0      	bne.n	8008a3a <HAL_I2C_ER_IRQHandler+0x3e>
  if ((I2C_CHECK_FLAG(itflags, I2C_FLAG_ARLO) != RESET) && (I2C_CHECK_IT_SOURCE(itsources, I2C_IT_ERRI) != RESET))
 8008a58:	2d00      	cmp	r5, #0
 8008a5a:	d0ee      	beq.n	8008a3a <HAL_I2C_ER_IRQHandler+0x3e>
 8008a5c:	0624      	lsls	r4, r4, #24
 8008a5e:	d441      	bmi.n	8008ae4 <HAL_I2C_ER_IRQHandler+0xe8>
  tmperror = hi2c->ErrorCode;
 8008a60:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8008a62:	f013 0f0b 	tst.w	r3, #11
 8008a66:	d0ec      	beq.n	8008a42 <HAL_I2C_ER_IRQHandler+0x46>
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008a68:	2500      	movs	r5, #0
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8008a6a:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8008a6e:	6801      	ldr	r1, [r0, #0]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008a70:	462c      	mov	r4, r5
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008a72:	f6cf 75ff 	movt	r5, #65535	; 0xffff
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008a76:	3a28      	subs	r2, #40	; 0x28
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008a78:	f880 4042 	strb.w	r4, [r0, #66]	; 0x42
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008a7c:	62c5      	str	r5, [r0, #44]	; 0x2c
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008a7e:	2a02      	cmp	r2, #2
  hi2c->XferCount     = 0U;
 8008a80:	8544      	strh	r4, [r0, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8008a82:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8008a84:	ea43 0304 	orr.w	r3, r3, r4
 8008a88:	6443      	str	r3, [r0, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008a8a:	d937      	bls.n	8008afc <HAL_I2C_ER_IRQHandler+0x100>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008a8c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008a90:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008a94:	680b      	ldr	r3, [r1, #0]
 8008a96:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8008a9a:	600b      	str	r3, [r1, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8008a9c:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8008aa0:	2b60      	cmp	r3, #96	; 0x60
 8008aa2:	d002      	beq.n	8008aaa <HAL_I2C_ER_IRQHandler+0xae>
      hi2c->State         = HAL_I2C_STATE_READY;
 8008aa4:	2320      	movs	r3, #32
 8008aa6:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8008aaa:	2300      	movs	r3, #0
 8008aac:	6343      	str	r3, [r0, #52]	; 0x34
 8008aae:	4604      	mov	r4, r0
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8008ab0:	6b80      	ldr	r0, [r0, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8008ab2:	6b23      	ldr	r3, [r4, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8008ab4:	b118      	cbz	r0, 8008abe <HAL_I2C_ER_IRQHandler+0xc2>
 8008ab6:	2b11      	cmp	r3, #17
 8008ab8:	d03c      	beq.n	8008b34 <HAL_I2C_ER_IRQHandler+0x138>
 8008aba:	2b21      	cmp	r3, #33	; 0x21
 8008abc:	d03a      	beq.n	8008b34 <HAL_I2C_ER_IRQHandler+0x138>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8008abe:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008ac0:	b118      	cbz	r0, 8008aca <HAL_I2C_ER_IRQHandler+0xce>
 8008ac2:	2b12      	cmp	r3, #18
 8008ac4:	d057      	beq.n	8008b76 <HAL_I2C_ER_IRQHandler+0x17a>
 8008ac6:	2b22      	cmp	r3, #34	; 0x22
 8008ac8:	d055      	beq.n	8008b76 <HAL_I2C_ER_IRQHandler+0x17a>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8008aca:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008ace:	2b60      	cmp	r3, #96	; 0x60
 8008ad0:	d06d      	beq.n	8008bae <HAL_I2C_ER_IRQHandler+0x1b2>
    hi2c->PreviousState = I2C_STATE_NONE;
 8008ad2:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8008ad4:	4620      	mov	r0, r4
    hi2c->PreviousState = I2C_STATE_NONE;
 8008ad6:	6323      	str	r3, [r4, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8008ad8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8008adc:	f7fe ffb6 	bl	8007a4c <HAL_I2C_ErrorCallback>
}
 8008ae0:	bd70      	pop	{r4, r5, r6, pc}
 8008ae2:	6806      	ldr	r6, [r0, #0]
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8008ae4:	6c43      	ldr	r3, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8008ae6:	f44f 7200 	mov.w	r2, #512	; 0x200
    hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
 8008aea:	f043 0302 	orr.w	r3, r3, #2
 8008aee:	6443      	str	r3, [r0, #68]	; 0x44
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_ARLO);
 8008af0:	61f2      	str	r2, [r6, #28]
  tmperror = hi2c->ErrorCode;
 8008af2:	6c43      	ldr	r3, [r0, #68]	; 0x44
  if ((tmperror & (HAL_I2C_ERROR_BERR | HAL_I2C_ERROR_OVR | HAL_I2C_ERROR_ARLO)) !=  HAL_I2C_ERROR_NONE)
 8008af4:	f013 0f0b 	tst.w	r3, #11
 8008af8:	d0a3      	beq.n	8008a42 <HAL_I2C_ER_IRQHandler+0x46>
 8008afa:	e7b5      	b.n	8008a68 <HAL_I2C_ER_IRQHandler+0x6c>
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008afc:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8008b00:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b02:	f890 5041 	ldrb.w	r5, [r0, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008b06:	f647 5399 	movw	r3, #32153	; 0x7d99
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b0a:	4032      	ands	r2, r6
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b0c:	4035      	ands	r5, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008b0e:	f6c0 0300 	movt	r3, #2048	; 0x800
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b12:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008b14:	680a      	ldr	r2, [r1, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b16:	bf14      	ite	ne
 8008b18:	f06f 04f6 	mvnne.w	r4, #246	; 0xf6
 8008b1c:	f06f 0446 	mvneq.w	r4, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008b20:	42b5      	cmp	r5, r6
 8008b22:	bf18      	it	ne
 8008b24:	f06f 04f6 	mvnne.w	r4, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008b28:	4022      	ands	r2, r4
 8008b2a:	600a      	str	r2, [r1, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008b2c:	6343      	str	r3, [r0, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8008b2e:	f880 6041 	strb.w	r6, [r0, #65]	; 0x41
 8008b32:	e7bc      	b.n	8008aae <HAL_I2C_ER_IRQHandler+0xb2>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8008b34:	6823      	ldr	r3, [r4, #0]
 8008b36:	681a      	ldr	r2, [r3, #0]
 8008b38:	0451      	lsls	r1, r2, #17
 8008b3a:	d504      	bpl.n	8008b46 <HAL_I2C_ER_IRQHandler+0x14a>
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8008b3c:	681a      	ldr	r2, [r3, #0]
 8008b3e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8008b42:	601a      	str	r2, [r3, #0]
 8008b44:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8008b46:	f7fc fc77 	bl	8005438 <HAL_DMA_GetState>
 8008b4a:	2801      	cmp	r0, #1
 8008b4c:	d0bd      	beq.n	8008aca <HAL_I2C_ER_IRQHandler+0xce>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8008b4e:	f647 2355 	movw	r3, #31317	; 0x7a55
 8008b52:	6ba1      	ldr	r1, [r4, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8008b54:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8008b56:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008b5a:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8008b5c:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8008b60:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 8008b62:	f7fb fdcf 	bl	8004704 <HAL_DMA_Abort_IT>
 8008b66:	2800      	cmp	r0, #0
 8008b68:	f43f af6b 	beq.w	8008a42 <HAL_I2C_ER_IRQHandler+0x46>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8008b6c:	6ba0      	ldr	r0, [r4, #56]	; 0x38
}
 8008b6e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8008b72:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8008b74:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8008b76:	6823      	ldr	r3, [r4, #0]
 8008b78:	681a      	ldr	r2, [r3, #0]
 8008b7a:	0412      	lsls	r2, r2, #16
 8008b7c:	d422      	bmi.n	8008bc4 <HAL_I2C_ER_IRQHandler+0x1c8>
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8008b7e:	f7fc fc5b 	bl	8005438 <HAL_DMA_GetState>
 8008b82:	2801      	cmp	r0, #1
 8008b84:	d0a1      	beq.n	8008aca <HAL_I2C_ER_IRQHandler+0xce>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8008b86:	f647 2355 	movw	r3, #31317	; 0x7a55
 8008b8a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8008b8c:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8008b8e:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008b92:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8008b94:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8008b98:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008b9a:	f7fb fdb3 	bl	8004704 <HAL_DMA_Abort_IT>
 8008b9e:	2800      	cmp	r0, #0
 8008ba0:	f43f af4f 	beq.w	8008a42 <HAL_I2C_ER_IRQHandler+0x46>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8008ba4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
}
 8008ba6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8008baa:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8008bac:	4718      	bx	r3
    hi2c->PreviousState = I2C_STATE_NONE;
 8008bae:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8008bb0:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8008bb2:	4620      	mov	r0, r4
    hi2c->State = HAL_I2C_STATE_READY;
 8008bb4:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8008bb8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8008bbc:	6323      	str	r3, [r4, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8008bbe:	f7fe ff47 	bl	8007a50 <HAL_I2C_AbortCpltCallback>
}
 8008bc2:	bd70      	pop	{r4, r5, r6, pc}
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8008bc4:	681a      	ldr	r2, [r3, #0]
 8008bc6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008bca:	601a      	str	r2, [r3, #0]
 8008bcc:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8008bce:	e7d6      	b.n	8008b7e <HAL_I2C_ER_IRQHandler+0x182>

08008bd0 <I2C_DMAError>:
{
 8008bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  I2C_HandleTypeDef *hi2c = (I2C_HandleTypeDef *)(((DMA_HandleTypeDef *)hdma)->Parent); /* Derogation MISRAC2012-Rule-11.5 */
 8008bd4:	6b85      	ldr	r5, [r0, #56]	; 0x38
  if (hi2c->hdmatx != NULL)
 8008bd6:	6bac      	ldr	r4, [r5, #56]	; 0x38
 8008bd8:	b124      	cbz	r4, 8008be4 <I2C_DMAError+0x14>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmatx) == 0U)
 8008bda:	6822      	ldr	r2, [r4, #0]
 8008bdc:	6854      	ldr	r4, [r2, #4]
 8008bde:	fab4 f484 	clz	r4, r4
 8008be2:	0964      	lsrs	r4, r4, #5
  if (hi2c->hdmarx != NULL)
 8008be4:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8008be6:	2a00      	cmp	r2, #0
 8008be8:	d04c      	beq.n	8008c84 <I2C_DMAError+0xb4>
    if (__HAL_DMA_GET_COUNTER(hi2c->hdmarx) == 0U)
 8008bea:	6812      	ldr	r2, [r2, #0]
 8008bec:	6853      	ldr	r3, [r2, #4]
 8008bee:	fab3 f383 	clz	r3, r3
 8008bf2:	095b      	lsrs	r3, r3, #5
 8008bf4:	2b00      	cmp	r3, #0
 8008bf6:	d045      	beq.n	8008c84 <I2C_DMAError+0xb4>
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
 8008bf8:	f7fc fc22 	bl	8005440 <HAL_DMA_GetError>
 8008bfc:	2802      	cmp	r0, #2
 8008bfe:	d03f      	beq.n	8008c80 <I2C_DMAError+0xb0>
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8008c00:	6828      	ldr	r0, [r5, #0]
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008c02:	2100      	movs	r1, #0
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8008c04:	6843      	ldr	r3, [r0, #4]
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008c06:	460a      	mov	r2, r1
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008c08:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    hi2c->Instance->CR2 |= I2C_CR2_NACK;
 8008c0c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8008c10:	6043      	str	r3, [r0, #4]
  HAL_I2C_StateTypeDef tmpstate = hi2c->State;
 8008c12:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  hi2c->Mode          = HAL_I2C_MODE_NONE;
 8008c16:	f885 2042 	strb.w	r2, [r5, #66]	; 0x42
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008c1a:	3b28      	subs	r3, #40	; 0x28
  hi2c->XferOptions   = I2C_NO_OPTION_FRAME;
 8008c1c:	62e9      	str	r1, [r5, #44]	; 0x2c
  hi2c->XferCount     = 0U;
 8008c1e:	856a      	strh	r2, [r5, #42]	; 0x2a
  hi2c->ErrorCode |= ErrorCode;
 8008c20:	6c6a      	ldr	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008c22:	2b02      	cmp	r3, #2
  hi2c->ErrorCode |= ErrorCode;
 8008c24:	f042 0210 	orr.w	r2, r2, #16
 8008c28:	646a      	str	r2, [r5, #68]	; 0x44
  if ((tmpstate == HAL_I2C_STATE_LISTEN)         ||
 8008c2a:	d933      	bls.n	8008c94 <I2C_DMAError+0xc4>
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008c2c:	682a      	ldr	r2, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008c2e:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008c32:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008c36:	6813      	ldr	r3, [r2, #0]
 8008c38:	f023 03fe 	bic.w	r3, r3, #254	; 0xfe
 8008c3c:	6013      	str	r3, [r2, #0]
    if (hi2c->State != HAL_I2C_STATE_ABORT)
 8008c3e:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8008c42:	2b60      	cmp	r3, #96	; 0x60
 8008c44:	d002      	beq.n	8008c4c <I2C_DMAError+0x7c>
      hi2c->State         = HAL_I2C_STATE_READY;
 8008c46:	2320      	movs	r3, #32
 8008c48:	f885 3041 	strb.w	r3, [r5, #65]	; 0x41
    hi2c->XferISR       = NULL;
 8008c4c:	2300      	movs	r3, #0
 8008c4e:	636b      	str	r3, [r5, #52]	; 0x34
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8008c50:	6ba8      	ldr	r0, [r5, #56]	; 0x38
  tmppreviousstate = hi2c->PreviousState;
 8008c52:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  if ((hi2c->hdmatx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_TX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_TX)))
 8008c54:	b118      	cbz	r0, 8008c5e <I2C_DMAError+0x8e>
 8008c56:	2b11      	cmp	r3, #17
 8008c58:	d039      	beq.n	8008cce <I2C_DMAError+0xfe>
 8008c5a:	2b21      	cmp	r3, #33	; 0x21
 8008c5c:	d037      	beq.n	8008cce <I2C_DMAError+0xfe>
  else if ((hi2c->hdmarx != NULL) && ((tmppreviousstate == I2C_STATE_MASTER_BUSY_RX) || (tmppreviousstate == I2C_STATE_SLAVE_BUSY_RX)))
 8008c5e:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8008c60:	b118      	cbz	r0, 8008c6a <I2C_DMAError+0x9a>
 8008c62:	2b12      	cmp	r3, #18
 8008c64:	d04e      	beq.n	8008d04 <I2C_DMAError+0x134>
 8008c66:	2b22      	cmp	r3, #34	; 0x22
 8008c68:	d04c      	beq.n	8008d04 <I2C_DMAError+0x134>
  if (hi2c->State == HAL_I2C_STATE_ABORT)
 8008c6a:	f895 3041 	ldrb.w	r3, [r5, #65]	; 0x41
 8008c6e:	2b60      	cmp	r3, #96	; 0x60
 8008c70:	d06e      	beq.n	8008d50 <I2C_DMAError+0x180>
    hi2c->PreviousState = I2C_STATE_NONE;
 8008c72:	2300      	movs	r3, #0
    HAL_I2C_ErrorCallback(hi2c);
 8008c74:	4628      	mov	r0, r5
    hi2c->PreviousState = I2C_STATE_NONE;
 8008c76:	632b      	str	r3, [r5, #48]	; 0x30
    __HAL_UNLOCK(hi2c);
 8008c78:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    HAL_I2C_ErrorCallback(hi2c);
 8008c7c:	f7fe fee6 	bl	8007a4c <HAL_I2C_ErrorCallback>
}
 8008c80:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (!((HAL_DMA_GetError(hdma) == HAL_DMA_ERROR_FE)) && (treatdmaerror != 0U))
 8008c84:	f7fc fbdc 	bl	8005440 <HAL_DMA_GetError>
 8008c88:	2802      	cmp	r0, #2
 8008c8a:	d0f9      	beq.n	8008c80 <I2C_DMAError+0xb0>
 8008c8c:	07e0      	lsls	r0, r4, #31
 8008c8e:	d4b7      	bmi.n	8008c00 <I2C_DMAError+0x30>
}
 8008c90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008c94:	f895 2041 	ldrb.w	r2, [r5, #65]	; 0x41
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8008c98:	2628      	movs	r6, #40	; 0x28
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008c9a:	f895 0041 	ldrb.w	r0, [r5, #65]	; 0x41
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008c9e:	f647 5399 	movw	r3, #32153	; 0x7d99
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008ca2:	4032      	ands	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008ca4:	682c      	ldr	r4, [r5, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008ca6:	4030      	ands	r0, r6
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008ca8:	f6c0 0300 	movt	r3, #2048	; 0x800
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008cac:	42b2      	cmp	r2, r6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008cae:	6822      	ldr	r2, [r4, #0]
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008cb0:	bf14      	ite	ne
 8008cb2:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
 8008cb6:	f06f 0146 	mvneq.w	r1, #70	; 0x46
    if (((uint32_t)hi2c->State & (uint32_t)HAL_I2C_STATE_LISTEN) != (uint32_t)HAL_I2C_STATE_LISTEN)
 8008cba:	42b0      	cmp	r0, r6
 8008cbc:	bf18      	it	ne
 8008cbe:	f06f 01f6 	mvnne.w	r1, #246	; 0xf6
  __HAL_I2C_DISABLE_IT(hi2c, tmpisr);
 8008cc2:	400a      	ands	r2, r1
 8008cc4:	6022      	str	r2, [r4, #0]
    hi2c->XferISR       = I2C_Slave_ISR_IT;
 8008cc6:	636b      	str	r3, [r5, #52]	; 0x34
    hi2c->State         = HAL_I2C_STATE_LISTEN;
 8008cc8:	f885 6041 	strb.w	r6, [r5, #65]	; 0x41
 8008ccc:	e7c0      	b.n	8008c50 <I2C_DMAError+0x80>
    if ((hi2c->Instance->CR1 & I2C_CR1_TXDMAEN) == I2C_CR1_TXDMAEN)
 8008cce:	682b      	ldr	r3, [r5, #0]
 8008cd0:	681a      	ldr	r2, [r3, #0]
 8008cd2:	0451      	lsls	r1, r2, #17
 8008cd4:	d436      	bmi.n	8008d44 <I2C_DMAError+0x174>
    if (HAL_DMA_GetState(hi2c->hdmatx) != HAL_DMA_STATE_READY)
 8008cd6:	f7fc fbaf 	bl	8005438 <HAL_DMA_GetState>
 8008cda:	2801      	cmp	r0, #1
 8008cdc:	d0c5      	beq.n	8008c6a <I2C_DMAError+0x9a>
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8008cde:	f647 2355 	movw	r3, #31317	; 0x7a55
 8008ce2:	6ba9      	ldr	r1, [r5, #56]	; 0x38
      __HAL_UNLOCK(hi2c);
 8008ce4:	2200      	movs	r2, #0
      hi2c->hdmatx->XferAbortCallback = I2C_DMAAbort;
 8008ce6:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008cea:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8008cec:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmatx) != HAL_OK)
 8008cf0:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8008cf2:	f7fb fd07 	bl	8004704 <HAL_DMA_Abort_IT>
 8008cf6:	2800      	cmp	r0, #0
 8008cf8:	d0c2      	beq.n	8008c80 <I2C_DMAError+0xb0>
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8008cfa:	6ba8      	ldr	r0, [r5, #56]	; 0x38
}
 8008cfc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hi2c->hdmatx->XferAbortCallback(hi2c->hdmatx);
 8008d00:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8008d02:	4718      	bx	r3
    if ((hi2c->Instance->CR1 & I2C_CR1_RXDMAEN) == I2C_CR1_RXDMAEN)
 8008d04:	682b      	ldr	r3, [r5, #0]
 8008d06:	681a      	ldr	r2, [r3, #0]
 8008d08:	0412      	lsls	r2, r2, #16
 8008d0a:	d504      	bpl.n	8008d16 <I2C_DMAError+0x146>
      hi2c->Instance->CR1 &= ~I2C_CR1_RXDMAEN;
 8008d0c:	681a      	ldr	r2, [r3, #0]
 8008d0e:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8008d12:	601a      	str	r2, [r3, #0]
 8008d14:	6be8      	ldr	r0, [r5, #60]	; 0x3c
    if (HAL_DMA_GetState(hi2c->hdmarx) != HAL_DMA_STATE_READY)
 8008d16:	f7fc fb8f 	bl	8005438 <HAL_DMA_GetState>
 8008d1a:	2801      	cmp	r0, #1
 8008d1c:	d0a5      	beq.n	8008c6a <I2C_DMAError+0x9a>
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8008d1e:	f647 2355 	movw	r3, #31317	; 0x7a55
 8008d22:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      __HAL_UNLOCK(hi2c);
 8008d24:	2200      	movs	r2, #0
      hi2c->hdmarx->XferAbortCallback = I2C_DMAAbort;
 8008d26:	f6c0 0300 	movt	r3, #2048	; 0x800
 8008d2a:	650b      	str	r3, [r1, #80]	; 0x50
      __HAL_UNLOCK(hi2c);
 8008d2c:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
      if (HAL_DMA_Abort_IT(hi2c->hdmarx) != HAL_OK)
 8008d30:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8008d32:	f7fb fce7 	bl	8004704 <HAL_DMA_Abort_IT>
 8008d36:	2800      	cmp	r0, #0
 8008d38:	d0a2      	beq.n	8008c80 <I2C_DMAError+0xb0>
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8008d3a:	6be8      	ldr	r0, [r5, #60]	; 0x3c
}
 8008d3c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        hi2c->hdmarx->XferAbortCallback(hi2c->hdmarx);
 8008d40:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8008d42:	4718      	bx	r3
      hi2c->Instance->CR1 &= ~I2C_CR1_TXDMAEN;
 8008d44:	681a      	ldr	r2, [r3, #0]
 8008d46:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8008d4a:	601a      	str	r2, [r3, #0]
 8008d4c:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8008d4e:	e7c2      	b.n	8008cd6 <I2C_DMAError+0x106>
    hi2c->PreviousState = I2C_STATE_NONE;
 8008d50:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8008d52:	2220      	movs	r2, #32
    HAL_I2C_AbortCpltCallback(hi2c);
 8008d54:	4628      	mov	r0, r5
    hi2c->State = HAL_I2C_STATE_READY;
 8008d56:	f885 2041 	strb.w	r2, [r5, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8008d5a:	f885 3040 	strb.w	r3, [r5, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
 8008d5e:	632b      	str	r3, [r5, #48]	; 0x30
    HAL_I2C_AbortCpltCallback(hi2c);
 8008d60:	f7fe fe76 	bl	8007a50 <HAL_I2C_AbortCpltCallback>
 8008d64:	e78c      	b.n	8008c80 <I2C_DMAError+0xb0>
 8008d66:	bf00      	nop

08008d68 <HAL_I2CEx_ConfigAnalogFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  AnalogFilter New state of the Analog filter.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigAnalogFilter(I2C_HandleTypeDef *hi2c, uint32_t AnalogFilter)
{
 8008d68:	b570      	push	{r4, r5, r6, lr}
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008d6a:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
{
 8008d6e:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008d70:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
 8008d74:	f44f 40b8 	mov.w	r0, #23552	; 0x5c00
 8008d78:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008d7c:	6822      	ldr	r2, [r4, #0]
 8008d7e:	f2c4 0500 	movt	r5, #16384	; 0x4000
 8008d82:	f2c4 0000 	movt	r0, #16384	; 0x4000
{
 8008d86:	460e      	mov	r6, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008d88:	429a      	cmp	r2, r3
 8008d8a:	bf18      	it	ne
 8008d8c:	42aa      	cmpne	r2, r5
 8008d8e:	bf14      	ite	ne
 8008d90:	2301      	movne	r3, #1
 8008d92:	2300      	moveq	r3, #0
 8008d94:	4282      	cmp	r2, r0
 8008d96:	bf0c      	ite	eq
 8008d98:	2300      	moveq	r3, #0
 8008d9a:	f003 0301 	andne.w	r3, r3, #1
 8008d9e:	b12b      	cbz	r3, 8008dac <HAL_I2CEx_ConfigAnalogFilter+0x44>
 8008da0:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8008da4:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8008da8:	429a      	cmp	r2, r3
 8008daa:	d135      	bne.n	8008e18 <HAL_I2CEx_ConfigAnalogFilter+0xb0>
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 8008dac:	f436 5380 	bics.w	r3, r6, #4096	; 0x1000
 8008db0:	d12a      	bne.n	8008e08 <HAL_I2CEx_ConfigAnalogFilter+0xa0>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8008db2:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008db6:	b2db      	uxtb	r3, r3
 8008db8:	2b20      	cmp	r3, #32
 8008dba:	d123      	bne.n	8008e04 <HAL_I2CEx_ConfigAnalogFilter+0x9c>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8008dbc:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8008dc0:	2a01      	cmp	r2, #1
 8008dc2:	d01f      	beq.n	8008e04 <HAL_I2CEx_ConfigAnalogFilter+0x9c>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8008dc4:	6825      	ldr	r5, [r4, #0]
    __HAL_LOCK(hi2c);
 8008dc6:	2101      	movs	r1, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
 8008dc8:	2224      	movs	r2, #36	; 0x24
    __HAL_LOCK(hi2c);
 8008dca:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008dce:	2100      	movs	r1, #0
    hi2c->State = HAL_I2C_STATE_BUSY;
 8008dd0:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
    __HAL_I2C_DISABLE(hi2c);
 8008dd4:	682a      	ldr	r2, [r5, #0]

    return HAL_OK;
 8008dd6:	4608      	mov	r0, r1
    __HAL_I2C_DISABLE(hi2c);
 8008dd8:	f022 0201 	bic.w	r2, r2, #1
 8008ddc:	602a      	str	r2, [r5, #0]
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8008dde:	6825      	ldr	r5, [r4, #0]
 8008de0:	682a      	ldr	r2, [r5, #0]
 8008de2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8008de6:	602a      	str	r2, [r5, #0]
    hi2c->Instance->CR1 |= AnalogFilter;
 8008de8:	6825      	ldr	r5, [r4, #0]
 8008dea:	682a      	ldr	r2, [r5, #0]
 8008dec:	4316      	orrs	r6, r2
 8008dee:	602e      	str	r6, [r5, #0]
    __HAL_I2C_ENABLE(hi2c);
 8008df0:	6825      	ldr	r5, [r4, #0]
 8008df2:	682a      	ldr	r2, [r5, #0]
 8008df4:	f042 0201 	orr.w	r2, r2, #1
 8008df8:	602a      	str	r2, [r5, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8008dfa:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8008dfe:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8008e02:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8008e04:	2002      	movs	r0, #2
}
 8008e06:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));
 8008e08:	f64d 309c 	movw	r0, #56220	; 0xdb9c
 8008e0c:	2165      	movs	r1, #101	; 0x65
 8008e0e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008e12:	f00c fd29 	bl	8015868 <assert_failed>
 8008e16:	e7cc      	b.n	8008db2 <HAL_I2CEx_ConfigAnalogFilter+0x4a>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008e18:	f64d 309c 	movw	r0, #56220	; 0xdb9c
 8008e1c:	2164      	movs	r1, #100	; 0x64
 8008e1e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008e22:	f00c fd21 	bl	8015868 <assert_failed>
 8008e26:	e7c1      	b.n	8008dac <HAL_I2CEx_ConfigAnalogFilter+0x44>

08008e28 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8008e28:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpreg;

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008e2a:	f44f 43a8 	mov.w	r3, #21504	; 0x5400
{
 8008e2e:	4604      	mov	r4, r0
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008e30:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
 8008e34:	f44f 40b8 	mov.w	r0, #23552	; 0x5c00
 8008e38:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8008e3c:	6822      	ldr	r2, [r4, #0]
 8008e3e:	f2c4 0500 	movt	r5, #16384	; 0x4000
 8008e42:	f2c4 0000 	movt	r0, #16384	; 0x4000
{
 8008e46:	460e      	mov	r6, r1
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008e48:	429a      	cmp	r2, r3
 8008e4a:	bf18      	it	ne
 8008e4c:	42aa      	cmpne	r2, r5
 8008e4e:	bf14      	ite	ne
 8008e50:	2301      	movne	r3, #1
 8008e52:	2300      	moveq	r3, #0
 8008e54:	4282      	cmp	r2, r0
 8008e56:	bf0c      	ite	eq
 8008e58:	2300      	moveq	r3, #0
 8008e5a:	f003 0301 	andne.w	r3, r3, #1
 8008e5e:	b12b      	cbz	r3, 8008e6c <HAL_I2CEx_ConfigDigitalFilter+0x44>
 8008e60:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8008e64:	f6c5 0300 	movt	r3, #22528	; 0x5800
 8008e68:	429a      	cmp	r2, r3
 8008e6a:	d132      	bne.n	8008ed2 <HAL_I2CEx_ConfigDigitalFilter+0xaa>
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8008e6c:	2e0f      	cmp	r6, #15
 8008e6e:	d828      	bhi.n	8008ec2 <HAL_I2CEx_ConfigDigitalFilter+0x9a>

  if (hi2c->State == HAL_I2C_STATE_READY)
 8008e70:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 8008e74:	b2db      	uxtb	r3, r3
 8008e76:	2b20      	cmp	r3, #32
 8008e78:	d121      	bne.n	8008ebe <HAL_I2CEx_ConfigDigitalFilter+0x96>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8008e7a:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 8008e7e:	2a01      	cmp	r2, #1
 8008e80:	d01d      	beq.n	8008ebe <HAL_I2CEx_ConfigDigitalFilter+0x96>

    hi2c->State = HAL_I2C_STATE_BUSY;

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8008e82:	6821      	ldr	r1, [r4, #0]
    __HAL_LOCK(hi2c);
 8008e84:	2001      	movs	r0, #1
    hi2c->State = HAL_I2C_STATE_BUSY;
 8008e86:	2224      	movs	r2, #36	; 0x24
    __HAL_I2C_ENABLE(hi2c);

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8008e88:	2500      	movs	r5, #0
    __HAL_LOCK(hi2c);
 8008e8a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->State = HAL_I2C_STATE_BUSY;
 8008e8e:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41

    return HAL_OK;
 8008e92:	4628      	mov	r0, r5
    __HAL_I2C_DISABLE(hi2c);
 8008e94:	680a      	ldr	r2, [r1, #0]
 8008e96:	f022 0201 	bic.w	r2, r2, #1
 8008e9a:	600a      	str	r2, [r1, #0]
    tmpreg = hi2c->Instance->CR1;
 8008e9c:	6822      	ldr	r2, [r4, #0]
 8008e9e:	6811      	ldr	r1, [r2, #0]
    tmpreg &= ~(I2C_CR1_DNF);
 8008ea0:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
    tmpreg |= DigitalFilter << 8U;
 8008ea4:	ea41 2106 	orr.w	r1, r1, r6, lsl #8
    hi2c->Instance->CR1 = tmpreg;
 8008ea8:	6011      	str	r1, [r2, #0]
    __HAL_I2C_ENABLE(hi2c);
 8008eaa:	6821      	ldr	r1, [r4, #0]
 8008eac:	680a      	ldr	r2, [r1, #0]
 8008eae:	f042 0201 	orr.w	r2, r2, #1
 8008eb2:	600a      	str	r2, [r1, #0]
    hi2c->State = HAL_I2C_STATE_READY;
 8008eb4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8008eb8:	f884 5040 	strb.w	r5, [r4, #64]	; 0x40
  }
  else
  {
    return HAL_BUSY;
  }
}
 8008ebc:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 8008ebe:	2002      	movs	r0, #2
}
 8008ec0:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));
 8008ec2:	f64d 309c 	movw	r0, #56220	; 0xdb9c
 8008ec6:	2193      	movs	r1, #147	; 0x93
 8008ec8:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008ecc:	f00c fccc 	bl	8015868 <assert_failed>
 8008ed0:	e7ce      	b.n	8008e70 <HAL_I2CEx_ConfigDigitalFilter+0x48>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
 8008ed2:	f64d 309c 	movw	r0, #56220	; 0xdb9c
 8008ed6:	2192      	movs	r1, #146	; 0x92
 8008ed8:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008edc:	f00c fcc4 	bl	8015868 <assert_failed>
 8008ee0:	e7c4      	b.n	8008e6c <HAL_I2CEx_ConfigDigitalFilter+0x44>
 8008ee2:	bf00      	nop

08008ee4 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8008ee4:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8008ee6:	1e43      	subs	r3, r0, #1
{
 8008ee8:	4604      	mov	r4, r0
  assert_param (IS_PWR_SUPPLY (SupplySource));
 8008eea:	2b01      	cmp	r3, #1
 8008eec:	d907      	bls.n	8008efe <HAL_PWREx_ConfigSupply+0x1a>
 8008eee:	f64d 30d8 	movw	r0, #56280	; 0xdbd8
 8008ef2:	f44f 719d 	mov.w	r1, #314	; 0x13a
 8008ef6:	f6c0 0002 	movt	r0, #2050	; 0x802
 8008efa:	f00c fcb5 	bl	8015868 <assert_failed>

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8008efe:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8008f02:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8008f06:	68da      	ldr	r2, [r3, #12]
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8008f08:	68d8      	ldr	r0, [r3, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8008f0a:	0752      	lsls	r2, r2, #29
 8008f0c:	d405      	bmi.n	8008f1a <HAL_PWREx_ConfigSupply+0x36>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8008f0e:	f000 0007 	and.w	r0, r0, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8008f12:	1b00      	subs	r0, r0, r4
 8008f14:	bf18      	it	ne
 8008f16:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 8008f18:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8008f1a:	f020 0007 	bic.w	r0, r0, #7
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8008f1e:	461d      	mov	r5, r3
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8008f20:	4320      	orrs	r0, r4
 8008f22:	60d8      	str	r0, [r3, #12]
  tickstart = HAL_GetTick ();
 8008f24:	f7f7 fd8a 	bl	8000a3c <HAL_GetTick>
 8008f28:	4604      	mov	r4, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8008f2a:	e005      	b.n	8008f38 <HAL_PWREx_ConfigSupply+0x54>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8008f2c:	f7f7 fd86 	bl	8000a3c <HAL_GetTick>
 8008f30:	1b00      	subs	r0, r0, r4
 8008f32:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8008f36:	d804      	bhi.n	8008f42 <HAL_PWREx_ConfigSupply+0x5e>
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8008f38:	686b      	ldr	r3, [r5, #4]
 8008f3a:	049b      	lsls	r3, r3, #18
 8008f3c:	d5f6      	bpl.n	8008f2c <HAL_PWREx_ConfigSupply+0x48>
  return HAL_OK;
 8008f3e:	2000      	movs	r0, #0
}
 8008f40:	bd38      	pop	{r3, r4, r5, pc}
      return HAL_ERROR;
 8008f42:	2001      	movs	r0, #1
}
 8008f44:	bd38      	pop	{r3, r4, r5, pc}
 8008f46:	bf00      	nop

08008f48 <HAL_PWREx_EnableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_EnableUSBVoltageDetector (void)
{
  /* Enable the USB voltage detector */
  SET_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8008f48:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8008f4c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8008f50:	68da      	ldr	r2, [r3, #12]
 8008f52:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8008f56:	60da      	str	r2, [r3, #12]
}
 8008f58:	4770      	bx	lr
 8008f5a:	bf00      	nop

08008f5c <HAL_PWREx_DisableUSBVoltageDetector>:
  * @retval None.
  */
void HAL_PWREx_DisableUSBVoltageDetector (void)
{
  /* Disable the USB voltage detector */
  CLEAR_BIT (PWR->CR3, PWR_CR3_USB33DEN);
 8008f5c:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8008f60:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8008f64:	68da      	ldr	r2, [r3, #12]
 8008f66:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8008f6a:	60da      	str	r2, [r3, #12]
}
 8008f6c:	4770      	bx	lr
 8008f6e:	bf00      	nop

08008f70 <HAL_RCC_OscConfig>:
{
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8008f70:	2800      	cmp	r0, #0
 8008f72:	f000 8287 	beq.w	8009484 <HAL_RCC_OscConfig+0x514>
{
 8008f76:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  {
    return HAL_ERROR;
  }

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8008f78:	6803      	ldr	r3, [r0, #0]
 8008f7a:	4604      	mov	r4, r0
 8008f7c:	2b00      	cmp	r3, #0
 8008f7e:	f000 80c1 	beq.w	8009104 <HAL_RCC_OscConfig+0x194>
 8008f82:	0698      	lsls	r0, r3, #26
 8008f84:	f000 8265 	beq.w	8009452 <HAL_RCC_OscConfig+0x4e2>
  /*------------------------------- HSE Configuration ------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8008f88:	07d9      	lsls	r1, r3, #31
 8008f8a:	d53f      	bpl.n	800900c <HAL_RCC_OscConfig+0x9c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 8008f8c:	6863      	ldr	r3, [r4, #4]
 8008f8e:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 8008f92:	d003      	beq.n	8008f9c <HAL_RCC_OscConfig+0x2c>
 8008f94:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8008f98:	f040 8220 	bne.w	80093dc <HAL_RCC_OscConfig+0x46c>

    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8008f9c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8008fa0:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8008fa4:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8008fa6:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8008fa8:	f003 0338 	and.w	r3, r3, #56	; 0x38
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8008fac:	2b10      	cmp	r3, #16
 8008fae:	f000 822d 	beq.w	800940c <HAL_RCC_OscConfig+0x49c>
 8008fb2:	2b18      	cmp	r3, #24
 8008fb4:	f000 8225 	beq.w	8009402 <HAL_RCC_OscConfig+0x492>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8008fb8:	6863      	ldr	r3, [r4, #4]
 8008fba:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8008fbe:	f000 8233 	beq.w	8009428 <HAL_RCC_OscConfig+0x4b8>
 8008fc2:	2b00      	cmp	r3, #0
 8008fc4:	f040 82c1 	bne.w	800954a <HAL_RCC_OscConfig+0x5da>
 8008fc8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8008fcc:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8008fd0:	681a      	ldr	r2, [r3, #0]
 8008fd2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8008fd6:	601a      	str	r2, [r3, #0]
 8008fd8:	681a      	ldr	r2, [r3, #0]
 8008fda:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8008fde:	601a      	str	r2, [r3, #0]

      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8008fe0:	6863      	ldr	r3, [r4, #4]
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSE is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008fe2:	f44f 4588 	mov.w	r5, #17408	; 0x4400
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8008fe6:	2b00      	cmp	r3, #0
 8008fe8:	f000 823d 	beq.w	8009466 <HAL_RCC_OscConfig+0x4f6>
        tickstart = HAL_GetTick();
 8008fec:	f7f7 fd26 	bl	8000a3c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008ff0:	f6c5 0502 	movt	r5, #22530	; 0x5802
        tickstart = HAL_GetTick();
 8008ff4:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8008ff6:	e005      	b.n	8009004 <HAL_RCC_OscConfig+0x94>
        {
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8008ff8:	f7f7 fd20 	bl	8000a3c <HAL_GetTick>
 8008ffc:	1b80      	subs	r0, r0, r6
 8008ffe:	2864      	cmp	r0, #100	; 0x64
 8009000:	f200 8225 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8009004:	682b      	ldr	r3, [r5, #0]
 8009006:	039b      	lsls	r3, r3, #14
 8009008:	d5f6      	bpl.n	8008ff8 <HAL_RCC_OscConfig+0x88>
 800900a:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 800900c:	0798      	lsls	r0, r3, #30
 800900e:	d537      	bpl.n	8009080 <HAL_RCC_OscConfig+0x110>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 8009010:	68e2      	ldr	r2, [r4, #12]
 8009012:	2a19      	cmp	r2, #25
 8009014:	f200 82e5 	bhi.w	80095e2 <HAL_RCC_OscConfig+0x672>
 8009018:	f240 2303 	movw	r3, #515	; 0x203
 800901c:	f2c0 2302 	movt	r3, #514	; 0x202
 8009020:	40d3      	lsrs	r3, r2
 8009022:	07d9      	lsls	r1, r3, #31
 8009024:	f140 82dd 	bpl.w	80095e2 <HAL_RCC_OscConfig+0x672>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 8009028:	6923      	ldr	r3, [r4, #16]
 800902a:	2b7f      	cmp	r3, #127	; 0x7f
 800902c:	f200 81cd 	bhi.w	80093ca <HAL_RCC_OscConfig+0x45a>

    /* When the HSI is used as system clock it will not be disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8009030:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009034:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009038:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 800903a:	6a92      	ldr	r2, [r2, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 800903c:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 8009040:	f040 8196 	bne.w	8009370 <HAL_RCC_OscConfig+0x400>
    {
      /* When HSI is used as system clock it will not be disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8009044:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009048:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800904c:	681b      	ldr	r3, [r3, #0]
 800904e:	075b      	lsls	r3, r3, #29
 8009050:	d503      	bpl.n	800905a <HAL_RCC_OscConfig+0xea>
 8009052:	68e3      	ldr	r3, [r4, #12]
 8009054:	2b00      	cmp	r3, #0
 8009056:	f000 81e5 	beq.w	8009424 <HAL_RCC_OscConfig+0x4b4>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800905a:	f7f7 fd09 	bl	8000a70 <HAL_GetREVID>
 800905e:	f241 0303 	movw	r3, #4099	; 0x1003
 8009062:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009066:	6921      	ldr	r1, [r4, #16]
 8009068:	4298      	cmp	r0, r3
 800906a:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800906e:	6853      	ldr	r3, [r2, #4]
 8009070:	f200 82ac 	bhi.w	80095cc <HAL_RCC_OscConfig+0x65c>
 8009074:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 8009078:	ea43 3301 	orr.w	r3, r3, r1, lsl #12
 800907c:	6053      	str	r3, [r2, #4]
 800907e:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*----------------------------- CSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 8009080:	06d9      	lsls	r1, r3, #27
 8009082:	d53f      	bpl.n	8009104 <HAL_RCC_OscConfig+0x194>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 8009084:	69e3      	ldr	r3, [r4, #28]
 8009086:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800908a:	f040 823f 	bne.w	800950c <HAL_RCC_OscConfig+0x59c>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 800908e:	6a23      	ldr	r3, [r4, #32]
 8009090:	2b3f      	cmp	r3, #63	; 0x3f
 8009092:	f200 8232 	bhi.w	80094fa <HAL_RCC_OscConfig+0x58a>

    /* When the CSI is used as system clock it will not disabled */
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8009096:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800909a:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800909e:	6913      	ldr	r3, [r2, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 80090a0:	6a92      	ldr	r2, [r2, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80090a2:	f003 0338 	and.w	r3, r3, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 80090a6:	2b08      	cmp	r3, #8
 80090a8:	f000 81f3 	beq.w	8009492 <HAL_RCC_OscConfig+0x522>
 80090ac:	2b18      	cmp	r3, #24
 80090ae:	f000 81eb 	beq.w	8009488 <HAL_RCC_OscConfig+0x518>
      }
    }
    else
    {
      /* Check the CSI State */
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 80090b2:	69e3      	ldr	r3, [r4, #28]
 80090b4:	2b00      	cmp	r3, #0
 80090b6:	f000 8259 	beq.w	800956c <HAL_RCC_OscConfig+0x5fc>
      {
        /* Enable the Internal High Speed oscillator (CSI). */
        __HAL_RCC_CSI_ENABLE();
 80090ba:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80090be:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80090c2:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till CSI is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80090c4:	461d      	mov	r5, r3
        __HAL_RCC_CSI_ENABLE();
 80090c6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80090ca:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80090cc:	f7f7 fcb6 	bl	8000a3c <HAL_GetTick>
 80090d0:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80090d2:	e005      	b.n	80090e0 <HAL_RCC_OscConfig+0x170>
        {
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 80090d4:	f7f7 fcb2 	bl	8000a3c <HAL_GetTick>
 80090d8:	1b80      	subs	r0, r0, r6
 80090da:	2802      	cmp	r0, #2
 80090dc:	f200 81b7 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80090e0:	682b      	ldr	r3, [r5, #0]
 80090e2:	05db      	lsls	r3, r3, #23
 80090e4:	d5f6      	bpl.n	80090d4 <HAL_RCC_OscConfig+0x164>
            return HAL_TIMEOUT;
          }
        }

        /* Adjusts the Internal High Speed oscillator (CSI) calibration value.*/
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80090e6:	f7f7 fcc3 	bl	8000a70 <HAL_GetREVID>
 80090ea:	f241 0303 	movw	r3, #4099	; 0x1003
 80090ee:	4298      	cmp	r0, r3
 80090f0:	f200 8307 	bhi.w	8009702 <HAL_RCC_OscConfig+0x792>
 80090f4:	686b      	ldr	r3, [r5, #4]
 80090f6:	6a22      	ldr	r2, [r4, #32]
 80090f8:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80090fc:	ea43 6382 	orr.w	r3, r3, r2, lsl #26
 8009100:	606b      	str	r3, [r5, #4]
 8009102:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8009104:	071d      	lsls	r5, r3, #28
 8009106:	d51d      	bpl.n	8009144 <HAL_RCC_OscConfig+0x1d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 8009108:	6963      	ldr	r3, [r4, #20]
 800910a:	2b01      	cmp	r3, #1
 800910c:	f200 816f 	bhi.w	80093ee <HAL_RCC_OscConfig+0x47e>

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8009110:	2b00      	cmp	r3, #0
 8009112:	f000 81dc 	beq.w	80094ce <HAL_RCC_OscConfig+0x55e>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8009116:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800911a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800911e:	6f5a      	ldr	r2, [r3, #116]	; 0x74

      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8009120:	461d      	mov	r5, r3
      __HAL_RCC_LSI_ENABLE();
 8009122:	f042 0201 	orr.w	r2, r2, #1
 8009126:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 8009128:	f7f7 fc88 	bl	8000a3c <HAL_GetTick>
 800912c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800912e:	e005      	b.n	800913c <HAL_RCC_OscConfig+0x1cc>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8009130:	f7f7 fc84 	bl	8000a3c <HAL_GetTick>
 8009134:	1b80      	subs	r0, r0, r6
 8009136:	2802      	cmp	r0, #2
 8009138:	f200 8189 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 800913c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800913e:	0798      	lsls	r0, r3, #30
 8009140:	d5f6      	bpl.n	8009130 <HAL_RCC_OscConfig+0x1c0>
 8009142:	6823      	ldr	r3, [r4, #0]
      }
    }
  }

  /*------------------------------ HSI48 Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8009144:	069a      	lsls	r2, r3, #26
 8009146:	d51d      	bpl.n	8009184 <HAL_RCC_OscConfig+0x214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 8009148:	69a3      	ldr	r3, [r4, #24]
 800914a:	2b01      	cmp	r3, #1
 800914c:	f200 8175 	bhi.w	800943a <HAL_RCC_OscConfig+0x4ca>

    /* Check the HSI48 State */
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 8009150:	2b00      	cmp	r3, #0
 8009152:	f000 81e4 	beq.w	800951e <HAL_RCC_OscConfig+0x5ae>
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8009156:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800915a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800915e:	681a      	ldr	r2, [r3, #0]

      /* Get time-out */
      tickstart = HAL_GetTick();

      /* Wait till HSI48 is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8009160:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_ENABLE();
 8009162:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009166:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8009168:	f7f7 fc68 	bl	8000a3c <HAL_GetTick>
 800916c:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800916e:	e005      	b.n	800917c <HAL_RCC_OscConfig+0x20c>
      {
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 8009170:	f7f7 fc64 	bl	8000a3c <HAL_GetTick>
 8009174:	1b80      	subs	r0, r0, r6
 8009176:	2802      	cmp	r0, #2
 8009178:	f200 8169 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 800917c:	682b      	ldr	r3, [r5, #0]
 800917e:	049f      	lsls	r7, r3, #18
 8009180:	d5f6      	bpl.n	8009170 <HAL_RCC_OscConfig+0x200>
 8009182:	6823      	ldr	r3, [r4, #0]
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8009184:	0759      	lsls	r1, r3, #29
 8009186:	d545      	bpl.n	8009214 <HAL_RCC_OscConfig+0x2a4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8009188:	68a3      	ldr	r3, [r4, #8]
 800918a:	2b01      	cmp	r3, #1
 800918c:	d902      	bls.n	8009194 <HAL_RCC_OscConfig+0x224>
 800918e:	2b05      	cmp	r3, #5
 8009190:	f040 823a 	bne.w	8009608 <HAL_RCC_OscConfig+0x698>

    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 8009194:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 8009198:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800919c:	681a      	ldr	r2, [r3, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800919e:	461d      	mov	r5, r3
    PWR->CR1 |= PWR_CR1_DBP;
 80091a0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80091a4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 80091a6:	f7f7 fc49 	bl	8000a3c <HAL_GetTick>
 80091aa:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80091ac:	e005      	b.n	80091ba <HAL_RCC_OscConfig+0x24a>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80091ae:	f7f7 fc45 	bl	8000a3c <HAL_GetTick>
 80091b2:	1b80      	subs	r0, r0, r6
 80091b4:	2864      	cmp	r0, #100	; 0x64
 80091b6:	f200 814a 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80091ba:	682b      	ldr	r3, [r5, #0]
 80091bc:	05da      	lsls	r2, r3, #23
 80091be:	d5f6      	bpl.n	80091ae <HAL_RCC_OscConfig+0x23e>
        return HAL_TIMEOUT;
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80091c0:	68a3      	ldr	r3, [r4, #8]
 80091c2:	2b01      	cmp	r3, #1
 80091c4:	f000 825f 	beq.w	8009686 <HAL_RCC_OscConfig+0x716>
 80091c8:	2b00      	cmp	r3, #0
 80091ca:	f040 828a 	bne.w	80096e2 <HAL_RCC_OscConfig+0x772>
 80091ce:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80091d2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80091d6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80091d8:	f022 0201 	bic.w	r2, r2, #1
 80091dc:	671a      	str	r2, [r3, #112]	; 0x70
 80091de:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80091e0:	f022 0204 	bic.w	r2, r2, #4
 80091e4:	671a      	str	r2, [r3, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80091e6:	68a3      	ldr	r3, [r4, #8]
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();

      /* Wait till LSE is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80091e8:	f44f 4588 	mov.w	r5, #17408	; 0x4400
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 80091ec:	2b00      	cmp	r3, #0
 80091ee:	f000 8253 	beq.w	8009698 <HAL_RCC_OscConfig+0x728>
      tickstart = HAL_GetTick();
 80091f2:	f7f7 fc23 	bl	8000a3c <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 80091f6:	f6c5 0502 	movt	r5, #22530	; 0x5802
      tickstart = HAL_GetTick();
 80091fa:	4607      	mov	r7, r0
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80091fc:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8009200:	e005      	b.n	800920e <HAL_RCC_OscConfig+0x29e>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8009202:	f7f7 fc1b 	bl	8000a3c <HAL_GetTick>
 8009206:	1bc0      	subs	r0, r0, r7
 8009208:	42b0      	cmp	r0, r6
 800920a:	f200 8120 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800920e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8009210:	079b      	lsls	r3, r3, #30
 8009212:	d5f6      	bpl.n	8009202 <HAL_RCC_OscConfig+0x292>
      }
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 8009214:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8009216:	2802      	cmp	r0, #2
 8009218:	f200 81ec 	bhi.w	80095f4 <HAL_RCC_OscConfig+0x684>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 800921c:	2800      	cmp	r0, #0
 800921e:	f000 80a5 	beq.w	800936c <HAL_RCC_OscConfig+0x3fc>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8009222:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009226:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800922a:	691a      	ldr	r2, [r3, #16]
 800922c:	f002 0238 	and.w	r2, r2, #56	; 0x38
 8009230:	2a18      	cmp	r2, #24
 8009232:	f000 81fa 	beq.w	800962a <HAL_RCC_OscConfig+0x6ba>
    {
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8009236:	2802      	cmp	r0, #2
 8009238:	f040 8240 	bne.w	80096bc <HAL_RCC_OscConfig+0x74c>
      {
        /* Check the parameters */
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800923c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800923e:	2b03      	cmp	r3, #3
 8009240:	f200 82a5 	bhi.w	800978e <HAL_RCC_OscConfig+0x81e>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 8009244:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009246:	3b01      	subs	r3, #1
 8009248:	2b3e      	cmp	r3, #62	; 0x3e
 800924a:	f200 8273 	bhi.w	8009734 <HAL_RCC_OscConfig+0x7c4>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 800924e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8009250:	3b04      	subs	r3, #4
 8009252:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8009256:	f200 8264 	bhi.w	8009722 <HAL_RCC_OscConfig+0x7b2>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 800925a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800925c:	3b01      	subs	r3, #1
 800925e:	2b7f      	cmp	r3, #127	; 0x7f
 8009260:	f200 828c 	bhi.w	800977c <HAL_RCC_OscConfig+0x80c>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 8009264:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009266:	3b01      	subs	r3, #1
 8009268:	2b7f      	cmp	r3, #127	; 0x7f
 800926a:	f200 827e 	bhi.w	800976a <HAL_RCC_OscConfig+0x7fa>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 800926e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8009270:	3b01      	subs	r3, #1
 8009272:	2b7f      	cmp	r3, #127	; 0x7f
 8009274:	f200 8270 	bhi.w	8009758 <HAL_RCC_OscConfig+0x7e8>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 8009278:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800927a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800927e:	f080 8262 	bcs.w	8009746 <HAL_RCC_OscConfig+0x7d6>

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8009282:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009286:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800928a:	681a      	ldr	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800928c:	461d      	mov	r5, r3
        __HAL_RCC_PLL_DISABLE();
 800928e:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8009292:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8009294:	f7f7 fbd2 	bl	8000a3c <HAL_GetTick>
 8009298:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800929a:	e005      	b.n	80092a8 <HAL_RCC_OscConfig+0x338>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800929c:	f7f7 fbce 	bl	8000a3c <HAL_GetTick>
 80092a0:	1b80      	subs	r0, r0, r6
 80092a2:	2802      	cmp	r0, #2
 80092a4:	f200 80d3 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80092a8:	682b      	ldr	r3, [r5, #0]
 80092aa:	0199      	lsls	r1, r3, #6
 80092ac:	d4f6      	bmi.n	800929c <HAL_RCC_OscConfig+0x32c>
            return HAL_TIMEOUT;
          }
        }

        /* Configure the main PLL clock source, multiplication and division factors. */
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80092ae:	f64f 430c 	movw	r3, #64524	; 0xfc0c
 80092b2:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 80092b4:	6aa0      	ldr	r0, [r4, #40]	; 0x28

         /* Disable PLLFRACN . */
         __HAL_RCC_PLLFRACN_DISABLE();

         /* Configure PLL PLL1FRACN */
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 80092b6:	2207      	movs	r2, #7
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80092b8:	f6cf 73ff 	movt	r3, #65535	; 0xffff

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till PLL is ready */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80092bc:	f44f 4688 	mov.w	r6, #17408	; 0x4400
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 80092c0:	f6cf 72ff 	movt	r2, #65535	; 0xffff
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80092c4:	400b      	ands	r3, r1
 80092c6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80092c8:	f6c5 0602 	movt	r6, #22530	; 0x5802
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80092cc:	4303      	orrs	r3, r0
 80092ce:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
 80092d2:	62ab      	str	r3, [r5, #40]	; 0x28
 80092d4:	6b27      	ldr	r7, [r4, #48]	; 0x30
 80092d6:	e9d4 310d 	ldrd	r3, r1, [r4, #52]	; 0x34
 80092da:	3f01      	subs	r7, #1
 80092dc:	1e48      	subs	r0, r1, #1
 80092de:	3b01      	subs	r3, #1
 80092e0:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80092e2:	f3c7 0708 	ubfx	r7, r7, #0, #9
 80092e6:	025b      	lsls	r3, r3, #9
 80092e8:	0400      	lsls	r0, r0, #16
 80092ea:	3901      	subs	r1, #1
 80092ec:	b29b      	uxth	r3, r3
 80092ee:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 80092f2:	0609      	lsls	r1, r1, #24
 80092f4:	4303      	orrs	r3, r0
 80092f6:	f001 41fe 	and.w	r1, r1, #2130706432	; 0x7f000000
 80092fa:	433b      	orrs	r3, r7
 80092fc:	430b      	orrs	r3, r1
 80092fe:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
 8009300:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009302:	f023 0301 	bic.w	r3, r3, #1
 8009306:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 8009308:	6b69      	ldr	r1, [r5, #52]	; 0x34
 800930a:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800930c:	400a      	ands	r2, r1
 800930e:	ea42 02c3 	orr.w	r2, r2, r3, lsl #3
 8009312:	636a      	str	r2, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 8009314:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009316:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8009318:	f023 030c 	bic.w	r3, r3, #12
 800931c:	4313      	orrs	r3, r2
 800931e:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 8009320:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009322:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8009324:	f023 0302 	bic.w	r3, r3, #2
 8009328:	4313      	orrs	r3, r2
 800932a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 800932c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800932e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8009332:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8009334:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009336:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800933a:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 800933c:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800933e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8009342:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
 8009344:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8009346:	f043 0301 	orr.w	r3, r3, #1
 800934a:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
 800934c:	682b      	ldr	r3, [r5, #0]
 800934e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8009352:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8009354:	f7f7 fb72 	bl	8000a3c <HAL_GetTick>
 8009358:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 800935a:	e004      	b.n	8009366 <HAL_RCC_OscConfig+0x3f6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 800935c:	f7f7 fb6e 	bl	8000a3c <HAL_GetTick>
 8009360:	1b00      	subs	r0, r0, r4
 8009362:	2802      	cmp	r0, #2
 8009364:	d873      	bhi.n	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8009366:	6833      	ldr	r3, [r6, #0]
 8009368:	019a      	lsls	r2, r3, #6
 800936a:	d5f7      	bpl.n	800935c <HAL_RCC_OscConfig+0x3ec>
      {
        return HAL_ERROR;
      }
    }
  }
  return HAL_OK;
 800936c:	2000      	movs	r0, #0
}
 800936e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 8009370:	2b18      	cmp	r3, #24
 8009372:	f000 8132 	beq.w	80095da <HAL_RCC_OscConfig+0x66a>
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8009376:	68e2      	ldr	r2, [r4, #12]
 8009378:	2a00      	cmp	r2, #0
 800937a:	f000 810f 	beq.w	800959c <HAL_RCC_OscConfig+0x62c>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800937e:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8009382:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8009386:	680b      	ldr	r3, [r1, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009388:	460d      	mov	r5, r1
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800938a:	f023 0319 	bic.w	r3, r3, #25
 800938e:	4313      	orrs	r3, r2
 8009390:	600b      	str	r3, [r1, #0]
        tickstart = HAL_GetTick();
 8009392:	f7f7 fb53 	bl	8000a3c <HAL_GetTick>
 8009396:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009398:	e004      	b.n	80093a4 <HAL_RCC_OscConfig+0x434>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800939a:	f7f7 fb4f 	bl	8000a3c <HAL_GetTick>
 800939e:	1b80      	subs	r0, r0, r6
 80093a0:	2802      	cmp	r0, #2
 80093a2:	d854      	bhi.n	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 80093a4:	682b      	ldr	r3, [r5, #0]
 80093a6:	075f      	lsls	r7, r3, #29
 80093a8:	d5f7      	bpl.n	800939a <HAL_RCC_OscConfig+0x42a>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80093aa:	f7f7 fb61 	bl	8000a70 <HAL_GetREVID>
 80093ae:	f241 0303 	movw	r3, #4099	; 0x1003
 80093b2:	6922      	ldr	r2, [r4, #16]
 80093b4:	4298      	cmp	r0, r3
 80093b6:	686b      	ldr	r3, [r5, #4]
 80093b8:	f200 81ac 	bhi.w	8009714 <HAL_RCC_OscConfig+0x7a4>
 80093bc:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 80093c0:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 80093c4:	606b      	str	r3, [r5, #4]
 80093c6:	6823      	ldr	r3, [r4, #0]
 80093c8:	e65a      	b.n	8009080 <HAL_RCC_OscConfig+0x110>
    assert_param(IS_RCC_HSICALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
 80093ca:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80093ce:	f44f 71ec 	mov.w	r1, #472	; 0x1d8
 80093d2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80093d6:	f00c fa47 	bl	8015868 <assert_failed>
 80093da:	e629      	b.n	8009030 <HAL_RCC_OscConfig+0xc0>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
 80093dc:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80093e0:	f240 11a3 	movw	r1, #419	; 0x1a3
 80093e4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80093e8:	f00c fa3e 	bl	8015868 <assert_failed>
 80093ec:	e5d6      	b.n	8008f9c <HAL_RCC_OscConfig+0x2c>
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));
 80093ee:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80093f2:	f44f 7117 	mov.w	r1, #604	; 0x25c
 80093f6:	f6c0 0002 	movt	r0, #2050	; 0x802
 80093fa:	f00c fa35 	bl	8015868 <assert_failed>
 80093fe:	6963      	ldr	r3, [r4, #20]
 8009400:	e686      	b.n	8009110 <HAL_RCC_OscConfig+0x1a0>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8009402:	f002 0203 	and.w	r2, r2, #3
 8009406:	2a02      	cmp	r2, #2
 8009408:	f47f add6 	bne.w	8008fb8 <HAL_RCC_OscConfig+0x48>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800940c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009410:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009414:	681b      	ldr	r3, [r3, #0]
 8009416:	039a      	lsls	r2, r3, #14
 8009418:	f57f adf7 	bpl.w	800900a <HAL_RCC_OscConfig+0x9a>
 800941c:	6863      	ldr	r3, [r4, #4]
 800941e:	2b00      	cmp	r3, #0
 8009420:	f47f adf3 	bne.w	800900a <HAL_RCC_OscConfig+0x9a>
        return HAL_ERROR;
 8009424:	2001      	movs	r0, #1
}
 8009426:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8009428:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800942c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009430:	681a      	ldr	r2, [r3, #0]
 8009432:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009436:	601a      	str	r2, [r3, #0]
 8009438:	e5d2      	b.n	8008fe0 <HAL_RCC_OscConfig+0x70>
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));
 800943a:	f64d 4014 	movw	r0, #56340	; 0xdc14
 800943e:	f240 2187 	movw	r1, #647	; 0x287
 8009442:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009446:	f00c fa0f 	bl	8015868 <assert_failed>
 800944a:	69a3      	ldr	r3, [r4, #24]
 800944c:	e680      	b.n	8009150 <HAL_RCC_OscConfig+0x1e0>
            return HAL_TIMEOUT;
 800944e:	2003      	movs	r0, #3
}
 8009450:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
 8009452:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009456:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 800945a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800945e:	f00c fa03 	bl	8015868 <assert_failed>
 8009462:	6823      	ldr	r3, [r4, #0]
 8009464:	e590      	b.n	8008f88 <HAL_RCC_OscConfig+0x18>
        tickstart = HAL_GetTick();
 8009466:	f7f7 fae9 	bl	8000a3c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800946a:	f6c5 0502 	movt	r5, #22530	; 0x5802
        tickstart = HAL_GetTick();
 800946e:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 8009470:	e004      	b.n	800947c <HAL_RCC_OscConfig+0x50c>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8009472:	f7f7 fae3 	bl	8000a3c <HAL_GetTick>
 8009476:	1b80      	subs	r0, r0, r6
 8009478:	2864      	cmp	r0, #100	; 0x64
 800947a:	d8e8      	bhi.n	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800947c:	682b      	ldr	r3, [r5, #0]
 800947e:	039f      	lsls	r7, r3, #14
 8009480:	d4f7      	bmi.n	8009472 <HAL_RCC_OscConfig+0x502>
 8009482:	e5c2      	b.n	800900a <HAL_RCC_OscConfig+0x9a>
    return HAL_ERROR;
 8009484:	2001      	movs	r0, #1
}
 8009486:	4770      	bx	lr
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8009488:	f002 0203 	and.w	r2, r2, #3
 800948c:	2a01      	cmp	r2, #1
 800948e:	f47f ae10 	bne.w	80090b2 <HAL_RCC_OscConfig+0x142>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 8009492:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009496:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800949a:	681b      	ldr	r3, [r3, #0]
 800949c:	05da      	lsls	r2, r3, #23
 800949e:	d502      	bpl.n	80094a6 <HAL_RCC_OscConfig+0x536>
 80094a0:	69e3      	ldr	r3, [r4, #28]
 80094a2:	2b80      	cmp	r3, #128	; 0x80
 80094a4:	d1be      	bne.n	8009424 <HAL_RCC_OscConfig+0x4b4>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80094a6:	f7f7 fae3 	bl	8000a70 <HAL_GetREVID>
 80094aa:	f241 0303 	movw	r3, #4099	; 0x1003
 80094ae:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80094b2:	6a21      	ldr	r1, [r4, #32]
 80094b4:	4298      	cmp	r0, r3
 80094b6:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80094ba:	f200 80ae 	bhi.w	800961a <HAL_RCC_OscConfig+0x6aa>
 80094be:	6853      	ldr	r3, [r2, #4]
 80094c0:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80094c4:	ea43 6381 	orr.w	r3, r3, r1, lsl #26
 80094c8:	6053      	str	r3, [r2, #4]
 80094ca:	6823      	ldr	r3, [r4, #0]
 80094cc:	e61a      	b.n	8009104 <HAL_RCC_OscConfig+0x194>
      __HAL_RCC_LSI_DISABLE();
 80094ce:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80094d2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80094d6:	6f5a      	ldr	r2, [r3, #116]	; 0x74
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80094d8:	461d      	mov	r5, r3
      __HAL_RCC_LSI_DISABLE();
 80094da:	f022 0201 	bic.w	r2, r2, #1
 80094de:	675a      	str	r2, [r3, #116]	; 0x74
      tickstart = HAL_GetTick();
 80094e0:	f7f7 faac 	bl	8000a3c <HAL_GetTick>
 80094e4:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80094e6:	e004      	b.n	80094f2 <HAL_RCC_OscConfig+0x582>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80094e8:	f7f7 faa8 	bl	8000a3c <HAL_GetTick>
 80094ec:	1b80      	subs	r0, r0, r6
 80094ee:	2802      	cmp	r0, #2
 80094f0:	d8ad      	bhi.n	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 80094f2:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 80094f4:	0799      	lsls	r1, r3, #30
 80094f6:	d4f7      	bmi.n	80094e8 <HAL_RCC_OscConfig+0x578>
 80094f8:	e623      	b.n	8009142 <HAL_RCC_OscConfig+0x1d2>
    assert_param(IS_RCC_CSICALIBRATION_VALUE(RCC_OscInitStruct->CSICalibrationValue));
 80094fa:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80094fe:	f240 211b 	movw	r1, #539	; 0x21b
 8009502:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009506:	f00c f9af 	bl	8015868 <assert_failed>
 800950a:	e5c4      	b.n	8009096 <HAL_RCC_OscConfig+0x126>
    assert_param(IS_RCC_CSI(RCC_OscInitStruct->CSIState));
 800950c:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009510:	f240 211a 	movw	r1, #538	; 0x21a
 8009514:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009518:	f00c f9a6 	bl	8015868 <assert_failed>
 800951c:	e5b7      	b.n	800908e <HAL_RCC_OscConfig+0x11e>
      __HAL_RCC_HSI48_DISABLE();
 800951e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009522:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009526:	681a      	ldr	r2, [r3, #0]
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8009528:	461d      	mov	r5, r3
      __HAL_RCC_HSI48_DISABLE();
 800952a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800952e:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8009530:	f7f7 fa84 	bl	8000a3c <HAL_GetTick>
 8009534:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8009536:	e004      	b.n	8009542 <HAL_RCC_OscConfig+0x5d2>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 8009538:	f7f7 fa80 	bl	8000a3c <HAL_GetTick>
 800953c:	1b80      	subs	r0, r0, r6
 800953e:	2802      	cmp	r0, #2
 8009540:	d885      	bhi.n	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 8009542:	682b      	ldr	r3, [r5, #0]
 8009544:	0498      	lsls	r0, r3, #18
 8009546:	d4f7      	bmi.n	8009538 <HAL_RCC_OscConfig+0x5c8>
 8009548:	e61b      	b.n	8009182 <HAL_RCC_OscConfig+0x212>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800954a:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 800954e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009552:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009556:	681a      	ldr	r2, [r3, #0]
 8009558:	f47f ad3b 	bne.w	8008fd2 <HAL_RCC_OscConfig+0x62>
 800955c:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8009560:	601a      	str	r2, [r3, #0]
 8009562:	681a      	ldr	r2, [r3, #0]
 8009564:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8009568:	601a      	str	r2, [r3, #0]
 800956a:	e539      	b.n	8008fe0 <HAL_RCC_OscConfig+0x70>
        __HAL_RCC_CSI_DISABLE();
 800956c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009570:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009574:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8009576:	461d      	mov	r5, r3
        __HAL_RCC_CSI_DISABLE();
 8009578:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 800957c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800957e:	f7f7 fa5d 	bl	8000a3c <HAL_GetTick>
 8009582:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8009584:	e005      	b.n	8009592 <HAL_RCC_OscConfig+0x622>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 8009586:	f7f7 fa59 	bl	8000a3c <HAL_GetTick>
 800958a:	1b80      	subs	r0, r0, r6
 800958c:	2802      	cmp	r0, #2
 800958e:	f63f af5e 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8009592:	682b      	ldr	r3, [r5, #0]
 8009594:	05df      	lsls	r7, r3, #23
 8009596:	d4f6      	bmi.n	8009586 <HAL_RCC_OscConfig+0x616>
 8009598:	6823      	ldr	r3, [r4, #0]
 800959a:	e5b3      	b.n	8009104 <HAL_RCC_OscConfig+0x194>
        __HAL_RCC_HSI_DISABLE();
 800959c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80095a0:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80095a4:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80095a6:	461d      	mov	r5, r3
        __HAL_RCC_HSI_DISABLE();
 80095a8:	f022 0201 	bic.w	r2, r2, #1
 80095ac:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80095ae:	f7f7 fa45 	bl	8000a3c <HAL_GetTick>
 80095b2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80095b4:	e005      	b.n	80095c2 <HAL_RCC_OscConfig+0x652>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80095b6:	f7f7 fa41 	bl	8000a3c <HAL_GetTick>
 80095ba:	1b80      	subs	r0, r0, r6
 80095bc:	2802      	cmp	r0, #2
 80095be:	f63f af46 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 80095c2:	682b      	ldr	r3, [r5, #0]
 80095c4:	0758      	lsls	r0, r3, #29
 80095c6:	d4f6      	bmi.n	80095b6 <HAL_RCC_OscConfig+0x646>
 80095c8:	6823      	ldr	r3, [r4, #0]
 80095ca:	e559      	b.n	8009080 <HAL_RCC_OscConfig+0x110>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80095cc:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80095d0:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 80095d4:	6053      	str	r3, [r2, #4]
 80095d6:	6823      	ldr	r3, [r4, #0]
 80095d8:	e552      	b.n	8009080 <HAL_RCC_OscConfig+0x110>
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 80095da:	0792      	lsls	r2, r2, #30
 80095dc:	f47f aecb 	bne.w	8009376 <HAL_RCC_OscConfig+0x406>
 80095e0:	e530      	b.n	8009044 <HAL_RCC_OscConfig+0xd4>
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
 80095e2:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80095e6:	f240 11d7 	movw	r1, #471	; 0x1d7
 80095ea:	f6c0 0002 	movt	r0, #2050	; 0x802
 80095ee:	f00c f93b 	bl	8015868 <assert_failed>
 80095f2:	e519      	b.n	8009028 <HAL_RCC_OscConfig+0xb8>
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
 80095f4:	f64d 4014 	movw	r0, #56340	; 0xdc14
 80095f8:	f240 21e3 	movw	r1, #739	; 0x2e3
 80095fc:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009600:	f00c f932 	bl	8015868 <assert_failed>
 8009604:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8009606:	e609      	b.n	800921c <HAL_RCC_OscConfig+0x2ac>
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
 8009608:	f64d 4014 	movw	r0, #56340	; 0xdc14
 800960c:	f240 21b1 	movw	r1, #689	; 0x2b1
 8009610:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009614:	f00c f928 	bl	8015868 <assert_failed>
 8009618:	e5bc      	b.n	8009194 <HAL_RCC_OscConfig+0x224>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 800961a:	68d3      	ldr	r3, [r2, #12]
 800961c:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 8009620:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8009624:	60d3      	str	r3, [r2, #12]
 8009626:	6823      	ldr	r3, [r4, #0]
 8009628:	e56c      	b.n	8009104 <HAL_RCC_OscConfig+0x194>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 800962a:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 800962c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 800962e:	6b1d      	ldr	r5, [r3, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8009630:	f43f ae9d 	beq.w	800936e <HAL_RCC_OscConfig+0x3fe>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8009634:	f002 0303 	and.w	r3, r2, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8009638:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800963a:	428b      	cmp	r3, r1
 800963c:	f47f aef2 	bne.w	8009424 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8009640:	f3c2 1205 	ubfx	r2, r2, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8009644:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8009646:	429a      	cmp	r2, r3
 8009648:	f47f aeec 	bne.w	8009424 <HAL_RCC_OscConfig+0x4b4>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800964c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800964e:	f3c5 0208 	ubfx	r2, r5, #0, #9
 8009652:	3b01      	subs	r3, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8009654:	429a      	cmp	r2, r3
 8009656:	f47f aee5 	bne.w	8009424 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 800965a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800965c:	f3c5 2246 	ubfx	r2, r5, #9, #7
 8009660:	3b01      	subs	r3, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8009662:	429a      	cmp	r2, r3
 8009664:	f47f aede 	bne.w	8009424 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8009668:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800966a:	f3c5 4206 	ubfx	r2, r5, #16, #7
 800966e:	3b01      	subs	r3, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8009670:	429a      	cmp	r2, r3
 8009672:	f47f aed7 	bne.w	8009424 <HAL_RCC_OscConfig+0x4b4>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 8009676:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8009678:	f3c5 6506 	ubfx	r5, r5, #24, #7
 800967c:	3801      	subs	r0, #1
    return HAL_ERROR;
 800967e:	1a28      	subs	r0, r5, r0
 8009680:	bf18      	it	ne
 8009682:	2001      	movne	r0, #1
 8009684:	e673      	b.n	800936e <HAL_RCC_OscConfig+0x3fe>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8009686:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800968a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800968e:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 8009690:	f042 0201 	orr.w	r2, r2, #1
 8009694:	671a      	str	r2, [r3, #112]	; 0x70
 8009696:	e5a6      	b.n	80091e6 <HAL_RCC_OscConfig+0x276>
      tickstart = HAL_GetTick();
 8009698:	f7f7 f9d0 	bl	8000a3c <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 800969c:	f6c5 0502 	movt	r5, #22530	; 0x5802
      tickstart = HAL_GetTick();
 80096a0:	4607      	mov	r7, r0
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80096a2:	f241 3688 	movw	r6, #5000	; 0x1388
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 80096a6:	e005      	b.n	80096b4 <HAL_RCC_OscConfig+0x744>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80096a8:	f7f7 f9c8 	bl	8000a3c <HAL_GetTick>
 80096ac:	1bc0      	subs	r0, r0, r7
 80096ae:	42b0      	cmp	r0, r6
 80096b0:	f63f aecd 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 80096b4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80096b6:	0798      	lsls	r0, r3, #30
 80096b8:	d4f6      	bmi.n	80096a8 <HAL_RCC_OscConfig+0x738>
 80096ba:	e5ab      	b.n	8009214 <HAL_RCC_OscConfig+0x2a4>
        __HAL_RCC_PLL_DISABLE();
 80096bc:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80096be:	461c      	mov	r4, r3
        __HAL_RCC_PLL_DISABLE();
 80096c0:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 80096c4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80096c6:	f7f7 f9b9 	bl	8000a3c <HAL_GetTick>
 80096ca:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80096cc:	e005      	b.n	80096da <HAL_RCC_OscConfig+0x76a>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80096ce:	f7f7 f9b5 	bl	8000a3c <HAL_GetTick>
 80096d2:	1b40      	subs	r0, r0, r5
 80096d4:	2802      	cmp	r0, #2
 80096d6:	f63f aeba 	bhi.w	800944e <HAL_RCC_OscConfig+0x4de>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 80096da:	6823      	ldr	r3, [r4, #0]
 80096dc:	019b      	lsls	r3, r3, #6
 80096de:	d4f6      	bmi.n	80096ce <HAL_RCC_OscConfig+0x75e>
 80096e0:	e644      	b.n	800936c <HAL_RCC_OscConfig+0x3fc>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80096e2:	2b05      	cmp	r3, #5
 80096e4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 80096e8:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80096ec:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80096ee:	f47f ad73 	bne.w	80091d8 <HAL_RCC_OscConfig+0x268>
 80096f2:	f042 0204 	orr.w	r2, r2, #4
 80096f6:	671a      	str	r2, [r3, #112]	; 0x70
 80096f8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80096fa:	f042 0201 	orr.w	r2, r2, #1
 80096fe:	671a      	str	r2, [r3, #112]	; 0x70
 8009700:	e571      	b.n	80091e6 <HAL_RCC_OscConfig+0x276>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8009702:	68eb      	ldr	r3, [r5, #12]
 8009704:	6a22      	ldr	r2, [r4, #32]
 8009706:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 800970a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800970e:	60eb      	str	r3, [r5, #12]
 8009710:	6823      	ldr	r3, [r4, #0]
 8009712:	e4f7      	b.n	8009104 <HAL_RCC_OscConfig+0x194>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8009714:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8009718:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800971c:	606b      	str	r3, [r5, #4]
 800971e:	6823      	ldr	r3, [r4, #0]
 8009720:	e4ae      	b.n	8009080 <HAL_RCC_OscConfig+0x110>
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
 8009722:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009726:	f240 21ee 	movw	r1, #750	; 0x2ee
 800972a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800972e:	f00c f89b 	bl	8015868 <assert_failed>
 8009732:	e592      	b.n	800925a <HAL_RCC_OscConfig+0x2ea>
        assert_param(IS_RCC_PLLM_VALUE(RCC_OscInitStruct->PLL.PLLM));
 8009734:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009738:	f240 21ed 	movw	r1, #749	; 0x2ed
 800973c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009740:	f00c f892 	bl	8015868 <assert_failed>
 8009744:	e583      	b.n	800924e <HAL_RCC_OscConfig+0x2de>
        assert_param(IS_RCC_PLLFRACN_VALUE(RCC_OscInitStruct->PLL.PLLFRACN));
 8009746:	f64d 4014 	movw	r0, #56340	; 0xdc14
 800974a:	f240 21f2 	movw	r1, #754	; 0x2f2
 800974e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009752:	f00c f889 	bl	8015868 <assert_failed>
 8009756:	e594      	b.n	8009282 <HAL_RCC_OscConfig+0x312>
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
 8009758:	f64d 4014 	movw	r0, #56340	; 0xdc14
 800975c:	f240 21f1 	movw	r1, #753	; 0x2f1
 8009760:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009764:	f00c f880 	bl	8015868 <assert_failed>
 8009768:	e586      	b.n	8009278 <HAL_RCC_OscConfig+0x308>
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
 800976a:	f64d 4014 	movw	r0, #56340	; 0xdc14
 800976e:	f44f 713c 	mov.w	r1, #752	; 0x2f0
 8009772:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009776:	f00c f877 	bl	8015868 <assert_failed>
 800977a:	e578      	b.n	800926e <HAL_RCC_OscConfig+0x2fe>
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
 800977c:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009780:	f240 21ef 	movw	r1, #751	; 0x2ef
 8009784:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009788:	f00c f86e 	bl	8015868 <assert_failed>
 800978c:	e56a      	b.n	8009264 <HAL_RCC_OscConfig+0x2f4>
        assert_param(IS_RCC_PLLSOURCE(RCC_OscInitStruct->PLL.PLLSource));
 800978e:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009792:	f44f 713b 	mov.w	r1, #748	; 0x2ec
 8009796:	f6c0 0002 	movt	r0, #2050	; 0x802
 800979a:	f00c f865 	bl	8015868 <assert_failed>
 800979e:	e551      	b.n	8009244 <HAL_RCC_OscConfig+0x2d4>

080097a0 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 80097a0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80097a4:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80097a8:	6913      	ldr	r3, [r2, #16]
 80097aa:	f003 0338 	and.w	r3, r3, #56	; 0x38
 80097ae:	2b10      	cmp	r3, #16
 80097b0:	d05c      	beq.n	800986c <HAL_RCC_GetSysClockFreq+0xcc>
 80097b2:	2b18      	cmp	r3, #24
 80097b4:	d011      	beq.n	80097da <HAL_RCC_GetSysClockFreq+0x3a>
 80097b6:	b123      	cbz	r3, 80097c2 <HAL_RCC_GetSysClockFreq+0x22>
      }

    break;

  case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
    sysclockfreq = CSI_VALUE;
 80097b8:	f44f 6010 	mov.w	r0, #2304	; 0x900
 80097bc:	f2c0 003d 	movt	r0, #61	; 0x3d
 80097c0:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80097c2:	6813      	ldr	r3, [r2, #0]
 80097c4:	0699      	lsls	r1, r3, #26
 80097c6:	d556      	bpl.n	8009876 <HAL_RCC_GetSysClockFreq+0xd6>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80097c8:	6813      	ldr	r3, [r2, #0]
 80097ca:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 80097ce:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 80097d2:	f2c0 30d0 	movt	r0, #976	; 0x3d0
 80097d6:	40d8      	lsrs	r0, r3
 80097d8:	4770      	bx	lr
{
 80097da:	b410      	push	{r4}
  case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

    /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
    SYSCLK = PLL_VCO / PLLR
    */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80097dc:	6a91      	ldr	r1, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 80097de:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 80097e0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 80097e2:	f3c0 1005 	ubfx	r0, r0, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80097e6:	6b54      	ldr	r4, [r2, #52]	; 0x34

    if (pllm != 0U)
 80097e8:	b3e8      	cbz	r0, 8009866 <HAL_RCC_GetSysClockFreq+0xc6>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80097ea:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 80097ee:	f003 0301 	and.w	r3, r3, #1
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80097f2:	f001 0103 	and.w	r1, r1, #3
 80097f6:	ee07 0a90 	vmov	s15, r0
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80097fa:	fb03 f304 	mul.w	r3, r3, r4
    {
      switch (pllsource)
 80097fe:	2901      	cmp	r1, #1
 8009800:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8009804:	ee07 3a10 	vmov	s14, r3
 8009808:	eeba 7ae9 	vcvt.f32.s32	s14, s14, #13
      switch (pllsource)
 800980c:	d002      	beq.n	8009814 <HAL_RCC_GetSysClockFreq+0x74>
 800980e:	d33f      	bcc.n	8009890 <HAL_RCC_GetSysClockFreq+0xf0>
 8009810:	2902      	cmp	r1, #2
 8009812:	d035      	beq.n	8009880 <HAL_RCC_GetSysClockFreq+0xe0>
      case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
        break;

      default:
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009814:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 8009818:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800981c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800981e:	f6c4 2174 	movt	r1, #19060	; 0x4a74
 8009822:	ee06 1a10 	vmov	s12, r1
 8009826:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800982a:	eec6 5a27 	vdiv.f32	s11, s12, s15
 800982e:	ee06 3a90 	vmov	s13, r3
 8009832:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8009836:	ee76 7a85 	vadd.f32	s15, s13, s10
 800983a:	ee37 7a87 	vadd.f32	s14, s15, s14
 800983e:	ee27 7a25 	vmul.f32	s14, s14, s11
        break;
      }
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8009842:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009846:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800984a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800984c:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8009850:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8009852:	ee07 3a90 	vmov	s15, r3
 8009856:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 800985a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 800985e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8009862:	ee17 0a90 	vmov	r0, s15
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
 8009866:	f85d 4b04 	ldr.w	r4, [sp], #4
 800986a:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 800986c:	f647 0040 	movw	r0, #30784	; 0x7840
 8009870:	f2c0 107d 	movt	r0, #381	; 0x17d
 8009874:	4770      	bx	lr
        sysclockfreq = (uint32_t) HSI_VALUE;
 8009876:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 800987a:	f2c0 30d0 	movt	r0, #976	; 0x3d0
}
 800987e:	4770      	bx	lr
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009880:	f64b 4120 	movw	r1, #48160	; 0xbc20
 8009884:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009886:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800988a:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
 800988e:	e7c8      	b.n	8009822 <HAL_RCC_GetSysClockFreq+0x82>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8009890:	6813      	ldr	r3, [r2, #0]
 8009892:	069b      	lsls	r3, r3, #26
 8009894:	d51d      	bpl.n	80098d2 <HAL_RCC_GetSysClockFreq+0x132>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009896:	6810      	ldr	r0, [r2, #0]
 8009898:	f44f 4110 	mov.w	r1, #36864	; 0x9000
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800989c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800989e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80098a2:	f3c0 02c1 	ubfx	r2, r0, #3, #2
 80098a6:	f2c0 31d0 	movt	r1, #976	; 0x3d0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80098aa:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80098ae:	40d1      	lsrs	r1, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80098b0:	ee06 3a10 	vmov	s12, r3
 80098b4:	ee05 1a90 	vmov	s11, r1
 80098b8:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 80098bc:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 80098c0:	ee36 6a26 	vadd.f32	s12, s12, s13
 80098c4:	eec5 6aa7 	vdiv.f32	s13, s11, s15
 80098c8:	ee36 7a07 	vadd.f32	s14, s12, s14
 80098cc:	ee26 7a87 	vmul.f32	s14, s13, s14
 80098d0:	e7b7      	b.n	8009842 <HAL_RCC_GetSysClockFreq+0xa2>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80098d2:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 80098d6:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80098d8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 80098dc:	f6c4 4174 	movt	r1, #19572	; 0x4c74
 80098e0:	e79f      	b.n	8009822 <HAL_RCC_GetSysClockFreq+0x82>
 80098e2:	bf00      	nop

080098e4 <HAL_RCC_ClockConfig>:
  if(RCC_ClkInitStruct == NULL)
 80098e4:	2800      	cmp	r0, #0
 80098e6:	f000 822b 	beq.w	8009d40 <HAL_RCC_ClockConfig+0x45c>
{
 80098ea:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 80098ee:	6803      	ldr	r3, [r0, #0]
 80098f0:	4604      	mov	r4, r0
 80098f2:	460d      	mov	r5, r1
 80098f4:	3b01      	subs	r3, #1
 80098f6:	2b3e      	cmp	r3, #62	; 0x3e
 80098f8:	f200 8209 	bhi.w	8009d0e <HAL_RCC_ClockConfig+0x42a>
  assert_param(IS_FLASH_LATENCY(FLatency));
 80098fc:	2d0f      	cmp	r5, #15
 80098fe:	f200 81f0 	bhi.w	8009ce2 <HAL_RCC_ClockConfig+0x3fe>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8009902:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8009906:	f2c5 2200 	movt	r2, #20992	; 0x5200
 800990a:	6813      	ldr	r3, [r2, #0]
 800990c:	f003 030f 	and.w	r3, r3, #15
 8009910:	42ab      	cmp	r3, r5
 8009912:	f0c0 8217 	bcc.w	8009d44 <HAL_RCC_ClockConfig+0x460>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8009916:	6823      	ldr	r3, [r4, #0]
 8009918:	075e      	lsls	r6, r3, #29
 800991a:	d518      	bpl.n	800994e <HAL_RCC_ClockConfig+0x6a>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 800991c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009920:	6921      	ldr	r1, [r4, #16]
 8009922:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009926:	6992      	ldr	r2, [r2, #24]
 8009928:	f002 0270 	and.w	r2, r2, #112	; 0x70
 800992c:	4291      	cmp	r1, r2
 800992e:	d90e      	bls.n	800994e <HAL_RCC_ClockConfig+0x6a>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8009930:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 8009934:	2b40      	cmp	r3, #64	; 0x40
 8009936:	f040 822e 	bne.w	8009d96 <HAL_RCC_ClockConfig+0x4b2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 800993a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800993e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009942:	6993      	ldr	r3, [r2, #24]
 8009944:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009948:	4319      	orrs	r1, r3
 800994a:	6191      	str	r1, [r2, #24]
 800994c:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800994e:	0718      	lsls	r0, r3, #28
 8009950:	d518      	bpl.n	8009984 <HAL_RCC_ClockConfig+0xa0>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8009952:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009956:	6961      	ldr	r1, [r4, #20]
 8009958:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800995c:	69d2      	ldr	r2, [r2, #28]
 800995e:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8009962:	4291      	cmp	r1, r2
 8009964:	d90e      	bls.n	8009984 <HAL_RCC_ClockConfig+0xa0>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8009966:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 800996a:	2b40      	cmp	r3, #64	; 0x40
 800996c:	f040 821d 	bne.w	8009daa <HAL_RCC_ClockConfig+0x4c6>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8009970:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009974:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009978:	69d3      	ldr	r3, [r2, #28]
 800997a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800997e:	4319      	orrs	r1, r3
 8009980:	61d1      	str	r1, [r2, #28]
 8009982:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8009984:	06d9      	lsls	r1, r3, #27
 8009986:	d519      	bpl.n	80099bc <HAL_RCC_ClockConfig+0xd8>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8009988:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800998c:	69a1      	ldr	r1, [r4, #24]
 800998e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009992:	69d2      	ldr	r2, [r2, #28]
 8009994:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8009998:	4291      	cmp	r1, r2
 800999a:	d90f      	bls.n	80099bc <HAL_RCC_ClockConfig+0xd8>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 800999c:	f421 7340 	bic.w	r3, r1, #768	; 0x300
 80099a0:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80099a4:	f040 820b 	bne.w	8009dbe <HAL_RCC_ClockConfig+0x4da>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 80099a8:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80099ac:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80099b0:	69d3      	ldr	r3, [r2, #28]
 80099b2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80099b6:	4319      	orrs	r1, r3
 80099b8:	61d1      	str	r1, [r2, #28]
 80099ba:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 80099bc:	069a      	lsls	r2, r3, #26
 80099be:	d518      	bpl.n	80099f2 <HAL_RCC_ClockConfig+0x10e>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 80099c0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80099c4:	69e1      	ldr	r1, [r4, #28]
 80099c6:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80099ca:	6a12      	ldr	r2, [r2, #32]
 80099cc:	f002 0270 	and.w	r2, r2, #112	; 0x70
 80099d0:	4291      	cmp	r1, r2
 80099d2:	d90e      	bls.n	80099f2 <HAL_RCC_ClockConfig+0x10e>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 80099d4:	f021 0330 	bic.w	r3, r1, #48	; 0x30
 80099d8:	2b40      	cmp	r3, #64	; 0x40
 80099da:	f040 81d2 	bne.w	8009d82 <HAL_RCC_ClockConfig+0x49e>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 80099de:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80099e2:	f6c5 0202 	movt	r2, #22530	; 0x5802
 80099e6:	6a13      	ldr	r3, [r2, #32]
 80099e8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80099ec:	4319      	orrs	r1, r3
 80099ee:	6211      	str	r1, [r2, #32]
 80099f0:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80099f2:	079f      	lsls	r7, r3, #30
 80099f4:	d518      	bpl.n	8009a28 <HAL_RCC_ClockConfig+0x144>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 80099f6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 80099fa:	68e1      	ldr	r1, [r4, #12]
 80099fc:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009a00:	6992      	ldr	r2, [r2, #24]
 8009a02:	f002 020f 	and.w	r2, r2, #15
 8009a06:	4291      	cmp	r1, r2
 8009a08:	d90e      	bls.n	8009a28 <HAL_RCC_ClockConfig+0x144>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8009a0a:	f1a1 0308 	sub.w	r3, r1, #8
 8009a0e:	2b07      	cmp	r3, #7
 8009a10:	f200 81df 	bhi.w	8009dd2 <HAL_RCC_ClockConfig+0x4ee>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8009a14:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009a18:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009a1c:	6993      	ldr	r3, [r2, #24]
 8009a1e:	f023 030f 	bic.w	r3, r3, #15
 8009a22:	4319      	orrs	r1, r3
 8009a24:	6191      	str	r1, [r2, #24]
 8009a26:	6823      	ldr	r3, [r4, #0]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8009a28:	07de      	lsls	r6, r3, #31
 8009a2a:	d55c      	bpl.n	8009ae6 <HAL_RCC_ClockConfig+0x202>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 8009a2c:	68a2      	ldr	r2, [r4, #8]
 8009a2e:	f432 6300 	bics.w	r3, r2, #2048	; 0x800
 8009a32:	f422 7000 	bic.w	r0, r2, #512	; 0x200
 8009a36:	f422 6180 	bic.w	r1, r2, #1024	; 0x400
 8009a3a:	bf14      	ite	ne
 8009a3c:	2301      	movne	r3, #1
 8009a3e:	2300      	moveq	r3, #0
 8009a40:	f5b0 6f10 	cmp.w	r0, #2304	; 0x900
 8009a44:	bf0c      	ite	eq
 8009a46:	2300      	moveq	r3, #0
 8009a48:	f003 0301 	andne.w	r3, r3, #1
 8009a4c:	f5b2 6f70 	cmp.w	r2, #3840	; 0xf00
 8009a50:	bf0c      	ite	eq
 8009a52:	2300      	moveq	r3, #0
 8009a54:	f003 0301 	andne.w	r3, r3, #1
 8009a58:	f5b1 6f20 	cmp.w	r1, #2560	; 0xa00
 8009a5c:	bf0c      	ite	eq
 8009a5e:	2300      	moveq	r3, #0
 8009a60:	f003 0301 	andne.w	r3, r3, #1
 8009a64:	b12b      	cbz	r3, 8009a72 <HAL_RCC_ClockConfig+0x18e>
 8009a66:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009a6a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 8009a6e:	f040 817b 	bne.w	8009d68 <HAL_RCC_ClockConfig+0x484>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8009a72:	6863      	ldr	r3, [r4, #4]
 8009a74:	2b03      	cmp	r3, #3
 8009a76:	f200 815a 	bhi.w	8009d2e <HAL_RCC_ClockConfig+0x44a>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 8009a7a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009a7e:	68a1      	ldr	r1, [r4, #8]
 8009a80:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009a84:	6993      	ldr	r3, [r2, #24]
 8009a86:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 8009a8a:	430b      	orrs	r3, r1
 8009a8c:	6193      	str	r3, [r2, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8009a8e:	6863      	ldr	r3, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8009a90:	6812      	ldr	r2, [r2, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8009a92:	2b02      	cmp	r3, #2
 8009a94:	f000 8147 	beq.w	8009d26 <HAL_RCC_ClockConfig+0x442>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8009a98:	2b03      	cmp	r3, #3
 8009a9a:	f000 8161 	beq.w	8009d60 <HAL_RCC_ClockConfig+0x47c>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 8009a9e:	2b01      	cmp	r3, #1
 8009aa0:	f000 816b 	beq.w	8009d7a <HAL_RCC_ClockConfig+0x496>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8009aa4:	0757      	lsls	r7, r2, #29
 8009aa6:	f140 812f 	bpl.w	8009d08 <HAL_RCC_ClockConfig+0x424>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8009aaa:	f44f 4188 	mov.w	r1, #17408	; 0x4400
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8009aae:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8009ab2:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8009ab6:	690a      	ldr	r2, [r1, #16]
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8009ab8:	460e      	mov	r6, r1
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8009aba:	f022 0207 	bic.w	r2, r2, #7
 8009abe:	4313      	orrs	r3, r2
 8009ac0:	610b      	str	r3, [r1, #16]
      tickstart = HAL_GetTick();
 8009ac2:	f7f6 ffbb 	bl	8000a3c <HAL_GetTick>
 8009ac6:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8009ac8:	e005      	b.n	8009ad6 <HAL_RCC_ClockConfig+0x1f2>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8009aca:	f7f6 ffb7 	bl	8000a3c <HAL_GetTick>
 8009ace:	1bc0      	subs	r0, r0, r7
 8009ad0:	4540      	cmp	r0, r8
 8009ad2:	f200 8143 	bhi.w	8009d5c <HAL_RCC_ClockConfig+0x478>
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8009ad6:	6933      	ldr	r3, [r6, #16]
 8009ad8:	6862      	ldr	r2, [r4, #4]
 8009ada:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8009ade:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 8009ae2:	d1f2      	bne.n	8009aca <HAL_RCC_ClockConfig+0x1e6>
 8009ae4:	6823      	ldr	r3, [r4, #0]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8009ae6:	079e      	lsls	r6, r3, #30
 8009ae8:	d520      	bpl.n	8009b2c <HAL_RCC_ClockConfig+0x248>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8009aea:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009aee:	68e2      	ldr	r2, [r4, #12]
 8009af0:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009af4:	699b      	ldr	r3, [r3, #24]
 8009af6:	f003 030f 	and.w	r3, r3, #15
 8009afa:	429a      	cmp	r2, r3
 8009afc:	d216      	bcs.n	8009b2c <HAL_RCC_ClockConfig+0x248>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8009afe:	f1a2 0308 	sub.w	r3, r2, #8
 8009b02:	2b06      	cmp	r3, #6
 8009b04:	d909      	bls.n	8009b1a <HAL_RCC_ClockConfig+0x236>
 8009b06:	b142      	cbz	r2, 8009b1a <HAL_RCC_ClockConfig+0x236>
 8009b08:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009b0c:	f240 4136 	movw	r1, #1078	; 0x436
 8009b10:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009b14:	f00b fea8 	bl	8015868 <assert_failed>
 8009b18:	68e2      	ldr	r2, [r4, #12]
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8009b1a:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8009b1e:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8009b22:	698b      	ldr	r3, [r1, #24]
 8009b24:	f023 030f 	bic.w	r3, r3, #15
 8009b28:	431a      	orrs	r2, r3
 8009b2a:	618a      	str	r2, [r1, #24]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8009b2c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8009b30:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8009b34:	681a      	ldr	r2, [r3, #0]
 8009b36:	f002 020f 	and.w	r2, r2, #15
 8009b3a:	42aa      	cmp	r2, r5
 8009b3c:	d90a      	bls.n	8009b54 <HAL_RCC_ClockConfig+0x270>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8009b3e:	681a      	ldr	r2, [r3, #0]
 8009b40:	f022 020f 	bic.w	r2, r2, #15
 8009b44:	432a      	orrs	r2, r5
 8009b46:	601a      	str	r2, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8009b48:	681b      	ldr	r3, [r3, #0]
 8009b4a:	f003 030f 	and.w	r3, r3, #15
 8009b4e:	42ab      	cmp	r3, r5
 8009b50:	f040 80da 	bne.w	8009d08 <HAL_RCC_ClockConfig+0x424>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8009b54:	6823      	ldr	r3, [r4, #0]
 8009b56:	0758      	lsls	r0, r3, #29
 8009b58:	d523      	bpl.n	8009ba2 <HAL_RCC_ClockConfig+0x2be>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8009b5a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009b5e:	6921      	ldr	r1, [r4, #16]
 8009b60:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009b64:	6992      	ldr	r2, [r2, #24]
 8009b66:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8009b6a:	4291      	cmp	r1, r2
 8009b6c:	d219      	bcs.n	8009ba2 <HAL_RCC_ClockConfig+0x2be>
     assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8009b6e:	2950      	cmp	r1, #80	; 0x50
 8009b70:	bf18      	it	ne
 8009b72:	2960      	cmpne	r1, #96	; 0x60
 8009b74:	d00b      	beq.n	8009b8e <HAL_RCC_ClockConfig+0x2aa>
 8009b76:	f031 0340 	bics.w	r3, r1, #64	; 0x40
 8009b7a:	d008      	beq.n	8009b8e <HAL_RCC_ClockConfig+0x2aa>
 8009b7c:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009b80:	f240 4157 	movw	r1, #1111	; 0x457
 8009b84:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009b88:	f00b fe6e 	bl	8015868 <assert_failed>
 8009b8c:	6921      	ldr	r1, [r4, #16]
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8009b8e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009b92:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009b96:	6993      	ldr	r3, [r2, #24]
 8009b98:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009b9c:	4319      	orrs	r1, r3
 8009b9e:	6191      	str	r1, [r2, #24]
 8009ba0:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8009ba2:	0719      	lsls	r1, r3, #28
 8009ba4:	d523      	bpl.n	8009bee <HAL_RCC_ClockConfig+0x30a>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8009ba6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009baa:	6961      	ldr	r1, [r4, #20]
 8009bac:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009bb0:	69d2      	ldr	r2, [r2, #28]
 8009bb2:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8009bb6:	4291      	cmp	r1, r2
 8009bb8:	d219      	bcs.n	8009bee <HAL_RCC_ClockConfig+0x30a>
     assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8009bba:	2950      	cmp	r1, #80	; 0x50
 8009bbc:	bf18      	it	ne
 8009bbe:	2960      	cmpne	r1, #96	; 0x60
 8009bc0:	d00b      	beq.n	8009bda <HAL_RCC_ClockConfig+0x2f6>
 8009bc2:	f031 0340 	bics.w	r3, r1, #64	; 0x40
 8009bc6:	d008      	beq.n	8009bda <HAL_RCC_ClockConfig+0x2f6>
 8009bc8:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009bcc:	f240 4169 	movw	r1, #1129	; 0x469
 8009bd0:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009bd4:	f00b fe48 	bl	8015868 <assert_failed>
 8009bd8:	6961      	ldr	r1, [r4, #20]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8009bda:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009bde:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009be2:	69d3      	ldr	r3, [r2, #28]
 8009be4:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009be8:	4319      	orrs	r1, r3
 8009bea:	61d1      	str	r1, [r2, #28]
 8009bec:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8009bee:	06da      	lsls	r2, r3, #27
 8009bf0:	d525      	bpl.n	8009c3e <HAL_RCC_ClockConfig+0x35a>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8009bf2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009bf6:	69a1      	ldr	r1, [r4, #24]
 8009bf8:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009bfc:	69d2      	ldr	r2, [r2, #28]
 8009bfe:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8009c02:	4291      	cmp	r1, r2
 8009c04:	d21b      	bcs.n	8009c3e <HAL_RCC_ClockConfig+0x35a>
     assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8009c06:	f5b1 6fc0 	cmp.w	r1, #1536	; 0x600
 8009c0a:	bf18      	it	ne
 8009c0c:	f5b1 6fa0 	cmpne.w	r1, #1280	; 0x500
 8009c10:	d00b      	beq.n	8009c2a <HAL_RCC_ClockConfig+0x346>
 8009c12:	f431 6380 	bics.w	r3, r1, #1024	; 0x400
 8009c16:	d008      	beq.n	8009c2a <HAL_RCC_ClockConfig+0x346>
 8009c18:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009c1c:	f240 417b 	movw	r1, #1147	; 0x47b
 8009c20:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009c24:	f00b fe20 	bl	8015868 <assert_failed>
 8009c28:	69a1      	ldr	r1, [r4, #24]
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8009c2a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009c2e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 8009c32:	69d3      	ldr	r3, [r2, #28]
 8009c34:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8009c38:	4319      	orrs	r1, r3
 8009c3a:	61d1      	str	r1, [r2, #28]
 8009c3c:	6823      	ldr	r3, [r4, #0]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8009c3e:	069b      	lsls	r3, r3, #26
 8009c40:	d522      	bpl.n	8009c88 <HAL_RCC_ClockConfig+0x3a4>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8009c42:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009c46:	69e2      	ldr	r2, [r4, #28]
 8009c48:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009c4c:	6a1b      	ldr	r3, [r3, #32]
 8009c4e:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8009c52:	429a      	cmp	r2, r3
 8009c54:	d218      	bcs.n	8009c88 <HAL_RCC_ClockConfig+0x3a4>
     assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8009c56:	2a50      	cmp	r2, #80	; 0x50
 8009c58:	bf18      	it	ne
 8009c5a:	2a60      	cmpne	r2, #96	; 0x60
 8009c5c:	d00b      	beq.n	8009c76 <HAL_RCC_ClockConfig+0x392>
 8009c5e:	f032 0340 	bics.w	r3, r2, #64	; 0x40
 8009c62:	d008      	beq.n	8009c76 <HAL_RCC_ClockConfig+0x392>
 8009c64:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009c68:	f240 418d 	movw	r1, #1165	; 0x48d
 8009c6c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009c70:	f00b fdfa 	bl	8015868 <assert_failed>
 8009c74:	69e2      	ldr	r2, [r4, #28]
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 8009c76:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 8009c7a:	f6c5 0102 	movt	r1, #22530	; 0x5802
 8009c7e:	6a0b      	ldr	r3, [r1, #32]
 8009c80:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8009c84:	431a      	orrs	r2, r3
 8009c86:	620a      	str	r2, [r1, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009c88:	f44f 4488 	mov.w	r4, #17408	; 0x4400
 8009c8c:	f7ff fd88 	bl	80097a0 <HAL_RCC_GetSysClockFreq>
 8009c90:	f64e 22c0 	movw	r2, #60096	; 0xeac0
  halstatus = HAL_InitTick (uwTickPrio);
 8009c94:	f240 0504 	movw	r5, #4
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009c98:	f6c5 0402 	movt	r4, #22530	; 0x5802
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009c9c:	f240 21b4 	movw	r1, #692	; 0x2b4
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009ca0:	f6c0 0202 	movt	r2, #2050	; 0x802
  halstatus = HAL_InitTick (uwTickPrio);
 8009ca4:	f2c2 0500 	movt	r5, #8192	; 0x2000
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009ca8:	69a3      	ldr	r3, [r4, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009caa:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8009cae:	69a4      	ldr	r4, [r4, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009cb0:	f3c3 2303 	ubfx	r3, r3, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009cb4:	f004 040f 	and.w	r4, r4, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009cb8:	5cd3      	ldrb	r3, [r2, r3]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009cba:	5d12      	ldrb	r2, [r2, r4]
  SystemCoreClock = common_system_clock;
 8009cbc:	f240 24b0 	movw	r4, #688	; 0x2b0
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009cc0:	f003 031f 	and.w	r3, r3, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009cc4:	f002 021f 	and.w	r2, r2, #31
  SystemCoreClock = common_system_clock;
 8009cc8:	f2c2 0400 	movt	r4, #8192	; 0x2000
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8009ccc:	fa20 f303 	lsr.w	r3, r0, r3
  halstatus = HAL_InitTick (uwTickPrio);
 8009cd0:	6828      	ldr	r0, [r5, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009cd2:	fa23 f202 	lsr.w	r2, r3, r2
  SystemCoreClock = common_system_clock;
 8009cd6:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009cd8:	600a      	str	r2, [r1, #0]
}
 8009cda:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
 8009cde:	f7f6 be3f 	b.w	8000960 <HAL_InitTick>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8009ce2:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009ce6:	f44f 7160 	mov.w	r1, #896	; 0x380
 8009cea:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009cee:	f00b fdbb 	bl	8015868 <assert_failed>
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8009cf2:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8009cf6:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8009cfa:	681a      	ldr	r2, [r3, #0]
    __HAL_FLASH_SET_LATENCY(FLatency);
 8009cfc:	6819      	ldr	r1, [r3, #0]
 8009cfe:	f021 010f 	bic.w	r1, r1, #15
 8009d02:	430d      	orrs	r5, r1
 8009d04:	601d      	str	r5, [r3, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8009d06:	681b      	ldr	r3, [r3, #0]
    return HAL_ERROR;
 8009d08:	2001      	movs	r0, #1
}
 8009d0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  assert_param(IS_RCC_CLOCKTYPE(RCC_ClkInitStruct->ClockType));
 8009d0e:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009d12:	f240 317f 	movw	r1, #895	; 0x37f
 8009d16:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009d1a:	f00b fda5 	bl	8015868 <assert_failed>
  assert_param(IS_FLASH_LATENCY(FLatency));
 8009d1e:	2d0f      	cmp	r5, #15
 8009d20:	f67f adef 	bls.w	8009902 <HAL_RCC_ClockConfig+0x1e>
 8009d24:	e7dd      	b.n	8009ce2 <HAL_RCC_ClockConfig+0x3fe>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8009d26:	0390      	lsls	r0, r2, #14
 8009d28:	f53f aebf 	bmi.w	8009aaa <HAL_RCC_ClockConfig+0x1c6>
 8009d2c:	e7ec      	b.n	8009d08 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
 8009d2e:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009d32:	f240 31f5 	movw	r1, #1013	; 0x3f5
 8009d36:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009d3a:	f00b fd95 	bl	8015868 <assert_failed>
 8009d3e:	e69c      	b.n	8009a7a <HAL_RCC_ClockConfig+0x196>
    return HAL_ERROR;
 8009d40:	2001      	movs	r0, #1
}
 8009d42:	4770      	bx	lr
    __HAL_FLASH_SET_LATENCY(FLatency);
 8009d44:	6813      	ldr	r3, [r2, #0]
 8009d46:	f023 030f 	bic.w	r3, r3, #15
 8009d4a:	432b      	orrs	r3, r5
 8009d4c:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8009d4e:	6813      	ldr	r3, [r2, #0]
 8009d50:	f003 030f 	and.w	r3, r3, #15
 8009d54:	42ab      	cmp	r3, r5
 8009d56:	f43f adde 	beq.w	8009916 <HAL_RCC_ClockConfig+0x32>
 8009d5a:	e7d5      	b.n	8009d08 <HAL_RCC_ClockConfig+0x424>
            return HAL_TIMEOUT;
 8009d5c:	2003      	movs	r0, #3
 8009d5e:	e7d4      	b.n	8009d0a <HAL_RCC_ClockConfig+0x426>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8009d60:	0191      	lsls	r1, r2, #6
 8009d62:	f53f aea2 	bmi.w	8009aaa <HAL_RCC_ClockConfig+0x1c6>
 8009d66:	e7cf      	b.n	8009d08 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_SYSCLK(RCC_ClkInitStruct->SYSCLKDivider));
 8009d68:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009d6c:	f44f 717d 	mov.w	r1, #1012	; 0x3f4
 8009d70:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009d74:	f00b fd78 	bl	8015868 <assert_failed>
 8009d78:	e67b      	b.n	8009a72 <HAL_RCC_ClockConfig+0x18e>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8009d7a:	05d2      	lsls	r2, r2, #23
 8009d7c:	f53f ae95 	bmi.w	8009aaa <HAL_RCC_ClockConfig+0x1c6>
 8009d80:	e7c2      	b.n	8009d08 <HAL_RCC_ClockConfig+0x424>
      assert_param(IS_RCC_D3PCLK1(RCC_ClkInitStruct->APB4CLKDivider));
 8009d82:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009d86:	f240 31d1 	movw	r1, #977	; 0x3d1
 8009d8a:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009d8e:	f00b fd6b 	bl	8015868 <assert_failed>
 8009d92:	69e1      	ldr	r1, [r4, #28]
 8009d94:	e623      	b.n	80099de <HAL_RCC_ClockConfig+0xfa>
      assert_param(IS_RCC_D1PCLK1(RCC_ClkInitStruct->APB3CLKDivider));
 8009d96:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009d9a:	f44f 7167 	mov.w	r1, #924	; 0x39c
 8009d9e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009da2:	f00b fd61 	bl	8015868 <assert_failed>
 8009da6:	6921      	ldr	r1, [r4, #16]
 8009da8:	e5c7      	b.n	800993a <HAL_RCC_ClockConfig+0x56>
      assert_param(IS_RCC_PCLK1(RCC_ClkInitStruct->APB1CLKDivider));
 8009daa:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009dae:	f240 31ae 	movw	r1, #942	; 0x3ae
 8009db2:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009db6:	f00b fd57 	bl	8015868 <assert_failed>
 8009dba:	6961      	ldr	r1, [r4, #20]
 8009dbc:	e5d8      	b.n	8009970 <HAL_RCC_ClockConfig+0x8c>
      assert_param(IS_RCC_PCLK2(RCC_ClkInitStruct->APB2CLKDivider));
 8009dbe:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009dc2:	f240 31bf 	movw	r1, #959	; 0x3bf
 8009dc6:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009dca:	f00b fd4d 	bl	8015868 <assert_failed>
 8009dce:	69a1      	ldr	r1, [r4, #24]
 8009dd0:	e5ea      	b.n	80099a8 <HAL_RCC_ClockConfig+0xc4>
      assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
 8009dd2:	f64d 4014 	movw	r0, #56340	; 0xdc14
 8009dd6:	f44f 7179 	mov.w	r1, #996	; 0x3e4
 8009dda:	f6c0 0002 	movt	r0, #2050	; 0x802
 8009dde:	f00b fd43 	bl	8015868 <assert_failed>
 8009de2:	68e1      	ldr	r1, [r4, #12]
 8009de4:	e616      	b.n	8009a14 <HAL_RCC_ClockConfig+0x130>
 8009de6:	bf00      	nop

08009de8 <HAL_RCC_GetHCLKFreq>:
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8009de8:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 8009dec:	f6c5 0202 	movt	r2, #22530	; 0x5802
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 8009df0:	b430      	push	{r4, r5}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8009df2:	6913      	ldr	r3, [r2, #16]
 8009df4:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8009df8:	2b10      	cmp	r3, #16
 8009dfa:	d07d      	beq.n	8009ef8 <HAL_RCC_GetHCLKFreq+0x110>
 8009dfc:	2b18      	cmp	r3, #24
 8009dfe:	d034      	beq.n	8009e6a <HAL_RCC_GetHCLKFreq+0x82>
 8009e00:	b333      	cbz	r3, 8009e50 <HAL_RCC_GetHCLKFreq+0x68>
    sysclockfreq = CSI_VALUE;
 8009e02:	f44f 6310 	mov.w	r3, #2304	; 0x900
 8009e06:	f2c0 033d 	movt	r3, #61	; 0x3d
uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e0a:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 8009e0e:	f64e 22c0 	movw	r2, #60096	; 0xeac0
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e12:	f240 21b4 	movw	r1, #692	; 0x2b4
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
#else
  SystemCoreClock = common_system_clock;
 8009e16:	f240 24b0 	movw	r4, #688	; 0x2b0
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e1a:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8009e1e:	f6c0 0202 	movt	r2, #2050	; 0x802
  SystemCoreClock = common_system_clock;
 8009e22:	f2c2 0400 	movt	r4, #8192	; 0x2000
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e26:	f2c2 0100 	movt	r1, #8192	; 0x2000
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e2a:	6985      	ldr	r5, [r0, #24]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e2c:	6980      	ldr	r0, [r0, #24]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e2e:	f3c5 2503 	ubfx	r5, r5, #8, #4
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e32:	f000 000f 	and.w	r0, r0, #15
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e36:	5d55      	ldrb	r5, [r2, r5]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e38:	5c10      	ldrb	r0, [r2, r0]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e3a:	f005 021f 	and.w	r2, r5, #31
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e3e:	f000 001f 	and.w	r0, r0, #31
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 8009e42:	40d3      	lsrs	r3, r2
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e44:	fa23 f000 	lsr.w	r0, r3, r0
  SystemCoreClock = common_system_clock;
 8009e48:	6023      	str	r3, [r4, #0]
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8009e4a:	6008      	str	r0, [r1, #0]
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
}
 8009e4c:	bc30      	pop	{r4, r5}
 8009e4e:	4770      	bx	lr
   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8009e50:	6813      	ldr	r3, [r2, #0]
 8009e52:	0699      	lsls	r1, r3, #26
 8009e54:	d555      	bpl.n	8009f02 <HAL_RCC_GetHCLKFreq+0x11a>
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009e56:	6813      	ldr	r3, [r2, #0]
 8009e58:	f44f 4210 	mov.w	r2, #36864	; 0x9000
 8009e5c:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 8009e60:	f2c0 32d0 	movt	r2, #976	; 0x3d0
 8009e64:	fa22 f303 	lsr.w	r3, r2, r3
 8009e68:	e7cf      	b.n	8009e0a <HAL_RCC_GetHCLKFreq+0x22>
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009e6a:	6a90      	ldr	r0, [r2, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8009e6c:	6a93      	ldr	r3, [r2, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8009e6e:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 8009e70:	f3c3 1305 	ubfx	r3, r3, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8009e74:	6b54      	ldr	r4, [r2, #52]	; 0x34
    if (pllm != 0U)
 8009e76:	2b00      	cmp	r3, #0
 8009e78:	d0c7      	beq.n	8009e0a <HAL_RCC_GetHCLKFreq+0x22>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8009e7a:	f3c4 04cc 	ubfx	r4, r4, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 8009e7e:	f001 0101 	and.w	r1, r1, #1
 8009e82:	ee07 3a90 	vmov	s15, r3
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8009e86:	f000 0003 	and.w	r0, r0, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8009e8a:	fb01 f304 	mul.w	r3, r1, r4
 8009e8e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
      switch (pllsource)
 8009e92:	2801      	cmp	r0, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 8009e94:	ee07 3a90 	vmov	s15, r3
 8009e98:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
      switch (pllsource)
 8009e9c:	d002      	beq.n	8009ea4 <HAL_RCC_GetHCLKFreq+0xbc>
 8009e9e:	d33d      	bcc.n	8009f1c <HAL_RCC_GetHCLKFreq+0x134>
 8009ea0:	2802      	cmp	r0, #2
 8009ea2:	d033      	beq.n	8009f0c <HAL_RCC_GetHCLKFreq+0x124>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009ea4:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 8009ea8:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 8009eac:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009eae:	f6c4 2174 	movt	r1, #19060	; 0x4a74
 8009eb2:	ee06 1a10 	vmov	s12, r1
 8009eb6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8009eba:	eec6 5a26 	vdiv.f32	s11, s12, s13
 8009ebe:	ee07 3a10 	vmov	s14, r3
 8009ec2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009ec6:	ee37 7a05 	vadd.f32	s14, s14, s10
 8009eca:	ee77 7a27 	vadd.f32	s15, s14, s15
 8009ece:	ee67 7aa5 	vmul.f32	s15, s15, s11
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8009ed2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009ed6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009eda:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8009edc:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8009ee0:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8009ee2:	ee07 3a10 	vmov	s14, r3
 8009ee6:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8009eea:	eec7 6a87 	vdiv.f32	s13, s15, s14
 8009eee:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 8009ef2:	ee17 3a90 	vmov	r3, s15
 8009ef6:	e788      	b.n	8009e0a <HAL_RCC_GetHCLKFreq+0x22>
    sysclockfreq = HSE_VALUE;
 8009ef8:	f647 0340 	movw	r3, #30784	; 0x7840
 8009efc:	f2c0 137d 	movt	r3, #381	; 0x17d
 8009f00:	e783      	b.n	8009e0a <HAL_RCC_GetHCLKFreq+0x22>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8009f02:	f44f 4310 	mov.w	r3, #36864	; 0x9000
 8009f06:	f2c0 33d0 	movt	r3, #976	; 0x3d0
 8009f0a:	e77e      	b.n	8009e0a <HAL_RCC_GetHCLKFreq+0x22>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009f0c:	f64b 4120 	movw	r1, #48160	; 0xbc20
 8009f10:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009f12:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 8009f16:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
 8009f1a:	e7ca      	b.n	8009eb2 <HAL_RCC_GetHCLKFreq+0xca>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8009f1c:	6813      	ldr	r3, [r2, #0]
 8009f1e:	069b      	lsls	r3, r3, #26
 8009f20:	d51d      	bpl.n	8009f5e <HAL_RCC_GetHCLKFreq+0x176>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009f22:	6810      	ldr	r0, [r2, #0]
 8009f24:	f44f 4110 	mov.w	r1, #36864	; 0x9000
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009f28:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009f2a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009f2e:	f3c0 02c1 	ubfx	r2, r0, #3, #2
 8009f32:	f2c0 31d0 	movt	r1, #976	; 0x3d0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009f36:	f3c3 0308 	ubfx	r3, r3, #0, #9
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8009f3a:	40d1      	lsrs	r1, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009f3c:	ee06 3a10 	vmov	s12, r3
 8009f40:	ee05 1a90 	vmov	s11, r1
 8009f44:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 8009f48:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 8009f4c:	ee36 6a07 	vadd.f32	s12, s12, s14
 8009f50:	ee85 7aa6 	vdiv.f32	s14, s11, s13
 8009f54:	ee76 7a27 	vadd.f32	s15, s12, s15
 8009f58:	ee67 7a27 	vmul.f32	s15, s14, s15
 8009f5c:	e7b9      	b.n	8009ed2 <HAL_RCC_GetHCLKFreq+0xea>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8009f5e:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 8009f62:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8009f64:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 8009f68:	f6c4 4174 	movt	r1, #19572	; 0x4c74
 8009f6c:	e7a1      	b.n	8009eb2 <HAL_RCC_GetHCLKFreq+0xca>
 8009f6e:	bf00      	nop

08009f70 <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 8009f70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8009f72:	6803      	ldr	r3, [r0, #0]
{
 8009f74:	4604      	mov	r4, r0
 8009f76:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 8009f78:	3b01      	subs	r3, #1
 8009f7a:	2b3e      	cmp	r3, #62	; 0x3e
 8009f7c:	f200 80a6 	bhi.w	800a0cc <RCCEx_PLL2_Config+0x15c>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 8009f80:	6863      	ldr	r3, [r4, #4]
 8009f82:	3b04      	subs	r3, #4
 8009f84:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 8009f88:	f200 80ae 	bhi.w	800a0e8 <RCCEx_PLL2_Config+0x178>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 8009f8c:	68a3      	ldr	r3, [r4, #8]
 8009f8e:	3b01      	subs	r3, #1
 8009f90:	2b7f      	cmp	r3, #127	; 0x7f
 8009f92:	f200 80b6 	bhi.w	800a102 <RCCEx_PLL2_Config+0x192>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 8009f96:	6923      	ldr	r3, [r4, #16]
 8009f98:	3b01      	subs	r3, #1
 8009f9a:	2b7f      	cmp	r3, #127	; 0x7f
 8009f9c:	f200 80be 	bhi.w	800a11c <RCCEx_PLL2_Config+0x1ac>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 8009fa0:	68e3      	ldr	r3, [r4, #12]
 8009fa2:	3b01      	subs	r3, #1
 8009fa4:	2b7f      	cmp	r3, #127	; 0x7f
 8009fa6:	f200 80c6 	bhi.w	800a136 <RCCEx_PLL2_Config+0x1c6>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 8009faa:	6963      	ldr	r3, [r4, #20]
 8009fac:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
 8009fb0:	f040 80ce 	bne.w	800a150 <RCCEx_PLL2_Config+0x1e0>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 8009fb4:	69a3      	ldr	r3, [r4, #24]
 8009fb6:	f033 0320 	bics.w	r3, r3, #32
 8009fba:	f040 80d6 	bne.w	800a16a <RCCEx_PLL2_Config+0x1fa>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 8009fbe:	69e3      	ldr	r3, [r4, #28]
 8009fc0:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 8009fc4:	d279      	bcs.n	800a0ba <RCCEx_PLL2_Config+0x14a>

  /* Check that PLL2 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 8009fc6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 8009fca:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8009fce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009fd0:	f002 0203 	and.w	r2, r2, #3
 8009fd4:	2a03      	cmp	r2, #3
 8009fd6:	d06c      	beq.n	800a0b2 <RCCEx_PLL2_Config+0x142>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 8009fd8:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8009fda:	461d      	mov	r5, r3
    __HAL_RCC_PLL2_DISABLE();
 8009fdc:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 8009fe0:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 8009fe2:	f7f6 fd2b 	bl	8000a3c <HAL_GetTick>
 8009fe6:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8009fe8:	e004      	b.n	8009ff4 <RCCEx_PLL2_Config+0x84>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 8009fea:	f7f6 fd27 	bl	8000a3c <HAL_GetTick>
 8009fee:	1bc0      	subs	r0, r0, r7
 8009ff0:	2802      	cmp	r0, #2
 8009ff2:	d860      	bhi.n	800a0b6 <RCCEx_PLL2_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8009ff4:	682b      	ldr	r3, [r5, #0]
 8009ff6:	011a      	lsls	r2, r3, #4
 8009ff8:	d4f7      	bmi.n	8009fea <RCCEx_PLL2_Config+0x7a>
        return HAL_TIMEOUT;
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 8009ffa:	6aab      	ldr	r3, [r5, #40]	; 0x28

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 8009ffc:	2107      	movs	r1, #7
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 8009ffe:	6822      	ldr	r2, [r4, #0]
 800a000:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800a004:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 800a008:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
 800a00c:	62ab      	str	r3, [r5, #40]	; 0x28
 800a00e:	6867      	ldr	r7, [r4, #4]
 800a010:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 800a014:	3f01      	subs	r7, #1
 800a016:	1e50      	subs	r0, r2, #1
 800a018:	3b01      	subs	r3, #1
 800a01a:	6922      	ldr	r2, [r4, #16]
 800a01c:	f3c7 0708 	ubfx	r7, r7, #0, #9
 800a020:	025b      	lsls	r3, r3, #9
 800a022:	0400      	lsls	r0, r0, #16
 800a024:	3a01      	subs	r2, #1
 800a026:	b29b      	uxth	r3, r3
 800a028:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 800a02c:	0612      	lsls	r2, r2, #24
 800a02e:	4303      	orrs	r3, r0
 800a030:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800a034:	433b      	orrs	r3, r7
 800a036:	4313      	orrs	r3, r2
 800a038:	63ab      	str	r3, [r5, #56]	; 0x38
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 800a03a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a03c:	6962      	ldr	r2, [r4, #20]
 800a03e:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800a042:	4313      	orrs	r3, r2
 800a044:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 800a046:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a048:	69a2      	ldr	r2, [r4, #24]
 800a04a:	f023 0320 	bic.w	r3, r3, #32
 800a04e:	4313      	orrs	r3, r2
 800a050:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_DISABLE();
 800a052:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a054:	f023 0310 	bic.w	r3, r3, #16
 800a058:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 800a05a:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 800a05c:	69e3      	ldr	r3, [r4, #28]
 800a05e:	4011      	ands	r1, r2
 800a060:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 800a064:	63e9      	str	r1, [r5, #60]	; 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 800a066:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a068:	f043 0310 	orr.w	r3, r3, #16
 800a06c:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL2 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800a06e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 800a070:	2e00      	cmp	r6, #0
 800a072:	f000 8083 	beq.w	800a17c <RCCEx_PLL2_Config+0x20c>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800a076:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 800a078:	bf0c      	ite	eq
 800a07a:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 800a07e:	f443 1300 	orrne.w	r3, r3, #2097152	; 0x200000
 800a082:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 800a084:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800a088:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a08c:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL2 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800a08e:	461c      	mov	r4, r3
    __HAL_RCC_PLL2_ENABLE();
 800a090:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800a094:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800a096:	f7f6 fcd1 	bl	8000a3c <HAL_GetTick>
 800a09a:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800a09c:	e004      	b.n	800a0a8 <RCCEx_PLL2_Config+0x138>
    {
      if( (HAL_GetTick() - tickstart ) > PLL2_TIMEOUT_VALUE)
 800a09e:	f7f6 fccd 	bl	8000a3c <HAL_GetTick>
 800a0a2:	1b40      	subs	r0, r0, r5
 800a0a4:	2802      	cmp	r0, #2
 800a0a6:	d806      	bhi.n	800a0b6 <RCCEx_PLL2_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 800a0a8:	6823      	ldr	r3, [r4, #0]
 800a0aa:	011b      	lsls	r3, r3, #4
 800a0ac:	d5f7      	bpl.n	800a09e <RCCEx_PLL2_Config+0x12e>
    }

  }


  return status;
 800a0ae:	2000      	movs	r0, #0
}
 800a0b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800a0b2:	2001      	movs	r0, #1
}
 800a0b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 800a0b6:	2003      	movs	r0, #3
}
 800a0b8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));
 800a0ba:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a0be:	f640 4186 	movw	r1, #3206	; 0xc86
 800a0c2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a0c6:	f00b fbcf 	bl	8015868 <assert_failed>
 800a0ca:	e77c      	b.n	8009fc6 <RCCEx_PLL2_Config+0x56>
  assert_param(IS_RCC_PLL2M_VALUE(pll2->PLL2M));
 800a0cc:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a0d0:	f640 417f 	movw	r1, #3199	; 0xc7f
 800a0d4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a0d8:	f00b fbc6 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2N_VALUE(pll2->PLL2N));
 800a0dc:	6863      	ldr	r3, [r4, #4]
 800a0de:	3b04      	subs	r3, #4
 800a0e0:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 800a0e4:	f67f af52 	bls.w	8009f8c <RCCEx_PLL2_Config+0x1c>
 800a0e8:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a0ec:	f44f 6148 	mov.w	r1, #3200	; 0xc80
 800a0f0:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a0f4:	f00b fbb8 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2P_VALUE(pll2->PLL2P));
 800a0f8:	68a3      	ldr	r3, [r4, #8]
 800a0fa:	3b01      	subs	r3, #1
 800a0fc:	2b7f      	cmp	r3, #127	; 0x7f
 800a0fe:	f67f af4a 	bls.w	8009f96 <RCCEx_PLL2_Config+0x26>
 800a102:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a106:	f640 4181 	movw	r1, #3201	; 0xc81
 800a10a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a10e:	f00b fbab 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2R_VALUE(pll2->PLL2R));
 800a112:	6923      	ldr	r3, [r4, #16]
 800a114:	3b01      	subs	r3, #1
 800a116:	2b7f      	cmp	r3, #127	; 0x7f
 800a118:	f67f af42 	bls.w	8009fa0 <RCCEx_PLL2_Config+0x30>
 800a11c:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a120:	f640 4182 	movw	r1, #3202	; 0xc82
 800a124:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a128:	f00b fb9e 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2Q_VALUE(pll2->PLL2Q));
 800a12c:	68e3      	ldr	r3, [r4, #12]
 800a12e:	3b01      	subs	r3, #1
 800a130:	2b7f      	cmp	r3, #127	; 0x7f
 800a132:	f67f af3a 	bls.w	8009faa <RCCEx_PLL2_Config+0x3a>
 800a136:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a13a:	f640 4183 	movw	r1, #3203	; 0xc83
 800a13e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a142:	f00b fb91 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
 800a146:	6963      	ldr	r3, [r4, #20]
 800a148:	f033 03c0 	bics.w	r3, r3, #192	; 0xc0
 800a14c:	f43f af32 	beq.w	8009fb4 <RCCEx_PLL2_Config+0x44>
 800a150:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a154:	f640 4184 	movw	r1, #3204	; 0xc84
 800a158:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a15c:	f00b fb84 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
 800a160:	69a3      	ldr	r3, [r4, #24]
 800a162:	f033 0320 	bics.w	r3, r3, #32
 800a166:	f43f af2a 	beq.w	8009fbe <RCCEx_PLL2_Config+0x4e>
 800a16a:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a16e:	f640 4185 	movw	r1, #3205	; 0xc85
 800a172:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a176:	f00b fb77 	bl	8015868 <assert_failed>
 800a17a:	e720      	b.n	8009fbe <RCCEx_PLL2_Config+0x4e>
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 800a17c:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
 800a180:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a182:	e77f      	b.n	800a084 <RCCEx_PLL2_Config+0x114>

0800a184 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 800a184:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 800a186:	6803      	ldr	r3, [r0, #0]
{
 800a188:	4604      	mov	r4, r0
 800a18a:	460e      	mov	r6, r1
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 800a18c:	3b01      	subs	r3, #1
 800a18e:	2b3e      	cmp	r3, #62	; 0x3e
 800a190:	f200 80a6 	bhi.w	800a2e0 <RCCEx_PLL3_Config+0x15c>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 800a194:	6863      	ldr	r3, [r4, #4]
 800a196:	3b04      	subs	r3, #4
 800a198:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 800a19c:	f200 80ae 	bhi.w	800a2fc <RCCEx_PLL3_Config+0x178>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 800a1a0:	68a3      	ldr	r3, [r4, #8]
 800a1a2:	3b01      	subs	r3, #1
 800a1a4:	2b7f      	cmp	r3, #127	; 0x7f
 800a1a6:	f200 80b6 	bhi.w	800a316 <RCCEx_PLL3_Config+0x192>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 800a1aa:	6923      	ldr	r3, [r4, #16]
 800a1ac:	3b01      	subs	r3, #1
 800a1ae:	2b7f      	cmp	r3, #127	; 0x7f
 800a1b0:	f200 80be 	bhi.w	800a330 <RCCEx_PLL3_Config+0x1ac>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 800a1b4:	68e3      	ldr	r3, [r4, #12]
 800a1b6:	3b01      	subs	r3, #1
 800a1b8:	2b7f      	cmp	r3, #127	; 0x7f
 800a1ba:	f200 80c6 	bhi.w	800a34a <RCCEx_PLL3_Config+0x1c6>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 800a1be:	6963      	ldr	r3, [r4, #20]
 800a1c0:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 800a1c4:	f040 80ce 	bne.w	800a364 <RCCEx_PLL3_Config+0x1e0>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 800a1c8:	69a3      	ldr	r3, [r4, #24]
 800a1ca:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800a1ce:	f040 80d6 	bne.w	800a37e <RCCEx_PLL3_Config+0x1fa>
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 800a1d2:	69e3      	ldr	r3, [r4, #28]
 800a1d4:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800a1d8:	d279      	bcs.n	800a2ce <RCCEx_PLL3_Config+0x14a>

  /* Check that PLL3 OSC clock source is already set */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 800a1da:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800a1de:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a1e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800a1e4:	f002 0203 	and.w	r2, r2, #3
 800a1e8:	2a03      	cmp	r2, #3
 800a1ea:	d06c      	beq.n	800a2c6 <RCCEx_PLL3_Config+0x142>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 800a1ec:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800a1ee:	461d      	mov	r5, r3
    __HAL_RCC_PLL3_DISABLE();
 800a1f0:	f022 5280 	bic.w	r2, r2, #268435456	; 0x10000000
 800a1f4:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800a1f6:	f7f6 fc21 	bl	8000a3c <HAL_GetTick>
 800a1fa:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800a1fc:	e004      	b.n	800a208 <RCCEx_PLL3_Config+0x84>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800a1fe:	f7f6 fc1d 	bl	8000a3c <HAL_GetTick>
 800a202:	1bc0      	subs	r0, r0, r7
 800a204:	2802      	cmp	r0, #2
 800a206:	d860      	bhi.n	800a2ca <RCCEx_PLL3_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 800a208:	682b      	ldr	r3, [r5, #0]
 800a20a:	009a      	lsls	r2, r3, #2
 800a20c:	d4f7      	bmi.n	800a1fe <RCCEx_PLL3_Config+0x7a>
        return HAL_TIMEOUT;
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800a20e:	6aab      	ldr	r3, [r5, #40]	; 0x28

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800a210:	2107      	movs	r1, #7
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800a212:	6822      	ldr	r2, [r4, #0]
 800a214:	f023 737c 	bic.w	r3, r3, #66060288	; 0x3f00000
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800a218:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 800a21c:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 800a220:	62ab      	str	r3, [r5, #40]	; 0x28
 800a222:	6867      	ldr	r7, [r4, #4]
 800a224:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 800a228:	3f01      	subs	r7, #1
 800a22a:	1e50      	subs	r0, r2, #1
 800a22c:	3b01      	subs	r3, #1
 800a22e:	6922      	ldr	r2, [r4, #16]
 800a230:	f3c7 0708 	ubfx	r7, r7, #0, #9
 800a234:	025b      	lsls	r3, r3, #9
 800a236:	0400      	lsls	r0, r0, #16
 800a238:	3a01      	subs	r2, #1
 800a23a:	b29b      	uxth	r3, r3
 800a23c:	f400 00fe 	and.w	r0, r0, #8323072	; 0x7f0000
 800a240:	0612      	lsls	r2, r2, #24
 800a242:	4303      	orrs	r3, r0
 800a244:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 800a248:	433b      	orrs	r3, r7
 800a24a:	4313      	orrs	r3, r2
 800a24c:	642b      	str	r3, [r5, #64]	; 0x40
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 800a24e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a250:	6962      	ldr	r2, [r4, #20]
 800a252:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
 800a256:	4313      	orrs	r3, r2
 800a258:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 800a25a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a25c:	69a2      	ldr	r2, [r4, #24]
 800a25e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800a262:	4313      	orrs	r3, r2
 800a264:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_DISABLE();
 800a266:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a268:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800a26c:	62eb      	str	r3, [r5, #44]	; 0x2c
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 800a26e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800a270:	69e3      	ldr	r3, [r4, #28]
 800a272:	4011      	ands	r1, r2
 800a274:	ea41 01c3 	orr.w	r1, r1, r3, lsl #3
 800a278:	6469      	str	r1, [r5, #68]	; 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 800a27a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 800a27c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800a280:	62eb      	str	r3, [r5, #44]	; 0x2c

    /* Enable the PLL3 clock output */
    if(Divider == DIVIDER_P_UPDATE)
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800a282:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
    if(Divider == DIVIDER_P_UPDATE)
 800a284:	2e00      	cmp	r6, #0
 800a286:	f000 8083 	beq.w	800a390 <RCCEx_PLL3_Config+0x20c>
    }
    else if(Divider == DIVIDER_Q_UPDATE)
 800a28a:	2e01      	cmp	r6, #1
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 800a28c:	bf0c      	ite	eq
 800a28e:	f443 0300 	orreq.w	r3, r3, #8388608	; 0x800000
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 800a292:	f043 7380 	orrne.w	r3, r3, #16777216	; 0x1000000
 800a296:	62eb      	str	r3, [r5, #44]	; 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 800a298:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800a29c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a2a0:	681a      	ldr	r2, [r3, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLL3 is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800a2a2:	461c      	mov	r4, r3
    __HAL_RCC_PLL3_ENABLE();
 800a2a4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800a2a8:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800a2aa:	f7f6 fbc7 	bl	8000a3c <HAL_GetTick>
 800a2ae:	4605      	mov	r5, r0
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800a2b0:	e004      	b.n	800a2bc <RCCEx_PLL3_Config+0x138>
    {
      if( (HAL_GetTick() - tickstart ) > PLL3_TIMEOUT_VALUE)
 800a2b2:	f7f6 fbc3 	bl	8000a3c <HAL_GetTick>
 800a2b6:	1b40      	subs	r0, r0, r5
 800a2b8:	2802      	cmp	r0, #2
 800a2ba:	d806      	bhi.n	800a2ca <RCCEx_PLL3_Config+0x146>
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 800a2bc:	6823      	ldr	r3, [r4, #0]
 800a2be:	009b      	lsls	r3, r3, #2
 800a2c0:	d5f7      	bpl.n	800a2b2 <RCCEx_PLL3_Config+0x12e>
    }

  }


  return status;
 800a2c2:	2000      	movs	r0, #0
}
 800a2c4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_ERROR;
 800a2c6:	2001      	movs	r0, #1
}
 800a2c8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        return HAL_TIMEOUT;
 800a2ca:	2003      	movs	r0, #3
}
 800a2cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));
 800a2ce:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a2d2:	f640 41ee 	movw	r1, #3310	; 0xcee
 800a2d6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a2da:	f00b fac5 	bl	8015868 <assert_failed>
 800a2de:	e77c      	b.n	800a1da <RCCEx_PLL3_Config+0x56>
  assert_param(IS_RCC_PLL3M_VALUE(pll3->PLL3M));
 800a2e0:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a2e4:	f640 41e7 	movw	r1, #3303	; 0xce7
 800a2e8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a2ec:	f00b fabc 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3N_VALUE(pll3->PLL3N));
 800a2f0:	6863      	ldr	r3, [r4, #4]
 800a2f2:	3b04      	subs	r3, #4
 800a2f4:	f5b3 7ffe 	cmp.w	r3, #508	; 0x1fc
 800a2f8:	f67f af52 	bls.w	800a1a0 <RCCEx_PLL3_Config+0x1c>
 800a2fc:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a300:	f640 41e8 	movw	r1, #3304	; 0xce8
 800a304:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a308:	f00b faae 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3P_VALUE(pll3->PLL3P));
 800a30c:	68a3      	ldr	r3, [r4, #8]
 800a30e:	3b01      	subs	r3, #1
 800a310:	2b7f      	cmp	r3, #127	; 0x7f
 800a312:	f67f af4a 	bls.w	800a1aa <RCCEx_PLL3_Config+0x26>
 800a316:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a31a:	f640 41e9 	movw	r1, #3305	; 0xce9
 800a31e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a322:	f00b faa1 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3R_VALUE(pll3->PLL3R));
 800a326:	6923      	ldr	r3, [r4, #16]
 800a328:	3b01      	subs	r3, #1
 800a32a:	2b7f      	cmp	r3, #127	; 0x7f
 800a32c:	f67f af42 	bls.w	800a1b4 <RCCEx_PLL3_Config+0x30>
 800a330:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a334:	f640 41ea 	movw	r1, #3306	; 0xcea
 800a338:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a33c:	f00b fa94 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3Q_VALUE(pll3->PLL3Q));
 800a340:	68e3      	ldr	r3, [r4, #12]
 800a342:	3b01      	subs	r3, #1
 800a344:	2b7f      	cmp	r3, #127	; 0x7f
 800a346:	f67f af3a 	bls.w	800a1be <RCCEx_PLL3_Config+0x3a>
 800a34a:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a34e:	f640 41eb 	movw	r1, #3307	; 0xceb
 800a352:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a356:	f00b fa87 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
 800a35a:	6963      	ldr	r3, [r4, #20]
 800a35c:	f433 6340 	bics.w	r3, r3, #3072	; 0xc00
 800a360:	f43f af32 	beq.w	800a1c8 <RCCEx_PLL3_Config+0x44>
 800a364:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a368:	f640 41ec 	movw	r1, #3308	; 0xcec
 800a36c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a370:	f00b fa7a 	bl	8015868 <assert_failed>
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
 800a374:	69a3      	ldr	r3, [r4, #24]
 800a376:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800a37a:	f43f af2a 	beq.w	800a1d2 <RCCEx_PLL3_Config+0x4e>
 800a37e:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800a382:	f640 41ed 	movw	r1, #3309	; 0xced
 800a386:	f6c0 0002 	movt	r0, #2050	; 0x802
 800a38a:	f00b fa6d 	bl	8015868 <assert_failed>
 800a38e:	e720      	b.n	800a1d2 <RCCEx_PLL3_Config+0x4e>
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 800a390:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 800a394:	62eb      	str	r3, [r5, #44]	; 0x2c
 800a396:	e77f      	b.n	800a298 <RCCEx_PLL3_Config+0x114>

0800a398 <HAL_RCCEx_PeriphCLKConfig>:
{
 800a398:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800a39c:	6803      	ldr	r3, [r0, #0]
{
 800a39e:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 800a3a0:	f013 6600 	ands.w	r6, r3, #134217728	; 0x8000000
 800a3a4:	d019      	beq.n	800a3da <HAL_RCCEx_PeriphCLKConfig+0x42>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800a3a6:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800a3a8:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 800a3ac:	f000 85a7 	beq.w	800aefe <HAL_RCCEx_PeriphCLKConfig+0xb66>
 800a3b0:	f240 86bb 	bls.w	800b12a <HAL_RCCEx_PeriphCLKConfig+0xd92>
 800a3b4:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800a3b8:	f000 85e1 	beq.w	800af7e <HAL_RCCEx_PeriphCLKConfig+0xbe6>
 800a3bc:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 800a3c0:	f040 86dc 	bne.w	800b17c <HAL_RCCEx_PeriphCLKConfig+0xde4>
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 800a3c4:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800a3c8:	2600      	movs	r6, #0
 800a3ca:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800a3ce:	6d0b      	ldr	r3, [r1, #80]	; 0x50
 800a3d0:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800a3d4:	431a      	orrs	r2, r3
 800a3d6:	650a      	str	r2, [r1, #80]	; 0x50
 800a3d8:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800a3da:	05dd      	lsls	r5, r3, #23
 800a3dc:	d50a      	bpl.n	800a3f4 <HAL_RCCEx_PeriphCLKConfig+0x5c>
    switch(PeriphClkInit->Sai1ClockSelection)
 800a3de:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800a3e0:	2a04      	cmp	r2, #4
 800a3e2:	d806      	bhi.n	800a3f2 <HAL_RCCEx_PeriphCLKConfig+0x5a>
 800a3e4:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a3e8:	0537051f 	.word	0x0537051f
 800a3ec:	04fb053d 	.word	0x04fb053d
 800a3f0:	04fb      	.short	0x04fb
      ret = HAL_ERROR;
 800a3f2:	2601      	movs	r6, #1
 800a3f4:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 800a3f6:	0598      	lsls	r0, r3, #22
 800a3f8:	d515      	bpl.n	800a426 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    switch(PeriphClkInit->Sai23ClockSelection)
 800a3fa:	6da2      	ldr	r2, [r4, #88]	; 0x58
 800a3fc:	2a80      	cmp	r2, #128	; 0x80
 800a3fe:	f000 8589 	beq.w	800af14 <HAL_RCCEx_PeriphCLKConfig+0xb7c>
 800a402:	f200 8687 	bhi.w	800b114 <HAL_RCCEx_PeriphCLKConfig+0xd7c>
 800a406:	2a00      	cmp	r2, #0
 800a408:	f000 85bf 	beq.w	800af8a <HAL_RCCEx_PeriphCLKConfig+0xbf2>
 800a40c:	2a40      	cmp	r2, #64	; 0x40
 800a40e:	f040 8688 	bne.w	800b122 <HAL_RCCEx_PeriphCLKConfig+0xd8a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a412:	2100      	movs	r1, #0
 800a414:	1d20      	adds	r0, r4, #4
 800a416:	f7ff fdab 	bl	8009f70 <RCCEx_PLL2_Config>
 800a41a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a41c:	2d00      	cmp	r5, #0
 800a41e:	f000 8582 	beq.w	800af26 <HAL_RCCEx_PeriphCLKConfig+0xb8e>
 800a422:	6823      	ldr	r3, [r4, #0]
 800a424:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 800a426:	0559      	lsls	r1, r3, #21
 800a428:	d518      	bpl.n	800a45c <HAL_RCCEx_PeriphCLKConfig+0xc4>
    switch(PeriphClkInit->Sai4AClockSelection)
 800a42a:	f8d4 20a4 	ldr.w	r2, [r4, #164]	; 0xa4
 800a42e:	f5b2 0f80 	cmp.w	r2, #4194304	; 0x400000
 800a432:	f000 8585 	beq.w	800af40 <HAL_RCCEx_PeriphCLKConfig+0xba8>
 800a436:	f200 8661 	bhi.w	800b0fc <HAL_RCCEx_PeriphCLKConfig+0xd64>
 800a43a:	2a00      	cmp	r2, #0
 800a43c:	f000 85b9 	beq.w	800afb2 <HAL_RCCEx_PeriphCLKConfig+0xc1a>
 800a440:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800a444:	f040 8662 	bne.w	800b10c <HAL_RCCEx_PeriphCLKConfig+0xd74>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a448:	2100      	movs	r1, #0
 800a44a:	1d20      	adds	r0, r4, #4
 800a44c:	f7ff fd90 	bl	8009f70 <RCCEx_PLL2_Config>
 800a450:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a452:	2d00      	cmp	r5, #0
 800a454:	f000 857d 	beq.w	800af52 <HAL_RCCEx_PeriphCLKConfig+0xbba>
 800a458:	6823      	ldr	r3, [r4, #0]
 800a45a:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 800a45c:	051a      	lsls	r2, r3, #20
 800a45e:	d518      	bpl.n	800a492 <HAL_RCCEx_PeriphCLKConfig+0xfa>
    switch(PeriphClkInit->Sai4BClockSelection)
 800a460:	f8d4 20a8 	ldr.w	r2, [r4, #168]	; 0xa8
 800a464:	f1b2 7f00 	cmp.w	r2, #33554432	; 0x2000000
 800a468:	f000 8581 	beq.w	800af6e <HAL_RCCEx_PeriphCLKConfig+0xbd6>
 800a46c:	f200 8675 	bhi.w	800b15a <HAL_RCCEx_PeriphCLKConfig+0xdc2>
 800a470:	2a00      	cmp	r2, #0
 800a472:	f000 852b 	beq.w	800aecc <HAL_RCCEx_PeriphCLKConfig+0xb34>
 800a476:	f1b2 7f80 	cmp.w	r2, #16777216	; 0x1000000
 800a47a:	f040 8676 	bne.w	800b16a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a47e:	2100      	movs	r1, #0
 800a480:	1d20      	adds	r0, r4, #4
 800a482:	f7ff fd75 	bl	8009f70 <RCCEx_PLL2_Config>
 800a486:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a488:	2d00      	cmp	r5, #0
 800a48a:	f000 852a 	beq.w	800aee2 <HAL_RCCEx_PeriphCLKConfig+0xb4a>
 800a48e:	6823      	ldr	r3, [r4, #0]
 800a490:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 800a492:	019f      	lsls	r7, r3, #6
 800a494:	d50d      	bpl.n	800a4b2 <HAL_RCCEx_PeriphCLKConfig+0x11a>
    switch(PeriphClkInit->QspiClockSelection)
 800a496:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800a498:	2a10      	cmp	r2, #16
 800a49a:	f000 845f 	beq.w	800ad5c <HAL_RCCEx_PeriphCLKConfig+0x9c4>
 800a49e:	f240 8668 	bls.w	800b172 <HAL_RCCEx_PeriphCLKConfig+0xdda>
 800a4a2:	2a20      	cmp	r2, #32
 800a4a4:	f000 8467 	beq.w	800ad76 <HAL_RCCEx_PeriphCLKConfig+0x9de>
 800a4a8:	2a30      	cmp	r2, #48	; 0x30
 800a4aa:	f000 845f 	beq.w	800ad6c <HAL_RCCEx_PeriphCLKConfig+0x9d4>
      ret = HAL_ERROR;
 800a4ae:	2601      	movs	r6, #1
 800a4b0:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 800a4b2:	04d8      	lsls	r0, r3, #19
 800a4b4:	d517      	bpl.n	800a4e6 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Spi123ClockSelection)
 800a4b6:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800a4b8:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800a4bc:	f000 84f0 	beq.w	800aea0 <HAL_RCCEx_PeriphCLKConfig+0xb08>
 800a4c0:	f200 863f 	bhi.w	800b142 <HAL_RCCEx_PeriphCLKConfig+0xdaa>
 800a4c4:	2a00      	cmp	r2, #0
 800a4c6:	f000 856a 	beq.w	800af9e <HAL_RCCEx_PeriphCLKConfig+0xc06>
 800a4ca:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800a4ce:	f040 8640 	bne.w	800b152 <HAL_RCCEx_PeriphCLKConfig+0xdba>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a4d2:	2100      	movs	r1, #0
 800a4d4:	1d20      	adds	r0, r4, #4
 800a4d6:	f7ff fd4b 	bl	8009f70 <RCCEx_PLL2_Config>
 800a4da:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a4dc:	2d00      	cmp	r5, #0
 800a4de:	f000 84e8 	beq.w	800aeb2 <HAL_RCCEx_PeriphCLKConfig+0xb1a>
 800a4e2:	6823      	ldr	r3, [r4, #0]
 800a4e4:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 800a4e6:	0499      	lsls	r1, r3, #18
 800a4e8:	d51e      	bpl.n	800a528 <HAL_RCCEx_PeriphCLKConfig+0x190>
    switch(PeriphClkInit->Spi45ClockSelection)
 800a4ea:	6e22      	ldr	r2, [r4, #96]	; 0x60
 800a4ec:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
 800a4f0:	f000 8455 	beq.w	800ad9e <HAL_RCCEx_PeriphCLKConfig+0xa06>
 800a4f4:	f200 85c2 	bhi.w	800b07c <HAL_RCCEx_PeriphCLKConfig+0xce4>
 800a4f8:	b142      	cbz	r2, 800a50c <HAL_RCCEx_PeriphCLKConfig+0x174>
 800a4fa:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800a4fe:	f040 85c9 	bne.w	800b094 <HAL_RCCEx_PeriphCLKConfig+0xcfc>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800a502:	2101      	movs	r1, #1
 800a504:	1d20      	adds	r0, r4, #4
 800a506:	f7ff fd33 	bl	8009f70 <RCCEx_PLL2_Config>
 800a50a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a50c:	2d00      	cmp	r5, #0
 800a50e:	f040 8389 	bne.w	800ac24 <HAL_RCCEx_PeriphCLKConfig+0x88c>
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 800a512:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a516:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800a518:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a51c:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800a51e:	f423 23e0 	bic.w	r3, r3, #458752	; 0x70000
 800a522:	430b      	orrs	r3, r1
 800a524:	6513      	str	r3, [r2, #80]	; 0x50
 800a526:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 800a528:	045a      	lsls	r2, r3, #17
 800a52a:	d520      	bpl.n	800a56e <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    switch(PeriphClkInit->Spi6ClockSelection)
 800a52c:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
 800a530:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800a534:	f000 843d 	beq.w	800adb2 <HAL_RCCEx_PeriphCLKConfig+0xa1a>
 800a538:	f200 85c0 	bhi.w	800b0bc <HAL_RCCEx_PeriphCLKConfig+0xd24>
 800a53c:	b142      	cbz	r2, 800a550 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
 800a53e:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800a542:	f040 85c7 	bne.w	800b0d4 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800a546:	2101      	movs	r1, #1
 800a548:	1d20      	adds	r0, r4, #4
 800a54a:	f7ff fd11 	bl	8009f70 <RCCEx_PLL2_Config>
 800a54e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a550:	2d00      	cmp	r5, #0
 800a552:	f040 8364 	bne.w	800ac1e <HAL_RCCEx_PeriphCLKConfig+0x886>
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 800a556:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a55a:	f8d4 10ac 	ldr.w	r1, [r4, #172]	; 0xac
 800a55e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a562:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a564:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 800a568:	430b      	orrs	r3, r1
 800a56a:	6593      	str	r3, [r2, #88]	; 0x58
 800a56c:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 800a56e:	041f      	lsls	r7, r3, #16
 800a570:	d50d      	bpl.n	800a58e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
    switch(PeriphClkInit->FdcanClockSelection)
 800a572:	6ee2      	ldr	r2, [r4, #108]	; 0x6c
 800a574:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800a578:	f000 8425 	beq.w	800adc6 <HAL_RCCEx_PeriphCLKConfig+0xa2e>
 800a57c:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800a580:	f000 82db 	beq.w	800ab3a <HAL_RCCEx_PeriphCLKConfig+0x7a2>
 800a584:	2a00      	cmp	r2, #0
 800a586:	f000 82dd 	beq.w	800ab44 <HAL_RCCEx_PeriphCLKConfig+0x7ac>
      ret = HAL_ERROR;
 800a58a:	2601      	movs	r6, #1
 800a58c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 800a58e:	01d8      	lsls	r0, r3, #7
 800a590:	d50a      	bpl.n	800a5a8 <HAL_RCCEx_PeriphCLKConfig+0x210>
    switch(PeriphClkInit->FmcClockSelection)
 800a592:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800a594:	2a03      	cmp	r2, #3
 800a596:	d805      	bhi.n	800a5a4 <HAL_RCCEx_PeriphCLKConfig+0x20c>
 800a598:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a59c:	038d02ac 	.word	0x038d02ac
 800a5a0:	02ac02a7 	.word	0x02ac02a7
      ret = HAL_ERROR;
 800a5a4:	2601      	movs	r6, #1
 800a5a6:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800a5a8:	0259      	lsls	r1, r3, #9
 800a5aa:	f140 80e3 	bpl.w	800a774 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 800a5ae:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 800a5b2:	f44f 7740 	mov.w	r7, #768	; 0x300
 800a5b6:	f44f 4c86 	mov.w	ip, #17152	; 0x4300
 800a5ba:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800a5be:	bf18      	it	ne
 800a5c0:	f5b2 7f00 	cmpne.w	r2, #512	; 0x200
 800a5c4:	f422 41a0 	bic.w	r1, r2, #20480	; 0x5000
 800a5c8:	f422 4010 	bic.w	r0, r2, #36864	; 0x9000
 800a5cc:	f422 3e88 	bic.w	lr, r2, #69632	; 0x11000
 800a5d0:	bf14      	ite	ne
 800a5d2:	2301      	movne	r3, #1
 800a5d4:	2300      	moveq	r3, #0
 800a5d6:	f2c0 0701 	movt	r7, #1
 800a5da:	f2c0 0c01 	movt	ip, #1
 800a5de:	f5b1 5f0c 	cmp.w	r1, #8960	; 0x2300
 800a5e2:	bf0c      	ite	eq
 800a5e4:	2300      	moveq	r3, #0
 800a5e6:	f003 0301 	andne.w	r3, r3, #1
 800a5ea:	f422 5140 	bic.w	r1, r2, #12288	; 0x3000
 800a5ee:	f5b0 4f86 	cmp.w	r0, #17152	; 0x4300
 800a5f2:	bf0c      	ite	eq
 800a5f4:	2300      	moveq	r3, #0
 800a5f6:	f003 0301 	andne.w	r3, r3, #1
 800a5fa:	f44f 4003 	mov.w	r0, #33536	; 0x8300
 800a5fe:	f5b1 4f03 	cmp.w	r1, #33536	; 0x8300
 800a602:	bf0c      	ite	eq
 800a604:	2300      	moveq	r3, #0
 800a606:	f003 0301 	andne.w	r3, r3, #1
 800a60a:	f2c0 0001 	movt	r0, #1
 800a60e:	f5be 4f63 	cmp.w	lr, #58112	; 0xe300
 800a612:	bf0c      	ite	eq
 800a614:	2300      	moveq	r3, #0
 800a616:	f003 0301 	andne.w	r3, r3, #1
 800a61a:	42b9      	cmp	r1, r7
 800a61c:	bf0c      	ite	eq
 800a61e:	2300      	moveq	r3, #0
 800a620:	f003 0301 	andne.w	r3, r3, #1
 800a624:	f44f 4743 	mov.w	r7, #49920	; 0xc300
 800a628:	4561      	cmp	r1, ip
 800a62a:	bf0c      	ite	eq
 800a62c:	2300      	moveq	r3, #0
 800a62e:	f003 0301 	andne.w	r3, r3, #1
 800a632:	f2c0 0701 	movt	r7, #1
 800a636:	f422 3c04 	bic.w	ip, r2, #135168	; 0x21000
 800a63a:	4281      	cmp	r1, r0
 800a63c:	bf0c      	ite	eq
 800a63e:	2300      	moveq	r3, #0
 800a640:	f003 0301 	andne.w	r3, r3, #1
 800a644:	f44f 7040 	mov.w	r0, #768	; 0x300
 800a648:	45bc      	cmp	ip, r7
 800a64a:	bf0c      	ite	eq
 800a64c:	2300      	moveq	r3, #0
 800a64e:	f003 0301 	andne.w	r3, r3, #1
 800a652:	f2c0 0002 	movt	r0, #2
 800a656:	f44f 4c86 	mov.w	ip, #17152	; 0x4300
 800a65a:	f44f 4703 	mov.w	r7, #33536	; 0x8300
 800a65e:	4281      	cmp	r1, r0
 800a660:	bf0c      	ite	eq
 800a662:	2300      	moveq	r3, #0
 800a664:	f003 0301 	andne.w	r3, r3, #1
 800a668:	f44f 4043 	mov.w	r0, #49920	; 0xc300
 800a66c:	f2c0 0c02 	movt	ip, #2
 800a670:	f2c0 0702 	movt	r7, #2
 800a674:	f2c0 0002 	movt	r0, #2
 800a678:	4561      	cmp	r1, ip
 800a67a:	bf0c      	ite	eq
 800a67c:	2300      	moveq	r3, #0
 800a67e:	f003 0301 	andne.w	r3, r3, #1
 800a682:	f44f 7c40 	mov.w	ip, #768	; 0x300
 800a686:	42b9      	cmp	r1, r7
 800a688:	bf0c      	ite	eq
 800a68a:	2300      	moveq	r3, #0
 800a68c:	f003 0301 	andne.w	r3, r3, #1
 800a690:	f2c0 0c03 	movt	ip, #3
 800a694:	f44f 4786 	mov.w	r7, #17152	; 0x4300
 800a698:	4281      	cmp	r1, r0
 800a69a:	bf0c      	ite	eq
 800a69c:	2300      	moveq	r3, #0
 800a69e:	f003 0301 	andne.w	r3, r3, #1
 800a6a2:	f44f 4003 	mov.w	r0, #33536	; 0x8300
 800a6a6:	f2c0 0703 	movt	r7, #3
 800a6aa:	4561      	cmp	r1, ip
 800a6ac:	bf0c      	ite	eq
 800a6ae:	2300      	moveq	r3, #0
 800a6b0:	f003 0301 	andne.w	r3, r3, #1
 800a6b4:	f2c0 0003 	movt	r0, #3
 800a6b8:	42b9      	cmp	r1, r7
 800a6ba:	bf0c      	ite	eq
 800a6bc:	2300      	moveq	r3, #0
 800a6be:	f003 0301 	andne.w	r3, r3, #1
 800a6c2:	4281      	cmp	r1, r0
 800a6c4:	bf0c      	ite	eq
 800a6c6:	2300      	moveq	r3, #0
 800a6c8:	f003 0301 	andne.w	r3, r3, #1
 800a6cc:	2b00      	cmp	r3, #0
 800a6ce:	f040 81cf 	bne.w	800aa70 <HAL_RCCEx_PeriphCLKConfig+0x6d8>
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800a6d2:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800a6d6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a6da:	681a      	ldr	r2, [r3, #0]
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800a6dc:	461f      	mov	r7, r3
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 800a6de:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a6e2:	601a      	str	r2, [r3, #0]
    tickstart = HAL_GetTick();
 800a6e4:	f7f6 f9aa 	bl	8000a3c <HAL_GetTick>
 800a6e8:	4680      	mov	r8, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800a6ea:	e006      	b.n	800a6fa <HAL_RCCEx_PeriphCLKConfig+0x362>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 800a6ec:	f7f6 f9a6 	bl	8000a3c <HAL_GetTick>
 800a6f0:	eba0 0008 	sub.w	r0, r0, r8
 800a6f4:	2864      	cmp	r0, #100	; 0x64
 800a6f6:	f200 827c 	bhi.w	800abf2 <HAL_RCCEx_PeriphCLKConfig+0x85a>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800a6fa:	683b      	ldr	r3, [r7, #0]
 800a6fc:	05da      	lsls	r2, r3, #23
 800a6fe:	d5f5      	bpl.n	800a6ec <HAL_RCCEx_PeriphCLKConfig+0x354>
    if(ret == HAL_OK)
 800a700:	2d00      	cmp	r5, #0
 800a702:	f040 854f 	bne.w	800b1a4 <HAL_RCCEx_PeriphCLKConfig+0xe0c>
      if((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 800a706:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800a70a:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 800a70e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a712:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800a714:	4051      	eors	r1, r2
 800a716:	f411 7f40 	tst.w	r1, #768	; 0x300
 800a71a:	d00d      	beq.n	800a738 <HAL_RCCEx_PeriphCLKConfig+0x3a0>
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800a71c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_FORCE();
 800a71e:	6f19      	ldr	r1, [r3, #112]	; 0x70
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800a720:	f422 7240 	bic.w	r2, r2, #768	; 0x300
        __HAL_RCC_BACKUPRESET_FORCE();
 800a724:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 800a728:	6719      	str	r1, [r3, #112]	; 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 800a72a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 800a72c:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
 800a730:	6719      	str	r1, [r3, #112]	; 0x70
        RCC->BDCR = tmpreg;
 800a732:	671a      	str	r2, [r3, #112]	; 0x70
 800a734:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
      if(PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 800a738:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800a73c:	f000 8477 	beq.w	800b02e <HAL_RCCEx_PeriphCLKConfig+0xc96>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800a740:	f402 7340 	and.w	r3, r2, #768	; 0x300
 800a744:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800a748:	f000 851b 	beq.w	800b182 <HAL_RCCEx_PeriphCLKConfig+0xdea>
 800a74c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800a750:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800a754:	691a      	ldr	r2, [r3, #16]
 800a756:	f422 527c 	bic.w	r2, r2, #16128	; 0x3f00
 800a75a:	611a      	str	r2, [r3, #16]
 800a75c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a760:	f8d4 30b0 	ldr.w	r3, [r4, #176]	; 0xb0
 800a764:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a768:	f3c3 030b 	ubfx	r3, r3, #0, #12
 800a76c:	6f11      	ldr	r1, [r2, #112]	; 0x70
 800a76e:	430b      	orrs	r3, r1
 800a770:	6713      	str	r3, [r2, #112]	; 0x70
 800a772:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 800a774:	07df      	lsls	r7, r3, #31
 800a776:	d52f      	bpl.n	800a7d8 <HAL_RCCEx_PeriphCLKConfig+0x440>
    switch(PeriphClkInit->Usart16ClockSelection)
 800a778:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800a77a:	2a28      	cmp	r2, #40	; 0x28
 800a77c:	d82a      	bhi.n	800a7d4 <HAL_RCCEx_PeriphCLKConfig+0x43c>
 800a77e:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a782:	01ce      	.short	0x01ce
 800a784:	00290029 	.word	0x00290029
 800a788:	00290029 	.word	0x00290029
 800a78c:	00290029 	.word	0x00290029
 800a790:	02d00029 	.word	0x02d00029
 800a794:	00290029 	.word	0x00290029
 800a798:	00290029 	.word	0x00290029
 800a79c:	00290029 	.word	0x00290029
 800a7a0:	01c80029 	.word	0x01c80029
 800a7a4:	00290029 	.word	0x00290029
 800a7a8:	00290029 	.word	0x00290029
 800a7ac:	00290029 	.word	0x00290029
 800a7b0:	01ce0029 	.word	0x01ce0029
 800a7b4:	00290029 	.word	0x00290029
 800a7b8:	00290029 	.word	0x00290029
 800a7bc:	00290029 	.word	0x00290029
 800a7c0:	01ce0029 	.word	0x01ce0029
 800a7c4:	00290029 	.word	0x00290029
 800a7c8:	00290029 	.word	0x00290029
 800a7cc:	00290029 	.word	0x00290029
 800a7d0:	01ce0029 	.word	0x01ce0029
      ret = HAL_ERROR;
 800a7d4:	2601      	movs	r6, #1
 800a7d6:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 800a7d8:	0798      	lsls	r0, r3, #30
 800a7da:	d50c      	bpl.n	800a7f6 <HAL_RCCEx_PeriphCLKConfig+0x45e>
    switch(PeriphClkInit->Usart234578ClockSelection)
 800a7dc:	6f62      	ldr	r2, [r4, #116]	; 0x74
 800a7de:	2a05      	cmp	r2, #5
 800a7e0:	d807      	bhi.n	800a7f2 <HAL_RCCEx_PeriphCLKConfig+0x45a>
 800a7e2:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a7e6:	0173      	.short	0x0173
 800a7e8:	016d0256 	.word	0x016d0256
 800a7ec:	01730173 	.word	0x01730173
 800a7f0:	0173      	.short	0x0173
      ret = HAL_ERROR;
 800a7f2:	2601      	movs	r6, #1
 800a7f4:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800a7f6:	0759      	lsls	r1, r3, #29
 800a7f8:	d50d      	bpl.n	800a816 <HAL_RCCEx_PeriphCLKConfig+0x47e>
    switch(PeriphClkInit->Lpuart1ClockSelection)
 800a7fa:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 800a7fe:	2a05      	cmp	r2, #5
 800a800:	d807      	bhi.n	800a812 <HAL_RCCEx_PeriphCLKConfig+0x47a>
 800a802:	e8df f012 	tbh	[pc, r2, lsl #1]
 800a806:	014d      	.short	0x014d
 800a808:	0147024f 	.word	0x0147024f
 800a80c:	014d014d 	.word	0x014d014d
 800a810:	014d      	.short	0x014d
      ret = HAL_ERROR;
 800a812:	2601      	movs	r6, #1
 800a814:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 800a816:	069a      	lsls	r2, r3, #26
 800a818:	d520      	bpl.n	800a85c <HAL_RCCEx_PeriphCLKConfig+0x4c4>
    switch(PeriphClkInit->Lptim1ClockSelection)
 800a81a:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 800a81e:	f1b2 5f00 	cmp.w	r2, #536870912	; 0x20000000
 800a822:	f000 82f6 	beq.w	800ae12 <HAL_RCCEx_PeriphCLKConfig+0xa7a>
 800a826:	f200 8439 	bhi.w	800b09c <HAL_RCCEx_PeriphCLKConfig+0xd04>
 800a82a:	b142      	cbz	r2, 800a83e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 800a82c:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
 800a830:	f040 8440 	bne.w	800b0b4 <HAL_RCCEx_PeriphCLKConfig+0xd1c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a834:	2100      	movs	r1, #0
 800a836:	1d20      	adds	r0, r4, #4
 800a838:	f7ff fb9a 	bl	8009f70 <RCCEx_PLL2_Config>
 800a83c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a83e:	2d00      	cmp	r5, #0
 800a840:	f040 81f9 	bne.w	800ac36 <HAL_RCCEx_PeriphCLKConfig+0x89e>
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 800a844:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a848:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 800a84c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a850:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800a852:	f023 43e0 	bic.w	r3, r3, #1879048192	; 0x70000000
 800a856:	430b      	orrs	r3, r1
 800a858:	6553      	str	r3, [r2, #84]	; 0x54
 800a85a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 800a85c:	065f      	lsls	r7, r3, #25
 800a85e:	d520      	bpl.n	800a8a2 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    switch(PeriphClkInit->Lptim2ClockSelection)
 800a860:	f8d4 2098 	ldr.w	r2, [r4, #152]	; 0x98
 800a864:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 800a868:	f000 82c9 	beq.w	800adfe <HAL_RCCEx_PeriphCLKConfig+0xa66>
 800a86c:	f200 8436 	bhi.w	800b0dc <HAL_RCCEx_PeriphCLKConfig+0xd44>
 800a870:	b142      	cbz	r2, 800a884 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 800a872:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800a876:	f040 843d 	bne.w	800b0f4 <HAL_RCCEx_PeriphCLKConfig+0xd5c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a87a:	2100      	movs	r1, #0
 800a87c:	1d20      	adds	r0, r4, #4
 800a87e:	f7ff fb77 	bl	8009f70 <RCCEx_PLL2_Config>
 800a882:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a884:	2d00      	cmp	r5, #0
 800a886:	f040 81d3 	bne.w	800ac30 <HAL_RCCEx_PeriphCLKConfig+0x898>
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800a88a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a88e:	f8d4 1098 	ldr.w	r1, [r4, #152]	; 0x98
 800a892:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a896:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a898:	f423 53e0 	bic.w	r3, r3, #7168	; 0x1c00
 800a89c:	430b      	orrs	r3, r1
 800a89e:	6593      	str	r3, [r2, #88]	; 0x58
 800a8a0:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 800a8a2:	0618      	lsls	r0, r3, #24
 800a8a4:	d520      	bpl.n	800a8e8 <HAL_RCCEx_PeriphCLKConfig+0x550>
    switch(PeriphClkInit->Lptim345ClockSelection)
 800a8a6:	f8d4 209c 	ldr.w	r2, [r4, #156]	; 0x9c
 800a8aa:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800a8ae:	f000 829c 	beq.w	800adea <HAL_RCCEx_PeriphCLKConfig+0xa52>
 800a8b2:	f200 83d4 	bhi.w	800b05e <HAL_RCCEx_PeriphCLKConfig+0xcc6>
 800a8b6:	b142      	cbz	r2, 800a8ca <HAL_RCCEx_PeriphCLKConfig+0x532>
 800a8b8:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800a8bc:	f040 83db 	bne.w	800b076 <HAL_RCCEx_PeriphCLKConfig+0xcde>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800a8c0:	2100      	movs	r1, #0
 800a8c2:	1d20      	adds	r0, r4, #4
 800a8c4:	f7ff fb54 	bl	8009f70 <RCCEx_PLL2_Config>
 800a8c8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a8ca:	2d00      	cmp	r5, #0
 800a8cc:	f040 81ad 	bne.w	800ac2a <HAL_RCCEx_PeriphCLKConfig+0x892>
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 800a8d0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a8d4:	f8d4 109c 	ldr.w	r1, [r4, #156]	; 0x9c
 800a8d8:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a8dc:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800a8de:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 800a8e2:	430b      	orrs	r3, r1
 800a8e4:	6593      	str	r3, [r2, #88]	; 0x58
 800a8e6:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 800a8e8:	0719      	lsls	r1, r3, #28
 800a8ea:	d513      	bpl.n	800a914 <HAL_RCCEx_PeriphCLKConfig+0x57c>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 800a8ec:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800a8f0:	f432 5340 	bics.w	r3, r2, #12288	; 0x3000
 800a8f4:	f040 8385 	bne.w	800b002 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    if ((PeriphClkInit->I2c123ClockSelection )== RCC_I2C123CLKSOURCE_PLL3 )
 800a8f8:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800a8fc:	f000 82b8 	beq.w	800ae70 <HAL_RCCEx_PeriphCLKConfig+0xad8>
      __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 800a900:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800a904:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800a908:	6d4b      	ldr	r3, [r1, #84]	; 0x54
 800a90a:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 800a90e:	4313      	orrs	r3, r2
 800a910:	654b      	str	r3, [r1, #84]	; 0x54
 800a912:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 800a914:	06da      	lsls	r2, r3, #27
 800a916:	d519      	bpl.n	800a94c <HAL_RCCEx_PeriphCLKConfig+0x5b4>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 800a918:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800a91c:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800a920:	bf18      	it	ne
 800a922:	f5b2 5f40 	cmpne.w	r2, #12288	; 0x3000
 800a926:	d003      	beq.n	800a930 <HAL_RCCEx_PeriphCLKConfig+0x598>
 800a928:	f432 7380 	bics.w	r3, r2, #256	; 0x100
 800a92c:	f040 8374 	bne.w	800b018 <HAL_RCCEx_PeriphCLKConfig+0xc80>
    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3 )
 800a930:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800a934:	f000 82a8 	beq.w	800ae88 <HAL_RCCEx_PeriphCLKConfig+0xaf0>
      __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 800a938:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800a93c:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800a940:	6d8b      	ldr	r3, [r1, #88]	; 0x58
 800a942:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800a946:	4313      	orrs	r3, r2
 800a948:	658b      	str	r3, [r1, #88]	; 0x58
 800a94a:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 800a94c:	031f      	lsls	r7, r3, #12
 800a94e:	d50e      	bpl.n	800a96e <HAL_RCCEx_PeriphCLKConfig+0x5d6>
    switch(PeriphClkInit->AdcClockSelection)
 800a950:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 800a954:	f5b1 3f80 	cmp.w	r1, #65536	; 0x10000
 800a958:	f000 8102 	beq.w	800ab60 <HAL_RCCEx_PeriphCLKConfig+0x7c8>
 800a95c:	f5b1 3f00 	cmp.w	r1, #131072	; 0x20000
 800a960:	f000 8104 	beq.w	800ab6c <HAL_RCCEx_PeriphCLKConfig+0x7d4>
 800a964:	2900      	cmp	r1, #0
 800a966:	f000 8338 	beq.w	800afda <HAL_RCCEx_PeriphCLKConfig+0xc42>
      ret = HAL_ERROR;
 800a96a:	2601      	movs	r6, #1
 800a96c:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 800a96e:	0358      	lsls	r0, r3, #13
 800a970:	d50f      	bpl.n	800a992 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
    switch(PeriphClkInit->UsbClockSelection)
 800a972:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800a976:	f5b2 1f00 	cmp.w	r2, #2097152	; 0x200000
 800a97a:	f000 8106 	beq.w	800ab8a <HAL_RCCEx_PeriphCLKConfig+0x7f2>
 800a97e:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
 800a982:	f000 8108 	beq.w	800ab96 <HAL_RCCEx_PeriphCLKConfig+0x7fe>
 800a986:	f5b2 1f80 	cmp.w	r2, #1048576	; 0x100000
 800a98a:	f000 832e 	beq.w	800afea <HAL_RCCEx_PeriphCLKConfig+0xc52>
      ret = HAL_ERROR;
 800a98e:	2601      	movs	r6, #1
 800a990:	4635      	mov	r5, r6
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 800a992:	03d9      	lsls	r1, r3, #15
 800a994:	d515      	bpl.n	800a9c2 <HAL_RCCEx_PeriphCLKConfig+0x62a>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 800a996:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800a998:	f433 3280 	bics.w	r2, r3, #65536	; 0x10000
 800a99c:	f040 81a1 	bne.w	800ace2 <HAL_RCCEx_PeriphCLKConfig+0x94a>
    switch(PeriphClkInit->SdmmcClockSelection)
 800a9a0:	2b00      	cmp	r3, #0
 800a9a2:	f000 815f 	beq.w	800ac64 <HAL_RCCEx_PeriphCLKConfig+0x8cc>
 800a9a6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800a9aa:	f040 814a 	bne.w	800ac42 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800a9ae:	2102      	movs	r1, #2
 800a9b0:	1d20      	adds	r0, r4, #4
 800a9b2:	f7ff fadd 	bl	8009f70 <RCCEx_PLL2_Config>
 800a9b6:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800a9b8:	2d00      	cmp	r5, #0
 800a9ba:	f000 815e 	beq.w	800ac7a <HAL_RCCEx_PeriphCLKConfig+0x8e2>
 800a9be:	6823      	ldr	r3, [r4, #0]
 800a9c0:	462e      	mov	r6, r5
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 800a9c2:	009a      	lsls	r2, r3, #2
 800a9c4:	f100 810a 	bmi.w	800abdc <HAL_RCCEx_PeriphCLKConfig+0x844>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 800a9c8:	039f      	lsls	r7, r3, #14
 800a9ca:	d440      	bmi.n	800aa4e <HAL_RCCEx_PeriphCLKConfig+0x6b6>
 800a9cc:	3600      	adds	r6, #0
 800a9ce:	bf18      	it	ne
 800a9d0:	2601      	movne	r6, #1
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 800a9d2:	02d8      	lsls	r0, r3, #11
 800a9d4:	d50e      	bpl.n	800a9f4 <HAL_RCCEx_PeriphCLKConfig+0x65c>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 800a9d6:	6f21      	ldr	r1, [r4, #112]	; 0x70
 800a9d8:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 800a9dc:	f040 8177 	bne.w	800acce <HAL_RCCEx_PeriphCLKConfig+0x936>
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 800a9e0:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800a9e4:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800a9e8:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800a9ea:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800a9ee:	430b      	orrs	r3, r1
 800a9f0:	6513      	str	r3, [r2, #80]	; 0x50
 800a9f2:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 800a9f4:	0299      	lsls	r1, r3, #10
 800a9f6:	d50e      	bpl.n	800aa16 <HAL_RCCEx_PeriphCLKConfig+0x67e>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 800a9f8:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800a9fa:	f031 7380 	bics.w	r3, r1, #16777216	; 0x1000000
 800a9fe:	f040 817d 	bne.w	800acfc <HAL_RCCEx_PeriphCLKConfig+0x964>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 800aa02:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aa06:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aa0a:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800aa0c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800aa10:	430b      	orrs	r3, r1
 800aa12:	6513      	str	r3, [r2, #80]	; 0x50
 800aa14:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 800aa16:	005a      	lsls	r2, r3, #1
 800aa18:	d513      	bpl.n	800aa42 <HAL_RCCEx_PeriphCLKConfig+0x6aa>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 800aa1a:	f8d4 30b8 	ldr.w	r3, [r4, #184]	; 0xb8
 800aa1e:	f433 4300 	bics.w	r3, r3, #32768	; 0x8000
 800aa22:	f040 8175 	bne.w	800ad10 <HAL_RCCEx_PeriphCLKConfig+0x978>
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 800aa26:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800aa2a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800aa2e:	691a      	ldr	r2, [r3, #16]
 800aa30:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800aa34:	611a      	str	r2, [r3, #16]
 800aa36:	691a      	ldr	r2, [r3, #16]
 800aa38:	f8d4 10b8 	ldr.w	r1, [r4, #184]	; 0xb8
 800aa3c:	430a      	orrs	r2, r1
 800aa3e:	611a      	str	r2, [r3, #16]
 800aa40:	6823      	ldr	r3, [r4, #0]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 800aa42:	2b00      	cmp	r3, #0
 800aa44:	f2c0 80b6 	blt.w	800abb4 <HAL_RCCEx_PeriphCLKConfig+0x81c>
}
 800aa48:	4630      	mov	r0, r6
 800aa4a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    switch(PeriphClkInit->RngClockSelection)
 800aa4e:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
 800aa50:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800aa54:	f000 80f9 	beq.w	800ac4a <HAL_RCCEx_PeriphCLKConfig+0x8b2>
 800aa58:	f240 816c 	bls.w	800ad34 <HAL_RCCEx_PeriphCLKConfig+0x99c>
 800aa5c:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 800aa60:	f000 80fb 	beq.w	800ac5a <HAL_RCCEx_PeriphCLKConfig+0x8c2>
 800aa64:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 800aa68:	f000 80f7 	beq.w	800ac5a <HAL_RCCEx_PeriphCLKConfig+0x8c2>
 800aa6c:	2601      	movs	r6, #1
 800aa6e:	e7b0      	b.n	800a9d2 <HAL_RCCEx_PeriphCLKConfig+0x63a>
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
 800aa70:	f44f 4363 	mov.w	r3, #58112	; 0xe300
 800aa74:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800aa78:	f2c0 0303 	movt	r3, #3
 800aa7c:	429a      	cmp	r2, r3
 800aa7e:	f43f ae28 	beq.w	800a6d2 <HAL_RCCEx_PeriphCLKConfig+0x33a>
 800aa82:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800aa86:	f44f 715a 	mov.w	r1, #872	; 0x368
 800aa8a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800aa8e:	f00a feeb 	bl	8015868 <assert_failed>
 800aa92:	e61e      	b.n	800a6d2 <HAL_RCCEx_PeriphCLKConfig+0x33a>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800aa94:	2101      	movs	r1, #1
 800aa96:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800aa9a:	f7ff fb73 	bl	800a184 <RCCEx_PLL3_Config>
 800aa9e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800aaa0:	2d00      	cmp	r5, #0
 800aaa2:	f040 80b0 	bne.w	800ac06 <HAL_RCCEx_PeriphCLKConfig+0x86e>
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800aaa6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aaaa:	f8d4 1090 	ldr.w	r1, [r4, #144]	; 0x90
 800aaae:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aab2:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800aab4:	f023 0307 	bic.w	r3, r3, #7
 800aab8:	430b      	orrs	r3, r1
 800aaba:	6593      	str	r3, [r2, #88]	; 0x58
 800aabc:	6823      	ldr	r3, [r4, #0]
 800aabe:	e6aa      	b.n	800a816 <HAL_RCCEx_PeriphCLKConfig+0x47e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800aac0:	2101      	movs	r1, #1
 800aac2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800aac6:	f7ff fb5d 	bl	800a184 <RCCEx_PLL3_Config>
 800aaca:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800aacc:	2d00      	cmp	r5, #0
 800aace:	f040 809d 	bne.w	800ac0c <HAL_RCCEx_PeriphCLKConfig+0x874>
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 800aad2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aad6:	6f61      	ldr	r1, [r4, #116]	; 0x74
 800aad8:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aadc:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800aade:	f023 0307 	bic.w	r3, r3, #7
 800aae2:	430b      	orrs	r3, r1
 800aae4:	6553      	str	r3, [r2, #84]	; 0x54
 800aae6:	6823      	ldr	r3, [r4, #0]
 800aae8:	e685      	b.n	800a7f6 <HAL_RCCEx_PeriphCLKConfig+0x45e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800aaea:	2102      	movs	r1, #2
 800aaec:	1d20      	adds	r0, r4, #4
 800aaee:	f7ff fa3f 	bl	8009f70 <RCCEx_PLL2_Config>
 800aaf2:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800aaf4:	2d00      	cmp	r5, #0
 800aaf6:	f040 8083 	bne.w	800ac00 <HAL_RCCEx_PeriphCLKConfig+0x868>
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 800aafa:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aafe:	6c61      	ldr	r1, [r4, #68]	; 0x44
 800ab00:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ab04:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800ab06:	f023 0303 	bic.w	r3, r3, #3
 800ab0a:	430b      	orrs	r3, r1
 800ab0c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800ab0e:	6823      	ldr	r3, [r4, #0]
 800ab10:	e54a      	b.n	800a5a8 <HAL_RCCEx_PeriphCLKConfig+0x210>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800ab12:	2101      	movs	r1, #1
 800ab14:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ab18:	f7ff fb34 	bl	800a184 <RCCEx_PLL3_Config>
 800ab1c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ab1e:	2d00      	cmp	r5, #0
 800ab20:	d16b      	bne.n	800abfa <HAL_RCCEx_PeriphCLKConfig+0x862>
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 800ab22:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ab26:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 800ab28:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ab2c:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800ab2e:	f023 0338 	bic.w	r3, r3, #56	; 0x38
 800ab32:	430b      	orrs	r3, r1
 800ab34:	6553      	str	r3, [r2, #84]	; 0x54
 800ab36:	6823      	ldr	r3, [r4, #0]
 800ab38:	e64e      	b.n	800a7d8 <HAL_RCCEx_PeriphCLKConfig+0x440>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ab3a:	2101      	movs	r1, #1
 800ab3c:	1d20      	adds	r0, r4, #4
 800ab3e:	f7ff fa17 	bl	8009f70 <RCCEx_PLL2_Config>
 800ab42:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ab44:	2d00      	cmp	r5, #0
 800ab46:	d179      	bne.n	800ac3c <HAL_RCCEx_PeriphCLKConfig+0x8a4>
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800ab48:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ab4c:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 800ab4e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ab52:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800ab54:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800ab58:	430b      	orrs	r3, r1
 800ab5a:	6513      	str	r3, [r2, #80]	; 0x50
 800ab5c:	6823      	ldr	r3, [r4, #0]
 800ab5e:	e516      	b.n	800a58e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800ab60:	2102      	movs	r1, #2
 800ab62:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ab66:	f7ff fb0d 	bl	800a184 <RCCEx_PLL3_Config>
 800ab6a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ab6c:	2d00      	cmp	r5, #0
 800ab6e:	d153      	bne.n	800ac18 <HAL_RCCEx_PeriphCLKConfig+0x880>
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800ab70:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ab74:	f8d4 10a0 	ldr.w	r1, [r4, #160]	; 0xa0
 800ab78:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ab7c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800ab7e:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 800ab82:	430b      	orrs	r3, r1
 800ab84:	6593      	str	r3, [r2, #88]	; 0x58
 800ab86:	6823      	ldr	r3, [r4, #0]
 800ab88:	e6f1      	b.n	800a96e <HAL_RCCEx_PeriphCLKConfig+0x5d6>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800ab8a:	2101      	movs	r1, #1
 800ab8c:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ab90:	f7ff faf8 	bl	800a184 <RCCEx_PLL3_Config>
 800ab94:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ab96:	2d00      	cmp	r5, #0
 800ab98:	d13b      	bne.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x87a>
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 800ab9a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ab9e:	f8d4 1084 	ldr.w	r1, [r4, #132]	; 0x84
 800aba2:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aba6:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800aba8:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 800abac:	430b      	orrs	r3, r1
 800abae:	6553      	str	r3, [r2, #84]	; 0x54
 800abb0:	6823      	ldr	r3, [r4, #0]
 800abb2:	e6ee      	b.n	800a992 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 800abb4:	6d21      	ldr	r1, [r4, #80]	; 0x50
 800abb6:	f031 5380 	bics.w	r3, r1, #268435456	; 0x10000000
 800abba:	d003      	beq.n	800abc4 <HAL_RCCEx_PeriphCLKConfig+0x82c>
 800abbc:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 800abc0:	f040 8201 	bne.w	800afc6 <HAL_RCCEx_PeriphCLKConfig+0xc2e>
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 800abc4:	f44f 4288 	mov.w	r2, #17408	; 0x4400
}
 800abc8:	4630      	mov	r0, r6
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 800abca:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800abce:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800abd0:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 800abd4:	430b      	orrs	r3, r1
 800abd6:	64d3      	str	r3, [r2, #76]	; 0x4c
}
 800abd8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!=HAL_OK)
 800abdc:	2102      	movs	r1, #2
 800abde:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800abe2:	f7ff facf 	bl	800a184 <RCCEx_PLL3_Config>
 800abe6:	6823      	ldr	r3, [r4, #0]
 800abe8:	2800      	cmp	r0, #0
 800abea:	f43f aeed 	beq.w	800a9c8 <HAL_RCCEx_PeriphCLKConfig+0x630>
      status=HAL_ERROR;
 800abee:	2601      	movs	r6, #1
 800abf0:	e6ea      	b.n	800a9c8 <HAL_RCCEx_PeriphCLKConfig+0x630>
            ret = HAL_TIMEOUT;
 800abf2:	2603      	movs	r6, #3
 800abf4:	6823      	ldr	r3, [r4, #0]
 800abf6:	4635      	mov	r5, r6
 800abf8:	e5bc      	b.n	800a774 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
 800abfa:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800abfc:	462e      	mov	r6, r5
 800abfe:	e5eb      	b.n	800a7d8 <HAL_RCCEx_PeriphCLKConfig+0x440>
 800ac00:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac02:	462e      	mov	r6, r5
 800ac04:	e4d0      	b.n	800a5a8 <HAL_RCCEx_PeriphCLKConfig+0x210>
 800ac06:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac08:	462e      	mov	r6, r5
 800ac0a:	e604      	b.n	800a816 <HAL_RCCEx_PeriphCLKConfig+0x47e>
 800ac0c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac0e:	462e      	mov	r6, r5
 800ac10:	e5f1      	b.n	800a7f6 <HAL_RCCEx_PeriphCLKConfig+0x45e>
 800ac12:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac14:	462e      	mov	r6, r5
 800ac16:	e6bc      	b.n	800a992 <HAL_RCCEx_PeriphCLKConfig+0x5fa>
 800ac18:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac1a:	462e      	mov	r6, r5
 800ac1c:	e6a7      	b.n	800a96e <HAL_RCCEx_PeriphCLKConfig+0x5d6>
 800ac1e:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac20:	462e      	mov	r6, r5
 800ac22:	e4a4      	b.n	800a56e <HAL_RCCEx_PeriphCLKConfig+0x1d6>
 800ac24:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac26:	462e      	mov	r6, r5
 800ac28:	e47e      	b.n	800a528 <HAL_RCCEx_PeriphCLKConfig+0x190>
 800ac2a:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac2c:	462e      	mov	r6, r5
 800ac2e:	e65b      	b.n	800a8e8 <HAL_RCCEx_PeriphCLKConfig+0x550>
 800ac30:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac32:	462e      	mov	r6, r5
 800ac34:	e635      	b.n	800a8a2 <HAL_RCCEx_PeriphCLKConfig+0x50a>
 800ac36:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac38:	462e      	mov	r6, r5
 800ac3a:	e60f      	b.n	800a85c <HAL_RCCEx_PeriphCLKConfig+0x4c4>
 800ac3c:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800ac3e:	462e      	mov	r6, r5
 800ac40:	e4a5      	b.n	800a58e <HAL_RCCEx_PeriphCLKConfig+0x1f6>
      ret = HAL_ERROR;
 800ac42:	2601      	movs	r6, #1
 800ac44:	6823      	ldr	r3, [r4, #0]
 800ac46:	4635      	mov	r5, r6
 800ac48:	e6bb      	b.n	800a9c2 <HAL_RCCEx_PeriphCLKConfig+0x62a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ac4a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800ac4e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800ac52:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ac54:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800ac58:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800ac5a:	2d00      	cmp	r5, #0
 800ac5c:	d06f      	beq.n	800ad3e <HAL_RCCEx_PeriphCLKConfig+0x9a6>
 800ac5e:	6823      	ldr	r3, [r4, #0]
 800ac60:	2601      	movs	r6, #1
 800ac62:	e6b6      	b.n	800a9d2 <HAL_RCCEx_PeriphCLKConfig+0x63a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ac64:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800ac68:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800ac6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ac6e:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800ac72:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800ac74:	2d00      	cmp	r5, #0
 800ac76:	f47f aea2 	bne.w	800a9be <HAL_RCCEx_PeriphCLKConfig+0x626>
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 800ac7a:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ac7e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800ac80:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ac84:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800ac86:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800ac8a:	430b      	orrs	r3, r1
 800ac8c:	64d3      	str	r3, [r2, #76]	; 0x4c
 800ac8e:	6823      	ldr	r3, [r4, #0]
 800ac90:	e697      	b.n	800a9c2 <HAL_RCCEx_PeriphCLKConfig+0x62a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ac92:	2101      	movs	r1, #1
 800ac94:	1d20      	adds	r0, r4, #4
 800ac96:	f7ff f96b 	bl	8009f70 <RCCEx_PLL2_Config>
 800ac9a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ac9c:	2d00      	cmp	r5, #0
 800ac9e:	f43f af18 	beq.w	800aad2 <HAL_RCCEx_PeriphCLKConfig+0x73a>
 800aca2:	e7b3      	b.n	800ac0c <HAL_RCCEx_PeriphCLKConfig+0x874>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800aca4:	2101      	movs	r1, #1
 800aca6:	1d20      	adds	r0, r4, #4
 800aca8:	f7ff f962 	bl	8009f70 <RCCEx_PLL2_Config>
 800acac:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800acae:	2d00      	cmp	r5, #0
 800acb0:	f43f aef9 	beq.w	800aaa6 <HAL_RCCEx_PeriphCLKConfig+0x70e>
 800acb4:	e7a7      	b.n	800ac06 <HAL_RCCEx_PeriphCLKConfig+0x86e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800acb6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800acba:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800acbe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800acc0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800acc4:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800acc6:	2d00      	cmp	r5, #0
 800acc8:	f43f af17 	beq.w	800aafa <HAL_RCCEx_PeriphCLKConfig+0x762>
 800accc:	e798      	b.n	800ac00 <HAL_RCCEx_PeriphCLKConfig+0x868>
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));
 800acce:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800acd2:	f240 51bd 	movw	r1, #1469	; 0x5bd
 800acd6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800acda:	f00a fdc5 	bl	8015868 <assert_failed>
 800acde:	6f21      	ldr	r1, [r4, #112]	; 0x70
 800ace0:	e67e      	b.n	800a9e0 <HAL_RCCEx_PeriphCLKConfig+0x648>
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));
 800ace2:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800ace6:	f240 515e 	movw	r1, #1374	; 0x55e
 800acea:	f6c0 0002 	movt	r0, #2050	; 0x802
 800acee:	f00a fdbb 	bl	8015868 <assert_failed>
 800acf2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    switch(PeriphClkInit->SdmmcClockSelection)
 800acf4:	2b00      	cmp	r3, #0
 800acf6:	f47f ae56 	bne.w	800a9a6 <HAL_RCCEx_PeriphCLKConfig+0x60e>
 800acfa:	e7b3      	b.n	800ac64 <HAL_RCCEx_PeriphCLKConfig+0x8cc>
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));
 800acfc:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800ad00:	f240 51d1 	movw	r1, #1489	; 0x5d1
 800ad04:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ad08:	f00a fdae 	bl	8015868 <assert_failed>
 800ad0c:	6ea1      	ldr	r1, [r4, #104]	; 0x68
 800ad0e:	e678      	b.n	800aa02 <HAL_RCCEx_PeriphCLKConfig+0x66a>
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
 800ad10:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800ad14:	f240 51e7 	movw	r1, #1511	; 0x5e7
 800ad18:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ad1c:	f00a fda4 	bl	8015868 <assert_failed>
 800ad20:	e681      	b.n	800aa26 <HAL_RCCEx_PeriphCLKConfig+0x68e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_Q_UPDATE);
 800ad22:	2101      	movs	r1, #1
 800ad24:	1d20      	adds	r0, r4, #4
 800ad26:	f7ff f923 	bl	8009f70 <RCCEx_PLL2_Config>
 800ad2a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ad2c:	2d00      	cmp	r5, #0
 800ad2e:	f43f aef8 	beq.w	800ab22 <HAL_RCCEx_PeriphCLKConfig+0x78a>
 800ad32:	e762      	b.n	800abfa <HAL_RCCEx_PeriphCLKConfig+0x862>
    switch(PeriphClkInit->RngClockSelection)
 800ad34:	2a00      	cmp	r2, #0
 800ad36:	f47f ae99 	bne.w	800aa6c <HAL_RCCEx_PeriphCLKConfig+0x6d4>
    if(ret == HAL_OK)
 800ad3a:	2d00      	cmp	r5, #0
 800ad3c:	d18f      	bne.n	800ac5e <HAL_RCCEx_PeriphCLKConfig+0x8c6>
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 800ad3e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ad42:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 800ad44:	3600      	adds	r6, #0
 800ad46:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ad4a:	bf18      	it	ne
 800ad4c:	2601      	movne	r6, #1
 800ad4e:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800ad50:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800ad54:	430b      	orrs	r3, r1
 800ad56:	6553      	str	r3, [r2, #84]	; 0x54
 800ad58:	6823      	ldr	r3, [r4, #0]
 800ad5a:	e63a      	b.n	800a9d2 <HAL_RCCEx_PeriphCLKConfig+0x63a>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ad5c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800ad60:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800ad64:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ad66:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800ad6a:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800ad6c:	b155      	cbz	r5, 800ad84 <HAL_RCCEx_PeriphCLKConfig+0x9ec>
 800ad6e:	6823      	ldr	r3, [r4, #0]
 800ad70:	462e      	mov	r6, r5
 800ad72:	f7ff bb9e 	b.w	800a4b2 <HAL_RCCEx_PeriphCLKConfig+0x11a>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800ad76:	2102      	movs	r1, #2
 800ad78:	1d20      	adds	r0, r4, #4
 800ad7a:	f7ff f8f9 	bl	8009f70 <RCCEx_PLL2_Config>
 800ad7e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ad80:	2d00      	cmp	r5, #0
 800ad82:	d1f4      	bne.n	800ad6e <HAL_RCCEx_PeriphCLKConfig+0x9d6>
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 800ad84:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ad88:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800ad8a:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ad8e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 800ad90:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800ad94:	430b      	orrs	r3, r1
 800ad96:	64d3      	str	r3, [r2, #76]	; 0x4c
 800ad98:	6823      	ldr	r3, [r4, #0]
 800ad9a:	f7ff bb8a 	b.w	800a4b2 <HAL_RCCEx_PeriphCLKConfig+0x11a>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800ad9e:	2101      	movs	r1, #1
 800ada0:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ada4:	f7ff f9ee 	bl	800a184 <RCCEx_PLL3_Config>
 800ada8:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800adaa:	2d00      	cmp	r5, #0
 800adac:	f43f abb1 	beq.w	800a512 <HAL_RCCEx_PeriphCLKConfig+0x17a>
 800adb0:	e738      	b.n	800ac24 <HAL_RCCEx_PeriphCLKConfig+0x88c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_Q_UPDATE);
 800adb2:	2101      	movs	r1, #1
 800adb4:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800adb8:	f7ff f9e4 	bl	800a184 <RCCEx_PLL3_Config>
 800adbc:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800adbe:	2d00      	cmp	r5, #0
 800adc0:	f43f abc9 	beq.w	800a556 <HAL_RCCEx_PeriphCLKConfig+0x1be>
 800adc4:	e72b      	b.n	800ac1e <HAL_RCCEx_PeriphCLKConfig+0x886>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800adc6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800adca:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800adce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800add0:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800add4:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800add6:	2d00      	cmp	r5, #0
 800add8:	f43f aeb6 	beq.w	800ab48 <HAL_RCCEx_PeriphCLKConfig+0x7b0>
 800addc:	e72e      	b.n	800ac3c <HAL_RCCEx_PeriphCLKConfig+0x8a4>
    switch(PeriphClkInit->Sai1ClockSelection)
 800adde:	4635      	mov	r5, r6
    if(ret == HAL_OK)
 800ade0:	b365      	cbz	r5, 800ae3c <HAL_RCCEx_PeriphCLKConfig+0xaa4>
 800ade2:	6823      	ldr	r3, [r4, #0]
 800ade4:	462e      	mov	r6, r5
 800ade6:	f7ff bb06 	b.w	800a3f6 <HAL_RCCEx_PeriphCLKConfig+0x5e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800adea:	2102      	movs	r1, #2
 800adec:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800adf0:	f7ff f9c8 	bl	800a184 <RCCEx_PLL3_Config>
 800adf4:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800adf6:	2d00      	cmp	r5, #0
 800adf8:	f43f ad6a 	beq.w	800a8d0 <HAL_RCCEx_PeriphCLKConfig+0x538>
 800adfc:	e715      	b.n	800ac2a <HAL_RCCEx_PeriphCLKConfig+0x892>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800adfe:	2102      	movs	r1, #2
 800ae00:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae04:	f7ff f9be 	bl	800a184 <RCCEx_PLL3_Config>
 800ae08:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ae0a:	2d00      	cmp	r5, #0
 800ae0c:	f43f ad3d 	beq.w	800a88a <HAL_RCCEx_PeriphCLKConfig+0x4f2>
 800ae10:	e70e      	b.n	800ac30 <HAL_RCCEx_PeriphCLKConfig+0x898>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800ae12:	2102      	movs	r1, #2
 800ae14:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae18:	f7ff f9b4 	bl	800a184 <RCCEx_PLL3_Config>
 800ae1c:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800ae1e:	2d00      	cmp	r5, #0
 800ae20:	f43f ad10 	beq.w	800a844 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
 800ae24:	e707      	b.n	800ac36 <HAL_RCCEx_PeriphCLKConfig+0x89e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ae26:	f44f 4388 	mov.w	r3, #17408	; 0x4400
      break;
 800ae2a:	4635      	mov	r5, r6
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800ae2c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800ae30:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800ae32:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800ae36:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800ae38:	2d00      	cmp	r5, #0
 800ae3a:	d1d2      	bne.n	800ade2 <HAL_RCCEx_PeriphCLKConfig+0xa4a>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800ae3c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ae40:	6d61      	ldr	r1, [r4, #84]	; 0x54
 800ae42:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800ae46:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800ae48:	f023 0307 	bic.w	r3, r3, #7
 800ae4c:	430b      	orrs	r3, r1
 800ae4e:	6513      	str	r3, [r2, #80]	; 0x50
 800ae50:	6823      	ldr	r3, [r4, #0]
 800ae52:	f7ff bad0 	b.w	800a3f6 <HAL_RCCEx_PeriphCLKConfig+0x5e>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800ae56:	2100      	movs	r1, #0
 800ae58:	1d20      	adds	r0, r4, #4
 800ae5a:	f7ff f889 	bl	8009f70 <RCCEx_PLL2_Config>
 800ae5e:	4605      	mov	r5, r0
      break;
 800ae60:	e7be      	b.n	800ade0 <HAL_RCCEx_PeriphCLKConfig+0xa48>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800ae62:	2100      	movs	r1, #0
 800ae64:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae68:	f7ff f98c 	bl	800a184 <RCCEx_PLL3_Config>
 800ae6c:	4605      	mov	r5, r0
      break;
 800ae6e:	e7b7      	b.n	800ade0 <HAL_RCCEx_PeriphCLKConfig+0xa48>
        if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800ae70:	2102      	movs	r1, #2
 800ae72:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae76:	f7ff f985 	bl	800a184 <RCCEx_PLL3_Config>
 800ae7a:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800ae7e:	2800      	cmp	r0, #0
 800ae80:	f43f ad3e 	beq.w	800a900 <HAL_RCCEx_PeriphCLKConfig+0x568>
          status = HAL_ERROR;
 800ae84:	2601      	movs	r6, #1
 800ae86:	e53b      	b.n	800a900 <HAL_RCCEx_PeriphCLKConfig+0x568>
      if(RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE)!= HAL_OK)
 800ae88:	2102      	movs	r1, #2
 800ae8a:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800ae8e:	f7ff f979 	bl	800a184 <RCCEx_PLL3_Config>
 800ae92:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800ae96:	2800      	cmp	r0, #0
 800ae98:	f43f ad4e 	beq.w	800a938 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
        status = HAL_ERROR;
 800ae9c:	2601      	movs	r6, #1
 800ae9e:	e54b      	b.n	800a938 <HAL_RCCEx_PeriphCLKConfig+0x5a0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800aea0:	2100      	movs	r1, #0
 800aea2:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800aea6:	f7ff f96d 	bl	800a184 <RCCEx_PLL3_Config>
 800aeaa:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800aeac:	2d00      	cmp	r5, #0
 800aeae:	f47f ab18 	bne.w	800a4e2 <HAL_RCCEx_PeriphCLKConfig+0x14a>
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 800aeb2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aeb6:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800aeb8:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aebc:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800aebe:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 800aec2:	430b      	orrs	r3, r1
 800aec4:	6513      	str	r3, [r2, #80]	; 0x50
 800aec6:	6823      	ldr	r3, [r4, #0]
 800aec8:	f7ff bb0d 	b.w	800a4e6 <HAL_RCCEx_PeriphCLKConfig+0x14e>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800aecc:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800aed0:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800aed4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aed6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800aeda:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800aedc:	2d00      	cmp	r5, #0
 800aede:	f47f aad6 	bne.w	800a48e <HAL_RCCEx_PeriphCLKConfig+0xf6>
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 800aee2:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800aee6:	f8d4 10a8 	ldr.w	r1, [r4, #168]	; 0xa8
 800aeea:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800aeee:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800aef0:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 800aef4:	430b      	orrs	r3, r1
 800aef6:	6593      	str	r3, [r2, #88]	; 0x58
 800aef8:	6823      	ldr	r3, [r4, #0]
 800aefa:	f7ff baca 	b.w	800a492 <HAL_RCCEx_PeriphCLKConfig+0xfa>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_R_UPDATE);
 800aefe:	2102      	movs	r1, #2
 800af00:	3004      	adds	r0, #4
 800af02:	f7ff f835 	bl	8009f70 <RCCEx_PLL2_Config>
 800af06:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 800af08:	2e00      	cmp	r6, #0
 800af0a:	f47f aa65 	bne.w	800a3d8 <HAL_RCCEx_PeriphCLKConfig+0x40>
 800af0e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800af10:	f7ff ba58 	b.w	800a3c4 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800af14:	2100      	movs	r1, #0
 800af16:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800af1a:	f7ff f933 	bl	800a184 <RCCEx_PLL3_Config>
 800af1e:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800af20:	2d00      	cmp	r5, #0
 800af22:	f47f aa7e 	bne.w	800a422 <HAL_RCCEx_PeriphCLKConfig+0x8a>
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 800af26:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800af2a:	6da1      	ldr	r1, [r4, #88]	; 0x58
 800af2c:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800af30:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800af32:	f423 73e0 	bic.w	r3, r3, #448	; 0x1c0
 800af36:	430b      	orrs	r3, r1
 800af38:	6513      	str	r3, [r2, #80]	; 0x50
 800af3a:	6823      	ldr	r3, [r4, #0]
 800af3c:	f7ff ba73 	b.w	800a426 <HAL_RCCEx_PeriphCLKConfig+0x8e>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_P_UPDATE);
 800af40:	2100      	movs	r1, #0
 800af42:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800af46:	f7ff f91d 	bl	800a184 <RCCEx_PLL3_Config>
 800af4a:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800af4c:	2d00      	cmp	r5, #0
 800af4e:	f47f aa83 	bne.w	800a458 <HAL_RCCEx_PeriphCLKConfig+0xc0>
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 800af52:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800af56:	f8d4 10a4 	ldr.w	r1, [r4, #164]	; 0xa4
 800af5a:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800af5e:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800af60:	f423 0360 	bic.w	r3, r3, #14680064	; 0xe00000
 800af64:	430b      	orrs	r3, r1
 800af66:	6593      	str	r3, [r2, #88]	; 0x58
 800af68:	6823      	ldr	r3, [r4, #0]
 800af6a:	f7ff ba77 	b.w	800a45c <HAL_RCCEx_PeriphCLKConfig+0xc4>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 800af6e:	2100      	movs	r1, #0
 800af70:	f104 0024 	add.w	r0, r4, #36	; 0x24
 800af74:	f7ff f906 	bl	800a184 <RCCEx_PLL3_Config>
 800af78:	4605      	mov	r5, r0
      break;
 800af7a:	f7ff ba85 	b.w	800a488 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3),DIVIDER_R_UPDATE);
 800af7e:	2102      	movs	r1, #2
 800af80:	3024      	adds	r0, #36	; 0x24
 800af82:	f7ff f8ff 	bl	800a184 <RCCEx_PLL3_Config>
 800af86:	4606      	mov	r6, r0
      break;
 800af88:	e7be      	b.n	800af08 <HAL_RCCEx_PeriphCLKConfig+0xb70>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800af8a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800af8e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800af92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800af94:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800af98:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
 800af9a:	f7ff ba3f 	b.w	800a41c <HAL_RCCEx_PeriphCLKConfig+0x84>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800af9e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800afa2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800afa6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800afa8:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800afac:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
 800afae:	f7ff ba95 	b.w	800a4dc <HAL_RCCEx_PeriphCLKConfig+0x144>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800afb2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800afb6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800afba:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800afbc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800afc0:	62da      	str	r2, [r3, #44]	; 0x2c
      break;
 800afc2:	f7ff ba46 	b.w	800a452 <HAL_RCCEx_PeriphCLKConfig+0xba>
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));
 800afc6:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800afca:	f240 51f1 	movw	r1, #1521	; 0x5f1
 800afce:	f6c0 0002 	movt	r0, #2050	; 0x802
 800afd2:	f00a fc49 	bl	8015868 <assert_failed>
 800afd6:	6d21      	ldr	r1, [r4, #80]	; 0x50
 800afd8:	e5f4      	b.n	800abc4 <HAL_RCCEx_PeriphCLKConfig+0x82c>
      ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2),DIVIDER_P_UPDATE);
 800afda:	1d20      	adds	r0, r4, #4
 800afdc:	f7fe ffc8 	bl	8009f70 <RCCEx_PLL2_Config>
 800afe0:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 800afe2:	2d00      	cmp	r5, #0
 800afe4:	f43f adc4 	beq.w	800ab70 <HAL_RCCEx_PeriphCLKConfig+0x7d8>
 800afe8:	e616      	b.n	800ac18 <HAL_RCCEx_PeriphCLKConfig+0x880>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800afea:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800afee:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800aff2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800aff4:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800aff8:	62da      	str	r2, [r3, #44]	; 0x2c
    if(ret == HAL_OK)
 800affa:	2d00      	cmp	r5, #0
 800affc:	f43f adcd 	beq.w	800ab9a <HAL_RCCEx_PeriphCLKConfig+0x802>
 800b000:	e607      	b.n	800ac12 <HAL_RCCEx_PeriphCLKConfig+0x87a>
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));
 800b002:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800b006:	f240 41e6 	movw	r1, #1254	; 0x4e6
 800b00a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b00e:	f00a fc2b 	bl	8015868 <assert_failed>
 800b012:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800b016:	e46f      	b.n	800a8f8 <HAL_RCCEx_PeriphCLKConfig+0x560>
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
 800b018:	f64d 404c 	movw	r0, #56396	; 0xdc4c
 800b01c:	f44f 619f 	mov.w	r1, #1272	; 0x4f8
 800b020:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b024:	f00a fc20 	bl	8015868 <assert_failed>
 800b028:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
 800b02c:	e480      	b.n	800a930 <HAL_RCCEx_PeriphCLKConfig+0x598>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b02e:	f44f 4788 	mov.w	r7, #17408	; 0x4400
        tickstart = HAL_GetTick();
 800b032:	f7f5 fd03 	bl	8000a3c <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b036:	f241 3888 	movw	r8, #5000	; 0x1388
        tickstart = HAL_GetTick();
 800b03a:	4681      	mov	r9, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b03c:	f6c5 0702 	movt	r7, #22530	; 0x5802
 800b040:	e006      	b.n	800b050 <HAL_RCCEx_PeriphCLKConfig+0xcb8>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800b042:	f7f5 fcfb 	bl	8000a3c <HAL_GetTick>
 800b046:	eba0 0009 	sub.w	r0, r0, r9
 800b04a:	4540      	cmp	r0, r8
 800b04c:	f63f add1 	bhi.w	800abf2 <HAL_RCCEx_PeriphCLKConfig+0x85a>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800b050:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 800b052:	079b      	lsls	r3, r3, #30
 800b054:	d5f5      	bpl.n	800b042 <HAL_RCCEx_PeriphCLKConfig+0xcaa>
 800b056:	f8d4 20b0 	ldr.w	r2, [r4, #176]	; 0xb0
 800b05a:	f7ff bb71 	b.w	800a740 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
    switch(PeriphClkInit->Lptim345ClockSelection)
 800b05e:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 800b062:	f43f ac32 	beq.w	800a8ca <HAL_RCCEx_PeriphCLKConfig+0x532>
 800b066:	f5b2 4f20 	cmp.w	r2, #40960	; 0xa000
 800b06a:	f43f ac2e 	beq.w	800a8ca <HAL_RCCEx_PeriphCLKConfig+0x532>
 800b06e:	f5b2 4fc0 	cmp.w	r2, #24576	; 0x6000
 800b072:	f43f ac2a 	beq.w	800a8ca <HAL_RCCEx_PeriphCLKConfig+0x532>
      ret = HAL_ERROR;
 800b076:	2601      	movs	r6, #1
 800b078:	4635      	mov	r5, r6
 800b07a:	e435      	b.n	800a8e8 <HAL_RCCEx_PeriphCLKConfig+0x550>
    switch(PeriphClkInit->Spi45ClockSelection)
 800b07c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
 800b080:	f43f aa44 	beq.w	800a50c <HAL_RCCEx_PeriphCLKConfig+0x174>
 800b084:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 800b088:	f43f aa40 	beq.w	800a50c <HAL_RCCEx_PeriphCLKConfig+0x174>
 800b08c:	f5b2 3f40 	cmp.w	r2, #196608	; 0x30000
 800b090:	f43f aa3c 	beq.w	800a50c <HAL_RCCEx_PeriphCLKConfig+0x174>
      ret = HAL_ERROR;
 800b094:	2601      	movs	r6, #1
 800b096:	4635      	mov	r5, r6
 800b098:	f7ff ba46 	b.w	800a528 <HAL_RCCEx_PeriphCLKConfig+0x190>
    switch(PeriphClkInit->Lptim1ClockSelection)
 800b09c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800b0a0:	f43f abcd 	beq.w	800a83e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 800b0a4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 800b0a8:	f43f abc9 	beq.w	800a83e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 800b0ac:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 800b0b0:	f43f abc5 	beq.w	800a83e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
      ret = HAL_ERROR;
 800b0b4:	2601      	movs	r6, #1
 800b0b6:	4635      	mov	r5, r6
 800b0b8:	f7ff bbd0 	b.w	800a85c <HAL_RCCEx_PeriphCLKConfig+0x4c4>
    switch(PeriphClkInit->Spi6ClockSelection)
 800b0bc:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800b0c0:	f43f aa46 	beq.w	800a550 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
 800b0c4:	f1b2 4fa0 	cmp.w	r2, #1342177280	; 0x50000000
 800b0c8:	f43f aa42 	beq.w	800a550 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
 800b0cc:	f1b2 5f40 	cmp.w	r2, #805306368	; 0x30000000
 800b0d0:	f43f aa3e 	beq.w	800a550 <HAL_RCCEx_PeriphCLKConfig+0x1b8>
      ret = HAL_ERROR;
 800b0d4:	2601      	movs	r6, #1
 800b0d6:	4635      	mov	r5, r6
 800b0d8:	f7ff ba49 	b.w	800a56e <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    switch(PeriphClkInit->Lptim2ClockSelection)
 800b0dc:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 800b0e0:	f43f abd0 	beq.w	800a884 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 800b0e4:	f5b2 5fa0 	cmp.w	r2, #5120	; 0x1400
 800b0e8:	f43f abcc 	beq.w	800a884 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
 800b0ec:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 800b0f0:	f43f abc8 	beq.w	800a884 <HAL_RCCEx_PeriphCLKConfig+0x4ec>
      ret = HAL_ERROR;
 800b0f4:	2601      	movs	r6, #1
 800b0f6:	4635      	mov	r5, r6
 800b0f8:	f7ff bbd3 	b.w	800a8a2 <HAL_RCCEx_PeriphCLKConfig+0x50a>
    switch(PeriphClkInit->Sai4AClockSelection)
 800b0fc:	f5b2 0fc0 	cmp.w	r2, #6291456	; 0x600000
 800b100:	f43f a9a7 	beq.w	800a452 <HAL_RCCEx_PeriphCLKConfig+0xba>
 800b104:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 800b108:	f43f a9a3 	beq.w	800a452 <HAL_RCCEx_PeriphCLKConfig+0xba>
      ret = HAL_ERROR;
 800b10c:	2601      	movs	r6, #1
 800b10e:	4635      	mov	r5, r6
 800b110:	f7ff b9a4 	b.w	800a45c <HAL_RCCEx_PeriphCLKConfig+0xc4>
    switch(PeriphClkInit->Sai23ClockSelection)
 800b114:	2ac0      	cmp	r2, #192	; 0xc0
 800b116:	f43f a981 	beq.w	800a41c <HAL_RCCEx_PeriphCLKConfig+0x84>
 800b11a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800b11e:	f43f a97d 	beq.w	800a41c <HAL_RCCEx_PeriphCLKConfig+0x84>
      ret = HAL_ERROR;
 800b122:	2601      	movs	r6, #1
 800b124:	4635      	mov	r5, r6
 800b126:	f7ff b97e 	b.w	800a426 <HAL_RCCEx_PeriphCLKConfig+0x8e>
    switch(PeriphClkInit->SpdifrxClockSelection)
 800b12a:	bb3a      	cbnz	r2, 800b17c <HAL_RCCEx_PeriphCLKConfig+0xde4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 800b12c:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b130:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b134:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b136:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800b13a:	62da      	str	r2, [r3, #44]	; 0x2c
 800b13c:	6e42      	ldr	r2, [r0, #100]	; 0x64
 800b13e:	f7ff b941 	b.w	800a3c4 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Spi123ClockSelection)
 800b142:	f5b2 5f40 	cmp.w	r2, #12288	; 0x3000
 800b146:	f43f a9c9 	beq.w	800a4dc <HAL_RCCEx_PeriphCLKConfig+0x144>
 800b14a:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800b14e:	f43f a9c5 	beq.w	800a4dc <HAL_RCCEx_PeriphCLKConfig+0x144>
      ret = HAL_ERROR;
 800b152:	2601      	movs	r6, #1
 800b154:	4635      	mov	r5, r6
 800b156:	f7ff b9c6 	b.w	800a4e6 <HAL_RCCEx_PeriphCLKConfig+0x14e>
    switch(PeriphClkInit->Sai4BClockSelection)
 800b15a:	f1b2 7f40 	cmp.w	r2, #50331648	; 0x3000000
 800b15e:	f43f a993 	beq.w	800a488 <HAL_RCCEx_PeriphCLKConfig+0xf0>
 800b162:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800b166:	f43f a98f 	beq.w	800a488 <HAL_RCCEx_PeriphCLKConfig+0xf0>
      ret = HAL_ERROR;
 800b16a:	2601      	movs	r6, #1
 800b16c:	4635      	mov	r5, r6
 800b16e:	f7ff b990 	b.w	800a492 <HAL_RCCEx_PeriphCLKConfig+0xfa>
    switch(PeriphClkInit->QspiClockSelection)
 800b172:	2a00      	cmp	r2, #0
 800b174:	f43f adfa 	beq.w	800ad6c <HAL_RCCEx_PeriphCLKConfig+0x9d4>
 800b178:	f7ff b999 	b.w	800a4ae <HAL_RCCEx_PeriphCLKConfig+0x116>
      ret = HAL_ERROR;
 800b17c:	2601      	movs	r6, #1
 800b17e:	f7ff b92c 	b.w	800a3da <HAL_RCCEx_PeriphCLKConfig+0x42>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 800b182:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800b186:	f64f 73cf 	movw	r3, #65487	; 0xffcf
 800b18a:	f6c5 0102 	movt	r1, #22530	; 0x5802
 800b18e:	f2c0 03ff 	movt	r3, #255	; 0xff
 800b192:	6908      	ldr	r0, [r1, #16]
 800b194:	ea03 1312 	and.w	r3, r3, r2, lsr #4
 800b198:	f420 527c 	bic.w	r2, r0, #16128	; 0x3f00
 800b19c:	4313      	orrs	r3, r2
 800b19e:	610b      	str	r3, [r1, #16]
 800b1a0:	f7ff badc 	b.w	800a75c <HAL_RCCEx_PeriphCLKConfig+0x3c4>
 800b1a4:	6823      	ldr	r3, [r4, #0]
    if(ret == HAL_OK)
 800b1a6:	462e      	mov	r6, r5
 800b1a8:	f7ff bae4 	b.w	800a774 <HAL_RCCEx_PeriphCLKConfig+0x3dc>

0800b1ac <HAL_RCCEx_GetPLL2ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b1ac:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b1b0:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
 800b1b4:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b1b6:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 800b1b8:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800b1ba:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll2m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM2)>> 12);
 800b1bc:	f3c3 3305 	ubfx	r3, r3, #12, #6
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800b1c0:	6bd5      	ldr	r5, [r2, #60]	; 0x3c
  if (pll2m != 0U)
 800b1c2:	2b00      	cmp	r3, #0
 800b1c4:	d060      	beq.n	800b288 <HAL_RCCEx_GetPLL2ClockFreq+0xdc>
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800b1c6:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll2fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) >> RCC_PLLCFGR_PLL2FRACEN_Pos;
 800b1ca:	f3c1 1100 	ubfx	r1, r1, #4, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b1ce:	f004 0403 	and.w	r4, r4, #3
 800b1d2:	ee07 3a90 	vmov	s15, r3
  fracn2 =(float_t)(uint32_t)(pll2fracen* ((RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN2)>> 3));
 800b1d6:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 800b1da:	2c01      	cmp	r4, #1
 800b1dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800b1e0:	ee06 1a90 	vmov	s13, r1
 800b1e4:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 800b1e8:	d002      	beq.n	800b1f0 <HAL_RCCEx_GetPLL2ClockFreq+0x44>
 800b1ea:	d35a      	bcc.n	800b2a2 <HAL_RCCEx_GetPLL2ClockFreq+0xf6>
 800b1ec:	2c02      	cmp	r4, #2
 800b1ee:	d050      	beq.n	800b292 <HAL_RCCEx_GetPLL2ClockFreq+0xe6>
      pll2vco = ((float_t)CSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b1f0:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b1f4:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b1f8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b1fa:	f6c4 2174 	movt	r1, #19060	; 0x4a74
 800b1fe:	ee06 1a10 	vmov	s12, r1
 800b202:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b206:	eec6 5a27 	vdiv.f32	s11, s12, s15
 800b20a:	ee07 3a10 	vmov	s14, r3
 800b20e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b212:	ee37 7a05 	vadd.f32	s14, s14, s10
 800b216:	ee77 7a26 	vadd.f32	s15, s14, s13
 800b21a:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 800b21e:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b222:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800b226:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b22a:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b22c:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800b230:	ee06 3a90 	vmov	s13, r3
 800b234:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 800b238:	bc30      	pop	{r4, r5}
    PLL2_Clocks->PLL2_P_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_P2) >>9)  + (float_t)1 )) ;
 800b23a:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b23e:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b242:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b246:	ed80 7a00 	vstr	s14, [r0]
    PLL2_Clocks->PLL2_Q_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_Q2) >>16) + (float_t)1 )) ;
 800b24a:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b24c:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800b250:	ee06 3a90 	vmov	s13, r3
 800b254:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800b258:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b25c:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b260:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b264:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL2_Clocks->PLL2_R_Frequency = (uint32_t)(float_t)(pll2vco/((float_t)(uint32_t)((RCC->PLL2DIVR & RCC_PLL2DIVR_R2) >>24) + (float_t)1 )) ;
 800b268:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b26a:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800b26e:	ee07 3a10 	vmov	s14, r3
 800b272:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b276:	ee37 7a06 	vadd.f32	s14, s14, s12
 800b27a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b27e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800b282:	edc0 6a02 	vstr	s13, [r0, #8]
}
 800b286:	4770      	bx	lr
    PLL2_Clocks->PLL2_Q_Frequency = 0U;
 800b288:	e9c0 3300 	strd	r3, r3, [r0]
    PLL2_Clocks->PLL2_R_Frequency = 0U;
 800b28c:	6083      	str	r3, [r0, #8]
}
 800b28e:	bc30      	pop	{r4, r5}
 800b290:	4770      	bx	lr
      pll2vco = ((float_t)HSE_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b292:	f64b 4120 	movw	r1, #48160	; 0xbc20
 800b296:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b298:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b29c:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
 800b2a0:	e7ad      	b.n	800b1fe <HAL_RCCEx_GetPLL2ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800b2a2:	6813      	ldr	r3, [r2, #0]
 800b2a4:	069b      	lsls	r3, r3, #26
 800b2a6:	d51d      	bpl.n	800b2e4 <HAL_RCCEx_GetPLL2ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b2a8:	6814      	ldr	r4, [r2, #0]
 800b2aa:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b2ae:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b2b0:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b2b4:	f3c4 02c1 	ubfx	r2, r4, #3, #2
 800b2b8:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b2bc:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b2c0:	40d1      	lsrs	r1, r2
        pll2vco = ( (float_t)hsivalue / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b2c2:	ee06 3a10 	vmov	s12, r3
 800b2c6:	ee05 1a90 	vmov	s11, r1
 800b2ca:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 800b2ce:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800b2d2:	ee36 6a07 	vadd.f32	s12, s12, s14
 800b2d6:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 800b2da:	ee76 7a26 	vadd.f32	s15, s12, s13
 800b2de:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b2e2:	e79c      	b.n	800b21e <HAL_RCCEx_GetPLL2ClockFreq+0x72>
        pll2vco = ((float_t)HSI_VALUE / (float_t)pll2m) * ((float_t)(uint32_t)(RCC->PLL2DIVR & RCC_PLL2DIVR_N2) + (fracn2/(float_t)0x2000) +(float_t)1 );
 800b2e4:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b2e8:	6b93      	ldr	r3, [r2, #56]	; 0x38
 800b2ea:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b2ee:	f6c4 4174 	movt	r1, #19572	; 0x4c74
 800b2f2:	e784      	b.n	800b1fe <HAL_RCCEx_GetPLL2ClockFreq+0x52>

0800b2f4 <HAL_RCCEx_GetPLL3ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b2f4:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b2f8:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
 800b2fc:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b2fe:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 800b300:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800b302:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll3m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM3)>> 20)  ;
 800b304:	f3c3 5305 	ubfx	r3, r3, #20, #6
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800b308:	6c55      	ldr	r5, [r2, #68]	; 0x44
  if (pll3m != 0U)
 800b30a:	2b00      	cmp	r3, #0
 800b30c:	d060      	beq.n	800b3d0 <HAL_RCCEx_GetPLL3ClockFreq+0xdc>
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800b30e:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll3fracen = (RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) >> RCC_PLLCFGR_PLL3FRACEN_Pos;
 800b312:	f3c1 2100 	ubfx	r1, r1, #8, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b316:	f004 0403 	and.w	r4, r4, #3
 800b31a:	ee07 3a90 	vmov	s15, r3
  fracn3 = (float_t)(uint32_t)(pll3fracen* ((RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN3)>> 3));
 800b31e:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 800b322:	2c01      	cmp	r4, #1
 800b324:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800b328:	ee06 1a90 	vmov	s13, r1
 800b32c:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 800b330:	d002      	beq.n	800b338 <HAL_RCCEx_GetPLL3ClockFreq+0x44>
 800b332:	d35a      	bcc.n	800b3ea <HAL_RCCEx_GetPLL3ClockFreq+0xf6>
 800b334:	2c02      	cmp	r4, #2
 800b336:	d050      	beq.n	800b3da <HAL_RCCEx_GetPLL3ClockFreq+0xe6>
      pll3vco = ((float_t)CSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b338:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b33c:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b340:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b342:	f6c4 2174 	movt	r1, #19060	; 0x4a74
 800b346:	ee06 1a10 	vmov	s12, r1
 800b34a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b34e:	eec6 5a27 	vdiv.f32	s11, s12, s15
 800b352:	ee07 3a10 	vmov	s14, r3
 800b356:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b35a:	ee37 7a05 	vadd.f32	s14, s14, s10
 800b35e:	ee77 7a26 	vadd.f32	s15, s14, s13
 800b362:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 800b366:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b36a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800b36e:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b372:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b374:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800b378:	ee06 3a90 	vmov	s13, r3
 800b37c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 800b380:	bc30      	pop	{r4, r5}
    PLL3_Clocks->PLL3_P_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_P3) >>9)  + (float_t)1 )) ;
 800b382:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b386:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b38a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b38e:	ed80 7a00 	vstr	s14, [r0]
    PLL3_Clocks->PLL3_Q_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_Q3) >>16) + (float_t)1 )) ;
 800b392:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b394:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800b398:	ee06 3a90 	vmov	s13, r3
 800b39c:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800b3a0:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b3a4:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b3a8:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b3ac:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL3_Clocks->PLL3_R_Frequency = (uint32_t)(float_t)(pll3vco/((float_t)(uint32_t)((RCC->PLL3DIVR & RCC_PLL3DIVR_R3) >>24) + (float_t)1 )) ;
 800b3b0:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b3b2:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800b3b6:	ee07 3a10 	vmov	s14, r3
 800b3ba:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b3be:	ee37 7a06 	vadd.f32	s14, s14, s12
 800b3c2:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b3c6:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800b3ca:	edc0 6a02 	vstr	s13, [r0, #8]
}
 800b3ce:	4770      	bx	lr
    PLL3_Clocks->PLL3_Q_Frequency = 0U;
 800b3d0:	e9c0 3300 	strd	r3, r3, [r0]
    PLL3_Clocks->PLL3_R_Frequency = 0U;
 800b3d4:	6083      	str	r3, [r0, #8]
}
 800b3d6:	bc30      	pop	{r4, r5}
 800b3d8:	4770      	bx	lr
      pll3vco = ((float_t)HSE_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b3da:	f64b 4120 	movw	r1, #48160	; 0xbc20
 800b3de:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b3e0:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b3e4:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
 800b3e8:	e7ad      	b.n	800b346 <HAL_RCCEx_GetPLL3ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800b3ea:	6813      	ldr	r3, [r2, #0]
 800b3ec:	069b      	lsls	r3, r3, #26
 800b3ee:	d51d      	bpl.n	800b42c <HAL_RCCEx_GetPLL3ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b3f0:	6814      	ldr	r4, [r2, #0]
 800b3f2:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b3f6:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b3f8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b3fc:	f3c4 02c1 	ubfx	r2, r4, #3, #2
 800b400:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b404:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b408:	40d1      	lsrs	r1, r2
        pll3vco = ((float_t)hsivalue / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b40a:	ee06 3a10 	vmov	s12, r3
 800b40e:	ee05 1a90 	vmov	s11, r1
 800b412:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 800b416:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800b41a:	ee36 6a07 	vadd.f32	s12, s12, s14
 800b41e:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 800b422:	ee76 7a26 	vadd.f32	s15, s12, s13
 800b426:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b42a:	e79c      	b.n	800b366 <HAL_RCCEx_GetPLL3ClockFreq+0x72>
        pll3vco = ((float_t)HSI_VALUE / (float_t)pll3m) * ((float_t)(uint32_t)(RCC->PLL3DIVR & RCC_PLL3DIVR_N3) + (fracn3/(float_t)0x2000) +(float_t)1 );
 800b42c:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b430:	6c13      	ldr	r3, [r2, #64]	; 0x40
 800b432:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b436:	f6c4 4174 	movt	r1, #19572	; 0x4c74
 800b43a:	e784      	b.n	800b346 <HAL_RCCEx_GetPLL3ClockFreq+0x52>

0800b43c <HAL_RCCEx_GetPLL1ClockFreq>:
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b43c:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b440:	f6c5 0202 	movt	r2, #22530	; 0x5802
{
 800b444:	b430      	push	{r4, r5}
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b446:	6a94      	ldr	r4, [r2, #40]	; 0x28
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
 800b448:	6a93      	ldr	r3, [r2, #40]	; 0x28
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800b44a:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
  pll1m = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4);
 800b44c:	f3c3 1305 	ubfx	r3, r3, #4, #6
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800b450:	6b55      	ldr	r5, [r2, #52]	; 0x34
  if (pll1m != 0U)
 800b452:	2b00      	cmp	r3, #0
 800b454:	d060      	beq.n	800b518 <HAL_RCCEx_GetPLL1ClockFreq+0xdc>
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800b456:	f3c5 05cc 	ubfx	r5, r5, #3, #13
  pll1fracen = RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN;
 800b45a:	f001 0101 	and.w	r1, r1, #1
  pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 800b45e:	f004 0403 	and.w	r4, r4, #3
 800b462:	ee07 3a90 	vmov	s15, r3
  fracn1 = (float_t)(uint32_t)(pll1fracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 800b466:	fb01 f105 	mul.w	r1, r1, r5
    switch (pllsource)
 800b46a:	2c01      	cmp	r4, #1
 800b46c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 800b470:	ee06 1a90 	vmov	s13, r1
 800b474:	eefa 6ae9 	vcvt.f32.s32	s13, s13, #13
 800b478:	d002      	beq.n	800b480 <HAL_RCCEx_GetPLL1ClockFreq+0x44>
 800b47a:	d35a      	bcc.n	800b532 <HAL_RCCEx_GetPLL1ClockFreq+0xf6>
 800b47c:	2c02      	cmp	r4, #2
 800b47e:	d050      	beq.n	800b522 <HAL_RCCEx_GetPLL1ClockFreq+0xe6>
      pll1vco = ((float_t)CSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b480:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b484:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b488:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b48a:	f6c4 2174 	movt	r1, #19060	; 0x4a74
 800b48e:	ee06 1a10 	vmov	s12, r1
 800b492:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800b496:	eec6 5a27 	vdiv.f32	s11, s12, s15
 800b49a:	ee07 3a10 	vmov	s14, r3
 800b49e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b4a2:	ee37 7a05 	vadd.f32	s14, s14, s10
 800b4a6:	ee77 7a26 	vadd.f32	s15, s14, s13
 800b4aa:	ee67 7aa5 	vmul.f32	s15, s15, s11
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
 800b4ae:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b4b2:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 800b4b6:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b4ba:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b4bc:	f3c3 2346 	ubfx	r3, r3, #9, #7
 800b4c0:	ee06 3a90 	vmov	s13, r3
 800b4c4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
}
 800b4c8:	bc30      	pop	{r4, r5}
    PLL1_Clocks->PLL1_P_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9)  + (float_t)1 )) ;
 800b4ca:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b4ce:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b4d2:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b4d6:	ed80 7a00 	vstr	s14, [r0]
    PLL1_Clocks->PLL1_Q_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_Q1) >>16) + (float_t)1 )) ;
 800b4da:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b4dc:	f3c3 4306 	ubfx	r3, r3, #16, #7
 800b4e0:	ee06 3a90 	vmov	s13, r3
 800b4e4:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 800b4e8:	ee76 6a86 	vadd.f32	s13, s13, s12
 800b4ec:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 800b4f0:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 800b4f4:	ed80 7a01 	vstr	s14, [r0, #4]
    PLL1_Clocks->PLL1_R_Frequency = (uint32_t)(float_t)(pll1vco/((float_t)(uint32_t)((RCC->PLL1DIVR & RCC_PLL1DIVR_R1) >>24) + (float_t)1 )) ;
 800b4f8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b4fa:	f3c3 6306 	ubfx	r3, r3, #24, #7
 800b4fe:	ee07 3a10 	vmov	s14, r3
 800b502:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 800b506:	ee37 7a06 	vadd.f32	s14, s14, s12
 800b50a:	eec7 6a87 	vdiv.f32	s13, s15, s14
 800b50e:	eefc 6ae6 	vcvt.u32.f32	s13, s13
 800b512:	edc0 6a02 	vstr	s13, [r0, #8]
}
 800b516:	4770      	bx	lr
    PLL1_Clocks->PLL1_Q_Frequency = 0U;
 800b518:	e9c0 3300 	strd	r3, r3, [r0]
    PLL1_Clocks->PLL1_R_Frequency = 0U;
 800b51c:	6083      	str	r3, [r0, #8]
}
 800b51e:	bc30      	pop	{r4, r5}
 800b520:	4770      	bx	lr
      pll1vco = ((float_t)HSE_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b522:	f64b 4120 	movw	r1, #48160	; 0xbc20
 800b526:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b528:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b52c:	f6c4 31be 	movt	r1, #19390	; 0x4bbe
 800b530:	e7ad      	b.n	800b48e <HAL_RCCEx_GetPLL1ClockFreq+0x52>
      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800b532:	6813      	ldr	r3, [r2, #0]
 800b534:	069b      	lsls	r3, r3, #26
 800b536:	d51d      	bpl.n	800b574 <HAL_RCCEx_GetPLL1ClockFreq+0x138>
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b538:	6814      	ldr	r4, [r2, #0]
 800b53a:	f44f 4110 	mov.w	r1, #36864	; 0x9000
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b53e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b540:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b544:	f3c4 02c1 	ubfx	r2, r4, #3, #2
 800b548:	f2c0 31d0 	movt	r1, #976	; 0x3d0
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b54c:	f3c3 0308 	ubfx	r3, r3, #0, #9
        hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 800b550:	40d1      	lsrs	r1, r2
        pll1vco = ((float_t)hsivalue / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b552:	ee06 3a10 	vmov	s12, r3
 800b556:	ee05 1a90 	vmov	s11, r1
 800b55a:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 800b55e:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 800b562:	ee36 6a07 	vadd.f32	s12, s12, s14
 800b566:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 800b56a:	ee76 7a26 	vadd.f32	s15, s12, s13
 800b56e:	ee67 7a27 	vmul.f32	s15, s14, s15
 800b572:	e79c      	b.n	800b4ae <HAL_RCCEx_GetPLL1ClockFreq+0x72>
        pll1vco = ((float_t)HSI_VALUE / (float_t)pll1m) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 800b574:	f44f 5110 	mov.w	r1, #9216	; 0x2400
 800b578:	6b13      	ldr	r3, [r2, #48]	; 0x30
 800b57a:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 800b57e:	f6c4 4174 	movt	r1, #19572	; 0x4c74
 800b582:	e784      	b.n	800b48e <HAL_RCCEx_GetPLL1ClockFreq+0x52>

0800b584 <HAL_RCCEx_GetPeriphCLKFreq>:
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800b584:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
{
 800b588:	b500      	push	{lr}
 800b58a:	b085      	sub	sp, #20
  if (PeriphClk == RCC_PERIPHCLK_SAI1)
 800b58c:	d031      	beq.n	800b5f2 <HAL_RCCEx_GetPeriphCLKFreq+0x6e>
  else if (PeriphClk == RCC_PERIPHCLK_SAI23)
 800b58e:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 800b592:	d018      	beq.n	800b5c6 <HAL_RCCEx_GetPeriphCLKFreq+0x42>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4A)
 800b594:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 800b598:	d05c      	beq.n	800b654 <HAL_RCCEx_GetPeriphCLKFreq+0xd0>
  else if (PeriphClk == RCC_PERIPHCLK_SAI4B)
 800b59a:	f5b0 6f00 	cmp.w	r0, #2048	; 0x800
 800b59e:	d03f      	beq.n	800b620 <HAL_RCCEx_GetPeriphCLKFreq+0x9c>
  else if (PeriphClk == RCC_PERIPHCLK_SPI123)
 800b5a0:	f5b0 5f80 	cmp.w	r0, #4096	; 0x1000
 800b5a4:	f000 80aa 	beq.w	800b6fc <HAL_RCCEx_GetPeriphCLKFreq+0x178>
  else if (PeriphClk == RCC_PERIPHCLK_ADC)
 800b5a8:	f5b0 2f00 	cmp.w	r0, #524288	; 0x80000
 800b5ac:	f000 80d0 	beq.w	800b750 <HAL_RCCEx_GetPeriphCLKFreq+0x1cc>
  else if (PeriphClk == RCC_PERIPHCLK_SDMMC)
 800b5b0:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
 800b5b4:	f000 80dd 	beq.w	800b772 <HAL_RCCEx_GetPeriphCLKFreq+0x1ee>
  else if (PeriphClk == RCC_PERIPHCLK_SPI6)
 800b5b8:	f5b0 4f80 	cmp.w	r0, #16384	; 0x4000
 800b5bc:	d079      	beq.n	800b6b2 <HAL_RCCEx_GetPeriphCLKFreq+0x12e>
          frequency = 0;
 800b5be:	2000      	movs	r0, #0
}
 800b5c0:	b005      	add	sp, #20
 800b5c2:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI23_SOURCE();
 800b5c6:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b5ca:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b5ce:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800b5d0:	f403 73e0 	and.w	r3, r3, #448	; 0x1c0
      switch (saiclocksource)
 800b5d4:	2b80      	cmp	r3, #128	; 0x80
 800b5d6:	d051      	beq.n	800b67c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
 800b5d8:	f200 8085 	bhi.w	800b6e6 <HAL_RCCEx_GetPeriphCLKFreq+0x162>
 800b5dc:	2b00      	cmp	r3, #0
 800b5de:	d046      	beq.n	800b66e <HAL_RCCEx_GetPeriphCLKFreq+0xea>
 800b5e0:	2b40      	cmp	r3, #64	; 0x40
 800b5e2:	d1ec      	bne.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800b5e4:	a801      	add	r0, sp, #4
 800b5e6:	f7ff fde1 	bl	800b1ac <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_P_Frequency;
 800b5ea:	9801      	ldr	r0, [sp, #4]
}
 800b5ec:	b005      	add	sp, #20
 800b5ee:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI1_SOURCE();
 800b5f2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b5f6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b5fa:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800b5fc:	f003 0307 	and.w	r3, r3, #7
      switch (saiclocksource)
 800b600:	2b04      	cmp	r3, #4
 800b602:	d8dc      	bhi.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800b604:	a201      	add	r2, pc, #4	; (adr r2, 800b60c <HAL_RCCEx_GetPeriphCLKFreq+0x88>)
 800b606:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800b60a:	bf00      	nop
 800b60c:	0800b66f 	.word	0x0800b66f
 800b610:	0800b5e5 	.word	0x0800b5e5
 800b614:	0800b67d 	.word	0x0800b67d
 800b618:	0800b647 	.word	0x0800b647
 800b61c:	0800b68b 	.word	0x0800b68b
      saiclocksource= __HAL_RCC_GET_SAI4B_SOURCE();
 800b620:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b624:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b628:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800b62a:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
      switch (saiclocksource)
 800b62e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800b632:	d023      	beq.n	800b67c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
 800b634:	d874      	bhi.n	800b720 <HAL_RCCEx_GetPeriphCLKFreq+0x19c>
 800b636:	b1d3      	cbz	r3, 800b66e <HAL_RCCEx_GetPeriphCLKFreq+0xea>
 800b638:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 800b63c:	d0d2      	beq.n	800b5e4 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
 800b63e:	e7be      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800b640:	f5b3 0fc0 	cmp.w	r3, #6291456	; 0x600000
 800b644:	d173      	bne.n	800b72e <HAL_RCCEx_GetPeriphCLKFreq+0x1aa>
          frequency = EXTERNAL_CLOCK_VALUE;
 800b646:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800b64a:	f2c0 00bb 	movt	r0, #187	; 0xbb
}
 800b64e:	b005      	add	sp, #20
 800b650:	f85d fb04 	ldr.w	pc, [sp], #4
      saiclocksource= __HAL_RCC_GET_SAI4A_SOURCE();
 800b654:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b658:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b65c:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800b65e:	f403 0360 	and.w	r3, r3, #14680064	; 0xe00000
      switch (saiclocksource)
 800b662:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800b666:	d009      	beq.n	800b67c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
 800b668:	d8ea      	bhi.n	800b640 <HAL_RCCEx_GetPeriphCLKFreq+0xbc>
 800b66a:	2b00      	cmp	r3, #0
 800b66c:	d163      	bne.n	800b736 <HAL_RCCEx_GetPeriphCLKFreq+0x1b2>
          HAL_RCCEx_GetPLL1ClockFreq(&pll1_clocks);
 800b66e:	a801      	add	r0, sp, #4
 800b670:	f7ff fee4 	bl	800b43c <HAL_RCCEx_GetPLL1ClockFreq>
          frequency = pll1_clocks.PLL1_Q_Frequency;
 800b674:	9802      	ldr	r0, [sp, #8]
}
 800b676:	b005      	add	sp, #20
 800b678:	f85d fb04 	ldr.w	pc, [sp], #4
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800b67c:	a801      	add	r0, sp, #4
 800b67e:	f7ff fe39 	bl	800b2f4 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_P_Frequency;
 800b682:	9801      	ldr	r0, [sp, #4]
}
 800b684:	b005      	add	sp, #20
 800b686:	f85d fb04 	ldr.w	pc, [sp], #4
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
 800b68a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b68e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b692:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
 800b694:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
 800b698:	d020      	beq.n	800b6dc <HAL_RCCEx_GetPeriphCLKFreq+0x158>
          else if(ckpclocksource== RCC_CLKPSOURCE_CSI)
 800b69a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800b69e:	d079      	beq.n	800b794 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
            frequency = HSE_VALUE;
 800b6a0:	f647 0040 	movw	r0, #30784	; 0x7840
 800b6a4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800b6a8:	f2c0 107d 	movt	r0, #381	; 0x17d
 800b6ac:	bf18      	it	ne
 800b6ae:	2000      	movne	r0, #0
 800b6b0:	e786      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      srcclk= __HAL_RCC_GET_SPI6_SOURCE();
 800b6b2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b6b6:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b6ba:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800b6bc:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
      switch (srcclk)
 800b6c0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 800b6c4:	d07f      	beq.n	800b7c6 <HAL_RCCEx_GetPeriphCLKFreq+0x242>
 800b6c6:	d96f      	bls.n	800b7a8 <HAL_RCCEx_GetPeriphCLKFreq+0x224>
 800b6c8:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 800b6cc:	d062      	beq.n	800b794 <HAL_RCCEx_GetPeriphCLKFreq+0x210>
 800b6ce:	f1b3 4fa0 	cmp.w	r3, #1342177280	; 0x50000000
 800b6d2:	d073      	beq.n	800b7bc <HAL_RCCEx_GetPeriphCLKFreq+0x238>
 800b6d4:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
 800b6d8:	f47f af71 	bne.w	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
            frequency = HSI_VALUE;
 800b6dc:	f44f 4010 	mov.w	r0, #36864	; 0x9000
 800b6e0:	f2c0 30d0 	movt	r0, #976	; 0x3d0
 800b6e4:	e76c      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (saiclocksource)
 800b6e6:	2bc0      	cmp	r3, #192	; 0xc0
 800b6e8:	d0ad      	beq.n	800b646 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
 800b6ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800b6ee:	f47f af66 	bne.w	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          ckpclocksource= __HAL_RCC_GET_CLKP_SOURCE();
 800b6f2:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
          if(ckpclocksource== RCC_CLKPSOURCE_HSI)
 800b6f4:	f013 5340 	ands.w	r3, r3, #805306368	; 0x30000000
 800b6f8:	d1cf      	bne.n	800b69a <HAL_RCCEx_GetPeriphCLKFreq+0x116>
 800b6fa:	e7ef      	b.n	800b6dc <HAL_RCCEx_GetPeriphCLKFreq+0x158>
      srcclk= __HAL_RCC_GET_SPI123_SOURCE();
 800b6fc:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b700:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b704:	6d13      	ldr	r3, [r2, #80]	; 0x50
 800b706:	f403 43e0 	and.w	r3, r3, #28672	; 0x7000
      switch (srcclk)
 800b70a:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800b70e:	d0b5      	beq.n	800b67c <HAL_RCCEx_GetPeriphCLKFreq+0xf8>
 800b710:	d816      	bhi.n	800b740 <HAL_RCCEx_GetPeriphCLKFreq+0x1bc>
 800b712:	2b00      	cmp	r3, #0
 800b714:	d0ab      	beq.n	800b66e <HAL_RCCEx_GetPeriphCLKFreq+0xea>
 800b716:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800b71a:	f43f af63 	beq.w	800b5e4 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
 800b71e:	e74e      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800b720:	f1b3 7f40 	cmp.w	r3, #50331648	; 0x3000000
 800b724:	d08f      	beq.n	800b646 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
 800b726:	f1b3 6f80 	cmp.w	r3, #67108864	; 0x4000000
 800b72a:	d0e2      	beq.n	800b6f2 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
 800b72c:	e747      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (saiclocksource)
 800b72e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800b732:	d0de      	beq.n	800b6f2 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
 800b734:	e743      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800b736:	f5b3 1f00 	cmp.w	r3, #2097152	; 0x200000
 800b73a:	f43f af53 	beq.w	800b5e4 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
 800b73e:	e73e      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      switch (srcclk)
 800b740:	f5b3 5f40 	cmp.w	r3, #12288	; 0x3000
 800b744:	f43f af7f 	beq.w	800b646 <HAL_RCCEx_GetPeriphCLKFreq+0xc2>
 800b748:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 800b74c:	d0d1      	beq.n	800b6f2 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
 800b74e:	e736      	b.n	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
      srcclk= __HAL_RCC_GET_ADC_SOURCE();
 800b750:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800b754:	f6c5 0202 	movt	r2, #22530	; 0x5802
 800b758:	6d93      	ldr	r3, [r2, #88]	; 0x58
 800b75a:	f403 3340 	and.w	r3, r3, #196608	; 0x30000
      switch (srcclk)
 800b75e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800b762:	d01c      	beq.n	800b79e <HAL_RCCEx_GetPeriphCLKFreq+0x21a>
 800b764:	f5b3 3f00 	cmp.w	r3, #131072	; 0x20000
 800b768:	d0c3      	beq.n	800b6f2 <HAL_RCCEx_GetPeriphCLKFreq+0x16e>
 800b76a:	2b00      	cmp	r3, #0
 800b76c:	f47f af27 	bne.w	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
 800b770:	e738      	b.n	800b5e4 <HAL_RCCEx_GetPeriphCLKFreq+0x60>
      srcclk= __HAL_RCC_GET_SDMMC_SOURCE();
 800b772:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b776:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b77a:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
      switch (srcclk)
 800b77c:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 800b780:	f43f af75 	beq.w	800b66e <HAL_RCCEx_GetPeriphCLKFreq+0xea>
 800b784:	2b00      	cmp	r3, #0
 800b786:	f43f af1a 	beq.w	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800b78a:	a801      	add	r0, sp, #4
 800b78c:	f7ff fd0e 	bl	800b1ac <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_R_Frequency;
 800b790:	9803      	ldr	r0, [sp, #12]
          break;
 800b792:	e715      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
            frequency = CSI_VALUE;
 800b794:	f44f 6010 	mov.w	r0, #2304	; 0x900
 800b798:	f2c0 003d 	movt	r0, #61	; 0x3d
 800b79c:	e710      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800b79e:	a801      	add	r0, sp, #4
 800b7a0:	f7ff fda8 	bl	800b2f4 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_R_Frequency;
 800b7a4:	9803      	ldr	r0, [sp, #12]
          break;
 800b7a6:	e70b      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
      switch (srcclk)
 800b7a8:	b193      	cbz	r3, 800b7d0 <HAL_RCCEx_GetPeriphCLKFreq+0x24c>
 800b7aa:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 800b7ae:	f47f af06 	bne.w	800b5be <HAL_RCCEx_GetPeriphCLKFreq+0x3a>
          HAL_RCCEx_GetPLL2ClockFreq(&pll2_clocks);
 800b7b2:	a801      	add	r0, sp, #4
 800b7b4:	f7ff fcfa 	bl	800b1ac <HAL_RCCEx_GetPLL2ClockFreq>
          frequency = pll2_clocks.PLL2_Q_Frequency;
 800b7b8:	9802      	ldr	r0, [sp, #8]
          break;
 800b7ba:	e701      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          frequency = HSE_VALUE;
 800b7bc:	f647 0040 	movw	r0, #30784	; 0x7840
 800b7c0:	f2c0 107d 	movt	r0, #381	; 0x17d
          break;
 800b7c4:	e6fc      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
          HAL_RCCEx_GetPLL3ClockFreq(&pll3_clocks);
 800b7c6:	a801      	add	r0, sp, #4
 800b7c8:	f7ff fd94 	bl	800b2f4 <HAL_RCCEx_GetPLL3ClockFreq>
          frequency = pll3_clocks.PLL3_Q_Frequency;
 800b7cc:	9802      	ldr	r0, [sp, #8]
          break;
 800b7ce:	e6f7      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>
  return (HAL_RCC_GetHCLKFreq() >> (D1CorePrescTable[(RCC->D3CFGR & RCC_D3CFGR_D3PPRE)>> RCC_D3CFGR_D3PPRE_Pos] & 0x1FU));
 800b7d0:	f7fe fb0a 	bl	8009de8 <HAL_RCC_GetHCLKFreq>
 800b7d4:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800b7d8:	f64e 22c0 	movw	r2, #60096	; 0xeac0
 800b7dc:	f6c5 0302 	movt	r3, #22530	; 0x5802
 800b7e0:	f6c0 0202 	movt	r2, #2050	; 0x802
 800b7e4:	6a1b      	ldr	r3, [r3, #32]
 800b7e6:	f3c3 1302 	ubfx	r3, r3, #4, #3
 800b7ea:	5cd3      	ldrb	r3, [r2, r3]
 800b7ec:	f003 031f 	and.w	r3, r3, #31
 800b7f0:	40d8      	lsrs	r0, r3
          break;
 800b7f2:	e6e5      	b.n	800b5c0 <HAL_RCCEx_GetPeriphCLKFreq+0x3c>

0800b7f4 <HAL_RNG_Init>:
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{
  uint32_t tickstart;
  /* Check the RNG handle allocation */
  if (hrng == NULL)
 800b7f4:	2800      	cmp	r0, #0
 800b7f6:	d052      	beq.n	800b89e <HAL_RNG_Init+0xaa>
{
 800b7f8:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }
  /* Check the parameters */
  assert_param(IS_RNG_ALL_INSTANCE(hrng->Instance));
 800b7fa:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800b7fe:	6802      	ldr	r2, [r0, #0]
 800b800:	4604      	mov	r4, r0
 800b802:	f6c4 0302 	movt	r3, #18434	; 0x4802
 800b806:	429a      	cmp	r2, r3
 800b808:	d006      	beq.n	800b818 <HAL_RNG_Init+0x24>
 800b80a:	f64d 4088 	movw	r0, #56456	; 0xdc88
 800b80e:	21b1      	movs	r1, #177	; 0xb1
 800b810:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b814:	f00a f828 	bl	8015868 <assert_failed>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 800b818:	6863      	ldr	r3, [r4, #4]
 800b81a:	f033 0320 	bics.w	r3, r3, #32
 800b81e:	d131      	bne.n	800b884 <HAL_RNG_Init+0x90>

    /* Init the low level hardware */
    hrng->MspInitCallback(hrng);
  }
#else
  if (hrng->State == HAL_RNG_STATE_RESET)
 800b820:	7a63      	ldrb	r3, [r4, #9]
 800b822:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800b826:	b343      	cbz	r3, 800b87a <HAL_RNG_Init+0x86>
    HAL_RNG_MspInit(hrng);
  }
#endif /* USE_HAL_RNG_REGISTER_CALLBACKS */

  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 800b828:	2302      	movs	r3, #2
      return HAL_ERROR;
    }
  }
#else
  /* Clock Error Detection Configuration */
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800b82a:	e9d4 2100 	ldrd	r2, r1, [r4]
  hrng->State = HAL_RNG_STATE_BUSY;
 800b82e:	7263      	strb	r3, [r4, #9]
  MODIFY_REG(hrng->Instance->CR, RNG_CR_CED, hrng->Init.ClockErrorDetection);
 800b830:	6813      	ldr	r3, [r2, #0]
 800b832:	f023 0320 	bic.w	r3, r3, #32
 800b836:	430b      	orrs	r3, r1
 800b838:	6013      	str	r3, [r2, #0]
#endif /* end of RNG_CR_CONDRST */

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 800b83a:	6822      	ldr	r2, [r4, #0]
 800b83c:	6813      	ldr	r3, [r2, #0]
 800b83e:	f043 0304 	orr.w	r3, r3, #4
 800b842:	6013      	str	r3, [r2, #0]

  /* verify that no seed error */
  if (__HAL_RNG_GET_IT(hrng, RNG_IT_SEI) != RESET)
 800b844:	6823      	ldr	r3, [r4, #0]
 800b846:	685b      	ldr	r3, [r3, #4]
 800b848:	065b      	lsls	r3, r3, #25
 800b84a:	d503      	bpl.n	800b854 <HAL_RNG_Init+0x60>
  {
    hrng->State = HAL_RNG_STATE_ERROR;
 800b84c:	2304      	movs	r3, #4
    return HAL_ERROR;
 800b84e:	2001      	movs	r0, #1
    hrng->State = HAL_RNG_STATE_ERROR;
 800b850:	7263      	strb	r3, [r4, #9]
  /* Initialise the error code */
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;

  /* Return function status */
  return HAL_OK;
}
 800b852:	bd38      	pop	{r3, r4, r5, pc}
  tickstart = HAL_GetTick();
 800b854:	f7f5 f8f2 	bl	8000a3c <HAL_GetTick>
 800b858:	4605      	mov	r5, r0
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800b85a:	e004      	b.n	800b866 <HAL_RNG_Init+0x72>
    if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800b85c:	f7f5 f8ee 	bl	8000a3c <HAL_GetTick>
 800b860:	1b40      	subs	r0, r0, r5
 800b862:	2802      	cmp	r0, #2
 800b864:	d81d      	bhi.n	800b8a2 <HAL_RNG_Init+0xae>
  while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_SECS) != RESET)
 800b866:	6823      	ldr	r3, [r4, #0]
 800b868:	685b      	ldr	r3, [r3, #4]
 800b86a:	f013 0304 	ands.w	r3, r3, #4
 800b86e:	d1f5      	bne.n	800b85c <HAL_RNG_Init+0x68>
  hrng->State = HAL_RNG_STATE_READY;
 800b870:	2201      	movs	r2, #1
  return HAL_OK;
 800b872:	4618      	mov	r0, r3
  hrng->State = HAL_RNG_STATE_READY;
 800b874:	7262      	strb	r2, [r4, #9]
  hrng->ErrorCode = HAL_RNG_ERROR_NONE;
 800b876:	60e3      	str	r3, [r4, #12]
}
 800b878:	bd38      	pop	{r3, r4, r5, pc}
    hrng->Lock = HAL_UNLOCKED;
 800b87a:	7222      	strb	r2, [r4, #8]
    HAL_RNG_MspInit(hrng);
 800b87c:	4620      	mov	r0, r4
 800b87e:	f00a fdf7 	bl	8016470 <HAL_RNG_MspInit>
 800b882:	e7d1      	b.n	800b828 <HAL_RNG_Init+0x34>
  assert_param(IS_RNG_CED(hrng->Init.ClockErrorDetection));
 800b884:	f64d 4088 	movw	r0, #56456	; 0xdc88
 800b888:	21b2      	movs	r1, #178	; 0xb2
 800b88a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b88e:	f009 ffeb 	bl	8015868 <assert_failed>
  if (hrng->State == HAL_RNG_STATE_RESET)
 800b892:	7a63      	ldrb	r3, [r4, #9]
 800b894:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800b898:	2b00      	cmp	r3, #0
 800b89a:	d1c5      	bne.n	800b828 <HAL_RNG_Init+0x34>
 800b89c:	e7ed      	b.n	800b87a <HAL_RNG_Init+0x86>
    return HAL_ERROR;
 800b89e:	2001      	movs	r0, #1
}
 800b8a0:	4770      	bx	lr
      hrng->State = HAL_RNG_STATE_ERROR;
 800b8a2:	2204      	movs	r2, #4
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800b8a4:	2302      	movs	r3, #2
      return HAL_ERROR;
 800b8a6:	2001      	movs	r0, #1
      hrng->State = HAL_RNG_STATE_ERROR;
 800b8a8:	7262      	strb	r2, [r4, #9]
      hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800b8aa:	60e3      	str	r3, [r4, #12]
}
 800b8ac:	bd38      	pop	{r3, r4, r5, pc}
 800b8ae:	bf00      	nop

0800b8b0 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 800b8b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;

  /* Process Locked */
  __HAL_LOCK(hrng);
 800b8b2:	7a03      	ldrb	r3, [r0, #8]
 800b8b4:	2b01      	cmp	r3, #1
 800b8b6:	d00b      	beq.n	800b8d0 <HAL_RNG_GenerateRandomNumber+0x20>
 800b8b8:	4604      	mov	r4, r0
 800b8ba:	2001      	movs	r0, #1
 800b8bc:	460e      	mov	r6, r1

  /* Check RNG peripheral state */
  if (hrng->State == HAL_RNG_STATE_READY)
 800b8be:	7a63      	ldrb	r3, [r4, #9]
  __HAL_LOCK(hrng);
 800b8c0:	7220      	strb	r0, [r4, #8]
  if (hrng->State == HAL_RNG_STATE_READY)
 800b8c2:	4283      	cmp	r3, r0
 800b8c4:	d006      	beq.n	800b8d4 <HAL_RNG_GenerateRandomNumber+0x24>

    hrng->State = HAL_RNG_STATE_READY;
  }
  else
  {
    hrng->ErrorCode = HAL_RNG_ERROR_BUSY;
 800b8c6:	2304      	movs	r3, #4
 800b8c8:	60e3      	str	r3, [r4, #12]
    status = HAL_ERROR;
  }

  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 800b8ca:	2300      	movs	r3, #0
 800b8cc:	7223      	strb	r3, [r4, #8]

  return status;
}
 800b8ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  __HAL_LOCK(hrng);
 800b8d0:	2002      	movs	r0, #2
}
 800b8d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrng->State = HAL_RNG_STATE_BUSY;
 800b8d4:	2302      	movs	r3, #2
 800b8d6:	7263      	strb	r3, [r4, #9]
    tickstart = HAL_GetTick();
 800b8d8:	f7f5 f8b0 	bl	8000a3c <HAL_GetTick>
 800b8dc:	4607      	mov	r7, r0
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 800b8de:	e004      	b.n	800b8ea <HAL_RNG_GenerateRandomNumber+0x3a>
      if ((HAL_GetTick() - tickstart) > RNG_TIMEOUT_VALUE)
 800b8e0:	f7f5 f8ac 	bl	8000a3c <HAL_GetTick>
 800b8e4:	1bc0      	subs	r0, r0, r7
 800b8e6:	2802      	cmp	r0, #2
 800b8e8:	d80b      	bhi.n	800b902 <HAL_RNG_GenerateRandomNumber+0x52>
    while (__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 800b8ea:	6822      	ldr	r2, [r4, #0]
 800b8ec:	6855      	ldr	r5, [r2, #4]
 800b8ee:	f015 0501 	ands.w	r5, r5, #1
 800b8f2:	d0f5      	beq.n	800b8e0 <HAL_RNG_GenerateRandomNumber+0x30>
    hrng->RandomNumber = hrng->Instance->DR;
 800b8f4:	6893      	ldr	r3, [r2, #8]
    hrng->State = HAL_RNG_STATE_READY;
 800b8f6:	2201      	movs	r2, #1
  HAL_StatusTypeDef status = HAL_OK;
 800b8f8:	2000      	movs	r0, #0
    hrng->RandomNumber = hrng->Instance->DR;
 800b8fa:	6123      	str	r3, [r4, #16]
    *random32bit = hrng->RandomNumber;
 800b8fc:	6033      	str	r3, [r6, #0]
    hrng->State = HAL_RNG_STATE_READY;
 800b8fe:	7262      	strb	r2, [r4, #9]
 800b900:	e7e3      	b.n	800b8ca <HAL_RNG_GenerateRandomNumber+0x1a>
        hrng->State = HAL_RNG_STATE_READY;
 800b902:	2001      	movs	r0, #1
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800b904:	2302      	movs	r3, #2
        __HAL_UNLOCK(hrng);
 800b906:	7225      	strb	r5, [r4, #8]
        hrng->State = HAL_RNG_STATE_READY;
 800b908:	7260      	strb	r0, [r4, #9]
        hrng->ErrorCode = HAL_RNG_ERROR_TIMEOUT;
 800b90a:	60e3      	str	r3, [r4, #12]
}
 800b90c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800b90e:	bf00      	nop

0800b910 <HAL_SAI_InitProtocol>:
HAL_StatusTypeDef HAL_SAI_InitProtocol(SAI_HandleTypeDef *hsai, uint32_t protocol, uint32_t datasize, uint32_t nbslot)
{
  HAL_StatusTypeDef status;

  /* Check the parameters */
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800b910:	2904      	cmp	r1, #4
{
 800b912:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800b914:	460d      	mov	r5, r1
 800b916:	4604      	mov	r4, r0
 800b918:	4617      	mov	r7, r2
 800b91a:	461e      	mov	r6, r3
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800b91c:	f200 8089 	bhi.w	800ba32 <HAL_SAI_InitProtocol+0x122>
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
 800b920:	2f03      	cmp	r7, #3
 800b922:	d87d      	bhi.n	800ba20 <HAL_SAI_InitProtocol+0x110>

  switch (protocol)
 800b924:	2d04      	cmp	r5, #4
 800b926:	d831      	bhi.n	800b98c <HAL_SAI_InitProtocol+0x7c>
 800b928:	e8df f005 	tbb	[pc, r5]
 800b92c:	32555555 	.word	0x32555555
 800b930:	32          	.byte	0x32
 800b931:	00          	.byte	0x00

  /* Check the SAI PDM parameters */
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
  if (hsai->Init.PdmInit.Activation == ENABLE)
  {
    assert_param(IS_SAI_PDM_MIC_PAIRS_NUMBER(hsai->Init.PdmInit.MicPairsNbr));
 800b932:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800b934:	3b01      	subs	r3, #1
 800b936:	2b02      	cmp	r3, #2
 800b938:	d907      	bls.n	800b94a <HAL_SAI_InitProtocol+0x3a>
 800b93a:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800b93e:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800b942:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b946:	f009 ff8f 	bl	8015868 <assert_failed>
    assert_param(IS_SAI_PDM_CLOCK_ENABLE(hsai->Init.PdmInit.ClockEnable));
 800b94a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800b94c:	b113      	cbz	r3, 800b954 <HAL_SAI_InitProtocol+0x44>
 800b94e:	f433 7340 	bics.w	r3, r3, #768	; 0x300
 800b952:	d007      	beq.n	800b964 <HAL_SAI_InitProtocol+0x54>
 800b954:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800b958:	f240 11af 	movw	r1, #431	; 0x1af
 800b95c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800b960:	f009 ff82 	bl	8015868 <assert_failed>
    /* Check that SAI sub-block is SAI1 or SAI4 sub-block A, in master RX mode with free protocol */
#if defined(SAI4)
    if (((hsai->Instance != SAI1_Block_A) && (hsai->Instance != SAI4_Block_A)) ||
 800b964:	f645 0204 	movw	r2, #22532	; 0x5804
 800b968:	6823      	ldr	r3, [r4, #0]
 800b96a:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800b96e:	4293      	cmp	r3, r2
 800b970:	d005      	beq.n	800b97e <HAL_SAI_InitProtocol+0x6e>
 800b972:	f245 4204 	movw	r2, #21508	; 0x5404
 800b976:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800b97a:	4293      	cmp	r3, r2
 800b97c:	d106      	bne.n	800b98c <HAL_SAI_InitProtocol+0x7c>
 800b97e:	6862      	ldr	r2, [r4, #4]
 800b980:	2a01      	cmp	r2, #1
 800b982:	d103      	bne.n	800b98c <HAL_SAI_InitProtocol+0x7c>
         (hsai->Init.AudioMode != SAI_MODEMASTER_RX) ||
 800b984:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800b986:	2a00      	cmp	r2, #0
 800b988:	f000 8197 	beq.w	800bcba <HAL_SAI_InitProtocol+0x3aa>
  hsai->SlotInit.SlotNumber      = nbslot;

  /* in IS2 the number of slot must be even */
  if ((nbslot & 0x1U) != 0U)
  {
    return HAL_ERROR;
 800b98c:	2001      	movs	r0, #1
}
 800b98e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  HAL_StatusTypeDef status = HAL_OK;

  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
  /* Compute ClockStrobing according AudioMode */
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b990:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800b992:	2300      	movs	r3, #0
  {
    /* Receive */
    hsai->Init.ClockStrobing     = SAI_CLOCKSTROBING_FALLINGEDGE;
  }
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
  hsai->FrameInit.FSPolarity     = SAI_FS_ACTIVE_HIGH;
 800b994:	f44f 3000 	mov.w	r0, #131072	; 0x20000
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 800b998:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b99c:	f032 0202 	bics.w	r2, r2, #2
  hsai->SlotInit.FirstBitOffset  = 0;
  hsai->SlotInit.SlotNumber      = nbslot;
 800b9a0:	6726      	str	r6, [r4, #112]	; 0x70
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800b9a2:	6463      	str	r3, [r4, #68]	; 0x44
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b9a4:	bf0c      	ite	eq
 800b9a6:	2201      	moveq	r2, #1
 800b9a8:	461a      	movne	r2, r3
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;

  if (protocol == SAI_PCM_SHORT)
  {
      hsai->FrameInit.ActiveFrameLength = 1;
 800b9aa:	2d04      	cmp	r5, #4
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800b9ac:	64e3      	str	r3, [r4, #76]	; 0x4c
 800b9ae:	6522      	str	r2, [r4, #80]	; 0x50
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800b9b0:	f64f 72ff 	movw	r2, #65535	; 0xffff
      hsai->FrameInit.ActiveFrameLength = 1;
 800b9b4:	bf14      	ite	ne
 800b9b6:	250d      	movne	r5, #13
 800b9b8:	2501      	moveq	r5, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_STARTFRAME;
 800b9ba:	65e3      	str	r3, [r4, #92]	; 0x5c
 800b9bc:	65a5      	str	r5, [r4, #88]	; 0x58
  hsai->SlotInit.FirstBitOffset  = 0;
 800b9be:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800b9c0:	6762      	str	r2, [r4, #116]	; 0x74
  hsai->FrameInit.FSOffset       = SAI_FS_BEFOREFIRSTBIT;
 800b9c2:	e9c4 0118 	strd	r0, r1, [r4, #96]	; 0x60
  {
    /* SAI_PCM_LONG */
      hsai->FrameInit.ActiveFrameLength = 13;
  }

  switch (datasize)
 800b9c6:	2f03      	cmp	r7, #3
 800b9c8:	d8e0      	bhi.n	800b98c <HAL_SAI_InitProtocol+0x7c>
 800b9ca:	e8df f017 	tbh	[pc, r7, lsl #1]
 800b9ce:	01b6      	.short	0x01b6
 800b9d0:	01bd01b0 	.word	0x01bd01b0
 800b9d4:	003b      	.short	0x003b
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b9d6:	6862      	ldr	r2, [r4, #4]
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800b9d8:	2300      	movs	r3, #0
  hsai->SlotInit.SlotNumber      = nbslot;
 800b9da:	6726      	str	r6, [r4, #112]	; 0x70
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b9dc:	f032 0202 	bics.w	r2, r2, #2
  hsai->Init.Protocol            = SAI_FREE_PROTOCOL;
 800b9e0:	6463      	str	r3, [r4, #68]	; 0x44
  hsai->Init.FirstBit            = SAI_FIRSTBIT_MSB;
 800b9e2:	64e3      	str	r3, [r4, #76]	; 0x4c
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 800b9e4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b9e8:	bf08      	it	eq
 800b9ea:	4619      	moveq	r1, r3
  hsai->SlotInit.FirstBitOffset  = 0;
 800b9ec:	66a3      	str	r3, [r4, #104]	; 0x68
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800b9ee:	f64f 73ff 	movw	r3, #65535	; 0xffff
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800b9f2:	bf18      	it	ne
 800b9f4:	2101      	movne	r1, #1
  hsai->FrameInit.FSDefinition   = SAI_FS_CHANNEL_IDENTIFICATION;
 800b9f6:	65e2      	str	r2, [r4, #92]	; 0x5c
  hsai->SlotInit.SlotActive      = SAI_SLOTACTIVE_ALL;
 800b9f8:	6763      	str	r3, [r4, #116]	; 0x74
  if ((nbslot & 0x1U) != 0U)
 800b9fa:	f016 0301 	ands.w	r3, r6, #1
 800b9fe:	6521      	str	r1, [r4, #80]	; 0x50
 800ba00:	d1c4      	bne.n	800b98c <HAL_SAI_InitProtocol+0x7c>
  if (protocol == SAI_I2S_STANDARD)
 800ba02:	2d00      	cmp	r5, #0
 800ba04:	f000 81a7 	beq.w	800bd56 <HAL_SAI_InitProtocol+0x446>
 800ba08:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800ba0c:	e9c4 2318 	strd	r2, r3, [r4, #96]	; 0x60
  switch (datasize)
 800ba10:	2f03      	cmp	r7, #3
 800ba12:	d8bb      	bhi.n	800b98c <HAL_SAI_InitProtocol+0x7c>
 800ba14:	e8df f017 	tbh	[pc, r7, lsl #1]
 800ba18:	02b602c6 	.word	0x02b602c6
 800ba1c:	029b02a5 	.word	0x029b02a5
  assert_param(IS_SAI_PROTOCOL_DATASIZE(datasize));
 800ba20:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800ba24:	f44f 71a9 	mov.w	r1, #338	; 0x152
 800ba28:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ba2c:	f009 ff1c 	bl	8015868 <assert_failed>
 800ba30:	e778      	b.n	800b924 <HAL_SAI_InitProtocol+0x14>
  assert_param(IS_SAI_SUPPORTED_PROTOCOL(protocol));
 800ba32:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800ba36:	f240 1151 	movw	r1, #337	; 0x151
 800ba3a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ba3e:	f009 ff13 	bl	8015868 <assert_failed>
 800ba42:	e76d      	b.n	800b920 <HAL_SAI_InitProtocol+0x10>
      hsai->FrameInit.FrameLength = 32U * nbslot;
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
      break;
    case SAI_PROTOCOL_DATASIZE_32BIT:
      hsai->Init.DataSize = SAI_DATASIZE_32;
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800ba44:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800ba46:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800ba48:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800ba4a:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800ba4c:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800ba4e:	66e2      	str	r2, [r4, #108]	; 0x6c
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 800ba50:	f645 0304 	movw	r3, #22532	; 0x5804
 800ba54:	f645 0524 	movw	r5, #22564	; 0x5824
 800ba58:	6822      	ldr	r2, [r4, #0]
 800ba5a:	f645 4004 	movw	r0, #23556	; 0x5c04
 800ba5e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ba62:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800ba66:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800ba6a:	f645 4124 	movw	r1, #23588	; 0x5c24
 800ba6e:	429a      	cmp	r2, r3
 800ba70:	bf18      	it	ne
 800ba72:	42aa      	cmpne	r2, r5
 800ba74:	f246 0504 	movw	r5, #24580	; 0x6004
 800ba78:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800ba7c:	bf14      	ite	ne
 800ba7e:	2301      	movne	r3, #1
 800ba80:	2300      	moveq	r3, #0
 800ba82:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800ba86:	4282      	cmp	r2, r0
 800ba88:	bf0c      	ite	eq
 800ba8a:	2300      	moveq	r3, #0
 800ba8c:	f003 0301 	andne.w	r3, r3, #1
 800ba90:	f246 0024 	movw	r0, #24612	; 0x6024
 800ba94:	428a      	cmp	r2, r1
 800ba96:	bf0c      	ite	eq
 800ba98:	2300      	moveq	r3, #0
 800ba9a:	f003 0301 	andne.w	r3, r3, #1
 800ba9e:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800baa2:	f245 4104 	movw	r1, #21508	; 0x5404
 800baa6:	42aa      	cmp	r2, r5
 800baa8:	bf0c      	ite	eq
 800baaa:	2300      	moveq	r3, #0
 800baac:	f003 0301 	andne.w	r3, r3, #1
 800bab0:	f6c5 0100 	movt	r1, #22528	; 0x5800
 800bab4:	4282      	cmp	r2, r0
 800bab6:	bf0c      	ite	eq
 800bab8:	2300      	moveq	r3, #0
 800baba:	f003 0301 	andne.w	r3, r3, #1
 800babe:	428a      	cmp	r2, r1
 800bac0:	bf0c      	ite	eq
 800bac2:	2300      	moveq	r3, #0
 800bac4:	f003 0301 	andne.w	r3, r3, #1
 800bac8:	b133      	cbz	r3, 800bad8 <HAL_SAI_InitProtocol+0x1c8>
 800baca:	f245 4324 	movw	r3, #21540	; 0x5424
 800bace:	f6c5 0300 	movt	r3, #22528	; 0x5800
 800bad2:	429a      	cmp	r2, r3
 800bad4:	f040 83de 	bne.w	800c294 <HAL_SAI_InitProtocol+0x984>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 800bad8:	f44f 436e 	mov.w	r3, #60928	; 0xee00
 800badc:	f44f 41ee 	mov.w	r1, #30464	; 0x7700
 800bae0:	6a22      	ldr	r2, [r4, #32]
 800bae2:	f64b 3680 	movw	r6, #48000	; 0xbb80
 800bae6:	f2c0 0302 	movt	r3, #2
 800baea:	f2c0 0101 	movt	r1, #1
 800baee:	f64a 4544 	movw	r5, #44100	; 0xac44
 800baf2:	f245 6022 	movw	r0, #22050	; 0x5622
 800baf6:	429a      	cmp	r2, r3
 800baf8:	bf18      	it	ne
 800bafa:	428a      	cmpne	r2, r1
 800bafc:	f642 3111 	movw	r1, #11025	; 0x2b11
 800bb00:	bf14      	ite	ne
 800bb02:	2301      	movne	r3, #1
 800bb04:	2300      	moveq	r3, #0
 800bb06:	42b2      	cmp	r2, r6
 800bb08:	bf0c      	ite	eq
 800bb0a:	2300      	moveq	r3, #0
 800bb0c:	f003 0301 	andne.w	r3, r3, #1
 800bb10:	42aa      	cmp	r2, r5
 800bb12:	bf0c      	ite	eq
 800bb14:	2300      	moveq	r3, #0
 800bb16:	f003 0301 	andne.w	r3, r3, #1
 800bb1a:	f5b2 4ffa 	cmp.w	r2, #32000	; 0x7d00
 800bb1e:	bf0c      	ite	eq
 800bb20:	2300      	moveq	r3, #0
 800bb22:	f003 0301 	andne.w	r3, r3, #1
 800bb26:	4282      	cmp	r2, r0
 800bb28:	bf0c      	ite	eq
 800bb2a:	2300      	moveq	r3, #0
 800bb2c:	f003 0301 	andne.w	r3, r3, #1
 800bb30:	f5b2 5f7a 	cmp.w	r2, #16000	; 0x3e80
 800bb34:	bf0c      	ite	eq
 800bb36:	2300      	moveq	r3, #0
 800bb38:	f003 0301 	andne.w	r3, r3, #1
 800bb3c:	428a      	cmp	r2, r1
 800bb3e:	bf0c      	ite	eq
 800bb40:	2300      	moveq	r3, #0
 800bb42:	f003 0301 	andne.w	r3, r3, #1
 800bb46:	f5b2 5ffa 	cmp.w	r2, #8000	; 0x1f40
 800bb4a:	bf0c      	ite	eq
 800bb4c:	2300      	moveq	r3, #0
 800bb4e:	f003 0301 	andne.w	r3, r3, #1
 800bb52:	b113      	cbz	r3, 800bb5a <HAL_SAI_InitProtocol+0x24a>
 800bb54:	2a00      	cmp	r2, #0
 800bb56:	f040 83b1 	bne.w	800c2bc <HAL_SAI_InitProtocol+0x9ac>
  assert_param(IS_SAI_BLOCK_PROTOCOL(hsai->Init.Protocol));
 800bb5a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800bb5c:	f033 0204 	bics.w	r2, r3, #4
 800bb60:	d009      	beq.n	800bb76 <HAL_SAI_InitProtocol+0x266>
 800bb62:	2b08      	cmp	r3, #8
 800bb64:	d007      	beq.n	800bb76 <HAL_SAI_InitProtocol+0x266>
 800bb66:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bb6a:	f240 1185 	movw	r1, #389	; 0x185
 800bb6e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bb72:	f009 fe79 	bl	8015868 <assert_failed>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 800bb76:	6863      	ldr	r3, [r4, #4]
 800bb78:	2b03      	cmp	r3, #3
 800bb7a:	f200 8197 	bhi.w	800beac <HAL_SAI_InitProtocol+0x59c>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800bb7e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 800bb80:	f023 0220 	bic.w	r2, r3, #32
 800bb84:	2a80      	cmp	r2, #128	; 0x80
 800bb86:	d004      	beq.n	800bb92 <HAL_SAI_InitProtocol+0x282>
 800bb88:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 800bb8c:	2b40      	cmp	r3, #64	; 0x40
 800bb8e:	f040 835c 	bne.w	800c24a <HAL_SAI_InitProtocol+0x93a>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 800bb92:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800bb94:	f433 7380 	bics.w	r3, r3, #256	; 0x100
 800bb98:	f040 817f 	bne.w	800be9a <HAL_SAI_InitProtocol+0x58a>
  assert_param(IS_SAI_BLOCK_CLOCK_STROBING(hsai->Init.ClockStrobing));
 800bb9c:	6d23      	ldr	r3, [r4, #80]	; 0x50
 800bb9e:	2b01      	cmp	r3, #1
 800bba0:	d907      	bls.n	800bbb2 <HAL_SAI_InitProtocol+0x2a2>
 800bba2:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bba6:	f240 1189 	movw	r1, #393	; 0x189
 800bbaa:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bbae:	f009 fe5b 	bl	8015868 <assert_failed>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 800bbb2:	68a3      	ldr	r3, [r4, #8]
 800bbb4:	2b05      	cmp	r3, #5
 800bbb6:	f200 8167 	bhi.w	800be88 <HAL_SAI_InitProtocol+0x578>
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800bbba:	f7f4 ff59 	bl	8000a70 <HAL_GetREVID>
 800bbbe:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 800bbc2:	d304      	bcc.n	800bbce <HAL_SAI_InitProtocol+0x2be>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
 800bbc4:	6923      	ldr	r3, [r4, #16]
 800bbc6:	f033 6300 	bics.w	r3, r3, #134217728	; 0x8000000
 800bbca:	f040 82fd 	bne.w	800c1c8 <HAL_SAI_InitProtocol+0x8b8>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 800bbce:	6963      	ldr	r3, [r4, #20]
 800bbd0:	f433 5300 	bics.w	r3, r3, #8192	; 0x2000
 800bbd4:	f040 814f 	bne.w	800be76 <HAL_SAI_InitProtocol+0x566>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 800bbd8:	69a3      	ldr	r3, [r4, #24]
 800bbda:	f433 2300 	bics.w	r3, r3, #524288	; 0x80000
 800bbde:	f040 81ad 	bne.w	800bf3c <HAL_SAI_InitProtocol+0x62c>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 800bbe2:	69e3      	ldr	r3, [r4, #28]
 800bbe4:	2b04      	cmp	r3, #4
 800bbe6:	f200 81a0 	bhi.w	800bf2a <HAL_SAI_InitProtocol+0x61a>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 800bbea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800bbec:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800bbf0:	f040 8192 	bne.w	800bf18 <HAL_SAI_InitProtocol+0x608>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 800bbf4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800bbf6:	f423 4180 	bic.w	r1, r3, #16384	; 0x4000
 800bbfa:	f423 4200 	bic.w	r2, r3, #32768	; 0x8000
 800bbfe:	f5b1 4f20 	cmp.w	r1, #40960	; 0xa000
 800bc02:	bf18      	it	ne
 800bc04:	2a00      	cmpne	r2, #0
 800bc06:	d003      	beq.n	800bc10 <HAL_SAI_InitProtocol+0x300>
 800bc08:	f5b3 4f40 	cmp.w	r3, #49152	; 0xc000
 800bc0c:	f040 830f 	bne.w	800c22e <HAL_SAI_InitProtocol+0x91e>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 800bc10:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800bc12:	f033 0310 	bics.w	r3, r3, #16
 800bc16:	f040 8176 	bne.w	800bf06 <HAL_SAI_InitProtocol+0x5f6>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 800bc1a:	68e3      	ldr	r3, [r4, #12]
 800bc1c:	2b02      	cmp	r3, #2
 800bc1e:	f200 8169 	bhi.w	800bef4 <HAL_SAI_InitProtocol+0x5e4>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
 800bc22:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800bc24:	f033 6380 	bics.w	r3, r3, #67108864	; 0x4000000
 800bc28:	f040 815b 	bne.w	800bee2 <HAL_SAI_InitProtocol+0x5d2>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 800bc2c:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800bc2e:	3b08      	subs	r3, #8
 800bc30:	2bf8      	cmp	r3, #248	; 0xf8
 800bc32:	f200 814d 	bhi.w	800bed0 <HAL_SAI_InitProtocol+0x5c0>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 800bc36:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800bc38:	3b01      	subs	r3, #1
 800bc3a:	2b7f      	cmp	r3, #127	; 0x7f
 800bc3c:	f200 813f 	bhi.w	800bebe <HAL_SAI_InitProtocol+0x5ae>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 800bc40:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800bc42:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
 800bc46:	f040 810d 	bne.w	800be64 <HAL_SAI_InitProtocol+0x554>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 800bc4a:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800bc4c:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800bc50:	f040 80ff 	bne.w	800be52 <HAL_SAI_InitProtocol+0x542>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 800bc54:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800bc56:	f433 2380 	bics.w	r3, r3, #262144	; 0x40000
 800bc5a:	f040 80f1 	bne.w	800be40 <HAL_SAI_InitProtocol+0x530>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 800bc5e:	6ea3      	ldr	r3, [r4, #104]	; 0x68
 800bc60:	2b18      	cmp	r3, #24
 800bc62:	f200 80e4 	bhi.w	800be2e <HAL_SAI_InitProtocol+0x51e>
  assert_param(IS_SAI_BLOCK_SLOT_SIZE(hsai->SlotInit.SlotSize));
 800bc66:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
 800bc68:	f033 0240 	bics.w	r2, r3, #64	; 0x40
 800bc6c:	d009      	beq.n	800bc82 <HAL_SAI_InitProtocol+0x372>
 800bc6e:	2b80      	cmp	r3, #128	; 0x80
 800bc70:	d007      	beq.n	800bc82 <HAL_SAI_InitProtocol+0x372>
 800bc72:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bc76:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
 800bc7a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bc7e:	f009 fdf3 	bl	8015868 <assert_failed>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 800bc82:	6f23      	ldr	r3, [r4, #112]	; 0x70
 800bc84:	3b01      	subs	r3, #1
 800bc86:	2b0f      	cmp	r3, #15
 800bc88:	f200 80c8 	bhi.w	800be1c <HAL_SAI_InitProtocol+0x50c>
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 800bc8c:	6f63      	ldr	r3, [r4, #116]	; 0x74
 800bc8e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800bc92:	f080 80ba 	bcs.w	800be0a <HAL_SAI_InitProtocol+0x4fa>
  assert_param(IS_FUNCTIONAL_STATE(hsai->Init.PdmInit.Activation));
 800bc96:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 800bc9a:	2b01      	cmp	r3, #1
 800bc9c:	d909      	bls.n	800bcb2 <HAL_SAI_InitProtocol+0x3a2>
 800bc9e:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bca2:	f240 11ab 	movw	r1, #427	; 0x1ab
 800bca6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bcaa:	f009 fddd 	bl	8015868 <assert_failed>
 800bcae:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
  if (hsai->Init.PdmInit.Activation == ENABLE)
 800bcb2:	2b01      	cmp	r3, #1
 800bcb4:	f43f ae3d 	beq.w	800b932 <HAL_SAI_InitProtocol+0x22>
 800bcb8:	6823      	ldr	r3, [r4, #0]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800bcba:	f645 0204 	movw	r2, #22532	; 0x5804
 800bcbe:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bcc2:	4293      	cmp	r3, r2
 800bcc4:	d054      	beq.n	800bd70 <HAL_SAI_InitProtocol+0x460>
 800bcc6:	f645 0224 	movw	r2, #22564	; 0x5824
 800bcca:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bcce:	4293      	cmp	r3, r2
 800bcd0:	d04e      	beq.n	800bd70 <HAL_SAI_InitProtocol+0x460>
  else if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 800bcd2:	f645 4204 	movw	r2, #23556	; 0x5c04
 800bcd6:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bcda:	4293      	cmp	r3, r2
 800bcdc:	f000 8171 	beq.w	800bfc2 <HAL_SAI_InitProtocol+0x6b2>
 800bce0:	f645 4224 	movw	r2, #23588	; 0x5c24
 800bce4:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bce8:	4293      	cmp	r3, r2
 800bcea:	f000 816a 	beq.w	800bfc2 <HAL_SAI_InitProtocol+0x6b2>
  else if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
 800bcee:	f246 0204 	movw	r2, #24580	; 0x6004
 800bcf2:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bcf6:	4293      	cmp	r3, r2
 800bcf8:	f000 82a2 	beq.w	800c240 <HAL_SAI_InitProtocol+0x930>
 800bcfc:	f246 0224 	movw	r2, #24612	; 0x6024
 800bd00:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bd04:	4293      	cmp	r3, r2
 800bd06:	f000 829b 	beq.w	800c240 <HAL_SAI_InitProtocol+0x930>
  else if ((hsai->Instance == SAI4_Block_A) || (hsai->Instance == SAI4_Block_B))
 800bd0a:	f245 4204 	movw	r2, #21508	; 0x5404
 800bd0e:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800bd12:	4293      	cmp	r3, r2
 800bd14:	d006      	beq.n	800bd24 <HAL_SAI_InitProtocol+0x414>
 800bd16:	f245 4224 	movw	r2, #21540	; 0x5424
 800bd1a:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800bd1e:	4293      	cmp	r3, r2
 800bd20:	f47f ae34 	bne.w	800b98c <HAL_SAI_InitProtocol+0x7c>
    SaiBaseAddress = SAI4;
 800bd24:	f44f 45a8 	mov.w	r5, #21504	; 0x5400
 800bd28:	f6c5 0500 	movt	r5, #22528	; 0x5800
 800bd2c:	e024      	b.n	800bd78 <HAL_SAI_InitProtocol+0x468>
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bd2e:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800bd30:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bd32:	64a2      	str	r2, [r4, #72]	; 0x48
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800bd34:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bd36:	66e2      	str	r2, [r4, #108]	; 0x6c
 800bd38:	e68a      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 16U * nbslot;
 800bd3a:	0136      	lsls	r6, r6, #4
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bd3c:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800bd3e:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 16U * nbslot;
 800bd40:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bd42:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800bd44:	66e2      	str	r2, [r4, #108]	; 0x6c
 800bd46:	e683      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800bd48:	0176      	lsls	r6, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800bd4a:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bd4c:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 32U * nbslot;
 800bd4e:	6566      	str	r6, [r4, #84]	; 0x54
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800bd50:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bd52:	66e2      	str	r2, [r4, #108]	; 0x6c
 800bd54:	e67c      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
 800bd56:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800bd5a:	e9c4 5318 	strd	r5, r3, [r4, #96]	; 0x60
  switch (datasize)
 800bd5e:	2f03      	cmp	r7, #3
 800bd60:	f63f ae14 	bhi.w	800b98c <HAL_SAI_InitProtocol+0x7c>
 800bd64:	e8df f017 	tbh	[pc, r7, lsl #1]
 800bd68:	010e011e 	.word	0x010e011e
 800bd6c:	00f300fd 	.word	0x00f300fd
    SaiBaseAddress = SAI1;
 800bd70:	f44f 45b0 	mov.w	r5, #22528	; 0x5800
 800bd74:	f2c4 0501 	movt	r5, #16385	; 0x4001
  if (hsai->State == HAL_SAI_STATE_RESET)
 800bd78:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
 800bd7c:	f002 01ff 	and.w	r1, r2, #255	; 0xff
 800bd80:	2a00      	cmp	r2, #0
 800bd82:	f000 821a 	beq.w	800c1ba <HAL_SAI_InitProtocol+0x8aa>
  *              the configuration information for SAI module.
  * @retval None
  */
static HAL_StatusTypeDef SAI_Disable(SAI_HandleTypeDef *hsai)
{
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800bd86:	f240 20b0 	movw	r0, #688	; 0x2b0
  HAL_StatusTypeDef status = HAL_OK;

  /* Disable the SAI instance */
  __HAL_SAI_DISABLE(hsai);
 800bd8a:	6819      	ldr	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800bd8c:	f64e 461b 	movw	r6, #60443	; 0xec1b
 800bd90:	f2c2 0000 	movt	r0, #8192	; 0x2000
  __HAL_SAI_DISABLE(hsai);
 800bd94:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800bd98:	f2c9 56cb 	movt	r6, #38347	; 0x95cb
 800bd9c:	6802      	ldr	r2, [r0, #0]
  __HAL_SAI_DISABLE(hsai);
 800bd9e:	6019      	str	r1, [r3, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800bda0:	fba6 3202 	umull	r3, r2, r6, r2
 800bda4:	0b12      	lsrs	r2, r2, #12

  do
  {
    /* Check for the Timeout */
    if (count == 0U)
 800bda6:	0093      	lsls	r3, r2, #2
 800bda8:	b33a      	cbz	r2, 800bdfa <HAL_SAI_InitProtocol+0x4ea>
      status = HAL_TIMEOUT;
      break;
    }
    count--;
  }
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800bdaa:	6821      	ldr	r1, [r4, #0]
    count--;
 800bdac:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800bdae:	680a      	ldr	r2, [r1, #0]
 800bdb0:	03d7      	lsls	r7, r2, #15
 800bdb2:	d504      	bpl.n	800bdbe <HAL_SAI_InitProtocol+0x4ae>
    if (count == 0U)
 800bdb4:	b30b      	cbz	r3, 800bdfa <HAL_SAI_InitProtocol+0x4ea>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800bdb6:	680a      	ldr	r2, [r1, #0]
    count--;
 800bdb8:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800bdba:	03d2      	lsls	r2, r2, #15
 800bdbc:	d4fa      	bmi.n	800bdb4 <HAL_SAI_InitProtocol+0x4a4>
  switch (hsai->Init.SynchroExt)
 800bdbe:	68e3      	ldr	r3, [r4, #12]
  hsai->State = HAL_SAI_STATE_BUSY;
 800bdc0:	2202      	movs	r2, #2
  switch (hsai->Init.SynchroExt)
 800bdc2:	2b01      	cmp	r3, #1
  hsai->State = HAL_SAI_STATE_BUSY;
 800bdc4:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
  switch (hsai->Init.SynchroExt)
 800bdc8:	f000 80f6 	beq.w	800bfb8 <HAL_SAI_InitProtocol+0x6a8>
 800bdcc:	4293      	cmp	r3, r2
 800bdce:	bf15      	itete	ne
 800bdd0:	4610      	movne	r0, r2
 800bdd2:	2123      	moveq	r1, #35	; 0x23
 800bdd4:	2103      	movne	r1, #3
 800bdd6:	2022      	moveq	r0, #34	; 0x22
 800bdd8:	bf0b      	itete	eq
 800bdda:	2621      	moveq	r6, #33	; 0x21
 800bddc:	2601      	movne	r6, #1
 800bdde:	2220      	moveq	r2, #32
 800bde0:	2200      	movne	r2, #0
  switch (hsai->Init.Synchro)
 800bde2:	68a3      	ldr	r3, [r4, #8]
 800bde4:	3b01      	subs	r3, #1
 800bde6:	2b04      	cmp	r3, #4
 800bde8:	f200 81e1 	bhi.w	800c1ae <HAL_SAI_InitProtocol+0x89e>
 800bdec:	e8df f013 	tbh	[pc, r3, lsl #1]
 800bdf0:	00ef01dc 	.word	0x00ef01dc
 800bdf4:	00ee01e1 	.word	0x00ee01e1
 800bdf8:	023c      	.short	0x023c
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800bdfa:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    return HAL_ERROR;
 800bdfe:	2001      	movs	r0, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800be00:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800be04:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
}
 800be08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_SAI_SLOT_ACTIVE(hsai->SlotInit.SlotActive));
 800be0a:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be0e:	f44f 71d4 	mov.w	r1, #424	; 0x1a8
 800be12:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be16:	f009 fd27 	bl	8015868 <assert_failed>
 800be1a:	e73c      	b.n	800bc96 <HAL_SAI_InitProtocol+0x386>
  assert_param(IS_SAI_BLOCK_SLOT_NUMBER(hsai->SlotInit.SlotNumber));
 800be1c:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be20:	f240 11a7 	movw	r1, #423	; 0x1a7
 800be24:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be28:	f009 fd1e 	bl	8015868 <assert_failed>
 800be2c:	e72e      	b.n	800bc8c <HAL_SAI_InitProtocol+0x37c>
  assert_param(IS_SAI_BLOCK_FIRSTBIT_OFFSET(hsai->SlotInit.FirstBitOffset));
 800be2e:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be32:	f240 11a5 	movw	r1, #421	; 0x1a5
 800be36:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be3a:	f009 fd15 	bl	8015868 <assert_failed>
 800be3e:	e712      	b.n	800bc66 <HAL_SAI_InitProtocol+0x356>
  assert_param(IS_SAI_BLOCK_FS_OFFSET(hsai->FrameInit.FSOffset));
 800be40:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be44:	f44f 71d1 	mov.w	r1, #418	; 0x1a2
 800be48:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be4c:	f009 fd0c 	bl	8015868 <assert_failed>
 800be50:	e705      	b.n	800bc5e <HAL_SAI_InitProtocol+0x34e>
  assert_param(IS_SAI_BLOCK_FS_POLARITY(hsai->FrameInit.FSPolarity));
 800be52:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be56:	f240 11a1 	movw	r1, #417	; 0x1a1
 800be5a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be5e:	f009 fd03 	bl	8015868 <assert_failed>
 800be62:	e6f7      	b.n	800bc54 <HAL_SAI_InitProtocol+0x344>
  assert_param(IS_SAI_BLOCK_FS_DEFINITION(hsai->FrameInit.FSDefinition));
 800be64:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be68:	f44f 71d0 	mov.w	r1, #416	; 0x1a0
 800be6c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be70:	f009 fcfa 	bl	8015868 <assert_failed>
 800be74:	e6e9      	b.n	800bc4a <HAL_SAI_InitProtocol+0x33a>
  assert_param(IS_SAI_BLOCK_OUTPUT_DRIVE(hsai->Init.OutputDrive));
 800be76:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be7a:	f44f 71ca 	mov.w	r1, #404	; 0x194
 800be7e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be82:	f009 fcf1 	bl	8015868 <assert_failed>
 800be86:	e6a7      	b.n	800bbd8 <HAL_SAI_InitProtocol+0x2c8>
  assert_param(IS_SAI_BLOCK_SYNCHRO(hsai->Init.Synchro));
 800be88:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be8c:	f44f 71c5 	mov.w	r1, #394	; 0x18a
 800be90:	f6c0 0002 	movt	r0, #2050	; 0x802
 800be94:	f009 fce8 	bl	8015868 <assert_failed>
 800be98:	e68f      	b.n	800bbba <HAL_SAI_InitProtocol+0x2aa>
  assert_param(IS_SAI_BLOCK_FIRST_BIT(hsai->Init.FirstBit));
 800be9a:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800be9e:	f44f 71c4 	mov.w	r1, #392	; 0x188
 800bea2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bea6:	f009 fcdf 	bl	8015868 <assert_failed>
 800beaa:	e677      	b.n	800bb9c <HAL_SAI_InitProtocol+0x28c>
  assert_param(IS_SAI_BLOCK_MODE(hsai->Init.AudioMode));
 800beac:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800beb0:	f44f 71c3 	mov.w	r1, #390	; 0x186
 800beb4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800beb8:	f009 fcd6 	bl	8015868 <assert_failed>
 800bebc:	e65f      	b.n	800bb7e <HAL_SAI_InitProtocol+0x26e>
  assert_param(IS_SAI_BLOCK_ACTIVE_FRAME(hsai->FrameInit.ActiveFrameLength));
 800bebe:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bec2:	f240 119f 	movw	r1, #415	; 0x19f
 800bec6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800beca:	f009 fccd 	bl	8015868 <assert_failed>
 800bece:	e6b7      	b.n	800bc40 <HAL_SAI_InitProtocol+0x330>
  assert_param(IS_SAI_BLOCK_FRAME_LENGTH(hsai->FrameInit.FrameLength));
 800bed0:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bed4:	f44f 71cf 	mov.w	r1, #414	; 0x19e
 800bed8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bedc:	f009 fcc4 	bl	8015868 <assert_failed>
 800bee0:	e6a9      	b.n	800bc36 <HAL_SAI_InitProtocol+0x326>
  assert_param(IS_SAI_BLOCK_MCK_OVERSAMPLING(hsai->Init.MckOverSampling));
 800bee2:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bee6:	f240 119b 	movw	r1, #411	; 0x19b
 800beea:	f6c0 0002 	movt	r0, #2050	; 0x802
 800beee:	f009 fcbb 	bl	8015868 <assert_failed>
 800bef2:	e69b      	b.n	800bc2c <HAL_SAI_InitProtocol+0x31c>
  assert_param(IS_SAI_BLOCK_SYNCEXT(hsai->Init.SynchroExt));
 800bef4:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bef8:	f44f 71cd 	mov.w	r1, #410	; 0x19a
 800befc:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bf00:	f009 fcb2 	bl	8015868 <assert_failed>
 800bf04:	e68d      	b.n	800bc22 <HAL_SAI_InitProtocol+0x312>
  assert_param(IS_SAI_BLOCK_TRISTATE_MANAGEMENT(hsai->Init.TriState));
 800bf06:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bf0a:	f240 1199 	movw	r1, #409	; 0x199
 800bf0e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bf12:	f009 fca9 	bl	8015868 <assert_failed>
 800bf16:	e680      	b.n	800bc1a <HAL_SAI_InitProtocol+0x30a>
  assert_param(IS_SAI_MONO_STEREO_MODE(hsai->Init.MonoStereoMode));
 800bf18:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bf1c:	f240 1197 	movw	r1, #407	; 0x197
 800bf20:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bf24:	f009 fca0 	bl	8015868 <assert_failed>
 800bf28:	e664      	b.n	800bbf4 <HAL_SAI_InitProtocol+0x2e4>
  assert_param(IS_SAI_BLOCK_FIFO_THRESHOLD(hsai->Init.FIFOThreshold));
 800bf2a:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bf2e:	f44f 71cb 	mov.w	r1, #406	; 0x196
 800bf32:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bf36:	f009 fc97 	bl	8015868 <assert_failed>
 800bf3a:	e656      	b.n	800bbea <HAL_SAI_InitProtocol+0x2da>
  assert_param(IS_SAI_BLOCK_NODIVIDER(hsai->Init.NoDivider));
 800bf3c:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800bf40:	f240 1195 	movw	r1, #405	; 0x195
 800bf44:	f6c0 0002 	movt	r0, #2050	; 0x802
 800bf48:	f009 fc8e 	bl	8015868 <assert_failed>
 800bf4c:	e649      	b.n	800bbe2 <HAL_SAI_InitProtocol+0x2d2>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf4e:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800bf50:	21e0      	movs	r1, #224	; 0xe0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bf52:	2280      	movs	r2, #128	; 0x80
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf54:	01b3      	lsls	r3, r6, #6
      hsai->Init.DataSize = SAI_DATASIZE_32;
 800bf56:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf58:	0176      	lsls	r6, r6, #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bf5a:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf5c:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
 800bf60:	e576      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf62:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800bf64:	21c0      	movs	r1, #192	; 0xc0
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bf66:	2280      	movs	r2, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800bf68:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf6a:	ea4f 1386 	mov.w	r3, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_24;
 800bf6e:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf70:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bf74:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf76:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800bf7a:	f47f ad69 	bne.w	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->SlotInit.FirstBitOffset = 8;
 800bf7e:	2308      	movs	r3, #8
 800bf80:	66a3      	str	r3, [r4, #104]	; 0x68
 800bf82:	e565      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf84:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bf86:	2380      	movs	r3, #128	; 0x80
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800bf88:	2d02      	cmp	r5, #2
      hsai->FrameInit.FrameLength = 64U * (nbslot / 2U);
 800bf8a:	ea4f 1286 	mov.w	r2, r6, lsl #6
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bf8e:	64a3      	str	r3, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf90:	ea4f 1646 	mov.w	r6, r6, lsl #5
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_32B;
 800bf94:	66e3      	str	r3, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 32U * (nbslot / 2U);
 800bf96:	e9c4 2615 	strd	r2, r6, [r4, #84]	; 0x54
  if (protocol == SAI_I2S_LSBJUSTIFIED)
 800bf9a:	f47f ad59 	bne.w	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->SlotInit.FirstBitOffset = 16;
 800bf9e:	2310      	movs	r3, #16
 800bfa0:	66a3      	str	r3, [r4, #104]	; 0x68
 800bfa2:	e555      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 800bfa4:	0876      	lsrs	r6, r6, #1
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bfa6:	2180      	movs	r1, #128	; 0x80
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800bfa8:	2240      	movs	r2, #64	; 0x40
      hsai->FrameInit.FrameLength = 32U * (nbslot / 2U);
 800bfaa:	0173      	lsls	r3, r6, #5
      hsai->Init.DataSize = SAI_DATASIZE_16;
 800bfac:	64a1      	str	r1, [r4, #72]	; 0x48
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 800bfae:	0136      	lsls	r6, r6, #4
      hsai->SlotInit.SlotSize = SAI_SLOTSIZE_16B;
 800bfb0:	66e2      	str	r2, [r4, #108]	; 0x6c
      hsai->FrameInit.ActiveFrameLength = 16U * (nbslot / 2U);
 800bfb2:	e9c4 3615 	strd	r3, r6, [r4, #84]	; 0x54
 800bfb6:	e54b      	b.n	800ba50 <HAL_SAI_InitProtocol+0x140>
  switch (hsai->Init.SynchroExt)
 800bfb8:	2113      	movs	r1, #19
 800bfba:	2012      	movs	r0, #18
 800bfbc:	2611      	movs	r6, #17
      tmpregisterGCR = SAI_GCR_SYNCOUT_0;
 800bfbe:	2210      	movs	r2, #16
 800bfc0:	e70f      	b.n	800bde2 <HAL_SAI_InitProtocol+0x4d2>
    SaiBaseAddress = SAI2;
 800bfc2:	f44f 45b8 	mov.w	r5, #23552	; 0x5c00
 800bfc6:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800bfca:	e6d5      	b.n	800bd78 <HAL_SAI_InitProtocol+0x468>
      tmpregisterGCR |= SAI_GCR_SYNCIN_1;
 800bfcc:	4602      	mov	r2, r0
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800bfce:	f44f 6600 	mov.w	r6, #2048	; 0x800
  SaiBaseAddress->GCR = tmpregisterGCR;
 800bfd2:	602a      	str	r2, [r5, #0]
  if (hsai->Init.AudioFrequency != SAI_AUDIO_FREQUENCY_MCKDIV)
 800bfd4:	6a23      	ldr	r3, [r4, #32]
 800bfd6:	2b00      	cmp	r3, #0
 800bfd8:	d060      	beq.n	800c09c <HAL_SAI_InitProtocol+0x78c>
    if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI1_Block_B))
 800bfda:	f645 0204 	movw	r2, #22532	; 0x5804
 800bfde:	6823      	ldr	r3, [r4, #0]
 800bfe0:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800bfe4:	4293      	cmp	r3, r2
 800bfe6:	f000 814f 	beq.w	800c288 <HAL_SAI_InitProtocol+0x978>
 800bfea:	f645 0024 	movw	r0, #22564	; 0x5824
 800bfee:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800bff2:	1a18      	subs	r0, r3, r0
 800bff4:	fab0 f080 	clz	r0, r0
 800bff8:	0940      	lsrs	r0, r0, #5
 800bffa:	2800      	cmp	r0, #0
 800bffc:	f040 8144 	bne.w	800c288 <HAL_SAI_InitProtocol+0x978>
    if ((hsai->Instance == SAI2_Block_A) || (hsai->Instance == SAI2_Block_B))
 800c000:	f645 4204 	movw	r2, #23556	; 0x5c04
 800c004:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800c008:	4293      	cmp	r3, r2
 800c00a:	f000 8137 	beq.w	800c27c <HAL_SAI_InitProtocol+0x96c>
 800c00e:	f645 4224 	movw	r2, #23588	; 0x5c24
 800c012:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800c016:	4293      	cmp	r3, r2
 800c018:	f000 8130 	beq.w	800c27c <HAL_SAI_InitProtocol+0x96c>
    if ((hsai->Instance == SAI3_Block_A) || (hsai->Instance == SAI3_Block_B))
 800c01c:	f246 0204 	movw	r2, #24580	; 0x6004
 800c020:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800c024:	4293      	cmp	r3, r2
 800c026:	f000 8123 	beq.w	800c270 <HAL_SAI_InitProtocol+0x960>
 800c02a:	f246 0224 	movw	r2, #24612	; 0x6024
 800c02e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800c032:	4293      	cmp	r3, r2
 800c034:	f000 811c 	beq.w	800c270 <HAL_SAI_InitProtocol+0x960>
    if (hsai->Instance == SAI4_Block_A)
 800c038:	f245 4204 	movw	r2, #21508	; 0x5404
 800c03c:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800c040:	4293      	cmp	r3, r2
 800c042:	f000 8135 	beq.w	800c2b0 <HAL_SAI_InitProtocol+0x9a0>
    if (hsai->Instance == SAI4_Block_B)
 800c046:	f245 4224 	movw	r2, #21540	; 0x5424
 800c04a:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800c04e:	4293      	cmp	r3, r2
 800c050:	f000 8129 	beq.w	800c2a6 <HAL_SAI_InitProtocol+0x996>
    if (hsai->Init.NoDivider == SAI_MASTERDIVIDER_DISABLE)
 800c054:	69a2      	ldr	r2, [r4, #24]
 800c056:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 800c05a:	6a23      	ldr	r3, [r4, #32]
 800c05c:	f5b2 2f00 	cmp.w	r2, #524288	; 0x80000
 800c060:	ea4f 0040 	mov.w	r0, r0, lsl #1
 800c064:	f000 80fa 	beq.w	800c25c <HAL_SAI_InitProtocol+0x94c>
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 800c068:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 800c06a:	021b      	lsls	r3, r3, #8
      tmposr = (hsai->Init.MckOverSampling == SAI_MCK_OVERSAMPLING_ENABLE) ? 2U : 1U;
 800c06c:	f1b2 6f80 	cmp.w	r2, #67108864	; 0x4000000
 800c070:	bf14      	ite	ne
 800c072:	2201      	movne	r2, #1
 800c074:	2202      	moveq	r2, #2
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * tmposr * 256U);
 800c076:	fb02 f303 	mul.w	r3, r2, r3
 800c07a:	fbb0 f3f3 	udiv	r3, r0, r3
    hsai->Init.Mckdiv = tmpval / 10U;
 800c07e:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 800c082:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
 800c086:	fba2 1203 	umull	r1, r2, r2, r3
 800c08a:	08d2      	lsrs	r2, r2, #3
    if ((tmpval % 10U) > 8U)
 800c08c:	eb02 0182 	add.w	r1, r2, r2, lsl #2
 800c090:	eba3 0341 	sub.w	r3, r3, r1, lsl #1
 800c094:	2b09      	cmp	r3, #9
      hsai->Init.Mckdiv += 1U;
 800c096:	bf08      	it	eq
 800c098:	3201      	addeq	r2, #1
 800c09a:	6262      	str	r2, [r4, #36]	; 0x24
  if ((hsai->Init.AudioMode == SAI_MODEMASTER_TX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c09c:	6863      	ldr	r3, [r4, #4]
 800c09e:	6d22      	ldr	r2, [r4, #80]	; 0x50
 800c0a0:	f033 0702 	bics.w	r7, r3, #2
 800c0a4:	f040 80bd 	bne.w	800c222 <HAL_SAI_InitProtocol+0x912>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 800c0a8:	2a01      	cmp	r2, #1
 800c0aa:	bf18      	it	ne
 800c0ac:	f44f 7700 	movne.w	r7, #512	; 0x200
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800c0b0:	f7f4 fcde 	bl	8000a70 <HAL_GetREVID>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800c0b4:	6822      	ldr	r2, [r4, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800c0b6:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800c0ba:	f24c 0310 	movw	r3, #49168	; 0xc010
 800c0be:	6811      	ldr	r1, [r2, #0]
  if (HAL_GetREVID() >= REV_ID_B) /* STM32H7xx Rev.B and above */
 800c0c0:	f0c0 809e 	bcc.w	800c200 <HAL_SAI_InitProtocol+0x8f0>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800c0c4:	f2cf 0305 	movt	r3, #61445	; 0xf005
 800c0c8:	400b      	ands	r3, r1
 800c0ca:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800c0cc:	6863      	ldr	r3, [r4, #4]
 800c0ce:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 800c0d0:	e9d4 1211 	ldrd	r1, r2, [r4, #68]	; 0x44
 800c0d4:	430b      	orrs	r3, r1
 800c0d6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800c0d8:	4313      	orrs	r3, r2
 800c0da:	6962      	ldr	r2, [r4, #20]
 800c0dc:	4303      	orrs	r3, r0
 800c0de:	69a0      	ldr	r0, [r4, #24]
 800c0e0:	430b      	orrs	r3, r1
 800c0e2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 800c0e4:	4313      	orrs	r3, r2
 800c0e6:	6922      	ldr	r2, [r4, #16]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800c0e8:	4303      	orrs	r3, r0
 800c0ea:	6820      	ldr	r0, [r4, #0]
 800c0ec:	430b      	orrs	r3, r1
 800c0ee:	6801      	ldr	r1, [r0, #0]
 800c0f0:	4313      	orrs	r3, r2
                            hsai->Init.NoDivider | (hsai->Init.Mckdiv << 20) |     \
 800c0f2:	6a62      	ldr	r2, [r4, #36]	; 0x24
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800c0f4:	430b      	orrs	r3, r1
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 800c0f6:	f24f 0120 	movw	r1, #61472	; 0xf020
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800c0fa:	ea43 5302 	orr.w	r3, r3, r2, lsl #20
 800c0fe:	4333      	orrs	r3, r6
 800c100:	433b      	orrs	r3, r7
 800c102:	6003      	str	r3, [r0, #0]
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800c104:	f641 73f0 	movw	r3, #8176	; 0x1ff0
 800c108:	6826      	ldr	r6, [r4, #0]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800c10a:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800c10e:	f6cf 73ff 	movt	r3, #65535	; 0xffff
 800c112:	6872      	ldr	r2, [r6, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800c114:	f6cf 70f8 	movt	r0, #65528	; 0xfff8
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800c118:	4013      	ands	r3, r2
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
 800c11a:	f645 0204 	movw	r2, #22532	; 0x5804
  hsai->Instance->CR2 &= ~(SAI_xCR2_FTH | SAI_xCR2_FFLUSH | SAI_xCR2_COMP | SAI_xCR2_CPL);
 800c11e:	6073      	str	r3, [r6, #4]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
 800c120:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai->Instance->CR2 |= (hsai->Init.FIFOThreshold | hsai->Init.CompandingMode | hsai->Init.TriState);
 800c124:	69e3      	ldr	r3, [r4, #28]
 800c126:	e9d4 760c 	ldrd	r7, r6, [r4, #48]	; 0x30
 800c12a:	433b      	orrs	r3, r7
 800c12c:	6827      	ldr	r7, [r4, #0]
 800c12e:	4333      	orrs	r3, r6
 800c130:	687e      	ldr	r6, [r7, #4]
 800c132:	4333      	orrs	r3, r6
 800c134:	607b      	str	r3, [r7, #4]
  hsai->Instance->FRCR &= (~(SAI_xFRCR_FRL | SAI_xFRCR_FSALL | SAI_xFRCR_FSDEF | \
 800c136:	6823      	ldr	r3, [r4, #0]
 800c138:	689e      	ldr	r6, [r3, #8]
 800c13a:	4030      	ands	r0, r6
 800c13c:	6098      	str	r0, [r3, #8]
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800c13e:	6e63      	ldr	r3, [r4, #100]	; 0x64
 800c140:	6827      	ldr	r7, [r4, #0]
 800c142:	e9d4 6017 	ldrd	r6, r0, [r4, #92]	; 0x5c
 800c146:	4333      	orrs	r3, r6
 800c148:	6d66      	ldr	r6, [r4, #84]	; 0x54
 800c14a:	4303      	orrs	r3, r0
 800c14c:	68b8      	ldr	r0, [r7, #8]
 800c14e:	3e01      	subs	r6, #1
 800c150:	4303      	orrs	r3, r0
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 800c152:	6da0      	ldr	r0, [r4, #88]	; 0x58
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800c154:	4333      	orrs	r3, r6
                           ((hsai->FrameInit.ActiveFrameLength - 1U) << 8));
 800c156:	3801      	subs	r0, #1
  hsai->Instance->FRCR |= ((hsai->FrameInit.FrameLength - 1U) |
 800c158:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 800c15c:	60bb      	str	r3, [r7, #8]
  hsai->Instance->SLOTR &= (~(SAI_xSLOTR_FBOFF | SAI_xSLOTR_SLOTSZ |  \
 800c15e:	6820      	ldr	r0, [r4, #0]
 800c160:	68c3      	ldr	r3, [r0, #12]
 800c162:	4019      	ands	r1, r3
 800c164:	60c1      	str	r1, [r0, #12]
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800c166:	6820      	ldr	r0, [r4, #0]
 800c168:	e9d4 361a 	ldrd	r3, r6, [r4, #104]	; 0x68
 800c16c:	68c1      	ldr	r1, [r0, #12]
 800c16e:	4333      	orrs	r3, r6
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800c170:	6f66      	ldr	r6, [r4, #116]	; 0x74
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800c172:	430b      	orrs	r3, r1
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800c174:	6f21      	ldr	r1, [r4, #112]	; 0x70
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800c176:	ea43 4306 	orr.w	r3, r3, r6, lsl #16
                           (hsai->SlotInit.SlotActive << 16) | ((hsai->SlotInit.SlotNumber - 1U) <<  8);
 800c17a:	3901      	subs	r1, #1
  hsai->Instance->SLOTR |= hsai->SlotInit.FirstBitOffset | hsai->SlotInit.SlotSize | \
 800c17c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800c180:	60c3      	str	r3, [r0, #12]
  if ((hsai->Instance == SAI1_Block_A) || (hsai->Instance == SAI4_Block_A))
 800c182:	6823      	ldr	r3, [r4, #0]
 800c184:	4293      	cmp	r3, r2
 800c186:	d028      	beq.n	800c1da <HAL_SAI_InitProtocol+0x8ca>
 800c188:	f245 4204 	movw	r2, #21508	; 0x5404
 800c18c:	f6c5 0200 	movt	r2, #22528	; 0x5800
 800c190:	4293      	cmp	r3, r2
 800c192:	d022      	beq.n	800c1da <HAL_SAI_InitProtocol+0x8ca>
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800c194:	2300      	movs	r3, #0
  hsai->State = HAL_SAI_STATE_READY;
 800c196:	2201      	movs	r2, #1
  hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800c198:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
  return HAL_OK;
 800c19c:	4618      	mov	r0, r3
  __HAL_UNLOCK(hsai);
 800c19e:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
  hsai->State = HAL_SAI_STATE_READY;
 800c1a2:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
}
 800c1a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      syncen_bits = SAI_xCR1_SYNCEN_0;
 800c1a8:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800c1ac:	e711      	b.n	800bfd2 <HAL_SAI_InitProtocol+0x6c2>
      syncen_bits = 0;
 800c1ae:	2600      	movs	r6, #0
 800c1b0:	e70f      	b.n	800bfd2 <HAL_SAI_InitProtocol+0x6c2>
      tmpregisterGCR |= SAI_GCR_SYNCIN_0;
 800c1b2:	4632      	mov	r2, r6
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800c1b4:	f44f 6600 	mov.w	r6, #2048	; 0x800
 800c1b8:	e70b      	b.n	800bfd2 <HAL_SAI_InitProtocol+0x6c2>
    hsai->Lock = HAL_UNLOCKED;
 800c1ba:	f884 1090 	strb.w	r1, [r4, #144]	; 0x90
    HAL_SAI_MspInit(hsai);
 800c1be:	4620      	mov	r0, r4
 800c1c0:	f00a f9b4 	bl	801652c <HAL_SAI_MspInit>
 800c1c4:	6823      	ldr	r3, [r4, #0]
 800c1c6:	e5de      	b.n	800bd86 <HAL_SAI_InitProtocol+0x476>
    assert_param(IS_SAI_BLOCK_MCK_OUTPUT(hsai->Init.MckOutput));
 800c1c8:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800c1cc:	f240 118f 	movw	r1, #399	; 0x18f
 800c1d0:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c1d4:	f009 fb48 	bl	8015868 <assert_failed>
 800c1d8:	e4f9      	b.n	800bbce <HAL_SAI_InitProtocol+0x2be>
    SaiBaseAddress->PDMCR &= ~(SAI_PDMCR_PDMEN);
 800c1da:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800c1dc:	f023 0301 	bic.w	r3, r3, #1
 800c1e0:	646b      	str	r3, [r5, #68]	; 0x44
    if (hsai->Init.PdmInit.Activation == ENABLE)
 800c1e2:	f894 3038 	ldrb.w	r3, [r4, #56]	; 0x38
 800c1e6:	2b01      	cmp	r3, #1
 800c1e8:	d1d4      	bne.n	800c194 <HAL_SAI_InitProtocol+0x884>
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800c1ea:	e9d4 230f 	ldrd	r2, r3, [r4, #60]	; 0x3c
                               ((hsai->Init.PdmInit.MicPairsNbr - 1U) << SAI_PDMCR_MICNBR_Pos));
 800c1ee:	3a01      	subs	r2, #1
      SaiBaseAddress->PDMCR = (hsai->Init.PdmInit.ClockEnable |
 800c1f0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800c1f4:	646b      	str	r3, [r5, #68]	; 0x44
      SaiBaseAddress->PDMCR |= SAI_PDMCR_PDMEN;
 800c1f6:	6c6b      	ldr	r3, [r5, #68]	; 0x44
 800c1f8:	f043 0301 	orr.w	r3, r3, #1
 800c1fc:	646b      	str	r3, [r5, #68]	; 0x44
 800c1fe:	e7c9      	b.n	800c194 <HAL_SAI_InitProtocol+0x884>
    hsai->Instance->CR1 &= ~(SAI_xCR1_MODE | SAI_xCR1_PRTCFG |  SAI_xCR1_DS |      \
 800c200:	f6cf 0305 	movt	r3, #63493	; 0xf805
 800c204:	400b      	ands	r3, r1
 800c206:	6013      	str	r3, [r2, #0]
    hsai->Instance->CR1 |= (hsai->Init.AudioMode | hsai->Init.Protocol |           \
 800c208:	6863      	ldr	r3, [r4, #4]
 800c20a:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 800c20c:	e9d4 2011 	ldrd	r2, r0, [r4, #68]	; 0x44
 800c210:	4313      	orrs	r3, r2
 800c212:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800c214:	4303      	orrs	r3, r0
 800c216:	6960      	ldr	r0, [r4, #20]
 800c218:	430b      	orrs	r3, r1
 800c21a:	69a1      	ldr	r1, [r4, #24]
 800c21c:	4313      	orrs	r3, r2
 800c21e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 800c220:	e762      	b.n	800c0e8 <HAL_SAI_InitProtocol+0x7d8>
    ckstr_bits = (hsai->Init.ClockStrobing == SAI_CLOCKSTROBING_RISINGEDGE) ? 0U : SAI_xCR1_CKSTR;
 800c222:	2a01      	cmp	r2, #1
 800c224:	bf14      	ite	ne
 800c226:	2700      	movne	r7, #0
 800c228:	f44f 7700 	moveq.w	r7, #512	; 0x200
 800c22c:	e740      	b.n	800c0b0 <HAL_SAI_InitProtocol+0x7a0>
  assert_param(IS_SAI_BLOCK_COMPANDING_MODE(hsai->Init.CompandingMode));
 800c22e:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800c232:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800c236:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c23a:	f009 fb15 	bl	8015868 <assert_failed>
 800c23e:	e4e7      	b.n	800bc10 <HAL_SAI_InitProtocol+0x300>
    SaiBaseAddress = SAI3;
 800c240:	f44f 45c0 	mov.w	r5, #24576	; 0x6000
 800c244:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800c248:	e596      	b.n	800bd78 <HAL_SAI_InitProtocol+0x468>
  assert_param(IS_SAI_BLOCK_DATASIZE(hsai->Init.DataSize));
 800c24a:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800c24e:	f240 1187 	movw	r1, #391	; 0x187
 800c252:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c256:	f009 fb07 	bl	8015868 <assert_failed>
 800c25a:	e49a      	b.n	800bb92 <HAL_SAI_InitProtocol+0x282>
      tmpval = (freq * 10U) / (hsai->Init.AudioFrequency * hsai->FrameInit.FrameLength);
 800c25c:	6d62      	ldr	r2, [r4, #84]	; 0x54
 800c25e:	fb02 f303 	mul.w	r3, r2, r3
 800c262:	fbb0 f3f3 	udiv	r3, r0, r3
 800c266:	e70a      	b.n	800c07e <HAL_SAI_InitProtocol+0x76e>
      tmpregisterGCR |= (SAI_GCR_SYNCIN_1 | SAI_GCR_SYNCIN_0);
 800c268:	460a      	mov	r2, r1
      syncen_bits = SAI_xCR1_SYNCEN_1;
 800c26a:	f44f 6600 	mov.w	r6, #2048	; 0x800
 800c26e:	e6b0      	b.n	800bfd2 <HAL_SAI_InitProtocol+0x6c2>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI3);
 800c270:	f44f 7000 	mov.w	r0, #512	; 0x200
 800c274:	f7ff f986 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800c278:	6823      	ldr	r3, [r4, #0]
 800c27a:	e6dd      	b.n	800c038 <HAL_SAI_InitProtocol+0x728>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI2);
 800c27c:	f44f 7000 	mov.w	r0, #512	; 0x200
 800c280:	f7ff f980 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800c284:	6823      	ldr	r3, [r4, #0]
 800c286:	e6c9      	b.n	800c01c <HAL_SAI_InitProtocol+0x70c>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI1);
 800c288:	f44f 7080 	mov.w	r0, #256	; 0x100
 800c28c:	f7ff f97a 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800c290:	6823      	ldr	r3, [r4, #0]
 800c292:	e6b5      	b.n	800c000 <HAL_SAI_InitProtocol+0x6f0>
  assert_param(IS_SAI_ALL_INSTANCE(hsai->Instance));
 800c294:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800c298:	f240 1181 	movw	r1, #385	; 0x181
 800c29c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c2a0:	f009 fae2 	bl	8015868 <assert_failed>
 800c2a4:	e418      	b.n	800bad8 <HAL_SAI_InitProtocol+0x1c8>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4B);
 800c2a6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800c2aa:	f7ff f96b 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800c2ae:	e6d1      	b.n	800c054 <HAL_SAI_InitProtocol+0x744>
      freq = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SAI4A);
 800c2b0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800c2b4:	f7ff f966 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800c2b8:	6823      	ldr	r3, [r4, #0]
 800c2ba:	e6c4      	b.n	800c046 <HAL_SAI_InitProtocol+0x736>
  assert_param(IS_SAI_AUDIO_FREQUENCY(hsai->Init.AudioFrequency));
 800c2bc:	f64d 40c0 	movw	r0, #56512	; 0xdcc0
 800c2c0:	f44f 71c2 	mov.w	r1, #388	; 0x184
 800c2c4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800c2c8:	f009 face 	bl	8015868 <assert_failed>
 800c2cc:	e445      	b.n	800bb5a <HAL_SAI_InitProtocol+0x24a>
 800c2ce:	bf00      	nop

0800c2d0 <HAL_SAI_Abort>:
{
 800c2d0:	b570      	push	{r4, r5, r6, lr}
  __HAL_LOCK(hsai);
 800c2d2:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
 800c2d6:	2b01      	cmp	r3, #1
 800c2d8:	d04d      	beq.n	800c376 <HAL_SAI_Abort+0xa6>
 800c2da:	2601      	movs	r6, #1
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c2dc:	6803      	ldr	r3, [r0, #0]
 800c2de:	4604      	mov	r4, r0
  __HAL_LOCK(hsai);
 800c2e0:	f880 6090 	strb.w	r6, [r0, #144]	; 0x90
  if ((hsai->Instance->CR1 & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c2e4:	681d      	ldr	r5, [r3, #0]
 800c2e6:	f415 3500 	ands.w	r5, r5, #131072	; 0x20000
 800c2ea:	d00d      	beq.n	800c308 <HAL_SAI_Abort+0x38>
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800c2ec:	681a      	ldr	r2, [r3, #0]
 800c2ee:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800c2f2:	601a      	str	r2, [r3, #0]
    if ((hsai->State == HAL_SAI_STATE_BUSY_TX)&& (hsai->hdmatx != NULL))
 800c2f4:	f890 3091 	ldrb.w	r3, [r0, #145]	; 0x91
 800c2f8:	2b12      	cmp	r3, #18
 800c2fa:	d055      	beq.n	800c3a8 <HAL_SAI_Abort+0xd8>
  HAL_StatusTypeDef status = HAL_OK;
 800c2fc:	2500      	movs	r5, #0
    if ((hsai->State == HAL_SAI_STATE_BUSY_RX) && (hsai->hdmarx != NULL))
 800c2fe:	f894 3091 	ldrb.w	r3, [r4, #145]	; 0x91
 800c302:	2b22      	cmp	r3, #34	; 0x22
 800c304:	d03a      	beq.n	800c37c <HAL_SAI_Abort+0xac>
 800c306:	6823      	ldr	r3, [r4, #0]
  hsai->Instance->IMR = 0;
 800c308:	2200      	movs	r2, #0
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c30a:	f240 21b0 	movw	r1, #688	; 0x2b0
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c30e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  hsai->Instance->IMR = 0;
 800c312:	611a      	str	r2, [r3, #16]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c314:	f2c2 0100 	movt	r1, #8192	; 0x2000
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c318:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c31a:	f64e 431b 	movw	r3, #60443	; 0xec1b
 800c31e:	680a      	ldr	r2, [r1, #0]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c320:	6186      	str	r6, [r0, #24]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c322:	f2c9 53cb 	movt	r3, #38347	; 0x95cb
  __HAL_SAI_DISABLE(hsai);
 800c326:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c328:	fba3 3202 	umull	r3, r2, r3, r2
  __HAL_SAI_DISABLE(hsai);
 800c32c:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c32e:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 800c330:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
 800c334:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
 800c336:	6001      	str	r1, [r0, #0]
 800c338:	6821      	ldr	r1, [r4, #0]
    if (count == 0U)
 800c33a:	b1a2      	cbz	r2, 800c366 <HAL_SAI_Abort+0x96>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c33c:	680a      	ldr	r2, [r1, #0]
    count--;
 800c33e:	4433      	add	r3, r6
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c340:	03d0      	lsls	r0, r2, #15
 800c342:	d504      	bpl.n	800c34e <HAL_SAI_Abort+0x7e>
    if (count == 0U)
 800c344:	b17b      	cbz	r3, 800c366 <HAL_SAI_Abort+0x96>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c346:	680a      	ldr	r2, [r1, #0]
    count--;
 800c348:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c34a:	03d2      	lsls	r2, r2, #15
 800c34c:	d4fa      	bmi.n	800c344 <HAL_SAI_Abort+0x74>
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800c34e:	684b      	ldr	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 800c350:	2001      	movs	r0, #1
  __HAL_UNLOCK(hsai);
 800c352:	2200      	movs	r2, #0
  SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800c354:	f043 0308 	orr.w	r3, r3, #8
 800c358:	604b      	str	r3, [r1, #4]
  hsai->State = HAL_SAI_STATE_READY;
 800c35a:	f884 0091 	strb.w	r0, [r4, #145]	; 0x91
}
 800c35e:	4628      	mov	r0, r5
  __HAL_UNLOCK(hsai);
 800c360:	f884 2090 	strb.w	r2, [r4, #144]	; 0x90
}
 800c364:	bd70      	pop	{r4, r5, r6, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c366:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
    status = HAL_ERROR;
 800c36a:	2501      	movs	r5, #1
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c36c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c370:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800c374:	e7eb      	b.n	800c34e <HAL_SAI_Abort+0x7e>
  __HAL_LOCK(hsai);
 800c376:	2502      	movs	r5, #2
}
 800c378:	4628      	mov	r0, r5
 800c37a:	bd70      	pop	{r4, r5, r6, pc}
    if ((hsai->State == HAL_SAI_STATE_BUSY_RX) && (hsai->hdmarx != NULL))
 800c37c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800c380:	2800      	cmp	r0, #0
 800c382:	d0c0      	beq.n	800c306 <HAL_SAI_Abort+0x36>
      if (HAL_DMA_Abort(hsai->hdmarx) != HAL_OK)
 800c384:	f7f7 fefc 	bl	8004180 <HAL_DMA_Abort>
 800c388:	2800      	cmp	r0, #0
 800c38a:	d0bc      	beq.n	800c306 <HAL_SAI_Abort+0x36>
        if (hsai->hdmarx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 800c38c:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800c390:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c392:	2b80      	cmp	r3, #128	; 0x80
 800c394:	d0b7      	beq.n	800c306 <HAL_SAI_Abort+0x36>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c396:	f8d4 2094 	ldr.w	r2, [r4, #148]	; 0x94
          status = HAL_ERROR;
 800c39a:	2501      	movs	r5, #1
 800c39c:	6823      	ldr	r3, [r4, #0]
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c39e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800c3a2:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
 800c3a6:	e7af      	b.n	800c308 <HAL_SAI_Abort+0x38>
    if ((hsai->State == HAL_SAI_STATE_BUSY_TX)&& (hsai->hdmatx != NULL))
 800c3a8:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800c3ac:	2800      	cmp	r0, #0
 800c3ae:	d0a5      	beq.n	800c2fc <HAL_SAI_Abort+0x2c>
      if (HAL_DMA_Abort(hsai->hdmatx) != HAL_OK)
 800c3b0:	f7f7 fee6 	bl	8004180 <HAL_DMA_Abort>
 800c3b4:	2800      	cmp	r0, #0
 800c3b6:	d0a1      	beq.n	800c2fc <HAL_SAI_Abort+0x2c>
        if (hsai->hdmatx->ErrorCode != HAL_DMA_ERROR_NO_XFER)
 800c3b8:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800c3bc:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800c3be:	2b80      	cmp	r3, #128	; 0x80
 800c3c0:	d09c      	beq.n	800c2fc <HAL_SAI_Abort+0x2c>
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c3c2:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
          status = HAL_ERROR;
 800c3c6:	4635      	mov	r5, r6
          hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c3c8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c3cc:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800c3d0:	e795      	b.n	800c2fe <HAL_SAI_Abort+0x2e>
 800c3d2:	bf00      	nop

0800c3d4 <HAL_SAI_Transmit_DMA>:
{
 800c3d4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800c3d8:	460f      	mov	r7, r1
 800c3da:	4604      	mov	r4, r0
 800c3dc:	4691      	mov	r9, r2
  uint32_t tickstart = HAL_GetTick();
 800c3de:	f7f4 fb2d 	bl	8000a3c <HAL_GetTick>
  if ((pData == NULL) || (Size == 0U))
 800c3e2:	2f00      	cmp	r7, #0
 800c3e4:	d06e      	beq.n	800c4c4 <HAL_SAI_Transmit_DMA+0xf0>
 800c3e6:	fab9 f589 	clz	r5, r9
 800c3ea:	096d      	lsrs	r5, r5, #5
 800c3ec:	2d00      	cmp	r5, #0
 800c3ee:	d169      	bne.n	800c4c4 <HAL_SAI_Transmit_DMA+0xf0>
  if (hsai->State == HAL_SAI_STATE_READY)
 800c3f0:	f894 6091 	ldrb.w	r6, [r4, #145]	; 0x91
 800c3f4:	b2f6      	uxtb	r6, r6
 800c3f6:	2e01      	cmp	r6, #1
 800c3f8:	d160      	bne.n	800c4bc <HAL_SAI_Transmit_DMA+0xe8>
    __HAL_LOCK(hsai);
 800c3fa:	f894 3090 	ldrb.w	r3, [r4, #144]	; 0x90
 800c3fe:	2b01      	cmp	r3, #1
 800c400:	d05c      	beq.n	800c4bc <HAL_SAI_Transmit_DMA+0xe8>
 800c402:	4680      	mov	r8, r0
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800c404:	f24c 6049 	movw	r0, #50761	; 0xc649
 800c408:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 800c40c:	f04f 0c12 	mov.w	ip, #18
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800c410:	f6c0 0000 	movt	r0, #2048	; 0x800
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800c414:	f24c 51e5 	movw	r1, #50661	; 0xc5e5
    hsai->pBuffPtr = pData;
 800c418:	67a7      	str	r7, [r4, #120]	; 0x78
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800c41a:	f24c 63c5 	movw	r3, #50885	; 0xc6c5
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800c41e:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800c422:	f6c0 0100 	movt	r1, #2048	; 0x800
    hsai->XferSize = Size;
 800c426:	f8a4 907c 	strh.w	r9, [r4, #124]	; 0x7c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800c42a:	f6c0 0300 	movt	r3, #2048	; 0x800
    __HAL_LOCK(hsai);
 800c42e:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->XferCount = Size;
 800c432:	f8a4 907e 	strh.w	r9, [r4, #126]	; 0x7e
    hsai->State = HAL_SAI_STATE_BUSY_TX;
 800c436:	f884 c091 	strb.w	ip, [r4, #145]	; 0x91
    hsai->hdmatx->XferHalfCpltCallback = SAI_DMATxHalfCplt;
 800c43a:	6410      	str	r0, [r2, #64]	; 0x40
    hsai->hdmatx->XferCpltCallback = SAI_DMATxCplt;
 800c43c:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800c440:	63d1      	str	r1, [r2, #60]	; 0x3c
    hsai->hdmatx->XferErrorCallback = SAI_DMAError;
 800c442:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 800c446:	64d3      	str	r3, [r2, #76]	; 0x4c
    hsai->hdmatx->XferAbortCallback = NULL;
 800c448:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800c44c:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmatx, (uint32_t)hsai->pBuffPtr, (uint32_t)&hsai->Instance->DR, hsai->XferSize) != HAL_OK)
 800c44e:	6822      	ldr	r2, [r4, #0]
 800c450:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 800c454:	321c      	adds	r2, #28
 800c456:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 800c458:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 800c45c:	f7f7 fade 	bl	8003a1c <HAL_DMA_Start_IT>
 800c460:	4607      	mov	r7, r0
 800c462:	2800      	cmp	r0, #0
 800c464:	d132      	bne.n	800c4cc <HAL_SAI_Transmit_DMA+0xf8>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c466:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800c468:	6863      	ldr	r3, [r4, #4]
 800c46a:	2a08      	cmp	r2, #8
 800c46c:	d03c      	beq.n	800c4e8 <HAL_SAI_Transmit_DMA+0x114>
 800c46e:	2005      	movs	r0, #5
 800c470:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c472:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c474:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
 800c476:	2b01      	cmp	r3, #1
 800c478:	bf88      	it	hi
 800c47a:	4602      	movhi	r2, r0
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c47c:	690b      	ldr	r3, [r1, #16]
 800c47e:	4313      	orrs	r3, r2
 800c480:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800c482:	6822      	ldr	r2, [r4, #0]
 800c484:	6813      	ldr	r3, [r2, #0]
 800c486:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c48a:	6013      	str	r3, [r2, #0]
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800c48c:	e006      	b.n	800c49c <HAL_SAI_Transmit_DMA+0xc8>
      if ((HAL_GetTick() - tickstart) > SAI_LONG_TIMEOUT)
 800c48e:	f7f4 fad5 	bl	8000a3c <HAL_GetTick>
 800c492:	eba0 0008 	sub.w	r0, r0, r8
 800c496:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800c49a:	d81b      	bhi.n	800c4d4 <HAL_SAI_Transmit_DMA+0x100>
    while ((hsai->Instance->SR & SAI_xSR_FLVL) == SAI_FIFOSTATUS_EMPTY)
 800c49c:	6822      	ldr	r2, [r4, #0]
 800c49e:	6955      	ldr	r5, [r2, #20]
 800c4a0:	f415 25e0 	ands.w	r5, r5, #458752	; 0x70000
 800c4a4:	d0f3      	beq.n	800c48e <HAL_SAI_Transmit_DMA+0xba>
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800c4a6:	6813      	ldr	r3, [r2, #0]
 800c4a8:	03db      	lsls	r3, r3, #15
 800c4aa:	d403      	bmi.n	800c4b4 <HAL_SAI_Transmit_DMA+0xe0>
      __HAL_SAI_ENABLE(hsai);
 800c4ac:	6813      	ldr	r3, [r2, #0]
 800c4ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800c4b2:	6013      	str	r3, [r2, #0]
    __HAL_UNLOCK(hsai);
 800c4b4:	2300      	movs	r3, #0
 800c4b6:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
    return HAL_OK;
 800c4ba:	e000      	b.n	800c4be <HAL_SAI_Transmit_DMA+0xea>
    return HAL_BUSY;
 800c4bc:	2702      	movs	r7, #2
}
 800c4be:	4638      	mov	r0, r7
 800c4c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    return  HAL_ERROR;
 800c4c4:	2701      	movs	r7, #1
}
 800c4c6:	4638      	mov	r0, r7
 800c4c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      __HAL_UNLOCK(hsai);
 800c4cc:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
 800c4d0:	4637      	mov	r7, r6
 800c4d2:	e7f4      	b.n	800c4be <HAL_SAI_Transmit_DMA+0xea>
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c4d4:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
 800c4d8:	2703      	movs	r7, #3
        __HAL_UNLOCK(hsai);
 800c4da:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
        hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c4de:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c4e2:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
        return HAL_TIMEOUT;
 800c4e6:	e7ea      	b.n	800c4be <HAL_SAI_Transmit_DMA+0xea>
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c4e8:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c4ec:	2a01      	cmp	r2, #1
 800c4ee:	bf0b      	itete	eq
 800c4f0:	2015      	moveq	r0, #21
 800c4f2:	2005      	movne	r0, #5
 800c4f4:	2271      	moveq	r2, #113	; 0x71
 800c4f6:	2261      	movne	r2, #97	; 0x61
 800c4f8:	e7bb      	b.n	800c472 <HAL_SAI_Transmit_DMA+0x9e>
 800c4fa:	bf00      	nop

0800c4fc <HAL_SAI_Receive_DMA>:
  if ((pData == NULL) || (Size == 0U))
 800c4fc:	2900      	cmp	r1, #0
 800c4fe:	d061      	beq.n	800c5c4 <HAL_SAI_Receive_DMA+0xc8>
{
 800c500:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if ((pData == NULL) || (Size == 0U))
 800c502:	fab2 f582 	clz	r5, r2
 800c506:	096d      	lsrs	r5, r5, #5
 800c508:	2d00      	cmp	r5, #0
 800c50a:	d159      	bne.n	800c5c0 <HAL_SAI_Receive_DMA+0xc4>
  if (hsai->State == HAL_SAI_STATE_READY)
 800c50c:	f890 6091 	ldrb.w	r6, [r0, #145]	; 0x91
 800c510:	b2f6      	uxtb	r6, r6
 800c512:	2e01      	cmp	r6, #1
 800c514:	d152      	bne.n	800c5bc <HAL_SAI_Receive_DMA+0xc0>
    __HAL_LOCK(hsai);
 800c516:	f890 3090 	ldrb.w	r3, [r0, #144]	; 0x90
 800c51a:	2b01      	cmp	r3, #1
 800c51c:	d04e      	beq.n	800c5bc <HAL_SAI_Receive_DMA+0xc0>
 800c51e:	4604      	mov	r4, r0
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800c520:	f24c 67b9 	movw	r7, #50873	; 0xc6b9
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 800c524:	f04f 0e22 	mov.w	lr, #34	; 0x22
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800c528:	f24c 6055 	movw	r0, #50773	; 0xc655
    hsai->XferSize = Size;
 800c52c:	f8a4 207c 	strh.w	r2, [r4, #124]	; 0x7c
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800c530:	f6c0 0700 	movt	r7, #2048	; 0x800
    hsai->XferCount = Size;
 800c534:	f8a4 207e 	strh.w	r2, [r4, #126]	; 0x7e
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800c538:	f6c0 0000 	movt	r0, #2048	; 0x800
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800c53c:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800c540:	f24c 63c5 	movw	r3, #50885	; 0xc6c5
    hsai->pBuffPtr = pData;
 800c544:	67a1      	str	r1, [r4, #120]	; 0x78
    hsai->ErrorCode = HAL_SAI_ERROR_NONE;
 800c546:	f8c4 5094 	str.w	r5, [r4, #148]	; 0x94
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800c54a:	f6c0 0300 	movt	r3, #2048	; 0x800
    __HAL_LOCK(hsai);
 800c54e:	f884 6090 	strb.w	r6, [r4, #144]	; 0x90
    hsai->State = HAL_SAI_STATE_BUSY_RX;
 800c552:	f884 e091 	strb.w	lr, [r4, #145]	; 0x91
    hsai->hdmarx->XferHalfCpltCallback = SAI_DMARxHalfCplt;
 800c556:	6417      	str	r7, [r2, #64]	; 0x40
    hsai->hdmarx->XferCpltCallback = SAI_DMARxCplt;
 800c558:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800c55c:	63d0      	str	r0, [r2, #60]	; 0x3c
    hsai->hdmarx->XferErrorCallback = SAI_DMAError;
 800c55e:	f8d4 2084 	ldr.w	r2, [r4, #132]	; 0x84
 800c562:	64d3      	str	r3, [r2, #76]	; 0x4c
    hsai->hdmarx->XferAbortCallback = NULL;
 800c564:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800c568:	651d      	str	r5, [r3, #80]	; 0x50
    if (HAL_DMA_Start_IT(hsai->hdmarx, (uint32_t)&hsai->Instance->DR, (uint32_t)hsai->pBuffPtr, hsai->XferSize) != HAL_OK)
 800c56a:	6821      	ldr	r1, [r4, #0]
 800c56c:	f8b4 307c 	ldrh.w	r3, [r4, #124]	; 0x7c
 800c570:	311c      	adds	r1, #28
 800c572:	6fa2      	ldr	r2, [r4, #120]	; 0x78
 800c574:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800c578:	f7f7 fa50 	bl	8003a1c <HAL_DMA_Start_IT>
 800c57c:	bb20      	cbnz	r0, 800c5c8 <HAL_SAI_Receive_DMA+0xcc>
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c57e:	6c62      	ldr	r2, [r4, #68]	; 0x44
 800c580:	6863      	ldr	r3, [r4, #4]
 800c582:	2a08      	cmp	r2, #8
 800c584:	d024      	beq.n	800c5d0 <HAL_SAI_Receive_DMA+0xd4>
 800c586:	2505      	movs	r5, #5
 800c588:	2261      	movs	r2, #97	; 0x61
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c58a:	6821      	ldr	r1, [r4, #0]
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c58c:	3b02      	subs	r3, #2
    tmpIT |= SAI_IT_WCKCFG;
 800c58e:	2b01      	cmp	r3, #1
 800c590:	bf88      	it	hi
 800c592:	462a      	movhi	r2, r5
    __HAL_SAI_ENABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c594:	690b      	ldr	r3, [r1, #16]
 800c596:	4313      	orrs	r3, r2
 800c598:	610b      	str	r3, [r1, #16]
    hsai->Instance->CR1 |= SAI_xCR1_DMAEN;
 800c59a:	6822      	ldr	r2, [r4, #0]
 800c59c:	6813      	ldr	r3, [r2, #0]
 800c59e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800c5a2:	6013      	str	r3, [r2, #0]
    if ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) == 0U)
 800c5a4:	6823      	ldr	r3, [r4, #0]
 800c5a6:	681a      	ldr	r2, [r3, #0]
 800c5a8:	03d2      	lsls	r2, r2, #15
 800c5aa:	d403      	bmi.n	800c5b4 <HAL_SAI_Receive_DMA+0xb8>
      __HAL_SAI_ENABLE(hsai);
 800c5ac:	681a      	ldr	r2, [r3, #0]
 800c5ae:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 800c5b2:	601a      	str	r2, [r3, #0]
    __HAL_UNLOCK(hsai);
 800c5b4:	2300      	movs	r3, #0
 800c5b6:	f884 3090 	strb.w	r3, [r4, #144]	; 0x90
}
 800c5ba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return HAL_BUSY;
 800c5bc:	2002      	movs	r0, #2
}
 800c5be:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 800c5c0:	2001      	movs	r0, #1
}
 800c5c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    return  HAL_ERROR;
 800c5c4:	2001      	movs	r0, #1
}
 800c5c6:	4770      	bx	lr
      __HAL_UNLOCK(hsai);
 800c5c8:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
      return  HAL_ERROR;
 800c5cc:	4630      	mov	r0, r6
}
 800c5ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c5d0:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c5d4:	2a01      	cmp	r2, #1
 800c5d6:	bf0b      	itete	eq
 800c5d8:	2515      	moveq	r5, #21
 800c5da:	2505      	movne	r5, #5
 800c5dc:	2271      	moveq	r2, #113	; 0x71
 800c5de:	2261      	movne	r2, #97	; 0x61
 800c5e0:	e7d3      	b.n	800c58a <HAL_SAI_Receive_DMA+0x8e>
 800c5e2:	bf00      	nop

0800c5e4 <SAI_DMATxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxCplt(DMA_HandleTypeDef *hdma)
{
 800c5e4:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800c5e6:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800c5e8:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800c5ea:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c5ee:	d01a      	beq.n	800c626 <SAI_DMATxCplt+0x42>
  {
    hsai->XferCount = 0;
 800c5f0:	2300      	movs	r3, #0

    /* Disable SAI Tx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800c5f2:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
 800c5f4:	f8a0 307e 	strh.w	r3, [r0, #126]	; 0x7e
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800c5f8:	6813      	ldr	r3, [r2, #0]
 800c5fa:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800c5fe:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c600:	6c43      	ldr	r3, [r0, #68]	; 0x44
 800c602:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c604:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c606:	d011      	beq.n	800c62c <SAI_DMATxCplt+0x48>
 800c608:	f06f 0261 	mvn.w	r2, #97	; 0x61
 800c60c:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c610:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c612:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
 800c614:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c616:	42a3      	cmp	r3, r4
 800c618:	bf88      	it	hi
 800c61a:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c61c:	690b      	ldr	r3, [r1, #16]
 800c61e:	4013      	ands	r3, r2
 800c620:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
 800c622:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxCpltCallback(hsai);
#else
  HAL_SAI_TxCpltCallback(hsai);
 800c626:	f006 fed5 	bl	80133d4 <HAL_SAI_TxCpltCallback>
#endif
}
 800c62a:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c62c:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c630:	2a01      	cmp	r2, #1
 800c632:	bf0b      	itete	eq
 800c634:	f06f 0271 	mvneq.w	r2, #113	; 0x71
 800c638:	f06f 0261 	mvnne.w	r2, #97	; 0x61
 800c63c:	f06f 0515 	mvneq.w	r5, #21
 800c640:	f06f 0505 	mvnne.w	r5, #5
 800c644:	e7e4      	b.n	800c610 <SAI_DMATxCplt+0x2c>
 800c646:	bf00      	nop

0800c648 <SAI_DMATxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMATxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800c648:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->TxHalfCpltCallback(hsai);
#else
  HAL_SAI_TxHalfCpltCallback(hsai);
 800c64a:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800c64c:	f006 fec4 	bl	80133d8 <HAL_SAI_TxHalfCpltCallback>
#endif
}
 800c650:	bd08      	pop	{r3, pc}
 800c652:	bf00      	nop

0800c654 <SAI_DMARxCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxCplt(DMA_HandleTypeDef *hdma)
{
 800c654:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

  if (hdma->Init.Mode != DMA_CIRCULAR)
 800c656:	69c3      	ldr	r3, [r0, #28]
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800c658:	6b80      	ldr	r0, [r0, #56]	; 0x38
  if (hdma->Init.Mode != DMA_CIRCULAR)
 800c65a:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800c65e:	d01a      	beq.n	800c696 <SAI_DMARxCplt+0x42>
  {
    /* Disable Rx DMA Request */
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800c660:	6802      	ldr	r2, [r0, #0]
    hsai->XferCount = 0;
 800c662:	2100      	movs	r1, #0
    hsai->Instance->CR1 &= (uint32_t)(~SAI_xCR1_DMAEN);
 800c664:	6813      	ldr	r3, [r2, #0]
 800c666:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800c66a:	6013      	str	r3, [r2, #0]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c66c:	6c43      	ldr	r3, [r0, #68]	; 0x44
    hsai->XferCount = 0;
 800c66e:	f8a0 107e 	strh.w	r1, [r0, #126]	; 0x7e
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c672:	2b08      	cmp	r3, #8
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c674:	6843      	ldr	r3, [r0, #4]
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c676:	d011      	beq.n	800c69c <SAI_DMARxCplt+0x48>
 800c678:	f06f 0261 	mvn.w	r2, #97	; 0x61
 800c67c:	f06f 0505 	mvn.w	r5, #5
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c680:	3b02      	subs	r3, #2

    /* Stop the interrupts error handling */
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c682:	6801      	ldr	r1, [r0, #0]

    hsai->State = HAL_SAI_STATE_READY;
 800c684:	2401      	movs	r4, #1
  if ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODESLAVE_TX))
 800c686:	42a3      	cmp	r3, r4
 800c688:	bf88      	it	hi
 800c68a:	462a      	movhi	r2, r5
    __HAL_SAI_DISABLE_IT(hsai, SAI_InterruptFlag(hsai, SAI_MODE_DMA));
 800c68c:	690b      	ldr	r3, [r1, #16]
 800c68e:	4013      	ands	r3, r2
 800c690:	610b      	str	r3, [r1, #16]
    hsai->State = HAL_SAI_STATE_READY;
 800c692:	f880 4091 	strb.w	r4, [r0, #145]	; 0x91
  }
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxCpltCallback(hsai);
#else
  HAL_SAI_RxCpltCallback(hsai);
 800c696:	f006 fea1 	bl	80133dc <HAL_SAI_RxCpltCallback>
#endif
}
 800c69a:	bd38      	pop	{r3, r4, r5, pc}
      ((hsai->Init.AudioMode == SAI_MODESLAVE_RX) || (hsai->Init.AudioMode == SAI_MODEMASTER_RX)))
 800c69c:	f023 0202 	bic.w	r2, r3, #2
  if ((hsai->Init.Protocol == SAI_AC97_PROTOCOL) &&
 800c6a0:	2a01      	cmp	r2, #1
 800c6a2:	bf0b      	itete	eq
 800c6a4:	f06f 0271 	mvneq.w	r2, #113	; 0x71
 800c6a8:	f06f 0261 	mvnne.w	r2, #97	; 0x61
 800c6ac:	f06f 0515 	mvneq.w	r5, #21
 800c6b0:	f06f 0505 	mvnne.w	r5, #5
 800c6b4:	e7e4      	b.n	800c680 <SAI_DMARxCplt+0x2c>
 800c6b6:	bf00      	nop

0800c6b8 <SAI_DMARxHalfCplt>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMARxHalfCplt(DMA_HandleTypeDef *hdma)
{
 800c6b8:	b508      	push	{r3, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;

#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->RxHalfCpltCallback(hsai);
#else
  HAL_SAI_RxHalfCpltCallback(hsai);
 800c6ba:	6b80      	ldr	r0, [r0, #56]	; 0x38
 800c6bc:	f006 fe92 	bl	80133e4 <HAL_SAI_RxHalfCpltCallback>
#endif
}
 800c6c0:	bd08      	pop	{r3, pc}
 800c6c2:	bf00      	nop

0800c6c4 <SAI_DMAError>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAError(DMA_HandleTypeDef *hdma)
{
 800c6c4:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800c6c6:	6b84      	ldr	r4, [r0, #56]	; 0x38

  /* Ignore DMA FIFO error */
  if (HAL_DMA_GetError(hdma) != HAL_DMA_ERROR_FE)
 800c6c8:	f7f8 feba 	bl	8005440 <HAL_DMA_GetError>
 800c6cc:	2802      	cmp	r0, #2
 800c6ce:	d030      	beq.n	800c732 <SAI_DMAError+0x6e>
  {
    /* Set SAI error code */
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c6d0:	f8d4 1094 	ldr.w	r1, [r4, #148]	; 0x94
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c6d4:	f240 23b0 	movw	r3, #688	; 0x2b0

    /* Disable the SAI DMA request */
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800c6d8:	6822      	ldr	r2, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c6da:	f64e 451b 	movw	r5, #60443	; 0xec1b
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c6de:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c6e2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 800c6e6:	f2c9 55cb 	movt	r5, #38347	; 0x95cb
    hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c6ea:	f8c4 1094 	str.w	r1, [r4, #148]	; 0x94
    hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800c6ee:	6811      	ldr	r1, [r2, #0]
 800c6f0:	f421 3100 	bic.w	r1, r1, #131072	; 0x20000
 800c6f4:	6011      	str	r1, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c6f6:	681a      	ldr	r2, [r3, #0]
  __HAL_SAI_DISABLE(hsai);
 800c6f8:	6820      	ldr	r0, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c6fa:	fba5 3202 	umull	r3, r2, r5, r2
  __HAL_SAI_DISABLE(hsai);
 800c6fe:	6801      	ldr	r1, [r0, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c700:	0b12      	lsrs	r2, r2, #12
  __HAL_SAI_DISABLE(hsai);
 800c702:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    if (count == 0U)
 800c706:	0093      	lsls	r3, r2, #2
  __HAL_SAI_DISABLE(hsai);
 800c708:	6001      	str	r1, [r0, #0]
    if (count == 0U)
 800c70a:	b19a      	cbz	r2, 800c734 <SAI_DMAError+0x70>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c70c:	6821      	ldr	r1, [r4, #0]
    count--;
 800c70e:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c710:	680a      	ldr	r2, [r1, #0]
 800c712:	03d0      	lsls	r0, r2, #15
 800c714:	d504      	bpl.n	800c720 <SAI_DMAError+0x5c>
    if (count == 0U)
 800c716:	b16b      	cbz	r3, 800c734 <SAI_DMAError+0x70>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c718:	680a      	ldr	r2, [r1, #0]
    count--;
 800c71a:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c71c:	03d2      	lsls	r2, r2, #15
 800c71e:	d4fa      	bmi.n	800c716 <SAI_DMAError+0x52>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Set the SAI state ready to be able to start again the process */
    hsai->State = HAL_SAI_STATE_READY;
 800c720:	2201      	movs	r2, #1

    /* Initialize XferCount */
    hsai->XferCount = 0U;
 800c722:	2300      	movs	r3, #0

    /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
    hsai->ErrorCallback(hsai);
#else
    HAL_SAI_ErrorCallback(hsai);
 800c724:	4620      	mov	r0, r4
    hsai->State = HAL_SAI_STATE_READY;
 800c726:	f884 2091 	strb.w	r2, [r4, #145]	; 0x91
    hsai->XferCount = 0U;
 800c72a:	f8a4 307e 	strh.w	r3, [r4, #126]	; 0x7e
    HAL_SAI_ErrorCallback(hsai);
 800c72e:	f006 fe4d 	bl	80133cc <HAL_SAI_ErrorCallback>
#endif
  }
}
 800c732:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c734:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800c738:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c73c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
 800c740:	e7ee      	b.n	800c720 <SAI_DMAError+0x5c>
 800c742:	bf00      	nop

0800c744 <HAL_SAI_IRQHandler>:
  if (hsai->State != HAL_SAI_STATE_RESET)
 800c744:	f890 2091 	ldrb.w	r2, [r0, #145]	; 0x91
 800c748:	2a00      	cmp	r2, #0
 800c74a:	d030      	beq.n	800c7ae <HAL_SAI_IRQHandler+0x6a>
{
 800c74c:	b570      	push	{r4, r5, r6, lr}
    uint32_t itflags = hsai->Instance->SR;
 800c74e:	6802      	ldr	r2, [r0, #0]
 800c750:	4604      	mov	r4, r0
 800c752:	6951      	ldr	r1, [r2, #20]
    uint32_t itsources = hsai->Instance->IMR;
 800c754:	6915      	ldr	r5, [r2, #16]
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 800c756:	070b      	lsls	r3, r1, #28
    uint32_t cr1config = hsai->Instance->CR1;
 800c758:	6816      	ldr	r6, [r2, #0]
    if (((itflags & SAI_xSR_FREQ) == SAI_xSR_FREQ) && ((itsources & SAI_IT_FREQ) == SAI_IT_FREQ))
 800c75a:	d506      	bpl.n	800c76a <HAL_SAI_IRQHandler+0x26>
 800c75c:	072b      	lsls	r3, r5, #28
 800c75e:	d504      	bpl.n	800c76a <HAL_SAI_IRQHandler+0x26>
      hsai->InterruptServiceRoutine(hsai);
 800c760:	f8d0 308c 	ldr.w	r3, [r0, #140]	; 0x8c
}
 800c764:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      hsai->InterruptServiceRoutine(hsai);
 800c768:	4718      	bx	r3
    else if (((itflags & SAI_FLAG_OVRUDR) == SAI_FLAG_OVRUDR) && ((itsources & SAI_IT_OVRUDR) == SAI_IT_OVRUDR))
 800c76a:	07cb      	lsls	r3, r1, #31
 800c76c:	d512      	bpl.n	800c794 <HAL_SAI_IRQHandler+0x50>
 800c76e:	07e8      	lsls	r0, r5, #31
 800c770:	d510      	bpl.n	800c794 <HAL_SAI_IRQHandler+0x50>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 800c772:	2301      	movs	r3, #1
      HAL_SAI_ErrorCallback(hsai);
 800c774:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_OVRUDR);
 800c776:	6193      	str	r3, [r2, #24]
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 800c778:	f894 2091 	ldrb.w	r2, [r4, #145]	; 0x91
      hsai->ErrorCode |= tmperror;
 800c77c:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
      tmperror = ((hsai->State == HAL_SAI_STATE_BUSY_RX) ? HAL_SAI_ERROR_OVR : HAL_SAI_ERROR_UDR);
 800c780:	2a22      	cmp	r2, #34	; 0x22
 800c782:	bf0c      	ite	eq
 800c784:	2201      	moveq	r2, #1
 800c786:	2202      	movne	r2, #2
      hsai->ErrorCode |= tmperror;
 800c788:	4313      	orrs	r3, r2
 800c78a:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      HAL_SAI_ErrorCallback(hsai);
 800c78e:	f006 fe1d 	bl	80133cc <HAL_SAI_ErrorCallback>
}
 800c792:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_MUTEDET) == SAI_FLAG_MUTEDET) && ((itsources & SAI_IT_MUTEDET) == SAI_IT_MUTEDET))
 800c794:	078b      	lsls	r3, r1, #30
 800c796:	d50b      	bpl.n	800c7b0 <HAL_SAI_IRQHandler+0x6c>
 800c798:	07a8      	lsls	r0, r5, #30
 800c79a:	d509      	bpl.n	800c7b0 <HAL_SAI_IRQHandler+0x6c>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_MUTEDET);
 800c79c:	2302      	movs	r3, #2
 800c79e:	6193      	str	r3, [r2, #24]
      if (hsai->mutecallback != NULL)
 800c7a0:	f8d4 3088 	ldr.w	r3, [r4, #136]	; 0x88
 800c7a4:	2b00      	cmp	r3, #0
 800c7a6:	d0f4      	beq.n	800c792 <HAL_SAI_IRQHandler+0x4e>
}
 800c7a8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        hsai->mutecallback();
 800c7ac:	4718      	bx	r3
 800c7ae:	4770      	bx	lr
    else if (((itflags & SAI_FLAG_AFSDET) == SAI_FLAG_AFSDET) && ((itsources & SAI_IT_AFSDET) == SAI_IT_AFSDET))
 800c7b0:	068b      	lsls	r3, r1, #26
 800c7b2:	d512      	bpl.n	800c7da <HAL_SAI_IRQHandler+0x96>
 800c7b4:	06a8      	lsls	r0, r5, #26
 800c7b6:	d510      	bpl.n	800c7da <HAL_SAI_IRQHandler+0x96>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_AFSDET);
 800c7b8:	2320      	movs	r3, #32
 800c7ba:	6193      	str	r3, [r2, #24]
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c7bc:	03b2      	lsls	r2, r6, #14
      hsai->ErrorCode |= HAL_SAI_ERROR_AFSDET;
 800c7be:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800c7c2:	f043 0304 	orr.w	r3, r3, #4
 800c7c6:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c7ca:	d424      	bmi.n	800c816 <HAL_SAI_IRQHandler+0xd2>
        (void) HAL_SAI_Abort(hsai);
 800c7cc:	4620      	mov	r0, r4
 800c7ce:	f7ff fd7f 	bl	800c2d0 <HAL_SAI_Abort>
        HAL_SAI_ErrorCallback(hsai);
 800c7d2:	4620      	mov	r0, r4
 800c7d4:	f006 fdfa 	bl	80133cc <HAL_SAI_ErrorCallback>
}
 800c7d8:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_LFSDET) == SAI_FLAG_LFSDET) && ((itsources & SAI_IT_LFSDET) == SAI_IT_LFSDET))
 800c7da:	064b      	lsls	r3, r1, #25
 800c7dc:	d50c      	bpl.n	800c7f8 <HAL_SAI_IRQHandler+0xb4>
 800c7de:	0668      	lsls	r0, r5, #25
 800c7e0:	d50a      	bpl.n	800c7f8 <HAL_SAI_IRQHandler+0xb4>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_LFSDET);
 800c7e2:	2340      	movs	r3, #64	; 0x40
 800c7e4:	6193      	str	r3, [r2, #24]
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c7e6:	03b2      	lsls	r2, r6, #14
      hsai->ErrorCode |= HAL_SAI_ERROR_LFSDET;
 800c7e8:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800c7ec:	f043 0308 	orr.w	r3, r3, #8
 800c7f0:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c7f4:	d5ea      	bpl.n	800c7cc <HAL_SAI_IRQHandler+0x88>
 800c7f6:	e00e      	b.n	800c816 <HAL_SAI_IRQHandler+0xd2>
    else if (((itflags & SAI_FLAG_WCKCFG) == SAI_FLAG_WCKCFG) && ((itsources & SAI_IT_WCKCFG) == SAI_IT_WCKCFG))
 800c7f8:	074b      	lsls	r3, r1, #29
 800c7fa:	d532      	bpl.n	800c862 <HAL_SAI_IRQHandler+0x11e>
 800c7fc:	0768      	lsls	r0, r5, #29
 800c7fe:	d530      	bpl.n	800c862 <HAL_SAI_IRQHandler+0x11e>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 800c800:	2304      	movs	r3, #4
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c802:	f416 3600 	ands.w	r6, r6, #131072	; 0x20000
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_WCKCFG);
 800c806:	6193      	str	r3, [r2, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_WCKCFG;
 800c808:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800c80c:	f043 0320 	orr.w	r3, r3, #32
 800c810:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      if ((cr1config & SAI_xCR1_DMAEN) == SAI_xCR1_DMAEN)
 800c814:	d03f      	beq.n	800c896 <HAL_SAI_IRQHandler+0x152>
        if (hsai->hdmatx != NULL)
 800c816:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 800c81a:	b14b      	cbz	r3, 800c830 <HAL_SAI_IRQHandler+0xec>
          hsai->hdmatx->XferAbortCallback = SAI_DMAAbort;
 800c81c:	f64c 02b5 	movw	r2, #51381	; 0xc8b5
 800c820:	f6c0 0200 	movt	r2, #2048	; 0x800
 800c824:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_DMA_Abort_IT(hsai->hdmatx) != HAL_OK)
 800c826:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 800c82a:	f7f7 ff6b 	bl	8004704 <HAL_DMA_Abort_IT>
 800c82e:	bb40      	cbnz	r0, 800c882 <HAL_SAI_IRQHandler+0x13e>
        if (hsai->hdmarx != NULL)
 800c830:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
 800c834:	2b00      	cmp	r3, #0
 800c836:	d0ac      	beq.n	800c792 <HAL_SAI_IRQHandler+0x4e>
          hsai->hdmarx->XferAbortCallback = SAI_DMAAbort;
 800c838:	f64c 02b5 	movw	r2, #51381	; 0xc8b5
 800c83c:	f6c0 0200 	movt	r2, #2048	; 0x800
 800c840:	651a      	str	r2, [r3, #80]	; 0x50
          if (HAL_DMA_Abort_IT(hsai->hdmarx) != HAL_OK)
 800c842:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 800c846:	f7f7 ff5d 	bl	8004704 <HAL_DMA_Abort_IT>
 800c84a:	2800      	cmp	r0, #0
 800c84c:	d0a1      	beq.n	800c792 <HAL_SAI_IRQHandler+0x4e>
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c84e:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800c852:	4620      	mov	r0, r4
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c854:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c858:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800c85c:	f006 fdb6 	bl	80133cc <HAL_SAI_ErrorCallback>
}
 800c860:	bd70      	pop	{r4, r5, r6, pc}
    else if (((itflags & SAI_FLAG_CNRDY) == SAI_FLAG_CNRDY) && ((itsources & SAI_IT_CNRDY) == SAI_IT_CNRDY))
 800c862:	06c9      	lsls	r1, r1, #27
 800c864:	d595      	bpl.n	800c792 <HAL_SAI_IRQHandler+0x4e>
 800c866:	06eb      	lsls	r3, r5, #27
 800c868:	d593      	bpl.n	800c792 <HAL_SAI_IRQHandler+0x4e>
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 800c86a:	2310      	movs	r3, #16
      HAL_SAI_ErrorCallback(hsai);
 800c86c:	4620      	mov	r0, r4
      __HAL_SAI_CLEAR_FLAG(hsai, SAI_FLAG_CNRDY);
 800c86e:	6193      	str	r3, [r2, #24]
      hsai->ErrorCode |= HAL_SAI_ERROR_CNREADY;
 800c870:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800c874:	f043 0310 	orr.w	r3, r3, #16
 800c878:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      HAL_SAI_ErrorCallback(hsai);
 800c87c:	f006 fda6 	bl	80133cc <HAL_SAI_ErrorCallback>
}
 800c880:	bd70      	pop	{r4, r5, r6, pc}
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c882:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800c886:	4620      	mov	r0, r4
            hsai->ErrorCode |= HAL_SAI_ERROR_DMA;
 800c888:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c88c:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
            HAL_SAI_ErrorCallback(hsai);
 800c890:	f006 fd9c 	bl	80133cc <HAL_SAI_ErrorCallback>
 800c894:	e7cc      	b.n	800c830 <HAL_SAI_IRQHandler+0xec>
        hsai->Instance->IMR = 0U;
 800c896:	6822      	ldr	r2, [r4, #0]
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c898:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        hsai->State = HAL_SAI_STATE_READY;
 800c89c:	2301      	movs	r3, #1
        HAL_SAI_ErrorCallback(hsai);
 800c89e:	4620      	mov	r0, r4
        hsai->Instance->IMR = 0U;
 800c8a0:	6116      	str	r6, [r2, #16]
        hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c8a2:	6822      	ldr	r2, [r4, #0]
 800c8a4:	6191      	str	r1, [r2, #24]
        hsai->XferCount = 0U;
 800c8a6:	f8a4 607e 	strh.w	r6, [r4, #126]	; 0x7e
        hsai->State = HAL_SAI_STATE_READY;
 800c8aa:	f884 3091 	strb.w	r3, [r4, #145]	; 0x91
        HAL_SAI_ErrorCallback(hsai);
 800c8ae:	f006 fd8d 	bl	80133cc <HAL_SAI_ErrorCallback>
}
 800c8b2:	bd70      	pop	{r4, r5, r6, pc}

0800c8b4 <SAI_DMAAbort>:
  * @param  hdma pointer to a DMA_HandleTypeDef structure that contains
  *              the configuration information for the specified DMA module.
  * @retval None
  */
static void SAI_DMAAbort(DMA_HandleTypeDef *hdma)
{
 800c8b4:	b538      	push	{r3, r4, r5, lr}
  SAI_HandleTypeDef *hsai = (SAI_HandleTypeDef *)((DMA_HandleTypeDef *)hdma)->Parent;
 800c8b6:	6b82      	ldr	r2, [r0, #56]	; 0x38

  /* Disable DMA request */
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;

  /* Disable all interrupts and clear all flags */
  hsai->Instance->IMR = 0U;
 800c8b8:	2400      	movs	r4, #0
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c8ba:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  hsai->Instance->CR1 &= ~SAI_xCR1_DMAEN;
 800c8be:	6811      	ldr	r1, [r2, #0]
 800c8c0:	680b      	ldr	r3, [r1, #0]
 800c8c2:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 800c8c6:	600b      	str	r3, [r1, #0]
  hsai->Instance->IMR = 0U;
 800c8c8:	6813      	ldr	r3, [r2, #0]
 800c8ca:	611c      	str	r4, [r3, #16]
  hsai->Instance->CLRFR = 0xFFFFFFFFU;
 800c8cc:	6813      	ldr	r3, [r2, #0]
 800c8ce:	6198      	str	r0, [r3, #24]

  if (hsai->ErrorCode != HAL_SAI_ERROR_WCKCFG)
 800c8d0:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800c8d4:	2b20      	cmp	r3, #32
 800c8d6:	d020      	beq.n	800c91a <SAI_DMAAbort+0x66>
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c8d8:	f240 20b0 	movw	r0, #688	; 0x2b0
 800c8dc:	f64e 451b 	movw	r5, #60443	; 0xec1b
  __HAL_SAI_DISABLE(hsai);
 800c8e0:	6814      	ldr	r4, [r2, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c8e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 800c8e6:	f2c9 55cb 	movt	r5, #38347	; 0x95cb
  __HAL_SAI_DISABLE(hsai);
 800c8ea:	6823      	ldr	r3, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c8ec:	6801      	ldr	r1, [r0, #0]
  __HAL_SAI_DISABLE(hsai);
 800c8ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c8f2:	fba5 0101 	umull	r0, r1, r5, r1
  __HAL_SAI_DISABLE(hsai);
 800c8f6:	6023      	str	r3, [r4, #0]
  register uint32_t count = SAI_DEFAULT_TIMEOUT * (SystemCoreClock / 7U / 1000U);
 800c8f8:	0b09      	lsrs	r1, r1, #12
 800c8fa:	6810      	ldr	r0, [r2, #0]
    if (count == 0U)
 800c8fc:	008b      	lsls	r3, r1, #2
 800c8fe:	b1b1      	cbz	r1, 800c92e <SAI_DMAAbort+0x7a>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c900:	6801      	ldr	r1, [r0, #0]
    count--;
 800c902:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c904:	03cc      	lsls	r4, r1, #15
 800c906:	d504      	bpl.n	800c912 <SAI_DMAAbort+0x5e>
    if (count == 0U)
 800c908:	b18b      	cbz	r3, 800c92e <SAI_DMAAbort+0x7a>
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c90a:	6801      	ldr	r1, [r0, #0]
    count--;
 800c90c:	3b01      	subs	r3, #1
  while ((hsai->Instance->CR1 & SAI_xCR1_SAIEN) != 0U);
 800c90e:	03c9      	lsls	r1, r1, #15
 800c910:	d4fa      	bmi.n	800c908 <SAI_DMAAbort+0x54>
    /* Disable SAI peripheral */
    /* No need to check return value because state will be updated and HAL_SAI_ErrorCallback will be called later */
    (void) SAI_Disable(hsai);

    /* Flush the fifo */
    SET_BIT(hsai->Instance->CR2, SAI_xCR2_FFLUSH);
 800c912:	6843      	ldr	r3, [r0, #4]
 800c914:	f043 0308 	orr.w	r3, r3, #8
 800c918:	6043      	str	r3, [r0, #4]
  }
  /* Set the SAI state to ready to be able to start again the process */
  hsai->State = HAL_SAI_STATE_READY;
 800c91a:	2101      	movs	r1, #1

  /* Initialize XferCount */
  hsai->XferCount = 0U;
 800c91c:	2300      	movs	r3, #0

  /* SAI error Callback */
#if (USE_HAL_SAI_REGISTER_CALLBACKS == 1)
  hsai->ErrorCallback(hsai);
#else
  HAL_SAI_ErrorCallback(hsai);
 800c91e:	4610      	mov	r0, r2
  hsai->State = HAL_SAI_STATE_READY;
 800c920:	f882 1091 	strb.w	r1, [r2, #145]	; 0x91
  hsai->XferCount = 0U;
 800c924:	f8a2 307e 	strh.w	r3, [r2, #126]	; 0x7e
  HAL_SAI_ErrorCallback(hsai);
 800c928:	f006 fd50 	bl	80133cc <HAL_SAI_ErrorCallback>
#endif
}
 800c92c:	bd38      	pop	{r3, r4, r5, pc}
      hsai->ErrorCode |= HAL_SAI_ERROR_TIMEOUT;
 800c92e:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 800c932:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800c936:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 800c93a:	e7ea      	b.n	800c912 <SAI_DMAAbort+0x5e>

0800c93c <SD_FindSCR>:
  * @param  hsd: Pointer to SD handle
  * @param  pSCR: pointer to the buffer that will contain the SCR value
  * @retval error state
  */
static uint32_t SD_FindSCR(SD_HandleTypeDef *hsd, uint32_t *pSCR)
{
 800c93c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c940:	4605      	mov	r5, r0
 800c942:	b087      	sub	sp, #28
 800c944:	460f      	mov	r7, r1
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 800c946:	f7f4 f879 	bl	8000a3c <HAL_GetTick>
  uint32_t index = 0U;
  uint32_t tempscr[2U] = {0UL, 0UL};
  uint32_t *scr = pSCR;

  /* Set Block Size To 8 Bytes */
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800c94a:	2108      	movs	r1, #8
  uint32_t tickstart = HAL_GetTick();
 800c94c:	4606      	mov	r6, r0
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 8U);
 800c94e:	6828      	ldr	r0, [r5, #0]
 800c950:	f003 f878 	bl	800fa44 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c954:	4604      	mov	r4, r0
 800c956:	b118      	cbz	r0, 800c960 <SD_FindSCR+0x24>
            ((tempscr[0] & SDMMC_16TO23BITS) >> 8) | ((tempscr[0] & SDMMC_24TO31BITS) >> 24));

  }

  return HAL_SD_ERROR_NONE;
}
 800c958:	4620      	mov	r0, r4
 800c95a:	b007      	add	sp, #28
 800c95c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)((hsd->SdCard.RelCardAdd) << 16U));
 800c960:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 800c962:	6828      	ldr	r0, [r5, #0]
 800c964:	0409      	lsls	r1, r1, #16
 800c966:	f003 faeb 	bl	800ff40 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c96a:	4604      	mov	r4, r0
 800c96c:	2800      	cmp	r0, #0
 800c96e:	d1f3      	bne.n	800c958 <SD_FindSCR+0x1c>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800c970:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 8U;
 800c974:	2308      	movs	r3, #8
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 800c976:	2130      	movs	r1, #48	; 0x30
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800c978:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800c97a:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c97c:	2202      	movs	r2, #2
  config.DataLength    = 8U;
 800c97e:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c980:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_8B;
 800c982:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c984:	4669      	mov	r1, sp
 800c986:	6828      	ldr	r0, [r5, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800c988:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800c98a:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800c98c:	f002 fff0 	bl	800f970 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdSendSCR(hsd->Instance);
 800c990:	6828      	ldr	r0, [r5, #0]
 800c992:	f003 fb99 	bl	80100c8 <SDMMC_CmdSendSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800c996:	4604      	mov	r4, r0
 800c998:	2800      	cmp	r0, #0
 800c99a:	d1dd      	bne.n	800c958 <SD_FindSCR+0x1c>
  uint32_t index = 0U;
 800c99c:	4681      	mov	r9, r0
  uint32_t tempscr[2U] = {0UL, 0UL};
 800c99e:	4683      	mov	fp, r0
 800c9a0:	4682      	mov	sl, r0
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800c9a2:	f240 582a 	movw	r8, #1322	; 0x52a
 800c9a6:	e004      	b.n	800c9b2 <SD_FindSCR+0x76>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800c9a8:	f7f4 f848 	bl	8000a3c <HAL_GetTick>
 800c9ac:	1b80      	subs	r0, r0, r6
 800c9ae:	3001      	adds	r0, #1
 800c9b0:	d028      	beq.n	800ca04 <SD_FindSCR+0xc8>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800c9b2:	6828      	ldr	r0, [r5, #0]
 800c9b4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c9b6:	ea13 0f08 	tst.w	r3, r8
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800c9ba:	6b43      	ldr	r3, [r0, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DBCKEND | SDMMC_FLAG_DATAEND))
 800c9bc:	d10e      	bne.n	800c9dc <SD_FindSCR+0xa0>
    if((!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOE)) && (index == 0U))
 800c9be:	031b      	lsls	r3, r3, #12
 800c9c0:	d4f2      	bmi.n	800c9a8 <SD_FindSCR+0x6c>
 800c9c2:	f1b9 0f00 	cmp.w	r9, #0
 800c9c6:	d1ef      	bne.n	800c9a8 <SD_FindSCR+0x6c>
      tempscr[0] = SDMMC_ReadFIFO(hsd->Instance);
 800c9c8:	f002 ffaa 	bl	800f920 <SDMMC_ReadFIFO>
 800c9cc:	4682      	mov	sl, r0
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800c9ce:	6828      	ldr	r0, [r5, #0]
      index++;
 800c9d0:	f04f 0901 	mov.w	r9, #1
      tempscr[1] = SDMMC_ReadFIFO(hsd->Instance);
 800c9d4:	f002 ffa4 	bl	800f920 <SDMMC_ReadFIFO>
 800c9d8:	4683      	mov	fp, r0
 800c9da:	e7e5      	b.n	800c9a8 <SD_FindSCR+0x6c>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800c9dc:	0719      	lsls	r1, r3, #28
 800c9de:	d414      	bmi.n	800ca0a <SD_FindSCR+0xce>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800c9e0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c9e2:	079a      	lsls	r2, r3, #30
 800c9e4:	d414      	bmi.n	800ca10 <SD_FindSCR+0xd4>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800c9e6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800c9e8:	069b      	lsls	r3, r3, #26
 800c9ea:	d414      	bmi.n	800ca16 <SD_FindSCR+0xda>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800c9ec:	f640 713a 	movw	r1, #3898	; 0xf3a
 800c9f0:	fa9b f28b 	rev.w	r2, fp
 800c9f4:	fa9a f38a 	rev.w	r3, sl
 800c9f8:	f6c1 0100 	movt	r1, #6144	; 0x1800
 800c9fc:	6381      	str	r1, [r0, #56]	; 0x38
    *scr = (((tempscr[0] & SDMMC_0TO7BITS) << 24)  | ((tempscr[0] & SDMMC_8TO15BITS) << 8) |\
 800c9fe:	e9c7 2300 	strd	r2, r3, [r7]
  return HAL_SD_ERROR_NONE;
 800ca02:	e7a9      	b.n	800c958 <SD_FindSCR+0x1c>
      return HAL_SD_ERROR_TIMEOUT;
 800ca04:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
 800ca08:	e7a6      	b.n	800c958 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DTIMEOUT);
 800ca0a:	2408      	movs	r4, #8
 800ca0c:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800ca0e:	e7a3      	b.n	800c958 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_DCRCFAIL);
 800ca10:	2402      	movs	r4, #2
 800ca12:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800ca14:	e7a0      	b.n	800c958 <SD_FindSCR+0x1c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_FLAG_RXOVERR);
 800ca16:	2420      	movs	r4, #32
 800ca18:	6384      	str	r4, [r0, #56]	; 0x38
    return HAL_SD_ERROR_RX_OVERRUN;
 800ca1a:	e79d      	b.n	800c958 <SD_FindSCR+0x1c>

0800ca1c <HAL_SD_ReadBlocks>:
{
 800ca1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ca20:	460d      	mov	r5, r1
 800ca22:	b086      	sub	sp, #24
 800ca24:	4604      	mov	r4, r0
 800ca26:	4690      	mov	r8, r2
 800ca28:	461e      	mov	r6, r3
  uint32_t tickstart = HAL_GetTick();
 800ca2a:	f7f4 f807 	bl	8000a3c <HAL_GetTick>
  if(NULL == pData)
 800ca2e:	2d00      	cmp	r5, #0
 800ca30:	d071      	beq.n	800cb16 <HAL_SD_ReadBlocks+0xfa>
 800ca32:	4607      	mov	r7, r0
  if(hsd->State == HAL_SD_STATE_READY)
 800ca34:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800ca38:	b2c0      	uxtb	r0, r0
 800ca3a:	2801      	cmp	r0, #1
 800ca3c:	d007      	beq.n	800ca4e <HAL_SD_ReadBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800ca3e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800ca40:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800ca42:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800ca46:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800ca48:	b006      	add	sp, #24
 800ca4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800ca4e:	eb08 0306 	add.w	r3, r8, r6
 800ca52:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800ca54:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800ca56:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800ca58:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800ca5a:	d864      	bhi.n	800cb26 <HAL_SD_ReadBlocks+0x10a>
    hsd->Instance->DCTRL = 0U;
 800ca5c:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 800ca5e:	2203      	movs	r2, #3
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800ca60:	f04f 0902 	mov.w	r9, #2
    hsd->State = HAL_SD_STATE_BUSY;
 800ca64:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800ca68:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
 800ca6a:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800ca6c:	0271      	lsls	r1, r6, #9
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800ca6e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800ca70:	9101      	str	r1, [sp, #4]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800ca72:	4669      	mov	r1, sp
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800ca74:	2b01      	cmp	r3, #1
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800ca76:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800ca7a:	6820      	ldr	r0, [r4, #0]
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800ca7c:	9300      	str	r3, [sp, #0]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ca7e:	f04f 0300 	mov.w	r3, #0
      add *= 512U;
 800ca82:	bf18      	it	ne
 800ca84:	ea4f 2848 	movne.w	r8, r8, lsl #9
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800ca88:	9202      	str	r2, [sp, #8]
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800ca8a:	9305      	str	r3, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ca8c:	e9cd 9303 	strd	r9, r3, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800ca90:	f002 ff6e 	bl	800f970 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800ca94:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
 800ca96:	2e01      	cmp	r6, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800ca98:	68d3      	ldr	r3, [r2, #12]
 800ca9a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ca9e:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
 800caa0:	d957      	bls.n	800cb52 <HAL_SD_ReadBlocks+0x136>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 800caa2:	f8c4 9030 	str.w	r9, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 800caa6:	4641      	mov	r1, r8
 800caa8:	6820      	ldr	r0, [r4, #0]
 800caaa:	f003 f857 	bl	800fb5c <SDMMC_CmdReadMultiBlock>
 800caae:	4602      	mov	r2, r0
 800cab0:	6823      	ldr	r3, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 800cab2:	2a00      	cmp	r2, #0
 800cab4:	d13e      	bne.n	800cb34 <HAL_SD_ReadBlocks+0x118>
    dataremaining = config.DataLength;
 800cab6:	f8dd 9004 	ldr.w	r9, [sp, #4]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800caba:	e006      	b.n	800caca <HAL_SD_ReadBlocks+0xae>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800cabc:	f7f3 ffbe 	bl	8000a3c <HAL_GetTick>
 800cac0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800cac2:	1bc0      	subs	r0, r0, r7
 800cac4:	4298      	cmp	r0, r3
 800cac6:	d27b      	bcs.n	800cbc0 <HAL_SD_ReadBlocks+0x1a4>
 800cac8:	6823      	ldr	r3, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800caca:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cacc:	f412 7f95 	tst.w	r2, #298	; 0x12a
 800cad0:	d147      	bne.n	800cb62 <HAL_SD_ReadBlocks+0x146>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF) && (dataremaining >= 32U))
 800cad2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cad4:	0411      	lsls	r1, r2, #16
 800cad6:	d5f1      	bpl.n	800cabc <HAL_SD_ReadBlocks+0xa0>
 800cad8:	f1b9 0f1f 	cmp.w	r9, #31
 800cadc:	d9ee      	bls.n	800cabc <HAL_SD_ReadBlocks+0xa0>
 800cade:	f105 0a04 	add.w	sl, r5, #4
 800cae2:	f105 0824 	add.w	r8, r5, #36	; 0x24
 800cae6:	e000      	b.n	800caea <HAL_SD_ReadBlocks+0xce>
 800cae8:	6823      	ldr	r3, [r4, #0]
          data = SDMMC_ReadFIFO(hsd->Instance);
 800caea:	4618      	mov	r0, r3
 800caec:	f10a 0a04 	add.w	sl, sl, #4
 800caf0:	f002 ff16 	bl	800f920 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)(data & 0xFFU);
 800caf4:	f80a 0c08 	strb.w	r0, [sl, #-8]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800caf8:	0a02      	lsrs	r2, r0, #8
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800cafa:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800cafc:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 800cafe:	f80a 2c07 	strb.w	r2, [sl, #-7]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 800cb02:	f80a 3c06 	strb.w	r3, [sl, #-6]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 800cb06:	f80a 0c05 	strb.w	r0, [sl, #-5]
        for(count = 0U; count < 8U; count++)
 800cb0a:	45c2      	cmp	sl, r8
 800cb0c:	d1ec      	bne.n	800cae8 <HAL_SD_ReadBlocks+0xcc>
 800cb0e:	3520      	adds	r5, #32
        dataremaining -= 32U;
 800cb10:	f1a9 0920 	sub.w	r9, r9, #32
 800cb14:	e7d2      	b.n	800cabc <HAL_SD_ReadBlocks+0xa0>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800cb16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800cb18:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800cb1a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800cb1e:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800cb20:	b006      	add	sp, #24
 800cb22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800cb26:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cb28:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800cb2c:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800cb2e:	b006      	add	sp, #24
 800cb30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cb34:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cb38:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
 800cb3a:	2600      	movs	r6, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cb3c:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800cb40:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cb42:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 800cb44:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cb46:	431a      	orrs	r2, r3
 800cb48:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cb4a:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cb4e:	6326      	str	r6, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cb50:	e77a      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800cb52:	2301      	movs	r3, #1
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800cb54:	4641      	mov	r1, r8
 800cb56:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 800cb58:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 800cb5a:	f002 ffb9 	bl	800fad0 <SDMMC_CmdReadSingleBlock>
 800cb5e:	4602      	mov	r2, r0
 800cb60:	e7a6      	b.n	800cab0 <HAL_SD_ReadBlocks+0x94>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800cb62:	68da      	ldr	r2, [r3, #12]
 800cb64:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800cb68:	60da      	str	r2, [r3, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800cb6a:	6823      	ldr	r3, [r4, #0]
 800cb6c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cb6e:	05d2      	lsls	r2, r2, #23
 800cb70:	d50b      	bpl.n	800cb8a <HAL_SD_ReadBlocks+0x16e>
 800cb72:	2e01      	cmp	r6, #1
 800cb74:	d909      	bls.n	800cb8a <HAL_SD_ReadBlocks+0x16e>
      if(hsd->SdCard.CardType != CARD_SECURED)
 800cb76:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800cb78:	2a03      	cmp	r2, #3
 800cb7a:	d006      	beq.n	800cb8a <HAL_SD_ReadBlocks+0x16e>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800cb7c:	4618      	mov	r0, r3
 800cb7e:	f003 f8bf 	bl	800fd00 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800cb82:	4603      	mov	r3, r0
 800cb84:	2800      	cmp	r0, #0
 800cb86:	d154      	bne.n	800cc32 <HAL_SD_ReadBlocks+0x216>
 800cb88:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800cb8a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cb8c:	f012 0208 	ands.w	r2, r2, #8
 800cb90:	d127      	bne.n	800cbe2 <HAL_SD_ReadBlocks+0x1c6>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800cb92:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800cb94:	f011 0102 	ands.w	r1, r1, #2
 800cb98:	d133      	bne.n	800cc02 <HAL_SD_ReadBlocks+0x1e6>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800cb9a:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800cb9c:	f010 0020 	ands.w	r0, r0, #32
 800cba0:	d03e      	beq.n	800cc20 <HAL_SD_ReadBlocks+0x204>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cba2:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cba6:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cba8:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800cbac:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbae:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 800cbb0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cbb2:	f043 0320 	orr.w	r3, r3, #32
 800cbb6:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cbb8:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cbbc:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cbbe:	e743      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbc0:	f640 73ff 	movw	r3, #4095	; 0xfff
 800cbc4:	6825      	ldr	r5, [r4, #0]
        hsd->State= HAL_SD_STATE_READY;
 800cbc6:	2101      	movs	r1, #1
        hsd->Context = SD_CONTEXT_NONE;
 800cbc8:	2200      	movs	r2, #0
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbca:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
        return HAL_TIMEOUT;
 800cbce:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbd0:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 800cbd2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cbd4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 800cbd8:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 800cbda:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800cbde:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800cbe0:	e732      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbe2:	f640 71ff 	movw	r1, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cbe6:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 800cbe8:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbea:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
      return HAL_ERROR;
 800cbee:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cbf0:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800cbf2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cbf4:	f043 0308 	orr.w	r3, r3, #8
 800cbf8:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cbfa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cbfe:	6325      	str	r5, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cc00:	e722      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cc02:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cc06:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cc08:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800cc0c:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cc0e:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800cc10:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cc12:	f043 0302 	orr.w	r3, r3, #2
 800cc16:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cc18:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cc1c:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cc1e:	e713      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800cc20:	f640 723a 	movw	r2, #3898	; 0xf3a
    hsd->State = HAL_SD_STATE_READY;
 800cc24:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800cc26:	f6c1 0200 	movt	r2, #6144	; 0x1800
 800cc2a:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800cc2c:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
 800cc30:	e70a      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cc32:	f640 72ff 	movw	r2, #4095	; 0xfff
 800cc36:	6820      	ldr	r0, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
 800cc38:	2101      	movs	r1, #1
          hsd->Context = SD_CONTEXT_NONE;
 800cc3a:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cc3c:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
 800cc40:	6382      	str	r2, [r0, #56]	; 0x38
          return HAL_ERROR;
 800cc42:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
 800cc44:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800cc46:	4313      	orrs	r3, r2
 800cc48:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 800cc4a:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 800cc4e:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
 800cc50:	e6fa      	b.n	800ca48 <HAL_SD_ReadBlocks+0x2c>
 800cc52:	bf00      	nop

0800cc54 <HAL_SD_WriteBlocks>:
{
 800cc54:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800cc58:	460d      	mov	r5, r1
 800cc5a:	b089      	sub	sp, #36	; 0x24
 800cc5c:	4604      	mov	r4, r0
 800cc5e:	4616      	mov	r6, r2
 800cc60:	461f      	mov	r7, r3
  uint32_t tickstart = HAL_GetTick();
 800cc62:	f7f3 feeb 	bl	8000a3c <HAL_GetTick>
  if(NULL == pData)
 800cc66:	2d00      	cmp	r5, #0
 800cc68:	d05f      	beq.n	800cd2a <HAL_SD_WriteBlocks+0xd6>
 800cc6a:	4680      	mov	r8, r0
  if(hsd->State == HAL_SD_STATE_READY)
 800cc6c:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 800cc70:	b2c0      	uxtb	r0, r0
 800cc72:	2801      	cmp	r0, #1
 800cc74:	d007      	beq.n	800cc86 <HAL_SD_WriteBlocks+0x32>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800cc76:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800cc78:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 800cc7a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800cc7e:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800cc80:	b009      	add	sp, #36	; 0x24
 800cc82:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800cc86:	19f3      	adds	r3, r6, r7
 800cc88:	6d62      	ldr	r2, [r4, #84]	; 0x54
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800cc8a:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800cc8c:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800cc8e:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 800cc90:	d853      	bhi.n	800cd3a <HAL_SD_WriteBlocks+0xe6>
    hsd->Instance->DCTRL = 0U;
 800cc92:	6823      	ldr	r3, [r4, #0]
    hsd->State = HAL_SD_STATE_BUSY;
 800cc94:	2203      	movs	r2, #3
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 800cc96:	0278      	lsls	r0, r7, #9
    hsd->State = HAL_SD_STATE_BUSY;
 800cc98:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800cc9c:	2290      	movs	r2, #144	; 0x90
    hsd->Instance->DCTRL = 0U;
 800cc9e:	62d9      	str	r1, [r3, #44]	; 0x2c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800cca0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800cca4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800cca6:	9102      	str	r1, [sp, #8]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800cca8:	a902      	add	r1, sp, #8
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 800ccaa:	2b01      	cmp	r3, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800ccac:	f04f 0300 	mov.w	r3, #0
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 800ccb0:	e9cd 0203 	strd	r0, r2, [sp, #12]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800ccb4:	6820      	ldr	r0, [r4, #0]
      add *= 512U;
 800ccb6:	bf18      	it	ne
 800ccb8:	0276      	lslne	r6, r6, #9
    config.DPSM          = SDMMC_DPSM_DISABLE;
 800ccba:	9307      	str	r3, [sp, #28]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800ccbc:	e9cd 3305 	strd	r3, r3, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 800ccc0:	f002 fe56 	bl	800f970 <SDMMC_ConfigData>
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800ccc4:	6822      	ldr	r2, [r4, #0]
    if(NumberOfBlocks > 1U)
 800ccc6:	2f01      	cmp	r7, #1
    __SDMMC_CMDTRANS_ENABLE( hsd->Instance);
 800ccc8:	68d3      	ldr	r3, [r2, #12]
 800ccca:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800ccce:	60d3      	str	r3, [r2, #12]
    if(NumberOfBlocks > 1U)
 800ccd0:	d949      	bls.n	800cd66 <HAL_SD_WriteBlocks+0x112>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800ccd2:	2320      	movs	r3, #32
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800ccd4:	4631      	mov	r1, r6
 800ccd6:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 800ccd8:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 800ccda:	f002 ffcb 	bl	800fc74 <SDMMC_CmdWriteMultiBlock>
 800ccde:	4602      	mov	r2, r0
 800cce0:	6823      	ldr	r3, [r4, #0]
    if(errorstate != HAL_SD_ERROR_NONE)
 800cce2:	2a00      	cmp	r2, #0
 800cce4:	d130      	bne.n	800cd48 <HAL_SD_WriteBlocks+0xf4>
    dataremaining = config.DataLength;
 800cce6:	9e03      	ldr	r6, [sp, #12]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800cce8:	e007      	b.n	800ccfa <HAL_SD_WriteBlocks+0xa6>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 800ccea:	f7f3 fea7 	bl	8000a3c <HAL_GetTick>
 800ccee:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800ccf0:	eba0 0008 	sub.w	r0, r0, r8
 800ccf4:	4298      	cmp	r0, r3
 800ccf6:	d26d      	bcs.n	800cdd4 <HAL_SD_WriteBlocks+0x180>
 800ccf8:	6823      	ldr	r3, [r4, #0]
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800ccfa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800ccfc:	f412 7f8d 	tst.w	r2, #282	; 0x11a
 800cd00:	d139      	bne.n	800cd76 <HAL_SD_WriteBlocks+0x122>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE) && (dataremaining >= 32U))
 800cd02:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cd04:	0451      	lsls	r1, r2, #17
 800cd06:	d5f0      	bpl.n	800ccea <HAL_SD_WriteBlocks+0x96>
 800cd08:	2e1f      	cmp	r6, #31
 800cd0a:	d9ee      	bls.n	800ccea <HAL_SD_WriteBlocks+0x96>
 800cd0c:	f105 0920 	add.w	r9, r5, #32
 800cd10:	e000      	b.n	800cd14 <HAL_SD_WriteBlocks+0xc0>
 800cd12:	6823      	ldr	r3, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
 800cd14:	f855 2b04 	ldr.w	r2, [r5], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800cd18:	4618      	mov	r0, r3
 800cd1a:	a901      	add	r1, sp, #4
          data |= ((uint32_t)(*tempbuff) << 24U);
 800cd1c:	9201      	str	r2, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 800cd1e:	f002 fe03 	bl	800f928 <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
 800cd22:	454d      	cmp	r5, r9
 800cd24:	d1f5      	bne.n	800cd12 <HAL_SD_WriteBlocks+0xbe>
        dataremaining -= 32U;
 800cd26:	3e20      	subs	r6, #32
 800cd28:	e7df      	b.n	800ccea <HAL_SD_WriteBlocks+0x96>
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800cd2a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 800cd2c:	2001      	movs	r0, #1
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800cd2e:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800cd32:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800cd34:	b009      	add	sp, #36	; 0x24
 800cd36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 800cd3a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cd3c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800cd40:	63a3      	str	r3, [r4, #56]	; 0x38
}
 800cd42:	b009      	add	sp, #36	; 0x24
 800cd44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cd48:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cd4c:	2101      	movs	r1, #1
      hsd->Context = SD_CONTEXT_NONE;
 800cd4e:	2600      	movs	r6, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cd50:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800cd54:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cd56:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 800cd58:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cd5a:	431a      	orrs	r2, r3
 800cd5c:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cd5e:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cd62:	6326      	str	r6, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cd64:	e78c      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800cd66:	2310      	movs	r3, #16
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800cd68:	4631      	mov	r1, r6
 800cd6a:	6820      	ldr	r0, [r4, #0]
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 800cd6c:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800cd6e:	f002 ff3b 	bl	800fbe8 <SDMMC_CmdWriteSingleBlock>
 800cd72:	4602      	mov	r2, r0
 800cd74:	e7b4      	b.n	800cce0 <HAL_SD_WriteBlocks+0x8c>
    __SDMMC_CMDTRANS_DISABLE( hsd->Instance);
 800cd76:	68da      	ldr	r2, [r3, #12]
 800cd78:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800cd7c:	60da      	str	r2, [r3, #12]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 800cd7e:	6823      	ldr	r3, [r4, #0]
 800cd80:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cd82:	05d2      	lsls	r2, r2, #23
 800cd84:	d50b      	bpl.n	800cd9e <HAL_SD_WriteBlocks+0x14a>
 800cd86:	2f01      	cmp	r7, #1
 800cd88:	d909      	bls.n	800cd9e <HAL_SD_WriteBlocks+0x14a>
      if(hsd->SdCard.CardType != CARD_SECURED)
 800cd8a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800cd8c:	2a03      	cmp	r2, #3
 800cd8e:	d006      	beq.n	800cd9e <HAL_SD_WriteBlocks+0x14a>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 800cd90:	4618      	mov	r0, r3
 800cd92:	f002 ffb5 	bl	800fd00 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 800cd96:	4603      	mov	r3, r0
 800cd98:	2800      	cmp	r0, #0
 800cd9a:	d152      	bne.n	800ce42 <HAL_SD_WriteBlocks+0x1ee>
 800cd9c:	6823      	ldr	r3, [r4, #0]
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800cd9e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800cda0:	f012 0208 	ands.w	r2, r2, #8
 800cda4:	d125      	bne.n	800cdf2 <HAL_SD_WriteBlocks+0x19e>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800cda6:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800cda8:	f011 0102 	ands.w	r1, r1, #2
 800cdac:	d131      	bne.n	800ce12 <HAL_SD_WriteBlocks+0x1be>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 800cdae:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800cdb0:	f010 0010 	ands.w	r0, r0, #16
 800cdb4:	d03c      	beq.n	800ce30 <HAL_SD_WriteBlocks+0x1dc>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdb6:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cdba:	2201      	movs	r2, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdbc:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800cdc0:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdc2:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800cdc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cdc6:	f043 0310 	orr.w	r3, r3, #16
 800cdca:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800cdcc:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800cdd0:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800cdd2:	e755      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdd4:	f640 73ff 	movw	r3, #4095	; 0xfff
 800cdd8:	6825      	ldr	r5, [r4, #0]
        hsd->State = HAL_SD_STATE_READY;
 800cdda:	2101      	movs	r1, #1
        hsd->Context = SD_CONTEXT_NONE;
 800cddc:	2200      	movs	r2, #0
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdde:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
        return HAL_TIMEOUT;
 800cde2:	2003      	movs	r0, #3
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cde4:	63ab      	str	r3, [r5, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 800cde6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800cde8:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 800cdea:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 800cdee:	6322      	str	r2, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 800cdf0:	e746      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdf2:	f640 71ff 	movw	r1, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800cdf6:	2201      	movs	r2, #1
      hsd->Context = SD_CONTEXT_NONE;
 800cdf8:	2500      	movs	r5, #0
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cdfa:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
      return HAL_ERROR;
 800cdfe:	4610      	mov	r0, r2
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce00:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 800ce02:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ce04:	f043 0308 	orr.w	r3, r3, #8
 800ce08:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800ce0a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800ce0e:	6325      	str	r5, [r4, #48]	; 0x30
      return HAL_ERROR;
 800ce10:	e736      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce12:	f640 75ff 	movw	r5, #4095	; 0xfff
      hsd->State = HAL_SD_STATE_READY;
 800ce16:	2101      	movs	r1, #1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce18:	f6c1 75e0 	movt	r5, #8160	; 0x1fe0
      return HAL_ERROR;
 800ce1c:	4608      	mov	r0, r1
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce1e:	639d      	str	r5, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800ce20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800ce22:	f043 0302 	orr.w	r3, r3, #2
 800ce26:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800ce28:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 800ce2c:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 800ce2e:	e727      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800ce30:	f640 723a 	movw	r2, #3898	; 0xf3a
    hsd->State = HAL_SD_STATE_READY;
 800ce34:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800ce36:	f6c1 0200 	movt	r2, #6144	; 0x1800
 800ce3a:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800ce3c:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
    return HAL_OK;
 800ce40:	e71e      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce42:	f640 72ff 	movw	r2, #4095	; 0xfff
 800ce46:	6820      	ldr	r0, [r4, #0]
          hsd->State = HAL_SD_STATE_READY;
 800ce48:	2101      	movs	r1, #1
          hsd->Context = SD_CONTEXT_NONE;
 800ce4a:	2500      	movs	r5, #0
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800ce4c:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
 800ce50:	6382      	str	r2, [r0, #56]	; 0x38
          return HAL_ERROR;
 800ce52:	4608      	mov	r0, r1
          hsd->ErrorCode |= errorstate;
 800ce54:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800ce56:	4313      	orrs	r3, r2
 800ce58:	63a3      	str	r3, [r4, #56]	; 0x38
          hsd->State = HAL_SD_STATE_READY;
 800ce5a:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
          hsd->Context = SD_CONTEXT_NONE;
 800ce5e:	6325      	str	r5, [r4, #48]	; 0x30
          return HAL_ERROR;
 800ce60:	e70e      	b.n	800cc80 <HAL_SD_WriteBlocks+0x2c>
 800ce62:	bf00      	nop

0800ce64 <HAL_SD_DriveTransceiver_1_8V_Callback>:
}
 800ce64:	4770      	bx	lr
 800ce66:	bf00      	nop

0800ce68 <HAL_SD_GetCardCSD>:
{
 800ce68:	4603      	mov	r3, r0
  pCSD->Reserved2 = 0U; /*!< Reserved */
 800ce6a:	2000      	movs	r0, #0
{
 800ce6c:	b430      	push	{r4, r5}
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 800ce6e:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800ce70:	0f92      	lsrs	r2, r2, #30
 800ce72:	700a      	strb	r2, [r1, #0]
  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 800ce74:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800ce76:	f3c2 6283 	ubfx	r2, r2, #26, #4
 800ce7a:	704a      	strb	r2, [r1, #1]
  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 800ce7c:	f893 2063 	ldrb.w	r2, [r3, #99]	; 0x63
 800ce80:	f002 0203 	and.w	r2, r2, #3
 800ce84:	708a      	strb	r2, [r1, #2]
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 800ce86:	f893 2062 	ldrb.w	r2, [r3, #98]	; 0x62
 800ce8a:	70ca      	strb	r2, [r1, #3]
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800ce8c:	f893 2061 	ldrb.w	r2, [r3, #97]	; 0x61
 800ce90:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 800ce92:	f893 2060 	ldrb.w	r2, [r3, #96]	; 0x60
 800ce96:	714a      	strb	r2, [r1, #5]
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 800ce98:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ce9a:	0d12      	lsrs	r2, r2, #20
 800ce9c:	80ca      	strh	r2, [r1, #6]
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800ce9e:	f8b3 2066 	ldrh.w	r2, [r3, #102]	; 0x66
 800cea2:	f002 020f 	and.w	r2, r2, #15
 800cea6:	720a      	strb	r2, [r1, #8]
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 800cea8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ceaa:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800ceae:	724a      	strb	r2, [r1, #9]
  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 800ceb0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ceb2:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800ceb6:	728a      	strb	r2, [r1, #10]
  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800ceb8:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800ceba:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800cebe:	72ca      	strb	r2, [r1, #11]
  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 800cec0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800cec2:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800cec6:	730a      	strb	r2, [r1, #12]
  pCSD->Reserved2 = 0U; /*!< Reserved */
 800cec8:	7348      	strb	r0, [r1, #13]
  if(hsd->SdCard.CardType == CARD_SDSC)
 800ceca:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800cecc:	2a00      	cmp	r2, #0
 800cece:	f040 8086 	bne.w	800cfde <HAL_SD_GetCardCSD+0x176>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800ced2:	6e5d      	ldr	r5, [r3, #100]	; 0x64
 800ced4:	f640 72fc 	movw	r2, #4092	; 0xffc
 800ced8:	6e98      	ldr	r0, [r3, #104]	; 0x68
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800ceda:	2401      	movs	r4, #1
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800cedc:	ea02 0285 	and.w	r2, r2, r5, lsl #2
    hsd->SdCard.LogBlockSize = 512U;
 800cee0:	f44f 7500 	mov.w	r5, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 800cee4:	ea42 7290 	orr.w	r2, r2, r0, lsr #30
 800cee8:	610a      	str	r2, [r1, #16]
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 800ceea:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800ceec:	f3c2 62c2 	ubfx	r2, r2, #27, #3
 800cef0:	750a      	strb	r2, [r1, #20]
    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 800cef2:	f893 206b 	ldrb.w	r2, [r3, #107]	; 0x6b
 800cef6:	f002 0207 	and.w	r2, r2, #7
 800cefa:	754a      	strb	r2, [r1, #21]
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 800cefc:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800cefe:	f3c2 5242 	ubfx	r2, r2, #21, #3
 800cf02:	758a      	strb	r2, [r1, #22]
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 800cf04:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800cf06:	f3c2 4282 	ubfx	r2, r2, #18, #3
 800cf0a:	75ca      	strb	r2, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 800cf0c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800cf0e:	f3c2 32c2 	ubfx	r2, r2, #15, #3
 800cf12:	760a      	strb	r2, [r1, #24]
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 800cf14:	690a      	ldr	r2, [r1, #16]
 800cf16:	4422      	add	r2, r4
 800cf18:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 800cf1a:	7e08      	ldrb	r0, [r1, #24]
 800cf1c:	f000 0007 	and.w	r0, r0, #7
 800cf20:	3002      	adds	r0, #2
 800cf22:	4082      	lsls	r2, r0
 800cf24:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800cf26:	7a08      	ldrb	r0, [r1, #8]
    hsd->SdCard.LogBlockSize = 512U;
 800cf28:	659d      	str	r5, [r3, #88]	; 0x58
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800cf2a:	f000 000f 	and.w	r0, r0, #15
 800cf2e:	fa04 f000 	lsl.w	r0, r4, r0
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800cf32:	0a44      	lsrs	r4, r0, #9
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 800cf34:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U);
 800cf36:	fb02 f204 	mul.w	r2, r2, r4
 800cf3a:	655a      	str	r2, [r3, #84]	; 0x54
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800cf3c:	6e9a      	ldr	r2, [r3, #104]	; 0x68
  pCSD->Reserved3 = 0;
 800cf3e:	2500      	movs	r5, #0
  pCSD->Reserved4 = 1;
 800cf40:	2401      	movs	r4, #1
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800cf42:	f3c2 3280 	ubfx	r2, r2, #14, #1
  return HAL_OK;
 800cf46:	4628      	mov	r0, r5
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800cf48:	764a      	strb	r2, [r1, #25]
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800cf4a:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800cf4c:	f3c2 12c6 	ubfx	r2, r2, #7, #7
 800cf50:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800cf52:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800cf54:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 800cf58:	76ca      	strb	r2, [r1, #27]
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 800cf5a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf5c:	0fd2      	lsrs	r2, r2, #31
 800cf5e:	770a      	strb	r2, [r1, #28]
  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 800cf60:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf62:	f3c2 7241 	ubfx	r2, r2, #29, #2
 800cf66:	774a      	strb	r2, [r1, #29]
  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800cf68:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf6a:	f3c2 6282 	ubfx	r2, r2, #26, #3
 800cf6e:	778a      	strb	r2, [r1, #30]
  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 800cf70:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf72:	f3c2 5283 	ubfx	r2, r2, #22, #4
 800cf76:	77ca      	strb	r2, [r1, #31]
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 800cf78:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf7a:	f3c2 5240 	ubfx	r2, r2, #21, #1
 800cf7e:	f881 2020 	strb.w	r2, [r1, #32]
  pCSD->Reserved3 = 0;
 800cf82:	f881 5021 	strb.w	r5, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800cf86:	f8b3 206e 	ldrh.w	r2, [r3, #110]	; 0x6e
 800cf8a:	4022      	ands	r2, r4
 800cf8c:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800cf90:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf92:	f3c2 32c0 	ubfx	r2, r2, #15, #1
 800cf96:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 800cf9a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cf9c:	f3c2 3280 	ubfx	r2, r2, #14, #1
 800cfa0:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24
  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800cfa4:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cfa6:	f3c2 3240 	ubfx	r2, r2, #13, #1
 800cfaa:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25
  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 800cfae:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cfb0:	f3c2 3200 	ubfx	r2, r2, #12, #1
 800cfb4:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26
  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800cfb8:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cfba:	f3c2 2281 	ubfx	r2, r2, #10, #2
 800cfbe:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 800cfc2:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800cfc4:	f3c2 2201 	ubfx	r2, r2, #8, #2
 800cfc8:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800cfcc:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800cfce:	f3c3 0346 	ubfx	r3, r3, #1, #7
 800cfd2:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29
  pCSD->Reserved4 = 1;
 800cfd6:	f881 402a 	strb.w	r4, [r1, #42]	; 0x2a
}
 800cfda:	bc30      	pop	{r4, r5}
 800cfdc:	4770      	bx	lr
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 800cfde:	2a01      	cmp	r2, #1
 800cfe0:	d00f      	beq.n	800d002 <HAL_SD_GetCardCSD+0x19a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cfe2:	f640 72ff 	movw	r2, #4095	; 0xfff
 800cfe6:	681c      	ldr	r4, [r3, #0]
    hsd->State = HAL_SD_STATE_READY;
 800cfe8:	2101      	movs	r1, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cfea:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
    return HAL_ERROR;
 800cfee:	4608      	mov	r0, r1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800cff0:	63a2      	str	r2, [r4, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800cff2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800cff4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800cff8:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800cffa:	f883 1034 	strb.w	r1, [r3, #52]	; 0x34
}
 800cffe:	bc30      	pop	{r4, r5}
 800d000:	4770      	bx	lr
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800d002:	6e5a      	ldr	r2, [r3, #100]	; 0x64
    hsd->SdCard.BlockSize = 512U;
 800d004:	f44f 7000 	mov.w	r0, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 800d008:	f8b3 406a 	ldrh.w	r4, [r3, #106]	; 0x6a
 800d00c:	0412      	lsls	r2, r2, #16
 800d00e:	f402 127c 	and.w	r2, r2, #4128768	; 0x3f0000
 800d012:	4322      	orrs	r2, r4
 800d014:	610a      	str	r2, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800d016:	690a      	ldr	r2, [r1, #16]
    hsd->SdCard.BlockSize = 512U;
 800d018:	6518      	str	r0, [r3, #80]	; 0x50
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800d01a:	3201      	adds	r2, #1
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 800d01c:	6598      	str	r0, [r3, #88]	; 0x58
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 800d01e:	0292      	lsls	r2, r2, #10
 800d020:	64da      	str	r2, [r3, #76]	; 0x4c
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 800d022:	655a      	str	r2, [r3, #84]	; 0x54
 800d024:	e78a      	b.n	800cf3c <HAL_SD_GetCardCSD+0xd4>
 800d026:	bf00      	nop

0800d028 <HAL_SD_InitCard>:
{
 800d028:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d02c:	6982      	ldr	r2, [r0, #24]
{
 800d02e:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 800d030:	2300      	movs	r3, #0
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 800d032:	21fa      	movs	r1, #250	; 0xfa
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d034:	2a02      	cmp	r2, #2
{
 800d036:	4604      	mov	r4, r0
 800d038:	6805      	ldr	r5, [r0, #0]
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 800d03a:	910b      	str	r1, [sp, #44]	; 0x2c
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 800d03c:	e9cd 3307 	strd	r3, r3, [sp, #28]
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 800d040:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
  if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d044:	d104      	bne.n	800d050 <HAL_SD_InitCard+0x28>
    hsd->Instance->POWER |= SDMMC_POWER_DIRPOL;
 800d046:	682b      	ldr	r3, [r5, #0]
 800d048:	f043 0310 	orr.w	r3, r3, #16
 800d04c:	602b      	str	r3, [r5, #0]
 800d04e:	6805      	ldr	r5, [r0, #0]
  (void)SDMMC_Init(hsd->Instance, Init);
 800d050:	aa0a      	add	r2, sp, #40	; 0x28
 800d052:	ab07      	add	r3, sp, #28
 800d054:	ca07      	ldmia	r2, {r0, r1, r2}
 800d056:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800d05a:	4628      	mov	r0, r5
 800d05c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800d05e:	f002 fbed 	bl	800f83c <SDMMC_Init>
  (void)SDMMC_PowerState_ON(hsd->Instance);
 800d062:	6820      	ldr	r0, [r4, #0]
 800d064:	f002 fc66 	bl	800f934 <SDMMC_PowerState_ON>
  sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC)/(2U*SDMMC_INIT_CLK_DIV);
 800d068:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 800d06c:	f7fe fa8a 	bl	800b584 <HAL_RCCEx_GetPeriphCLKFreq>
 800d070:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800d074:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800d078:	fba3 3000 	umull	r3, r0, r3, r0
  if(sdmmc_clk != 0U)
 800d07c:	0940      	lsrs	r0, r0, #5
 800d07e:	d01c      	beq.n	800d0ba <HAL_SD_InitCard+0x92>
    HAL_Delay(1U+ (74U*1000U/(sdmmc_clk)));
 800d080:	f242 1310 	movw	r3, #8464	; 0x2110
 800d084:	f2c0 0301 	movt	r3, #1
 800d088:	fbb3 f0f0 	udiv	r0, r3, r0
 800d08c:	3001      	adds	r0, #1
 800d08e:	f7f3 fcdb 	bl	8000a48 <HAL_Delay>
  __IO uint32_t count = 0U;
 800d092:	2300      	movs	r3, #0
 800d094:	9306      	str	r3, [sp, #24]
  uint32_t tickstart = HAL_GetTick();
 800d096:	f7f3 fcd1 	bl	8000a3c <HAL_GetTick>
 800d09a:	4680      	mov	r8, r0
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800d09c:	6820      	ldr	r0, [r4, #0]
 800d09e:	f002 fedd 	bl	800fe5c <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d0a2:	4605      	mov	r5, r0
 800d0a4:	b168      	cbz	r0, 800d0c2 <HAL_SD_InitCard+0x9a>
    hsd->State = HAL_SD_STATE_READY;
 800d0a6:	2601      	movs	r6, #1
 800d0a8:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800d0ac:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d0ae:	431d      	orrs	r5, r3
 800d0b0:	63a5      	str	r5, [r4, #56]	; 0x38
}
 800d0b2:	4630      	mov	r0, r6
 800d0b4:	b018      	add	sp, #96	; 0x60
 800d0b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    HAL_Delay(2U);
 800d0ba:	2002      	movs	r0, #2
 800d0bc:	f7f3 fcc4 	bl	8000a48 <HAL_Delay>
 800d0c0:	e7e7      	b.n	800d092 <HAL_SD_InitCard+0x6a>
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 800d0c2:	6820      	ldr	r0, [r4, #0]
 800d0c4:	f002 fefa 	bl	800febc <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d0c8:	2800      	cmp	r0, #0
 800d0ca:	d17e      	bne.n	800d1ca <HAL_SD_InitCard+0x1a2>
    hsd->SdCard.CardVersion = CARD_V2_X;
 800d0cc:	2301      	movs	r3, #1
 800d0ce:	6423      	str	r3, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800d0d0:	2100      	movs	r1, #0
 800d0d2:	6820      	ldr	r0, [r4, #0]
 800d0d4:	f002 ff34 	bl	800ff40 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d0d8:	bb18      	cbnz	r0, 800d122 <HAL_SD_InitCard+0xfa>
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800d0da:	9b06      	ldr	r3, [sp, #24]
 800d0dc:	f64f 76fe 	movw	r6, #65534	; 0xfffe
 800d0e0:	42b3      	cmp	r3, r6
 800d0e2:	f200 810f 	bhi.w	800d304 <HAL_SD_InitCard+0x2dc>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800d0e6:	2700      	movs	r7, #0
 800d0e8:	f2cc 1710 	movt	r7, #49424	; 0xc110
 800d0ec:	e00c      	b.n	800d108 <HAL_SD_InitCard+0xe0>
    response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d0ee:	4601      	mov	r1, r0
 800d0f0:	6820      	ldr	r0, [r4, #0]
 800d0f2:	f002 fc2b 	bl	800f94c <SDMMC_GetResponse>
    count++;
 800d0f6:	9b06      	ldr	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800d0f8:	1e02      	subs	r2, r0, #0
    count++;
 800d0fa:	f103 0301 	add.w	r3, r3, #1
 800d0fe:	9306      	str	r3, [sp, #24]
  while((count < SDMMC_MAX_VOLT_TRIAL) && (validvoltage == 0U))
 800d100:	9b06      	ldr	r3, [sp, #24]
 800d102:	db11      	blt.n	800d128 <HAL_SD_InitCard+0x100>
 800d104:	42b3      	cmp	r3, r6
 800d106:	d80f      	bhi.n	800d128 <HAL_SD_InitCard+0x100>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 800d108:	2100      	movs	r1, #0
 800d10a:	6820      	ldr	r0, [r4, #0]
 800d10c:	f002 ff18 	bl	800ff40 <SDMMC_CmdAppCommand>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800d110:	4639      	mov	r1, r7
    if(errorstate != HAL_SD_ERROR_NONE)
 800d112:	4605      	mov	r5, r0
 800d114:	2800      	cmp	r0, #0
 800d116:	d1c6      	bne.n	800d0a6 <HAL_SD_InitCard+0x7e>
    errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_VOLTAGE_WINDOW_SD | SDMMC_HIGH_CAPACITY | SD_SWITCH_1_8V_CAPACITY);
 800d118:	6820      	ldr	r0, [r4, #0]
 800d11a:	f002 ff57 	bl	800ffcc <SDMMC_CmdAppOperCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d11e:	2800      	cmp	r0, #0
 800d120:	d0e5      	beq.n	800d0ee <HAL_SD_InitCard+0xc6>
      return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800d122:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 800d126:	e7be      	b.n	800d0a6 <HAL_SD_InitCard+0x7e>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800d128:	9906      	ldr	r1, [sp, #24]
 800d12a:	f64f 73fe 	movw	r3, #65534	; 0xfffe
 800d12e:	4299      	cmp	r1, r3
 800d130:	f200 80a1 	bhi.w	800d276 <HAL_SD_InitCard+0x24e>
  if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 800d134:	0057      	lsls	r7, r2, #1
 800d136:	6820      	ldr	r0, [r4, #0]
 800d138:	d504      	bpl.n	800d144 <HAL_SD_InitCard+0x11c>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d13a:	69a3      	ldr	r3, [r4, #24]
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800d13c:	2101      	movs	r1, #1
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d13e:	2b02      	cmp	r3, #2
    hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800d140:	63e1      	str	r1, [r4, #60]	; 0x3c
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_PRESENT)
 800d142:	d055      	beq.n	800d1f0 <HAL_SD_InitCard+0x1c8>
  uint16_t sd_rca = 1U;
 800d144:	2301      	movs	r3, #1
 800d146:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U)
 800d14a:	f002 fbfb 	bl	800f944 <SDMMC_GetPowerState>
 800d14e:	2800      	cmp	r0, #0
 800d150:	d048      	beq.n	800d1e4 <HAL_SD_InitCard+0x1bc>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d152:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800d154:	6823      	ldr	r3, [r4, #0]
 800d156:	2a03      	cmp	r2, #3
 800d158:	d128      	bne.n	800d1ac <HAL_SD_InitCard+0x184>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800d15a:	4618      	mov	r0, r3
 800d15c:	2104      	movs	r1, #4
 800d15e:	f002 fbf5 	bl	800f94c <SDMMC_GetResponse>
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800d162:	a90d      	add	r1, sp, #52	; 0x34
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800d164:	0d03      	lsrs	r3, r0, #20
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800d166:	4620      	mov	r0, r4
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20U);
 800d168:	6463      	str	r3, [r4, #68]	; 0x44
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 800d16a:	f7ff fe7d 	bl	800ce68 <HAL_SD_GetCardCSD>
 800d16e:	4606      	mov	r6, r0
 800d170:	2800      	cmp	r0, #0
 800d172:	d13a      	bne.n	800d1ea <HAL_SD_InitCard+0x1c2>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16U));
 800d174:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 800d176:	4603      	mov	r3, r0
 800d178:	6820      	ldr	r0, [r4, #0]
 800d17a:	0412      	lsls	r2, r2, #16
 800d17c:	f002 fe28 	bl	800fdd0 <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d180:	b9c8      	cbnz	r0, 800d1b6 <HAL_SD_InitCard+0x18e>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800d182:	f44f 7100 	mov.w	r1, #512	; 0x200
 800d186:	6820      	ldr	r0, [r4, #0]
 800d188:	f002 fc5c 	bl	800fa44 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d18c:	2800      	cmp	r0, #0
 800d18e:	d090      	beq.n	800d0b2 <HAL_SD_InitCard+0x8a>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d190:	f640 73ff 	movw	r3, #4095	; 0xfff
 800d194:	6821      	ldr	r1, [r4, #0]
    hsd->State = HAL_SD_STATE_READY;
 800d196:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d198:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
    return HAL_ERROR;
 800d19c:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d19e:	638b      	str	r3, [r1, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800d1a0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d1a2:	4318      	orrs	r0, r3
 800d1a4:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800d1a6:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_ERROR;
 800d1aa:	e782      	b.n	800d0b2 <HAL_SD_InitCard+0x8a>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 800d1ac:	4618      	mov	r0, r3
 800d1ae:	f002 ffd3 	bl	8010158 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d1b2:	2800      	cmp	r0, #0
 800d1b4:	d062      	beq.n	800d27c <HAL_SD_InitCard+0x254>
    hsd->State = HAL_SD_STATE_READY;
 800d1b6:	2601      	movs	r6, #1
 800d1b8:	f884 6034 	strb.w	r6, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800d1bc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800d1be:	4308      	orrs	r0, r1
 800d1c0:	63a0      	str	r0, [r4, #56]	; 0x38
}
 800d1c2:	4630      	mov	r0, r6
 800d1c4:	b018      	add	sp, #96	; 0x60
 800d1c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    hsd->SdCard.CardVersion = CARD_V1_X;
 800d1ca:	6425      	str	r5, [r4, #64]	; 0x40
    errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800d1cc:	6820      	ldr	r0, [r4, #0]
 800d1ce:	f002 fe45 	bl	800fe5c <SDMMC_CmdGoIdleState>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d1d2:	4605      	mov	r5, r0
 800d1d4:	2800      	cmp	r0, #0
 800d1d6:	f47f af66 	bne.w	800d0a6 <HAL_SD_InitCard+0x7e>
  if( hsd->SdCard.CardVersion == CARD_V2_X)
 800d1da:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800d1dc:	2b01      	cmp	r3, #1
 800d1de:	f47f af7c 	bne.w	800d0da <HAL_SD_InitCard+0xb2>
 800d1e2:	e775      	b.n	800d0d0 <HAL_SD_InitCard+0xa8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800d1e4:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800d1e8:	e7e5      	b.n	800d1b6 <HAL_SD_InitCard+0x18e>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800d1ea:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 800d1ee:	e7e2      	b.n	800d1b6 <HAL_SD_InitCard+0x18e>
      if((response & SD_SWITCH_1_8V_CAPACITY) == SD_SWITCH_1_8V_CAPACITY)
 800d1f0:	01d6      	lsls	r6, r2, #7
 800d1f2:	d5a7      	bpl.n	800d144 <HAL_SD_InitCard+0x11c>
        hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800d1f4:	f44f 7300 	mov.w	r3, #512	; 0x200
 800d1f8:	65e3      	str	r3, [r4, #92]	; 0x5c
        hsd->Instance->POWER |= SDMMC_POWER_VSWITCHEN;
 800d1fa:	6803      	ldr	r3, [r0, #0]
 800d1fc:	f043 0308 	orr.w	r3, r3, #8
 800d200:	6003      	str	r3, [r0, #0]
        errorstate = SDMMC_CmdVoltageSwitch(hsd->Instance);
 800d202:	6820      	ldr	r0, [r4, #0]
 800d204:	f003 f906 	bl	8010414 <SDMMC_CmdVoltageSwitch>
        if(errorstate != HAL_SD_ERROR_NONE)
 800d208:	4605      	mov	r5, r0
 800d20a:	b130      	cbz	r0, 800d21a <HAL_SD_InitCard+0x1f2>
 800d20c:	e74b      	b.n	800d0a6 <HAL_SD_InitCard+0x7e>
          if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800d20e:	f7f3 fc15 	bl	8000a3c <HAL_GetTick>
 800d212:	eba0 0008 	sub.w	r0, r0, r8
 800d216:	3001      	adds	r0, #1
 800d218:	d079      	beq.n	800d30e <HAL_SD_InitCard+0x2e6>
        while(( hsd->Instance->STA & SDMMC_FLAG_CKSTOP) != SDMMC_FLAG_CKSTOP)
 800d21a:	6823      	ldr	r3, [r4, #0]
 800d21c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d21e:	0155      	lsls	r5, r2, #5
 800d220:	d5f5      	bpl.n	800d20e <HAL_SD_InitCard+0x1e6>
        hsd->Instance->ICR = SDMMC_FLAG_CKSTOP;
 800d222:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
 800d226:	639a      	str	r2, [r3, #56]	; 0x38
        if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) != SDMMC_FLAG_BUSYD0)
 800d228:	6823      	ldr	r3, [r4, #0]
 800d22a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800d22c:	02d8      	lsls	r0, r3, #11
 800d22e:	f57f af78 	bpl.w	800d122 <HAL_SD_InitCard+0xfa>
          HAL_SD_DriveTransceiver_1_8V_Callback(SET);
 800d232:	2001      	movs	r0, #1
 800d234:	f7ff fe16 	bl	800ce64 <HAL_SD_DriveTransceiver_1_8V_Callback>
          hsd->Instance->POWER |= SDMMC_POWER_VSWITCH;
 800d238:	6822      	ldr	r2, [r4, #0]
 800d23a:	6813      	ldr	r3, [r2, #0]
 800d23c:	f043 0304 	orr.w	r3, r3, #4
 800d240:	6013      	str	r3, [r2, #0]
 800d242:	e005      	b.n	800d250 <HAL_SD_InitCard+0x228>
            if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800d244:	f7f3 fbfa 	bl	8000a3c <HAL_GetTick>
 800d248:	eba0 0008 	sub.w	r0, r0, r8
 800d24c:	3001      	adds	r0, #1
 800d24e:	d05e      	beq.n	800d30e <HAL_SD_InitCard+0x2e6>
          while(( hsd->Instance->STA & SDMMC_FLAG_VSWEND) != SDMMC_FLAG_VSWEND)
 800d250:	6823      	ldr	r3, [r4, #0]
 800d252:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d254:	0191      	lsls	r1, r2, #6
 800d256:	d5f5      	bpl.n	800d244 <HAL_SD_InitCard+0x21c>
          hsd->Instance->ICR = SDMMC_FLAG_VSWEND;
 800d258:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 800d25c:	639a      	str	r2, [r3, #56]	; 0x38
          if(( hsd->Instance->STA & SDMMC_FLAG_BUSYD0) == SDMMC_FLAG_BUSYD0)
 800d25e:	6823      	ldr	r3, [r4, #0]
 800d260:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d262:	02d2      	lsls	r2, r2, #11
 800d264:	d407      	bmi.n	800d276 <HAL_SD_InitCard+0x24e>
          hsd->Instance->POWER = 0x13U;
 800d266:	2113      	movs	r1, #19
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800d268:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          hsd->Instance->POWER = 0x13U;
 800d26c:	6019      	str	r1, [r3, #0]
          hsd->Instance->ICR = 0xFFFFFFFFU;
 800d26e:	6823      	ldr	r3, [r4, #0]
 800d270:	639a      	str	r2, [r3, #56]	; 0x38
 800d272:	6820      	ldr	r0, [r4, #0]
 800d274:	e766      	b.n	800d144 <HAL_SD_InitCard+0x11c>
    return HAL_SD_ERROR_INVALID_VOLTRANGE;
 800d276:	f04f 7580 	mov.w	r5, #16777216	; 0x1000000
 800d27a:	e714      	b.n	800d0a6 <HAL_SD_InitCard+0x7e>
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d27c:	4601      	mov	r1, r0
 800d27e:	6820      	ldr	r0, [r4, #0]
 800d280:	f002 fb64 	bl	800f94c <SDMMC_GetResponse>
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d284:	2104      	movs	r1, #4
      hsd->CID[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d286:	6720      	str	r0, [r4, #112]	; 0x70
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d288:	6820      	ldr	r0, [r4, #0]
 800d28a:	f002 fb5f 	bl	800f94c <SDMMC_GetResponse>
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d28e:	2108      	movs	r1, #8
      hsd->CID[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d290:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d292:	6820      	ldr	r0, [r4, #0]
 800d294:	f002 fb5a 	bl	800f94c <SDMMC_GetResponse>
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800d298:	210c      	movs	r1, #12
      hsd->CID[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d29a:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800d29c:	6820      	ldr	r0, [r4, #0]
 800d29e:	f002 fb55 	bl	800f94c <SDMMC_GetResponse>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d2a2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
      hsd->CID[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800d2a4:	67e0      	str	r0, [r4, #124]	; 0x7c
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d2a6:	2b03      	cmp	r3, #3
 800d2a8:	d034      	beq.n	800d314 <HAL_SD_InitCard+0x2ec>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800d2aa:	f10d 0116 	add.w	r1, sp, #22
 800d2ae:	6820      	ldr	r0, [r4, #0]
 800d2b0:	f002 ffcc 	bl	801024c <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d2b4:	2800      	cmp	r0, #0
 800d2b6:	f47f af7e 	bne.w	800d1b6 <HAL_SD_InitCard+0x18e>
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d2ba:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800d2bc:	6823      	ldr	r3, [r4, #0]
 800d2be:	2a03      	cmp	r2, #3
 800d2c0:	f43f af4b 	beq.w	800d15a <HAL_SD_InitCard+0x132>
    hsd->SdCard.RelCardAdd = sd_rca;
 800d2c4:	f8bd 1016 	ldrh.w	r1, [sp, #22]
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d2c8:	4618      	mov	r0, r3
    hsd->SdCard.RelCardAdd = sd_rca;
 800d2ca:	64a1      	str	r1, [r4, #72]	; 0x48
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d2cc:	0409      	lsls	r1, r1, #16
 800d2ce:	f002 ff81 	bl	80101d4 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d2d2:	2800      	cmp	r0, #0
 800d2d4:	f47f af6f 	bne.w	800d1b6 <HAL_SD_InitCard+0x18e>
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d2d8:	4601      	mov	r1, r0
 800d2da:	6820      	ldr	r0, [r4, #0]
 800d2dc:	f002 fb36 	bl	800f94c <SDMMC_GetResponse>
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d2e0:	2104      	movs	r1, #4
      hsd->CSD[0U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d2e2:	6620      	str	r0, [r4, #96]	; 0x60
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d2e4:	6820      	ldr	r0, [r4, #0]
 800d2e6:	f002 fb31 	bl	800f94c <SDMMC_GetResponse>
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d2ea:	2108      	movs	r1, #8
      hsd->CSD[1U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 800d2ec:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d2ee:	6820      	ldr	r0, [r4, #0]
 800d2f0:	f002 fb2c 	bl	800f94c <SDMMC_GetResponse>
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800d2f4:	210c      	movs	r1, #12
      hsd->CSD[2U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 800d2f6:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[3U] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 800d2f8:	6820      	ldr	r0, [r4, #0]
 800d2fa:	f002 fb27 	bl	800f94c <SDMMC_GetResponse>
 800d2fe:	6823      	ldr	r3, [r4, #0]
 800d300:	66e0      	str	r0, [r4, #108]	; 0x6c
 800d302:	e72a      	b.n	800d15a <HAL_SD_InitCard+0x132>
  if(count >= SDMMC_MAX_VOLT_TRIAL)
 800d304:	9b06      	ldr	r3, [sp, #24]
 800d306:	42b3      	cmp	r3, r6
 800d308:	d8b5      	bhi.n	800d276 <HAL_SD_InitCard+0x24e>
 800d30a:	6820      	ldr	r0, [r4, #0]
 800d30c:	e71a      	b.n	800d144 <HAL_SD_InitCard+0x11c>
            return HAL_SD_ERROR_TIMEOUT;
 800d30e:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 800d312:	e6c8      	b.n	800d0a6 <HAL_SD_InitCard+0x7e>
 800d314:	6823      	ldr	r3, [r4, #0]
 800d316:	e720      	b.n	800d15a <HAL_SD_InitCard+0x132>

0800d318 <HAL_SD_GetCardStatus>:
{
 800d318:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d31c:	4604      	mov	r4, r0
 800d31e:	b096      	sub	sp, #88	; 0x58
 800d320:	460d      	mov	r5, r1
  uint32_t tickstart = HAL_GetTick();
 800d322:	f7f3 fb8b 	bl	8000a3c <HAL_GetTick>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d326:	2100      	movs	r1, #0
  uint32_t tickstart = HAL_GetTick();
 800d328:	4680      	mov	r8, r0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d32a:	6820      	ldr	r0, [r4, #0]
 800d32c:	f002 fb0e 	bl	800f94c <SDMMC_GetResponse>
 800d330:	0187      	lsls	r7, r0, #6
 800d332:	d428      	bmi.n	800d386 <HAL_SD_GetCardStatus+0x6e>
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, 64U);
 800d334:	2140      	movs	r1, #64	; 0x40
 800d336:	6820      	ldr	r0, [r4, #0]
 800d338:	f002 fb84 	bl	800fa44 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d33c:	b338      	cbz	r0, 800d38e <HAL_SD_GetCardStatus+0x76>
    hsd->ErrorCode |= HAL_SD_ERROR_NONE;
 800d33e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d340:	63a3      	str	r3, [r4, #56]	; 0x38
 800d342:	6823      	ldr	r3, [r4, #0]
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d344:	f640 71ff 	movw	r1, #4095	; 0xfff
    hsd->State = HAL_SD_STATE_READY;
 800d348:	2201      	movs	r2, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d34a:	f6c1 71e0 	movt	r1, #8160	; 0x1fe0
    status = HAL_ERROR;
 800d34e:	4616      	mov	r6, r2
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d350:	6399      	str	r1, [r3, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800d352:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d354:	4318      	orrs	r0, r3
 800d356:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800d358:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800d35c:	f44f 7100 	mov.w	r1, #512	; 0x200
 800d360:	6820      	ldr	r0, [r4, #0]
 800d362:	f002 fb6f 	bl	800fa44 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d366:	b150      	cbz	r0, 800d37e <HAL_SD_GetCardStatus+0x66>
    hsd->State = HAL_SD_STATE_READY;
 800d368:	2301      	movs	r3, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d36a:	f640 72ff 	movw	r2, #4095	; 0xfff
 800d36e:	6821      	ldr	r1, [r4, #0]
 800d370:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
    status = HAL_ERROR;
 800d374:	461e      	mov	r6, r3
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d376:	638a      	str	r2, [r1, #56]	; 0x38
    hsd->ErrorCode = errorstate;
 800d378:	63a0      	str	r0, [r4, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 800d37a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800d37e:	4630      	mov	r0, r6
 800d380:	b016      	add	sp, #88	; 0x58
 800d382:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800d386:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800d388:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800d38c:	e7da      	b.n	800d344 <HAL_SD_GetCardStatus+0x2c>
  errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d38e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800d390:	6820      	ldr	r0, [r4, #0]
 800d392:	0409      	lsls	r1, r1, #16
 800d394:	f002 fdd4 	bl	800ff40 <SDMMC_CmdAppCommand>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d398:	2800      	cmp	r0, #0
 800d39a:	d1d0      	bne.n	800d33e <HAL_SD_GetCardStatus+0x26>
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800d39c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
  config.DataLength    = 64U;
 800d3a0:	2340      	movs	r3, #64	; 0x40
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
 800d3a2:	2160      	movs	r1, #96	; 0x60
  config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800d3a4:	9004      	str	r0, [sp, #16]
  config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800d3a6:	9200      	str	r2, [sp, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800d3a8:	2202      	movs	r2, #2
  config.DataLength    = 64U;
 800d3aa:	9301      	str	r3, [sp, #4]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800d3ac:	2301      	movs	r3, #1
  config.DataBlockSize = SDMMC_DATABLOCK_SIZE_64B;
 800d3ae:	9102      	str	r1, [sp, #8]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800d3b0:	4669      	mov	r1, sp
 800d3b2:	6820      	ldr	r0, [r4, #0]
  config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 800d3b4:	9203      	str	r2, [sp, #12]
  config.DPSM          = SDMMC_DPSM_ENABLE;
 800d3b6:	9305      	str	r3, [sp, #20]
  (void)SDMMC_ConfigData(hsd->Instance, &config);
 800d3b8:	f002 fada 	bl	800f970 <SDMMC_ConfigData>
  errorstate = SDMMC_CmdStatusRegister(hsd->Instance);
 800d3bc:	6820      	ldr	r0, [r4, #0]
 800d3be:	f002 ffe1 	bl	8010384 <SDMMC_CmdStatusRegister>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d3c2:	2800      	cmp	r0, #0
 800d3c4:	d1bb      	bne.n	800d33e <HAL_SD_GetCardStatus+0x26>
  uint32_t *pData = pSDstatus;
 800d3c6:	af06      	add	r7, sp, #24
 800d3c8:	e005      	b.n	800d3d6 <HAL_SD_GetCardStatus+0xbe>
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800d3ca:	f7f3 fb37 	bl	8000a3c <HAL_GetTick>
 800d3ce:	eba0 0008 	sub.w	r0, r0, r8
 800d3d2:	3001      	adds	r0, #1
 800d3d4:	d013      	beq.n	800d3fe <HAL_SD_GetCardStatus+0xe6>
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800d3d6:	6823      	ldr	r3, [r4, #0]
 800d3d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d3da:	f412 7f95 	tst.w	r2, #298	; 0x12a
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800d3de:	6b5a      	ldr	r2, [r3, #52]	; 0x34
  while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 800d3e0:	d110      	bne.n	800d404 <HAL_SD_GetCardStatus+0xec>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 800d3e2:	0416      	lsls	r6, r2, #16
 800d3e4:	d5f1      	bpl.n	800d3ca <HAL_SD_GetCardStatus+0xb2>
 800d3e6:	f107 0620 	add.w	r6, r7, #32
 800d3ea:	e000      	b.n	800d3ee <HAL_SD_GetCardStatus+0xd6>
 800d3ec:	6823      	ldr	r3, [r4, #0]
        *pData = SDMMC_ReadFIFO(hsd->Instance);
 800d3ee:	4618      	mov	r0, r3
 800d3f0:	f002 fa96 	bl	800f920 <SDMMC_ReadFIFO>
 800d3f4:	f847 0b04 	str.w	r0, [r7], #4
      for(count = 0U; count < 8U; count++)
 800d3f8:	42b7      	cmp	r7, r6
 800d3fa:	d1f7      	bne.n	800d3ec <HAL_SD_GetCardStatus+0xd4>
 800d3fc:	e7e5      	b.n	800d3ca <HAL_SD_GetCardStatus+0xb2>
      return HAL_SD_ERROR_TIMEOUT;
 800d3fe:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800d402:	e79e      	b.n	800d342 <HAL_SD_GetCardStatus+0x2a>
  if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 800d404:	0710      	lsls	r0, r2, #28
 800d406:	d455      	bmi.n	800d4b4 <HAL_SD_GetCardStatus+0x19c>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800d408:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d40a:	0791      	lsls	r1, r2, #30
 800d40c:	d454      	bmi.n	800d4b8 <HAL_SD_GetCardStatus+0x1a0>
  else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 800d40e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d410:	0692      	lsls	r2, r2, #26
 800d412:	d50b      	bpl.n	800d42c <HAL_SD_GetCardStatus+0x114>
 800d414:	e052      	b.n	800d4bc <HAL_SD_GetCardStatus+0x1a4>
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800d416:	f002 fa83 	bl	800f920 <SDMMC_ReadFIFO>
 800d41a:	f847 0b04 	str.w	r0, [r7], #4
    if((HAL_GetTick() - tickstart) >=  SDMMC_DATATIMEOUT)
 800d41e:	f7f3 fb0d 	bl	8000a3c <HAL_GetTick>
 800d422:	eba0 0008 	sub.w	r0, r0, r8
 800d426:	3001      	adds	r0, #1
 800d428:	d0e9      	beq.n	800d3fe <HAL_SD_GetCardStatus+0xe6>
 800d42a:	6823      	ldr	r3, [r4, #0]
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800d42c:	6b5e      	ldr	r6, [r3, #52]	; 0x34
    *pData = SDMMC_ReadFIFO(hsd->Instance);
 800d42e:	4618      	mov	r0, r3
  while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DPSMACT)))
 800d430:	f416 5680 	ands.w	r6, r6, #4096	; 0x1000
 800d434:	d1ef      	bne.n	800d416 <HAL_SD_GetCardStatus+0xfe>
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800d436:	9f06      	ldr	r7, [sp, #24]
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800d438:	f640 7e3a 	movw	lr, #3898	; 0xf3a
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800d43c:	9808      	ldr	r0, [sp, #32]
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800d43e:	0a39      	lsrs	r1, r7, #8
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800d440:	f6c1 0e00 	movt	lr, #6144	; 0x1800
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800d444:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800d446:	ea4f 4c10 	mov.w	ip, r0, lsr #16
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800d44a:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800d44e:	f8c3 e038 	str.w	lr, [r3, #56]	; 0x38
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800d452:	f3c7 1e81 	ubfx	lr, r7, #6, #2
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800d456:	f02c 0cff 	bic.w	ip, ip, #255	; 0xff
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800d45a:	ea41 6317 	orr.w	r3, r1, r7, lsr #24
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800d45e:	f3c7 1740 	ubfx	r7, r7, #5, #1
    pStatus->DataBusWidth = (uint8_t)((sd_status[0] & 0xC0U) >> 6U);
 800d462:	f885 e000 	strb.w	lr, [r5]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800d466:	fa5f fe82 	uxtb.w	lr, r2
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800d46a:	b29b      	uxth	r3, r3
 800d46c:	9907      	ldr	r1, [sp, #28]
    pStatus->SecuredMode = (uint8_t)((sd_status[0] & 0x20U) >> 5U);
 800d46e:	706f      	strb	r7, [r5, #1]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800d470:	ea4c 070e 	orr.w	r7, ip, lr
    pStatus->CardType = (uint16_t)(((sd_status[0] & 0x00FF0000U) >> 8U) | ((sd_status[0] & 0xFF000000U) >> 24U));
 800d474:	806b      	strh	r3, [r5, #2]
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800d476:	fa5f fc80 	uxtb.w	ip, r0
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800d47a:	f3c0 2307 	ubfx	r3, r0, #8, #8
 800d47e:	ba09      	rev	r1, r1
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800d480:	f3c2 2e85 	ubfx	lr, r2, #10, #6
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800d484:	f3c0 5003 	ubfx	r0, r0, #20, #4
    pStatus->ProtectedAreaSize = (((sd_status[1] & 0xFFU) << 24U)    | ((sd_status[1] & 0xFF00U) << 8U) |
 800d488:	6069      	str	r1, [r5, #4]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800d48a:	f3c2 1103 	ubfx	r1, r2, #4, #4
    pStatus->SpeedClass = (uint8_t)(sd_status[2] & 0xFFU);
 800d48e:	f885 c008 	strb.w	ip, [r5, #8]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800d492:	f3c2 2c01 	ubfx	ip, r2, #8, #2
    pStatus->PerformanceMove = (uint8_t)((sd_status[2] & 0xFF00U) >> 8U);
 800d496:	726b      	strb	r3, [r5, #9]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800d498:	f002 020f 	and.w	r2, r2, #15
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800d49c:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    pStatus->AllocationUnitSize = (uint8_t)((sd_status[2] & 0xF00000U) >> 20U);
 800d4a0:	72a8      	strb	r0, [r5, #10]
    pStatus->EraseSize = (uint16_t)(((sd_status[2] & 0xFF000000U) >> 16U) | (sd_status[3] & 0xFFU));
 800d4a2:	81af      	strh	r7, [r5, #12]
    pStatus->EraseTimeout = (uint8_t)((sd_status[3] & 0xFC00U) >> 10U);
 800d4a4:	f885 e00e 	strb.w	lr, [r5, #14]
    pStatus->EraseOffset = (uint8_t)((sd_status[3] & 0x0300U) >> 8U);
 800d4a8:	f885 c00f 	strb.w	ip, [r5, #15]
    pStatus->UhsSpeedGrade = (uint8_t)((sd_status[3] & 0x00F0U) >> 4U);
 800d4ac:	7429      	strb	r1, [r5, #16]
    pStatus->UhsAllocationUnitSize = (uint8_t)(sd_status[3] & 0x000FU) ;
 800d4ae:	746a      	strb	r2, [r5, #17]
    pStatus->VideoSpeedClass = (uint8_t)((sd_status[4] & 0xFF000000U) >> 24U);
 800d4b0:	74ab      	strb	r3, [r5, #18]
 800d4b2:	e753      	b.n	800d35c <HAL_SD_GetCardStatus+0x44>
    return HAL_SD_ERROR_DATA_TIMEOUT;
 800d4b4:	2008      	movs	r0, #8
 800d4b6:	e745      	b.n	800d344 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_DATA_CRC_FAIL;
 800d4b8:	2002      	movs	r0, #2
 800d4ba:	e743      	b.n	800d344 <HAL_SD_GetCardStatus+0x2c>
    return HAL_SD_ERROR_RX_OVERRUN;
 800d4bc:	2020      	movs	r0, #32
 800d4be:	e741      	b.n	800d344 <HAL_SD_GetCardStatus+0x2c>

0800d4c0 <HAL_SD_GetCardInfo>:
{
 800d4c0:	4603      	mov	r3, r0
}
 800d4c2:	2000      	movs	r0, #0
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 800d4c4:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800d4c6:	600a      	str	r2, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 800d4c8:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 800d4ca:	604a      	str	r2, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800d4cc:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800d4ce:	608a      	str	r2, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 800d4d0:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800d4d2:	60ca      	str	r2, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 800d4d4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800d4d6:	610a      	str	r2, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 800d4d8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 800d4da:	614a      	str	r2, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800d4dc:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 800d4de:	618a      	str	r2, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 800d4e0:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800d4e2:	61cb      	str	r3, [r1, #28]
}
 800d4e4:	4770      	bx	lr
 800d4e6:	bf00      	nop

0800d4e8 <HAL_SD_ConfigWideBusOperation>:
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800d4e8:	f431 4380 	bics.w	r3, r1, #16384	; 0x4000
{
 800d4ec:	b570      	push	{r4, r5, r6, lr}
 800d4ee:	460d      	mov	r5, r1
 800d4f0:	b08a      	sub	sp, #40	; 0x28
 800d4f2:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800d4f4:	d002      	beq.n	800d4fc <HAL_SD_ConfigWideBusOperation+0x14>
 800d4f6:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800d4fa:	d158      	bne.n	800d5ae <HAL_SD_ConfigWideBusOperation+0xc6>
  hsd->State = HAL_SD_STATE_BUSY;
 800d4fc:	2103      	movs	r1, #3
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d4fe:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800d500:	6823      	ldr	r3, [r4, #0]
 800d502:	428a      	cmp	r2, r1
  hsd->State = HAL_SD_STATE_BUSY;
 800d504:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  if(hsd->SdCard.CardType != CARD_SECURED)
 800d508:	d025      	beq.n	800d556 <HAL_SD_ConfigWideBusOperation+0x6e>
    if(WideMode == SDMMC_BUS_WIDE_8B)
 800d50a:	f5b5 4f00 	cmp.w	r5, #32768	; 0x8000
 800d50e:	d022      	beq.n	800d556 <HAL_SD_ConfigWideBusOperation+0x6e>
    else if(WideMode == SDMMC_BUS_WIDE_4B)
 800d510:	f5b5 4f80 	cmp.w	r5, #16384	; 0x4000
 800d514:	d074      	beq.n	800d600 <HAL_SD_ConfigWideBusOperation+0x118>
    else if(WideMode == SDMMC_BUS_WIDE_1B)
 800d516:	2d00      	cmp	r5, #0
 800d518:	d052      	beq.n	800d5c0 <HAL_SD_ConfigWideBusOperation+0xd8>
      hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 800d51a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d51c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000
 800d520:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800d522:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d524:	b9f2      	cbnz	r2, 800d564 <HAL_SD_ConfigWideBusOperation+0x7c>
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800d526:	6962      	ldr	r2, [r4, #20]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800d528:	6921      	ldr	r1, [r4, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800d52a:	2a03      	cmp	r2, #3
    Init.BusWide             = WideMode;
 800d52c:	9506      	str	r5, [sp, #24]
    Init.HardwareFlowControl = hsd->Init.HardwareFlowControl;
 800d52e:	9107      	str	r1, [sp, #28]
    Init.ClockPowerSave      = hsd->Init.ClockPowerSave;
 800d530:	e9d4 6001 	ldrd	r6, r0, [r4, #4]
 800d534:	e9cd 6004 	strd	r6, r0, [sp, #16]
    if(hsd->Init.ClockDiv >= SDMMC_NSpeed_CLK_DIV)
 800d538:	d930      	bls.n	800d59c <HAL_SD_ConfigWideBusOperation+0xb4>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 800d53a:	9208      	str	r2, [sp, #32]
    (void)SDMMC_Init(hsd->Instance, Init);
 800d53c:	aa0a      	add	r2, sp, #40	; 0x28
 800d53e:	ae04      	add	r6, sp, #16
  HAL_StatusTypeDef status = HAL_OK;
 800d540:	2500      	movs	r5, #0
    (void)SDMMC_Init(hsd->Instance, Init);
 800d542:	e912 0007 	ldmdb	r2, {r0, r1, r2}
 800d546:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800d54a:	4618      	mov	r0, r3
 800d54c:	e896 000e 	ldmia.w	r6, {r1, r2, r3}
 800d550:	f002 f974 	bl	800f83c <SDMMC_Init>
 800d554:	e00c      	b.n	800d570 <HAL_SD_ConfigWideBusOperation+0x88>
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800d556:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d558:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800d55c:	63a2      	str	r2, [r4, #56]	; 0x38
  if(hsd->ErrorCode != HAL_SD_ERROR_NONE)
 800d55e:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d560:	2a00      	cmp	r2, #0
 800d562:	d0e0      	beq.n	800d526 <HAL_SD_ConfigWideBusOperation+0x3e>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d564:	f640 72ff 	movw	r2, #4095	; 0xfff
    status = HAL_ERROR;
 800d568:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d56a:	f6c1 72e0 	movt	r2, #8160	; 0x1fe0
 800d56e:	639a      	str	r2, [r3, #56]	; 0x38
  errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800d570:	f44f 7100 	mov.w	r1, #512	; 0x200
 800d574:	6820      	ldr	r0, [r4, #0]
 800d576:	f002 fa65 	bl	800fa44 <SDMMC_CmdBlockLength>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d57a:	b148      	cbz	r0, 800d590 <HAL_SD_ConfigWideBusOperation+0xa8>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d57c:	f640 73ff 	movw	r3, #4095	; 0xfff
 800d580:	6822      	ldr	r2, [r4, #0]
    status = HAL_ERROR;
 800d582:	2501      	movs	r5, #1
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 800d584:	f6c1 73e0 	movt	r3, #8160	; 0x1fe0
 800d588:	6393      	str	r3, [r2, #56]	; 0x38
    hsd->ErrorCode |= errorstate;
 800d58a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d58c:	4318      	orrs	r0, r3
 800d58e:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->State = HAL_SD_STATE_READY;
 800d590:	2301      	movs	r3, #1
}
 800d592:	4628      	mov	r0, r5
  hsd->State = HAL_SD_STATE_READY;
 800d594:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 800d598:	b00a      	add	sp, #40	; 0x28
 800d59a:	bd70      	pop	{r4, r5, r6, pc}
    else if (hsd->SdCard.CardSpeed == CARD_ULTRA_HIGH_SPEED)
 800d59c:	6de1      	ldr	r1, [r4, #92]	; 0x5c
 800d59e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800d5a2:	d0ca      	beq.n	800d53a <HAL_SD_ConfigWideBusOperation+0x52>
    else if (hsd->SdCard.CardSpeed == CARD_HIGH_SPEED)
 800d5a4:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800d5a8:	d037      	beq.n	800d61a <HAL_SD_ConfigWideBusOperation+0x132>
      Init.ClockDiv = SDMMC_NSpeed_CLK_DIV;
 800d5aa:	2204      	movs	r2, #4
 800d5ac:	e7c5      	b.n	800d53a <HAL_SD_ConfigWideBusOperation+0x52>
  assert_param(IS_SDMMC_BUS_WIDE(WideMode));
 800d5ae:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d5b2:	f640 1149 	movw	r1, #2377	; 0x949
 800d5b6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d5ba:	f008 f955 	bl	8015868 <assert_failed>
 800d5be:	e79d      	b.n	800d4fc <HAL_SD_ConfigWideBusOperation+0x14>
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d5c0:	4629      	mov	r1, r5
 800d5c2:	4618      	mov	r0, r3
  uint32_t scr[2U] = {0UL, 0UL};
 800d5c4:	e9cd 5504 	strd	r5, r5, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d5c8:	f002 f9c0 	bl	800f94c <SDMMC_GetResponse>
 800d5cc:	0181      	lsls	r1, r0, #6
 800d5ce:	d420      	bmi.n	800d612 <HAL_SD_ConfigWideBusOperation+0x12a>
  errorstate = SD_FindSCR(hsd, scr);
 800d5d0:	a904      	add	r1, sp, #16
 800d5d2:	4620      	mov	r0, r4
 800d5d4:	f7ff f9b2 	bl	800c93c <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d5d8:	b968      	cbnz	r0, 800d5f6 <HAL_SD_ConfigWideBusOperation+0x10e>
  if((scr[1U] & SDMMC_SINGLE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800d5da:	9a05      	ldr	r2, [sp, #20]
 800d5dc:	6823      	ldr	r3, [r4, #0]
 800d5de:	03d2      	lsls	r2, r2, #15
 800d5e0:	d534      	bpl.n	800d64c <HAL_SD_ConfigWideBusOperation+0x164>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d5e2:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800d5e4:	4618      	mov	r0, r3
 800d5e6:	0409      	lsls	r1, r1, #16
 800d5e8:	f002 fcaa 	bl	800ff40 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d5ec:	b918      	cbnz	r0, 800d5f6 <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 0U);
 800d5ee:	4629      	mov	r1, r5
 800d5f0:	6820      	ldr	r0, [r4, #0]
 800d5f2:	f002 fd23 	bl	801003c <SDMMC_CmdBusWidth>
 800d5f6:	6823      	ldr	r3, [r4, #0]
      hsd->ErrorCode |= errorstate;
 800d5f8:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800d5fa:	4310      	orrs	r0, r2
 800d5fc:	63a0      	str	r0, [r4, #56]	; 0x38
 800d5fe:	e7ae      	b.n	800d55e <HAL_SD_ConfigWideBusOperation+0x76>
  uint32_t scr[2U] = {0UL, 0UL};
 800d600:	2200      	movs	r2, #0
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d602:	4618      	mov	r0, r3
 800d604:	4611      	mov	r1, r2
  uint32_t scr[2U] = {0UL, 0UL};
 800d606:	e9cd 2204 	strd	r2, r2, [sp, #16]
  if((SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1) & SDMMC_CARD_LOCKED) == SDMMC_CARD_LOCKED)
 800d60a:	f002 f99f 	bl	800f94c <SDMMC_GetResponse>
 800d60e:	0186      	lsls	r6, r0, #6
 800d610:	d506      	bpl.n	800d620 <HAL_SD_ConfigWideBusOperation+0x138>
 800d612:	6823      	ldr	r3, [r4, #0]
    return HAL_SD_ERROR_LOCK_UNLOCK_FAILED;
 800d614:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800d618:	e7ee      	b.n	800d5f8 <HAL_SD_ConfigWideBusOperation+0x110>
      Init.ClockDiv = SDMMC_HSpeed_CLK_DIV;
 800d61a:	2202      	movs	r2, #2
 800d61c:	9208      	str	r2, [sp, #32]
 800d61e:	e78d      	b.n	800d53c <HAL_SD_ConfigWideBusOperation+0x54>
  errorstate = SD_FindSCR(hsd, scr);
 800d620:	a904      	add	r1, sp, #16
 800d622:	4620      	mov	r0, r4
 800d624:	f7ff f98a 	bl	800c93c <SD_FindSCR>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d628:	2800      	cmp	r0, #0
 800d62a:	d1e4      	bne.n	800d5f6 <HAL_SD_ConfigWideBusOperation+0x10e>
  if((scr[1U] & SDMMC_WIDE_BUS_SUPPORT) != SDMMC_ALLZERO)
 800d62c:	9a05      	ldr	r2, [sp, #20]
 800d62e:	6823      	ldr	r3, [r4, #0]
 800d630:	0350      	lsls	r0, r2, #13
 800d632:	d50b      	bpl.n	800d64c <HAL_SD_ConfigWideBusOperation+0x164>
    errorstate = SDMMC_CmdAppCommand(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d634:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800d636:	4618      	mov	r0, r3
 800d638:	0409      	lsls	r1, r1, #16
 800d63a:	f002 fc81 	bl	800ff40 <SDMMC_CmdAppCommand>
    if(errorstate != HAL_SD_ERROR_NONE)
 800d63e:	2800      	cmp	r0, #0
 800d640:	d1d9      	bne.n	800d5f6 <HAL_SD_ConfigWideBusOperation+0x10e>
    errorstate = SDMMC_CmdBusWidth(hsd->Instance, 2U);
 800d642:	2102      	movs	r1, #2
 800d644:	6820      	ldr	r0, [r4, #0]
 800d646:	f002 fcf9 	bl	801003c <SDMMC_CmdBusWidth>
 800d64a:	e7d4      	b.n	800d5f6 <HAL_SD_ConfigWideBusOperation+0x10e>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 800d64c:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 800d650:	e7d2      	b.n	800d5f8 <HAL_SD_ConfigWideBusOperation+0x110>
 800d652:	bf00      	nop

0800d654 <HAL_SD_Init>:
{
 800d654:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d656:	b087      	sub	sp, #28
  if(hsd == NULL)
 800d658:	2800      	cmp	r0, #0
 800d65a:	d042      	beq.n	800d6e2 <HAL_SD_Init+0x8e>
  assert_param(IS_SDMMC_ALL_INSTANCE(hsd->Instance));
 800d65c:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
 800d660:	6802      	ldr	r2, [r0, #0]
 800d662:	4604      	mov	r4, r0
 800d664:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800d668:	429a      	cmp	r2, r3
 800d66a:	d00d      	beq.n	800d688 <HAL_SD_Init+0x34>
 800d66c:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800d670:	f6c4 0302 	movt	r3, #18434	; 0x4802
 800d674:	429a      	cmp	r2, r3
 800d676:	d007      	beq.n	800d688 <HAL_SD_Init+0x34>
 800d678:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d67c:	f240 115b 	movw	r1, #347	; 0x15b
 800d680:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d684:	f008 f8f0 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
 800d688:	6863      	ldr	r3, [r4, #4]
 800d68a:	f433 3380 	bics.w	r3, r3, #65536	; 0x10000
 800d68e:	f040 8081 	bne.w	800d794 <HAL_SD_Init+0x140>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800d692:	68a3      	ldr	r3, [r4, #8]
 800d694:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800d698:	d16f      	bne.n	800d77a <HAL_SD_Init+0x126>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800d69a:	68e3      	ldr	r3, [r4, #12]
 800d69c:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
 800d6a0:	d003      	beq.n	800d6aa <HAL_SD_Init+0x56>
 800d6a2:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800d6a6:	f040 8091 	bne.w	800d7cc <HAL_SD_Init+0x178>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800d6aa:	6923      	ldr	r3, [r4, #16]
 800d6ac:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800d6b0:	d17e      	bne.n	800d7b0 <HAL_SD_Init+0x15c>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800d6b2:	6963      	ldr	r3, [r4, #20]
 800d6b4:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800d6b8:	d250      	bcs.n	800d75c <HAL_SD_Init+0x108>
  if(hsd->State == HAL_SD_STATE_RESET)
 800d6ba:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800d6be:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800d6c2:	b93b      	cbnz	r3, 800d6d4 <HAL_SD_Init+0x80>
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
 800d6c4:	69a3      	ldr	r3, [r4, #24]
    hsd->Lock = HAL_UNLOCKED;
 800d6c6:	7722      	strb	r2, [r4, #28]
    if (hsd->Init.TranceiverPresent == SDMMC_TRANSCEIVER_UNKNOWN)
 800d6c8:	b90b      	cbnz	r3, 800d6ce <HAL_SD_Init+0x7a>
      hsd->Init.TranceiverPresent = SDMMC_TRANSCEIVER_PRESENT;
 800d6ca:	2302      	movs	r3, #2
 800d6cc:	61a3      	str	r3, [r4, #24]
    HAL_SD_MspInit(hsd);
 800d6ce:	4620      	mov	r0, r4
 800d6d0:	f009 f8ac 	bl	801682c <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
 800d6d4:	2303      	movs	r3, #3
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800d6d6:	4620      	mov	r0, r4
  hsd->State = HAL_SD_STATE_BUSY;
 800d6d8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 800d6dc:	f7ff fca4 	bl	800d028 <HAL_SD_InitCard>
 800d6e0:	b118      	cbz	r0, 800d6ea <HAL_SD_Init+0x96>
    return HAL_ERROR;
 800d6e2:	2501      	movs	r5, #1
}
 800d6e4:	4628      	mov	r0, r5
 800d6e6:	b007      	add	sp, #28
 800d6e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if( HAL_SD_GetCardStatus(hsd, &CardStatus) != HAL_OK)
 800d6ea:	a901      	add	r1, sp, #4
 800d6ec:	4620      	mov	r0, r4
 800d6ee:	f7ff fe13 	bl	800d318 <HAL_SD_GetCardStatus>
 800d6f2:	2800      	cmp	r0, #0
 800d6f4:	d1f5      	bne.n	800d6e2 <HAL_SD_Init+0x8e>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800d6f6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  speedgrade = CardStatus.UhsSpeedGrade;
 800d6f8:	f89d 2014 	ldrb.w	r2, [sp, #20]
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800d6fc:	2901      	cmp	r1, #1
  unitsize = CardStatus.UhsAllocationUnitSize;
 800d6fe:	f89d 3015 	ldrb.w	r3, [sp, #21]
  speedgrade = CardStatus.UhsSpeedGrade;
 800d702:	b2d2      	uxtb	r2, r2
  unitsize = CardStatus.UhsAllocationUnitSize;
 800d704:	b2db      	uxtb	r3, r3
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800d706:	d06f      	beq.n	800d7e8 <HAL_SD_Init+0x194>
      hsd->SdCard.CardSpeed  = CARD_NORMAL_SPEED;
 800d708:	65e0      	str	r0, [r4, #92]	; 0x5c
  if(HAL_SD_ConfigWideBusOperation(hsd, hsd->Init.BusWide) != HAL_OK)
 800d70a:	68e1      	ldr	r1, [r4, #12]
 800d70c:	4620      	mov	r0, r4
 800d70e:	f7ff feeb 	bl	800d4e8 <HAL_SD_ConfigWideBusOperation>
 800d712:	4605      	mov	r5, r0
 800d714:	2800      	cmp	r0, #0
 800d716:	d1e4      	bne.n	800d6e2 <HAL_SD_Init+0x8e>
  tickstart = HAL_GetTick();
 800d718:	f7f3 f990 	bl	8000a3c <HAL_GetTick>
 800d71c:	4607      	mov	r7, r0
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800d71e:	e007      	b.n	800d730 <HAL_SD_Init+0xdc>
    hsd->ErrorCode |= errorstate;
 800d720:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d722:	431e      	orrs	r6, r3
 800d724:	63a6      	str	r6, [r4, #56]	; 0x38
    if((HAL_GetTick()-tickstart) >=  SDMMC_DATATIMEOUT)
 800d726:	f7f3 f989 	bl	8000a3c <HAL_GetTick>
 800d72a:	1bc0      	subs	r0, r0, r7
 800d72c:	3001      	adds	r0, #1
 800d72e:	d063      	beq.n	800d7f8 <HAL_SD_Init+0x1a4>
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d730:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 800d732:	6820      	ldr	r0, [r4, #0]
 800d734:	0409      	lsls	r1, r1, #16
 800d736:	f002 fddf 	bl	80102f8 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d73a:	4606      	mov	r6, r0
 800d73c:	2800      	cmp	r0, #0
 800d73e:	d1ef      	bne.n	800d720 <HAL_SD_Init+0xcc>
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d740:	4601      	mov	r1, r0
 800d742:	6820      	ldr	r0, [r4, #0]
 800d744:	f002 f902 	bl	800f94c <SDMMC_GetResponse>
  cardstate = ((resp1 >> 9U) & 0x0FU);
 800d748:	f3c0 2043 	ubfx	r0, r0, #9, #4
  while((HAL_SD_GetCardState(hsd) != HAL_SD_CARD_TRANSFER))
 800d74c:	2804      	cmp	r0, #4
 800d74e:	d1ea      	bne.n	800d726 <HAL_SD_Init+0xd2>
  hsd->State = HAL_SD_STATE_READY;
 800d750:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 800d752:	63a6      	str	r6, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 800d754:	6326      	str	r6, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 800d756:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  return HAL_OK;
 800d75a:	e7c3      	b.n	800d6e4 <HAL_SD_Init+0x90>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800d75c:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d760:	f44f 71b0 	mov.w	r1, #352	; 0x160
 800d764:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d768:	f008 f87e 	bl	8015868 <assert_failed>
  if(hsd->State == HAL_SD_STATE_RESET)
 800d76c:	f894 3034 	ldrb.w	r3, [r4, #52]	; 0x34
 800d770:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800d774:	2b00      	cmp	r3, #0
 800d776:	d1ad      	bne.n	800d6d4 <HAL_SD_Init+0x80>
 800d778:	e7a4      	b.n	800d6c4 <HAL_SD_Init+0x70>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800d77a:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d77e:	f240 115d 	movw	r1, #349	; 0x15d
 800d782:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d786:	f008 f86f 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800d78a:	68e3      	ldr	r3, [r4, #12]
 800d78c:	f433 4280 	bics.w	r2, r3, #16384	; 0x4000
 800d790:	d187      	bne.n	800d6a2 <HAL_SD_Init+0x4e>
 800d792:	e78a      	b.n	800d6aa <HAL_SD_Init+0x56>
  assert_param(IS_SDMMC_CLOCK_EDGE(hsd->Init.ClockEdge));
 800d794:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d798:	f44f 71ae 	mov.w	r1, #348	; 0x15c
 800d79c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d7a0:	f008 f862 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(hsd->Init.ClockPowerSave));
 800d7a4:	68a3      	ldr	r3, [r4, #8]
 800d7a6:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800d7aa:	f43f af76 	beq.w	800d69a <HAL_SD_Init+0x46>
 800d7ae:	e7e4      	b.n	800d77a <HAL_SD_Init+0x126>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800d7b0:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d7b4:	f240 115f 	movw	r1, #351	; 0x15f
 800d7b8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d7bc:	f008 f854 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_CLKDIV(hsd->Init.ClockDiv));
 800d7c0:	6963      	ldr	r3, [r4, #20]
 800d7c2:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800d7c6:	f4ff af78 	bcc.w	800d6ba <HAL_SD_Init+0x66>
 800d7ca:	e7c7      	b.n	800d75c <HAL_SD_Init+0x108>
  assert_param(IS_SDMMC_BUS_WIDE(hsd->Init.BusWide));
 800d7cc:	f64d 40f8 	movw	r0, #56568	; 0xdcf8
 800d7d0:	f44f 71af 	mov.w	r1, #350	; 0x15e
 800d7d4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d7d8:	f008 f846 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(hsd->Init.HardwareFlowControl));
 800d7dc:	6923      	ldr	r3, [r4, #16]
 800d7de:	f433 3300 	bics.w	r3, r3, #131072	; 0x20000
 800d7e2:	f43f af66 	beq.w	800d6b2 <HAL_SD_Init+0x5e>
 800d7e6:	e7e3      	b.n	800d7b0 <HAL_SD_Init+0x15c>
  if ((hsd->SdCard.CardType == CARD_SDHC_SDXC) && ((speedgrade != 0U) || (unitsize != 0U)))
 800d7e8:	4313      	orrs	r3, r2
    hsd->SdCard.CardSpeed = CARD_ULTRA_HIGH_SPEED;
 800d7ea:	bf14      	ite	ne
 800d7ec:	f44f 7300 	movne.w	r3, #512	; 0x200
      hsd->SdCard.CardSpeed  = CARD_HIGH_SPEED;
 800d7f0:	f44f 7380 	moveq.w	r3, #256	; 0x100
 800d7f4:	65e3      	str	r3, [r4, #92]	; 0x5c
 800d7f6:	e788      	b.n	800d70a <HAL_SD_Init+0xb6>
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800d7f8:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
      hsd->State= HAL_SD_STATE_READY;
 800d7fc:	2301      	movs	r3, #1
      return HAL_TIMEOUT;
 800d7fe:	2503      	movs	r5, #3
      hsd->ErrorCode = HAL_SD_ERROR_TIMEOUT;
 800d800:	63a2      	str	r2, [r4, #56]	; 0x38
      hsd->State= HAL_SD_STATE_READY;
 800d802:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
      return HAL_TIMEOUT;
 800d806:	e76d      	b.n	800d6e4 <HAL_SD_Init+0x90>

0800d808 <HAL_SD_GetCardState>:
{
 800d808:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d80a:	6c81      	ldr	r1, [r0, #72]	; 0x48
{
 800d80c:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800d80e:	6800      	ldr	r0, [r0, #0]
 800d810:	0409      	lsls	r1, r1, #16
 800d812:	f002 fd71 	bl	80102f8 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 800d816:	4601      	mov	r1, r0
 800d818:	b120      	cbz	r0, 800d824 <HAL_SD_GetCardState+0x1c>
    hsd->ErrorCode |= errorstate;
 800d81a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800d81c:	2000      	movs	r0, #0
 800d81e:	4319      	orrs	r1, r3
 800d820:	63a1      	str	r1, [r4, #56]	; 0x38
}
 800d822:	bd10      	pop	{r4, pc}
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800d824:	6820      	ldr	r0, [r4, #0]
 800d826:	f002 f891 	bl	800f94c <SDMMC_GetResponse>
 800d82a:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 800d82e:	bd10      	pop	{r4, pc}

0800d830 <HAL_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{
  /* Check the SDRAM handle parameter */
  if (hsdram == NULL)
 800d830:	b328      	cbz	r0, 800d87e <HAL_SDRAM_Init+0x4e>
{
 800d832:	b538      	push	{r3, r4, r5, lr}
  {
    return HAL_ERROR;
  }

  if (hsdram->State == HAL_SDRAM_STATE_RESET)
 800d834:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800d838:	4604      	mov	r4, r0
 800d83a:	460d      	mov	r5, r1
 800d83c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800d840:	b1c3      	cbz	r3, 800d874 <HAL_SDRAM_Init+0x44>
    HAL_SDRAM_MspInit(hsdram);
#endif
  }

  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d842:	2302      	movs	r3, #2

  /* Initialize SDRAM control Interface */
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800d844:	1d21      	adds	r1, r4, #4
 800d846:	6820      	ldr	r0, [r4, #0]
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d848:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  (void)FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800d84c:	f001 fd64 	bl	800f318 <FMC_SDRAM_Init>

  /* Initialize SDRAM timing Interface */
  (void)FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank);
 800d850:	4629      	mov	r1, r5
 800d852:	e9d4 0200 	ldrd	r0, r2, [r4]
 800d856:	f001 fe49 	bl	800f4ec <FMC_SDRAM_Timing_Init>

  /* Enable FMC Peripheral */
  __FMC_ENABLE();
 800d85a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 800d85e:	2101      	movs	r1, #1

  return HAL_OK;
 800d860:	2000      	movs	r0, #0
  __FMC_ENABLE();
 800d862:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800d866:	681a      	ldr	r2, [r3, #0]
 800d868:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800d86c:	601a      	str	r2, [r3, #0]
  hsdram->State = HAL_SDRAM_STATE_READY;
 800d86e:	f884 102c 	strb.w	r1, [r4, #44]	; 0x2c
}
 800d872:	bd38      	pop	{r3, r4, r5, pc}
    hsdram->Lock = HAL_UNLOCKED;
 800d874:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    HAL_SDRAM_MspInit(hsdram);
 800d878:	f006 fb26 	bl	8013ec8 <HAL_SDRAM_MspInit>
 800d87c:	e7e1      	b.n	800d842 <HAL_SDRAM_Init+0x12>
    return HAL_ERROR;
 800d87e:	2001      	movs	r0, #1
}
 800d880:	4770      	bx	lr
 800d882:	bf00      	nop

0800d884 <HAL_SDRAM_SendCommand>:
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  HAL_SDRAM_StateTypeDef state = hsdram->State;
 800d884:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800d888:	b2db      	uxtb	r3, r3
  
  /* Check the SDRAM controller state */
  if (state == HAL_SDRAM_STATE_BUSY)
 800d88a:	2b02      	cmp	r3, #2
 800d88c:	d015      	beq.n	800d8ba <HAL_SDRAM_SendCommand+0x36>
{
 800d88e:	b570      	push	{r4, r5, r6, lr}
  {
    return HAL_BUSY;
  }
  else if((state == HAL_SDRAM_STATE_READY) || (state == HAL_SDRAM_STATE_PRECHARGED))
 800d890:	f003 04fb 	and.w	r4, r3, #251	; 0xfb
 800d894:	2c01      	cmp	r4, #1
 800d896:	d001      	beq.n	800d89c <HAL_SDRAM_SendCommand+0x18>
      hsdram->State = HAL_SDRAM_STATE_READY;
    }
  }
  else
  {
    return HAL_ERROR;
 800d898:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 800d89a:	bd70      	pop	{r4, r5, r6, pc}
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d89c:	2302      	movs	r3, #2
 800d89e:	4605      	mov	r5, r0
 800d8a0:	460e      	mov	r6, r1
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800d8a2:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d8a4:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
    (void)FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800d8a8:	f001 fee4 	bl	800f674 <FMC_SDRAM_SendCommand>
    if (Command->CommandMode == FMC_SDRAM_CMD_PALL)
 800d8ac:	6833      	ldr	r3, [r6, #0]
 800d8ae:	2b02      	cmp	r3, #2
 800d8b0:	d005      	beq.n	800d8be <HAL_SDRAM_SendCommand+0x3a>
      hsdram->State = HAL_SDRAM_STATE_READY;
 800d8b2:	f885 402c 	strb.w	r4, [r5, #44]	; 0x2c
  return HAL_OK;
 800d8b6:	2000      	movs	r0, #0
}
 800d8b8:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_BUSY;
 800d8ba:	4618      	mov	r0, r3
}
 800d8bc:	4770      	bx	lr
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800d8be:	2305      	movs	r3, #5
  return HAL_OK;
 800d8c0:	2000      	movs	r0, #0
      hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 800d8c2:	f885 302c 	strb.w	r3, [r5, #44]	; 0x2c
}
 800d8c6:	bd70      	pop	{r4, r5, r6, pc}

0800d8c8 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.
  * @param  RefreshRate The SDRAM refresh rate value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 800d8c8:	b538      	push	{r3, r4, r5, lr}
  /* Check the SDRAM controller state */
  if (hsdram->State == HAL_SDRAM_STATE_BUSY)
 800d8ca:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 800d8ce:	b2db      	uxtb	r3, r3
 800d8d0:	2b02      	cmp	r3, #2
 800d8d2:	d006      	beq.n	800d8e2 <HAL_SDRAM_ProgramRefreshRate+0x1a>
  {
    return HAL_BUSY;
  }
  else if (hsdram->State == HAL_SDRAM_STATE_READY)
 800d8d4:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
 800d8d8:	b2ed      	uxtb	r5, r5
 800d8da:	2d01      	cmp	r5, #1
 800d8dc:	d003      	beq.n	800d8e6 <HAL_SDRAM_ProgramRefreshRate+0x1e>
    /* Update the SDRAM state */
    hsdram->State = HAL_SDRAM_STATE_READY;
  }
  else
  {
    return HAL_ERROR;
 800d8de:	2001      	movs	r0, #1
  }

  return HAL_OK;
}
 800d8e0:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_BUSY;
 800d8e2:	4618      	mov	r0, r3
}
 800d8e4:	bd38      	pop	{r3, r4, r5, pc}
 800d8e6:	4604      	mov	r4, r0
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d8e8:	2302      	movs	r3, #2
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800d8ea:	6800      	ldr	r0, [r0, #0]
    hsdram->State = HAL_SDRAM_STATE_BUSY;
 800d8ec:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
    (void)FMC_SDRAM_ProgramRefreshRate(hsdram->Instance, RefreshRate);
 800d8f0:	f001 ff18 	bl	800f724 <FMC_SDRAM_ProgramRefreshRate>
    hsdram->State = HAL_SDRAM_STATE_READY;
 800d8f4:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
  return HAL_OK;
 800d8f8:	2000      	movs	r0, #0
}
 800d8fa:	bd38      	pop	{r3, r4, r5, pc}

0800d8fc <TIM_OC1_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800d8fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 1: Reset the CC1E Bit */
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800d900:	6a02      	ldr	r2, [r0, #32]
{
 800d902:	460f      	mov	r7, r1
  /* Get the TIMx CCMR1 register value */
  tmpccmrx = TIMx->CCMR1;

  /* Reset the Output Compare Mode Bits */
  tmpccmrx &= ~TIM_CCMR1_OC1M;
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800d904:	f64f 738c 	movw	r3, #65420	; 0xff8c
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC1P;
  /* Set the Output Compare Polarity */
  tmpccer |= OC_Config->OCPolarity;

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800d908:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800d90a:	f022 0201 	bic.w	r2, r2, #1
{
 800d90e:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800d910:	f6cf 73fe 	movt	r3, #65534	; 0xfffe
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800d914:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800d918:	6202      	str	r2, [r0, #32]
  tmpccer = TIMx->CCER;
 800d91a:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800d91c:	428c      	cmp	r4, r1
  tmpcr2 =  TIMx->CR2;
 800d91e:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 800d922:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC1P;
 800d924:	f025 0502 	bic.w	r5, r5, #2
  tmpccer |= OC_Config->OCPolarity;
 800d928:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC1S;
 800d92a:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= OC_Config->OCMode;
 800d92e:	683e      	ldr	r6, [r7, #0]
  tmpccer |= OC_Config->OCPolarity;
 800d930:	ea45 0502 	orr.w	r5, r5, r2
  tmpccmrx |= OC_Config->OCMode;
 800d934:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
 800d938:	d055      	beq.n	800d9e6 <TIM_OC1_SetConfig+0xea>
 800d93a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800d93e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800d942:	429c      	cmp	r4, r3
 800d944:	d04f      	beq.n	800d9e6 <TIM_OC1_SetConfig+0xea>
 800d946:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800d94a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800d94e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800d952:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800d956:	429c      	cmp	r4, r3
 800d958:	bf18      	it	ne
 800d95a:	4294      	cmpne	r4, r2
 800d95c:	d005      	beq.n	800d96a <TIM_OC1_SetConfig+0x6e>
 800d95e:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800d962:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800d966:	429c      	cmp	r4, r3
 800d968:	d155      	bne.n	800da16 <TIM_OC1_SetConfig+0x11a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800d96a:	68fb      	ldr	r3, [r7, #12]
 800d96c:	f025 0508 	bic.w	r5, r5, #8
 800d970:	f033 0208 	bics.w	r2, r3, #8
 800d974:	d03d      	beq.n	800d9f2 <TIM_OC1_SetConfig+0xf6>
 800d976:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800d97a:	f641 0106 	movw	r1, #6150	; 0x1806
 800d97e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d982:	f007 ff71 	bl	8015868 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC1NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d986:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800d98a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    tmpccer |= OC_Config->OCNPolarity;
 800d98e:	68f9      	ldr	r1, [r7, #12]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d990:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800d994:	f2c4 0301 	movt	r3, #16385	; 0x4001
    tmpccer |= OC_Config->OCNPolarity;
 800d998:	430d      	orrs	r5, r1
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d99a:	429c      	cmp	r4, r3
 800d99c:	bf18      	it	ne
 800d99e:	4294      	cmpne	r4, r2
    tmpccer &= ~TIM_CCER_CC1NE;
 800d9a0:	f025 0504 	bic.w	r5, r5, #4
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800d9a4:	d028      	beq.n	800d9f8 <TIM_OC1_SetConfig+0xfc>
 800d9a6:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800d9aa:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800d9ae:	429c      	cmp	r4, r3
 800d9b0:	d131      	bne.n	800da16 <TIM_OC1_SetConfig+0x11a>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800d9b2:	69bb      	ldr	r3, [r7, #24]
 800d9b4:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d9b8:	d022      	beq.n	800da00 <TIM_OC1_SetConfig+0x104>
 800d9ba:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800d9be:	f641 0113 	movw	r1, #6163	; 0x1813
 800d9c2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d9c6:	f007 ff4f 	bl	8015868 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800d9ca:	697b      	ldr	r3, [r7, #20]
 800d9cc:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800d9d0:	d01a      	beq.n	800da08 <TIM_OC1_SetConfig+0x10c>
 800d9d2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800d9d6:	f641 0114 	movw	r1, #6164	; 0x1814
 800d9da:	f6c0 0002 	movt	r0, #2050	; 0x802
 800d9de:	f007 ff43 	bl	8015868 <assert_failed>
 800d9e2:	697b      	ldr	r3, [r7, #20]
 800d9e4:	e010      	b.n	800da08 <TIM_OC1_SetConfig+0x10c>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800d9e6:	68fb      	ldr	r3, [r7, #12]
 800d9e8:	f025 0508 	bic.w	r5, r5, #8
 800d9ec:	f033 0208 	bics.w	r2, r3, #8
 800d9f0:	d119      	bne.n	800da26 <TIM_OC1_SetConfig+0x12a>
    tmpccer |= OC_Config->OCNPolarity;
 800d9f2:	431d      	orrs	r5, r3
    tmpccer &= ~TIM_CCER_CC1NE;
 800d9f4:	f025 0504 	bic.w	r5, r5, #4
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800d9f8:	69bb      	ldr	r3, [r7, #24]
 800d9fa:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800d9fe:	d1dc      	bne.n	800d9ba <TIM_OC1_SetConfig+0xbe>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800da00:	697b      	ldr	r3, [r7, #20]
 800da02:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800da06:	d1e4      	bne.n	800d9d2 <TIM_OC1_SetConfig+0xd6>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS1;
    tmpcr2 &= ~TIM_CR2_OIS1N;
 800da08:	f428 7840 	bic.w	r8, r8, #768	; 0x300
 800da0c:	69ba      	ldr	r2, [r7, #24]
 800da0e:	ea48 0802 	orr.w	r8, r8, r2
    /* Set the Output Idle state */
    tmpcr2 |= OC_Config->OCIdleState;
    /* Set the Output N Idle state */
    tmpcr2 |= OC_Config->OCNIdleState;
 800da12:	ea48 0803 	orr.w	r8, r8, r3
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800da16:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR1 */
  TIMx->CCMR1 = tmpccmrx;
 800da1a:	61a6      	str	r6, [r4, #24]

  /* Set the Capture Compare Register value */
  TIMx->CCR1 = OC_Config->Pulse;
 800da1c:	687b      	ldr	r3, [r7, #4]
 800da1e:	6363      	str	r3, [r4, #52]	; 0x34

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800da20:	6225      	str	r5, [r4, #32]
}
 800da22:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800da26:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800da2a:	f641 0106 	movw	r1, #6150	; 0x1806
 800da2e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800da32:	f007 ff19 	bl	8015868 <assert_failed>
    tmpccer |= OC_Config->OCNPolarity;
 800da36:	68fb      	ldr	r3, [r7, #12]
 800da38:	e7db      	b.n	800d9f2 <TIM_OC1_SetConfig+0xf6>
 800da3a:	bf00      	nop

0800da3c <TIM_OC3_SetConfig>:
  * @param  TIMx to select the TIM peripheral
  * @param  OC_Config The ouput configuration structure
  * @retval None
  */
static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
{
 800da3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t tmpccmrx;
  uint32_t tmpccer;
  uint32_t tmpcr2;

  /* Disable the Channel 3: Reset the CC2E Bit */
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800da40:	6a03      	ldr	r3, [r0, #32]
{
 800da42:	460f      	mov	r7, r1
  /* Reset the Output Polarity level */
  tmpccer &= ~TIM_CCER_CC3P;
  /* Set the Output Compare Polarity */
  tmpccer |= (OC_Config->OCPolarity << 8U);

  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800da44:	2100      	movs	r1, #0
{
 800da46:	4604      	mov	r4, r0
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800da48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800da4c:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC3E;
 800da50:	6203      	str	r3, [r0, #32]
  tmpccer = TIMx->CCER;
 800da52:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800da54:	4288      	cmp	r0, r1
  tmpcr2 =  TIMx->CR2;
 800da56:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR2;
 800da5a:	69c6      	ldr	r6, [r0, #28]
  tmpccer &= ~TIM_CCER_CC3P;
 800da5c:	f425 7500 	bic.w	r5, r5, #512	; 0x200
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800da60:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR2_CC3S;
 800da62:	f026 0673 	bic.w	r6, r6, #115	; 0x73
  tmpccmrx |= OC_Config->OCMode;
 800da66:	683b      	ldr	r3, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 8U);
 800da68:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
  tmpccmrx |= OC_Config->OCMode;
 800da6c:	ea46 0603 	orr.w	r6, r6, r3
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
 800da70:	d02e      	beq.n	800dad0 <TIM_OC3_SetConfig+0x94>
 800da72:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800da76:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800da7a:	4298      	cmp	r0, r3
 800da7c:	d028      	beq.n	800dad0 <TIM_OC3_SetConfig+0x94>
    tmpccer |= (OC_Config->OCNPolarity << 8U);
    /* Reset the Output N State */
    tmpccer &= ~TIM_CCER_CC3NE;
  }

  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800da7e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800da82:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800da86:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800da8a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800da8e:	4298      	cmp	r0, r3
 800da90:	bf18      	it	ne
 800da92:	4290      	cmpne	r0, r2
 800da94:	d005      	beq.n	800daa2 <TIM_OC3_SetConfig+0x66>
 800da96:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800da9a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800da9e:	4298      	cmp	r0, r3
 800daa0:	d10e      	bne.n	800dac0 <TIM_OC3_SetConfig+0x84>
  {
    /* Check parameters */
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800daa2:	69bb      	ldr	r3, [r7, #24]
 800daa4:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800daa8:	d120      	bne.n	800daec <TIM_OC3_SetConfig+0xb0>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800daaa:	697b      	ldr	r3, [r7, #20]
 800daac:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800dab0:	d128      	bne.n	800db04 <TIM_OC3_SetConfig+0xc8>

    /* Reset the Output Compare and Output Compare N IDLE State */
    tmpcr2 &= ~TIM_CR2_OIS3;
    tmpcr2 &= ~TIM_CR2_OIS3N;
 800dab2:	f428 5840 	bic.w	r8, r8, #12288	; 0x3000
    /* Set the Output Idle state */
    tmpcr2 |= (OC_Config->OCIdleState << 4U);
    /* Set the Output N Idle state */
    tmpcr2 |= (OC_Config->OCNIdleState << 4U);
 800dab6:	69ba      	ldr	r2, [r7, #24]
 800dab8:	ea48 1802 	orr.w	r8, r8, r2, lsl #4
 800dabc:	ea48 1803 	orr.w	r8, r8, r3, lsl #4
  }

  /* Write to TIMx CR2 */
  TIMx->CR2 = tmpcr2;
 800dac0:	f8c4 8004 	str.w	r8, [r4, #4]

  /* Write to TIMx CCMR2 */
  TIMx->CCMR2 = tmpccmrx;
 800dac4:	61e6      	str	r6, [r4, #28]

  /* Set the Capture Compare Register value */
  TIMx->CCR3 = OC_Config->Pulse;
 800dac6:	687b      	ldr	r3, [r7, #4]
 800dac8:	63e3      	str	r3, [r4, #60]	; 0x3c

  /* Write to TIMx CCER */
  TIMx->CCER = tmpccer;
 800daca:	6225      	str	r5, [r4, #32]
}
 800dacc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800dad0:	68fb      	ldr	r3, [r7, #12]
 800dad2:	f033 0208 	bics.w	r2, r3, #8
 800dad6:	d11f      	bne.n	800db18 <TIM_OC3_SetConfig+0xdc>
    tmpccer &= ~TIM_CCER_CC3NP;
 800dad8:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800dadc:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 800dae0:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800dae4:	69bb      	ldr	r3, [r7, #24]
 800dae6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800daea:	d0de      	beq.n	800daaa <TIM_OC3_SetConfig+0x6e>
 800daec:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800daf0:	f641 01a9 	movw	r1, #6313	; 0x18a9
 800daf4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800daf8:	f007 feb6 	bl	8015868 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800dafc:	697b      	ldr	r3, [r7, #20]
 800dafe:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800db02:	d0d6      	beq.n	800dab2 <TIM_OC3_SetConfig+0x76>
 800db04:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800db08:	f641 01aa 	movw	r1, #6314	; 0x18aa
 800db0c:	f6c0 0002 	movt	r0, #2050	; 0x802
 800db10:	f007 feaa 	bl	8015868 <assert_failed>
 800db14:	697b      	ldr	r3, [r7, #20]
 800db16:	e7cc      	b.n	800dab2 <TIM_OC3_SetConfig+0x76>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800db18:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800db1c:	f641 019c 	movw	r1, #6300	; 0x189c
    tmpccer &= ~TIM_CCER_CC3NP;
 800db20:	f425 6500 	bic.w	r5, r5, #2048	; 0x800
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800db24:	f6c0 0002 	movt	r0, #2050	; 0x802
 800db28:	f007 fe9e 	bl	8015868 <assert_failed>
 800db2c:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 8U);
 800db2e:	ea45 2503 	orr.w	r5, r5, r3, lsl #8
    tmpccer &= ~TIM_CCER_CC3NE;
 800db32:	f425 6580 	bic.w	r5, r5, #1024	; 0x400
 800db36:	e7d5      	b.n	800dae4 <TIM_OC3_SetConfig+0xa8>

0800db38 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 800db38:	2800      	cmp	r0, #0
 800db3a:	f000 811c 	beq.w	800dd76 <HAL_TIM_Base_Init+0x23e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800db3e:	2300      	movs	r3, #0
 800db40:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800db44:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800db48:	f2c4 0100 	movt	r1, #16384	; 0x4000
{
 800db4c:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800db4e:	6802      	ldr	r2, [r0, #0]
 800db50:	4604      	mov	r4, r0
 800db52:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800db56:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 800db5a:	429a      	cmp	r2, r3
 800db5c:	bf18      	it	ne
 800db5e:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800db62:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800db66:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800db6a:	bf14      	ite	ne
 800db6c:	2301      	movne	r3, #1
 800db6e:	2300      	moveq	r3, #0
 800db70:	4282      	cmp	r2, r0
 800db72:	bf0c      	ite	eq
 800db74:	2300      	moveq	r3, #0
 800db76:	f003 0301 	andne.w	r3, r3, #1
 800db7a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800db7e:	428a      	cmp	r2, r1
 800db80:	bf0c      	ite	eq
 800db82:	2300      	moveq	r3, #0
 800db84:	f003 0301 	andne.w	r3, r3, #1
 800db88:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800db8c:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 800db90:	42aa      	cmp	r2, r5
 800db92:	bf0c      	ite	eq
 800db94:	2300      	moveq	r3, #0
 800db96:	f003 0301 	andne.w	r3, r3, #1
 800db9a:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800db9e:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800dba2:	4282      	cmp	r2, r0
 800dba4:	bf0c      	ite	eq
 800dba6:	2300      	moveq	r3, #0
 800dba8:	f003 0301 	andne.w	r3, r3, #1
 800dbac:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800dbb0:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 800dbb4:	428a      	cmp	r2, r1
 800dbb6:	bf0c      	ite	eq
 800dbb8:	2300      	moveq	r3, #0
 800dbba:	f003 0301 	andne.w	r3, r3, #1
 800dbbe:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 800dbc2:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800dbc6:	42aa      	cmp	r2, r5
 800dbc8:	bf0c      	ite	eq
 800dbca:	2300      	moveq	r3, #0
 800dbcc:	f003 0301 	andne.w	r3, r3, #1
 800dbd0:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800dbd4:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 800dbd8:	4282      	cmp	r2, r0
 800dbda:	bf0c      	ite	eq
 800dbdc:	2300      	moveq	r3, #0
 800dbde:	f003 0301 	andne.w	r3, r3, #1
 800dbe2:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800dbe6:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800dbea:	428a      	cmp	r2, r1
 800dbec:	bf0c      	ite	eq
 800dbee:	2300      	moveq	r3, #0
 800dbf0:	f003 0301 	andne.w	r3, r3, #1
 800dbf4:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800dbf8:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800dbfc:	42aa      	cmp	r2, r5
 800dbfe:	bf0c      	ite	eq
 800dc00:	2300      	moveq	r3, #0
 800dc02:	f003 0301 	andne.w	r3, r3, #1
 800dc06:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800dc0a:	4282      	cmp	r2, r0
 800dc0c:	bf0c      	ite	eq
 800dc0e:	2300      	moveq	r3, #0
 800dc10:	f003 0301 	andne.w	r3, r3, #1
 800dc14:	428a      	cmp	r2, r1
 800dc16:	bf0c      	ite	eq
 800dc18:	2300      	moveq	r3, #0
 800dc1a:	f003 0301 	andne.w	r3, r3, #1
 800dc1e:	b133      	cbz	r3, 800dc2e <HAL_TIM_Base_Init+0xf6>
 800dc20:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800dc24:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dc28:	429a      	cmp	r2, r3
 800dc2a:	f040 80ca 	bne.w	800ddc2 <HAL_TIM_Base_Init+0x28a>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800dc2e:	68a3      	ldr	r3, [r4, #8]
 800dc30:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 800dc34:	f023 0210 	bic.w	r2, r3, #16
 800dc38:	2920      	cmp	r1, #32
 800dc3a:	bf18      	it	ne
 800dc3c:	2a00      	cmpne	r2, #0
 800dc3e:	d002      	beq.n	800dc46 <HAL_TIM_Base_Init+0x10e>
 800dc40:	2b40      	cmp	r3, #64	; 0x40
 800dc42:	f040 80a8 	bne.w	800dd96 <HAL_TIM_Base_Init+0x25e>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800dc46:	6923      	ldr	r3, [r4, #16]
 800dc48:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800dc4c:	d003      	beq.n	800dc56 <HAL_TIM_Base_Init+0x11e>
 800dc4e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800dc52:	f040 8092 	bne.w	800dd7a <HAL_TIM_Base_Init+0x242>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800dc56:	69a3      	ldr	r3, [r4, #24]
 800dc58:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800dc5c:	d17b      	bne.n	800dd56 <HAL_TIM_Base_Init+0x21e>
  if (htim->State == HAL_TIM_STATE_RESET)
 800dc5e:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800dc62:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800dc66:	2b00      	cmp	r3, #0
 800dc68:	d06f      	beq.n	800dd4a <HAL_TIM_Base_Init+0x212>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800dc6a:	2100      	movs	r1, #0
 800dc6c:	f44f 6380 	mov.w	r3, #1024	; 0x400
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800dc70:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800dc72:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800dc74:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800dc78:	f2c4 0301 	movt	r3, #16385	; 0x4001
  htim->State = HAL_TIM_STATE_BUSY;
 800dc7c:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800dc80:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800dc84:	eba2 0001 	sub.w	r0, r2, r1
 800dc88:	eba2 0103 	sub.w	r1, r2, r3
  tmpcr1 = TIMx->CR1;
 800dc8c:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800dc8e:	fab0 f080 	clz	r0, r0
 800dc92:	fab1 f181 	clz	r1, r1
 800dc96:	ea4f 1050 	mov.w	r0, r0, lsr #5
 800dc9a:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800dc9e:	d027      	beq.n	800dcf0 <HAL_TIM_Base_Init+0x1b8>
 800dca0:	bb30      	cbnz	r0, 800dcf0 <HAL_TIM_Base_Init+0x1b8>
 800dca2:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800dca6:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800dcaa:	42aa      	cmp	r2, r5
 800dcac:	d020      	beq.n	800dcf0 <HAL_TIM_Base_Init+0x1b8>
 800dcae:	f44f 6500 	mov.w	r5, #2048	; 0x800
 800dcb2:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800dcb6:	42aa      	cmp	r2, r5
 800dcb8:	d01a      	beq.n	800dcf0 <HAL_TIM_Base_Init+0x1b8>
 800dcba:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 800dcbe:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800dcc2:	42aa      	cmp	r2, r5
 800dcc4:	d070      	beq.n	800dda8 <HAL_TIM_Base_Init+0x270>
 800dcc6:	2900      	cmp	r1, #0
 800dcc8:	d16e      	bne.n	800dda8 <HAL_TIM_Base_Init+0x270>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800dcca:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800dcce:	f44f 4588 	mov.w	r5, #17408	; 0x4400
 800dcd2:	f2c4 0601 	movt	r6, #16385	; 0x4001
 800dcd6:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800dcda:	42aa      	cmp	r2, r5
 800dcdc:	bf18      	it	ne
 800dcde:	42b2      	cmpne	r2, r6
 800dce0:	d00a      	beq.n	800dcf8 <HAL_TIM_Base_Init+0x1c0>
 800dce2:	f44f 4590 	mov.w	r5, #18432	; 0x4800
 800dce6:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800dcea:	42aa      	cmp	r2, r5
 800dcec:	d108      	bne.n	800dd00 <HAL_TIM_Base_Init+0x1c8>
 800dcee:	e003      	b.n	800dcf8 <HAL_TIM_Base_Init+0x1c0>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800dcf0:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800dcf4:	68a5      	ldr	r5, [r4, #8]
 800dcf6:	432b      	orrs	r3, r5
    tmpcr1 &= ~TIM_CR1_CKD;
 800dcf8:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800dcfc:	6925      	ldr	r5, [r4, #16]
 800dcfe:	432b      	orrs	r3, r5
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800dd00:	69a5      	ldr	r5, [r4, #24]
 800dd02:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800dd06:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 800dd08:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800dd0a:	68e3      	ldr	r3, [r4, #12]
 800dd0c:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800dd0e:	6863      	ldr	r3, [r4, #4]
 800dd10:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800dd12:	b990      	cbnz	r0, 800dd3a <HAL_TIM_Base_Init+0x202>
 800dd14:	b989      	cbnz	r1, 800dd3a <HAL_TIM_Base_Init+0x202>
 800dd16:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800dd1a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800dd1e:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800dd22:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dd26:	429a      	cmp	r2, r3
 800dd28:	bf18      	it	ne
 800dd2a:	428a      	cmpne	r2, r1
 800dd2c:	d005      	beq.n	800dd3a <HAL_TIM_Base_Init+0x202>
 800dd2e:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800dd32:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dd36:	429a      	cmp	r2, r3
 800dd38:	d101      	bne.n	800dd3e <HAL_TIM_Base_Init+0x206>
    TIMx->RCR = Structure->RepetitionCounter;
 800dd3a:	6963      	ldr	r3, [r4, #20]
 800dd3c:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 800dd3e:	2301      	movs	r3, #1
  return HAL_OK;
 800dd40:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800dd42:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800dd44:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800dd48:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 800dd4a:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 800dd4e:	4620      	mov	r0, r4
 800dd50:	f011 fd24 	bl	801f79c <HAL_TIM_Base_MspInit>
 800dd54:	e789      	b.n	800dc6a <HAL_TIM_Base_Init+0x132>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800dd56:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800dd5a:	f44f 718c 	mov.w	r1, #280	; 0x118
 800dd5e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800dd62:	f007 fd81 	bl	8015868 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 800dd66:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800dd6a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800dd6e:	2b00      	cmp	r3, #0
 800dd70:	f47f af7b 	bne.w	800dc6a <HAL_TIM_Base_Init+0x132>
 800dd74:	e7e9      	b.n	800dd4a <HAL_TIM_Base_Init+0x212>
    return HAL_ERROR;
 800dd76:	2001      	movs	r0, #1
}
 800dd78:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800dd7a:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800dd7e:	f240 1117 	movw	r1, #279	; 0x117
 800dd82:	f6c0 0002 	movt	r0, #2050	; 0x802
 800dd86:	f007 fd6f 	bl	8015868 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800dd8a:	69a3      	ldr	r3, [r4, #24]
 800dd8c:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800dd90:	f43f af65 	beq.w	800dc5e <HAL_TIM_Base_Init+0x126>
 800dd94:	e7df      	b.n	800dd56 <HAL_TIM_Base_Init+0x21e>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800dd96:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800dd9a:	f44f 718b 	mov.w	r1, #278	; 0x116
 800dd9e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800dda2:	f007 fd61 	bl	8015868 <assert_failed>
 800dda6:	e74e      	b.n	800dc46 <HAL_TIM_Base_Init+0x10e>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800dda8:	f44f 6540 	mov.w	r5, #3072	; 0xc00
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800ddac:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800ddb0:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800ddb2:	f2c4 0500 	movt	r5, #16384	; 0x4000
    tmpcr1 |= Structure->CounterMode;
 800ddb6:	4333      	orrs	r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800ddb8:	42aa      	cmp	r2, r5
 800ddba:	d09d      	beq.n	800dcf8 <HAL_TIM_Base_Init+0x1c0>
 800ddbc:	2900      	cmp	r1, #0
 800ddbe:	d19b      	bne.n	800dcf8 <HAL_TIM_Base_Init+0x1c0>
 800ddc0:	e783      	b.n	800dcca <HAL_TIM_Base_Init+0x192>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800ddc2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ddc6:	f240 1115 	movw	r1, #277	; 0x115
 800ddca:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ddce:	f007 fd4b 	bl	8015868 <assert_failed>
 800ddd2:	e72c      	b.n	800dc2e <HAL_TIM_Base_Init+0xf6>

0800ddd4 <HAL_TIM_PWM_Init>:
  if (htim == NULL)
 800ddd4:	2800      	cmp	r0, #0
 800ddd6:	f000 811c 	beq.w	800e012 <HAL_TIM_PWM_Init+0x23e>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800ddda:	2300      	movs	r3, #0
 800dddc:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800dde0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dde4:	f2c4 0100 	movt	r1, #16384	; 0x4000
{
 800dde8:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800ddea:	6802      	ldr	r2, [r0, #0]
 800ddec:	4604      	mov	r4, r0
 800ddee:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ddf2:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 800ddf6:	429a      	cmp	r2, r3
 800ddf8:	bf18      	it	ne
 800ddfa:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800ddfe:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800de02:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800de06:	bf14      	ite	ne
 800de08:	2301      	movne	r3, #1
 800de0a:	2300      	moveq	r3, #0
 800de0c:	4282      	cmp	r2, r0
 800de0e:	bf0c      	ite	eq
 800de10:	2300      	moveq	r3, #0
 800de12:	f003 0301 	andne.w	r3, r3, #1
 800de16:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800de1a:	428a      	cmp	r2, r1
 800de1c:	bf0c      	ite	eq
 800de1e:	2300      	moveq	r3, #0
 800de20:	f003 0301 	andne.w	r3, r3, #1
 800de24:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800de28:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 800de2c:	42aa      	cmp	r2, r5
 800de2e:	bf0c      	ite	eq
 800de30:	2300      	moveq	r3, #0
 800de32:	f003 0301 	andne.w	r3, r3, #1
 800de36:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800de3a:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800de3e:	4282      	cmp	r2, r0
 800de40:	bf0c      	ite	eq
 800de42:	2300      	moveq	r3, #0
 800de44:	f003 0301 	andne.w	r3, r3, #1
 800de48:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800de4c:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 800de50:	428a      	cmp	r2, r1
 800de52:	bf0c      	ite	eq
 800de54:	2300      	moveq	r3, #0
 800de56:	f003 0301 	andne.w	r3, r3, #1
 800de5a:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 800de5e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800de62:	42aa      	cmp	r2, r5
 800de64:	bf0c      	ite	eq
 800de66:	2300      	moveq	r3, #0
 800de68:	f003 0301 	andne.w	r3, r3, #1
 800de6c:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800de70:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 800de74:	4282      	cmp	r2, r0
 800de76:	bf0c      	ite	eq
 800de78:	2300      	moveq	r3, #0
 800de7a:	f003 0301 	andne.w	r3, r3, #1
 800de7e:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800de82:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800de86:	428a      	cmp	r2, r1
 800de88:	bf0c      	ite	eq
 800de8a:	2300      	moveq	r3, #0
 800de8c:	f003 0301 	andne.w	r3, r3, #1
 800de90:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800de94:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800de98:	42aa      	cmp	r2, r5
 800de9a:	bf0c      	ite	eq
 800de9c:	2300      	moveq	r3, #0
 800de9e:	f003 0301 	andne.w	r3, r3, #1
 800dea2:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800dea6:	4282      	cmp	r2, r0
 800dea8:	bf0c      	ite	eq
 800deaa:	2300      	moveq	r3, #0
 800deac:	f003 0301 	andne.w	r3, r3, #1
 800deb0:	428a      	cmp	r2, r1
 800deb2:	bf0c      	ite	eq
 800deb4:	2300      	moveq	r3, #0
 800deb6:	f003 0301 	andne.w	r3, r3, #1
 800deba:	b133      	cbz	r3, 800deca <HAL_TIM_PWM_Init+0xf6>
 800debc:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800dec0:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dec4:	429a      	cmp	r2, r3
 800dec6:	f040 80ca 	bne.w	800e05e <HAL_TIM_PWM_Init+0x28a>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800deca:	68a3      	ldr	r3, [r4, #8]
 800decc:	f023 0140 	bic.w	r1, r3, #64	; 0x40
 800ded0:	f023 0210 	bic.w	r2, r3, #16
 800ded4:	2920      	cmp	r1, #32
 800ded6:	bf18      	it	ne
 800ded8:	2a00      	cmpne	r2, #0
 800deda:	d002      	beq.n	800dee2 <HAL_TIM_PWM_Init+0x10e>
 800dedc:	2b40      	cmp	r3, #64	; 0x40
 800dede:	f040 80a8 	bne.w	800e032 <HAL_TIM_PWM_Init+0x25e>
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800dee2:	6923      	ldr	r3, [r4, #16]
 800dee4:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800dee8:	d003      	beq.n	800def2 <HAL_TIM_PWM_Init+0x11e>
 800deea:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800deee:	f040 8092 	bne.w	800e016 <HAL_TIM_PWM_Init+0x242>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800def2:	69a3      	ldr	r3, [r4, #24]
 800def4:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800def8:	d17b      	bne.n	800dff2 <HAL_TIM_PWM_Init+0x21e>
  if (htim->State == HAL_TIM_STATE_RESET)
 800defa:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800defe:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800df02:	2b00      	cmp	r3, #0
 800df04:	d06f      	beq.n	800dfe6 <HAL_TIM_PWM_Init+0x212>
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800df06:	2100      	movs	r1, #0
 800df08:	f44f 6380 	mov.w	r3, #1024	; 0x400
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 800df0c:	6822      	ldr	r2, [r4, #0]
  htim->State = HAL_TIM_STATE_BUSY;
 800df0e:	2002      	movs	r0, #2
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800df10:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800df14:	f2c4 0301 	movt	r3, #16385	; 0x4001
  htim->State = HAL_TIM_STATE_BUSY;
 800df18:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800df1c:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800df20:	eba2 0001 	sub.w	r0, r2, r1
 800df24:	eba2 0103 	sub.w	r1, r2, r3
  tmpcr1 = TIMx->CR1;
 800df28:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 800df2a:	fab0 f080 	clz	r0, r0
 800df2e:	fab1 f181 	clz	r1, r1
 800df32:	ea4f 1050 	mov.w	r0, r0, lsr #5
 800df36:	ea4f 1151 	mov.w	r1, r1, lsr #5
 800df3a:	d027      	beq.n	800df8c <HAL_TIM_PWM_Init+0x1b8>
 800df3c:	bb30      	cbnz	r0, 800df8c <HAL_TIM_PWM_Init+0x1b8>
 800df3e:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800df42:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800df46:	42aa      	cmp	r2, r5
 800df48:	d020      	beq.n	800df8c <HAL_TIM_PWM_Init+0x1b8>
 800df4a:	f44f 6500 	mov.w	r5, #2048	; 0x800
 800df4e:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800df52:	42aa      	cmp	r2, r5
 800df54:	d01a      	beq.n	800df8c <HAL_TIM_PWM_Init+0x1b8>
 800df56:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 800df5a:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800df5e:	42aa      	cmp	r2, r5
 800df60:	d070      	beq.n	800e044 <HAL_TIM_PWM_Init+0x270>
 800df62:	2900      	cmp	r1, #0
 800df64:	d16e      	bne.n	800e044 <HAL_TIM_PWM_Init+0x270>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800df66:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800df6a:	f44f 4588 	mov.w	r5, #17408	; 0x4400
 800df6e:	f2c4 0601 	movt	r6, #16385	; 0x4001
 800df72:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800df76:	42aa      	cmp	r2, r5
 800df78:	bf18      	it	ne
 800df7a:	42b2      	cmpne	r2, r6
 800df7c:	d00a      	beq.n	800df94 <HAL_TIM_PWM_Init+0x1c0>
 800df7e:	f44f 4590 	mov.w	r5, #18432	; 0x4800
 800df82:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800df86:	42aa      	cmp	r2, r5
 800df88:	d108      	bne.n	800df9c <HAL_TIM_PWM_Init+0x1c8>
 800df8a:	e003      	b.n	800df94 <HAL_TIM_PWM_Init+0x1c0>
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800df8c:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800df90:	68a5      	ldr	r5, [r4, #8]
 800df92:	432b      	orrs	r3, r5
    tmpcr1 &= ~TIM_CR1_CKD;
 800df94:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 800df98:	6925      	ldr	r5, [r4, #16]
 800df9a:	432b      	orrs	r3, r5
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 800df9c:	69a5      	ldr	r5, [r4, #24]
 800df9e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800dfa2:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 800dfa4:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 800dfa6:	68e3      	ldr	r3, [r4, #12]
 800dfa8:	62d3      	str	r3, [r2, #44]	; 0x2c
  TIMx->PSC = Structure->Prescaler;
 800dfaa:	6863      	ldr	r3, [r4, #4]
 800dfac:	6293      	str	r3, [r2, #40]	; 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800dfae:	b990      	cbnz	r0, 800dfd6 <HAL_TIM_PWM_Init+0x202>
 800dfb0:	b989      	cbnz	r1, 800dfd6 <HAL_TIM_PWM_Init+0x202>
 800dfb2:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800dfb6:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800dfba:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800dfbe:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dfc2:	429a      	cmp	r2, r3
 800dfc4:	bf18      	it	ne
 800dfc6:	428a      	cmpne	r2, r1
 800dfc8:	d005      	beq.n	800dfd6 <HAL_TIM_PWM_Init+0x202>
 800dfca:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800dfce:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800dfd2:	429a      	cmp	r2, r3
 800dfd4:	d101      	bne.n	800dfda <HAL_TIM_PWM_Init+0x206>
    TIMx->RCR = Structure->RepetitionCounter;
 800dfd6:	6963      	ldr	r3, [r4, #20]
 800dfd8:	6313      	str	r3, [r2, #48]	; 0x30
  TIMx->EGR = TIM_EGR_UG;
 800dfda:	2301      	movs	r3, #1
  return HAL_OK;
 800dfdc:	2000      	movs	r0, #0
  TIMx->EGR = TIM_EGR_UG;
 800dfde:	6153      	str	r3, [r2, #20]
  htim->State = HAL_TIM_STATE_READY;
 800dfe0:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
}
 800dfe4:	bd70      	pop	{r4, r5, r6, pc}
    htim->Lock = HAL_UNLOCKED;
 800dfe6:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
    HAL_TIM_PWM_MspInit(htim);
 800dfea:	4620      	mov	r0, r4
 800dfec:	f011 fbba 	bl	801f764 <HAL_TIM_PWM_MspInit>
 800dff0:	e789      	b.n	800df06 <HAL_TIM_PWM_Init+0x132>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800dff2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800dff6:	f240 41a5 	movw	r1, #1189	; 0x4a5
 800dffa:	f6c0 0002 	movt	r0, #2050	; 0x802
 800dffe:	f007 fc33 	bl	8015868 <assert_failed>
  if (htim->State == HAL_TIM_STATE_RESET)
 800e002:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 800e006:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800e00a:	2b00      	cmp	r3, #0
 800e00c:	f47f af7b 	bne.w	800df06 <HAL_TIM_PWM_Init+0x132>
 800e010:	e7e9      	b.n	800dfe6 <HAL_TIM_PWM_Init+0x212>
    return HAL_ERROR;
 800e012:	2001      	movs	r0, #1
}
 800e014:	4770      	bx	lr
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
 800e016:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e01a:	f240 41a4 	movw	r1, #1188	; 0x4a4
 800e01e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e022:	f007 fc21 	bl	8015868 <assert_failed>
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
 800e026:	69a3      	ldr	r3, [r4, #24]
 800e028:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800e02c:	f43f af65 	beq.w	800defa <HAL_TIM_PWM_Init+0x126>
 800e030:	e7df      	b.n	800dff2 <HAL_TIM_PWM_Init+0x21e>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
 800e032:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e036:	f240 41a3 	movw	r1, #1187	; 0x4a3
 800e03a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e03e:	f007 fc13 	bl	8015868 <assert_failed>
 800e042:	e74e      	b.n	800dee2 <HAL_TIM_PWM_Init+0x10e>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800e044:	f44f 6540 	mov.w	r5, #3072	; 0xc00
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 800e048:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 800e04c:	68a6      	ldr	r6, [r4, #8]
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800e04e:	f2c4 0500 	movt	r5, #16384	; 0x4000
    tmpcr1 |= Structure->CounterMode;
 800e052:	4333      	orrs	r3, r6
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 800e054:	42aa      	cmp	r2, r5
 800e056:	d09d      	beq.n	800df94 <HAL_TIM_PWM_Init+0x1c0>
 800e058:	2900      	cmp	r1, #0
 800e05a:	d19b      	bne.n	800df94 <HAL_TIM_PWM_Init+0x1c0>
 800e05c:	e783      	b.n	800df66 <HAL_TIM_PWM_Init+0x192>
  assert_param(IS_TIM_INSTANCE(htim->Instance));
 800e05e:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e062:	f240 41a2 	movw	r1, #1186	; 0x4a2
 800e066:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e06a:	f007 fbfd 	bl	8015868 <assert_failed>
 800e06e:	e72c      	b.n	800deca <HAL_TIM_PWM_Init+0xf6>

0800e070 <HAL_TIM_PWM_Start>:
{
 800e070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800e072:	2300      	movs	r3, #0
 800e074:	6804      	ldr	r4, [r0, #0]
{
 800e076:	4606      	mov	r6, r0
 800e078:	460d      	mov	r5, r1
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800e07a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e07e:	429c      	cmp	r4, r3
 800e080:	f000 80d5 	beq.w	800e22e <HAL_TIM_PWM_Start+0x1be>
 800e084:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800e088:	f000 80ca 	beq.w	800e220 <HAL_TIM_PWM_Start+0x1b0>
 800e08c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e090:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e094:	429c      	cmp	r4, r3
 800e096:	f000 80c3 	beq.w	800e220 <HAL_TIM_PWM_Start+0x1b0>
 800e09a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800e09e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e0a2:	429c      	cmp	r4, r3
 800e0a4:	f000 80bc 	beq.w	800e220 <HAL_TIM_PWM_Start+0x1b0>
 800e0a8:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800e0ac:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e0b0:	429c      	cmp	r4, r3
 800e0b2:	f000 80b5 	beq.w	800e220 <HAL_TIM_PWM_Start+0x1b0>
 800e0b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e0ba:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e0be:	429c      	cmp	r4, r3
 800e0c0:	f000 80d2 	beq.w	800e268 <HAL_TIM_PWM_Start+0x1f8>
 800e0c4:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800e0c8:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e0cc:	429c      	cmp	r4, r3
 800e0ce:	f000 80d6 	beq.w	800e27e <HAL_TIM_PWM_Start+0x20e>
 800e0d2:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800e0d6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e0da:	429c      	cmp	r4, r3
 800e0dc:	f040 80d4 	bne.w	800e288 <HAL_TIM_PWM_Start+0x218>
 800e0e0:	b345      	cbz	r5, 800e134 <HAL_TIM_PWM_Start+0xc4>
 800e0e2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e0e6:	f240 511c 	movw	r1, #1308	; 0x51c
 800e0ea:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e0ee:	f007 fbbb 	bl	8015868 <assert_failed>
void TIM_CCxChannelCmd(TIM_TypeDef *TIMx, uint32_t Channel, uint32_t ChannelState)
{
  uint32_t tmp;

  /* Check the parameters */
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
 800e0f2:	2300      	movs	r3, #0
  TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
 800e0f4:	6834      	ldr	r4, [r6, #0]
  assert_param(IS_TIM_CC1_INSTANCE(TIMx));
 800e0f6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e0fa:	429c      	cmp	r4, r3
 800e0fc:	d046      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e0fe:	f1b4 4f80 	cmp.w	r4, #1073741824	; 0x40000000
 800e102:	d043      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e104:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e108:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e10c:	429c      	cmp	r4, r3
 800e10e:	d03d      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e110:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800e114:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e118:	429c      	cmp	r4, r3
 800e11a:	d037      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e11c:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 800e120:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e124:	429c      	cmp	r4, r3
 800e126:	d031      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e128:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e12c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e130:	429c      	cmp	r4, r3
 800e132:	d02b      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e134:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800e138:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e13c:	429c      	cmp	r4, r3
 800e13e:	d025      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e140:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 800e144:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e148:	429c      	cmp	r4, r3
 800e14a:	d01f      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e14c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800e150:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e154:	429c      	cmp	r4, r3
 800e156:	d019      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e158:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e15c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e160:	429c      	cmp	r4, r3
 800e162:	d013      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e164:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800e168:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e16c:	429c      	cmp	r4, r3
 800e16e:	d00d      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e170:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800e174:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e178:	429c      	cmp	r4, r3
 800e17a:	d007      	beq.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e17c:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e180:	f641 3154 	movw	r1, #6996	; 0x1b54
 800e184:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e188:	f007 fb6e 	bl	8015868 <assert_failed>
  assert_param(IS_TIM_CHANNELS(Channel));
 800e18c:	2d14      	cmp	r5, #20
 800e18e:	d959      	bls.n	800e244 <HAL_TIM_PWM_Start+0x1d4>
 800e190:	2d3c      	cmp	r5, #60	; 0x3c
 800e192:	d160      	bne.n	800e256 <HAL_TIM_PWM_Start+0x1e6>

  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800e194:	2301      	movs	r3, #1
 800e196:	f005 051f 	and.w	r5, r5, #31

  /* Reset the CCxE Bit */
  TIMx->CCER &= ~tmp;
 800e19a:	6a21      	ldr	r1, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e19c:	2200      	movs	r2, #0
  tmp = TIM_CCER_CC1E << (Channel & 0x1FU); /* 0x1FU = 31 bits max shift */
 800e19e:	fa03 f505 	lsl.w	r5, r3, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e1a2:	f44f 6780 	mov.w	r7, #1024	; 0x400
 800e1a6:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800e1aa:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  TIMx->CCER &= ~tmp;
 800e1ae:	ea21 0105 	bic.w	r1, r1, r5
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e1b2:	f2c4 0701 	movt	r7, #16385	; 0x4001
 800e1b6:	f2c4 0001 	movt	r0, #16385	; 0x4001
  TIMx->CCER &= ~tmp;
 800e1ba:	6221      	str	r1, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e1bc:	f44f 4188 	mov.w	r1, #17408	; 0x4400

  /* Set or reset the CCxE Bit */
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800e1c0:	6a23      	ldr	r3, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e1c2:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER |= (uint32_t)(ChannelState << (Channel & 0x1FU)); /* 0x1FU = 31 bits max shift */
 800e1c6:	431d      	orrs	r5, r3
 800e1c8:	6225      	str	r5, [r4, #32]
  if (IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
 800e1ca:	6833      	ldr	r3, [r6, #0]
 800e1cc:	42bb      	cmp	r3, r7
 800e1ce:	bf18      	it	ne
 800e1d0:	4293      	cmpne	r3, r2
 800e1d2:	bf0c      	ite	eq
 800e1d4:	2201      	moveq	r2, #1
 800e1d6:	2200      	movne	r2, #0
 800e1d8:	4283      	cmp	r3, r0
 800e1da:	bf08      	it	eq
 800e1dc:	f042 0201 	orreq.w	r2, r2, #1
 800e1e0:	428b      	cmp	r3, r1
 800e1e2:	bf08      	it	eq
 800e1e4:	f042 0201 	orreq.w	r2, r2, #1
 800e1e8:	b92a      	cbnz	r2, 800e1f6 <HAL_TIM_PWM_Start+0x186>
 800e1ea:	f44f 4290 	mov.w	r2, #18432	; 0x4800
 800e1ee:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800e1f2:	4293      	cmp	r3, r2
 800e1f4:	d104      	bne.n	800e200 <HAL_TIM_PWM_Start+0x190>
    __HAL_TIM_MOE_ENABLE(htim);
 800e1f6:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800e1f8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800e1fc:	645a      	str	r2, [r3, #68]	; 0x44
 800e1fe:	6833      	ldr	r3, [r6, #0]
  tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 800e200:	2207      	movs	r2, #7
 800e202:	6899      	ldr	r1, [r3, #8]
 800e204:	f2c0 0201 	movt	r2, #1
 800e208:	400a      	ands	r2, r1
  if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 800e20a:	2a06      	cmp	r2, #6
 800e20c:	d006      	beq.n	800e21c <HAL_TIM_PWM_Start+0x1ac>
 800e20e:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800e212:	d003      	beq.n	800e21c <HAL_TIM_PWM_Start+0x1ac>
    __HAL_TIM_ENABLE(htim);
 800e214:	681a      	ldr	r2, [r3, #0]
 800e216:	f042 0201 	orr.w	r2, r2, #1
 800e21a:	601a      	str	r2, [r3, #0]
}
 800e21c:	2000      	movs	r0, #0
 800e21e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800e220:	f035 030c 	bics.w	r3, r5, #12
 800e224:	f47f af5d 	bne.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
  assert_param(IS_TIM_CHANNELS(Channel));
 800e228:	2d14      	cmp	r5, #20
 800e22a:	d8b1      	bhi.n	800e190 <HAL_TIM_PWM_Start+0x120>
 800e22c:	e00a      	b.n	800e244 <HAL_TIM_PWM_Start+0x1d4>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800e22e:	2914      	cmp	r1, #20
 800e230:	f63f af57 	bhi.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e234:	f241 1311 	movw	r3, #4369	; 0x1111
 800e238:	f2c0 0311 	movt	r3, #17
 800e23c:	40cb      	lsrs	r3, r1
 800e23e:	07d9      	lsls	r1, r3, #31
 800e240:	f57f af4f 	bpl.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
  assert_param(IS_TIM_CHANNELS(Channel));
 800e244:	f241 1311 	movw	r3, #4369	; 0x1111
 800e248:	f2c0 0311 	movt	r3, #17
 800e24c:	40eb      	lsrs	r3, r5
 800e24e:	07db      	lsls	r3, r3, #31
 800e250:	d4a0      	bmi.n	800e194 <HAL_TIM_PWM_Start+0x124>
 800e252:	2d3c      	cmp	r5, #60	; 0x3c
 800e254:	d09e      	beq.n	800e194 <HAL_TIM_PWM_Start+0x124>
 800e256:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e25a:	f641 3155 	movw	r1, #6997	; 0x1b55
 800e25e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e262:	f007 fb01 	bl	8015868 <assert_failed>
 800e266:	e795      	b.n	800e194 <HAL_TIM_PWM_Start+0x124>
  assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
 800e268:	2914      	cmp	r1, #20
 800e26a:	f63f af3a 	bhi.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e26e:	f241 1311 	movw	r3, #4369	; 0x1111
 800e272:	f2c0 0311 	movt	r3, #17
 800e276:	40cb      	lsrs	r3, r1
 800e278:	07da      	lsls	r2, r3, #31
 800e27a:	d487      	bmi.n	800e18c <HAL_TIM_PWM_Start+0x11c>
 800e27c:	e731      	b.n	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e27e:	f035 0304 	bics.w	r3, r5, #4
 800e282:	f47f af2e 	bne.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e286:	e755      	b.n	800e134 <HAL_TIM_PWM_Start+0xc4>
 800e288:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800e28c:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800e290:	429c      	cmp	r4, r3
 800e292:	f43f af25 	beq.w	800e0e0 <HAL_TIM_PWM_Start+0x70>
 800e296:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e29a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e29e:	429c      	cmp	r4, r3
 800e2a0:	d0ed      	beq.n	800e27e <HAL_TIM_PWM_Start+0x20e>
 800e2a2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800e2a6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e2aa:	429c      	cmp	r4, r3
 800e2ac:	f43f af18 	beq.w	800e0e0 <HAL_TIM_PWM_Start+0x70>
 800e2b0:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800e2b4:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e2b8:	429c      	cmp	r4, r3
 800e2ba:	f47f af12 	bne.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e2be:	2900      	cmp	r1, #0
 800e2c0:	f47f af0f 	bne.w	800e0e2 <HAL_TIM_PWM_Start+0x72>
 800e2c4:	461c      	mov	r4, r3
 800e2c6:	e729      	b.n	800e11c <HAL_TIM_PWM_Start+0xac>

0800e2c8 <HAL_TIM_ConfigClockSource>:
{
 800e2c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(htim);
 800e2ca:	f890 303c 	ldrb.w	r3, [r0, #60]	; 0x3c
 800e2ce:	2b01      	cmp	r3, #1
 800e2d0:	f000 81d7 	beq.w	800e682 <HAL_TIM_ConfigClockSource+0x3ba>
 800e2d4:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800e2d6:	2302      	movs	r3, #2
 800e2d8:	460d      	mov	r5, r1
 800e2da:	4604      	mov	r4, r0
  __HAL_LOCK(htim);
 800e2dc:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800e2e0:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800e2e4:	680b      	ldr	r3, [r1, #0]
 800e2e6:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e2ea:	bf18      	it	ne
 800e2ec:	f5b3 5f00 	cmpne.w	r3, #8192	; 0x2000
 800e2f0:	bf14      	ite	ne
 800e2f2:	2201      	movne	r2, #1
 800e2f4:	2200      	moveq	r2, #0
 800e2f6:	f033 0330 	bics.w	r3, r3, #48	; 0x30
 800e2fa:	bf08      	it	eq
 800e2fc:	2200      	moveq	r2, #0
 800e2fe:	b112      	cbz	r2, 800e306 <HAL_TIM_ConfigClockSource+0x3e>
 800e300:	2b40      	cmp	r3, #64	; 0x40
 800e302:	f040 82de 	bne.w	800e8c2 <HAL_TIM_ConfigClockSource+0x5fa>
  tmpsmcr = htim->Instance->SMCR;
 800e306:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800e308:	2388      	movs	r3, #136	; 0x88
  tmpsmcr = htim->Instance->SMCR;
 800e30a:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800e30c:	f6cf 73ce 	movt	r3, #65486	; 0xffce
 800e310:	400b      	ands	r3, r1
  htim->Instance->SMCR = tmpsmcr;
 800e312:	6093      	str	r3, [r2, #8]
  switch (sClockSourceConfig->ClockSource)
 800e314:	682b      	ldr	r3, [r5, #0]
 800e316:	2b70      	cmp	r3, #112	; 0x70
 800e318:	f000 81b5 	beq.w	800e686 <HAL_TIM_ConfigClockSource+0x3be>
 800e31c:	d86e      	bhi.n	800e3fc <HAL_TIM_ConfigClockSource+0x134>
 800e31e:	2b30      	cmp	r3, #48	; 0x30
 800e320:	f000 826b 	beq.w	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e324:	f240 8262 	bls.w	800e7ec <HAL_TIM_ConfigClockSource+0x524>
 800e328:	2b50      	cmp	r3, #80	; 0x50
 800e32a:	f000 81fe 	beq.w	800e72a <HAL_TIM_ConfigClockSource+0x462>
 800e32e:	2b60      	cmp	r3, #96	; 0x60
 800e330:	f000 80f3 	beq.w	800e51a <HAL_TIM_ConfigClockSource+0x252>
 800e334:	2b40      	cmp	r3, #64	; 0x40
 800e336:	f040 80e8 	bne.w	800e50a <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e33a:	2300      	movs	r3, #0
 800e33c:	6822      	ldr	r2, [r4, #0]
 800e33e:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800e342:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800e346:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e34a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e34e:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e352:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e356:	429a      	cmp	r2, r3
 800e358:	bf18      	it	ne
 800e35a:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e35e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e362:	bf14      	ite	ne
 800e364:	2301      	movne	r3, #1
 800e366:	2300      	moveq	r3, #0
 800e368:	42b2      	cmp	r2, r6
 800e36a:	bf0c      	ite	eq
 800e36c:	2300      	moveq	r3, #0
 800e36e:	f003 0301 	andne.w	r3, r3, #1
 800e372:	428a      	cmp	r2, r1
 800e374:	bf0c      	ite	eq
 800e376:	2300      	moveq	r3, #0
 800e378:	f003 0301 	andne.w	r3, r3, #1
 800e37c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800e380:	4282      	cmp	r2, r0
 800e382:	bf0c      	ite	eq
 800e384:	2300      	moveq	r3, #0
 800e386:	f003 0301 	andne.w	r3, r3, #1
 800e38a:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800e38e:	428a      	cmp	r2, r1
 800e390:	bf0c      	ite	eq
 800e392:	2300      	moveq	r3, #0
 800e394:	f003 0301 	andne.w	r3, r3, #1
 800e398:	b133      	cbz	r3, 800e3a8 <HAL_TIM_ConfigClockSource+0xe0>
 800e39a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e39e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e3a2:	429a      	cmp	r2, r3
 800e3a4:	f040 82e0 	bne.w	800e968 <HAL_TIM_ConfigClockSource+0x6a0>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e3a8:	686b      	ldr	r3, [r5, #4]
 800e3aa:	2b0a      	cmp	r3, #10
 800e3ac:	bf18      	it	ne
 800e3ae:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800e3b2:	d003      	beq.n	800e3bc <HAL_TIM_ConfigClockSource+0xf4>
 800e3b4:	f033 0302 	bics.w	r3, r3, #2
 800e3b8:	f040 828c 	bne.w	800e8d4 <HAL_TIM_ConfigClockSource+0x60c>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e3bc:	68ef      	ldr	r7, [r5, #12]
 800e3be:	2f0f      	cmp	r7, #15
 800e3c0:	f200 8303 	bhi.w	800e9ca <HAL_TIM_ConfigClockSource+0x702>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e3c4:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e3c6:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e3ca:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
 800e3cc:	6a16      	ldr	r6, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e3ce:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e3d2:	6a15      	ldr	r5, [r2, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800e3d4:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e3d8:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 800e3dc:	4330      	orrs	r0, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e3de:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
 800e3e0:	6991      	ldr	r1, [r2, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800e3e2:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800e3e6:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 800e3ea:	6191      	str	r1, [r2, #24]
  TIMx->CCER = tmpccer;
 800e3ec:	6210      	str	r0, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 800e3ee:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800e3f0:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e3f2:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800e3f4:	f043 0347 	orr.w	r3, r3, #71	; 0x47
  TIMx->SMCR = tmpsmcr;
 800e3f8:	6093      	str	r3, [r2, #8]
 800e3fa:	e086      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
 800e3fc:	f1b3 1f10 	cmp.w	r3, #1048592	; 0x100010
 800e400:	f000 81fb 	beq.w	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e404:	f200 823a 	bhi.w	800e87c <HAL_TIM_ConfigClockSource+0x5b4>
 800e408:	f5b3 5f00 	cmp.w	r3, #8192	; 0x2000
 800e40c:	f000 80e7 	beq.w	800e5de <HAL_TIM_ConfigClockSource+0x316>
 800e410:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 800e414:	f000 81f1 	beq.w	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e418:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 800e41c:	d175      	bne.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800e41e:	2300      	movs	r3, #0
 800e420:	6822      	ldr	r2, [r4, #0]
 800e422:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800e426:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800e42a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e42e:	f44f 6540 	mov.w	r5, #3072	; 0xc00
 800e432:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e436:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e43a:	429a      	cmp	r2, r3
 800e43c:	bf18      	it	ne
 800e43e:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e442:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800e446:	bf14      	ite	ne
 800e448:	2301      	movne	r3, #1
 800e44a:	2300      	moveq	r3, #0
 800e44c:	4282      	cmp	r2, r0
 800e44e:	bf0c      	ite	eq
 800e450:	2300      	moveq	r3, #0
 800e452:	f003 0301 	andne.w	r3, r3, #1
 800e456:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800e45a:	428a      	cmp	r2, r1
 800e45c:	bf0c      	ite	eq
 800e45e:	2300      	moveq	r3, #0
 800e460:	f003 0301 	andne.w	r3, r3, #1
 800e464:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e468:	f44f 51a0 	mov.w	r1, #5120	; 0x1400
 800e46c:	42aa      	cmp	r2, r5
 800e46e:	bf0c      	ite	eq
 800e470:	2300      	moveq	r3, #0
 800e472:	f003 0301 	andne.w	r3, r3, #1
 800e476:	f44f 6580 	mov.w	r5, #1024	; 0x400
 800e47a:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e47e:	4282      	cmp	r2, r0
 800e480:	bf0c      	ite	eq
 800e482:	2300      	moveq	r3, #0
 800e484:	f003 0301 	andne.w	r3, r3, #1
 800e488:	f2c4 0501 	movt	r5, #16385	; 0x4001
 800e48c:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
 800e490:	428a      	cmp	r2, r1
 800e492:	bf0c      	ite	eq
 800e494:	2300      	moveq	r3, #0
 800e496:	f003 0301 	andne.w	r3, r3, #1
 800e49a:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 800e49e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e4a2:	42aa      	cmp	r2, r5
 800e4a4:	bf0c      	ite	eq
 800e4a6:	2300      	moveq	r3, #0
 800e4a8:	f003 0301 	andne.w	r3, r3, #1
 800e4ac:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e4b0:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 800e4b4:	4282      	cmp	r2, r0
 800e4b6:	bf0c      	ite	eq
 800e4b8:	2300      	moveq	r3, #0
 800e4ba:	f003 0301 	andne.w	r3, r3, #1
 800e4be:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800e4c2:	f2c4 0500 	movt	r5, #16384	; 0x4000
 800e4c6:	428a      	cmp	r2, r1
 800e4c8:	bf0c      	ite	eq
 800e4ca:	2300      	moveq	r3, #0
 800e4cc:	f003 0301 	andne.w	r3, r3, #1
 800e4d0:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800e4d4:	f44f 4188 	mov.w	r1, #17408	; 0x4400
 800e4d8:	42aa      	cmp	r2, r5
 800e4da:	bf0c      	ite	eq
 800e4dc:	2300      	moveq	r3, #0
 800e4de:	f003 0301 	andne.w	r3, r3, #1
 800e4e2:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800e4e6:	4282      	cmp	r2, r0
 800e4e8:	bf0c      	ite	eq
 800e4ea:	2300      	moveq	r3, #0
 800e4ec:	f003 0301 	andne.w	r3, r3, #1
 800e4f0:	428a      	cmp	r2, r1
 800e4f2:	bf0c      	ite	eq
 800e4f4:	2300      	moveq	r3, #0
 800e4f6:	f003 0301 	andne.w	r3, r3, #1
 800e4fa:	b133      	cbz	r3, 800e50a <HAL_TIM_ConfigClockSource+0x242>
 800e4fc:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800e500:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e504:	429a      	cmp	r2, r3
 800e506:	f040 827c 	bne.w	800ea02 <HAL_TIM_ConfigClockSource+0x73a>
  __HAL_UNLOCK(htim);
 800e50a:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800e50c:	2201      	movs	r2, #1
  return HAL_OK;
 800e50e:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800e510:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800e514:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800e518:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e51a:	2300      	movs	r3, #0
 800e51c:	6822      	ldr	r2, [r4, #0]
 800e51e:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800e522:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800e526:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e52a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e52e:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e532:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e536:	429a      	cmp	r2, r3
 800e538:	bf18      	it	ne
 800e53a:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e53e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e542:	bf14      	ite	ne
 800e544:	2301      	movne	r3, #1
 800e546:	2300      	moveq	r3, #0
 800e548:	42b2      	cmp	r2, r6
 800e54a:	bf0c      	ite	eq
 800e54c:	2300      	moveq	r3, #0
 800e54e:	f003 0301 	andne.w	r3, r3, #1
 800e552:	428a      	cmp	r2, r1
 800e554:	bf0c      	ite	eq
 800e556:	2300      	moveq	r3, #0
 800e558:	f003 0301 	andne.w	r3, r3, #1
 800e55c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800e560:	4282      	cmp	r2, r0
 800e562:	bf0c      	ite	eq
 800e564:	2300      	moveq	r3, #0
 800e566:	f003 0301 	andne.w	r3, r3, #1
 800e56a:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800e56e:	428a      	cmp	r2, r1
 800e570:	bf0c      	ite	eq
 800e572:	2300      	moveq	r3, #0
 800e574:	f003 0301 	andne.w	r3, r3, #1
 800e578:	b133      	cbz	r3, 800e588 <HAL_TIM_ConfigClockSource+0x2c0>
 800e57a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e57e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e582:	429a      	cmp	r2, r3
 800e584:	f040 81e7 	bne.w	800e956 <HAL_TIM_ConfigClockSource+0x68e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e588:	686b      	ldr	r3, [r5, #4]
 800e58a:	2b0a      	cmp	r3, #10
 800e58c:	bf18      	it	ne
 800e58e:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800e592:	d003      	beq.n	800e59c <HAL_TIM_ConfigClockSource+0x2d4>
 800e594:	f033 0302 	bics.w	r3, r3, #2
 800e598:	f040 81a5 	bne.w	800e8e6 <HAL_TIM_ConfigClockSource+0x61e>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e59c:	68ee      	ldr	r6, [r5, #12]
 800e59e:	2e0f      	cmp	r6, #15
 800e5a0:	f200 8209 	bhi.w	800e9b6 <HAL_TIM_ConfigClockSource+0x6ee>
      TIM_TI2_ConfigInputStage(htim->Instance,
 800e5a4:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e5a6:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI2_ConfigInputStage(htim->Instance,
 800e5aa:	686f      	ldr	r7, [r5, #4]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800e5ac:	6a15      	ldr	r5, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e5ae:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800e5b2:	f025 0510 	bic.w	r5, r5, #16
 800e5b6:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
 800e5b8:	6990      	ldr	r0, [r2, #24]
  tmpccer = TIMx->CCER;
 800e5ba:	6a11      	ldr	r1, [r2, #32]
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 800e5bc:	f420 4070 	bic.w	r0, r0, #61440	; 0xf000
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 800e5c0:	f021 01a0 	bic.w	r1, r1, #160	; 0xa0
  tmpccmr1 |= (TIM_ICFilter << 12U);
 800e5c4:	ea40 3006 	orr.w	r0, r0, r6, lsl #12
  tmpccer |= (TIM_ICPolarity << 4U);
 800e5c8:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1 ;
 800e5cc:	6190      	str	r0, [r2, #24]
  TIMx->CCER = tmpccer;
 800e5ce:	6211      	str	r1, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 800e5d0:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800e5d2:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e5d4:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800e5d6:	f043 0367 	orr.w	r3, r3, #103	; 0x67
  TIMx->SMCR = tmpsmcr;
 800e5da:	6093      	str	r3, [r2, #8]
 800e5dc:	e795      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800e5de:	2300      	movs	r3, #0
 800e5e0:	6822      	ldr	r2, [r4, #0]
 800e5e2:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800e5e6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e5ea:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e5ee:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 800e5f2:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e5f6:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e5fa:	429a      	cmp	r2, r3
 800e5fc:	bf18      	it	ne
 800e5fe:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e602:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e606:	bf14      	ite	ne
 800e608:	2301      	movne	r3, #1
 800e60a:	2300      	moveq	r3, #0
 800e60c:	42b2      	cmp	r2, r6
 800e60e:	bf0c      	ite	eq
 800e610:	2300      	moveq	r3, #0
 800e612:	f003 0301 	andne.w	r3, r3, #1
 800e616:	4282      	cmp	r2, r0
 800e618:	bf0c      	ite	eq
 800e61a:	2300      	moveq	r3, #0
 800e61c:	f003 0301 	andne.w	r3, r3, #1
 800e620:	428a      	cmp	r2, r1
 800e622:	bf0c      	ite	eq
 800e624:	2300      	moveq	r3, #0
 800e626:	f003 0301 	andne.w	r3, r3, #1
 800e62a:	b133      	cbz	r3, 800e63a <HAL_TIM_ConfigClockSource+0x372>
 800e62c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e630:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e634:	429a      	cmp	r2, r3
 800e636:	f040 8132 	bne.w	800e89e <HAL_TIM_ConfigClockSource+0x5d6>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800e63a:	68ab      	ldr	r3, [r5, #8]
 800e63c:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 800e640:	f040 81cd 	bne.w	800e9de <HAL_TIM_ConfigClockSource+0x716>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e644:	686b      	ldr	r3, [r5, #4]
 800e646:	2b0a      	cmp	r3, #10
 800e648:	bf18      	it	ne
 800e64a:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800e64e:	d003      	beq.n	800e658 <HAL_TIM_ConfigClockSource+0x390>
 800e650:	f033 0302 	bics.w	r3, r3, #2
 800e654:	f040 8159 	bne.w	800e90a <HAL_TIM_ConfigClockSource+0x642>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e658:	68e9      	ldr	r1, [r5, #12]
 800e65a:	290f      	cmp	r1, #15
 800e65c:	f200 818d 	bhi.w	800e97a <HAL_TIM_ConfigClockSource+0x6b2>
      TIM_ETR_SetConfig(htim->Instance,
 800e660:	6820      	ldr	r0, [r4, #0]
 800e662:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
 800e664:	6882      	ldr	r2, [r0, #8]
 800e666:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800e668:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800e66c:	432b      	orrs	r3, r5
 800e66e:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800e670:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
 800e674:	6083      	str	r3, [r0, #8]
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 800e676:	6822      	ldr	r2, [r4, #0]
 800e678:	6893      	ldr	r3, [r2, #8]
 800e67a:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800e67e:	6093      	str	r3, [r2, #8]
      break;
 800e680:	e743      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
  __HAL_LOCK(htim);
 800e682:	2002      	movs	r0, #2
}
 800e684:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800e686:	2300      	movs	r3, #0
 800e688:	6822      	ldr	r2, [r4, #0]
 800e68a:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800e68e:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e692:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e696:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 800e69a:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e69e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e6a2:	429a      	cmp	r2, r3
 800e6a4:	bf18      	it	ne
 800e6a6:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e6aa:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e6ae:	bf14      	ite	ne
 800e6b0:	2301      	movne	r3, #1
 800e6b2:	2300      	moveq	r3, #0
 800e6b4:	42b2      	cmp	r2, r6
 800e6b6:	bf0c      	ite	eq
 800e6b8:	2300      	moveq	r3, #0
 800e6ba:	f003 0301 	andne.w	r3, r3, #1
 800e6be:	4282      	cmp	r2, r0
 800e6c0:	bf0c      	ite	eq
 800e6c2:	2300      	moveq	r3, #0
 800e6c4:	f003 0301 	andne.w	r3, r3, #1
 800e6c8:	428a      	cmp	r2, r1
 800e6ca:	bf0c      	ite	eq
 800e6cc:	2300      	moveq	r3, #0
 800e6ce:	f003 0301 	andne.w	r3, r3, #1
 800e6d2:	b133      	cbz	r3, 800e6e2 <HAL_TIM_ConfigClockSource+0x41a>
 800e6d4:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e6d8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e6dc:	429a      	cmp	r2, r3
 800e6de:	f040 80e7 	bne.w	800e8b0 <HAL_TIM_ConfigClockSource+0x5e8>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800e6e2:	68ab      	ldr	r3, [r5, #8]
 800e6e4:	f433 5340 	bics.w	r3, r3, #12288	; 0x3000
 800e6e8:	f040 8182 	bne.w	800e9f0 <HAL_TIM_ConfigClockSource+0x728>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e6ec:	686b      	ldr	r3, [r5, #4]
 800e6ee:	2b0a      	cmp	r3, #10
 800e6f0:	bf18      	it	ne
 800e6f2:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800e6f6:	d003      	beq.n	800e700 <HAL_TIM_ConfigClockSource+0x438>
 800e6f8:	f033 0302 	bics.w	r3, r3, #2
 800e6fc:	f040 80fc 	bne.w	800e8f8 <HAL_TIM_ConfigClockSource+0x630>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e700:	68e9      	ldr	r1, [r5, #12]
 800e702:	290f      	cmp	r1, #15
 800e704:	f200 814d 	bhi.w	800e9a2 <HAL_TIM_ConfigClockSource+0x6da>
      TIM_ETR_SetConfig(htim->Instance,
 800e708:	6820      	ldr	r0, [r4, #0]
 800e70a:	68ab      	ldr	r3, [r5, #8]
  tmpsmcr = TIMx->SMCR;
 800e70c:	6882      	ldr	r2, [r0, #8]
 800e70e:	686d      	ldr	r5, [r5, #4]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 800e710:	f422 427f 	bic.w	r2, r2, #65280	; 0xff00
 800e714:	432b      	orrs	r3, r5
 800e716:	4313      	orrs	r3, r2
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 800e718:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
  TIMx->SMCR = tmpsmcr;
 800e71c:	6083      	str	r3, [r0, #8]
      tmpsmcr = htim->Instance->SMCR;
 800e71e:	6822      	ldr	r2, [r4, #0]
 800e720:	6893      	ldr	r3, [r2, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 800e722:	f043 0377 	orr.w	r3, r3, #119	; 0x77
      htim->Instance->SMCR = tmpsmcr;
 800e726:	6093      	str	r3, [r2, #8]
      break;
 800e728:	e6ef      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e72a:	2300      	movs	r3, #0
 800e72c:	6822      	ldr	r2, [r4, #0]
 800e72e:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800e732:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800e736:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e73a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800e73e:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e742:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800e746:	429a      	cmp	r2, r3
 800e748:	bf18      	it	ne
 800e74a:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800e74e:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e752:	bf14      	ite	ne
 800e754:	2301      	movne	r3, #1
 800e756:	2300      	moveq	r3, #0
 800e758:	42b2      	cmp	r2, r6
 800e75a:	bf0c      	ite	eq
 800e75c:	2300      	moveq	r3, #0
 800e75e:	f003 0301 	andne.w	r3, r3, #1
 800e762:	428a      	cmp	r2, r1
 800e764:	bf0c      	ite	eq
 800e766:	2300      	moveq	r3, #0
 800e768:	f003 0301 	andne.w	r3, r3, #1
 800e76c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800e770:	4282      	cmp	r2, r0
 800e772:	bf0c      	ite	eq
 800e774:	2300      	moveq	r3, #0
 800e776:	f003 0301 	andne.w	r3, r3, #1
 800e77a:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800e77e:	428a      	cmp	r2, r1
 800e780:	bf0c      	ite	eq
 800e782:	2300      	moveq	r3, #0
 800e784:	f003 0301 	andne.w	r3, r3, #1
 800e788:	b133      	cbz	r3, 800e798 <HAL_TIM_ConfigClockSource+0x4d0>
 800e78a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800e78e:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800e792:	429a      	cmp	r2, r3
 800e794:	f040 80cb 	bne.w	800e92e <HAL_TIM_ConfigClockSource+0x666>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e798:	686b      	ldr	r3, [r5, #4]
 800e79a:	2b0a      	cmp	r3, #10
 800e79c:	bf18      	it	ne
 800e79e:	f5b3 4f00 	cmpne.w	r3, #32768	; 0x8000
 800e7a2:	d003      	beq.n	800e7ac <HAL_TIM_ConfigClockSource+0x4e4>
 800e7a4:	f033 0302 	bics.w	r3, r3, #2
 800e7a8:	f040 80b8 	bne.w	800e91c <HAL_TIM_ConfigClockSource+0x654>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e7ac:	68ef      	ldr	r7, [r5, #12]
 800e7ae:	2f0f      	cmp	r7, #15
 800e7b0:	f200 80ed 	bhi.w	800e98e <HAL_TIM_ConfigClockSource+0x6c6>
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e7b4:	6822      	ldr	r2, [r4, #0]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e7b6:	f64f 738f 	movw	r3, #65423	; 0xff8f
      TIM_TI1_ConfigInputStage(htim->Instance,
 800e7ba:	6868      	ldr	r0, [r5, #4]
  tmpccer = TIMx->CCER;
 800e7bc:	6a16      	ldr	r6, [r2, #32]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e7be:	f6cf 73cf 	movt	r3, #65487	; 0xffcf
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e7c2:	6a15      	ldr	r5, [r2, #32]
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 800e7c4:	f026 060a 	bic.w	r6, r6, #10
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e7c8:	f025 0501 	bic.w	r5, r5, #1
  tmpccer |= TIM_ICPolarity;
 800e7cc:	4330      	orrs	r0, r6
  TIMx->CCER &= ~TIM_CCER_CC1E;
 800e7ce:	6215      	str	r5, [r2, #32]
  tmpccmr1 = TIMx->CCMR1;
 800e7d0:	6991      	ldr	r1, [r2, #24]
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 800e7d2:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  tmpccmr1 |= (TIM_ICFilter << 4U);
 800e7d6:	ea41 1107 	orr.w	r1, r1, r7, lsl #4
  TIMx->CCMR1 = tmpccmr1;
 800e7da:	6191      	str	r1, [r2, #24]
  TIMx->CCER = tmpccer;
 800e7dc:	6210      	str	r0, [r2, #32]
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 800e7de:	6822      	ldr	r2, [r4, #0]
  tmpsmcr = TIMx->SMCR;
 800e7e0:	6891      	ldr	r1, [r2, #8]
  tmpsmcr &= ~TIM_SMCR_TS;
 800e7e2:	400b      	ands	r3, r1
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800e7e4:	f043 0357 	orr.w	r3, r3, #87	; 0x57
  TIMx->SMCR = tmpsmcr;
 800e7e8:	6093      	str	r3, [r2, #8]
 800e7ea:	e68e      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
 800e7ec:	2b10      	cmp	r3, #16
 800e7ee:	d004      	beq.n	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e7f0:	2b20      	cmp	r3, #32
 800e7f2:	d002      	beq.n	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e7f4:	2b00      	cmp	r3, #0
 800e7f6:	f47f ae88 	bne.w	800e50a <HAL_TIM_ConfigClockSource+0x242>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800e7fa:	2200      	movs	r2, #0
 800e7fc:	6821      	ldr	r1, [r4, #0]
 800e7fe:	f44f 6780 	mov.w	r7, #1024	; 0x400
 800e802:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800e806:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800e80a:	f44f 6640 	mov.w	r6, #3072	; 0xc00
 800e80e:	f2c4 0700 	movt	r7, #16384	; 0x4000
 800e812:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800e816:	4291      	cmp	r1, r2
 800e818:	bf18      	it	ne
 800e81a:	f1b1 4f80 	cmpne.w	r1, #1073741824	; 0x40000000
 800e81e:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800e822:	bf14      	ite	ne
 800e824:	2201      	movne	r2, #1
 800e826:	2200      	moveq	r2, #0
 800e828:	42b9      	cmp	r1, r7
 800e82a:	bf0c      	ite	eq
 800e82c:	2200      	moveq	r2, #0
 800e82e:	f002 0201 	andne.w	r2, r2, #1
 800e832:	4281      	cmp	r1, r0
 800e834:	bf0c      	ite	eq
 800e836:	2200      	moveq	r2, #0
 800e838:	f002 0201 	andne.w	r2, r2, #1
 800e83c:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800e840:	42b1      	cmp	r1, r6
 800e842:	bf0c      	ite	eq
 800e844:	2200      	moveq	r2, #0
 800e846:	f002 0201 	andne.w	r2, r2, #1
 800e84a:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800e84e:	4281      	cmp	r1, r0
 800e850:	bf0c      	ite	eq
 800e852:	2200      	moveq	r2, #0
 800e854:	f002 0201 	andne.w	r2, r2, #1
 800e858:	b12a      	cbz	r2, 800e866 <HAL_TIM_ConfigClockSource+0x59e>
 800e85a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800e85e:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800e862:	4291      	cmp	r1, r2
 800e864:	d16c      	bne.n	800e940 <HAL_TIM_ConfigClockSource+0x678>
  tmpsmcr &= ~TIM_SMCR_TS;
 800e866:	f64f 728f 	movw	r2, #65423	; 0xff8f
  tmpsmcr = TIMx->SMCR;
 800e86a:	6888      	ldr	r0, [r1, #8]
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800e86c:	f043 0307 	orr.w	r3, r3, #7
  tmpsmcr &= ~TIM_SMCR_TS;
 800e870:	f6cf 72cf 	movt	r2, #65487	; 0xffcf
 800e874:	4002      	ands	r2, r0
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 800e876:	4313      	orrs	r3, r2
  TIMx->SMCR = tmpsmcr;
 800e878:	608b      	str	r3, [r1, #8]
 800e87a:	e646      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>
  switch (sClockSourceConfig->ClockSource)
 800e87c:	2230      	movs	r2, #48	; 0x30
 800e87e:	f2c0 0210 	movt	r2, #16
 800e882:	4293      	cmp	r3, r2
 800e884:	d0b9      	beq.n	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e886:	2240      	movs	r2, #64	; 0x40
 800e888:	f2c0 0210 	movt	r2, #16
 800e88c:	4293      	cmp	r3, r2
 800e88e:	d0b4      	beq.n	800e7fa <HAL_TIM_ConfigClockSource+0x532>
 800e890:	2220      	movs	r2, #32
 800e892:	f2c0 0210 	movt	r2, #16
 800e896:	4293      	cmp	r3, r2
 800e898:	f47f ae37 	bne.w	800e50a <HAL_TIM_ConfigClockSource+0x242>
 800e89c:	e7ad      	b.n	800e7fa <HAL_TIM_ConfigClockSource+0x532>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
 800e89e:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8a2:	f241 21ab 	movw	r1, #4779	; 0x12ab
 800e8a6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e8aa:	f006 ffdd 	bl	8015868 <assert_failed>
 800e8ae:	e6c4      	b.n	800e63a <HAL_TIM_ConfigClockSource+0x372>
      assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
 800e8b0:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8b4:	f241 2193 	movw	r1, #4755	; 0x1293
 800e8b8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e8bc:	f006 ffd4 	bl	8015868 <assert_failed>
 800e8c0:	e70f      	b.n	800e6e2 <HAL_TIM_ConfigClockSource+0x41a>
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
 800e8c2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8c6:	f44f 5194 	mov.w	r1, #4736	; 0x1280
 800e8ca:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e8ce:	f006 ffcb 	bl	8015868 <assert_failed>
 800e8d2:	e518      	b.n	800e306 <HAL_TIM_ConfigClockSource+0x3e>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e8d4:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8d8:	f241 21e2 	movw	r1, #4834	; 0x12e2
 800e8dc:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e8e0:	f006 ffc2 	bl	8015868 <assert_failed>
 800e8e4:	e56a      	b.n	800e3bc <HAL_TIM_ConfigClockSource+0xf4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e8e6:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8ea:	f241 21d2 	movw	r1, #4818	; 0x12d2
 800e8ee:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e8f2:	f006 ffb9 	bl	8015868 <assert_failed>
 800e8f6:	e651      	b.n	800e59c <HAL_TIM_ConfigClockSource+0x2d4>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e8f8:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e8fc:	f241 2197 	movw	r1, #4759	; 0x1297
 800e900:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e904:	f006 ffb0 	bl	8015868 <assert_failed>
 800e908:	e6fa      	b.n	800e700 <HAL_TIM_ConfigClockSource+0x438>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e90a:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e90e:	f241 21af 	movw	r1, #4783	; 0x12af
 800e912:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e916:	f006 ffa7 	bl	8015868 <assert_failed>
 800e91a:	e69d      	b.n	800e658 <HAL_TIM_ConfigClockSource+0x390>
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
 800e91c:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e920:	f241 21c2 	movw	r1, #4802	; 0x12c2
 800e924:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e928:	f006 ff9e 	bl	8015868 <assert_failed>
 800e92c:	e73e      	b.n	800e7ac <HAL_TIM_ConfigClockSource+0x4e4>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e92e:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e932:	f241 21bf 	movw	r1, #4799	; 0x12bf
 800e936:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e93a:	f006 ff95 	bl	8015868 <assert_failed>
 800e93e:	e72b      	b.n	800e798 <HAL_TIM_ConfigClockSource+0x4d0>
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
 800e940:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e944:	f241 21f7 	movw	r1, #4855	; 0x12f7
 800e948:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e94c:	f006 ff8c 	bl	8015868 <assert_failed>
 800e950:	682b      	ldr	r3, [r5, #0]
 800e952:	6821      	ldr	r1, [r4, #0]
 800e954:	e787      	b.n	800e866 <HAL_TIM_ConfigClockSource+0x59e>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e956:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e95a:	f241 21cf 	movw	r1, #4815	; 0x12cf
 800e95e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e962:	f006 ff81 	bl	8015868 <assert_failed>
 800e966:	e60f      	b.n	800e588 <HAL_TIM_ConfigClockSource+0x2c0>
      assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
 800e968:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e96c:	f241 21df 	movw	r1, #4831	; 0x12df
 800e970:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e974:	f006 ff78 	bl	8015868 <assert_failed>
 800e978:	e516      	b.n	800e3a8 <HAL_TIM_ConfigClockSource+0xe0>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e97a:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e97e:	f241 21b0 	movw	r1, #4784	; 0x12b0
 800e982:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e986:	f006 ff6f 	bl	8015868 <assert_failed>
 800e98a:	68e9      	ldr	r1, [r5, #12]
 800e98c:	e668      	b.n	800e660 <HAL_TIM_ConfigClockSource+0x398>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e98e:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e992:	f241 21c3 	movw	r1, #4803	; 0x12c3
 800e996:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e99a:	f006 ff65 	bl	8015868 <assert_failed>
 800e99e:	68ef      	ldr	r7, [r5, #12]
 800e9a0:	e708      	b.n	800e7b4 <HAL_TIM_ConfigClockSource+0x4ec>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e9a2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e9a6:	f241 2198 	movw	r1, #4760	; 0x1298
 800e9aa:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e9ae:	f006 ff5b 	bl	8015868 <assert_failed>
 800e9b2:	68e9      	ldr	r1, [r5, #12]
 800e9b4:	e6a8      	b.n	800e708 <HAL_TIM_ConfigClockSource+0x440>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e9b6:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e9ba:	f241 21d3 	movw	r1, #4819	; 0x12d3
 800e9be:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e9c2:	f006 ff51 	bl	8015868 <assert_failed>
 800e9c6:	68ee      	ldr	r6, [r5, #12]
 800e9c8:	e5ec      	b.n	800e5a4 <HAL_TIM_ConfigClockSource+0x2dc>
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
 800e9ca:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e9ce:	f241 21e3 	movw	r1, #4835	; 0x12e3
 800e9d2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e9d6:	f006 ff47 	bl	8015868 <assert_failed>
 800e9da:	68ef      	ldr	r7, [r5, #12]
 800e9dc:	e4f2      	b.n	800e3c4 <HAL_TIM_ConfigClockSource+0xfc>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800e9de:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e9e2:	f241 21ae 	movw	r1, #4782	; 0x12ae
 800e9e6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e9ea:	f006 ff3d 	bl	8015868 <assert_failed>
 800e9ee:	e629      	b.n	800e644 <HAL_TIM_ConfigClockSource+0x37c>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
 800e9f0:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800e9f4:	f241 2196 	movw	r1, #4758	; 0x1296
 800e9f8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800e9fc:	f006 ff34 	bl	8015868 <assert_failed>
 800ea00:	e674      	b.n	800e6ec <HAL_TIM_ConfigClockSource+0x424>
      assert_param(IS_TIM_INSTANCE(htim->Instance));
 800ea02:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ea06:	f241 218c 	movw	r1, #4748	; 0x128c
 800ea0a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ea0e:	f006 ff2b 	bl	8015868 <assert_failed>
 800ea12:	e57a      	b.n	800e50a <HAL_TIM_ConfigClockSource+0x242>

0800ea14 <TIM_OC2_SetConfig>:
{
 800ea14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ea18:	6a02      	ldr	r2, [r0, #32]
{
 800ea1a:	460f      	mov	r7, r1
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800ea1c:	f648 43ff 	movw	r3, #36095	; 0x8cff
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800ea20:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ea22:	f022 0210 	bic.w	r2, r2, #16
{
 800ea26:	4604      	mov	r4, r0
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800ea28:	f6cf 63ff 	movt	r3, #65279	; 0xfeff
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800ea2c:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC2E;
 800ea30:	6202      	str	r2, [r0, #32]
  tmpccer = TIMx->CCER;
 800ea32:	6a05      	ldr	r5, [r0, #32]
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800ea34:	428c      	cmp	r4, r1
  tmpcr2 =  TIMx->CR2;
 800ea36:	f8d0 8004 	ldr.w	r8, [r0, #4]
  tmpccmrx = TIMx->CCMR1;
 800ea3a:	6980      	ldr	r0, [r0, #24]
  tmpccer &= ~TIM_CCER_CC2P;
 800ea3c:	f025 0520 	bic.w	r5, r5, #32
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800ea40:	68ba      	ldr	r2, [r7, #8]
  tmpccmrx &= ~TIM_CCMR1_CC2S;
 800ea42:	ea03 0300 	and.w	r3, r3, r0
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800ea46:	683e      	ldr	r6, [r7, #0]
  tmpccer |= (OC_Config->OCPolarity << 4U);
 800ea48:	ea45 1502 	orr.w	r5, r5, r2, lsl #4
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800ea4c:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
  if (IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
 800ea50:	d02e      	beq.n	800eab0 <TIM_OC2_SetConfig+0x9c>
 800ea52:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ea56:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ea5a:	429c      	cmp	r4, r3
 800ea5c:	d028      	beq.n	800eab0 <TIM_OC2_SetConfig+0x9c>
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ea5e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800ea62:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800ea66:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800ea6a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ea6e:	429c      	cmp	r4, r3
 800ea70:	bf18      	it	ne
 800ea72:	4294      	cmpne	r4, r2
 800ea74:	d005      	beq.n	800ea82 <TIM_OC2_SetConfig+0x6e>
 800ea76:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800ea7a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ea7e:	429c      	cmp	r4, r3
 800ea80:	d10e      	bne.n	800eaa0 <TIM_OC2_SetConfig+0x8c>
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800ea82:	69bb      	ldr	r3, [r7, #24]
 800ea84:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800ea88:	d120      	bne.n	800eacc <TIM_OC2_SetConfig+0xb8>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800ea8a:	697b      	ldr	r3, [r7, #20]
 800ea8c:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800ea90:	d128      	bne.n	800eae4 <TIM_OC2_SetConfig+0xd0>
    tmpcr2 &= ~TIM_CR2_OIS2N;
 800ea92:	f428 6840 	bic.w	r8, r8, #3072	; 0xc00
    tmpcr2 |= (OC_Config->OCNIdleState << 2U);
 800ea96:	69ba      	ldr	r2, [r7, #24]
 800ea98:	ea48 0882 	orr.w	r8, r8, r2, lsl #2
 800ea9c:	ea48 0883 	orr.w	r8, r8, r3, lsl #2
  TIMx->CR2 = tmpcr2;
 800eaa0:	f8c4 8004 	str.w	r8, [r4, #4]
  TIMx->CCMR1 = tmpccmrx;
 800eaa4:	61a6      	str	r6, [r4, #24]
  TIMx->CCR2 = OC_Config->Pulse;
 800eaa6:	687b      	ldr	r3, [r7, #4]
 800eaa8:	63a3      	str	r3, [r4, #56]	; 0x38
  TIMx->CCER = tmpccer;
 800eaaa:	6225      	str	r5, [r4, #32]
}
 800eaac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800eab0:	68fb      	ldr	r3, [r7, #12]
 800eab2:	f033 0208 	bics.w	r2, r3, #8
 800eab6:	d11f      	bne.n	800eaf8 <TIM_OC2_SetConfig+0xe4>
    tmpccer &= ~TIM_CCER_CC2NP;
 800eab8:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800eabc:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800eac0:	f025 0540 	bic.w	r5, r5, #64	; 0x40
    assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
 800eac4:	69bb      	ldr	r3, [r7, #24]
 800eac6:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800eaca:	d0de      	beq.n	800ea8a <TIM_OC2_SetConfig+0x76>
 800eacc:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ead0:	f641 015f 	movw	r1, #6239	; 0x185f
 800ead4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ead8:	f006 fec6 	bl	8015868 <assert_failed>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800eadc:	697b      	ldr	r3, [r7, #20]
 800eade:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800eae2:	d0d6      	beq.n	800ea92 <TIM_OC2_SetConfig+0x7e>
 800eae4:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800eae8:	f44f 51c3 	mov.w	r1, #6240	; 0x1860
 800eaec:	f6c0 0002 	movt	r0, #2050	; 0x802
 800eaf0:	f006 feba 	bl	8015868 <assert_failed>
 800eaf4:	697b      	ldr	r3, [r7, #20]
 800eaf6:	e7cc      	b.n	800ea92 <TIM_OC2_SetConfig+0x7e>
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800eaf8:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800eafc:	f641 0151 	movw	r1, #6225	; 0x1851
    tmpccer &= ~TIM_CCER_CC2NP;
 800eb00:	f025 0580 	bic.w	r5, r5, #128	; 0x80
    assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
 800eb04:	f6c0 0002 	movt	r0, #2050	; 0x802
 800eb08:	f006 feae 	bl	8015868 <assert_failed>
 800eb0c:	68fb      	ldr	r3, [r7, #12]
    tmpccer |= (OC_Config->OCNPolarity << 4U);
 800eb0e:	ea45 1503 	orr.w	r5, r5, r3, lsl #4
    tmpccer &= ~TIM_CCER_CC2NE;
 800eb12:	f025 0540 	bic.w	r5, r5, #64	; 0x40
 800eb16:	e7d5      	b.n	800eac4 <TIM_OC2_SetConfig+0xb0>

0800eb18 <HAL_TIM_PWM_ConfigChannel>:
  assert_param(IS_TIM_CHANNELS(Channel));
 800eb18:	2a14      	cmp	r2, #20
{
 800eb1a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800eb1e:	4616      	mov	r6, r2
 800eb20:	4604      	mov	r4, r0
 800eb22:	460d      	mov	r5, r1
  assert_param(IS_TIM_CHANNELS(Channel));
 800eb24:	f240 80c1 	bls.w	800ecaa <HAL_TIM_PWM_ConfigChannel+0x192>
 800eb28:	2a3c      	cmp	r2, #60	; 0x3c
 800eb2a:	f040 80c6 	bne.w	800ecba <HAL_TIM_PWM_ConfigChannel+0x1a2>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 800eb2e:	682a      	ldr	r2, [r5, #0]
 800eb30:	2340      	movs	r3, #64	; 0x40
 800eb32:	f022 0110 	bic.w	r1, r2, #16
 800eb36:	f2c0 0301 	movt	r3, #1
 800eb3a:	4299      	cmp	r1, r3
 800eb3c:	d007      	beq.n	800eb4e <HAL_TIM_PWM_ConfigChannel+0x36>
 800eb3e:	f64f 73ef 	movw	r3, #65519	; 0xffef
 800eb42:	f6cf 73fe 	movt	r3, #65534	; 0xfffe
 800eb46:	4013      	ands	r3, r2
 800eb48:	2b60      	cmp	r3, #96	; 0x60
 800eb4a:	f040 829d 	bne.w	800f088 <HAL_TIM_PWM_ConfigChannel+0x570>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800eb4e:	68ab      	ldr	r3, [r5, #8]
 800eb50:	f033 0302 	bics.w	r3, r3, #2
 800eb54:	f040 80ba 	bne.w	800eccc <HAL_TIM_PWM_ConfigChannel+0x1b4>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 800eb58:	692b      	ldr	r3, [r5, #16]
 800eb5a:	f033 0304 	bics.w	r3, r3, #4
 800eb5e:	f040 80c2 	bne.w	800ece6 <HAL_TIM_PWM_ConfigChannel+0x1ce>
  __HAL_LOCK(htim);
 800eb62:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800eb66:	2b01      	cmp	r3, #1
 800eb68:	f000 80ca 	beq.w	800ed00 <HAL_TIM_PWM_ConfigChannel+0x1e8>
 800eb6c:	2201      	movs	r2, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800eb6e:	2302      	movs	r3, #2
  __HAL_LOCK(htim);
 800eb70:	f884 203c 	strb.w	r2, [r4, #60]	; 0x3c
  htim->State = HAL_TIM_STATE_BUSY;
 800eb74:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  switch (Channel)
 800eb78:	2e14      	cmp	r6, #20
 800eb7a:	f200 808d 	bhi.w	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
 800eb7e:	e8df f016 	tbh	[pc, r6, lsl #1]
 800eb82:	0015      	.short	0x0015
 800eb84:	008b008b 	.word	0x008b008b
 800eb88:	00c2008b 	.word	0x00c2008b
 800eb8c:	008b008b 	.word	0x008b008b
 800eb90:	0116008b 	.word	0x0116008b
 800eb94:	008b008b 	.word	0x008b008b
 800eb98:	0157008b 	.word	0x0157008b
 800eb9c:	008b008b 	.word	0x008b008b
 800eba0:	01d5008b 	.word	0x01d5008b
 800eba4:	008b008b 	.word	0x008b008b
 800eba8:	022c008b 	.word	0x022c008b
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 800ebac:	2300      	movs	r3, #0
 800ebae:	6820      	ldr	r0, [r4, #0]
 800ebb0:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800ebb4:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800ebb8:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ebbc:	f44f 6140 	mov.w	r1, #3072	; 0xc00
 800ebc0:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800ebc4:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ebc8:	4298      	cmp	r0, r3
 800ebca:	bf18      	it	ne
 800ebcc:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800ebd0:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800ebd4:	bf14      	ite	ne
 800ebd6:	2301      	movne	r3, #1
 800ebd8:	2300      	moveq	r3, #0
 800ebda:	42b0      	cmp	r0, r6
 800ebdc:	bf0c      	ite	eq
 800ebde:	2300      	moveq	r3, #0
 800ebe0:	f003 0301 	andne.w	r3, r3, #1
 800ebe4:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
 800ebe8:	4290      	cmp	r0, r2
 800ebea:	bf0c      	ite	eq
 800ebec:	2300      	moveq	r3, #0
 800ebee:	f003 0301 	andne.w	r3, r3, #1
 800ebf2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ebf6:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800ebfa:	4288      	cmp	r0, r1
 800ebfc:	bf0c      	ite	eq
 800ebfe:	2300      	moveq	r3, #0
 800ec00:	f003 0301 	andne.w	r3, r3, #1
 800ec04:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800ec08:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
 800ec0c:	4290      	cmp	r0, r2
 800ec0e:	bf0c      	ite	eq
 800ec10:	2300      	moveq	r3, #0
 800ec12:	f003 0301 	andne.w	r3, r3, #1
 800ec16:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800ec1a:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800ec1e:	42b0      	cmp	r0, r6
 800ec20:	bf0c      	ite	eq
 800ec22:	2300      	moveq	r3, #0
 800ec24:	f003 0301 	andne.w	r3, r3, #1
 800ec28:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ec2c:	4288      	cmp	r0, r1
 800ec2e:	bf0c      	ite	eq
 800ec30:	2300      	moveq	r3, #0
 800ec32:	f003 0301 	andne.w	r3, r3, #1
 800ec36:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800ec3a:	4290      	cmp	r0, r2
 800ec3c:	bf0c      	ite	eq
 800ec3e:	2300      	moveq	r3, #0
 800ec40:	f003 0301 	andne.w	r3, r3, #1
 800ec44:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800ec48:	f44f 4288 	mov.w	r2, #17408	; 0x4400
 800ec4c:	4288      	cmp	r0, r1
 800ec4e:	bf0c      	ite	eq
 800ec50:	2300      	moveq	r3, #0
 800ec52:	f003 0301 	andne.w	r3, r3, #1
 800ec56:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800ec5a:	4290      	cmp	r0, r2
 800ec5c:	bf0c      	ite	eq
 800ec5e:	2300      	moveq	r3, #0
 800ec60:	f003 0301 	andne.w	r3, r3, #1
 800ec64:	b133      	cbz	r3, 800ec74 <HAL_TIM_PWM_ConfigChannel+0x15c>
 800ec66:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800ec6a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ec6e:	4298      	cmp	r0, r3
 800ec70:	f040 824f 	bne.w	800f112 <HAL_TIM_PWM_ConfigChannel+0x5fa>
      TIM_OC1_SetConfig(htim->Instance, sConfig);
 800ec74:	4629      	mov	r1, r5
 800ec76:	f7fe fe41 	bl	800d8fc <TIM_OC1_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
 800ec7a:	6822      	ldr	r2, [r4, #0]
 800ec7c:	6993      	ldr	r3, [r2, #24]
 800ec7e:	f043 0308 	orr.w	r3, r3, #8
 800ec82:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
 800ec84:	6822      	ldr	r2, [r4, #0]
 800ec86:	6993      	ldr	r3, [r2, #24]
 800ec88:	f023 0304 	bic.w	r3, r3, #4
 800ec8c:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode;
 800ec8e:	6822      	ldr	r2, [r4, #0]
 800ec90:	6929      	ldr	r1, [r5, #16]
 800ec92:	6993      	ldr	r3, [r2, #24]
 800ec94:	430b      	orrs	r3, r1
 800ec96:	6193      	str	r3, [r2, #24]
  __HAL_UNLOCK(htim);
 800ec98:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800ec9a:	2201      	movs	r2, #1
  return HAL_OK;
 800ec9c:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800ec9e:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800eca2:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800eca6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  assert_param(IS_TIM_CHANNELS(Channel));
 800ecaa:	f241 1311 	movw	r3, #4369	; 0x1111
 800ecae:	f2c0 0311 	movt	r3, #17
 800ecb2:	40d3      	lsrs	r3, r2
 800ecb4:	07db      	lsls	r3, r3, #31
 800ecb6:	f53f af3a 	bmi.w	800eb2e <HAL_TIM_PWM_ConfigChannel+0x16>
 800ecba:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ecbe:	f640 611c 	movw	r1, #3612	; 0xe1c
 800ecc2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ecc6:	f006 fdcf 	bl	8015868 <assert_failed>
 800ecca:	e730      	b.n	800eb2e <HAL_TIM_PWM_ConfigChannel+0x16>
  assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
 800eccc:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ecd0:	f640 611e 	movw	r1, #3614	; 0xe1e
 800ecd4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ecd8:	f006 fdc6 	bl	8015868 <assert_failed>
  assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
 800ecdc:	692b      	ldr	r3, [r5, #16]
 800ecde:	f033 0304 	bics.w	r3, r3, #4
 800ece2:	f43f af3e 	beq.w	800eb62 <HAL_TIM_PWM_ConfigChannel+0x4a>
 800ece6:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800ecea:	f640 611f 	movw	r1, #3615	; 0xe1f
 800ecee:	f6c0 0002 	movt	r0, #2050	; 0x802
 800ecf2:	f006 fdb9 	bl	8015868 <assert_failed>
  __HAL_LOCK(htim);
 800ecf6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800ecfa:	2b01      	cmp	r3, #1
 800ecfc:	f47f af36 	bne.w	800eb6c <HAL_TIM_PWM_ConfigChannel+0x54>
 800ed00:	2002      	movs	r0, #2
}
 800ed02:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 800ed06:	2300      	movs	r3, #0
 800ed08:	6820      	ldr	r0, [r4, #0]
 800ed0a:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800ed0e:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800ed12:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ed16:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 800ed1a:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800ed1e:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800ed22:	4298      	cmp	r0, r3
 800ed24:	bf18      	it	ne
 800ed26:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800ed2a:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ed2e:	bf14      	ite	ne
 800ed30:	2301      	movne	r3, #1
 800ed32:	2300      	moveq	r3, #0
 800ed34:	42b0      	cmp	r0, r6
 800ed36:	bf0c      	ite	eq
 800ed38:	2300      	moveq	r3, #0
 800ed3a:	f003 0301 	andne.w	r3, r3, #1
 800ed3e:	4288      	cmp	r0, r1
 800ed40:	bf0c      	ite	eq
 800ed42:	2300      	moveq	r3, #0
 800ed44:	f003 0301 	andne.w	r3, r3, #1
 800ed48:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800ed4c:	4290      	cmp	r0, r2
 800ed4e:	bf0c      	ite	eq
 800ed50:	2300      	moveq	r3, #0
 800ed52:	f003 0301 	andne.w	r3, r3, #1
 800ed56:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800ed5a:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
 800ed5e:	4288      	cmp	r0, r1
 800ed60:	bf0c      	ite	eq
 800ed62:	2300      	moveq	r3, #0
 800ed64:	f003 0301 	andne.w	r3, r3, #1
 800ed68:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ed6c:	4290      	cmp	r0, r2
 800ed6e:	bf0c      	ite	eq
 800ed70:	2300      	moveq	r3, #0
 800ed72:	f003 0301 	andne.w	r3, r3, #1
 800ed76:	b133      	cbz	r3, 800ed86 <HAL_TIM_PWM_ConfigChannel+0x26e>
 800ed78:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800ed7c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ed80:	4298      	cmp	r0, r3
 800ed82:	f040 81bc 	bne.w	800f0fe <HAL_TIM_PWM_ConfigChannel+0x5e6>
      TIM_OC2_SetConfig(htim->Instance, sConfig);
 800ed86:	4629      	mov	r1, r5
 800ed88:	f7ff fe44 	bl	800ea14 <TIM_OC2_SetConfig>
      htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
 800ed8c:	6822      	ldr	r2, [r4, #0]
 800ed8e:	6993      	ldr	r3, [r2, #24]
 800ed90:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800ed94:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
 800ed96:	6822      	ldr	r2, [r4, #0]
 800ed98:	6993      	ldr	r3, [r2, #24]
 800ed9a:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ed9e:	6193      	str	r3, [r2, #24]
      htim->Instance->CCMR1 |= sConfig->OCFastMode << 8U;
 800eda0:	6822      	ldr	r2, [r4, #0]
 800eda2:	6929      	ldr	r1, [r5, #16]
 800eda4:	6993      	ldr	r3, [r2, #24]
 800eda6:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800edaa:	6193      	str	r3, [r2, #24]
      break;
 800edac:	e774      	b.n	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 800edae:	2300      	movs	r3, #0
 800edb0:	6820      	ldr	r0, [r4, #0]
 800edb2:	f44f 6680 	mov.w	r6, #1024	; 0x400
 800edb6:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800edba:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800edbe:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 800edc2:	f2c4 0600 	movt	r6, #16384	; 0x4000
 800edc6:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800edca:	4298      	cmp	r0, r3
 800edcc:	bf18      	it	ne
 800edce:	f1b0 4f80 	cmpne.w	r0, #1073741824	; 0x40000000
 800edd2:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800edd6:	bf14      	ite	ne
 800edd8:	2301      	movne	r3, #1
 800edda:	2300      	moveq	r3, #0
 800eddc:	42b0      	cmp	r0, r6
 800edde:	bf0c      	ite	eq
 800ede0:	2300      	moveq	r3, #0
 800ede2:	f003 0301 	andne.w	r3, r3, #1
 800ede6:	4288      	cmp	r0, r1
 800ede8:	bf0c      	ite	eq
 800edea:	2300      	moveq	r3, #0
 800edec:	f003 0301 	andne.w	r3, r3, #1
 800edf0:	4290      	cmp	r0, r2
 800edf2:	bf0c      	ite	eq
 800edf4:	2300      	moveq	r3, #0
 800edf6:	f003 0301 	andne.w	r3, r3, #1
 800edfa:	b133      	cbz	r3, 800ee0a <HAL_TIM_PWM_ConfigChannel+0x2f2>
 800edfc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ee00:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ee04:	4298      	cmp	r0, r3
 800ee06:	f040 8170 	bne.w	800f0ea <HAL_TIM_PWM_ConfigChannel+0x5d2>
      TIM_OC3_SetConfig(htim->Instance, sConfig);
 800ee0a:	4629      	mov	r1, r5
 800ee0c:	f7fe fe16 	bl	800da3c <TIM_OC3_SetConfig>
      htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
 800ee10:	6822      	ldr	r2, [r4, #0]
 800ee12:	69d3      	ldr	r3, [r2, #28]
 800ee14:	f043 0308 	orr.w	r3, r3, #8
 800ee18:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
 800ee1a:	6822      	ldr	r2, [r4, #0]
 800ee1c:	69d3      	ldr	r3, [r2, #28]
 800ee1e:	f023 0304 	bic.w	r3, r3, #4
 800ee22:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode;
 800ee24:	6822      	ldr	r2, [r4, #0]
 800ee26:	6929      	ldr	r1, [r5, #16]
 800ee28:	69d3      	ldr	r3, [r2, #28]
 800ee2a:	430b      	orrs	r3, r1
 800ee2c:	61d3      	str	r3, [r2, #28]
      break;
 800ee2e:	e733      	b.n	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800ee30:	2300      	movs	r3, #0
 800ee32:	6826      	ldr	r6, [r4, #0]
 800ee34:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ee38:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800ee3c:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ee40:	f44f 6240 	mov.w	r2, #3072	; 0xc00
 800ee44:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800ee48:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800ee4c:	429e      	cmp	r6, r3
 800ee4e:	bf18      	it	ne
 800ee50:	f1b6 4f80 	cmpne.w	r6, #1073741824	; 0x40000000
 800ee54:	f2c4 0200 	movt	r2, #16384	; 0x4000
 800ee58:	bf14      	ite	ne
 800ee5a:	2301      	movne	r3, #1
 800ee5c:	2300      	moveq	r3, #0
 800ee5e:	4286      	cmp	r6, r0
 800ee60:	bf0c      	ite	eq
 800ee62:	2300      	moveq	r3, #0
 800ee64:	f003 0301 	andne.w	r3, r3, #1
 800ee68:	428e      	cmp	r6, r1
 800ee6a:	bf0c      	ite	eq
 800ee6c:	2300      	moveq	r3, #0
 800ee6e:	f003 0301 	andne.w	r3, r3, #1
 800ee72:	4296      	cmp	r6, r2
 800ee74:	bf0c      	ite	eq
 800ee76:	2300      	moveq	r3, #0
 800ee78:	f003 0301 	andne.w	r3, r3, #1
 800ee7c:	b133      	cbz	r3, 800ee8c <HAL_TIM_PWM_ConfigChannel+0x374>
 800ee7e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ee82:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800ee86:	429e      	cmp	r6, r3
 800ee88:	f040 8125 	bne.w	800f0d6 <HAL_TIM_PWM_ConfigChannel+0x5be>
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800ee8c:	6a33      	ldr	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ee8e:	2100      	movs	r1, #0
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800ee90:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ee94:	f2c4 0101 	movt	r1, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC4E;
 800ee98:	6233      	str	r3, [r6, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ee9a:	428e      	cmp	r6, r1
  tmpccer = TIMx->CCER;
 800ee9c:	6a33      	ldr	r3, [r6, #32]
  tmpcr2 =  TIMx->CR2;
 800ee9e:	f8d6 9004 	ldr.w	r9, [r6, #4]
  tmpccmrx = TIMx->CCMR2;
 800eea2:	69f7      	ldr	r7, [r6, #28]
  tmpccer &= ~TIM_CCER_CC4P;
 800eea4:	f423 5800 	bic.w	r8, r3, #8192	; 0x2000
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800eea8:	68aa      	ldr	r2, [r5, #8]
  tmpccmrx &= ~TIM_CCMR2_CC4S;
 800eeaa:	f427 47e6 	bic.w	r7, r7, #29440	; 0x7300
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800eeae:	682b      	ldr	r3, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 12U);
 800eeb0:	ea48 3802 	orr.w	r8, r8, r2, lsl #12
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800eeb4:	ea47 2703 	orr.w	r7, r7, r3, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800eeb8:	d017      	beq.n	800eeea <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800eeba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800eebe:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800eec2:	429e      	cmp	r6, r3
 800eec4:	d011      	beq.n	800eeea <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800eec6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800eeca:	f44f 4388 	mov.w	r3, #17408	; 0x4400
 800eece:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800eed2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800eed6:	429e      	cmp	r6, r3
 800eed8:	bf18      	it	ne
 800eeda:	4296      	cmpne	r6, r2
 800eedc:	d005      	beq.n	800eeea <HAL_TIM_PWM_ConfigChannel+0x3d2>
 800eede:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 800eee2:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800eee6:	429e      	cmp	r6, r3
 800eee8:	d108      	bne.n	800eefc <HAL_TIM_PWM_ConfigChannel+0x3e4>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800eeea:	696b      	ldr	r3, [r5, #20]
 800eeec:	f433 7280 	bics.w	r2, r3, #256	; 0x100
 800eef0:	f040 80e7 	bne.w	800f0c2 <HAL_TIM_PWM_ConfigChannel+0x5aa>
    tmpcr2 &= ~TIM_CR2_OIS4;
 800eef4:	f429 4980 	bic.w	r9, r9, #16384	; 0x4000
    tmpcr2 |= (OC_Config->OCIdleState << 6U);
 800eef8:	ea49 1983 	orr.w	r9, r9, r3, lsl #6
  TIMx->CR2 = tmpcr2;
 800eefc:	f8c6 9004 	str.w	r9, [r6, #4]
  TIMx->CCMR2 = tmpccmrx;
 800ef00:	61f7      	str	r7, [r6, #28]
  TIMx->CCR4 = OC_Config->Pulse;
 800ef02:	686b      	ldr	r3, [r5, #4]
 800ef04:	6433      	str	r3, [r6, #64]	; 0x40
  TIMx->CCER = tmpccer;
 800ef06:	f8c6 8020 	str.w	r8, [r6, #32]
      htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
 800ef0a:	6822      	ldr	r2, [r4, #0]
 800ef0c:	69d3      	ldr	r3, [r2, #28]
 800ef0e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800ef12:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
 800ef14:	6822      	ldr	r2, [r4, #0]
 800ef16:	69d3      	ldr	r3, [r2, #28]
 800ef18:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800ef1c:	61d3      	str	r3, [r2, #28]
      htim->Instance->CCMR2 |= sConfig->OCFastMode << 8U;
 800ef1e:	6822      	ldr	r2, [r4, #0]
 800ef20:	6929      	ldr	r1, [r5, #16]
 800ef22:	69d3      	ldr	r3, [r2, #28]
 800ef24:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800ef28:	61d3      	str	r3, [r2, #28]
      break;
 800ef2a:	e6b5      	b.n	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
 800ef2c:	2200      	movs	r2, #0
 800ef2e:	6823      	ldr	r3, [r4, #0]
 800ef30:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800ef34:	4293      	cmp	r3, r2
 800ef36:	d006      	beq.n	800ef46 <HAL_TIM_PWM_ConfigChannel+0x42e>
 800ef38:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800ef3c:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800ef40:	4293      	cmp	r3, r2
 800ef42:	f040 80b4 	bne.w	800f0ae <HAL_TIM_PWM_ConfigChannel+0x596>
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800ef46:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ef48:	2700      	movs	r7, #0
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800ef4a:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ef4e:	f2c4 0701 	movt	r7, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC5E;
 800ef52:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ef54:	42bb      	cmp	r3, r7
  tmpccer = TIMx->CCER;
 800ef56:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800ef58:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 800ef5c:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= ~TIM_CCER_CC5P;
 800ef5e:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800ef62:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC5M);
 800ef64:	f021 0170 	bic.w	r1, r1, #112	; 0x70
  tmpccmrx |= OC_Config->OCMode;
 800ef68:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 16U);
 800ef6a:	ea42 4206 	orr.w	r2, r2, r6, lsl #16
  tmpccmrx |= OC_Config->OCMode;
 800ef6e:	ea41 0100 	orr.w	r1, r1, r0
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800ef72:	d017      	beq.n	800efa4 <HAL_TIM_PWM_ConfigChannel+0x48c>
 800ef74:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800ef78:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800ef7c:	4283      	cmp	r3, r0
 800ef7e:	d011      	beq.n	800efa4 <HAL_TIM_PWM_ConfigChannel+0x48c>
 800ef80:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800ef84:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 800ef88:	f2c4 0601 	movt	r6, #16385	; 0x4001
 800ef8c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800ef90:	4283      	cmp	r3, r0
 800ef92:	bf18      	it	ne
 800ef94:	42b3      	cmpne	r3, r6
 800ef96:	d005      	beq.n	800efa4 <HAL_TIM_PWM_ConfigChannel+0x48c>
 800ef98:	f44f 4090 	mov.w	r0, #18432	; 0x4800
 800ef9c:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800efa0:	4283      	cmp	r3, r0
 800efa2:	d104      	bne.n	800efae <HAL_TIM_PWM_ConfigChannel+0x496>
    tmpcr2 &= ~TIM_CR2_OIS5;
 800efa4:	f42c 3c80 	bic.w	ip, ip, #65536	; 0x10000
    tmpcr2 |= (OC_Config->OCIdleState << 8U);
 800efa8:	6968      	ldr	r0, [r5, #20]
 800efaa:	ea4c 2c00 	orr.w	ip, ip, r0, lsl #8
  TIMx->CR2 = tmpcr2;
 800efae:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800efb2:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR5 = OC_Config->Pulse;
 800efb4:	6869      	ldr	r1, [r5, #4]
 800efb6:	6599      	str	r1, [r3, #88]	; 0x58
  TIMx->CCER = tmpccer;
 800efb8:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC5PE;
 800efba:	6822      	ldr	r2, [r4, #0]
 800efbc:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800efbe:	f043 0308 	orr.w	r3, r3, #8
 800efc2:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC5FE;
 800efc4:	6822      	ldr	r2, [r4, #0]
 800efc6:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800efc8:	f023 0304 	bic.w	r3, r3, #4
 800efcc:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode;
 800efce:	6822      	ldr	r2, [r4, #0]
 800efd0:	6929      	ldr	r1, [r5, #16]
 800efd2:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800efd4:	430b      	orrs	r3, r1
 800efd6:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 800efd8:	e65e      	b.n	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
 800efda:	2200      	movs	r2, #0
 800efdc:	6823      	ldr	r3, [r4, #0]
 800efde:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800efe2:	4293      	cmp	r3, r2
 800efe4:	d005      	beq.n	800eff2 <HAL_TIM_PWM_ConfigChannel+0x4da>
 800efe6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800efea:	f2c4 0201 	movt	r2, #16385	; 0x4001
 800efee:	4293      	cmp	r3, r2
 800eff0:	d153      	bne.n	800f09a <HAL_TIM_PWM_ConfigChannel+0x582>
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800eff2:	6a1a      	ldr	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800eff4:	2700      	movs	r7, #0
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800eff6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800effa:	f2c4 0701 	movt	r7, #16385	; 0x4001
  TIMx->CCER &= ~TIM_CCER_CC6E;
 800effe:	621a      	str	r2, [r3, #32]
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800f000:	42bb      	cmp	r3, r7
  tmpccer = TIMx->CCER;
 800f002:	6a1a      	ldr	r2, [r3, #32]
  tmpcr2 =  TIMx->CR2;
 800f004:	f8d3 c004 	ldr.w	ip, [r3, #4]
  tmpccmrx = TIMx->CCMR3;
 800f008:	6d59      	ldr	r1, [r3, #84]	; 0x54
  tmpccer &= (uint32_t)~TIM_CCER_CC6P;
 800f00a:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800f00e:	68ae      	ldr	r6, [r5, #8]
  tmpccmrx &= ~(TIM_CCMR3_OC6M);
 800f010:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800f014:	6828      	ldr	r0, [r5, #0]
  tmpccer |= (OC_Config->OCPolarity << 20U);
 800f016:	ea42 5206 	orr.w	r2, r2, r6, lsl #20
  tmpccmrx |= (OC_Config->OCMode << 8U);
 800f01a:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
  if (IS_TIM_BREAK_INSTANCE(TIMx))
 800f01e:	d017      	beq.n	800f050 <HAL_TIM_PWM_ConfigChannel+0x538>
 800f020:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800f024:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f028:	4283      	cmp	r3, r0
 800f02a:	d011      	beq.n	800f050 <HAL_TIM_PWM_ConfigChannel+0x538>
 800f02c:	f44f 4680 	mov.w	r6, #16384	; 0x4000
 800f030:	f44f 4088 	mov.w	r0, #17408	; 0x4400
 800f034:	f2c4 0601 	movt	r6, #16385	; 0x4001
 800f038:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f03c:	4283      	cmp	r3, r0
 800f03e:	bf18      	it	ne
 800f040:	42b3      	cmpne	r3, r6
 800f042:	d005      	beq.n	800f050 <HAL_TIM_PWM_ConfigChannel+0x538>
 800f044:	f44f 4090 	mov.w	r0, #18432	; 0x4800
 800f048:	f2c4 0001 	movt	r0, #16385	; 0x4001
 800f04c:	4283      	cmp	r3, r0
 800f04e:	d104      	bne.n	800f05a <HAL_TIM_PWM_ConfigChannel+0x542>
    tmpcr2 &= ~TIM_CR2_OIS6;
 800f050:	f42c 3c00 	bic.w	ip, ip, #131072	; 0x20000
    tmpcr2 |= (OC_Config->OCIdleState << 10U);
 800f054:	6968      	ldr	r0, [r5, #20]
 800f056:	ea4c 2c80 	orr.w	ip, ip, r0, lsl #10
  TIMx->CR2 = tmpcr2;
 800f05a:	f8c3 c004 	str.w	ip, [r3, #4]
  TIMx->CCMR3 = tmpccmrx;
 800f05e:	6559      	str	r1, [r3, #84]	; 0x54
  TIMx->CCR6 = OC_Config->Pulse;
 800f060:	6869      	ldr	r1, [r5, #4]
 800f062:	65d9      	str	r1, [r3, #92]	; 0x5c
  TIMx->CCER = tmpccer;
 800f064:	621a      	str	r2, [r3, #32]
      htim->Instance->CCMR3 |= TIM_CCMR3_OC6PE;
 800f066:	6822      	ldr	r2, [r4, #0]
 800f068:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800f06a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800f06e:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 &= ~TIM_CCMR3_OC6FE;
 800f070:	6822      	ldr	r2, [r4, #0]
 800f072:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800f074:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 800f078:	6553      	str	r3, [r2, #84]	; 0x54
      htim->Instance->CCMR3 |= sConfig->OCFastMode << 8U;
 800f07a:	6822      	ldr	r2, [r4, #0]
 800f07c:	6929      	ldr	r1, [r5, #16]
 800f07e:	6d53      	ldr	r3, [r2, #84]	; 0x54
 800f080:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 800f084:	6553      	str	r3, [r2, #84]	; 0x54
      break;
 800f086:	e607      	b.n	800ec98 <HAL_TIM_PWM_ConfigChannel+0x180>
  assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
 800f088:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f08c:	f640 611d 	movw	r1, #3613	; 0xe1d
 800f090:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f094:	f006 fbe8 	bl	8015868 <assert_failed>
 800f098:	e559      	b.n	800eb4e <HAL_TIM_PWM_ConfigChannel+0x36>
      assert_param(IS_TIM_CC6_INSTANCE(htim->Instance));
 800f09a:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f09e:	f44f 6168 	mov.w	r1, #3712	; 0xe80
 800f0a2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f0a6:	f006 fbdf 	bl	8015868 <assert_failed>
 800f0aa:	6823      	ldr	r3, [r4, #0]
 800f0ac:	e7a1      	b.n	800eff2 <HAL_TIM_PWM_ConfigChannel+0x4da>
      assert_param(IS_TIM_CC5_INSTANCE(htim->Instance));
 800f0ae:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f0b2:	f640 616f 	movw	r1, #3695	; 0xe6f
 800f0b6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f0ba:	f006 fbd5 	bl	8015868 <assert_failed>
 800f0be:	6823      	ldr	r3, [r4, #0]
 800f0c0:	e741      	b.n	800ef46 <HAL_TIM_PWM_ConfigChannel+0x42e>
    assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
 800f0c2:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f0c6:	f641 01e8 	movw	r1, #6376	; 0x18e8
 800f0ca:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f0ce:	f006 fbcb 	bl	8015868 <assert_failed>
 800f0d2:	696b      	ldr	r3, [r5, #20]
 800f0d4:	e70e      	b.n	800eef4 <HAL_TIM_PWM_ConfigChannel+0x3dc>
      assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
 800f0d6:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f0da:	f640 615e 	movw	r1, #3678	; 0xe5e
 800f0de:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f0e2:	f006 fbc1 	bl	8015868 <assert_failed>
 800f0e6:	6826      	ldr	r6, [r4, #0]
 800f0e8:	e6d0      	b.n	800ee8c <HAL_TIM_PWM_ConfigChannel+0x374>
      assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
 800f0ea:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f0ee:	f640 614d 	movw	r1, #3661	; 0xe4d
 800f0f2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f0f6:	f006 fbb7 	bl	8015868 <assert_failed>
 800f0fa:	6820      	ldr	r0, [r4, #0]
 800f0fc:	e685      	b.n	800ee0a <HAL_TIM_PWM_ConfigChannel+0x2f2>
      assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
 800f0fe:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f102:	f640 613c 	movw	r1, #3644	; 0xe3c
 800f106:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f10a:	f006 fbad 	bl	8015868 <assert_failed>
 800f10e:	6820      	ldr	r0, [r4, #0]
 800f110:	e639      	b.n	800ed86 <HAL_TIM_PWM_ConfigChannel+0x26e>
      assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
 800f112:	f64d 5030 	movw	r0, #56624	; 0xdd30
 800f116:	f640 612b 	movw	r1, #3627	; 0xe2b
 800f11a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f11e:	f006 fba3 	bl	8015868 <assert_failed>
 800f122:	6820      	ldr	r0, [r4, #0]
 800f124:	e5a6      	b.n	800ec74 <HAL_TIM_PWM_ConfigChannel+0x15c>
 800f126:	bf00      	nop

0800f128 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        TIM_MasterConfigTypeDef *sMasterConfig)
{
 800f128:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tmpcr2;
  uint32_t tmpsmcr;

  /* Check the parameters */
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800f12a:	2300      	movs	r3, #0
 800f12c:	6802      	ldr	r2, [r0, #0]
 800f12e:	f44f 6680 	mov.w	r6, #1024	; 0x400
{
 800f132:	460d      	mov	r5, r1
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800f134:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800f138:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800f13c:	f2c4 0600 	movt	r6, #16384	; 0x4000
{
 800f140:	4604      	mov	r4, r0
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800f142:	429a      	cmp	r2, r3
 800f144:	bf18      	it	ne
 800f146:	f1b2 4f80 	cmpne.w	r2, #1073741824	; 0x40000000
 800f14a:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800f14e:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800f152:	bf14      	ite	ne
 800f154:	2301      	movne	r3, #1
 800f156:	2300      	moveq	r3, #0
 800f158:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800f15c:	42b2      	cmp	r2, r6
 800f15e:	bf0c      	ite	eq
 800f160:	2300      	moveq	r3, #0
 800f162:	f003 0301 	andne.w	r3, r3, #1
 800f166:	428a      	cmp	r2, r1
 800f168:	bf0c      	ite	eq
 800f16a:	2300      	moveq	r3, #0
 800f16c:	f003 0301 	andne.w	r3, r3, #1
 800f170:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800f174:	4282      	cmp	r2, r0
 800f176:	bf0c      	ite	eq
 800f178:	2300      	moveq	r3, #0
 800f17a:	f003 0301 	andne.w	r3, r3, #1
 800f17e:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800f182:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 800f186:	428a      	cmp	r2, r1
 800f188:	bf0c      	ite	eq
 800f18a:	2300      	moveq	r3, #0
 800f18c:	f003 0301 	andne.w	r3, r3, #1
 800f190:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f194:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800f198:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800f19c:	4282      	cmp	r2, r0
 800f19e:	bf0c      	ite	eq
 800f1a0:	2300      	moveq	r3, #0
 800f1a2:	f003 0301 	andne.w	r3, r3, #1
 800f1a6:	428a      	cmp	r2, r1
 800f1a8:	bf0c      	ite	eq
 800f1aa:	2300      	moveq	r3, #0
 800f1ac:	f003 0301 	andne.w	r3, r3, #1
 800f1b0:	b133      	cbz	r3, 800f1c0 <HAL_TIMEx_MasterConfigSynchronization+0x98>
 800f1b2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800f1b6:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800f1ba:	429a      	cmp	r2, r3
 800f1bc:	f040 808e 	bne.w	800f2dc <HAL_TIMEx_MasterConfigSynchronization+0x1b4>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800f1c0:	682b      	ldr	r3, [r5, #0]
 800f1c2:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 800f1c6:	2b40      	cmp	r3, #64	; 0x40
 800f1c8:	d002      	beq.n	800f1d0 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
 800f1ca:	2b00      	cmp	r3, #0
 800f1cc:	f040 808f 	bne.w	800f2ee <HAL_TIMEx_MasterConfigSynchronization+0x1c6>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800f1d0:	68ab      	ldr	r3, [r5, #8]
 800f1d2:	f033 0380 	bics.w	r3, r3, #128	; 0x80
 800f1d6:	d173      	bne.n	800f2c0 <HAL_TIMEx_MasterConfigSynchronization+0x198>

  /* Check input state */
  __HAL_LOCK(htim);
 800f1d8:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800f1dc:	2b01      	cmp	r3, #1
 800f1de:	d07b      	beq.n	800f2d8 <HAL_TIMEx_MasterConfigSynchronization+0x1b0>

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800f1e0:	2300      	movs	r3, #0
  tmpcr2 = htim->Instance->CR2;
 800f1e2:	6822      	ldr	r2, [r4, #0]
  __HAL_LOCK(htim);
 800f1e4:	2001      	movs	r0, #1
  htim->State = HAL_TIM_STATE_BUSY;
 800f1e6:	2102      	movs	r1, #2
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800f1e8:	f2c4 0301 	movt	r3, #16385	; 0x4001
  __HAL_LOCK(htim);
 800f1ec:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800f1f0:	429a      	cmp	r2, r3
  htim->State = HAL_TIM_STATE_BUSY;
 800f1f2:	f884 103d 	strb.w	r1, [r4, #61]	; 0x3d
  tmpcr2 = htim->Instance->CR2;
 800f1f6:	6857      	ldr	r7, [r2, #4]
  tmpsmcr = htim->Instance->SMCR;
 800f1f8:	6896      	ldr	r6, [r2, #8]
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 800f1fa:	d049      	beq.n	800f290 <HAL_TIMEx_MasterConfigSynchronization+0x168>
 800f1fc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f200:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800f204:	429a      	cmp	r2, r3
 800f206:	d043      	beq.n	800f290 <HAL_TIMEx_MasterConfigSynchronization+0x168>
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800f208:	6829      	ldr	r1, [r5, #0]
  tmpcr2 &= ~TIM_CR2_MMS;
 800f20a:	f027 0770 	bic.w	r7, r7, #112	; 0x70

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800f20e:	2300      	movs	r3, #0
 800f210:	f44f 6080 	mov.w	r0, #1024	; 0x400
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 800f214:	430f      	orrs	r7, r1
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800f216:	f44f 6100 	mov.w	r1, #2048	; 0x800
 800f21a:	f2c4 0301 	movt	r3, #16385	; 0x4001
 800f21e:	f2c4 0000 	movt	r0, #16384	; 0x4000
  htim->Instance->CR2 = tmpcr2;
 800f222:	6057      	str	r7, [r2, #4]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 800f224:	f2c4 0100 	movt	r1, #16384	; 0x4000
 800f228:	6822      	ldr	r2, [r4, #0]
 800f22a:	f1b2 4f80 	cmp.w	r2, #1073741824	; 0x40000000
 800f22e:	bf18      	it	ne
 800f230:	429a      	cmpne	r2, r3
 800f232:	bf0c      	ite	eq
 800f234:	2301      	moveq	r3, #1
 800f236:	2300      	movne	r3, #0
 800f238:	4282      	cmp	r2, r0
 800f23a:	bf08      	it	eq
 800f23c:	f043 0301 	orreq.w	r3, r3, #1
 800f240:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 800f244:	428a      	cmp	r2, r1
 800f246:	bf08      	it	eq
 800f248:	f043 0301 	orreq.w	r3, r3, #1
 800f24c:	f2c4 0000 	movt	r0, #16384	; 0x4000
 800f250:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f254:	4282      	cmp	r2, r0
 800f256:	bf08      	it	eq
 800f258:	f043 0301 	orreq.w	r3, r3, #1
 800f25c:	f2c4 0101 	movt	r1, #16385	; 0x4001
 800f260:	428a      	cmp	r2, r1
 800f262:	bf08      	it	eq
 800f264:	f043 0301 	orreq.w	r3, r3, #1
 800f268:	b92b      	cbnz	r3, 800f276 <HAL_TIMEx_MasterConfigSynchronization+0x14e>
 800f26a:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 800f26e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 800f272:	429a      	cmp	r2, r3
 800f274:	d104      	bne.n	800f280 <HAL_TIMEx_MasterConfigSynchronization+0x158>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800f276:	68ab      	ldr	r3, [r5, #8]
    tmpsmcr &= ~TIM_SMCR_MSM;
 800f278:	f026 0680 	bic.w	r6, r6, #128	; 0x80
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 800f27c:	431e      	orrs	r6, r3

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 800f27e:	6096      	str	r6, [r2, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;

  __HAL_UNLOCK(htim);
 800f280:	2300      	movs	r3, #0
  htim->State = HAL_TIM_STATE_READY;
 800f282:	2201      	movs	r2, #1

  return HAL_OK;
 800f284:	4618      	mov	r0, r3
  htim->State = HAL_TIM_STATE_READY;
 800f286:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d
  __HAL_UNLOCK(htim);
 800f28a:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
}
 800f28e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 800f290:	6868      	ldr	r0, [r5, #4]
 800f292:	f420 1340 	bic.w	r3, r0, #3145728	; 0x300000
 800f296:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800f29a:	bf18      	it	ne
 800f29c:	2b00      	cmpne	r3, #0
 800f29e:	bf14      	ite	ne
 800f2a0:	2101      	movne	r1, #1
 800f2a2:	2100      	moveq	r1, #0
 800f2a4:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 800f2a8:	bf0c      	ite	eq
 800f2aa:	2100      	moveq	r1, #0
 800f2ac:	f001 0101 	andne.w	r1, r1, #1
 800f2b0:	b111      	cbz	r1, 800f2b8 <HAL_TIMEx_MasterConfigSynchronization+0x190>
 800f2b2:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
 800f2b6:	d123      	bne.n	800f300 <HAL_TIMEx_MasterConfigSynchronization+0x1d8>
    tmpcr2 &= ~TIM_CR2_MMS2;
 800f2b8:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 800f2bc:	4307      	orrs	r7, r0
 800f2be:	e7a3      	b.n	800f208 <HAL_TIMEx_MasterConfigSynchronization+0xe0>
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));
 800f2c0:	f64d 5068 	movw	r0, #56680	; 0xdd68
 800f2c4:	f240 6175 	movw	r1, #1653	; 0x675
 800f2c8:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f2cc:	f006 facc 	bl	8015868 <assert_failed>
  __HAL_LOCK(htim);
 800f2d0:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 800f2d4:	2b01      	cmp	r3, #1
 800f2d6:	d183      	bne.n	800f1e0 <HAL_TIMEx_MasterConfigSynchronization+0xb8>
 800f2d8:	2002      	movs	r0, #2
}
 800f2da:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
 800f2dc:	f64d 5068 	movw	r0, #56680	; 0xdd68
 800f2e0:	f240 6173 	movw	r1, #1651	; 0x673
 800f2e4:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f2e8:	f006 fabe 	bl	8015868 <assert_failed>
 800f2ec:	e768      	b.n	800f1c0 <HAL_TIMEx_MasterConfigSynchronization+0x98>
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
 800f2ee:	f64d 5068 	movw	r0, #56680	; 0xdd68
 800f2f2:	f240 6174 	movw	r1, #1652	; 0x674
 800f2f6:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f2fa:	f006 fab5 	bl	8015868 <assert_failed>
 800f2fe:	e767      	b.n	800f1d0 <HAL_TIMEx_MasterConfigSynchronization+0xa8>
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));
 800f300:	f64d 5068 	movw	r0, #56680	; 0xdd68
 800f304:	f240 6187 	movw	r1, #1671	; 0x687
 800f308:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f30c:	f006 faac 	bl	8015868 <assert_failed>
 800f310:	6868      	ldr	r0, [r5, #4]
 800f312:	6822      	ldr	r2, [r4, #0]
 800f314:	e7d0      	b.n	800f2b8 <HAL_TIMEx_MasterConfigSynchronization+0x190>
 800f316:	bf00      	nop

0800f318 <FMC_SDRAM_Init>:
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f318:	f244 1340 	movw	r3, #16704	; 0x4140
 800f31c:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800f320:	4298      	cmp	r0, r3
{
 800f322:	b570      	push	{r4, r5, r6, lr}
 800f324:	4605      	mov	r5, r0
 800f326:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f328:	d007      	beq.n	800f33a <FMC_SDRAM_Init+0x22>
 800f32a:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f32e:	f240 311a 	movw	r1, #794	; 0x31a
 800f332:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f336:	f006 fa97 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_SDRAM_BANK(Init->SDBank));
 800f33a:	6823      	ldr	r3, [r4, #0]
 800f33c:	2b01      	cmp	r3, #1
 800f33e:	d907      	bls.n	800f350 <FMC_SDRAM_Init+0x38>
 800f340:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f344:	f240 311b 	movw	r1, #795	; 0x31b
 800f348:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f34c:	f006 fa8c 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800f350:	6863      	ldr	r3, [r4, #4]
 800f352:	2b03      	cmp	r3, #3
 800f354:	f200 80c0 	bhi.w	800f4d8 <FMC_SDRAM_Init+0x1c0>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 800f358:	68a3      	ldr	r3, [r4, #8]
 800f35a:	f033 0204 	bics.w	r2, r3, #4
 800f35e:	d002      	beq.n	800f366 <FMC_SDRAM_Init+0x4e>
 800f360:	2b08      	cmp	r3, #8
 800f362:	f040 80b0 	bne.w	800f4c6 <FMC_SDRAM_Init+0x1ae>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 800f366:	68e3      	ldr	r3, [r4, #12]
 800f368:	f033 0210 	bics.w	r2, r3, #16
 800f36c:	d002      	beq.n	800f374 <FMC_SDRAM_Init+0x5c>
 800f36e:	2b20      	cmp	r3, #32
 800f370:	f040 8093 	bne.w	800f49a <FMC_SDRAM_Init+0x182>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 800f374:	6923      	ldr	r3, [r4, #16]
 800f376:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 800f37a:	f040 809b 	bne.w	800f4b4 <FMC_SDRAM_Init+0x19c>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 800f37e:	6963      	ldr	r3, [r4, #20]
 800f380:	f423 7280 	bic.w	r2, r3, #256	; 0x100
 800f384:	2a80      	cmp	r2, #128	; 0x80
 800f386:	d002      	beq.n	800f38e <FMC_SDRAM_Init+0x76>
 800f388:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800f38c:	d170      	bne.n	800f470 <FMC_SDRAM_Init+0x158>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800f38e:	69a3      	ldr	r3, [r4, #24]
 800f390:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800f394:	d178      	bne.n	800f488 <FMC_SDRAM_Init+0x170>
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 800f396:	69e3      	ldr	r3, [r4, #28]
 800f398:	f433 6200 	bics.w	r2, r3, #2048	; 0x800
 800f39c:	d002      	beq.n	800f3a4 <FMC_SDRAM_Init+0x8c>
 800f39e:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 800f3a2:	d150      	bne.n	800f446 <FMC_SDRAM_Init+0x12e>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 800f3a4:	6a23      	ldr	r3, [r4, #32]
 800f3a6:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800f3aa:	d158      	bne.n	800f45e <FMC_SDRAM_Init+0x146>
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
 800f3ac:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800f3ae:	f432 5300 	bics.w	r3, r2, #8192	; 0x2000
 800f3b2:	d002      	beq.n	800f3ba <FMC_SDRAM_Init+0xa2>
 800f3b4:	f5b2 4f80 	cmp.w	r2, #16384	; 0x4000
 800f3b8:	d11f      	bne.n	800f3fa <FMC_SDRAM_Init+0xe2>

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800f3ba:	6821      	ldr	r1, [r4, #0]
 800f3bc:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
 800f3c0:	b349      	cbz	r1, 800f416 <FMC_SDRAM_Init+0xfe>
                Init->ReadBurst          |
                Init->ReadPipeDelay));
  }
  else /* FMC_Bank2_SDRAM */
  {
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f3c2:	6829      	ldr	r1, [r5, #0]
 800f3c4:	4303      	orrs	r3, r0
               FMC_SDCRx_RPIPE,
               (Init->SDClockPeriod      |
                Init->ReadBurst          |
                Init->ReadPipeDelay));

    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800f3c6:	f44f 4000 	mov.w	r0, #32768	; 0x8000
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f3ca:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800f3ce:	f6cf 70ff 	movt	r0, #65535	; 0xffff
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f3d2:	430b      	orrs	r3, r1
 800f3d4:	4313      	orrs	r3, r2
 800f3d6:	602b      	str	r3, [r5, #0]
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800f3d8:	68e2      	ldr	r2, [r4, #12]
 800f3da:	e9d4 3101 	ldrd	r3, r1, [r4, #4]
 800f3de:	430b      	orrs	r3, r1
 800f3e0:	6921      	ldr	r1, [r4, #16]
 800f3e2:	4313      	orrs	r3, r2
 800f3e4:	e9d4 6205 	ldrd	r6, r2, [r4, #20]
 800f3e8:	430b      	orrs	r3, r1
 800f3ea:	6869      	ldr	r1, [r5, #4]
 800f3ec:	4333      	orrs	r3, r6
 800f3ee:	4008      	ands	r0, r1
 800f3f0:	4313      	orrs	r3, r2
 800f3f2:	4303      	orrs	r3, r0
                Init->CASLatency         |
                Init->WriteProtection));
  }

  return HAL_OK;
}
 800f3f4:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK2],
 800f3f6:	606b      	str	r3, [r5, #4]
}
 800f3f8:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));
 800f3fa:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f3fe:	f44f 7149 	mov.w	r1, #804	; 0x324
 800f402:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f406:	f006 fa2f 	bl	8015868 <assert_failed>
  if (Init->SDBank == FMC_SDRAM_BANK1)
 800f40a:	6821      	ldr	r1, [r4, #0]
 800f40c:	6a62      	ldr	r2, [r4, #36]	; 0x24
 800f40e:	e9d4 3007 	ldrd	r3, r0, [r4, #28]
 800f412:	2900      	cmp	r1, #0
 800f414:	d1d5      	bne.n	800f3c2 <FMC_SDRAM_Init+0xaa>
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f416:	4303      	orrs	r3, r0
 800f418:	e9d4 0101 	ldrd	r0, r1, [r4, #4]
 800f41c:	4303      	orrs	r3, r0
 800f41e:	68e0      	ldr	r0, [r4, #12]
 800f420:	430b      	orrs	r3, r1
 800f422:	6921      	ldr	r1, [r4, #16]
 800f424:	4303      	orrs	r3, r0
 800f426:	e9d4 0405 	ldrd	r0, r4, [r4, #20]
 800f42a:	430b      	orrs	r3, r1
 800f42c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800f430:	4303      	orrs	r3, r0
 800f432:	f6cf 71ff 	movt	r1, #65535	; 0xffff
 800f436:	6828      	ldr	r0, [r5, #0]
 800f438:	4323      	orrs	r3, r4
 800f43a:	4001      	ands	r1, r0
}
 800f43c:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDCR[FMC_SDRAM_BANK1],
 800f43e:	430b      	orrs	r3, r1
 800f440:	4313      	orrs	r3, r2
 800f442:	602b      	str	r3, [r5, #0]
}
 800f444:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
 800f446:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f44a:	f240 3122 	movw	r1, #802	; 0x322
 800f44e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f452:	f006 fa09 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
 800f456:	6a23      	ldr	r3, [r4, #32]
 800f458:	f433 5380 	bics.w	r3, r3, #4096	; 0x1000
 800f45c:	d0a6      	beq.n	800f3ac <FMC_SDRAM_Init+0x94>
 800f45e:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f462:	f240 3123 	movw	r1, #803	; 0x323
 800f466:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f46a:	f006 f9fd 	bl	8015868 <assert_failed>
 800f46e:	e79d      	b.n	800f3ac <FMC_SDRAM_Init+0x94>
  assert_param(IS_FMC_CAS_LATENCY(Init->CASLatency));
 800f470:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f474:	f44f 7148 	mov.w	r1, #800	; 0x320
 800f478:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f47c:	f006 f9f4 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_WRITE_PROTECTION(Init->WriteProtection));
 800f480:	69a3      	ldr	r3, [r4, #24]
 800f482:	f433 7300 	bics.w	r3, r3, #512	; 0x200
 800f486:	d086      	beq.n	800f396 <FMC_SDRAM_Init+0x7e>
 800f488:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f48c:	f240 3121 	movw	r1, #801	; 0x321
 800f490:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f494:	f006 f9e8 	bl	8015868 <assert_failed>
 800f498:	e77d      	b.n	800f396 <FMC_SDRAM_Init+0x7e>
  assert_param(IS_FMC_SDMEMORY_WIDTH(Init->MemoryDataWidth));
 800f49a:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f49e:	f240 311e 	movw	r1, #798	; 0x31e
 800f4a2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f4a6:	f006 f9df 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_INTERNALBANK_NUMBER(Init->InternalBankNumber));
 800f4aa:	6923      	ldr	r3, [r4, #16]
 800f4ac:	f033 0340 	bics.w	r3, r3, #64	; 0x40
 800f4b0:	f43f af65 	beq.w	800f37e <FMC_SDRAM_Init+0x66>
 800f4b4:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f4b8:	f240 311f 	movw	r1, #799	; 0x31f
 800f4bc:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f4c0:	f006 f9d2 	bl	8015868 <assert_failed>
 800f4c4:	e75b      	b.n	800f37e <FMC_SDRAM_Init+0x66>
  assert_param(IS_FMC_ROWBITS_NUMBER(Init->RowBitsNumber));
 800f4c6:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f4ca:	f240 311d 	movw	r1, #797	; 0x31d
 800f4ce:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f4d2:	f006 f9c9 	bl	8015868 <assert_failed>
 800f4d6:	e746      	b.n	800f366 <FMC_SDRAM_Init+0x4e>
  assert_param(IS_FMC_COLUMNBITS_NUMBER(Init->ColumnBitsNumber));
 800f4d8:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f4dc:	f44f 7147 	mov.w	r1, #796	; 0x31c
 800f4e0:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f4e4:	f006 f9c0 	bl	8015868 <assert_failed>
 800f4e8:	e736      	b.n	800f358 <FMC_SDRAM_Init+0x40>
 800f4ea:	bf00      	nop

0800f4ec <FMC_SDRAM_Timing_Init>:
  * @param  Timing Pointer to SDRAM Timing structure
  * @param  Bank SDRAM bank number
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 800f4ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f4ee:	f244 1340 	movw	r3, #16704	; 0x4140
{
 800f4f2:	4605      	mov	r5, r0
 800f4f4:	460c      	mov	r4, r1
 800f4f6:	4616      	mov	r6, r2
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f4f8:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800f4fc:	4298      	cmp	r0, r3
 800f4fe:	d007      	beq.n	800f510 <FMC_SDRAM_Timing_Init+0x24>
 800f500:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f504:	f44f 7156 	mov.w	r1, #856	; 0x358
 800f508:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f50c:	f006 f9ac 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 800f510:	6823      	ldr	r3, [r4, #0]
 800f512:	3b01      	subs	r3, #1
 800f514:	2b0f      	cmp	r3, #15
 800f516:	f200 80a4 	bhi.w	800f662 <FMC_SDRAM_Timing_Init+0x176>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 800f51a:	6863      	ldr	r3, [r4, #4]
 800f51c:	3b01      	subs	r3, #1
 800f51e:	2b0f      	cmp	r3, #15
 800f520:	f200 8096 	bhi.w	800f650 <FMC_SDRAM_Timing_Init+0x164>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 800f524:	68a3      	ldr	r3, [r4, #8]
 800f526:	3b01      	subs	r3, #1
 800f528:	2b0f      	cmp	r3, #15
 800f52a:	f200 8088 	bhi.w	800f63e <FMC_SDRAM_Timing_Init+0x152>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 800f52e:	68e3      	ldr	r3, [r4, #12]
 800f530:	3b01      	subs	r3, #1
 800f532:	2b0f      	cmp	r3, #15
 800f534:	d87a      	bhi.n	800f62c <FMC_SDRAM_Timing_Init+0x140>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 800f536:	6923      	ldr	r3, [r4, #16]
 800f538:	3b01      	subs	r3, #1
 800f53a:	2b0f      	cmp	r3, #15
 800f53c:	d86d      	bhi.n	800f61a <FMC_SDRAM_Timing_Init+0x12e>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 800f53e:	6963      	ldr	r3, [r4, #20]
 800f540:	3b01      	subs	r3, #1
 800f542:	2b0f      	cmp	r3, #15
 800f544:	d860      	bhi.n	800f608 <FMC_SDRAM_Timing_Init+0x11c>
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 800f546:	69a3      	ldr	r3, [r4, #24]
 800f548:	3b01      	subs	r3, #1
 800f54a:	2b0f      	cmp	r3, #15
 800f54c:	d853      	bhi.n	800f5f6 <FMC_SDRAM_Timing_Init+0x10a>
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 800f54e:	2e01      	cmp	r6, #1
 800f550:	d821      	bhi.n	800f596 <FMC_SDRAM_Timing_Init+0xaa>
 800f552:	68e3      	ldr	r3, [r4, #12]
 800f554:	6961      	ldr	r1, [r4, #20]
 800f556:	3b01      	subs	r3, #1
 800f558:	3901      	subs	r1, #1
 800f55a:	031b      	lsls	r3, r3, #12
 800f55c:	0509      	lsls	r1, r1, #20

  /* Set SDRAM device timing parameters */
  if (Bank == FMC_SDRAM_BANK1)
 800f55e:	bb46      	cbnz	r6, 800f5b2 <FMC_SDRAM_Timing_Init+0xc6>
  {
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800f560:	6822      	ldr	r2, [r4, #0]
 800f562:	430b      	orrs	r3, r1
 800f564:	6860      	ldr	r0, [r4, #4]
 800f566:	3a01      	subs	r2, #1
 800f568:	68a1      	ldr	r1, [r4, #8]
 800f56a:	1e47      	subs	r7, r0, #1
 800f56c:	6920      	ldr	r0, [r4, #16]
 800f56e:	4313      	orrs	r3, r2
 800f570:	1e4e      	subs	r6, r1, #1
 800f572:	3801      	subs	r0, #1
 800f574:	69a1      	ldr	r1, [r4, #24]
 800f576:	ea43 1307 	orr.w	r3, r3, r7, lsl #4
 800f57a:	68aa      	ldr	r2, [r5, #8]
 800f57c:	3901      	subs	r1, #1
 800f57e:	ea43 2306 	orr.w	r3, r3, r6, lsl #8
 800f582:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800f586:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
                (((Timing->WriteRecoveryTime) - 1U)    << FMC_SDTRx_TWR_Pos)  |
                (((Timing->RCDDelay) - 1U)             << FMC_SDTRx_TRCD_Pos)));
  }

  return HAL_OK;
}
 800f58a:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800f58c:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800f590:	4313      	orrs	r3, r2
 800f592:	60ab      	str	r3, [r5, #8]
}
 800f594:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_SDRAM_BANK(Bank));
 800f596:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f59a:	f44f 7158 	mov.w	r1, #864	; 0x360
 800f59e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f5a2:	f006 f961 	bl	8015868 <assert_failed>
 800f5a6:	68e3      	ldr	r3, [r4, #12]
 800f5a8:	6961      	ldr	r1, [r4, #20]
 800f5aa:	3b01      	subs	r3, #1
 800f5ac:	3901      	subs	r1, #1
 800f5ae:	031b      	lsls	r3, r3, #12
 800f5b0:	0509      	lsls	r1, r1, #20
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK1],
 800f5b2:	f640 72ff 	movw	r2, #4095	; 0xfff
 800f5b6:	68a8      	ldr	r0, [r5, #8]
 800f5b8:	430b      	orrs	r3, r1
 800f5ba:	f6cf 720f 	movt	r2, #65295	; 0xff0f
 800f5be:	4002      	ands	r2, r0
 800f5c0:	4313      	orrs	r3, r2
 800f5c2:	60ab      	str	r3, [r5, #8]
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800f5c4:	6820      	ldr	r0, [r4, #0]
 800f5c6:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
 800f5ca:	1e46      	subs	r6, r0, #1
 800f5cc:	1e5a      	subs	r2, r3, #1
 800f5ce:	1e4b      	subs	r3, r1, #1
 800f5d0:	6921      	ldr	r1, [r4, #16]
 800f5d2:	0212      	lsls	r2, r2, #8
 800f5d4:	1e48      	subs	r0, r1, #1
 800f5d6:	69a1      	ldr	r1, [r4, #24]
 800f5d8:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 800f5dc:	68ea      	ldr	r2, [r5, #12]
 800f5de:	3901      	subs	r1, #1
 800f5e0:	4333      	orrs	r3, r6
 800f5e2:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
 800f5e6:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
}
 800f5ea:	2000      	movs	r0, #0
    MODIFY_REG(Device->SDTR[FMC_SDRAM_BANK2],
 800f5ec:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 800f5f0:	4313      	orrs	r3, r2
 800f5f2:	60eb      	str	r3, [r5, #12]
}
 800f5f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
 800f5f6:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f5fa:	f240 315f 	movw	r1, #863	; 0x35f
 800f5fe:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f602:	f006 f931 	bl	8015868 <assert_failed>
 800f606:	e7a2      	b.n	800f54e <FMC_SDRAM_Timing_Init+0x62>
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
 800f608:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f60c:	f240 315e 	movw	r1, #862	; 0x35e
 800f610:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f614:	f006 f928 	bl	8015868 <assert_failed>
 800f618:	e795      	b.n	800f546 <FMC_SDRAM_Timing_Init+0x5a>
  assert_param(IS_FMC_WRITE_RECOVERY_TIME(Timing->WriteRecoveryTime));
 800f61a:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f61e:	f240 315d 	movw	r1, #861	; 0x35d
 800f622:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f626:	f006 f91f 	bl	8015868 <assert_failed>
 800f62a:	e788      	b.n	800f53e <FMC_SDRAM_Timing_Init+0x52>
  assert_param(IS_FMC_ROWCYCLE_DELAY(Timing->RowCycleDelay));
 800f62c:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f630:	f44f 7157 	mov.w	r1, #860	; 0x35c
 800f634:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f638:	f006 f916 	bl	8015868 <assert_failed>
 800f63c:	e77b      	b.n	800f536 <FMC_SDRAM_Timing_Init+0x4a>
  assert_param(IS_FMC_SELFREFRESH_TIME(Timing->SelfRefreshTime));
 800f63e:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f642:	f240 315b 	movw	r1, #859	; 0x35b
 800f646:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f64a:	f006 f90d 	bl	8015868 <assert_failed>
 800f64e:	e76e      	b.n	800f52e <FMC_SDRAM_Timing_Init+0x42>
  assert_param(IS_FMC_EXITSELFREFRESH_DELAY(Timing->ExitSelfRefreshDelay));
 800f650:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f654:	f240 315a 	movw	r1, #858	; 0x35a
 800f658:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f65c:	f006 f904 	bl	8015868 <assert_failed>
 800f660:	e760      	b.n	800f524 <FMC_SDRAM_Timing_Init+0x38>
  assert_param(IS_FMC_LOADTOACTIVE_DELAY(Timing->LoadToActiveDelay));
 800f662:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f666:	f240 3159 	movw	r1, #857	; 0x359
 800f66a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f66e:	f006 f8fb 	bl	8015868 <assert_failed>
 800f672:	e752      	b.n	800f51a <FMC_SDRAM_Timing_Init+0x2e>

0800f674 <FMC_SDRAM_SendCommand>:
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f674:	f244 1340 	movw	r3, #16704	; 0x4140
 800f678:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800f67c:	4298      	cmp	r0, r3
{
 800f67e:	b570      	push	{r4, r5, r6, lr}
 800f680:	4605      	mov	r5, r0
 800f682:	460c      	mov	r4, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f684:	d007      	beq.n	800f696 <FMC_SDRAM_SendCommand+0x22>
 800f686:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f68a:	f240 31d9 	movw	r1, #985	; 0x3d9
 800f68e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f692:	f006 f8e9 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 800f696:	6823      	ldr	r3, [r4, #0]
 800f698:	2b06      	cmp	r3, #6
 800f69a:	d83a      	bhi.n	800f712 <FMC_SDRAM_SendCommand+0x9e>
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 800f69c:	6863      	ldr	r3, [r4, #4]
 800f69e:	f023 0210 	bic.w	r2, r3, #16
 800f6a2:	2a08      	cmp	r2, #8
 800f6a4:	d001      	beq.n	800f6aa <FMC_SDRAM_SendCommand+0x36>
 800f6a6:	2b10      	cmp	r3, #16
 800f6a8:	d11e      	bne.n	800f6e8 <FMC_SDRAM_SendCommand+0x74>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 800f6aa:	68a3      	ldr	r3, [r4, #8]
 800f6ac:	3b01      	subs	r3, #1
 800f6ae:	2b0e      	cmp	r3, #14
 800f6b0:	d826      	bhi.n	800f700 <FMC_SDRAM_SendCommand+0x8c>
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));
 800f6b2:	68e1      	ldr	r1, [r4, #12]
 800f6b4:	f5b1 5f00 	cmp.w	r1, #8192	; 0x2000
 800f6b8:	d308      	bcc.n	800f6cc <FMC_SDRAM_SendCommand+0x58>
 800f6ba:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f6be:	f240 31dd 	movw	r1, #989	; 0x3dd
 800f6c2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f6c6:	f006 f8cf 	bl	8015868 <assert_failed>
 800f6ca:	68e1      	ldr	r1, [r4, #12]

  /* Set command register */
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
 800f6cc:	6823      	ldr	r3, [r4, #0]
                          (((Command->AutoRefreshNumber) - 1U) << FMC_SDCMR_NRFS_Pos)   |
                          ((Command->ModeRegisterDefinition)   << FMC_SDCMR_MRD_Pos)));
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Timeout);
  return HAL_OK;
}
 800f6ce:	2000      	movs	r0, #0
  SET_BIT(Device->SDCMR, ((Command->CommandMode)                                                 |
 800f6d0:	e9d4 6201 	ldrd	r6, r2, [r4, #4]
 800f6d4:	692c      	ldr	r4, [r5, #16]
 800f6d6:	4333      	orrs	r3, r6
 800f6d8:	3a01      	subs	r2, #1
 800f6da:	4323      	orrs	r3, r4
 800f6dc:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 800f6e0:	ea43 2341 	orr.w	r3, r3, r1, lsl #9
 800f6e4:	612b      	str	r3, [r5, #16]
}
 800f6e6:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
 800f6e8:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f6ec:	f240 31db 	movw	r1, #987	; 0x3db
 800f6f0:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f6f4:	f006 f8b8 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
 800f6f8:	68a3      	ldr	r3, [r4, #8]
 800f6fa:	3b01      	subs	r3, #1
 800f6fc:	2b0e      	cmp	r3, #14
 800f6fe:	d9d8      	bls.n	800f6b2 <FMC_SDRAM_SendCommand+0x3e>
 800f700:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f704:	f44f 7177 	mov.w	r1, #988	; 0x3dc
 800f708:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f70c:	f006 f8ac 	bl	8015868 <assert_failed>
 800f710:	e7cf      	b.n	800f6b2 <FMC_SDRAM_SendCommand+0x3e>
  assert_param(IS_FMC_COMMAND_MODE(Command->CommandMode));
 800f712:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f716:	f240 31da 	movw	r1, #986	; 0x3da
 800f71a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f71e:	f006 f8a3 	bl	8015868 <assert_failed>
 800f722:	e7bb      	b.n	800f69c <FMC_SDRAM_SendCommand+0x28>

0800f724 <FMC_SDRAM_ProgramRefreshRate>:
  * @param  Device Pointer to SDRAM device instance
  * @param  RefreshRate The SDRAM refresh rate value.
  * @retval HAL state
  */
HAL_StatusTypeDef FMC_SDRAM_ProgramRefreshRate(FMC_SDRAM_TypeDef *Device, uint32_t RefreshRate)
{
 800f724:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f726:	f244 1340 	movw	r3, #16704	; 0x4140
{
 800f72a:	4604      	mov	r4, r0
 800f72c:	460d      	mov	r5, r1
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
 800f72e:	f2c5 2300 	movt	r3, #20992	; 0x5200
 800f732:	4298      	cmp	r0, r3
 800f734:	d007      	beq.n	800f746 <FMC_SDRAM_ProgramRefreshRate+0x22>
 800f736:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f73a:	f240 31f2 	movw	r1, #1010	; 0x3f2
 800f73e:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f742:	f006 f891 	bl	8015868 <assert_failed>
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
 800f746:	f5b5 5f00 	cmp.w	r5, #8192	; 0x2000
 800f74a:	d307      	bcc.n	800f75c <FMC_SDRAM_ProgramRefreshRate+0x38>
 800f74c:	f64d 50a4 	movw	r0, #56740	; 0xdda4
 800f750:	f240 31f3 	movw	r1, #1011	; 0x3f3
 800f754:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f758:	f006 f886 	bl	8015868 <assert_failed>

  /* Set the refresh rate in command register */
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800f75c:	f24c 0101 	movw	r1, #49153	; 0xc001
 800f760:	6963      	ldr	r3, [r4, #20]

  return HAL_OK;
}
 800f762:	2000      	movs	r0, #0
  MODIFY_REG(Device->SDRTR, FMC_SDRTR_COUNT, (RefreshRate << FMC_SDRTR_COUNT_Pos));
 800f764:	f6cf 71ff 	movt	r1, #65535	; 0xffff
 800f768:	4019      	ands	r1, r3
 800f76a:	ea41 0145 	orr.w	r1, r1, r5, lsl #1
 800f76e:	6161      	str	r1, [r4, #20]
}
 800f770:	bd38      	pop	{r3, r4, r5, pc}
 800f772:	bf00      	nop

0800f774 <SDMMC_GetCmdResp1.part.2>:
  }

  /* We have received response, retrieve it for analysis  */
  response_r1 = SDMMC_GetResponse(SDMMCx, SDMMC_RESP1);

  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800f774:	f24e 0308 	movw	r3, #57352	; 0xe008
  return (*(__IO uint32_t *) tmp);
 800f778:	6942      	ldr	r2, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 800f77a:	f6cf 53ff 	movt	r3, #65023	; 0xfdff
 800f77e:	4013      	ands	r3, r2
 800f780:	b34b      	cbz	r3, 800f7d6 <SDMMC_GetCmdResp1.part.2+0x62>
  {
    return SDMMC_ERROR_NONE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 800f782:	2a00      	cmp	r2, #0
 800f784:	db29      	blt.n	800f7da <SDMMC_GetCmdResp1.part.2+0x66>
  {
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
  }
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 800f786:	0051      	lsls	r1, r2, #1
 800f788:	d42d      	bmi.n	800f7e6 <SDMMC_GetCmdResp1.part.2+0x72>
  {
    return SDMMC_ERROR_ADDR_MISALIGNED;
  }
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 800f78a:	0093      	lsls	r3, r2, #2
 800f78c:	d42d      	bmi.n	800f7ea <SDMMC_GetCmdResp1.part.2+0x76>
  {
    return SDMMC_ERROR_BLOCK_LEN_ERR;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 800f78e:	00d1      	lsls	r1, r2, #3
 800f790:	d426      	bmi.n	800f7e0 <SDMMC_GetCmdResp1.part.2+0x6c>
  {
    return SDMMC_ERROR_ERASE_SEQ_ERR;
  }
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 800f792:	0113      	lsls	r3, r2, #4
 800f794:	d42e      	bmi.n	800f7f4 <SDMMC_GetCmdResp1.part.2+0x80>
  {
    return SDMMC_ERROR_BAD_ERASE_PARAM;
  }
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 800f796:	0151      	lsls	r1, r2, #5
 800f798:	d42f      	bmi.n	800f7fa <SDMMC_GetCmdResp1.part.2+0x86>
  {
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
  }
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 800f79a:	01d3      	lsls	r3, r2, #7
 800f79c:	d427      	bmi.n	800f7ee <SDMMC_GetCmdResp1.part.2+0x7a>
  {
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 800f79e:	0211      	lsls	r1, r2, #8
 800f7a0:	d42e      	bmi.n	800f800 <SDMMC_GetCmdResp1.part.2+0x8c>
  {
    return SDMMC_ERROR_COM_CRC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 800f7a2:	0253      	lsls	r3, r2, #9
 800f7a4:	d42f      	bmi.n	800f806 <SDMMC_GetCmdResp1.part.2+0x92>
  {
    return SDMMC_ERROR_ILLEGAL_CMD;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 800f7a6:	0291      	lsls	r1, r2, #10
 800f7a8:	d430      	bmi.n	800f80c <SDMMC_GetCmdResp1.part.2+0x98>
  {
    return SDMMC_ERROR_CARD_ECC_FAILED;
  }
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 800f7aa:	02d3      	lsls	r3, r2, #11
 800f7ac:	d431      	bmi.n	800f812 <SDMMC_GetCmdResp1.part.2+0x9e>
  {
    return SDMMC_ERROR_CC_ERR;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 800f7ae:	0351      	lsls	r1, r2, #13
 800f7b0:	d432      	bmi.n	800f818 <SDMMC_GetCmdResp1.part.2+0xa4>
  {
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
  }
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800f7b2:	0393      	lsls	r3, r2, #14
 800f7b4:	d433      	bmi.n	800f81e <SDMMC_GetCmdResp1.part.2+0xaa>
  {
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
  }
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800f7b6:	03d1      	lsls	r1, r2, #15
 800f7b8:	d434      	bmi.n	800f824 <SDMMC_GetCmdResp1.part.2+0xb0>
  {
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
  }
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 800f7ba:	0413      	lsls	r3, r2, #16
 800f7bc:	d435      	bmi.n	800f82a <SDMMC_GetCmdResp1.part.2+0xb6>
  {
    return SDMMC_ERROR_WP_ERASE_SKIP;
  }
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 800f7be:	0451      	lsls	r1, r2, #17
 800f7c0:	d436      	bmi.n	800f830 <SDMMC_GetCmdResp1.part.2+0xbc>
  {
    return SDMMC_ERROR_CARD_ECC_DISABLED;
  }
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800f7c2:	0493      	lsls	r3, r2, #18
 800f7c4:	d437      	bmi.n	800f836 <SDMMC_GetCmdResp1.part.2+0xc2>
  {
    return SDMMC_ERROR_ERASE_RESET;
  }
  else if((response_r1 & SDMMC_OCR_AKE_SEQ_ERROR) == SDMMC_OCR_AKE_SEQ_ERROR)
 800f7c6:	f012 0f08 	tst.w	r2, #8
  {
    return SDMMC_ERROR_AKE_SEQ_ERR;
  }
  else
  {
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800f7ca:	bf14      	ite	ne
 800f7cc:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 800f7d0:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800f7d4:	4770      	bx	lr
    return SDMMC_ERROR_NONE;
 800f7d6:	4618      	mov	r0, r3
 800f7d8:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 800f7da:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800f7de:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 800f7e0:	f44f 7080 	mov.w	r0, #256	; 0x100
 800f7e4:	4770      	bx	lr
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800f7e6:	2040      	movs	r0, #64	; 0x40
 800f7e8:	4770      	bx	lr
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800f7ea:	2080      	movs	r0, #128	; 0x80
 800f7ec:	4770      	bx	lr
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 800f7ee:	f44f 6000 	mov.w	r0, #2048	; 0x800
 800f7f2:	4770      	bx	lr
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 800f7f4:	f44f 7000 	mov.w	r0, #512	; 0x200
 800f7f8:	4770      	bx	lr
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800f7fa:	f44f 6080 	mov.w	r0, #1024	; 0x400
 800f7fe:	4770      	bx	lr
    return SDMMC_ERROR_COM_CRC_FAILED;
 800f800:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800f804:	4770      	bx	lr
    return SDMMC_ERROR_ILLEGAL_CMD;
 800f806:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800f80a:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_FAILED;
 800f80c:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800f810:	4770      	bx	lr
    return SDMMC_ERROR_CC_ERR;
 800f812:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 800f816:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 800f818:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800f81c:	4770      	bx	lr
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 800f81e:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800f822:	4770      	bx	lr
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800f824:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 800f828:	4770      	bx	lr
    return SDMMC_ERROR_WP_ERASE_SKIP;
 800f82a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800f82e:	4770      	bx	lr
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800f830:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800f834:	4770      	bx	lr
    return SDMMC_ERROR_ERASE_RESET;
 800f836:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
  }
}
 800f83a:	4770      	bx	lr

0800f83c <SDMMC_Init>:
{
 800f83c:	b084      	sub	sp, #16
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800f83e:	f44f 4ce0 	mov.w	ip, #28672	; 0x7000
{
 800f842:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800f846:	f2c5 2c00 	movt	ip, #20992	; 0x5200
{
 800f84a:	4605      	mov	r5, r0
 800f84c:	a809      	add	r0, sp, #36	; 0x24
 800f84e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800f850:	4565      	cmp	r5, ip
 800f852:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 800f854:	460c      	mov	r4, r1
{
 800f856:	e880 000e 	stmia.w	r0, {r1, r2, r3}
 800f85a:	e9dd 980a 	ldrd	r9, r8, [sp, #40]	; 0x28
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800f85e:	d005      	beq.n	800f86c <SDMMC_Init+0x30>
 800f860:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 800f864:	f6c4 0302 	movt	r3, #18434	; 0x4802
 800f868:	429d      	cmp	r5, r3
 800f86a:	d12b      	bne.n	800f8c4 <SDMMC_Init+0x88>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
 800f86c:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
 800f870:	d132      	bne.n	800f8d8 <SDMMC_Init+0x9c>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
 800f872:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
 800f876:	d139      	bne.n	800f8ec <SDMMC_Init+0xb0>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
 800f878:	f438 4380 	bics.w	r3, r8, #16384	; 0x4000
 800f87c:	d002      	beq.n	800f884 <SDMMC_Init+0x48>
 800f87e:	f5b8 4f00 	cmp.w	r8, #32768	; 0x8000
 800f882:	d13b      	bne.n	800f8fc <SDMMC_Init+0xc0>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
 800f884:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
 800f888:	d142      	bne.n	800f910 <SDMMC_Init+0xd4>
  assert_param(IS_SDMMC_CLKDIV(Init.ClockDiv));
 800f88a:	f5b6 6f80 	cmp.w	r6, #1024	; 0x400
 800f88e:	d306      	bcc.n	800f89e <SDMMC_Init+0x62>
 800f890:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f894:	21d7      	movs	r1, #215	; 0xd7
 800f896:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f89a:	f005 ffe5 	bl	8015868 <assert_failed>
  tmpreg |= (Init.ClockEdge           |\
 800f89e:	ea44 0309 	orr.w	r3, r4, r9
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800f8a2:	f44f 5230 	mov.w	r2, #11264	; 0x2c00
 800f8a6:	6869      	ldr	r1, [r5, #4]
}
 800f8a8:	2000      	movs	r0, #0
             Init.ClockPowerSave      |\
 800f8aa:	ea43 0308 	orr.w	r3, r3, r8
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800f8ae:	f6cf 72c0 	movt	r2, #65472	; 0xffc0
             Init.BusWide             |\
 800f8b2:	433b      	orrs	r3, r7
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800f8b4:	400a      	ands	r2, r1
             Init.HardwareFlowControl |\
 800f8b6:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, tmpreg);
 800f8b8:	4313      	orrs	r3, r2
 800f8ba:	606b      	str	r3, [r5, #4]
}
 800f8bc:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800f8c0:	b004      	add	sp, #16
 800f8c2:	4770      	bx	lr
  assert_param(IS_SDMMC_ALL_INSTANCE(SDMMCx));
 800f8c4:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f8c8:	21d2      	movs	r1, #210	; 0xd2
 800f8ca:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f8ce:	f005 ffcb 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_EDGE(Init.ClockEdge));
 800f8d2:	f434 3380 	bics.w	r3, r4, #65536	; 0x10000
 800f8d6:	d0cc      	beq.n	800f872 <SDMMC_Init+0x36>
 800f8d8:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f8dc:	21d3      	movs	r1, #211	; 0xd3
 800f8de:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f8e2:	f005 ffc1 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_CLOCK_POWER_SAVE(Init.ClockPowerSave));
 800f8e6:	f439 5380 	bics.w	r3, r9, #4096	; 0x1000
 800f8ea:	d0c5      	beq.n	800f878 <SDMMC_Init+0x3c>
 800f8ec:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f8f0:	21d4      	movs	r1, #212	; 0xd4
 800f8f2:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f8f6:	f005 ffb7 	bl	8015868 <assert_failed>
 800f8fa:	e7bd      	b.n	800f878 <SDMMC_Init+0x3c>
  assert_param(IS_SDMMC_BUS_WIDE(Init.BusWide));
 800f8fc:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f900:	21d5      	movs	r1, #213	; 0xd5
 800f902:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f906:	f005 ffaf 	bl	8015868 <assert_failed>
  assert_param(IS_SDMMC_HARDWARE_FLOW_CONTROL(Init.HardwareFlowControl));
 800f90a:	f437 3300 	bics.w	r3, r7, #131072	; 0x20000
 800f90e:	d0bc      	beq.n	800f88a <SDMMC_Init+0x4e>
 800f910:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f914:	21d6      	movs	r1, #214	; 0xd6
 800f916:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f91a:	f005 ffa5 	bl	8015868 <assert_failed>
 800f91e:	e7b4      	b.n	800f88a <SDMMC_Init+0x4e>

0800f920 <SDMMC_ReadFIFO>:
  return (SDMMCx->FIFO);
 800f920:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
}
 800f924:	4770      	bx	lr
 800f926:	bf00      	nop

0800f928 <SDMMC_WriteFIFO>:
{
 800f928:	4603      	mov	r3, r0
  SDMMCx->FIFO = *pWriteData;
 800f92a:	680a      	ldr	r2, [r1, #0]
}
 800f92c:	2000      	movs	r0, #0
  SDMMCx->FIFO = *pWriteData;
 800f92e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
}
 800f932:	4770      	bx	lr

0800f934 <SDMMC_PowerState_ON>:
{
 800f934:	4602      	mov	r2, r0
}
 800f936:	2000      	movs	r0, #0
  SDMMCx->POWER |= SDMMC_POWER_PWRCTRL;
 800f938:	6813      	ldr	r3, [r2, #0]
 800f93a:	f043 0303 	orr.w	r3, r3, #3
 800f93e:	6013      	str	r3, [r2, #0]
}
 800f940:	4770      	bx	lr
 800f942:	bf00      	nop

0800f944 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 800f944:	6800      	ldr	r0, [r0, #0]
}
 800f946:	f000 0003 	and.w	r0, r0, #3
 800f94a:	4770      	bx	lr

0800f94c <SDMMC_GetResponse>:
{
 800f94c:	b538      	push	{r3, r4, r5, lr}
  assert_param(IS_SDMMC_RESP(Response));
 800f94e:	f031 030c 	bics.w	r3, r1, #12
{
 800f952:	460d      	mov	r5, r1
 800f954:	4604      	mov	r4, r0
  assert_param(IS_SDMMC_RESP(Response));
 800f956:	d007      	beq.n	800f968 <SDMMC_GetResponse+0x1c>
 800f958:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f95c:	f44f 71cc 	mov.w	r1, #408	; 0x198
 800f960:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f964:	f005 ff80 	bl	8015868 <assert_failed>
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800f968:	3414      	adds	r4, #20
  return (*(__IO uint32_t *) tmp);
 800f96a:	5960      	ldr	r0, [r4, r5]
}
 800f96c:	bd38      	pop	{r3, r4, r5, pc}
 800f96e:	bf00      	nop

0800f970 <SDMMC_ConfigData>:
{
 800f970:	b570      	push	{r4, r5, r6, lr}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800f972:	684b      	ldr	r3, [r1, #4]
{
 800f974:	460c      	mov	r4, r1
 800f976:	4605      	mov	r5, r0
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800f978:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 800f97c:	d23e      	bcs.n	800f9fc <SDMMC_ConfigData+0x8c>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
 800f97e:	68a2      	ldr	r2, [r4, #8]
 800f980:	f032 0130 	bics.w	r1, r2, #48	; 0x30
 800f984:	bf14      	ite	ne
 800f986:	2301      	movne	r3, #1
 800f988:	2300      	moveq	r3, #0
 800f98a:	2940      	cmp	r1, #64	; 0x40
 800f98c:	bf0c      	ite	eq
 800f98e:	2300      	moveq	r3, #0
 800f990:	f003 0301 	andne.w	r3, r3, #1
 800f994:	2ae0      	cmp	r2, #224	; 0xe0
 800f996:	bf0c      	ite	eq
 800f998:	2300      	moveq	r3, #0
 800f99a:	f003 0301 	andne.w	r3, r3, #1
 800f99e:	2980      	cmp	r1, #128	; 0x80
 800f9a0:	bf0c      	ite	eq
 800f9a2:	2300      	moveq	r3, #0
 800f9a4:	f003 0301 	andne.w	r3, r3, #1
 800f9a8:	b11b      	cbz	r3, 800f9b2 <SDMMC_ConfigData+0x42>
 800f9aa:	f022 0210 	bic.w	r2, r2, #16
 800f9ae:	2ac0      	cmp	r2, #192	; 0xc0
 800f9b0:	d13f      	bne.n	800fa32 <SDMMC_ConfigData+0xc2>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
 800f9b2:	68e3      	ldr	r3, [r4, #12]
 800f9b4:	f033 0302 	bics.w	r3, r3, #2
 800f9b8:	d132      	bne.n	800fa20 <SDMMC_ConfigData+0xb0>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
 800f9ba:	6923      	ldr	r3, [r4, #16]
 800f9bc:	f033 0308 	bics.w	r3, r3, #8
 800f9c0:	d125      	bne.n	800fa0e <SDMMC_ConfigData+0x9e>
  assert_param(IS_SDMMC_DPSM(Data->DPSM));
 800f9c2:	6963      	ldr	r3, [r4, #20]
 800f9c4:	2b01      	cmp	r3, #1
 800f9c6:	d907      	bls.n	800f9d8 <SDMMC_ConfigData+0x68>
 800f9c8:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800f9cc:	f240 11b1 	movw	r1, #433	; 0x1b1
 800f9d0:	f6c0 0002 	movt	r0, #2050	; 0x802
 800f9d4:	f005 ff48 	bl	8015868 <assert_failed>
  SDMMCx->DTIMER = Data->DataTimeOut;
 800f9d8:	6823      	ldr	r3, [r4, #0]
}
 800f9da:	2000      	movs	r0, #0
  SDMMCx->DTIMER = Data->DataTimeOut;
 800f9dc:	626b      	str	r3, [r5, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
 800f9de:	6863      	ldr	r3, [r4, #4]
 800f9e0:	62ab      	str	r3, [r5, #40]	; 0x28
                       Data->TransferDir   |\
 800f9e2:	6926      	ldr	r6, [r4, #16]
                       Data->TransferMode  |\
 800f9e4:	6961      	ldr	r1, [r4, #20]
  tmpreg |= (uint32_t)(Data->DataBlockSize |\
 800f9e6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 800f9ea:	4313      	orrs	r3, r2
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800f9ec:	6aea      	ldr	r2, [r5, #44]	; 0x2c
                       Data->TransferDir   |\
 800f9ee:	4333      	orrs	r3, r6
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800f9f0:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
                       Data->TransferMode  |\
 800f9f4:	430b      	orrs	r3, r1
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, tmpreg);
 800f9f6:	4313      	orrs	r3, r2
 800f9f8:	62eb      	str	r3, [r5, #44]	; 0x2c
}
 800f9fa:	bd70      	pop	{r4, r5, r6, pc}
  assert_param(IS_SDMMC_DATA_LENGTH(Data->DataLength));
 800f9fc:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800fa00:	f240 11ad 	movw	r1, #429	; 0x1ad
 800fa04:	f6c0 0002 	movt	r0, #2050	; 0x802
 800fa08:	f005 ff2e 	bl	8015868 <assert_failed>
 800fa0c:	e7b7      	b.n	800f97e <SDMMC_ConfigData+0xe>
  assert_param(IS_SDMMC_TRANSFER_MODE(Data->TransferMode));
 800fa0e:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800fa12:	f44f 71d8 	mov.w	r1, #432	; 0x1b0
 800fa16:	f6c0 0002 	movt	r0, #2050	; 0x802
 800fa1a:	f005 ff25 	bl	8015868 <assert_failed>
 800fa1e:	e7d0      	b.n	800f9c2 <SDMMC_ConfigData+0x52>
  assert_param(IS_SDMMC_TRANSFER_DIR(Data->TransferDir));
 800fa20:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800fa24:	f240 11af 	movw	r1, #431	; 0x1af
 800fa28:	f6c0 0002 	movt	r0, #2050	; 0x802
 800fa2c:	f005 ff1c 	bl	8015868 <assert_failed>
 800fa30:	e7c3      	b.n	800f9ba <SDMMC_ConfigData+0x4a>
  assert_param(IS_SDMMC_BLOCK_SIZE(Data->DataBlockSize));
 800fa32:	f64d 50dc 	movw	r0, #56796	; 0xdddc
 800fa36:	f44f 71d7 	mov.w	r1, #430	; 0x1ae
 800fa3a:	f6c0 0002 	movt	r0, #2050	; 0x802
 800fa3e:	f005 ff13 	bl	8015868 <assert_failed>
 800fa42:	e7b6      	b.n	800f9b2 <SDMMC_ConfigData+0x42>

0800fa44 <SDMMC_CmdBlockLength>:
{
 800fa44:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa46:	f240 25b0 	movw	r5, #688	; 0x2b0
 800fa4a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fa4e:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fa52:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa54:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800fa58:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fa5c:	68c1      	ldr	r1, [r0, #12]
 800fa5e:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa62:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fa64:	f241 1510 	movw	r5, #4368	; 0x1110
 800fa68:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fa6a:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa6c:	fba3 3202 	umull	r3, r2, r3, r2
 800fa70:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fa74:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fa76:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa7a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fa7c:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fa7e:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800fa82:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fa86:	d314      	bcc.n	800fab2 <SDMMC_CmdBlockLength+0x6e>
    sta_reg = SDMMCx->STA;
 800fa88:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fa8a:	420a      	tst	r2, r1
 800fa8c:	d0f9      	beq.n	800fa82 <SDMMC_CmdBlockLength+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fa8e:	0494      	lsls	r4, r2, #18
 800fa90:	d4f7      	bmi.n	800fa82 <SDMMC_CmdBlockLength+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fa92:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fa94:	075a      	lsls	r2, r3, #29
 800fa96:	d410      	bmi.n	800faba <SDMMC_CmdBlockLength+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fa98:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fa9a:	07db      	lsls	r3, r3, #31
 800fa9c:	d411      	bmi.n	800fac2 <SDMMC_CmdBlockLength+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fa9e:	23c5      	movs	r3, #197	; 0xc5
 800faa0:	f2c0 0320 	movt	r3, #32
 800faa4:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800faa6:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800faa8:	b2db      	uxtb	r3, r3
 800faaa:	2b10      	cmp	r3, #16
 800faac:	d00d      	beq.n	800faca <SDMMC_CmdBlockLength+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800faae:	2001      	movs	r0, #1
  return errorstate;
 800fab0:	e001      	b.n	800fab6 <SDMMC_CmdBlockLength+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fab2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fab6:	bc30      	pop	{r4, r5}
 800fab8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800faba:	2304      	movs	r3, #4
 800fabc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fabe:	4618      	mov	r0, r3
 800fac0:	e7f9      	b.n	800fab6 <SDMMC_CmdBlockLength+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fac2:	2301      	movs	r3, #1
 800fac4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fac6:	4618      	mov	r0, r3
 800fac8:	e7f5      	b.n	800fab6 <SDMMC_CmdBlockLength+0x72>
}
 800faca:	bc30      	pop	{r4, r5}
 800facc:	f7ff be52 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fad0 <SDMMC_CmdReadSingleBlock>:
{
 800fad0:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fad2:	f240 25b0 	movw	r5, #688	; 0x2b0
 800fad6:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fada:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fade:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fae0:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800fae4:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fae8:	68c1      	ldr	r1, [r0, #12]
 800faea:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800faee:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800faf0:	f241 1511 	movw	r5, #4369	; 0x1111
 800faf4:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800faf6:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800faf8:	fba3 3202 	umull	r3, r2, r3, r2
 800fafc:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb00:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fb02:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb06:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb08:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb0a:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800fb0e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fb12:	d314      	bcc.n	800fb3e <SDMMC_CmdReadSingleBlock+0x6e>
    sta_reg = SDMMCx->STA;
 800fb14:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fb16:	420a      	tst	r2, r1
 800fb18:	d0f9      	beq.n	800fb0e <SDMMC_CmdReadSingleBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fb1a:	0494      	lsls	r4, r2, #18
 800fb1c:	d4f7      	bmi.n	800fb0e <SDMMC_CmdReadSingleBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fb1e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fb20:	075a      	lsls	r2, r3, #29
 800fb22:	d410      	bmi.n	800fb46 <SDMMC_CmdReadSingleBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fb24:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fb26:	07db      	lsls	r3, r3, #31
 800fb28:	d411      	bmi.n	800fb4e <SDMMC_CmdReadSingleBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fb2a:	23c5      	movs	r3, #197	; 0xc5
 800fb2c:	f2c0 0320 	movt	r3, #32
 800fb30:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fb32:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fb34:	b2db      	uxtb	r3, r3
 800fb36:	2b11      	cmp	r3, #17
 800fb38:	d00d      	beq.n	800fb56 <SDMMC_CmdReadSingleBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fb3a:	2001      	movs	r0, #1
  return errorstate;
 800fb3c:	e001      	b.n	800fb42 <SDMMC_CmdReadSingleBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fb3e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fb42:	bc30      	pop	{r4, r5}
 800fb44:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fb46:	2304      	movs	r3, #4
 800fb48:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fb4a:	4618      	mov	r0, r3
 800fb4c:	e7f9      	b.n	800fb42 <SDMMC_CmdReadSingleBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fb4e:	2301      	movs	r3, #1
 800fb50:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fb52:	4618      	mov	r0, r3
 800fb54:	e7f5      	b.n	800fb42 <SDMMC_CmdReadSingleBlock+0x72>
}
 800fb56:	bc30      	pop	{r4, r5}
 800fb58:	f7ff be0c 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fb5c <SDMMC_CmdReadMultiBlock>:
{
 800fb5c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb5e:	f240 25b0 	movw	r5, #688	; 0x2b0
 800fb62:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb66:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fb6a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb6c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800fb70:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb74:	68c1      	ldr	r1, [r0, #12]
 800fb76:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb7a:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb7c:	f241 1512 	movw	r5, #4370	; 0x1112
 800fb80:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fb82:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb84:	fba3 3202 	umull	r3, r2, r3, r2
 800fb88:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb8c:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fb8e:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb92:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fb94:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fb96:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800fb9a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fb9e:	d314      	bcc.n	800fbca <SDMMC_CmdReadMultiBlock+0x6e>
    sta_reg = SDMMCx->STA;
 800fba0:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fba2:	420a      	tst	r2, r1
 800fba4:	d0f9      	beq.n	800fb9a <SDMMC_CmdReadMultiBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fba6:	0494      	lsls	r4, r2, #18
 800fba8:	d4f7      	bmi.n	800fb9a <SDMMC_CmdReadMultiBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fbaa:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fbac:	075a      	lsls	r2, r3, #29
 800fbae:	d410      	bmi.n	800fbd2 <SDMMC_CmdReadMultiBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fbb0:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fbb2:	07db      	lsls	r3, r3, #31
 800fbb4:	d411      	bmi.n	800fbda <SDMMC_CmdReadMultiBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fbb6:	23c5      	movs	r3, #197	; 0xc5
 800fbb8:	f2c0 0320 	movt	r3, #32
 800fbbc:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fbbe:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fbc0:	b2db      	uxtb	r3, r3
 800fbc2:	2b12      	cmp	r3, #18
 800fbc4:	d00d      	beq.n	800fbe2 <SDMMC_CmdReadMultiBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fbc6:	2001      	movs	r0, #1
  return errorstate;
 800fbc8:	e001      	b.n	800fbce <SDMMC_CmdReadMultiBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fbca:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fbce:	bc30      	pop	{r4, r5}
 800fbd0:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fbd2:	2304      	movs	r3, #4
 800fbd4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fbd6:	4618      	mov	r0, r3
 800fbd8:	e7f9      	b.n	800fbce <SDMMC_CmdReadMultiBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fbda:	2301      	movs	r3, #1
 800fbdc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fbde:	4618      	mov	r0, r3
 800fbe0:	e7f5      	b.n	800fbce <SDMMC_CmdReadMultiBlock+0x72>
}
 800fbe2:	bc30      	pop	{r4, r5}
 800fbe4:	f7ff bdc6 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fbe8 <SDMMC_CmdWriteSingleBlock>:
{
 800fbe8:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fbea:	f240 25b0 	movw	r5, #688	; 0x2b0
 800fbee:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fbf2:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fbf6:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fbf8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800fbfc:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc00:	68c1      	ldr	r1, [r0, #12]
 800fc02:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc06:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc08:	f241 1518 	movw	r5, #4376	; 0x1118
 800fc0c:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fc0e:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc10:	fba3 3202 	umull	r3, r2, r3, r2
 800fc14:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc18:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fc1a:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc1e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc20:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc22:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800fc26:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fc2a:	d314      	bcc.n	800fc56 <SDMMC_CmdWriteSingleBlock+0x6e>
    sta_reg = SDMMCx->STA;
 800fc2c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fc2e:	420a      	tst	r2, r1
 800fc30:	d0f9      	beq.n	800fc26 <SDMMC_CmdWriteSingleBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fc32:	0494      	lsls	r4, r2, #18
 800fc34:	d4f7      	bmi.n	800fc26 <SDMMC_CmdWriteSingleBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fc36:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fc38:	075a      	lsls	r2, r3, #29
 800fc3a:	d410      	bmi.n	800fc5e <SDMMC_CmdWriteSingleBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fc3c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fc3e:	07db      	lsls	r3, r3, #31
 800fc40:	d411      	bmi.n	800fc66 <SDMMC_CmdWriteSingleBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fc42:	23c5      	movs	r3, #197	; 0xc5
 800fc44:	f2c0 0320 	movt	r3, #32
 800fc48:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fc4a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fc4c:	b2db      	uxtb	r3, r3
 800fc4e:	2b18      	cmp	r3, #24
 800fc50:	d00d      	beq.n	800fc6e <SDMMC_CmdWriteSingleBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fc52:	2001      	movs	r0, #1
  return errorstate;
 800fc54:	e001      	b.n	800fc5a <SDMMC_CmdWriteSingleBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fc56:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fc5a:	bc30      	pop	{r4, r5}
 800fc5c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fc5e:	2304      	movs	r3, #4
 800fc60:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fc62:	4618      	mov	r0, r3
 800fc64:	e7f9      	b.n	800fc5a <SDMMC_CmdWriteSingleBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fc66:	2301      	movs	r3, #1
 800fc68:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fc6a:	4618      	mov	r0, r3
 800fc6c:	e7f5      	b.n	800fc5a <SDMMC_CmdWriteSingleBlock+0x72>
}
 800fc6e:	bc30      	pop	{r4, r5}
 800fc70:	f7ff bd80 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fc74 <SDMMC_CmdWriteMultiBlock>:
{
 800fc74:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc76:	f240 25b0 	movw	r5, #688	; 0x2b0
 800fc7a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc7e:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fc82:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc84:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800fc88:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc8c:	68c1      	ldr	r1, [r0, #12]
 800fc8e:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc92:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fc94:	f241 1519 	movw	r5, #4377	; 0x1119
 800fc98:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fc9a:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fc9c:	fba3 3202 	umull	r3, r2, r3, r2
 800fca0:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fca4:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fca6:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fcaa:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fcac:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fcae:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800fcb2:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fcb6:	d314      	bcc.n	800fce2 <SDMMC_CmdWriteMultiBlock+0x6e>
    sta_reg = SDMMCx->STA;
 800fcb8:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fcba:	420a      	tst	r2, r1
 800fcbc:	d0f9      	beq.n	800fcb2 <SDMMC_CmdWriteMultiBlock+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fcbe:	0494      	lsls	r4, r2, #18
 800fcc0:	d4f7      	bmi.n	800fcb2 <SDMMC_CmdWriteMultiBlock+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fcc2:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fcc4:	075a      	lsls	r2, r3, #29
 800fcc6:	d410      	bmi.n	800fcea <SDMMC_CmdWriteMultiBlock+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fcc8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fcca:	07db      	lsls	r3, r3, #31
 800fccc:	d411      	bmi.n	800fcf2 <SDMMC_CmdWriteMultiBlock+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fcce:	23c5      	movs	r3, #197	; 0xc5
 800fcd0:	f2c0 0320 	movt	r3, #32
 800fcd4:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fcd6:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fcd8:	b2db      	uxtb	r3, r3
 800fcda:	2b19      	cmp	r3, #25
 800fcdc:	d00d      	beq.n	800fcfa <SDMMC_CmdWriteMultiBlock+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fcde:	2001      	movs	r0, #1
  return errorstate;
 800fce0:	e001      	b.n	800fce6 <SDMMC_CmdWriteMultiBlock+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fce2:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fce6:	bc30      	pop	{r4, r5}
 800fce8:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fcea:	2304      	movs	r3, #4
 800fcec:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fcee:	4618      	mov	r0, r3
 800fcf0:	e7f9      	b.n	800fce6 <SDMMC_CmdWriteMultiBlock+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fcf2:	2301      	movs	r3, #1
 800fcf4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fcf6:	4618      	mov	r0, r3
 800fcf8:	e7f5      	b.n	800fce6 <SDMMC_CmdWriteMultiBlock+0x72>
}
 800fcfa:	bc30      	pop	{r4, r5}
 800fcfc:	f7ff bd3a 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fd00 <SDMMC_CmdStopTransfer>:
{
 800fd00:	b570      	push	{r4, r5, r6, lr}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd02:	f240 25b0 	movw	r5, #688	; 0x2b0
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800fd06:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd08:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  SDMMCx->ARG = Command->Argument;
 800fd0c:	2600      	movs	r6, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd0e:	f2c2 0500 	movt	r5, #8192	; 0x2000
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800fd12:	f041 0180 	orr.w	r1, r1, #128	; 0x80
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd16:	f2c1 0262 	movt	r2, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd1a:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  __SDMMC_CMDSTOP_ENABLE(SDMMCx);
 800fd1e:	60c1      	str	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd20:	682b      	ldr	r3, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd22:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800fd26:	68c1      	ldr	r1, [r0, #12]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd28:	f241 150c 	movw	r5, #4364	; 0x110c
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd2c:	fba2 2303 	umull	r2, r3, r2, r3
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800fd30:	f021 0140 	bic.w	r1, r1, #64	; 0x40
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd34:	0a5a      	lsrs	r2, r3, #9
 800fd36:	f44f 4361 	mov.w	r3, #57600	; 0xe100
  __SDMMC_CMDTRANS_DISABLE(SDMMCx);
 800fd3a:	60c1      	str	r1, [r0, #12]
  SDMMCx->ARG = Command->Argument;
 800fd3c:	6086      	str	r6, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd3e:	f2c0 53f5 	movt	r3, #1525	; 0x5f5
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd42:	68c1      	ldr	r1, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fd44:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd48:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fd4a:	2145      	movs	r1, #69	; 0x45
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd4c:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fd4e:	f2c0 0120 	movt	r1, #32
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fd52:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 800fd54:	b1d3      	cbz	r3, 800fd8c <SDMMC_CmdStopTransfer+0x8c>
    sta_reg = SDMMCx->STA;
 800fd56:	6b42      	ldr	r2, [r0, #52]	; 0x34
 800fd58:	3b01      	subs	r3, #1
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fd5a:	420a      	tst	r2, r1
 800fd5c:	d0fa      	beq.n	800fd54 <SDMMC_CmdStopTransfer+0x54>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fd5e:	0492      	lsls	r2, r2, #18
 800fd60:	d4f8      	bmi.n	800fd54 <SDMMC_CmdStopTransfer+0x54>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fd62:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fd64:	075b      	lsls	r3, r3, #29
 800fd66:	d419      	bmi.n	800fd9c <SDMMC_CmdStopTransfer+0x9c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fd68:	6b44      	ldr	r4, [r0, #52]	; 0x34
 800fd6a:	f014 0401 	ands.w	r4, r4, #1
 800fd6e:	d11c      	bne.n	800fdaa <SDMMC_CmdStopTransfer+0xaa>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fd70:	23c5      	movs	r3, #197	; 0xc5
 800fd72:	f2c0 0320 	movt	r3, #32
 800fd76:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fd78:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fd7a:	b2db      	uxtb	r3, r3
 800fd7c:	2b0c      	cmp	r3, #12
 800fd7e:	d01b      	beq.n	800fdb8 <SDMMC_CmdStopTransfer+0xb8>
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fd80:	68c3      	ldr	r3, [r0, #12]
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fd82:	2401      	movs	r4, #1
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fd84:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fd88:	60c3      	str	r3, [r0, #12]
 800fd8a:	e005      	b.n	800fd98 <SDMMC_CmdStopTransfer+0x98>
 800fd8c:	68c3      	ldr	r3, [r0, #12]
      return SDMMC_ERROR_TIMEOUT;
 800fd8e:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fd92:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fd96:	60c3      	str	r3, [r0, #12]
}
 800fd98:	4620      	mov	r0, r4
 800fd9a:	bd70      	pop	{r4, r5, r6, pc}
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fd9c:	2404      	movs	r4, #4
 800fd9e:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fda0:	68c3      	ldr	r3, [r0, #12]
 800fda2:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fda6:	60c3      	str	r3, [r0, #12]
 800fda8:	e7f6      	b.n	800fd98 <SDMMC_CmdStopTransfer+0x98>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fdaa:	2401      	movs	r4, #1
 800fdac:	6384      	str	r4, [r0, #56]	; 0x38
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fdae:	68c3      	ldr	r3, [r0, #12]
 800fdb0:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fdb4:	60c3      	str	r3, [r0, #12]
 800fdb6:	e7ef      	b.n	800fd98 <SDMMC_CmdStopTransfer+0x98>
 800fdb8:	4605      	mov	r5, r0
 800fdba:	f7ff fcdb 	bl	800f774 <SDMMC_GetCmdResp1.part.2>
  if (errorstate == SDMMC_ERROR_ADDR_OUT_OF_RANGE)
 800fdbe:	f1b0 7f00 	cmp.w	r0, #33554432	; 0x2000000
 800fdc2:	bf18      	it	ne
 800fdc4:	4604      	movne	r4, r0
  __SDMMC_CMDSTOP_DISABLE(SDMMCx);
 800fdc6:	68eb      	ldr	r3, [r5, #12]
 800fdc8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800fdcc:	60eb      	str	r3, [r5, #12]
 800fdce:	e7e3      	b.n	800fd98 <SDMMC_CmdStopTransfer+0x98>

0800fdd0 <SDMMC_CmdSelDesel>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fdd0:	f240 21b0 	movw	r1, #688	; 0x2b0
 800fdd4:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800fdd8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 800fddc:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
 800fde0:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 800fde2:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fde4:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fde8:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fdea:	f241 1507 	movw	r5, #4359	; 0x1107
 800fdee:	68c1      	ldr	r1, [r0, #12]
 800fdf0:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fdf4:	fba3 3202 	umull	r3, r2, r3, r2
 800fdf8:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fdfc:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fdfe:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fe00:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe02:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fe04:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800fe08:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe0c:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 800fe0e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fe12:	d314      	bcc.n	800fe3e <SDMMC_CmdSelDesel+0x6e>
    sta_reg = SDMMCx->STA;
 800fe14:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800fe16:	420a      	tst	r2, r1
 800fe18:	d0f9      	beq.n	800fe0e <SDMMC_CmdSelDesel+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800fe1a:	0494      	lsls	r4, r2, #18
 800fe1c:	d4f7      	bmi.n	800fe0e <SDMMC_CmdSelDesel+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800fe1e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fe20:	075a      	lsls	r2, r3, #29
 800fe22:	d410      	bmi.n	800fe46 <SDMMC_CmdSelDesel+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800fe24:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800fe26:	07db      	lsls	r3, r3, #31
 800fe28:	d411      	bmi.n	800fe4e <SDMMC_CmdSelDesel+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800fe2a:	23c5      	movs	r3, #197	; 0xc5
 800fe2c:	f2c0 0320 	movt	r3, #32
 800fe30:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800fe32:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800fe34:	b2db      	uxtb	r3, r3
 800fe36:	2b07      	cmp	r3, #7
 800fe38:	d00d      	beq.n	800fe56 <SDMMC_CmdSelDesel+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fe3a:	2001      	movs	r0, #1
  return errorstate;
 800fe3c:	e001      	b.n	800fe42 <SDMMC_CmdSelDesel+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800fe3e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fe42:	bc30      	pop	{r4, r5}
 800fe44:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800fe46:	2304      	movs	r3, #4
 800fe48:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800fe4a:	4618      	mov	r0, r3
 800fe4c:	e7f9      	b.n	800fe42 <SDMMC_CmdSelDesel+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800fe4e:	2301      	movs	r3, #1
 800fe50:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800fe52:	4618      	mov	r0, r3
 800fe54:	e7f5      	b.n	800fe42 <SDMMC_CmdSelDesel+0x72>
}
 800fe56:	bc30      	pop	{r4, r5}
 800fe58:	f7ff bc8c 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800fe5c <SDMMC_CmdGoIdleState>:
{
 800fe5c:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe5e:	f240 24b0 	movw	r4, #688	; 0x2b0
{
 800fe62:	4602      	mov	r2, r0
  SDMMCx->ARG = Command->Argument;
 800fe64:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe66:	f644 55d3 	movw	r5, #19923	; 0x4dd3
 800fe6a:	f2c2 0400 	movt	r4, #8192	; 0x2000
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe6e:	f24e 01c0 	movw	r1, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fe72:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe74:	f2c1 0562 	movt	r5, #4194	; 0x1062
 800fe78:	6820      	ldr	r0, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe7a:	f6cf 71fe 	movt	r1, #65534	; 0xfffe
 800fe7e:	68d4      	ldr	r4, [r2, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe80:	f241 3388 	movw	r3, #5000	; 0x1388
 800fe84:	fba5 5000 	umull	r5, r0, r5, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe88:	4021      	ands	r1, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe8a:	0a40      	lsrs	r0, r0, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe8c:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fe90:	fb03 f300 	mul.w	r3, r3, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fe94:	60d1      	str	r1, [r2, #12]
 800fe96:	e002      	b.n	800fe9e <SDMMC_CmdGoIdleState+0x42>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 800fe98:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800fe9a:	0609      	lsls	r1, r1, #24
 800fe9c:	d406      	bmi.n	800feac <SDMMC_CmdGoIdleState+0x50>
    if (count-- == 0U)
 800fe9e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fea2:	d2f9      	bcs.n	800fe98 <SDMMC_CmdGoIdleState+0x3c>
      return SDMMC_ERROR_TIMEOUT;
 800fea4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800fea8:	bc30      	pop	{r4, r5}
 800feaa:	4770      	bx	lr
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800feac:	23c5      	movs	r3, #197	; 0xc5
  return SDMMC_ERROR_NONE;
 800feae:	2000      	movs	r0, #0
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800feb0:	f2c0 0320 	movt	r3, #32
 800feb4:	6393      	str	r3, [r2, #56]	; 0x38
}
 800feb6:	bc30      	pop	{r4, r5}
 800feb8:	4770      	bx	lr
 800feba:	bf00      	nop

0800febc <SDMMC_CmdOperCond>:
{
 800febc:	b430      	push	{r4, r5}
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  uint32_t sta_reg;
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800febe:	f240 24b0 	movw	r4, #688	; 0x2b0
{
 800fec2:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
 800fec4:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fec8:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 800fecc:	f2c2 0400 	movt	r4, #8192	; 0x2000
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fed0:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800fed4:	608a      	str	r2, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fed6:	f2c1 0362 	movt	r3, #4194	; 0x1062
 800feda:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fedc:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
 800fee0:	68cd      	ldr	r5, [r1, #12]
 800fee2:	f241 1408 	movw	r4, #4360	; 0x1108
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fee6:	fba3 3202 	umull	r3, r2, r3, r2
 800feea:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800feee:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fef0:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fef2:	4304      	orrs	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fef4:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fef8:	60cc      	str	r4, [r1, #12]

  do
  {
    if (count-- == 0U)
 800fefa:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800fefe:	d313      	bcc.n	800ff28 <SDMMC_CmdOperCond+0x6c>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    sta_reg = SDMMCx->STA;
 800ff00:	6b4a      	ldr	r2, [r1, #52]	; 0x34
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800ff02:	f012 0f45 	tst.w	r2, #69	; 0x45
 800ff06:	d0f8      	beq.n	800fefa <SDMMC_CmdOperCond+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 800ff08:	0492      	lsls	r2, r2, #18
 800ff0a:	d4f6      	bmi.n	800fefa <SDMMC_CmdOperCond+0x3e>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800ff0c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800ff0e:	075b      	lsls	r3, r3, #29
 800ff10:	d40e      	bmi.n	800ff30 <SDMMC_CmdOperCond+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);

    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }

  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800ff12:	6b48      	ldr	r0, [r1, #52]	; 0x34
 800ff14:	f010 0001 	ands.w	r0, r0, #1
 800ff18:	d10d      	bne.n	800ff36 <SDMMC_CmdOperCond+0x7a>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800ff1a:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800ff1c:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 800ff20:	d00c      	beq.n	800ff3c <SDMMC_CmdOperCond+0x80>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 800ff22:	2340      	movs	r3, #64	; 0x40
 800ff24:	638b      	str	r3, [r1, #56]	; 0x38
 800ff26:	e001      	b.n	800ff2c <SDMMC_CmdOperCond+0x70>
      return SDMMC_ERROR_TIMEOUT;
 800ff28:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800ff2c:	bc30      	pop	{r4, r5}
 800ff2e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800ff30:	2004      	movs	r0, #4
 800ff32:	6388      	str	r0, [r1, #56]	; 0x38
 800ff34:	e7fa      	b.n	800ff2c <SDMMC_CmdOperCond+0x70>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800ff36:	2001      	movs	r0, #1
 800ff38:	6388      	str	r0, [r1, #56]	; 0x38
 800ff3a:	e7f7      	b.n	800ff2c <SDMMC_CmdOperCond+0x70>
  }

  return SDMMC_ERROR_NONE;
 800ff3c:	4618      	mov	r0, r3
  return errorstate;
 800ff3e:	e7f5      	b.n	800ff2c <SDMMC_CmdOperCond+0x70>

0800ff40 <SDMMC_CmdAppCommand>:
{
 800ff40:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff42:	f240 25b0 	movw	r5, #688	; 0x2b0
 800ff46:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ff4a:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 800ff4e:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff50:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800ff54:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ff58:	68c1      	ldr	r1, [r0, #12]
 800ff5a:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff5e:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ff60:	f241 1537 	movw	r5, #4407	; 0x1137
 800ff64:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800ff66:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff68:	fba3 3202 	umull	r3, r2, r3, r2
 800ff6c:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ff70:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800ff72:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff76:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ff78:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 800ff7a:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 800ff7e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 800ff82:	d314      	bcc.n	800ffae <SDMMC_CmdAppCommand+0x6e>
    sta_reg = SDMMCx->STA;
 800ff84:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 800ff86:	420a      	tst	r2, r1
 800ff88:	d0f9      	beq.n	800ff7e <SDMMC_CmdAppCommand+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 800ff8a:	0494      	lsls	r4, r2, #18
 800ff8c:	d4f7      	bmi.n	800ff7e <SDMMC_CmdAppCommand+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800ff8e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800ff90:	075a      	lsls	r2, r3, #29
 800ff92:	d410      	bmi.n	800ffb6 <SDMMC_CmdAppCommand+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800ff94:	6b43      	ldr	r3, [r0, #52]	; 0x34
 800ff96:	07db      	lsls	r3, r3, #31
 800ff98:	d411      	bmi.n	800ffbe <SDMMC_CmdAppCommand+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800ff9a:	23c5      	movs	r3, #197	; 0xc5
 800ff9c:	f2c0 0320 	movt	r3, #32
 800ffa0:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 800ffa2:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 800ffa4:	b2db      	uxtb	r3, r3
 800ffa6:	2b37      	cmp	r3, #55	; 0x37
 800ffa8:	d00d      	beq.n	800ffc6 <SDMMC_CmdAppCommand+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800ffaa:	2001      	movs	r0, #1
  return errorstate;
 800ffac:	e001      	b.n	800ffb2 <SDMMC_CmdAppCommand+0x72>
      return SDMMC_ERROR_TIMEOUT;
 800ffae:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 800ffb2:	bc30      	pop	{r4, r5}
 800ffb4:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 800ffb6:	2304      	movs	r3, #4
 800ffb8:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 800ffba:	4618      	mov	r0, r3
 800ffbc:	e7f9      	b.n	800ffb2 <SDMMC_CmdAppCommand+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 800ffbe:	2301      	movs	r3, #1
 800ffc0:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 800ffc2:	4618      	mov	r0, r3
 800ffc4:	e7f5      	b.n	800ffb2 <SDMMC_CmdAppCommand+0x72>
}
 800ffc6:	bc30      	pop	{r4, r5}
 800ffc8:	f7ff bbd4 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

0800ffcc <SDMMC_CmdAppOperCommand>:
{
 800ffcc:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ffce:	f240 25b0 	movw	r5, #688	; 0x2b0
 800ffd2:	f644 53d3 	movw	r3, #19923	; 0x4dd3
{
 800ffd6:	4604      	mov	r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ffd8:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ffdc:	f2c2 0500 	movt	r5, #8192	; 0x2000
 800ffe0:	f2c1 0362 	movt	r3, #4194	; 0x1062
  SDMMCx->ARG = Command->Argument;
 800ffe4:	60a1      	str	r1, [r4, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ffe6:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800ffea:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800ffec:	f241 1129 	movw	r1, #4393	; 0x1129
 800fff0:	68e5      	ldr	r5, [r4, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fff2:	fba3 3202 	umull	r3, r2, r3, r2
 800fff6:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fffa:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800fffc:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 800fffe:	4301      	orrs	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010000:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010004:	60e1      	str	r1, [r4, #12]
    if (count-- == 0U)
 8010006:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 801000a:	d30f      	bcc.n	801002c <SDMMC_CmdAppOperCommand+0x60>
    sta_reg = SDMMCx->STA;
 801000c:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 801000e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8010012:	d0f8      	beq.n	8010006 <SDMMC_CmdAppOperCommand+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8010014:	0492      	lsls	r2, r2, #18
 8010016:	d4f6      	bmi.n	8010006 <SDMMC_CmdAppOperCommand+0x3a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010018:	6b60      	ldr	r0, [r4, #52]	; 0x34
 801001a:	f010 0004 	ands.w	r0, r0, #4
 801001e:	d109      	bne.n	8010034 <SDMMC_CmdAppOperCommand+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8010020:	23c5      	movs	r3, #197	; 0xc5
 8010022:	f2c0 0320 	movt	r3, #32
 8010026:	63a3      	str	r3, [r4, #56]	; 0x38
}
 8010028:	bc30      	pop	{r4, r5}
 801002a:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 801002c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8010030:	bc30      	pop	{r4, r5}
 8010032:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8010034:	2004      	movs	r0, #4
 8010036:	63a0      	str	r0, [r4, #56]	; 0x38
 8010038:	e7fa      	b.n	8010030 <SDMMC_CmdAppOperCommand+0x64>
 801003a:	bf00      	nop

0801003c <SDMMC_CmdBusWidth>:
{
 801003c:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801003e:	f240 25b0 	movw	r5, #688	; 0x2b0
 8010042:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010046:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 801004a:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801004c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8010050:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010054:	68c1      	ldr	r1, [r0, #12]
 8010056:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801005a:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801005c:	f241 1506 	movw	r5, #4358	; 0x1106
 8010060:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010062:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010064:	fba3 3202 	umull	r3, r2, r3, r2
 8010068:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801006c:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 801006e:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010072:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010074:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010076:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 801007a:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 801007e:	d314      	bcc.n	80100aa <SDMMC_CmdBusWidth+0x6e>
    sta_reg = SDMMCx->STA;
 8010080:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8010082:	420a      	tst	r2, r1
 8010084:	d0f9      	beq.n	801007a <SDMMC_CmdBusWidth+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010086:	0494      	lsls	r4, r2, #18
 8010088:	d4f7      	bmi.n	801007a <SDMMC_CmdBusWidth+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 801008a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801008c:	075a      	lsls	r2, r3, #29
 801008e:	d410      	bmi.n	80100b2 <SDMMC_CmdBusWidth+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8010090:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8010092:	07db      	lsls	r3, r3, #31
 8010094:	d411      	bmi.n	80100ba <SDMMC_CmdBusWidth+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8010096:	23c5      	movs	r3, #197	; 0xc5
 8010098:	f2c0 0320 	movt	r3, #32
 801009c:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801009e:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80100a0:	b2db      	uxtb	r3, r3
 80100a2:	2b06      	cmp	r3, #6
 80100a4:	d00d      	beq.n	80100c2 <SDMMC_CmdBusWidth+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80100a6:	2001      	movs	r0, #1
  return errorstate;
 80100a8:	e001      	b.n	80100ae <SDMMC_CmdBusWidth+0x72>
      return SDMMC_ERROR_TIMEOUT;
 80100aa:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80100ae:	bc30      	pop	{r4, r5}
 80100b0:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80100b2:	2304      	movs	r3, #4
 80100b4:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80100b6:	4618      	mov	r0, r3
 80100b8:	e7f9      	b.n	80100ae <SDMMC_CmdBusWidth+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80100ba:	2301      	movs	r3, #1
 80100bc:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80100be:	4618      	mov	r0, r3
 80100c0:	e7f5      	b.n	80100ae <SDMMC_CmdBusWidth+0x72>
}
 80100c2:	bc30      	pop	{r4, r5}
 80100c4:	f7ff bb56 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

080100c8 <SDMMC_CmdSendSCR>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80100c8:	f240 21b0 	movw	r1, #688	; 0x2b0
  SDMMCx->ARG = Command->Argument;
 80100cc:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80100ce:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 80100d2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80100d6:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
 80100da:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 80100dc:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80100de:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80100e2:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80100e4:	f241 1533 	movw	r5, #4403	; 0x1133
 80100e8:	68c1      	ldr	r1, [r0, #12]
 80100ea:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80100ee:	fba3 3202 	umull	r3, r2, r3, r2
 80100f2:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80100f6:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 80100f8:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80100fa:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80100fc:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 80100fe:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010102:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010106:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 8010108:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 801010c:	d314      	bcc.n	8010138 <SDMMC_CmdSendSCR+0x70>
    sta_reg = SDMMCx->STA;
 801010e:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8010110:	420a      	tst	r2, r1
 8010112:	d0f9      	beq.n	8010108 <SDMMC_CmdSendSCR+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010114:	0494      	lsls	r4, r2, #18
 8010116:	d4f7      	bmi.n	8010108 <SDMMC_CmdSendSCR+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010118:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801011a:	075a      	lsls	r2, r3, #29
 801011c:	d410      	bmi.n	8010140 <SDMMC_CmdSendSCR+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801011e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8010120:	07db      	lsls	r3, r3, #31
 8010122:	d411      	bmi.n	8010148 <SDMMC_CmdSendSCR+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8010124:	23c5      	movs	r3, #197	; 0xc5
 8010126:	f2c0 0320 	movt	r3, #32
 801012a:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801012c:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801012e:	b2db      	uxtb	r3, r3
 8010130:	2b33      	cmp	r3, #51	; 0x33
 8010132:	d00d      	beq.n	8010150 <SDMMC_CmdSendSCR+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8010134:	2001      	movs	r0, #1
  return errorstate;
 8010136:	e001      	b.n	801013c <SDMMC_CmdSendSCR+0x74>
      return SDMMC_ERROR_TIMEOUT;
 8010138:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 801013c:	bc30      	pop	{r4, r5}
 801013e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8010140:	2304      	movs	r3, #4
 8010142:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8010144:	4618      	mov	r0, r3
 8010146:	e7f9      	b.n	801013c <SDMMC_CmdSendSCR+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8010148:	2301      	movs	r3, #1
 801014a:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801014c:	4618      	mov	r0, r3
 801014e:	e7f5      	b.n	801013c <SDMMC_CmdSendSCR+0x74>
}
 8010150:	bc30      	pop	{r4, r5}
 8010152:	f7ff bb0f 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>
 8010156:	bf00      	nop

08010158 <SDMMC_CmdSendCID>:
{
 8010158:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801015a:	f240 24b0 	movw	r4, #688	; 0x2b0
{
 801015e:	4601      	mov	r1, r0
  SDMMCx->ARG = Command->Argument;
 8010160:	2200      	movs	r2, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010162:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 8010166:	f2c2 0400 	movt	r4, #8192	; 0x2000
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801016a:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 801016e:	608a      	str	r2, [r1, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010170:	f2c1 0362 	movt	r3, #4194	; 0x1062
 8010174:	6822      	ldr	r2, [r4, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010176:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
 801017a:	68cd      	ldr	r5, [r1, #12]
 801017c:	f241 3402 	movw	r4, #4866	; 0x1302
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010180:	fba3 3202 	umull	r3, r2, r3, r2
 8010184:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010188:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801018a:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801018c:	4304      	orrs	r4, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801018e:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010192:	60cc      	str	r4, [r1, #12]
    if (count-- == 0U)
 8010194:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8010198:	d311      	bcc.n	80101be <SDMMC_CmdSendCID+0x66>
    sta_reg = SDMMCx->STA;
 801019a:	6b4a      	ldr	r2, [r1, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 801019c:	f012 0f45 	tst.w	r2, #69	; 0x45
 80101a0:	d0f8      	beq.n	8010194 <SDMMC_CmdSendCID+0x3c>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 80101a2:	0492      	lsls	r2, r2, #18
 80101a4:	d4f6      	bmi.n	8010194 <SDMMC_CmdSendCID+0x3c>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80101a6:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80101a8:	075b      	lsls	r3, r3, #29
 80101aa:	d40c      	bmi.n	80101c6 <SDMMC_CmdSendCID+0x6e>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80101ac:	6b48      	ldr	r0, [r1, #52]	; 0x34
 80101ae:	f010 0001 	ands.w	r0, r0, #1
 80101b2:	d10b      	bne.n	80101cc <SDMMC_CmdSendCID+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80101b4:	23c5      	movs	r3, #197	; 0xc5
 80101b6:	f2c0 0320 	movt	r3, #32
 80101ba:	638b      	str	r3, [r1, #56]	; 0x38
 80101bc:	e001      	b.n	80101c2 <SDMMC_CmdSendCID+0x6a>
      return SDMMC_ERROR_TIMEOUT;
 80101be:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80101c2:	bc30      	pop	{r4, r5}
 80101c4:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80101c6:	2004      	movs	r0, #4
 80101c8:	6388      	str	r0, [r1, #56]	; 0x38
 80101ca:	e7fa      	b.n	80101c2 <SDMMC_CmdSendCID+0x6a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80101cc:	2001      	movs	r0, #1
 80101ce:	6388      	str	r0, [r1, #56]	; 0x38
 80101d0:	e7f7      	b.n	80101c2 <SDMMC_CmdSendCID+0x6a>
 80101d2:	bf00      	nop

080101d4 <SDMMC_CmdSendCSD>:
{
 80101d4:	b430      	push	{r4, r5}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80101d6:	f240 25b0 	movw	r5, #688	; 0x2b0
 80101da:	f644 53d3 	movw	r3, #19923	; 0x4dd3
{
 80101de:	4604      	mov	r4, r0
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80101e0:	f24e 00c0 	movw	r0, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80101e4:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80101e8:	f2c1 0362 	movt	r3, #4194	; 0x1062
  SDMMCx->ARG = Command->Argument;
 80101ec:	60a1      	str	r1, [r4, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80101ee:	f6cf 70fe 	movt	r0, #65534	; 0xfffe
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80101f2:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80101f4:	f241 3109 	movw	r1, #4873	; 0x1309
 80101f8:	68e5      	ldr	r5, [r4, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80101fa:	fba3 3202 	umull	r3, r2, r3, r2
 80101fe:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010202:	4028      	ands	r0, r5
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010204:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010206:	4301      	orrs	r1, r0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010208:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801020c:	60e1      	str	r1, [r4, #12]
    if (count-- == 0U)
 801020e:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8010212:	d311      	bcc.n	8010238 <SDMMC_CmdSendCSD+0x64>
    sta_reg = SDMMCx->STA;
 8010214:	6b62      	ldr	r2, [r4, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 8010216:	f012 0f45 	tst.w	r2, #69	; 0x45
 801021a:	d0f8      	beq.n	801020e <SDMMC_CmdSendCSD+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 801021c:	0492      	lsls	r2, r2, #18
 801021e:	d4f6      	bmi.n	801020e <SDMMC_CmdSendCSD+0x3a>
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010220:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8010222:	075b      	lsls	r3, r3, #29
 8010224:	d40c      	bmi.n	8010240 <SDMMC_CmdSendCSD+0x6c>
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8010226:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8010228:	f010 0001 	ands.w	r0, r0, #1
 801022c:	d10b      	bne.n	8010246 <SDMMC_CmdSendCSD+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 801022e:	23c5      	movs	r3, #197	; 0xc5
 8010230:	f2c0 0320 	movt	r3, #32
 8010234:	63a3      	str	r3, [r4, #56]	; 0x38
 8010236:	e001      	b.n	801023c <SDMMC_CmdSendCSD+0x68>
      return SDMMC_ERROR_TIMEOUT;
 8010238:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 801023c:	bc30      	pop	{r4, r5}
 801023e:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8010240:	2004      	movs	r0, #4
 8010242:	63a0      	str	r0, [r4, #56]	; 0x38
 8010244:	e7fa      	b.n	801023c <SDMMC_CmdSendCSD+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8010246:	2001      	movs	r0, #1
 8010248:	63a0      	str	r0, [r4, #56]	; 0x38
 801024a:	e7f7      	b.n	801023c <SDMMC_CmdSendCSD+0x68>

0801024c <SDMMC_CmdSetRelAdd>:
{
 801024c:	b470      	push	{r4, r5, r6}
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801024e:	f240 25b0 	movw	r5, #688	; 0x2b0
  SDMMCx->ARG = Command->Argument;
 8010252:	2300      	movs	r3, #0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010254:	f644 52d3 	movw	r2, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010258:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 801025c:	f2c2 0500 	movt	r5, #8192	; 0x2000
  SDMMCx->ARG = Command->Argument;
 8010260:	6083      	str	r3, [r0, #8]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010262:	f2c1 0262 	movt	r2, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010266:	68c6      	ldr	r6, [r0, #12]
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010268:	682b      	ldr	r3, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801026a:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
 801026e:	f241 1503 	movw	r5, #4355	; 0x1103
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010272:	fba2 3203 	umull	r3, r2, r2, r3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010276:	4034      	ands	r4, r6
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010278:	f241 3388 	movw	r3, #5000	; 0x1388
 801027c:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801027e:	4325      	orrs	r5, r4
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8010280:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010284:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 8010286:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 801028a:	d311      	bcc.n	80102b0 <SDMMC_CmdSetRelAdd+0x64>
    sta_reg = SDMMCx->STA;
 801028c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 801028e:	f012 0f45 	tst.w	r2, #69	; 0x45
 8010292:	d0f8      	beq.n	8010286 <SDMMC_CmdSetRelAdd+0x3a>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT)) == 0U) ||
 8010294:	0496      	lsls	r6, r2, #18
 8010296:	d4f6      	bmi.n	8010286 <SDMMC_CmdSetRelAdd+0x3a>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010298:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801029a:	075d      	lsls	r5, r3, #29
 801029c:	d40c      	bmi.n	80102b8 <SDMMC_CmdSetRelAdd+0x6c>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801029e:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80102a0:	07dc      	lsls	r4, r3, #31
 80102a2:	d40d      	bmi.n	80102c0 <SDMMC_CmdSetRelAdd+0x74>
  return (uint8_t)(SDMMCx->RESPCMD);
 80102a4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80102a6:	b2db      	uxtb	r3, r3
 80102a8:	2b03      	cmp	r3, #3
 80102aa:	d00d      	beq.n	80102c8 <SDMMC_CmdSetRelAdd+0x7c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80102ac:	2001      	movs	r0, #1
 80102ae:	e001      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>
      return SDMMC_ERROR_TIMEOUT;
 80102b0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80102b4:	bc70      	pop	{r4, r5, r6}
 80102b6:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80102b8:	2304      	movs	r3, #4
 80102ba:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 80102bc:	4618      	mov	r0, r3
 80102be:	e7f9      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 80102c0:	2301      	movs	r3, #1
 80102c2:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80102c4:	4618      	mov	r0, r3
 80102c6:	e7f5      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80102c8:	23c5      	movs	r3, #197	; 0xc5
 80102ca:	f2c0 0320 	movt	r3, #32
 80102ce:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 80102d0:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 80102d2:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 80102d6:	d009      	beq.n	80102ec <SDMMC_CmdSetRelAdd+0xa0>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 80102d8:	045a      	lsls	r2, r3, #17
 80102da:	d40a      	bmi.n	80102f2 <SDMMC_CmdSetRelAdd+0xa6>
    return SDMMC_ERROR_COM_CRC_FAILED;
 80102dc:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 80102e0:	bf0c      	ite	eq
 80102e2:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 80102e6:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 80102ea:	e7e3      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>
    *pRCA = (uint16_t) (response_r1 >> 16);
 80102ec:	0c1b      	lsrs	r3, r3, #16
 80102ee:	800b      	strh	r3, [r1, #0]
 80102f0:	e7e0      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>
    return SDMMC_ERROR_ILLEGAL_CMD;
 80102f2:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80102f6:	e7dd      	b.n	80102b4 <SDMMC_CmdSetRelAdd+0x68>

080102f8 <SDMMC_CmdSendStatus>:
{
 80102f8:	b430      	push	{r4, r5}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80102fa:	f240 25b0 	movw	r5, #688	; 0x2b0
 80102fe:	f644 53d3 	movw	r3, #19923	; 0x4dd3
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010302:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  SDMMCx->ARG = Command->Argument;
 8010306:	6081      	str	r1, [r0, #8]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010308:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801030c:	f2c1 0362 	movt	r3, #4194	; 0x1062
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010310:	68c1      	ldr	r1, [r0, #12]
 8010312:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010316:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010318:	f241 150d 	movw	r5, #4365	; 0x110d
 801031c:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 801031e:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010320:	fba3 3202 	umull	r3, r2, r3, r2
 8010324:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010328:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 801032a:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801032e:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010330:	60c5      	str	r5, [r0, #12]
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010332:	fb03 f302 	mul.w	r3, r3, r2
    if (count-- == 0U)
 8010336:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 801033a:	d314      	bcc.n	8010366 <SDMMC_CmdSendStatus+0x6e>
    sta_reg = SDMMCx->STA;
 801033c:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 801033e:	420a      	tst	r2, r1
 8010340:	d0f9      	beq.n	8010336 <SDMMC_CmdSendStatus+0x3e>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010342:	0494      	lsls	r4, r2, #18
 8010344:	d4f7      	bmi.n	8010336 <SDMMC_CmdSendStatus+0x3e>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010346:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8010348:	075a      	lsls	r2, r3, #29
 801034a:	d410      	bmi.n	801036e <SDMMC_CmdSendStatus+0x76>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801034c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801034e:	07db      	lsls	r3, r3, #31
 8010350:	d411      	bmi.n	8010376 <SDMMC_CmdSendStatus+0x7e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8010352:	23c5      	movs	r3, #197	; 0xc5
 8010354:	f2c0 0320 	movt	r3, #32
 8010358:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 801035a:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801035c:	b2db      	uxtb	r3, r3
 801035e:	2b0d      	cmp	r3, #13
 8010360:	d00d      	beq.n	801037e <SDMMC_CmdSendStatus+0x86>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8010362:	2001      	movs	r0, #1
  return errorstate;
 8010364:	e001      	b.n	801036a <SDMMC_CmdSendStatus+0x72>
      return SDMMC_ERROR_TIMEOUT;
 8010366:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 801036a:	bc30      	pop	{r4, r5}
 801036c:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801036e:	2304      	movs	r3, #4
 8010370:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8010372:	4618      	mov	r0, r3
 8010374:	e7f9      	b.n	801036a <SDMMC_CmdSendStatus+0x72>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8010376:	2301      	movs	r3, #1
 8010378:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 801037a:	4618      	mov	r0, r3
 801037c:	e7f5      	b.n	801036a <SDMMC_CmdSendStatus+0x72>
}
 801037e:	bc30      	pop	{r4, r5}
 8010380:	f7ff b9f8 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>

08010384 <SDMMC_CmdStatusRegister>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010384:	f240 21b0 	movw	r1, #688	; 0x2b0
  SDMMCx->ARG = Command->Argument;
 8010388:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801038a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 801038e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8010392:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
 8010396:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 8010398:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801039a:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801039e:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80103a0:	f241 150d 	movw	r5, #4365	; 0x110d
 80103a4:	68c1      	ldr	r1, [r0, #12]
 80103a6:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80103aa:	fba3 3202 	umull	r3, r2, r3, r2
 80103ae:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80103b2:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 80103b4:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80103b6:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80103b8:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 80103ba:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 80103be:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 80103c2:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 80103c4:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 80103c8:	d314      	bcc.n	80103f4 <SDMMC_CmdStatusRegister+0x70>
    sta_reg = SDMMCx->STA;
 80103ca:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 80103cc:	420a      	tst	r2, r1
 80103ce:	d0f9      	beq.n	80103c4 <SDMMC_CmdStatusRegister+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 80103d0:	0494      	lsls	r4, r2, #18
 80103d2:	d4f7      	bmi.n	80103c4 <SDMMC_CmdStatusRegister+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 80103d4:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80103d6:	075a      	lsls	r2, r3, #29
 80103d8:	d410      	bmi.n	80103fc <SDMMC_CmdStatusRegister+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 80103da:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80103dc:	07db      	lsls	r3, r3, #31
 80103de:	d411      	bmi.n	8010404 <SDMMC_CmdStatusRegister+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80103e0:	23c5      	movs	r3, #197	; 0xc5
 80103e2:	f2c0 0320 	movt	r3, #32
 80103e6:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 80103e8:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 80103ea:	b2db      	uxtb	r3, r3
 80103ec:	2b0d      	cmp	r3, #13
 80103ee:	d00d      	beq.n	801040c <SDMMC_CmdStatusRegister+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80103f0:	2001      	movs	r0, #1
  return errorstate;
 80103f2:	e001      	b.n	80103f8 <SDMMC_CmdStatusRegister+0x74>
      return SDMMC_ERROR_TIMEOUT;
 80103f4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 80103f8:	bc30      	pop	{r4, r5}
 80103fa:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 80103fc:	2304      	movs	r3, #4
 80103fe:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8010400:	4618      	mov	r0, r3
 8010402:	e7f9      	b.n	80103f8 <SDMMC_CmdStatusRegister+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8010404:	2301      	movs	r3, #1
 8010406:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8010408:	4618      	mov	r0, r3
 801040a:	e7f5      	b.n	80103f8 <SDMMC_CmdStatusRegister+0x74>
}
 801040c:	bc30      	pop	{r4, r5}
 801040e:	f7ff b9b1 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>
 8010412:	bf00      	nop

08010414 <SDMMC_CmdVoltageSwitch>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010414:	f240 21b0 	movw	r1, #688	; 0x2b0
  SDMMCx->ARG = Command->Argument;
 8010418:	2200      	movs	r2, #0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801041a:	f644 53d3 	movw	r3, #19923	; 0x4dd3
 801041e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8010422:	f2c1 0362 	movt	r3, #4194	; 0x1062
{
 8010426:	b430      	push	{r4, r5}
  SDMMCx->ARG = Command->Argument;
 8010428:	6082      	str	r2, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 801042a:	f24e 04c0 	movw	r4, #57536	; 0xe0c0
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801042e:	680a      	ldr	r2, [r1, #0]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010430:	f241 150b 	movw	r5, #4363	; 0x110b
 8010434:	68c1      	ldr	r1, [r0, #12]
 8010436:	f6cf 74fe 	movt	r4, #65534	; 0xfffe
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801043a:	fba3 3202 	umull	r3, r2, r3, r2
 801043e:	f241 3388 	movw	r3, #5000	; 0x1388
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010442:	400c      	ands	r4, r1
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010444:	2145      	movs	r1, #69	; 0x45
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8010446:	0a52      	lsrs	r2, r2, #9
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010448:	4325      	orrs	r5, r4
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 801044a:	f2c0 0120 	movt	r1, #32
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 801044e:	fb03 f302 	mul.w	r3, r3, r2
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, tmpreg);
 8010452:	60c5      	str	r5, [r0, #12]
    if (count-- == 0U)
 8010454:	f113 33ff 	adds.w	r3, r3, #4294967295	; 0xffffffff
 8010458:	d314      	bcc.n	8010484 <SDMMC_CmdVoltageSwitch+0x70>
    sta_reg = SDMMCx->STA;
 801045a:	6b42      	ldr	r2, [r0, #52]	; 0x34
         ((sta_reg & SDMMC_FLAG_CMDACT) != 0U ));
 801045c:	420a      	tst	r2, r1
 801045e:	d0f9      	beq.n	8010454 <SDMMC_CmdVoltageSwitch+0x40>
  }while(((sta_reg & (SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT | SDMMC_FLAG_BUSYD0END)) == 0U) ||
 8010460:	0494      	lsls	r4, r2, #18
 8010462:	d4f7      	bmi.n	8010454 <SDMMC_CmdVoltageSwitch+0x40>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8010464:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8010466:	075a      	lsls	r2, r3, #29
 8010468:	d410      	bmi.n	801048c <SDMMC_CmdVoltageSwitch+0x78>
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 801046a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 801046c:	07db      	lsls	r3, r3, #31
 801046e:	d411      	bmi.n	8010494 <SDMMC_CmdVoltageSwitch+0x80>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8010470:	23c5      	movs	r3, #197	; 0xc5
 8010472:	f2c0 0320 	movt	r3, #32
 8010476:	6383      	str	r3, [r0, #56]	; 0x38
  return (uint8_t)(SDMMCx->RESPCMD);
 8010478:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 801047a:	b2db      	uxtb	r3, r3
 801047c:	2b0b      	cmp	r3, #11
 801047e:	d00d      	beq.n	801049c <SDMMC_CmdVoltageSwitch+0x88>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8010480:	2001      	movs	r0, #1
  return errorstate;
 8010482:	e001      	b.n	8010488 <SDMMC_CmdVoltageSwitch+0x74>
      return SDMMC_ERROR_TIMEOUT;
 8010484:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8010488:	bc30      	pop	{r4, r5}
 801048a:	4770      	bx	lr
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 801048c:	2304      	movs	r3, #4
 801048e:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8010490:	4618      	mov	r0, r3
 8010492:	e7f9      	b.n	8010488 <SDMMC_CmdVoltageSwitch+0x74>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8010494:	2301      	movs	r3, #1
 8010496:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8010498:	4618      	mov	r0, r3
 801049a:	e7f5      	b.n	8010488 <SDMMC_CmdVoltageSwitch+0x74>
}
 801049c:	bc30      	pop	{r4, r5}
 801049e:	f7ff b969 	b.w	800f774 <SDMMC_GetCmdResp1.part.2>
 80104a2:	bf00      	nop

080104a4 <USB_CoreInit>:
  * @param  cfg pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_CoreInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 80104a4:	b084      	sub	sp, #16
 80104a6:	b430      	push	{r4, r5}
  HAL_StatusTypeDef ret;

  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80104a8:	9d08      	ldr	r5, [sp, #32]
{
 80104aa:	ac03      	add	r4, sp, #12
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80104ac:	2d01      	cmp	r5, #1
{
 80104ae:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  if (cfg.phy_itface == USB_OTG_ULPI_PHY)
 80104b2:	d13a      	bne.n	801052a <USB_CoreInit+0x86>
  {
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80104b4:	6b82      	ldr	r2, [r0, #56]	; 0x38

    /* Init The ULPI Interface */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80104b6:	f64f 73bf 	movw	r3, #65471	; 0xffbf

    /* Select vbus source */
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
    if (cfg.use_external_vbus == 1U)
 80104ba:	990f      	ldr	r1, [sp, #60]	; 0x3c
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80104bc:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80104c0:	f6cf 73bd 	movt	r3, #65469	; 0xffbd
    if (cfg.use_external_vbus == 1U)
 80104c4:	2901      	cmp	r1, #1
    USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 80104c6:	6382      	str	r2, [r0, #56]	; 0x38
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_TSDPS | USB_OTG_GUSBCFG_ULPIFSLS | USB_OTG_GUSBCFG_PHYSEL);
 80104c8:	68c2      	ldr	r2, [r0, #12]
 80104ca:	ea03 0302 	and.w	r3, r3, r2
 80104ce:	60c3      	str	r3, [r0, #12]
    USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_ULPIEVBUSD | USB_OTG_GUSBCFG_ULPIEVBUSI);
 80104d0:	68c3      	ldr	r3, [r0, #12]
 80104d2:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 80104d6:	60c3      	str	r3, [r0, #12]
    if (cfg.use_external_vbus == 1U)
 80104d8:	d050      	beq.n	801057c <USB_CoreInit+0xd8>
{
 80104da:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 80104de:	f2c0 0303 	movt	r3, #3
 80104e2:	e001      	b.n	80104e8 <USB_CoreInit+0x44>
  uint32_t count = 0U;

  /* Wait for AHB master IDLE state. */
  do
  {
    if (++count > 200000U)
 80104e4:	3b01      	subs	r3, #1
 80104e6:	d04e      	beq.n	8010586 <USB_CoreInit+0xe2>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 80104e8:	6902      	ldr	r2, [r0, #16]
 80104ea:	2a00      	cmp	r2, #0
 80104ec:	dafa      	bge.n	80104e4 <USB_CoreInit+0x40>

  /* Core Soft Reset */
  count = 0U;
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 80104ee:	6903      	ldr	r3, [r0, #16]
 80104f0:	f44f 6254 	mov.w	r2, #3392	; 0xd40
 80104f4:	f043 0301 	orr.w	r3, r3, #1
 80104f8:	f2c0 0203 	movt	r2, #3
 80104fc:	6103      	str	r3, [r0, #16]
 80104fe:	e001      	b.n	8010504 <USB_CoreInit+0x60>

  do
  {
    if (++count > 200000U)
 8010500:	3a01      	subs	r2, #1
 8010502:	d040      	beq.n	8010586 <USB_CoreInit+0xe2>
    {
      return HAL_TIMEOUT;
    }
  }
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 8010504:	6903      	ldr	r3, [r0, #16]
 8010506:	f013 0301 	ands.w	r3, r3, #1
 801050a:	d1f9      	bne.n	8010500 <USB_CoreInit+0x5c>
  if (cfg.dma_enable == 1U)
 801050c:	9a06      	ldr	r2, [sp, #24]
 801050e:	2a01      	cmp	r2, #1
 8010510:	d107      	bne.n	8010522 <USB_CoreInit+0x7e>
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_HBSTLEN_2;
 8010512:	6882      	ldr	r2, [r0, #8]
 8010514:	f042 0206 	orr.w	r2, r2, #6
 8010518:	6082      	str	r2, [r0, #8]
    USBx->GAHBCFG |= USB_OTG_GAHBCFG_DMAEN;
 801051a:	6882      	ldr	r2, [r0, #8]
 801051c:	f042 0220 	orr.w	r2, r2, #32
 8010520:	6082      	str	r2, [r0, #8]
}
 8010522:	4618      	mov	r0, r3
 8010524:	bc30      	pop	{r4, r5}
 8010526:	b004      	add	sp, #16
 8010528:	4770      	bx	lr
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_PHYSEL;
 801052a:	68c2      	ldr	r2, [r0, #12]
 801052c:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 8010530:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8010534:	f2c0 0303 	movt	r3, #3
 8010538:	60c2      	str	r2, [r0, #12]
 801053a:	e001      	b.n	8010540 <USB_CoreInit+0x9c>
    if (++count > 200000U)
 801053c:	3b01      	subs	r3, #1
 801053e:	d024      	beq.n	801058a <USB_CoreInit+0xe6>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_AHBIDL) == 0U);
 8010540:	6902      	ldr	r2, [r0, #16]
 8010542:	2a00      	cmp	r2, #0
 8010544:	dafa      	bge.n	801053c <USB_CoreInit+0x98>
  USBx->GRSTCTL |= USB_OTG_GRSTCTL_CSRST;
 8010546:	6903      	ldr	r3, [r0, #16]
 8010548:	f44f 6254 	mov.w	r2, #3392	; 0xd40
 801054c:	f043 0301 	orr.w	r3, r3, #1
 8010550:	f2c0 0203 	movt	r2, #3
 8010554:	6103      	str	r3, [r0, #16]
 8010556:	e001      	b.n	801055c <USB_CoreInit+0xb8>
    if (++count > 200000U)
 8010558:	3a01      	subs	r2, #1
 801055a:	d016      	beq.n	801058a <USB_CoreInit+0xe6>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_CSRST) == USB_OTG_GRSTCTL_CSRST);
 801055c:	6903      	ldr	r3, [r0, #16]
 801055e:	f013 0301 	ands.w	r3, r3, #1
 8010562:	d1f9      	bne.n	8010558 <USB_CoreInit+0xb4>
    if (cfg.battery_charging_enable == 0U)
 8010564:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8010566:	b922      	cbnz	r2, 8010572 <USB_CoreInit+0xce>
      USBx->GCCFG |= USB_OTG_GCCFG_PWRDWN;
 8010568:	6b82      	ldr	r2, [r0, #56]	; 0x38
 801056a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 801056e:	6382      	str	r2, [r0, #56]	; 0x38
 8010570:	e7cc      	b.n	801050c <USB_CoreInit+0x68>
      USBx->GCCFG &= ~(USB_OTG_GCCFG_PWRDWN);
 8010572:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8010574:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8010578:	6382      	str	r2, [r0, #56]	; 0x38
 801057a:	e7c7      	b.n	801050c <USB_CoreInit+0x68>
      USBx->GUSBCFG |= USB_OTG_GUSBCFG_ULPIEVBUSD;
 801057c:	68c3      	ldr	r3, [r0, #12]
 801057e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8010582:	60c3      	str	r3, [r0, #12]
 8010584:	e7a9      	b.n	80104da <USB_CoreInit+0x36>
      return HAL_TIMEOUT;
 8010586:	2303      	movs	r3, #3
 8010588:	e7c0      	b.n	801050c <USB_CoreInit+0x68>
 801058a:	2303      	movs	r3, #3
 801058c:	e7ea      	b.n	8010564 <USB_CoreInit+0xc0>
 801058e:	bf00      	nop

08010590 <USB_EnableGlobalInt>:
{
 8010590:	4602      	mov	r2, r0
}
 8010592:	2000      	movs	r0, #0
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8010594:	6893      	ldr	r3, [r2, #8]
 8010596:	f043 0301 	orr.w	r3, r3, #1
 801059a:	6093      	str	r3, [r2, #8]
}
 801059c:	4770      	bx	lr
 801059e:	bf00      	nop

080105a0 <USB_DisableGlobalInt>:
{
 80105a0:	4602      	mov	r2, r0
}
 80105a2:	2000      	movs	r0, #0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 80105a4:	6893      	ldr	r3, [r2, #8]
 80105a6:	f023 0301 	bic.w	r3, r3, #1
 80105aa:	6093      	str	r3, [r2, #8]
}
 80105ac:	4770      	bx	lr
 80105ae:	bf00      	nop

080105b0 <USB_SetCurrentMode>:
{
 80105b0:	b508      	push	{r3, lr}
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80105b2:	68c3      	ldr	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80105b4:	2901      	cmp	r1, #1
  USBx->GUSBCFG &= ~(USB_OTG_GUSBCFG_FHMOD | USB_OTG_GUSBCFG_FDMOD);
 80105b6:	f023 43c0 	bic.w	r3, r3, #1610612736	; 0x60000000
 80105ba:	60c3      	str	r3, [r0, #12]
  if (mode == USB_HOST_MODE)
 80105bc:	d00b      	beq.n	80105d6 <USB_SetCurrentMode+0x26>
  else if (mode == USB_DEVICE_MODE)
 80105be:	b941      	cbnz	r1, 80105d2 <USB_SetCurrentMode+0x22>
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FDMOD;
 80105c0:	68c3      	ldr	r3, [r0, #12]
 80105c2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 80105c6:	60c3      	str	r3, [r0, #12]
  HAL_Delay(50U);
 80105c8:	2032      	movs	r0, #50	; 0x32
 80105ca:	f7f0 fa3d 	bl	8000a48 <HAL_Delay>
  return HAL_OK;
 80105ce:	2000      	movs	r0, #0
}
 80105d0:	bd08      	pop	{r3, pc}
    return HAL_ERROR;
 80105d2:	2001      	movs	r0, #1
}
 80105d4:	bd08      	pop	{r3, pc}
    USBx->GUSBCFG |= USB_OTG_GUSBCFG_FHMOD;
 80105d6:	68c3      	ldr	r3, [r0, #12]
 80105d8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80105dc:	60c3      	str	r3, [r0, #12]
 80105de:	e7f3      	b.n	80105c8 <USB_SetCurrentMode+0x18>

080105e0 <USB_ReadPacket>:
  uint32_t count32b = ((uint32_t)len + 3U) / 4U;
 80105e0:	3203      	adds	r2, #3
  for (i = 0U; i < count32b; i++)
 80105e2:	0892      	lsrs	r2, r2, #2
 80105e4:	d00d      	beq.n	8010602 <USB_ReadPacket+0x22>
 80105e6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
{
 80105ea:	b410      	push	{r4}
 80105ec:	f500 5480 	add.w	r4, r0, #4096	; 0x1000
  uint32_t *pDest = (uint32_t *)dest;
 80105f0:	4608      	mov	r0, r1
    __UNALIGNED_UINT32_WRITE(pDest, USBx_DFIFO(0U));
 80105f2:	6823      	ldr	r3, [r4, #0]
 80105f4:	f840 3b04 	str.w	r3, [r0], #4
  for (i = 0U; i < count32b; i++)
 80105f8:	4282      	cmp	r2, r0
 80105fa:	d1fa      	bne.n	80105f2 <USB_ReadPacket+0x12>
}
 80105fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010600:	4770      	bx	lr
  uint32_t *pDest = (uint32_t *)dest;
 8010602:	4608      	mov	r0, r1
}
 8010604:	4770      	bx	lr
 8010606:	bf00      	nop

08010608 <USB_ReadInterrupts>:
  tmpreg = USBx->GINTSTS;
 8010608:	6942      	ldr	r2, [r0, #20]
  tmpreg &= USBx->GINTMSK;
 801060a:	6980      	ldr	r0, [r0, #24]
}
 801060c:	4010      	ands	r0, r2
 801060e:	4770      	bx	lr

08010610 <USB_GetMode>:
  return ((USBx->GINTSTS) & 0x1U);
 8010610:	6940      	ldr	r0, [r0, #20]
}
 8010612:	f000 0001 	and.w	r0, r0, #1
 8010616:	4770      	bx	lr

08010618 <USB_HostInit>:
  * @param  cfg   pointer to a USB_OTG_CfgTypeDef structure that contains
  *         the configuration information for the specified USBx peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef USB_HostInit(USB_OTG_GlobalTypeDef *USBx, USB_OTG_CfgTypeDef cfg)
{
 8010618:	b084      	sub	sp, #16
 801061a:	b530      	push	{r4, r5, lr}
 801061c:	4604      	mov	r4, r0
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t i;

  /* Restart the Phy Clock */
  USBx_PCGCCTL = 0U;
 801061e:	2500      	movs	r5, #0
{
 8010620:	b083      	sub	sp, #12
  USBx_PCGCCTL = 0U;
 8010622:	f8c4 5e00 	str.w	r5, [r4, #3584]	; 0xe00

  /* Disable VBUS sensing */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 8010626:	6ba5      	ldr	r5, [r4, #56]	; 0x38
{
 8010628:	a807      	add	r0, sp, #28
  USBx->GCCFG &= ~(USB_OTG_GCCFG_VBDEN);
 801062a:	f425 1500 	bic.w	r5, r5, #2097152	; 0x200000
 801062e:	63a5      	str	r5, [r4, #56]	; 0x38

  /* Disable Battery chargin detector */
  USBx->GCCFG &= ~(USB_OTG_GCCFG_BCDEN);
 8010630:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8010632:	f425 3500 	bic.w	r5, r5, #131072	; 0x20000
 8010636:	63a5      	str	r5, [r4, #56]	; 0x38


  if ((USBx->CID & (0x1U << 8)) != 0U)
 8010638:	6be5      	ldr	r5, [r4, #60]	; 0x3c
{
 801063a:	e880 000e 	stmia.w	r0, {r1, r2, r3}
  if ((USBx->CID & (0x1U << 8)) != 0U)
 801063e:	05eb      	lsls	r3, r5, #23
 8010640:	9908      	ldr	r1, [sp, #32]
 8010642:	d576      	bpl.n	8010732 <USB_HostInit+0x11a>
  {
    if (cfg.speed == USB_OTG_SPEED_FULL)
 8010644:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8010646:	2b03      	cmp	r3, #3
    {
      /* Force Device Enumeration to FS/LS mode only */
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 8010648:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
    if (cfg.speed == USB_OTG_SPEED_FULL)
 801064c:	d074      	beq.n	8010738 <USB_HostInit+0x120>
    }
  }
  else
  {
    /* Set default Max speed support */
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 801064e:	f023 0304 	bic.w	r3, r3, #4
 8010652:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8010656:	f44f 6284 	mov.w	r2, #1056	; 0x420
 801065a:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 801065e:	6122      	str	r2, [r4, #16]
 8010660:	f2c0 0303 	movt	r3, #3
 8010664:	e001      	b.n	801066a <USB_HostInit+0x52>
    if (++count > 200000U)
 8010666:	3b01      	subs	r3, #1
 8010668:	d002      	beq.n	8010670 <USB_HostInit+0x58>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 801066a:	6922      	ldr	r2, [r4, #16]
 801066c:	0695      	lsls	r5, r2, #26
 801066e:	d4fa      	bmi.n	8010666 <USB_HostInit+0x4e>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8010670:	2210      	movs	r2, #16
 8010672:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 8010676:	6122      	str	r2, [r4, #16]
 8010678:	f2c0 0303 	movt	r3, #3
 801067c:	e001      	b.n	8010682 <USB_HostInit+0x6a>
    if (++count > 200000U)
 801067e:	3b01      	subs	r3, #1
 8010680:	d002      	beq.n	8010688 <USB_HostInit+0x70>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8010682:	6922      	ldr	r2, [r4, #16]
 8010684:	06d0      	lsls	r0, r2, #27
 8010686:	d4fa      	bmi.n	801067e <USB_HostInit+0x66>
  /* Make sure the FIFOs are flushed. */
  (void)USB_FlushTxFifo(USBx, 0x10U); /* all Tx FIFOs */
  (void)USB_FlushRxFifo(USBx);

  /* Clear all pending HC Interrupts */
  for (i = 0U; i < cfg.Host_channels; i++)
 8010688:	b159      	cbz	r1, 80106a2 <USB_HostInit+0x8a>
 801068a:	2200      	movs	r2, #0
 801068c:	f504 63a0 	add.w	r3, r4, #1280	; 0x500
  {
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 8010690:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    USBx_HC(i)->HCINTMSK = 0U;
 8010694:	4610      	mov	r0, r2
  for (i = 0U; i < cfg.Host_channels; i++)
 8010696:	3201      	adds	r2, #1
    USBx_HC(i)->HCINT = 0xFFFFFFFFU;
 8010698:	609d      	str	r5, [r3, #8]
    USBx_HC(i)->HCINTMSK = 0U;
 801069a:	60d8      	str	r0, [r3, #12]
 801069c:	3320      	adds	r3, #32
  for (i = 0U; i < cfg.Host_channels; i++)
 801069e:	428a      	cmp	r2, r1
 80106a0:	d1f9      	bne.n	8010696 <USB_HostInit+0x7e>
  * @retval HAL status
*/
HAL_StatusTypeDef USB_DriveVbus(USB_OTG_GlobalTypeDef *USBx, uint8_t state)
{
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 80106a2:	2300      	movs	r3, #0
 80106a4:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 80106a6:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 80106aa:	9301      	str	r3, [sp, #4]

  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80106ac:	9b01      	ldr	r3, [sp, #4]
 80106ae:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80106b2:	9301      	str	r3, [sp, #4]
             USB_OTG_HPRT_PENCHNG | USB_OTG_HPRT_POCCHNG);

  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 80106b4:	9b01      	ldr	r3, [sp, #4]
 80106b6:	04da      	lsls	r2, r3, #19
 80106b8:	d404      	bmi.n	80106c4 <USB_HostInit+0xac>
  {
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 80106ba:	9b01      	ldr	r3, [sp, #4]
 80106bc:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 80106c0:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(200U);
 80106c4:	20c8      	movs	r0, #200	; 0xc8
  }
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 80106c6:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(200U);
 80106c8:	f7f0 f9be 	bl	8000a48 <HAL_Delay>
  USBx->GINTSTS = 0xFFFFFFFFU;
 80106cc:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTMSK = 0U;
 80106d0:	2200      	movs	r2, #0
 80106d2:	61a2      	str	r2, [r4, #24]
  USBx->GINTSTS = 0xFFFFFFFFU;
 80106d4:	6163      	str	r3, [r4, #20]
  if ((USBx->CID & (0x1U << 8)) != 0U)
 80106d6:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80106d8:	05db      	lsls	r3, r3, #23
 80106da:	d51e      	bpl.n	801071a <USB_HostInit+0x102>
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 80106dc:	f44f 7200 	mov.w	r2, #512	; 0x200
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 80106e0:	f44f 7340 	mov.w	r3, #768	; 0x300
    USBx->GRXFSIZ  = 0x200U;
 80106e4:	4611      	mov	r1, r2
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 80106e6:	f2c0 03e0 	movt	r3, #224	; 0xe0
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 80106ea:	f2c0 1200 	movt	r2, #256	; 0x100
    USBx->GRXFSIZ  = 0x200U;
 80106ee:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x100U << 16) & USB_OTG_NPTXFD) | 0x200U);
 80106f0:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0xE0U << 16) & USB_OTG_HPTXFSIZ_PTXFD) | 0x300U);
 80106f2:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
  if (cfg.dma_enable == 0U)
 80106f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80106f8:	b91b      	cbnz	r3, 8010702 <USB_HostInit+0xea>
    USBx->GINTMSK |= USB_OTG_GINTMSK_RXFLVLM;
 80106fa:	69a3      	ldr	r3, [r4, #24]
 80106fc:	f043 0310 	orr.w	r3, r3, #16
 8010700:	61a3      	str	r3, [r4, #24]
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 8010702:	2308      	movs	r3, #8
 8010704:	69a2      	ldr	r2, [r4, #24]
}
 8010706:	2000      	movs	r0, #0
  USBx->GINTMSK |= (USB_OTG_GINTMSK_PRTIM            | USB_OTG_GINTMSK_HCIM | \
 8010708:	f2ca 3320 	movt	r3, #41760	; 0xa320
 801070c:	4313      	orrs	r3, r2
 801070e:	61a3      	str	r3, [r4, #24]
}
 8010710:	b003      	add	sp, #12
 8010712:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8010716:	b004      	add	sp, #16
 8010718:	4770      	bx	lr
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 801071a:	2280      	movs	r2, #128	; 0x80
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 801071c:	23e0      	movs	r3, #224	; 0xe0
    USBx->GRXFSIZ  = 0x80U;
 801071e:	4611      	mov	r1, r2
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 8010720:	f2c0 0340 	movt	r3, #64	; 0x40
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 8010724:	f2c0 0260 	movt	r2, #96	; 0x60
    USBx->GRXFSIZ  = 0x80U;
 8010728:	6261      	str	r1, [r4, #36]	; 0x24
    USBx->DIEPTXF0_HNPTXFSIZ = (uint32_t)(((0x60U << 16) & USB_OTG_NPTXFD) | 0x80U);
 801072a:	62a2      	str	r2, [r4, #40]	; 0x28
    USBx->HPTXFSIZ = (uint32_t)(((0x40U << 16)& USB_OTG_HPTXFSIZ_PTXFD) | 0xE0U);
 801072c:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
 8010730:	e7e1      	b.n	80106f6 <USB_HostInit+0xde>
    USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSS);
 8010732:	f8d4 3400 	ldr.w	r3, [r4, #1024]	; 0x400
 8010736:	e78a      	b.n	801064e <USB_HostInit+0x36>
      USBx_HOST->HCFG |= USB_OTG_HCFG_FSLSS;
 8010738:	f043 0304 	orr.w	r3, r3, #4
 801073c:	f8c4 3400 	str.w	r3, [r4, #1024]	; 0x400
 8010740:	e789      	b.n	8010656 <USB_HostInit+0x3e>
 8010742:	bf00      	nop

08010744 <USB_InitFSLSPClkSel>:
{
 8010744:	b410      	push	{r4}
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 8010746:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 801074a:	f001 0303 	and.w	r3, r1, #3
  if (freq == HCFG_48_MHZ)
 801074e:	2901      	cmp	r1, #1
  USBx_HOST->HCFG &= ~(USB_OTG_HCFG_FSLSPCS);
 8010750:	f500 6480 	add.w	r4, r0, #1024	; 0x400
 8010754:	f022 0203 	bic.w	r2, r2, #3
 8010758:	f8c0 2400 	str.w	r2, [r0, #1024]	; 0x400
  USBx_HOST->HCFG |= (uint32_t)freq & USB_OTG_HCFG_FSLSPCS;
 801075c:	f8d0 2400 	ldr.w	r2, [r0, #1024]	; 0x400
 8010760:	ea43 0302 	orr.w	r3, r3, r2
 8010764:	f8c0 3400 	str.w	r3, [r0, #1024]	; 0x400
  if (freq == HCFG_48_MHZ)
 8010768:	d00c      	beq.n	8010784 <USB_InitFSLSPClkSel+0x40>
  else if (freq == HCFG_6_MHZ)
 801076a:	2902      	cmp	r1, #2
 801076c:	d003      	beq.n	8010776 <USB_InitFSLSPClkSel+0x32>
}
 801076e:	2000      	movs	r0, #0
 8010770:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010774:	4770      	bx	lr
    USBx_HOST->HFIR = 6000U;
 8010776:	f241 7370 	movw	r3, #6000	; 0x1770
}
 801077a:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 6000U;
 801077c:	6063      	str	r3, [r4, #4]
}
 801077e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010782:	4770      	bx	lr
    USBx_HOST->HFIR = 48000U;
 8010784:	f64b 3380 	movw	r3, #48000	; 0xbb80
}
 8010788:	2000      	movs	r0, #0
    USBx_HOST->HFIR = 48000U;
 801078a:	6063      	str	r3, [r4, #4]
}
 801078c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010790:	4770      	bx	lr
 8010792:	bf00      	nop

08010794 <USB_ResetPort>:
{
 8010794:	b530      	push	{r4, r5, lr}
 8010796:	4604      	mov	r4, r0
 8010798:	b083      	sub	sp, #12
  __IO uint32_t hprt0 = 0U;
 801079a:	2500      	movs	r5, #0
  HAL_Delay(100U);                                 /* See Note #1 */
 801079c:	2064      	movs	r0, #100	; 0x64
  __IO uint32_t hprt0 = 0U;
 801079e:	9501      	str	r5, [sp, #4]
  hprt0 = USBx_HPRT0;
 80107a0:	f8d4 3440 	ldr.w	r3, [r4, #1088]	; 0x440
 80107a4:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80107a6:	9b01      	ldr	r3, [sp, #4]
 80107a8:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80107ac:	9301      	str	r3, [sp, #4]
  USBx_HPRT0 = (USB_OTG_HPRT_PRST | hprt0);
 80107ae:	9b01      	ldr	r3, [sp, #4]
 80107b0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80107b4:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(100U);                                 /* See Note #1 */
 80107b8:	f7f0 f946 	bl	8000a48 <HAL_Delay>
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 80107bc:	9b01      	ldr	r3, [sp, #4]
  HAL_Delay(10U);
 80107be:	200a      	movs	r0, #10
  USBx_HPRT0 = ((~USB_OTG_HPRT_PRST) & hprt0);
 80107c0:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80107c4:	f8c4 3440 	str.w	r3, [r4, #1088]	; 0x440
  HAL_Delay(10U);
 80107c8:	f7f0 f93e 	bl	8000a48 <HAL_Delay>
}
 80107cc:	4628      	mov	r0, r5
 80107ce:	b003      	add	sp, #12
 80107d0:	bd30      	pop	{r4, r5, pc}
 80107d2:	bf00      	nop

080107d4 <USB_DriveVbus>:
{
 80107d4:	b082      	sub	sp, #8
  __IO uint32_t hprt0 = 0U;
 80107d6:	2300      	movs	r3, #0
 80107d8:	9301      	str	r3, [sp, #4]
  hprt0 = USBx_HPRT0;
 80107da:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 80107de:	9301      	str	r3, [sp, #4]
  hprt0 &= ~(USB_OTG_HPRT_PENA | USB_OTG_HPRT_PCDET |
 80107e0:	9b01      	ldr	r3, [sp, #4]
 80107e2:	f023 032e 	bic.w	r3, r3, #46	; 0x2e
 80107e6:	9301      	str	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 80107e8:	9b01      	ldr	r3, [sp, #4]
 80107ea:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 80107ee:	9b01      	ldr	r3, [sp, #4]
  if (((hprt0 & USB_OTG_HPRT_PPWR) == 0U) && (state == 1U))
 80107f0:	d101      	bne.n	80107f6 <USB_DriveVbus+0x22>
 80107f2:	2901      	cmp	r1, #1
 80107f4:	d00a      	beq.n	801080c <USB_DriveVbus+0x38>
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 80107f6:	04db      	lsls	r3, r3, #19
 80107f8:	d505      	bpl.n	8010806 <USB_DriveVbus+0x32>
 80107fa:	b921      	cbnz	r1, 8010806 <USB_DriveVbus+0x32>
  {
    USBx_HPRT0 = ((~USB_OTG_HPRT_PPWR) & hprt0);
 80107fc:	9b01      	ldr	r3, [sp, #4]
 80107fe:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 8010802:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
  }
  return HAL_OK;
}
 8010806:	2000      	movs	r0, #0
 8010808:	b002      	add	sp, #8
 801080a:	4770      	bx	lr
    USBx_HPRT0 = (USB_OTG_HPRT_PPWR | hprt0);
 801080c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8010810:	f8c0 3440 	str.w	r3, [r0, #1088]	; 0x440
}
 8010814:	2000      	movs	r0, #0
  if (((hprt0 & USB_OTG_HPRT_PPWR) == USB_OTG_HPRT_PPWR) && (state == 0U))
 8010816:	9b01      	ldr	r3, [sp, #4]
}
 8010818:	b002      	add	sp, #8
 801081a:	4770      	bx	lr

0801081c <USB_GetHostSpeed>:
  *            @arg HCD_SPEED_HIGH: High speed mode
  *            @arg HCD_SPEED_FULL: Full speed mode
  *            @arg HCD_SPEED_LOW: Low speed mode
  */
uint32_t USB_GetHostSpeed(USB_OTG_GlobalTypeDef *USBx)
{
 801081c:	b082      	sub	sp, #8
  uint32_t USBx_BASE = (uint32_t)USBx;
  __IO uint32_t hprt0 = 0U;
 801081e:	2300      	movs	r3, #0
 8010820:	9301      	str	r3, [sp, #4]

  hprt0 = USBx_HPRT0;
 8010822:	f8d0 3440 	ldr.w	r3, [r0, #1088]	; 0x440
 8010826:	9301      	str	r3, [sp, #4]
  return ((hprt0 & USB_OTG_HPRT_PSPD) >> 17);
 8010828:	9801      	ldr	r0, [sp, #4]
}
 801082a:	f3c0 4041 	ubfx	r0, r0, #17, #2
 801082e:	b002      	add	sp, #8
 8010830:	4770      	bx	lr
 8010832:	bf00      	nop

08010834 <USB_GetCurrentFrame>:
*/
uint32_t USB_GetCurrentFrame(USB_OTG_GlobalTypeDef *USBx)
{
  uint32_t USBx_BASE = (uint32_t)USBx;

  return (USBx_HOST->HFNUM & USB_OTG_HFNUM_FRNUM);
 8010834:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8010838:	6880      	ldr	r0, [r0, #8]
}
 801083a:	b280      	uxth	r0, r0
 801083c:	4770      	bx	lr
 801083e:	bf00      	nop

08010840 <USB_HC_Init>:
                              uint8_t epnum,
                              uint8_t dev_address,
                              uint8_t speed,
                              uint8_t ep_type,
                              uint16_t mps)
{
 8010840:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8010844:	4606      	mov	r6, r0
  HAL_StatusTypeDef ret = HAL_OK;
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t HCcharEpDir, HCcharLowSpeed;

  /* Clear old interrupt conditions for this host channel. */
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 8010846:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 801084a:	2001      	movs	r0, #1
{
 801084c:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 8010850:	eb06 1541 	add.w	r5, r6, r1, lsl #5
 8010854:	f001 010f 	and.w	r1, r1, #15
 8010858:	f506 6980 	add.w	r9, r6, #1024	; 0x400
{
 801085c:	f89d e01c 	ldrb.w	lr, [sp, #28]
  USBx_HC((uint32_t)ch_num)->HCINT = 0xFFFFFFFFU;
 8010860:	f505 68a0 	add.w	r8, r5, #1280	; 0x500
 8010864:	fa00 f101 	lsl.w	r1, r0, r1
 8010868:	f8c8 7008 	str.w	r7, [r8, #8]
 801086c:	b250      	sxtb	r0, r2
{
 801086e:	f8bd c024 	ldrh.w	ip, [sp, #36]	; 0x24

  /* Enable channel interrupts required for this transfer. */
  switch (ep_type)
 8010872:	2c03      	cmp	r4, #3
 8010874:	d85b      	bhi.n	801092e <USB_HC_Init+0xee>
 8010876:	e8df f004 	tbb	[pc, r4]
 801087a:	3d4a      	.short	0x3d4a
 801087c:	024a      	.short	0x024a
        }
      }
      break;

    case EP_TYPE_INTR:
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 801087e:	f240 679d 	movw	r7, #1693	; 0x69d
                                            USB_OTG_HCINTMSK_DTERRM |
                                            USB_OTG_HCINTMSK_NAKM   |
                                            USB_OTG_HCINTMSK_AHBERR |
                                            USB_OTG_HCINTMSK_FRMORM;

      if ((epnum & 0x80U) == 0x80U)
 8010882:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8010884:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 8010888:	db63      	blt.n	8010952 <USB_HC_Init+0x112>
      ret = HAL_ERROR;
      break;
  }

  /* Enable the top level host channel interrupt. */
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 801088a:	f8d9 7018 	ldr.w	r7, [r9, #24]

  /* Make sure host channel interrupts are enabled. */
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 801088e:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8010890:	4339      	orrs	r1, r7
  {
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
  }
  else
  {
    HCcharEpDir = 0U;
 8010892:	4607      	mov	r7, r0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8010894:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8010898:	69b1      	ldr	r1, [r6, #24]
 801089a:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 801089e:	61b1      	str	r1, [r6, #24]
  else
  {
    HCcharLowSpeed = 0U;
  }

  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80108a0:	0599      	lsls	r1, r3, #22
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 80108a2:	f3cc 030a 	ubfx	r3, ip, #0, #11
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 80108a6:	02d2      	lsls	r2, r2, #11
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 80108a8:	f1be 0f02 	cmp.w	lr, #2
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80108ac:	f001 51fe 	and.w	r1, r1, #532676608	; 0x1fc00000
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 80108b0:	ea4f 4684 	mov.w	r6, r4, lsl #18
                                      ((((uint32_t)epnum & 0x7FU) << 11) & USB_OTG_HCCHAR_EPNUM) |
 80108b4:	f402 42f0 	and.w	r2, r2, #30720	; 0x7800
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 80108b8:	bf18      	it	ne
 80108ba:	f04f 0c00 	movne.w	ip, #0
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 80108be:	ea43 0301 	orr.w	r3, r3, r1
 80108c2:	f406 2140 	and.w	r1, r6, #786432	; 0xc0000
    HCcharLowSpeed = (0x1U << 17) & USB_OTG_HCCHAR_LSDEV;
 80108c6:	bf08      	it	eq
 80108c8:	f44f 3c00 	moveq.w	ip, #131072	; 0x20000

  if (ep_type == EP_TYPE_INTR)
 80108cc:	2c03      	cmp	r4, #3
                                      (((uint32_t)ep_type << 18) & USB_OTG_HCCHAR_EPTYP) |
 80108ce:	ea43 0302 	orr.w	r3, r3, r2
 80108d2:	ea43 0301 	orr.w	r3, r3, r1
                                      ((uint32_t)mps & USB_OTG_HCCHAR_MPSIZ) | HCcharEpDir | HCcharLowSpeed;
 80108d6:	ea43 0307 	orr.w	r3, r3, r7
 80108da:	ea43 030c 	orr.w	r3, r3, ip
  USBx_HC((uint32_t)ch_num)->HCCHAR = (((uint32_t)dev_address << 22) & USB_OTG_HCCHAR_DAD) |
 80108de:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  if (ep_type == EP_TYPE_INTR)
 80108e2:	d105      	bne.n	80108f0 <USB_HC_Init+0xb0>
  {
    USBx_HC((uint32_t)ch_num)->HCCHAR |= USB_OTG_HCCHAR_ODDFRM ;
 80108e4:	f8d5 3500 	ldr.w	r3, [r5, #1280]	; 0x500
 80108e8:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 80108ec:	f8c5 3500 	str.w	r3, [r5, #1280]	; 0x500
  }

  return ret;
}
 80108f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80108f4:	f240 2725 	movw	r7, #549	; 0x225
      if ((epnum & 0x80U) == 0x80U)
 80108f8:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 80108fa:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 80108fe:	dac4      	bge.n	801088a <USB_HC_Init+0x4a>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_TXERRM | USB_OTG_HCINTMSK_BBERRM);
 8010900:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8010904:	f440 70c0 	orr.w	r0, r0, #384	; 0x180
 8010908:	f8c8 000c 	str.w	r0, [r8, #12]
 801090c:	e027      	b.n	801095e <USB_HC_Init+0x11e>
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 801090e:	f240 479d 	movw	r7, #1181	; 0x49d
      if ((epnum & 0x80U) == 0x80U)
 8010912:	2800      	cmp	r0, #0
      USBx_HC((uint32_t)ch_num)->HCINTMSK = USB_OTG_HCINTMSK_XFRCM  |
 8010914:	f8c8 700c 	str.w	r7, [r8, #12]
      if ((epnum & 0x80U) == 0x80U)
 8010918:	db1b      	blt.n	8010952 <USB_HC_Init+0x112>
        if ((USBx->CID & (0x1U << 8)) != 0U)
 801091a:	6bf0      	ldr	r0, [r6, #60]	; 0x3c
 801091c:	05c0      	lsls	r0, r0, #23
 801091e:	d5b4      	bpl.n	801088a <USB_HC_Init+0x4a>
          USBx_HC((uint32_t)ch_num)->HCINTMSK |= (USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
 8010920:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8010924:	f040 0060 	orr.w	r0, r0, #96	; 0x60
 8010928:	f8c8 000c 	str.w	r0, [r8, #12]
 801092c:	e7ad      	b.n	801088a <USB_HC_Init+0x4a>
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 801092e:	f8d9 7018 	ldr.w	r7, [r9, #24]
      ret = HAL_ERROR;
 8010932:	2800      	cmp	r0, #0
 8010934:	f04f 0001 	mov.w	r0, #1
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8010938:	ea41 0107 	orr.w	r1, r1, r7
      ret = HAL_ERROR;
 801093c:	bfac      	ite	ge
 801093e:	2700      	movge	r7, #0
 8010940:	f44f 4700 	movlt.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8010944:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8010948:	69b1      	ldr	r1, [r6, #24]
 801094a:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 801094e:	61b1      	str	r1, [r6, #24]
 8010950:	e7a6      	b.n	80108a0 <USB_HC_Init+0x60>
        USBx_HC((uint32_t)ch_num)->HCINTMSK |= USB_OTG_HCINTMSK_BBERRM;
 8010952:	f8d8 000c 	ldr.w	r0, [r8, #12]
 8010956:	f440 7080 	orr.w	r0, r0, #256	; 0x100
 801095a:	f8c8 000c 	str.w	r0, [r8, #12]
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 801095e:	f8d9 7018 	ldr.w	r7, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 8010962:	2000      	movs	r0, #0
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 8010964:	4339      	orrs	r1, r7
    HCcharEpDir = (0x1U << 15) & USB_OTG_HCCHAR_EPDIR;
 8010966:	f44f 4700 	mov.w	r7, #32768	; 0x8000
  USBx_HOST->HAINTMSK |= 1UL << (ch_num & 0xFU);
 801096a:	f8c9 1018 	str.w	r1, [r9, #24]
  USBx->GINTMSK |= USB_OTG_GINTMSK_HCIM;
 801096e:	69b1      	ldr	r1, [r6, #24]
 8010970:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 8010974:	61b1      	str	r1, [r6, #24]
 8010976:	e793      	b.n	80108a0 <USB_HC_Init+0x60>

08010978 <USB_HC_StartXfer>:
  *           0 : DMA feature not used
  *           1 : DMA feature used
  * @retval HAL state
  */
HAL_StatusTypeDef USB_HC_StartXfer(USB_OTG_GlobalTypeDef *USBx, USB_OTG_HCTypeDef *hc, uint8_t dma)
{
 8010978:	b4f0      	push	{r4, r5, r6, r7}
 801097a:	784c      	ldrb	r4, [r1, #1]
  uint8_t  is_oddframe;
  uint16_t len_words;
  uint16_t num_packets;
  uint16_t max_hc_pkt_count = 256U;

  if (((USBx->CID & (0x1U << 8)) != 0U) && (hc->speed == USBH_HS_SPEED))
 801097c:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
 801097e:	eb00 1444 	add.w	r4, r0, r4, lsl #5
 8010982:	05db      	lsls	r3, r3, #23
 8010984:	f504 67a0 	add.w	r7, r4, #1280	; 0x500
 8010988:	d50a      	bpl.n	80109a0 <USB_HC_StartXfer+0x28>
 801098a:	790b      	ldrb	r3, [r1, #4]
 801098c:	b943      	cbnz	r3, 80109a0 <USB_HC_StartXfer+0x28>
  {
    if ((dma == 0U) && (hc->do_ping == 1U))
 801098e:	2a00      	cmp	r2, #0
 8010990:	d062      	beq.n	8010a58 <USB_HC_StartXfer+0xe0>
    {
      (void)USB_DoPing(USBx, hc->ch_num);
      return HAL_OK;
    }
    else if (dma == 1U)
 8010992:	2a01      	cmp	r2, #1
 8010994:	d104      	bne.n	80109a0 <USB_HC_StartXfer+0x28>
    {
      USBx_HC(ch_num)->HCINTMSK &= ~(USB_OTG_HCINTMSK_NYET | USB_OTG_HCINTMSK_ACKM);
 8010996:	68fd      	ldr	r5, [r7, #12]
 8010998:	f025 0560 	bic.w	r5, r5, #96	; 0x60
 801099c:	60fd      	str	r5, [r7, #12]
      hc->do_ping = 0U;
 801099e:	714b      	strb	r3, [r1, #5]
      /* ... */
    }
  }

  /* Compute the expected number of packets associated to the transfer */
  if (hc->xfer_len > 0U)
 80109a0:	690d      	ldr	r5, [r1, #16]
 80109a2:	2d00      	cmp	r5, #0
 80109a4:	d14c      	bne.n	8010a40 <USB_HC_StartXfer+0xc8>
 80109a6:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 80109aa:	f04f 0c01 	mov.w	ip, #1
  }
  else
  {
    num_packets = 1U;
  }
  if (hc->ep_is_in != 0U)
 80109ae:	78cb      	ldrb	r3, [r1, #3]
 80109b0:	b11b      	cbz	r3, 80109ba <USB_HC_StartXfer+0x42>
  {
    hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
 80109b2:	890d      	ldrh	r5, [r1, #8]
 80109b4:	fb0c f505 	mul.w	r5, ip, r5
 80109b8:	610d      	str	r5, [r1, #16]
  }

  /* Initialize the HCTSIZn register */
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 80109ba:	7a8b      	ldrb	r3, [r1, #10]
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
 80109bc:	f3c5 0512 	ubfx	r5, r5, #0, #19
                            (((uint32_t)hc->data_pid << 29) & USB_OTG_HCTSIZ_DPID);
 80109c0:	075b      	lsls	r3, r3, #29
 80109c2:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
                            (((uint32_t)num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 80109c6:	4333      	orrs	r3, r6
 80109c8:	432b      	orrs	r3, r5
  USBx_HC(ch_num)->HCTSIZ = (hc->xfer_len & USB_OTG_HCTSIZ_XFRSIZ) |
 80109ca:	613b      	str	r3, [r7, #16]

  if (dma != 0U)
 80109cc:	b10a      	cbz	r2, 80109d2 <USB_HC_StartXfer+0x5a>
  {
    /* xfer_buff MUST be 32-bits aligned */
    USBx_HC(ch_num)->HCDMA = (uint32_t)hc->xfer_buff;
 80109ce:	68cb      	ldr	r3, [r1, #12]
 80109d0:	617b      	str	r3, [r7, #20]
  }

  is_oddframe = (((uint32_t)USBx_HOST->HFNUM & 0x01U) != 0U) ? 0U : 1U;
 80109d2:	f500 6680 	add.w	r6, r0, #1024	; 0x400
 80109d6:	68b5      	ldr	r5, [r6, #8]
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 80109d8:	f8d4 7500 	ldr.w	r7, [r4, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;

  /* Set host channel enable */
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80109dc:	f240 43bc 	movw	r3, #1212	; 0x4bc
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80109e0:	43ed      	mvns	r5, r5
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 80109e2:	f027 5700 	bic.w	r7, r7, #536870912	; 0x20000000
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80109e6:	f2c2 0300 	movt	r3, #8192	; 0x2000
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80109ea:	076d      	lsls	r5, r5, #29
  USBx_HC(ch_num)->HCCHAR &= ~USB_OTG_HCCHAR_ODDFRM;
 80109ec:	f8c4 7500 	str.w	r7, [r4, #1280]	; 0x500
  USBx_HC(ch_num)->HCCHAR |= (uint32_t)is_oddframe << 29;
 80109f0:	f005 5500 	and.w	r5, r5, #536870912	; 0x20000000
 80109f4:	f8d4 7500 	ldr.w	r7, [r4, #1280]	; 0x500
 80109f8:	433d      	orrs	r5, r7
 80109fa:	f8c4 5500 	str.w	r5, [r4, #1280]	; 0x500
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 80109fe:	f8d4 5500 	ldr.w	r5, [r4, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;

  /* make sure to set the correct ep direction */
  if (hc->ep_is_in != 0U)
 8010a02:	78cf      	ldrb	r7, [r1, #3]
  tmpreg = USBx_HC(ch_num)->HCCHAR;
 8010a04:	601d      	str	r5, [r3, #0]
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8010a06:	681d      	ldr	r5, [r3, #0]
 8010a08:	f025 4580 	bic.w	r5, r5, #1073741824	; 0x40000000
 8010a0c:	601d      	str	r5, [r3, #0]
  {
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 8010a0e:	681d      	ldr	r5, [r3, #0]
  if (hc->ep_is_in != 0U)
 8010a10:	2f00      	cmp	r7, #0
 8010a12:	d033      	beq.n	8010a7c <USB_HC_StartXfer+0x104>
    tmpreg |= USB_OTG_HCCHAR_EPDIR;
 8010a14:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
 8010a18:	601d      	str	r5, [r3, #0]
  }
  else
  {
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
  }
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8010a1a:	681d      	ldr	r5, [r3, #0]
 8010a1c:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
 8010a20:	601d      	str	r5, [r3, #0]
  USBx_HC(ch_num)->HCCHAR = tmpreg;
 8010a22:	681b      	ldr	r3, [r3, #0]
 8010a24:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500

  if (dma == 0U) /* Slave mode */
 8010a28:	bb2a      	cbnz	r2, 8010a76 <USB_HC_StartXfer+0xfe>
  {
    if ((hc->ep_is_in == 0U) && (hc->xfer_len > 0U))
 8010a2a:	78cb      	ldrb	r3, [r1, #3]
 8010a2c:	bb1b      	cbnz	r3, 8010a76 <USB_HC_StartXfer+0xfe>
 8010a2e:	690b      	ldr	r3, [r1, #16]
 8010a30:	b30b      	cbz	r3, 8010a76 <USB_HC_StartXfer+0xfe>
    {
      switch (hc->ep_type)
 8010a32:	79ca      	ldrb	r2, [r1, #7]
 8010a34:	2a03      	cmp	r2, #3
 8010a36:	d833      	bhi.n	8010aa0 <USB_HC_StartXfer+0x128>
 8010a38:	e8df f002 	tbb	[pc, r2]
 8010a3c:	2b462b46 	.word	0x2b462b46
    num_packets = (uint16_t)((hc->xfer_len + hc->max_packet - 1U) / hc->max_packet);
 8010a40:	890e      	ldrh	r6, [r1, #8]
 8010a42:	1e6b      	subs	r3, r5, #1
 8010a44:	4433      	add	r3, r6
 8010a46:	fbb3 f3f6 	udiv	r3, r3, r6
    if (num_packets > max_hc_pkt_count)
 8010a4a:	fa1f fc83 	uxth.w	ip, r3
 8010a4e:	f5bc 7f80 	cmp.w	ip, #256	; 0x100
 8010a52:	d817      	bhi.n	8010a84 <USB_HC_StartXfer+0x10c>
 8010a54:	04de      	lsls	r6, r3, #19
 8010a56:	e7aa      	b.n	80109ae <USB_HC_StartXfer+0x36>
    if ((dma == 0U) && (hc->do_ping == 1U))
 8010a58:	794b      	ldrb	r3, [r1, #5]
 8010a5a:	2b01      	cmp	r3, #1
 8010a5c:	d1a0      	bne.n	80109a0 <USB_HC_StartXfer+0x28>
  uint32_t USBx_BASE = (uint32_t)USBx;
  uint32_t chnum = (uint32_t)ch_num;
  uint32_t num_packets = 1U;
  uint32_t tmpreg;

  USBx_HC(chnum)->HCTSIZ = ((num_packets << 19) & USB_OTG_HCTSIZ_PKTCNT) |
 8010a5e:	2300      	movs	r3, #0
 8010a60:	f2c8 0308 	movt	r3, #32776	; 0x8008
 8010a64:	613b      	str	r3, [r7, #16]
                           USB_OTG_HCTSIZ_DOPING;

  /* Set host channel enable */
  tmpreg = USBx_HC(chnum)->HCCHAR;
 8010a66:	f8d4 3500 	ldr.w	r3, [r4, #1280]	; 0x500
  tmpreg &= ~USB_OTG_HCCHAR_CHDIS;
 8010a6a:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
  tmpreg |= USB_OTG_HCCHAR_CHENA;
 8010a6e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
  USBx_HC(chnum)->HCCHAR = tmpreg;
 8010a72:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
}
 8010a76:	2000      	movs	r0, #0
 8010a78:	bcf0      	pop	{r4, r5, r6, r7}
 8010a7a:	4770      	bx	lr
    tmpreg &= ~USB_OTG_HCCHAR_EPDIR;
 8010a7c:	f425 4500 	bic.w	r5, r5, #32768	; 0x8000
 8010a80:	601d      	str	r5, [r3, #0]
 8010a82:	e7ca      	b.n	8010a1a <USB_HC_StartXfer+0xa2>
      hc->xfer_len = (uint32_t)num_packets * hc->max_packet;
 8010a84:	0235      	lsls	r5, r6, #8
 8010a86:	f44f 7c80 	mov.w	ip, #256	; 0x100
 8010a8a:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
 8010a8e:	610d      	str	r5, [r1, #16]
 8010a90:	e78d      	b.n	80109ae <USB_HC_StartXfer+0x36>
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8010a92:	6934      	ldr	r4, [r6, #16]
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8010a94:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx_HOST->HPTXSTS & 0xFFFFU)) /* split the transfer */
 8010a96:	b2a4      	uxth	r4, r4
 8010a98:	f3c2 028f 	ubfx	r2, r2, #2, #16
 8010a9c:	4294      	cmp	r4, r2
 8010a9e:	d320      	bcc.n	8010ae2 <USB_HC_StartXfer+0x16a>
    count32b = ((uint32_t)len + 3U) / 4U;
 8010aa0:	b29b      	uxth	r3, r3
      (void)USB_WritePacket(USBx, hc->xfer_buff, hc->ch_num, (uint16_t)hc->xfer_len, 0);
 8010aa2:	68ca      	ldr	r2, [r1, #12]
 8010aa4:	7849      	ldrb	r1, [r1, #1]
    count32b = ((uint32_t)len + 3U) / 4U;
 8010aa6:	3303      	adds	r3, #3
    for (i = 0U; i < count32b; i++)
 8010aa8:	089b      	lsrs	r3, r3, #2
 8010aaa:	d0e4      	beq.n	8010a76 <USB_HC_StartXfer+0xfe>
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8010aac:	eb00 3001 	add.w	r0, r0, r1, lsl #12
 8010ab0:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8010ab4:	f500 5080 	add.w	r0, r0, #4096	; 0x1000
 8010ab8:	f852 1b04 	ldr.w	r1, [r2], #4
    for (i = 0U; i < count32b; i++)
 8010abc:	4293      	cmp	r3, r2
      USBx_DFIFO((uint32_t)ch_ep_num) = __UNALIGNED_UINT32_READ(pSrc);
 8010abe:	6001      	str	r1, [r0, #0]
    for (i = 0U; i < count32b; i++)
 8010ac0:	d1fa      	bne.n	8010ab8 <USB_HC_StartXfer+0x140>
}
 8010ac2:	2000      	movs	r0, #0
 8010ac4:	bcf0      	pop	{r4, r5, r6, r7}
 8010ac6:	4770      	bx	lr
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8010ac8:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
          len_words = (uint16_t)((hc->xfer_len + 3U) / 4U);
 8010aca:	1cda      	adds	r2, r3, #3
          if (len_words > (USBx->HNPTXSTS & 0xFFFFU))
 8010acc:	b2a4      	uxth	r4, r4
 8010ace:	f3c2 028f 	ubfx	r2, r2, #2, #16
 8010ad2:	4294      	cmp	r4, r2
 8010ad4:	d2e4      	bcs.n	8010aa0 <USB_HC_StartXfer+0x128>
            USBx->GINTMSK |= USB_OTG_GINTMSK_NPTXFEM;
 8010ad6:	6983      	ldr	r3, [r0, #24]
 8010ad8:	f043 0320 	orr.w	r3, r3, #32
 8010adc:	6183      	str	r3, [r0, #24]
 8010ade:	690b      	ldr	r3, [r1, #16]
 8010ae0:	e7de      	b.n	8010aa0 <USB_HC_StartXfer+0x128>
            USBx->GINTMSK |= USB_OTG_GINTMSK_PTXFEM;
 8010ae2:	6983      	ldr	r3, [r0, #24]
 8010ae4:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8010ae8:	6183      	str	r3, [r0, #24]
 8010aea:	690b      	ldr	r3, [r1, #16]
 8010aec:	e7d8      	b.n	8010aa0 <USB_HC_StartXfer+0x128>
 8010aee:	bf00      	nop

08010af0 <USB_HC_ReadInterrupt>:
  return ((USBx_HOST->HAINT) & 0xFFFFU);
 8010af0:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 8010af4:	6940      	ldr	r0, [r0, #20]
}
 8010af6:	b280      	uxth	r0, r0
 8010af8:	4770      	bx	lr
 8010afa:	bf00      	nop

08010afc <USB_HC_Halt>:
  uint32_t HcEpType = (USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_EPTYP) >> 18;
 8010afc:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8010b00:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8010b04:	f501 62a0 	add.w	r2, r1, #1280	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8010b08:	f413 2f80 	tst.w	r3, #262144	; 0x40000
    USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHDIS;
 8010b0c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8010b10:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
 8010b14:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
  if ((HcEpType == HCCHAR_CTRL) || (HcEpType == HCCHAR_BULK))
 8010b18:	d11f      	bne.n	8010b5a <USB_HC_Halt+0x5e>
    if ((USBx->HNPTXSTS & (0xFFU << 16)) == 0U)
 8010b1a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8010b1c:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
 8010b20:	d13c      	bne.n	8010b9c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8010b22:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 8010b26:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8010b2a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8010b2e:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8010b32:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 8010b36:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 8010b3a:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 8010b3e:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 8010b42:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8010b46:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
 8010b4a:	e001      	b.n	8010b50 <USB_HC_Halt+0x54>
        if (++count > 1000U)
 8010b4c:	3b01      	subs	r3, #1
 8010b4e:	d02b      	beq.n	8010ba8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8010b50:	6811      	ldr	r1, [r2, #0]
 8010b52:	2900      	cmp	r1, #0
 8010b54:	dbfa      	blt.n	8010b4c <USB_HC_Halt+0x50>
}
 8010b56:	2000      	movs	r0, #0
 8010b58:	4770      	bx	lr
    if ((USBx_HOST->HPTXSTS & (0xFFU << 16)) == 0U)
 8010b5a:	f8d0 3410 	ldr.w	r3, [r0, #1040]	; 0x410
 8010b5e:	f413 0f7f 	tst.w	r3, #16711680	; 0xff0000
 8010b62:	d11b      	bne.n	8010b9c <USB_HC_Halt+0xa0>
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8010b64:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 8010b68:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_CHENA;
 8010b6c:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 8010b70:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8010b74:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 8010b78:	f040 4000 	orr.w	r0, r0, #2147483648	; 0x80000000
 8010b7c:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
      USBx_HC(hcnum)->HCCHAR &= ~USB_OTG_HCCHAR_EPDIR;
 8010b80:	f8d1 0500 	ldr.w	r0, [r1, #1280]	; 0x500
 8010b84:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8010b88:	f8c1 0500 	str.w	r0, [r1, #1280]	; 0x500
 8010b8c:	e001      	b.n	8010b92 <USB_HC_Halt+0x96>
        if (++count > 1000U)
 8010b8e:	3b01      	subs	r3, #1
 8010b90:	d00a      	beq.n	8010ba8 <USB_HC_Halt+0xac>
      while ((USBx_HC(hcnum)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8010b92:	6811      	ldr	r1, [r2, #0]
 8010b94:	2900      	cmp	r1, #0
 8010b96:	dbfa      	blt.n	8010b8e <USB_HC_Halt+0x92>
}
 8010b98:	2000      	movs	r0, #0
 8010b9a:	4770      	bx	lr
      USBx_HC(hcnum)->HCCHAR |= USB_OTG_HCCHAR_CHENA;
 8010b9c:	f8d1 3500 	ldr.w	r3, [r1, #1280]	; 0x500
 8010ba0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8010ba4:	f8c1 3500 	str.w	r3, [r1, #1280]	; 0x500
}
 8010ba8:	2000      	movs	r0, #0
 8010baa:	4770      	bx	lr

08010bac <USB_StopHost>:
  * @brief  Stop Host Core
  * @param  USBx  Selected device
  * @retval HAL state
  */
HAL_StatusTypeDef USB_StopHost(USB_OTG_GlobalTypeDef *USBx)
{
 8010bac:	b410      	push	{r4}
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8010bae:	6882      	ldr	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8010bb0:	f44f 6184 	mov.w	r1, #1056	; 0x420
 8010bb4:	f44f 6354 	mov.w	r3, #3392	; 0xd40
{
 8010bb8:	4604      	mov	r4, r0
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8010bba:	f022 0201 	bic.w	r2, r2, #1
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8010bbe:	f2c0 0303 	movt	r3, #3
  USBx->GAHBCFG &= ~USB_OTG_GAHBCFG_GINT;
 8010bc2:	6082      	str	r2, [r0, #8]
  USBx->GRSTCTL = (USB_OTG_GRSTCTL_TXFFLSH | (num << 6));
 8010bc4:	6101      	str	r1, [r0, #16]
 8010bc6:	e001      	b.n	8010bcc <USB_StopHost+0x20>
    if (++count > 200000U)
 8010bc8:	3b01      	subs	r3, #1
 8010bca:	d002      	beq.n	8010bd2 <USB_StopHost+0x26>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_TXFFLSH) == USB_OTG_GRSTCTL_TXFFLSH);
 8010bcc:	6922      	ldr	r2, [r4, #16]
 8010bce:	0691      	lsls	r1, r2, #26
 8010bd0:	d4fa      	bmi.n	8010bc8 <USB_StopHost+0x1c>
  USBx->GRSTCTL = USB_OTG_GRSTCTL_RXFFLSH;
 8010bd2:	2210      	movs	r2, #16
 8010bd4:	f44f 6354 	mov.w	r3, #3392	; 0xd40
 8010bd8:	6122      	str	r2, [r4, #16]
 8010bda:	f2c0 0303 	movt	r3, #3
 8010bde:	e001      	b.n	8010be4 <USB_StopHost+0x38>
    if (++count > 200000U)
 8010be0:	3b01      	subs	r3, #1
 8010be2:	d002      	beq.n	8010bea <USB_StopHost+0x3e>
  while ((USBx->GRSTCTL & USB_OTG_GRSTCTL_RXFFLSH) == USB_OTG_GRSTCTL_RXFFLSH);
 8010be4:	6922      	ldr	r2, [r4, #16]
 8010be6:	06d2      	lsls	r2, r2, #27
 8010be8:	d4fa      	bmi.n	8010be0 <USB_StopHost+0x34>
  (void)USB_FlushRxFifo(USBx);

  /* Flush out any leftover queued requests. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 8010bea:	f8d4 2500 	ldr.w	r2, [r4, #1280]	; 0x500
 8010bee:	f504 61a0 	add.w	r1, r4, #1280	; 0x500
 8010bf2:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
  uint32_t count = 0U;
 8010bf6:	2300      	movs	r3, #0
 8010bf8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value |=  USB_OTG_HCCHAR_CHDIS;
    value &= ~USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010bfc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c00:	f8c4 2500 	str.w	r2, [r4, #1280]	; 0x500
    value = USBx_HC(i)->HCCHAR;
 8010c04:	f8d4 2520 	ldr.w	r2, [r4, #1312]	; 0x520
 8010c08:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c0c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c10:	f8c4 2520 	str.w	r2, [r4, #1312]	; 0x520
    value = USBx_HC(i)->HCCHAR;
 8010c14:	f8d4 2540 	ldr.w	r2, [r4, #1344]	; 0x540
 8010c18:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c1c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c20:	f8c4 2540 	str.w	r2, [r4, #1344]	; 0x540
    value = USBx_HC(i)->HCCHAR;
 8010c24:	f8d4 2560 	ldr.w	r2, [r4, #1376]	; 0x560
 8010c28:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c2c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c30:	f8c4 2560 	str.w	r2, [r4, #1376]	; 0x560
    value = USBx_HC(i)->HCCHAR;
 8010c34:	f8d4 2580 	ldr.w	r2, [r4, #1408]	; 0x580
 8010c38:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c3c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c40:	f8c4 2580 	str.w	r2, [r4, #1408]	; 0x580
    value = USBx_HC(i)->HCCHAR;
 8010c44:	f8d4 25a0 	ldr.w	r2, [r4, #1440]	; 0x5a0
 8010c48:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c4c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c50:	f8c4 25a0 	str.w	r2, [r4, #1440]	; 0x5a0
    value = USBx_HC(i)->HCCHAR;
 8010c54:	f8d4 25c0 	ldr.w	r2, [r4, #1472]	; 0x5c0
 8010c58:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c5c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c60:	f8c4 25c0 	str.w	r2, [r4, #1472]	; 0x5c0
    value = USBx_HC(i)->HCCHAR;
 8010c64:	f8d4 25e0 	ldr.w	r2, [r4, #1504]	; 0x5e0
 8010c68:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c6c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c70:	f8c4 25e0 	str.w	r2, [r4, #1504]	; 0x5e0
    value = USBx_HC(i)->HCCHAR;
 8010c74:	f8d4 2600 	ldr.w	r2, [r4, #1536]	; 0x600
 8010c78:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c7c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c80:	f8c4 2600 	str.w	r2, [r4, #1536]	; 0x600
    value = USBx_HC(i)->HCCHAR;
 8010c84:	f8d4 2620 	ldr.w	r2, [r4, #1568]	; 0x620
 8010c88:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c8c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010c90:	f8c4 2620 	str.w	r2, [r4, #1568]	; 0x620
    value = USBx_HC(i)->HCCHAR;
 8010c94:	f8d4 2640 	ldr.w	r2, [r4, #1600]	; 0x640
 8010c98:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010c9c:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010ca0:	f8c4 2640 	str.w	r2, [r4, #1600]	; 0x640
    value = USBx_HC(i)->HCCHAR;
 8010ca4:	f8d4 2660 	ldr.w	r2, [r4, #1632]	; 0x660
 8010ca8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010cac:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010cb0:	f8c4 2660 	str.w	r2, [r4, #1632]	; 0x660
    value = USBx_HC(i)->HCCHAR;
 8010cb4:	f8d4 2680 	ldr.w	r2, [r4, #1664]	; 0x680
 8010cb8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010cbc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010cc0:	f8c4 2680 	str.w	r2, [r4, #1664]	; 0x680
    value = USBx_HC(i)->HCCHAR;
 8010cc4:	f8d4 26a0 	ldr.w	r2, [r4, #1696]	; 0x6a0
 8010cc8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010ccc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010cd0:	f8c4 26a0 	str.w	r2, [r4, #1696]	; 0x6a0
    value = USBx_HC(i)->HCCHAR;
 8010cd4:	f8d4 26c0 	ldr.w	r2, [r4, #1728]	; 0x6c0
 8010cd8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010cdc:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010ce0:	f8c4 26c0 	str.w	r2, [r4, #1728]	; 0x6c0
    value = USBx_HC(i)->HCCHAR;
 8010ce4:	f8d4 26e0 	ldr.w	r2, [r4, #1760]	; 0x6e0
 8010ce8:	f022 2280 	bic.w	r2, r2, #2147516416	; 0x80008000
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010cec:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
    USBx_HC(i)->HCCHAR = value;
 8010cf0:	f8c4 26e0 	str.w	r2, [r4, #1760]	; 0x6e0
  }

  /* Halt all channels to put them into a known state. */
  for (i = 0U; i <= 15U; i++)
  {
    value = USBx_HC(i)->HCCHAR;
 8010cf4:	680a      	ldr	r2, [r1, #0]
 8010cf6:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    value |= USB_OTG_HCCHAR_CHDIS;
    value |= USB_OTG_HCCHAR_CHENA;
    value &= ~USB_OTG_HCCHAR_EPDIR;
 8010cfa:	f042 4240 	orr.w	r2, r2, #3221225472	; 0xc0000000
    USBx_HC(i)->HCCHAR = value;
 8010cfe:	600a      	str	r2, [r1, #0]
 8010d00:	e002      	b.n	8010d08 <USB_StopHost+0x15c>
      if (++count > 1000U)
      {
        break;
      }
    }
    while ((USBx_HC(i)->HCCHAR & USB_OTG_HCCHAR_CHENA) == USB_OTG_HCCHAR_CHENA);
 8010d02:	680a      	ldr	r2, [r1, #0]
 8010d04:	2a00      	cmp	r2, #0
 8010d06:	da03      	bge.n	8010d10 <USB_StopHost+0x164>
      if (++count > 1000U)
 8010d08:	3301      	adds	r3, #1
 8010d0a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8010d0e:	d9f8      	bls.n	8010d02 <USB_StopHost+0x156>
 8010d10:	3120      	adds	r1, #32
  for (i = 0U; i <= 15U; i++)
 8010d12:	4281      	cmp	r1, r0
 8010d14:	d1ee      	bne.n	8010cf4 <USB_StopHost+0x148>
  }

  /* Clear any pending Host interrupts */
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 8010d16:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
  USBx->GINTSTS = 0xFFFFFFFFU;

  (void)USB_EnableGlobalInt(USBx);

  return HAL_OK;
}
 8010d1a:	2000      	movs	r0, #0
  USBx_HOST->HAINT = 0xFFFFFFFFU;
 8010d1c:	f8c4 3414 	str.w	r3, [r4, #1044]	; 0x414
  USBx->GINTSTS = 0xFFFFFFFFU;
 8010d20:	6163      	str	r3, [r4, #20]
  USBx->GAHBCFG |= USB_OTG_GAHBCFG_GINT;
 8010d22:	68a3      	ldr	r3, [r4, #8]
 8010d24:	f043 0301 	orr.w	r3, r3, #1
 8010d28:	60a3      	str	r3, [r4, #8]
}
 8010d2a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8010d2e:	4770      	bx	lr

08010d30 <USBH_Init>:
USBH_StatusTypeDef  USBH_Init(USBH_HandleTypeDef *phost,
                              void (*pUsrFunc)(USBH_HandleTypeDef *phost,
                              uint8_t id), uint8_t id)
{
  /* Check whether the USB Host handle is valid */
  if (phost == NULL)
 8010d30:	b3a0      	cbz	r0, 8010d9c <USBH_Init+0x6c>
{
 8010d32:	b570      	push	{r4, r5, r6, lr}
 8010d34:	4604      	mov	r4, r0

  /* Set DRiver ID */
  phost->id = id;

  /* Unlink class*/
  phost->pActiveClass = NULL;
 8010d36:	2500      	movs	r5, #0
  phost->id = id;
 8010d38:	f880 253c 	strb.w	r2, [r0, #1340]	; 0x53c
 8010d3c:	460e      	mov	r6, r1
 8010d3e:	223c      	movs	r2, #60	; 0x3c
 8010d40:	4629      	mov	r1, r5
 8010d42:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
  phost->pActiveClass = NULL;
 8010d46:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
  phost->ClassNumber = 0U;
 8010d4a:	f8c4 54f0 	str.w	r5, [r4, #1264]	; 0x4f0
 8010d4e:	f019 ffd4 	bl	802acfa <memset>
 8010d52:	4629      	mov	r1, r5
 8010d54:	f44f 7200 	mov.w	r2, #512	; 0x200
 8010d58:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 8010d5c:	f019 ffcd 	bl	802acfa <memset>
    phost->device.Data[i] = 0U;
  }

  phost->gState = HOST_IDLE;
  phost->EnumState = ENUM_IDLE;
  phost->RequestState = CMD_SEND;
 8010d60:	2301      	movs	r3, #1
  phost->Timer = 0U;

  phost->Control.state = CTRL_SETUP;
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8010d62:	2140      	movs	r1, #64	; 0x40
  phost->Control.errorcount = 0U;

  phost->device.address = USBH_ADDRESS_DEFAULT;
 8010d64:	f44f 7280 	mov.w	r2, #256	; 0x100
  phost->gState = HOST_IDLE;
 8010d68:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
 8010d6a:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
 8010d6c:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
 8010d70:	7665      	strb	r5, [r4, #25]
  phost->device.is_connected = 0U;
 8010d72:	f884 5320 	strb.w	r5, [r4, #800]	; 0x320
  phost->device.PortEnabled = 0U;
 8010d76:	f884 5323 	strb.w	r5, [r4, #803]	; 0x323
  phost->device.is_disconnected = 0U;
 8010d7a:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
  phost->RequestState = CMD_SEND;
 8010d7e:	70a3      	strb	r3, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
 8010d80:	f884 5322 	strb.w	r5, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
 8010d84:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8010d86:	71a1      	strb	r1, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
 8010d88:	f8c4 231c 	str.w	r2, [r4, #796]	; 0x31c
  if (pUsrFunc != NULL)
 8010d8c:	b10e      	cbz	r6, 8010d92 <USBH_Init+0x62>
    phost->pUser = pUsrFunc;
 8010d8e:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
  USBH_LL_Init(phost);
 8010d92:	4620      	mov	r0, r4
 8010d94:	f010 fdfa 	bl	802198c <USBH_LL_Init>
  return USBH_OK;
 8010d98:	2000      	movs	r0, #0
}
 8010d9a:	bd70      	pop	{r4, r5, r6, pc}
    return USBH_FAIL;
 8010d9c:	2002      	movs	r0, #2
}
 8010d9e:	4770      	bx	lr

08010da0 <USBH_DeInit>:
{
 8010da0:	b538      	push	{r3, r4, r5, lr}
 8010da2:	4604      	mov	r4, r0
 8010da4:	223c      	movs	r2, #60	; 0x3c
 8010da6:	2100      	movs	r1, #0
 8010da8:	f200 40f4 	addw	r0, r0, #1268	; 0x4f4
 8010dac:	f019 ffa5 	bl	802acfa <memset>
 8010db0:	f44f 7200 	mov.w	r2, #512	; 0x200
 8010db4:	2100      	movs	r1, #0
 8010db6:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 8010dba:	f019 ff9e 	bl	802acfa <memset>
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8010dbe:	2540      	movs	r5, #64	; 0x40
  phost->gState = HOST_IDLE;
 8010dc0:	2300      	movs	r3, #0
  phost->RequestState = CMD_SEND;
 8010dc2:	2201      	movs	r2, #1
  phost->device.address = USBH_ADDRESS_DEFAULT;
 8010dc4:	f44f 7080 	mov.w	r0, #256	; 0x100
  if (phost->pData != NULL)
 8010dc8:	f8d4 1540 	ldr.w	r1, [r4, #1344]	; 0x540
  phost->gState = HOST_IDLE;
 8010dcc:	7023      	strb	r3, [r4, #0]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 8010dce:	71a5      	strb	r5, [r4, #6]
  phost->Timer = 0U;
 8010dd0:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
  phost->device.address = USBH_ADDRESS_DEFAULT;
 8010dd4:	f8c4 031c 	str.w	r0, [r4, #796]	; 0x31c
  phost->device.is_connected = 0U;
 8010dd8:	f884 3320 	strb.w	r3, [r4, #800]	; 0x320
  phost->EnumState = ENUM_IDLE;
 8010ddc:	7063      	strb	r3, [r4, #1]
  phost->device.is_disconnected = 0U;
 8010dde:	f884 3321 	strb.w	r3, [r4, #801]	; 0x321
  phost->Control.errorcount = 0U;
 8010de2:	7663      	strb	r3, [r4, #25]
  phost->device.PortEnabled = 0U;
 8010de4:	f884 3323 	strb.w	r3, [r4, #803]	; 0x323
  phost->RequestState = CMD_SEND;
 8010de8:	70a2      	strb	r2, [r4, #2]
  phost->device.is_ReEnumerated = 0U;
 8010dea:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  phost->Control.state = CTRL_SETUP;
 8010dee:	7622      	strb	r2, [r4, #24]
  if (phost->pData != NULL)
 8010df0:	b111      	cbz	r1, 8010df8 <USBH_DeInit+0x58>
    USBH_LL_Stop(phost);
 8010df2:	4620      	mov	r0, r4
 8010df4:	f010 fe0a 	bl	8021a0c <USBH_LL_Stop>
}
 8010df8:	2000      	movs	r0, #0
 8010dfa:	bd38      	pop	{r3, r4, r5, pc}

08010dfc <USBH_RegisterClass>:
  */
USBH_StatusTypeDef USBH_RegisterClass(USBH_HandleTypeDef *phost, USBH_ClassTypeDef *pclass)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (pclass != NULL)
 8010dfc:	b149      	cbz	r1, 8010e12 <USBH_RegisterClass+0x16>
  {
    if (phost->ClassNumber < USBH_MAX_NUM_SUPPORTED_CLASS)
 8010dfe:	f8d0 34f0 	ldr.w	r3, [r0, #1264]	; 0x4f0
 8010e02:	b933      	cbnz	r3, 8010e12 <USBH_RegisterClass+0x16>
    {
      /* link the class to the USB Host handle */
      phost->pClass[phost->ClassNumber++] = pclass;
 8010e04:	2201      	movs	r2, #1
 8010e06:	f8c0 14e8 	str.w	r1, [r0, #1256]	; 0x4e8
 8010e0a:	f8c0 24f0 	str.w	r2, [r0, #1264]	; 0x4f0
    USBH_ErrLog("Invalid Class handle");
    status = USBH_FAIL;
  }

  return status;
}
 8010e0e:	4618      	mov	r0, r3
 8010e10:	4770      	bx	lr
    status = USBH_FAIL;
 8010e12:	2302      	movs	r3, #2
}
 8010e14:	4618      	mov	r0, r3
 8010e16:	4770      	bx	lr

08010e18 <USBH_SelectInterface>:
  */
USBH_StatusTypeDef USBH_SelectInterface(USBH_HandleTypeDef *phost, uint8_t interface)
{
  USBH_StatusTypeDef status = USBH_OK;

  if (interface < phost->device.CfgDesc.bNumInterfaces)
 8010e18:	f890 333c 	ldrb.w	r3, [r0, #828]	; 0x33c
 8010e1c:	428b      	cmp	r3, r1
 8010e1e:	d903      	bls.n	8010e28 <USBH_SelectInterface+0x10>
  {
    phost->device.current_interface = interface;
 8010e20:	f880 1324 	strb.w	r1, [r0, #804]	; 0x324
  USBH_StatusTypeDef status = USBH_OK;
 8010e24:	2000      	movs	r0, #0
 8010e26:	4770      	bx	lr
    USBH_UsrLog("Protocol : %xh", phost->device.CfgDesc.Itf_Desc[interface].bInterfaceProtocol);
  }
  else
  {
    USBH_ErrLog("Cannot Select This Interface.");
    status = USBH_FAIL;
 8010e28:	2002      	movs	r0, #2
  }

  return status;
}
 8010e2a:	4770      	bx	lr

08010e2c <USBH_FindInterface>:
  * @param  Protocol: Protocol code
  * @retval interface index in the configuration structure
  * @note : (1)interface index 0xFF means interface index not found
  */
uint8_t  USBH_FindInterface(USBH_HandleTypeDef *phost, uint8_t Class, uint8_t SubClass, uint8_t Protocol)
{
 8010e2c:	b430      	push	{r4, r5}
 8010e2e:	f1a1 04ff 	sub.w	r4, r1, #255	; 0xff
  pcfg = &phost->device.CfgDesc;

  while (if_ix < USBH_MAX_NUM_INTERFACES)
  {
    pif = &pcfg->Itf_Desc[if_ix];
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010e32:	f890 5347 	ldrb.w	r5, [r0, #839]	; 0x347
 8010e36:	fab4 f484 	clz	r4, r4
 8010e3a:	428d      	cmp	r5, r1
 8010e3c:	ea4f 1454 	mov.w	r4, r4, lsr #5
 8010e40:	d03c      	beq.n	8010ebc <USBH_FindInterface+0x90>
 8010e42:	2c00      	cmp	r4, #0
 8010e44:	d13a      	bne.n	8010ebc <USBH_FindInterface+0x90>
 8010e46:	f890 5371 	ldrb.w	r5, [r0, #881]	; 0x371
 8010e4a:	428d      	cmp	r5, r1
 8010e4c:	d044      	beq.n	8010ed8 <USBH_FindInterface+0xac>
 8010e4e:	2c00      	cmp	r4, #0
 8010e50:	d142      	bne.n	8010ed8 <USBH_FindInterface+0xac>
 8010e52:	f890 539b 	ldrb.w	r5, [r0, #923]	; 0x39b
 8010e56:	428d      	cmp	r5, r1
 8010e58:	d04c      	beq.n	8010ef4 <USBH_FindInterface+0xc8>
 8010e5a:	2c00      	cmp	r4, #0
 8010e5c:	d14a      	bne.n	8010ef4 <USBH_FindInterface+0xc8>
 8010e5e:	f890 53c5 	ldrb.w	r5, [r0, #965]	; 0x3c5
 8010e62:	428d      	cmp	r5, r1
 8010e64:	d054      	beq.n	8010f10 <USBH_FindInterface+0xe4>
 8010e66:	2c00      	cmp	r4, #0
 8010e68:	d152      	bne.n	8010f10 <USBH_FindInterface+0xe4>
 8010e6a:	f890 53ef 	ldrb.w	r5, [r0, #1007]	; 0x3ef
 8010e6e:	428d      	cmp	r5, r1
 8010e70:	d05c      	beq.n	8010f2c <USBH_FindInterface+0x100>
 8010e72:	2c00      	cmp	r4, #0
 8010e74:	d15a      	bne.n	8010f2c <USBH_FindInterface+0x100>
 8010e76:	f890 5419 	ldrb.w	r5, [r0, #1049]	; 0x419
 8010e7a:	428d      	cmp	r5, r1
 8010e7c:	d064      	beq.n	8010f48 <USBH_FindInterface+0x11c>
 8010e7e:	2c00      	cmp	r4, #0
 8010e80:	d162      	bne.n	8010f48 <USBH_FindInterface+0x11c>
 8010e82:	f890 5443 	ldrb.w	r5, [r0, #1091]	; 0x443
 8010e86:	428d      	cmp	r5, r1
 8010e88:	d06c      	beq.n	8010f64 <USBH_FindInterface+0x138>
 8010e8a:	2c00      	cmp	r4, #0
 8010e8c:	d16a      	bne.n	8010f64 <USBH_FindInterface+0x138>
 8010e8e:	f890 546d 	ldrb.w	r5, [r0, #1133]	; 0x46d
 8010e92:	428d      	cmp	r5, r1
 8010e94:	d074      	beq.n	8010f80 <USBH_FindInterface+0x154>
 8010e96:	2c00      	cmp	r4, #0
 8010e98:	d172      	bne.n	8010f80 <USBH_FindInterface+0x154>
 8010e9a:	f890 5497 	ldrb.w	r5, [r0, #1175]	; 0x497
 8010e9e:	428d      	cmp	r5, r1
 8010ea0:	d07c      	beq.n	8010f9c <USBH_FindInterface+0x170>
 8010ea2:	2c00      	cmp	r4, #0
 8010ea4:	d17a      	bne.n	8010f9c <USBH_FindInterface+0x170>
 8010ea6:	f890 54c1 	ldrb.w	r5, [r0, #1217]	; 0x4c1
 8010eaa:	428d      	cmp	r5, r1
 8010eac:	f000 8086 	beq.w	8010fbc <USBH_FindInterface+0x190>
 8010eb0:	2c00      	cmp	r4, #0
 8010eb2:	f040 8083 	bne.w	8010fbc <USBH_FindInterface+0x190>
    {
      return  if_ix;
    }
    if_ix++;
  }
  return 0xFFU;
 8010eb6:	20ff      	movs	r0, #255	; 0xff
}
 8010eb8:	bc30      	pop	{r4, r5}
 8010eba:	4770      	bx	lr
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010ebc:	f890 5348 	ldrb.w	r5, [r0, #840]	; 0x348
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010ec0:	4295      	cmp	r5, r2
 8010ec2:	d001      	beq.n	8010ec8 <USBH_FindInterface+0x9c>
 8010ec4:	2aff      	cmp	r2, #255	; 0xff
 8010ec6:	d1be      	bne.n	8010e46 <USBH_FindInterface+0x1a>
 8010ec8:	f890 5349 	ldrb.w	r5, [r0, #841]	; 0x349
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010ecc:	429d      	cmp	r5, r3
 8010ece:	d001      	beq.n	8010ed4 <USBH_FindInterface+0xa8>
 8010ed0:	2bff      	cmp	r3, #255	; 0xff
 8010ed2:	d1b8      	bne.n	8010e46 <USBH_FindInterface+0x1a>
  uint8_t if_ix = 0U;
 8010ed4:	2000      	movs	r0, #0
 8010ed6:	e7ef      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010ed8:	f890 5372 	ldrb.w	r5, [r0, #882]	; 0x372
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010edc:	4295      	cmp	r5, r2
 8010ede:	d001      	beq.n	8010ee4 <USBH_FindInterface+0xb8>
 8010ee0:	2aff      	cmp	r2, #255	; 0xff
 8010ee2:	d1b6      	bne.n	8010e52 <USBH_FindInterface+0x26>
 8010ee4:	f890 5373 	ldrb.w	r5, [r0, #883]	; 0x373
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010ee8:	429d      	cmp	r5, r3
 8010eea:	d001      	beq.n	8010ef0 <USBH_FindInterface+0xc4>
 8010eec:	2bff      	cmp	r3, #255	; 0xff
 8010eee:	d1b0      	bne.n	8010e52 <USBH_FindInterface+0x26>
    if_ix++;
 8010ef0:	2001      	movs	r0, #1
 8010ef2:	e7e1      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010ef4:	f890 539c 	ldrb.w	r5, [r0, #924]	; 0x39c
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010ef8:	4295      	cmp	r5, r2
 8010efa:	d001      	beq.n	8010f00 <USBH_FindInterface+0xd4>
 8010efc:	2aff      	cmp	r2, #255	; 0xff
 8010efe:	d1ae      	bne.n	8010e5e <USBH_FindInterface+0x32>
 8010f00:	f890 539d 	ldrb.w	r5, [r0, #925]	; 0x39d
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f04:	429d      	cmp	r5, r3
 8010f06:	d001      	beq.n	8010f0c <USBH_FindInterface+0xe0>
 8010f08:	2bff      	cmp	r3, #255	; 0xff
 8010f0a:	d1a8      	bne.n	8010e5e <USBH_FindInterface+0x32>
    if_ix++;
 8010f0c:	2002      	movs	r0, #2
 8010f0e:	e7d3      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f10:	f890 53c6 	ldrb.w	r5, [r0, #966]	; 0x3c6
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010f14:	4295      	cmp	r5, r2
 8010f16:	d001      	beq.n	8010f1c <USBH_FindInterface+0xf0>
 8010f18:	2aff      	cmp	r2, #255	; 0xff
 8010f1a:	d1a6      	bne.n	8010e6a <USBH_FindInterface+0x3e>
 8010f1c:	f890 53c7 	ldrb.w	r5, [r0, #967]	; 0x3c7
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f20:	429d      	cmp	r5, r3
 8010f22:	d001      	beq.n	8010f28 <USBH_FindInterface+0xfc>
 8010f24:	2bff      	cmp	r3, #255	; 0xff
 8010f26:	d1a0      	bne.n	8010e6a <USBH_FindInterface+0x3e>
    if_ix++;
 8010f28:	2003      	movs	r0, #3
 8010f2a:	e7c5      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f2c:	f890 53f0 	ldrb.w	r5, [r0, #1008]	; 0x3f0
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010f30:	4295      	cmp	r5, r2
 8010f32:	d001      	beq.n	8010f38 <USBH_FindInterface+0x10c>
 8010f34:	2aff      	cmp	r2, #255	; 0xff
 8010f36:	d19e      	bne.n	8010e76 <USBH_FindInterface+0x4a>
 8010f38:	f890 53f1 	ldrb.w	r5, [r0, #1009]	; 0x3f1
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f3c:	429d      	cmp	r5, r3
 8010f3e:	d001      	beq.n	8010f44 <USBH_FindInterface+0x118>
 8010f40:	2bff      	cmp	r3, #255	; 0xff
 8010f42:	d198      	bne.n	8010e76 <USBH_FindInterface+0x4a>
    if_ix++;
 8010f44:	2004      	movs	r0, #4
 8010f46:	e7b7      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f48:	f890 541a 	ldrb.w	r5, [r0, #1050]	; 0x41a
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010f4c:	4295      	cmp	r5, r2
 8010f4e:	d001      	beq.n	8010f54 <USBH_FindInterface+0x128>
 8010f50:	2aff      	cmp	r2, #255	; 0xff
 8010f52:	d196      	bne.n	8010e82 <USBH_FindInterface+0x56>
 8010f54:	f890 541b 	ldrb.w	r5, [r0, #1051]	; 0x41b
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f58:	429d      	cmp	r5, r3
 8010f5a:	d001      	beq.n	8010f60 <USBH_FindInterface+0x134>
 8010f5c:	2bff      	cmp	r3, #255	; 0xff
 8010f5e:	d190      	bne.n	8010e82 <USBH_FindInterface+0x56>
    if_ix++;
 8010f60:	2005      	movs	r0, #5
 8010f62:	e7a9      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f64:	f890 5444 	ldrb.w	r5, [r0, #1092]	; 0x444
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010f68:	4295      	cmp	r5, r2
 8010f6a:	d001      	beq.n	8010f70 <USBH_FindInterface+0x144>
 8010f6c:	2aff      	cmp	r2, #255	; 0xff
 8010f6e:	d18e      	bne.n	8010e8e <USBH_FindInterface+0x62>
 8010f70:	f890 5445 	ldrb.w	r5, [r0, #1093]	; 0x445
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f74:	429d      	cmp	r5, r3
 8010f76:	d001      	beq.n	8010f7c <USBH_FindInterface+0x150>
 8010f78:	2bff      	cmp	r3, #255	; 0xff
 8010f7a:	d188      	bne.n	8010e8e <USBH_FindInterface+0x62>
    if_ix++;
 8010f7c:	2006      	movs	r0, #6
 8010f7e:	e79b      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f80:	f890 546e 	ldrb.w	r5, [r0, #1134]	; 0x46e
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010f84:	4295      	cmp	r5, r2
 8010f86:	d001      	beq.n	8010f8c <USBH_FindInterface+0x160>
 8010f88:	2aff      	cmp	r2, #255	; 0xff
 8010f8a:	d186      	bne.n	8010e9a <USBH_FindInterface+0x6e>
 8010f8c:	f890 546f 	ldrb.w	r5, [r0, #1135]	; 0x46f
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010f90:	429d      	cmp	r5, r3
 8010f92:	d001      	beq.n	8010f98 <USBH_FindInterface+0x16c>
 8010f94:	2bff      	cmp	r3, #255	; 0xff
 8010f96:	d180      	bne.n	8010e9a <USBH_FindInterface+0x6e>
    if_ix++;
 8010f98:	2007      	movs	r0, #7
 8010f9a:	e78d      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010f9c:	f890 5498 	ldrb.w	r5, [r0, #1176]	; 0x498
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010fa0:	4295      	cmp	r5, r2
 8010fa2:	d002      	beq.n	8010faa <USBH_FindInterface+0x17e>
 8010fa4:	2aff      	cmp	r2, #255	; 0xff
 8010fa6:	f47f af7e 	bne.w	8010ea6 <USBH_FindInterface+0x7a>
 8010faa:	f890 5499 	ldrb.w	r5, [r0, #1177]	; 0x499
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010fae:	429d      	cmp	r5, r3
 8010fb0:	d002      	beq.n	8010fb8 <USBH_FindInterface+0x18c>
 8010fb2:	2bff      	cmp	r3, #255	; 0xff
 8010fb4:	f47f af77 	bne.w	8010ea6 <USBH_FindInterface+0x7a>
    if_ix++;
 8010fb8:	2008      	movs	r0, #8
 8010fba:	e77d      	b.n	8010eb8 <USBH_FindInterface+0x8c>
    if (((pif->bInterfaceClass == Class) || (Class == 0xFFU)) &&
 8010fbc:	f890 14c2 	ldrb.w	r1, [r0, #1218]	; 0x4c2
        ((pif->bInterfaceSubClass == SubClass) || (SubClass == 0xFFU)) &&
 8010fc0:	4291      	cmp	r1, r2
 8010fc2:	d002      	beq.n	8010fca <USBH_FindInterface+0x19e>
 8010fc4:	2aff      	cmp	r2, #255	; 0xff
 8010fc6:	f47f af76 	bne.w	8010eb6 <USBH_FindInterface+0x8a>
 8010fca:	f890 24c3 	ldrb.w	r2, [r0, #1219]	; 0x4c3
        ((pif->bInterfaceProtocol == Protocol) || (Protocol == 0xFFU)))
 8010fce:	429a      	cmp	r2, r3
 8010fd0:	d002      	beq.n	8010fd8 <USBH_FindInterface+0x1ac>
 8010fd2:	2bff      	cmp	r3, #255	; 0xff
 8010fd4:	f47f af6f 	bne.w	8010eb6 <USBH_FindInterface+0x8a>
    if_ix++;
 8010fd8:	2009      	movs	r0, #9
 8010fda:	e76d      	b.n	8010eb8 <USBH_FindInterface+0x8c>

08010fdc <USBH_Start>:
  *         Start the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Start(USBH_HandleTypeDef *phost)
{
 8010fdc:	b510      	push	{r4, lr}
 8010fde:	4604      	mov	r4, r0
  /* Start the low level driver  */
  USBH_LL_Start(phost);
 8010fe0:	f010 fd04 	bl	80219ec <USBH_LL_Start>

  /* Activate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 1);
 8010fe4:	2101      	movs	r1, #1
 8010fe6:	4620      	mov	r0, r4
 8010fe8:	f010 fd92 	bl	8021b10 <USBH_LL_DriverVBUS>

  return USBH_OK;
}
 8010fec:	2000      	movs	r0, #0
 8010fee:	bd10      	pop	{r4, pc}

08010ff0 <USBH_Stop>:
  *         Stop the USB Host Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Stop(USBH_HandleTypeDef *phost)
{
 8010ff0:	b510      	push	{r4, lr}
 8010ff2:	4604      	mov	r4, r0
  /* DeActivate VBUS on the port */
  USBH_LL_DriverVBUS(phost, 0);
 8010ff4:	2100      	movs	r1, #0
 8010ff6:	f010 fd8b 	bl	8021b10 <USBH_LL_DriverVBUS>

  /* Stop and cleanup the low level driver  */
  USBH_LL_Stop(phost);
 8010ffa:	4620      	mov	r0, r4
 8010ffc:	f010 fd06 	bl	8021a0c <USBH_LL_Stop>

  /* Free Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
 8011000:	7921      	ldrb	r1, [r4, #4]
 8011002:	4620      	mov	r0, r4
 8011004:	f001 fa62 	bl	80124cc <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
 8011008:	7961      	ldrb	r1, [r4, #5]
 801100a:	4620      	mov	r0, r4
 801100c:	f001 fa5e 	bl	80124cc <USBH_FreePipe>

  return USBH_OK;
}
 8011010:	2000      	movs	r0, #0
 8011012:	bd10      	pop	{r4, pc}

08011014 <USBH_Process>:
  *         Background process of the USB Core.
  * @param  phost: Host Handle
  * @retval USBH Status
  */
USBH_StatusTypeDef  USBH_Process(USBH_HandleTypeDef *phost)
{
 8011014:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 8011016:	2302      	movs	r3, #2
{
 8011018:	b087      	sub	sp, #28
 801101a:	4604      	mov	r4, r0
  __IO USBH_StatusTypeDef status = USBH_FAIL;
 801101c:	f88d 3017 	strb.w	r3, [sp, #23]
  uint8_t idx = 0U;

  /* check for Host pending port disconnect event */
  if (phost->device.is_disconnected == 1U)
 8011020:	f890 3321 	ldrb.w	r3, [r0, #801]	; 0x321
 8011024:	2b01      	cmp	r3, #1
 8011026:	d101      	bne.n	801102c <USBH_Process+0x18>
  {
    phost->gState = HOST_DEV_DISCONNECTED;
 8011028:	2303      	movs	r3, #3
 801102a:	7003      	strb	r3, [r0, #0]
  }

  switch (phost->gState)
 801102c:	7823      	ldrb	r3, [r4, #0]
 801102e:	2b0b      	cmp	r3, #11
 8011030:	d84f      	bhi.n	80110d2 <USBH_Process+0xbe>
 8011032:	e8df f013 	tbh	[pc, r3, lsl #1]
 8011036:	0059      	.short	0x0059
 8011038:	0082006b 	.word	0x0082006b
 801103c:	004e00b8 	.word	0x004e00b8
 8011040:	00f700ee 	.word	0x00f700ee
 8011044:	011f010c 	.word	0x011f010c
 8011048:	000c0117 	.word	0x000c0117
 801104c:	0051      	.short	0x0051
#endif
      break;

    case HOST_CHECK_CLASS:

      if (phost->ClassNumber == 0U)
 801104e:	f8d4 34f0 	ldr.w	r3, [r4, #1264]	; 0x4f0
 8011052:	2b00      	cmp	r3, #0
 8011054:	d03d      	beq.n	80110d2 <USBH_Process+0xbe>
      {
        USBH_UsrLog("No Class has been registered.");
      }
      else
      {
        phost->pActiveClass = NULL;
 8011056:	2300      	movs	r3, #0

        for (idx = 0U; idx < USBH_MAX_NUM_SUPPORTED_CLASS; idx++)
        {
          for (int j = 0; j < 10; j++)
          {
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
 8011058:	f8d4 14e8 	ldr.w	r1, [r4, #1256]	; 0x4e8
 801105c:	f894 2347 	ldrb.w	r2, [r4, #839]	; 0x347
        phost->pActiveClass = NULL;
 8011060:	f8c4 34ec 	str.w	r3, [r4, #1260]	; 0x4ec
			  if (phost->pClass[idx]->ClassCode == phost->device.CfgDesc.Itf_Desc[j].bInterfaceClass)
 8011064:	790b      	ldrb	r3, [r1, #4]
 8011066:	429a      	cmp	r2, r3
 8011068:	d024      	beq.n	80110b4 <USBH_Process+0xa0>
 801106a:	f894 2371 	ldrb.w	r2, [r4, #881]	; 0x371
 801106e:	429a      	cmp	r2, r3
 8011070:	d020      	beq.n	80110b4 <USBH_Process+0xa0>
 8011072:	f894 239b 	ldrb.w	r2, [r4, #923]	; 0x39b
 8011076:	429a      	cmp	r2, r3
 8011078:	d01c      	beq.n	80110b4 <USBH_Process+0xa0>
 801107a:	f894 23c5 	ldrb.w	r2, [r4, #965]	; 0x3c5
 801107e:	429a      	cmp	r2, r3
 8011080:	d018      	beq.n	80110b4 <USBH_Process+0xa0>
 8011082:	f894 23ef 	ldrb.w	r2, [r4, #1007]	; 0x3ef
 8011086:	429a      	cmp	r2, r3
 8011088:	d014      	beq.n	80110b4 <USBH_Process+0xa0>
 801108a:	f894 2419 	ldrb.w	r2, [r4, #1049]	; 0x419
 801108e:	429a      	cmp	r2, r3
 8011090:	d010      	beq.n	80110b4 <USBH_Process+0xa0>
 8011092:	f894 2443 	ldrb.w	r2, [r4, #1091]	; 0x443
 8011096:	429a      	cmp	r2, r3
 8011098:	d00c      	beq.n	80110b4 <USBH_Process+0xa0>
 801109a:	f894 246d 	ldrb.w	r2, [r4, #1133]	; 0x46d
 801109e:	429a      	cmp	r2, r3
 80110a0:	d008      	beq.n	80110b4 <USBH_Process+0xa0>
 80110a2:	f894 2497 	ldrb.w	r2, [r4, #1175]	; 0x497
 80110a6:	429a      	cmp	r2, r3
 80110a8:	d004      	beq.n	80110b4 <USBH_Process+0xa0>
 80110aa:	f894 24c1 	ldrb.w	r2, [r4, #1217]	; 0x4c1
 80110ae:	429a      	cmp	r2, r3
 80110b0:	f040 80c8 	bne.w	8011244 <USBH_Process+0x230>
			  {
				phost->pActiveClass = phost->pClass[idx];
 80110b4:	f8c4 14ec 	str.w	r1, [r4, #1260]	; 0x4ec
          }
        }

        if (phost->pActiveClass != NULL)
        {
          if (phost->pActiveClass->Init(phost) == USBH_OK)
 80110b8:	4620      	mov	r0, r4
 80110ba:	688b      	ldr	r3, [r1, #8]
 80110bc:	4798      	blx	r3
 80110be:	2800      	cmp	r0, #0
 80110c0:	f040 80c0 	bne.w	8011244 <USBH_Process+0x230>
          {
            phost->gState = HOST_CLASS_REQUEST;
 80110c4:	2206      	movs	r2, #6
            USBH_UsrLog("%s class started.", phost->pActiveClass->Name);

            /* Inform user that a class has been activated */
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 80110c6:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 80110ca:	4620      	mov	r0, r4
 80110cc:	2103      	movs	r1, #3
            phost->gState = HOST_CLASS_REQUEST;
 80110ce:	7022      	strb	r2, [r4, #0]
            phost->pUser(phost, HOST_USER_CLASS_SELECTED);
 80110d0:	4798      	blx	r3
    case HOST_ABORT_STATE:
    default :
      break;
  }
  return USBH_OK;
}
 80110d2:	2000      	movs	r0, #0
 80110d4:	b007      	add	sp, #28
 80110d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pActiveClass != NULL)
 80110d8:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 80110dc:	2b00      	cmp	r3, #0
 80110de:	d0f8      	beq.n	80110d2 <USBH_Process+0xbe>
        phost->pActiveClass->BgndProcess(phost);
 80110e0:	695b      	ldr	r3, [r3, #20]
 80110e2:	4620      	mov	r0, r4
 80110e4:	4798      	blx	r3
 80110e6:	e7f4      	b.n	80110d2 <USBH_Process+0xbe>
      if (phost->device.is_connected)
 80110e8:	f894 3320 	ldrb.w	r3, [r4, #800]	; 0x320
 80110ec:	2b00      	cmp	r3, #0
 80110ee:	d0f0      	beq.n	80110d2 <USBH_Process+0xbe>
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 80110f0:	2301      	movs	r3, #1
        USBH_Delay(200U);
 80110f2:	20c8      	movs	r0, #200	; 0xc8
        phost->gState = HOST_DEV_WAIT_FOR_ATTACHMENT;
 80110f4:	7023      	strb	r3, [r4, #0]
        USBH_Delay(200U);
 80110f6:	f010 fd2f 	bl	8021b58 <USBH_Delay>
        USBH_LL_ResetPort(phost);
 80110fa:	4620      	mov	r0, r4
 80110fc:	f010 fca6 	bl	8021a4c <USBH_LL_ResetPort>
        phost->device.address = USBH_ADDRESS_DEFAULT;
 8011100:	2300      	movs	r3, #0
 8011102:	f884 331c 	strb.w	r3, [r4, #796]	; 0x31c
        phost->Timeout = 0U;
 8011106:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
 801110a:	e7e2      	b.n	80110d2 <USBH_Process+0xbe>
      if (phost->device.PortEnabled == 1U)
 801110c:	f894 3323 	ldrb.w	r3, [r4, #803]	; 0x323
 8011110:	2b01      	cmp	r3, #1
 8011112:	f000 8145 	beq.w	80113a0 <USBH_Process+0x38c>
        if (phost->Timeout > USBH_DEV_RESET_TIMEOUT)
 8011116:	f8d4 3538 	ldr.w	r3, [r4, #1336]	; 0x538
 801111a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 801111e:	f240 80b7 	bls.w	8011290 <USBH_Process+0x27c>
          phost->device.RstCnt++;
 8011122:	f894 331f 	ldrb.w	r3, [r4, #799]	; 0x31f
 8011126:	3301      	adds	r3, #1
 8011128:	b2db      	uxtb	r3, r3
          if (phost->device.RstCnt > 3U)
 801112a:	2b03      	cmp	r3, #3
          phost->device.RstCnt++;
 801112c:	f884 331f 	strb.w	r3, [r4, #799]	; 0x31f
          if (phost->device.RstCnt > 3U)
 8011130:	f200 8088 	bhi.w	8011244 <USBH_Process+0x230>
            phost->gState = HOST_IDLE;
 8011134:	2300      	movs	r3, #0
 8011136:	7023      	strb	r3, [r4, #0]
 8011138:	e7cb      	b.n	80110d2 <USBH_Process+0xbe>
      if (phost->pUser != NULL)
 801113a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 801113e:	b113      	cbz	r3, 8011146 <USBH_Process+0x132>
        phost->pUser(phost, HOST_USER_CONNECTION);
 8011140:	2104      	movs	r1, #4
 8011142:	4620      	mov	r0, r4
 8011144:	4798      	blx	r3
      USBH_Delay(100U);
 8011146:	2064      	movs	r0, #100	; 0x64
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 8011148:	2500      	movs	r5, #0
      USBH_Delay(100U);
 801114a:	f010 fd05 	bl	8021b58 <USBH_Delay>
      phost->device.speed = USBH_LL_GetSpeed(phost);
 801114e:	4620      	mov	r0, r4
 8011150:	f010 fc6c 	bl	8021a2c <USBH_LL_GetSpeed>
      phost->gState = HOST_ENUMERATION;
 8011154:	2305      	movs	r3, #5
      phost->device.speed = USBH_LL_GetSpeed(phost);
 8011156:	f884 031d 	strb.w	r0, [r4, #797]	; 0x31d
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 801115a:	4629      	mov	r1, r5
      phost->gState = HOST_ENUMERATION;
 801115c:	7023      	strb	r3, [r4, #0]
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 801115e:	4620      	mov	r0, r4
 8011160:	f001 f96a 	bl	8012438 <USBH_AllocPipe>
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8011164:	2180      	movs	r1, #128	; 0x80
      phost->Control.pipe_out = USBH_AllocPipe(phost, 0x00U);
 8011166:	7160      	strb	r0, [r4, #5]
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 8011168:	4620      	mov	r0, r4
 801116a:	f001 f965 	bl	8012438 <USBH_AllocPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 801116e:	79a7      	ldrb	r7, [r4, #6]
 8011170:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
 8011174:	4601      	mov	r1, r0
 8011176:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 801117a:	2280      	movs	r2, #128	; 0x80
      phost->Control.pipe_in  = USBH_AllocPipe(phost, 0x80U);
 801117c:	7120      	strb	r0, [r4, #4]
      USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,
 801117e:	4620      	mov	r0, r4
 8011180:	9702      	str	r7, [sp, #8]
 8011182:	e9cd 6500 	strd	r6, r5, [sp]
 8011186:	f001 f941 	bl	801240c <USBH_OpenPipe>
      USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U,
 801118a:	79a7      	ldrb	r7, [r4, #6]
 801118c:	f894 631d 	ldrb.w	r6, [r4, #797]	; 0x31d
 8011190:	462a      	mov	r2, r5
 8011192:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 8011196:	4620      	mov	r0, r4
 8011198:	7961      	ldrb	r1, [r4, #5]
 801119a:	9501      	str	r5, [sp, #4]
 801119c:	9702      	str	r7, [sp, #8]
 801119e:	9600      	str	r6, [sp, #0]
 80111a0:	f001 f934 	bl	801240c <USBH_OpenPipe>
      break;
 80111a4:	e795      	b.n	80110d2 <USBH_Process+0xbe>
      phost->device.is_disconnected = 0U;
 80111a6:	2500      	movs	r5, #0
 80111a8:	223c      	movs	r2, #60	; 0x3c
 80111aa:	f204 40f4 	addw	r0, r4, #1268	; 0x4f4
 80111ae:	4629      	mov	r1, r5
 80111b0:	f884 5321 	strb.w	r5, [r4, #801]	; 0x321
 80111b4:	f019 fda1 	bl	802acfa <memset>
 80111b8:	4629      	mov	r1, r5
 80111ba:	f44f 7200 	mov.w	r2, #512	; 0x200
 80111be:	f504 708e 	add.w	r0, r4, #284	; 0x11c
 80111c2:	f019 fd9a 	bl	802acfa <memset>
  phost->RequestState = CMD_SEND;
 80111c6:	2301      	movs	r3, #1
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 80111c8:	2040      	movs	r0, #64	; 0x40
  phost->device.address = USBH_ADDRESS_DEFAULT;
 80111ca:	f44f 7180 	mov.w	r1, #256	; 0x100
      if (phost->pActiveClass != NULL)
 80111ce:	f8d4 24ec 	ldr.w	r2, [r4, #1260]	; 0x4ec
  phost->gState = HOST_IDLE;
 80111d2:	7025      	strb	r5, [r4, #0]
  phost->EnumState = ENUM_IDLE;
 80111d4:	7065      	strb	r5, [r4, #1]
  phost->Timer = 0U;
 80111d6:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
  phost->Control.errorcount = 0U;
 80111da:	7665      	strb	r5, [r4, #25]
  phost->RequestState = CMD_SEND;
 80111dc:	70a3      	strb	r3, [r4, #2]
  phost->Control.state = CTRL_SETUP;
 80111de:	7623      	strb	r3, [r4, #24]
  phost->Control.pipe_size = USBH_MPS_DEFAULT;
 80111e0:	71a0      	strb	r0, [r4, #6]
  phost->device.address = USBH_ADDRESS_DEFAULT;
 80111e2:	f8c4 131c 	str.w	r1, [r4, #796]	; 0x31c
      if (phost->pActiveClass != NULL)
 80111e6:	b122      	cbz	r2, 80111f2 <USBH_Process+0x1de>
        phost->pActiveClass->DeInit(phost);
 80111e8:	68d3      	ldr	r3, [r2, #12]
 80111ea:	4620      	mov	r0, r4
 80111ec:	4798      	blx	r3
        phost->pActiveClass = NULL;
 80111ee:	f8c4 54ec 	str.w	r5, [r4, #1260]	; 0x4ec
      if (phost->pUser != NULL)
 80111f2:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 80111f6:	b113      	cbz	r3, 80111fe <USBH_Process+0x1ea>
        phost->pUser(phost, HOST_USER_DISCONNECTION);
 80111f8:	2105      	movs	r1, #5
 80111fa:	4620      	mov	r0, r4
 80111fc:	4798      	blx	r3
      if (phost->device.is_ReEnumerated == 1U)
 80111fe:	f894 5322 	ldrb.w	r5, [r4, #802]	; 0x322
 8011202:	b2ed      	uxtb	r5, r5
 8011204:	2d01      	cmp	r5, #1
 8011206:	f000 80c0 	beq.w	801138a <USBH_Process+0x376>
        USBH_LL_Start(phost);
 801120a:	4620      	mov	r0, r4
 801120c:	f010 fbee 	bl	80219ec <USBH_LL_Start>
  return USBH_OK;
 8011210:	e75f      	b.n	80110d2 <USBH_Process+0xbe>
static USBH_StatusTypeDef USBH_HandleEnum(USBH_HandleTypeDef *phost)
{
  USBH_StatusTypeDef Status = USBH_BUSY;
  USBH_StatusTypeDef ReqStatus = USBH_BUSY;

  switch (phost->EnumState)
 8011212:	7863      	ldrb	r3, [r4, #1]
 8011214:	2b07      	cmp	r3, #7
 8011216:	d84d      	bhi.n	80112b4 <USBH_Process+0x2a0>
 8011218:	e8df f003 	tbb	[pc, r3]
 801121c:	a58b9b41 	.word	0xa58b9b41
 8011220:	5f656d75 	.word	0x5f656d75
      if (phost->pActiveClass != NULL)
 8011224:	f8d4 34ec 	ldr.w	r3, [r4, #1260]	; 0x4ec
 8011228:	b163      	cbz	r3, 8011244 <USBH_Process+0x230>
        status = phost->pActiveClass->Requests(phost);
 801122a:	691b      	ldr	r3, [r3, #16]
 801122c:	4620      	mov	r0, r4
 801122e:	4798      	blx	r3
 8011230:	f88d 0017 	strb.w	r0, [sp, #23]
        if (status == USBH_OK)
 8011234:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8011238:	b33b      	cbz	r3, 801128a <USBH_Process+0x276>
        else if (status == USBH_FAIL)
 801123a:	f89d 3017 	ldrb.w	r3, [sp, #23]
 801123e:	2b02      	cmp	r3, #2
 8011240:	f47f af47 	bne.w	80110d2 <USBH_Process+0xbe>
        phost->gState = HOST_ABORT_STATE;
 8011244:	230d      	movs	r3, #13
}
 8011246:	2000      	movs	r0, #0
        phost->gState = HOST_ABORT_STATE;
 8011248:	7023      	strb	r3, [r4, #0]
}
 801124a:	b007      	add	sp, #28
 801124c:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (phost->pUser != NULL)
 801124e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8011252:	2b00      	cmp	r3, #0
 8011254:	f43f af3d 	beq.w	80110d2 <USBH_Process+0xbe>
        phost->pUser(phost, HOST_USER_SELECT_CONFIGURATION);
 8011258:	2101      	movs	r1, #1
 801125a:	4620      	mov	r0, r4
 801125c:	4798      	blx	r3
        phost->gState = HOST_SET_CONFIGURATION;
 801125e:	2308      	movs	r3, #8
 8011260:	7023      	strb	r3, [r4, #0]
 8011262:	e736      	b.n	80110d2 <USBH_Process+0xbe>
      if ((phost->device.CfgDesc.bmAttributes) & (1U << 5))
 8011264:	f894 333f 	ldrb.w	r3, [r4, #831]	; 0x33f
 8011268:	069b      	lsls	r3, r3, #26
 801126a:	f100 8086 	bmi.w	801137a <USBH_Process+0x366>
        phost->gState = HOST_CHECK_CLASS;
 801126e:	230a      	movs	r3, #10
 8011270:	7023      	strb	r3, [r4, #0]
 8011272:	e72e      	b.n	80110d2 <USBH_Process+0xbe>
      if (USBH_SetCfg(phost, (uint16_t)phost->device.CfgDesc.bConfigurationValue) == USBH_OK)
 8011274:	f894 133d 	ldrb.w	r1, [r4, #829]	; 0x33d
 8011278:	4620      	mov	r0, r4
 801127a:	f000 fdc9 	bl	8011e10 <USBH_SetCfg>
 801127e:	2800      	cmp	r0, #0
 8011280:	f47f af27 	bne.w	80110d2 <USBH_Process+0xbe>
        phost->gState = HOST_SET_WAKEUP_FEATURE;
 8011284:	2309      	movs	r3, #9
 8011286:	7023      	strb	r3, [r4, #0]
 8011288:	e723      	b.n	80110d2 <USBH_Process+0xbe>
          phost->gState = HOST_CLASS;
 801128a:	230b      	movs	r3, #11
 801128c:	7023      	strb	r3, [r4, #0]
 801128e:	e720      	b.n	80110d2 <USBH_Process+0xbe>
          phost->Timeout += 10U;
 8011290:	330a      	adds	r3, #10
          USBH_Delay(10U);
 8011292:	200a      	movs	r0, #10
          phost->Timeout += 10U;
 8011294:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
          USBH_Delay(10U);
 8011298:	f010 fc5e 	bl	8021b58 <USBH_Delay>
 801129c:	e719      	b.n	80110d2 <USBH_Process+0xbe>
  {
    case ENUM_IDLE:
      /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
      ReqStatus = USBH_Get_DevDesc(phost, 8U);
 801129e:	2108      	movs	r1, #8
 80112a0:	4620      	mov	r0, r4
 80112a2:	f000 f959 	bl	8011558 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 80112a6:	4605      	mov	r5, r0
 80112a8:	2800      	cmp	r0, #0
 80112aa:	f000 80c1 	beq.w	8011430 <USBH_Process+0x41c>
        /* Open Control pipes */
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
                      phost->device.speed, USBH_EP_CONTROL,
                      (uint16_t)phost->Control.pipe_size);
      }
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 80112ae:	2803      	cmp	r0, #3
 80112b0:	f000 80aa 	beq.w	8011408 <USBH_Process+0x3f4>
  USBH_StatusTypeDef Status = USBH_BUSY;
 80112b4:	2301      	movs	r3, #1
      status = USBH_HandleEnum(phost);
 80112b6:	f88d 3017 	strb.w	r3, [sp, #23]
      if (status == USBH_OK)
 80112ba:	f89d 3017 	ldrb.w	r3, [sp, #23]
 80112be:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80112c2:	2b00      	cmp	r3, #0
 80112c4:	f47f af05 	bne.w	80110d2 <USBH_Process+0xbe>
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 80112c8:	f894 3337 	ldrb.w	r3, [r4, #823]	; 0x337
        phost->device.current_interface = 0U;
 80112cc:	f884 2324 	strb.w	r2, [r4, #804]	; 0x324
        if (phost->device.DevDesc.bNumConfigurations == 1U)
 80112d0:	2b01      	cmp	r3, #1
 80112d2:	d0c4      	beq.n	801125e <USBH_Process+0x24a>
          phost->gState = HOST_INPUT;
 80112d4:	2307      	movs	r3, #7
 80112d6:	7023      	strb	r3, [r4, #0]
 80112d8:	e6fb      	b.n	80110d2 <USBH_Process+0xbe>
#endif
      }
      break;

    case ENUM_GET_SERIALNUM_STRING_DESC:
      if (phost->device.DevDesc.iSerialNumber != 0U)
 80112da:	f894 1336 	ldrb.w	r1, [r4, #822]	; 0x336
 80112de:	2900      	cmp	r1, #0
 80112e0:	d174      	bne.n	80113cc <USBH_Process+0x3b8>
        }
      }
      else
      {
        USBH_UsrLog("Serial Number : N/A");
        Status = USBH_OK;
 80112e2:	460b      	mov	r3, r1
 80112e4:	e7e7      	b.n	80112b6 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iProduct != 0U)
 80112e6:	f894 1335 	ldrb.w	r1, [r4, #821]	; 0x335
 80112ea:	2900      	cmp	r1, #0
 80112ec:	d17f      	bne.n	80113ee <USBH_Process+0x3da>
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80112ee:	2207      	movs	r2, #7
  USBH_StatusTypeDef Status = USBH_BUSY;
 80112f0:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
 80112f2:	7062      	strb	r2, [r4, #1]
 80112f4:	e7df      	b.n	80112b6 <USBH_Process+0x2a2>
      if (phost->device.DevDesc.iManufacturer != 0U)
 80112f6:	f894 1334 	ldrb.w	r1, [r4, #820]	; 0x334
 80112fa:	2900      	cmp	r1, #0
 80112fc:	d15a      	bne.n	80113b4 <USBH_Process+0x3a0>
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 80112fe:	2206      	movs	r2, #6
  USBH_StatusTypeDef Status = USBH_BUSY;
 8011300:	2301      	movs	r3, #1
          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
 8011302:	7062      	strb	r2, [r4, #1]
 8011304:	e7d7      	b.n	80112b6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, phost->device.CfgDesc.wTotalLength);
 8011306:	f8b4 133a 	ldrh.w	r1, [r4, #826]	; 0x33a
 801130a:	4620      	mov	r0, r4
 801130c:	f000 fa34 	bl	8011778 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 8011310:	2800      	cmp	r0, #0
 8011312:	d04b      	beq.n	80113ac <USBH_Process+0x398>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8011314:	2803      	cmp	r0, #3
 8011316:	d1cd      	bne.n	80112b4 <USBH_Process+0x2a0>
        phost->device.EnumCnt++;
 8011318:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
 801131c:	3301      	adds	r3, #1
 801131e:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 8011320:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 8011322:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8011326:	f240 80a6 	bls.w	8011476 <USBH_Process+0x462>
          phost->gState = HOST_ABORT_STATE;
 801132a:	220d      	movs	r2, #13
  USBH_StatusTypeDef Status = USBH_BUSY;
 801132c:	2301      	movs	r3, #1
          phost->gState = HOST_ABORT_STATE;
 801132e:	7022      	strb	r2, [r4, #0]
 8011330:	e7c1      	b.n	80112b6 <USBH_Process+0x2a2>
      ReqStatus = USBH_SetAddress(phost, USBH_DEVICE_ADDRESS);
 8011332:	2101      	movs	r1, #1
 8011334:	4620      	mov	r0, r4
 8011336:	f000 fc85 	bl	8011c44 <USBH_SetAddress>
      if (ReqStatus == USBH_OK)
 801133a:	4606      	mov	r6, r0
 801133c:	2800      	cmp	r0, #0
 801133e:	f000 80a7 	beq.w	8011490 <USBH_Process+0x47c>
      else if (ReqStatus == USBH_NOT_SUPPORTED)
 8011342:	2803      	cmp	r0, #3
 8011344:	d1b6      	bne.n	80112b4 <USBH_Process+0x2a0>
        phost->gState = HOST_ABORT_STATE;
 8011346:	210d      	movs	r1, #13
        phost->EnumState = ENUM_IDLE;
 8011348:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 801134a:	2301      	movs	r3, #1
        phost->gState = HOST_ABORT_STATE;
 801134c:	7021      	strb	r1, [r4, #0]
        phost->EnumState = ENUM_IDLE;
 801134e:	7062      	strb	r2, [r4, #1]
 8011350:	e7b1      	b.n	80112b6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_DevDesc(phost, USB_DEVICE_DESC_SIZE);
 8011352:	2112      	movs	r1, #18
 8011354:	4620      	mov	r0, r4
 8011356:	f000 f8ff 	bl	8011558 <USBH_Get_DevDesc>
      if (ReqStatus == USBH_OK)
 801135a:	2800      	cmp	r0, #0
 801135c:	d1da      	bne.n	8011314 <USBH_Process+0x300>
        phost->EnumState = ENUM_SET_ADDR;
 801135e:	2202      	movs	r2, #2
  USBH_StatusTypeDef Status = USBH_BUSY;
 8011360:	2301      	movs	r3, #1
        phost->EnumState = ENUM_SET_ADDR;
 8011362:	7062      	strb	r2, [r4, #1]
 8011364:	e7a7      	b.n	80112b6 <USBH_Process+0x2a2>
      ReqStatus = USBH_Get_CfgDesc(phost, USB_CONFIGURATION_DESC_SIZE);
 8011366:	2109      	movs	r1, #9
 8011368:	4620      	mov	r0, r4
 801136a:	f000 fa05 	bl	8011778 <USBH_Get_CfgDesc>
      if (ReqStatus == USBH_OK)
 801136e:	2800      	cmp	r0, #0
 8011370:	d1d0      	bne.n	8011314 <USBH_Process+0x300>
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 8011372:	2204      	movs	r2, #4
  USBH_StatusTypeDef Status = USBH_BUSY;
 8011374:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_FULL_CFG_DESC;
 8011376:	7062      	strb	r2, [r4, #1]
 8011378:	e79d      	b.n	80112b6 <USBH_Process+0x2a2>
        if (USBH_SetFeature(phost, FEATURE_SELECTOR_REMOTEWAKEUP) == USBH_OK)
 801137a:	2101      	movs	r1, #1
 801137c:	4620      	mov	r0, r4
 801137e:	f000 fe2d 	bl	8011fdc <USBH_SetFeature>
 8011382:	2800      	cmp	r0, #0
 8011384:	f47f aea5 	bne.w	80110d2 <USBH_Process+0xbe>
 8011388:	e771      	b.n	801126e <USBH_Process+0x25a>
        phost->device.is_ReEnumerated = 0U;
 801138a:	2300      	movs	r3, #0
  USBH_LL_Start(phost);
 801138c:	4620      	mov	r0, r4
        phost->device.is_ReEnumerated = 0U;
 801138e:	f884 3322 	strb.w	r3, [r4, #802]	; 0x322
  USBH_LL_Start(phost);
 8011392:	f010 fb2b 	bl	80219ec <USBH_LL_Start>
  USBH_LL_DriverVBUS(phost, 1);
 8011396:	4629      	mov	r1, r5
 8011398:	4620      	mov	r0, r4
 801139a:	f010 fbb9 	bl	8021b10 <USBH_LL_DriverVBUS>
 801139e:	e698      	b.n	80110d2 <USBH_Process+0xbe>
        phost->device.RstCnt = 0U;
 80113a0:	2200      	movs	r2, #0
        phost->gState = HOST_DEV_ATTACHED;
 80113a2:	2302      	movs	r3, #2
        phost->device.RstCnt = 0U;
 80113a4:	f884 231f 	strb.w	r2, [r4, #799]	; 0x31f
        phost->gState = HOST_DEV_ATTACHED;
 80113a8:	7023      	strb	r3, [r4, #0]
 80113aa:	e692      	b.n	80110d2 <USBH_Process+0xbe>
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 80113ac:	2205      	movs	r2, #5
  USBH_StatusTypeDef Status = USBH_BUSY;
 80113ae:	2301      	movs	r3, #1
        phost->EnumState = ENUM_GET_MFC_STRING_DESC;
 80113b0:	7062      	strb	r2, [r4, #1]
 80113b2:	e780      	b.n	80112b6 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iManufacturer,
 80113b4:	23ff      	movs	r3, #255	; 0xff
 80113b6:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 80113ba:	4620      	mov	r0, r4
 80113bc:	f000 fb34 	bl	8011a28 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 80113c0:	2800      	cmp	r0, #0
 80113c2:	d09c      	beq.n	80112fe <USBH_Process+0x2ea>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 80113c4:	2803      	cmp	r0, #3
 80113c6:	f47f af75 	bne.w	80112b4 <USBH_Process+0x2a0>
 80113ca:	e798      	b.n	80112fe <USBH_Process+0x2ea>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iSerialNumber,
 80113cc:	23ff      	movs	r3, #255	; 0xff
 80113ce:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 80113d2:	4620      	mov	r0, r4
 80113d4:	f000 fb28 	bl	8011a28 <USBH_Get_StringDesc>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 80113d8:	f1a0 0303 	sub.w	r3, r0, #3
 80113dc:	fab3 f383 	clz	r3, r3
 80113e0:	095b      	lsrs	r3, r3, #5
 80113e2:	2800      	cmp	r0, #0
 80113e4:	bf08      	it	eq
 80113e6:	2301      	moveq	r3, #1
  USBH_StatusTypeDef Status = USBH_BUSY;
 80113e8:	f083 0301 	eor.w	r3, r3, #1
 80113ec:	e763      	b.n	80112b6 <USBH_Process+0x2a2>
        ReqStatus = USBH_Get_StringDesc(phost, phost->device.DevDesc.iProduct,
 80113ee:	23ff      	movs	r3, #255	; 0xff
 80113f0:	f504 728e 	add.w	r2, r4, #284	; 0x11c
 80113f4:	4620      	mov	r0, r4
 80113f6:	f000 fb17 	bl	8011a28 <USBH_Get_StringDesc>
        if (ReqStatus == USBH_OK)
 80113fa:	2800      	cmp	r0, #0
 80113fc:	f43f af77 	beq.w	80112ee <USBH_Process+0x2da>
        else if (ReqStatus == USBH_NOT_SUPPORTED)
 8011400:	2803      	cmp	r0, #3
 8011402:	f47f af57 	bne.w	80112b4 <USBH_Process+0x2a0>
 8011406:	e772      	b.n	80112ee <USBH_Process+0x2da>
        phost->device.EnumCnt++;
 8011408:	f894 331e 	ldrb.w	r3, [r4, #798]	; 0x31e
 801140c:	3301      	adds	r3, #1
 801140e:	b2db      	uxtb	r3, r3
        if (phost->device.EnumCnt > 3U)
 8011410:	2b03      	cmp	r3, #3
        phost->device.EnumCnt++;
 8011412:	f884 331e 	strb.w	r3, [r4, #798]	; 0x31e
        if (phost->device.EnumCnt > 3U)
 8011416:	d888      	bhi.n	801132a <USBH_Process+0x316>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8011418:	7961      	ldrb	r1, [r4, #5]
 801141a:	4620      	mov	r0, r4
 801141c:	f001 f856 	bl	80124cc <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 8011420:	7921      	ldrb	r1, [r4, #4]
 8011422:	4620      	mov	r0, r4
 8011424:	f001 f852 	bl	80124cc <USBH_FreePipe>
          phost->gState = HOST_IDLE;
 8011428:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 801142a:	2301      	movs	r3, #1
          phost->gState = HOST_IDLE;
 801142c:	7022      	strb	r2, [r4, #0]
 801142e:	e742      	b.n	80112b6 <USBH_Process+0x2a2>
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 8011430:	f894 732d 	ldrb.w	r7, [r4, #813]	; 0x32d
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 8011434:	2601      	movs	r6, #1
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 8011436:	f894 c31d 	ldrb.w	ip, [r4, #797]	; 0x31d
 801143a:	2280      	movs	r2, #128	; 0x80
 801143c:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 8011440:	4620      	mov	r0, r4
 8011442:	7921      	ldrb	r1, [r4, #4]
 8011444:	9501      	str	r5, [sp, #4]
        phost->Control.pipe_size = phost->device.DevDesc.bMaxPacketSize;
 8011446:	71a7      	strb	r7, [r4, #6]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 8011448:	9702      	str	r7, [sp, #8]
        phost->EnumState = ENUM_GET_FULL_DEV_DESC;
 801144a:	7066      	strb	r6, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U, phost->device.address,
 801144c:	f8cd c000 	str.w	ip, [sp]
 8011450:	f000 ffdc 	bl	801240c <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 8011454:	f894 c006 	ldrb.w	ip, [r4, #6]
 8011458:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 801145c:	462a      	mov	r2, r5
 801145e:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 8011462:	4620      	mov	r0, r4
 8011464:	7961      	ldrb	r1, [r4, #5]
 8011466:	9501      	str	r5, [sp, #4]
 8011468:	f8cd c008 	str.w	ip, [sp, #8]
 801146c:	9700      	str	r7, [sp, #0]
 801146e:	f000 ffcd 	bl	801240c <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
 8011472:	4633      	mov	r3, r6
 8011474:	e71f      	b.n	80112b6 <USBH_Process+0x2a2>
          USBH_FreePipe(phost, phost->Control.pipe_out);
 8011476:	7961      	ldrb	r1, [r4, #5]
 8011478:	4620      	mov	r0, r4
 801147a:	f001 f827 	bl	80124cc <USBH_FreePipe>
          USBH_FreePipe(phost, phost->Control.pipe_in);
 801147e:	7921      	ldrb	r1, [r4, #4]
 8011480:	4620      	mov	r0, r4
 8011482:	f001 f823 	bl	80124cc <USBH_FreePipe>
          phost->EnumState = ENUM_IDLE;
 8011486:	2200      	movs	r2, #0
  USBH_StatusTypeDef Status = USBH_BUSY;
 8011488:	2301      	movs	r3, #1
          phost->EnumState = ENUM_IDLE;
 801148a:	7062      	strb	r2, [r4, #1]
          phost->gState = HOST_IDLE;
 801148c:	7022      	strb	r2, [r4, #0]
 801148e:	e712      	b.n	80112b6 <USBH_Process+0x2a2>
        USBH_Delay(2U);
 8011490:	2002      	movs	r0, #2
        phost->device.address = USBH_DEVICE_ADDRESS;
 8011492:	2501      	movs	r5, #1
        USBH_Delay(2U);
 8011494:	f010 fb60 	bl	8021b58 <USBH_Delay>
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 8011498:	79a7      	ldrb	r7, [r4, #6]
        phost->EnumState = ENUM_GET_CFG_DESC;
 801149a:	2003      	movs	r0, #3
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 801149c:	7921      	ldrb	r1, [r4, #4]
 801149e:	9601      	str	r6, [sp, #4]
 80114a0:	462b      	mov	r3, r5
        phost->EnumState = ENUM_GET_CFG_DESC;
 80114a2:	7060      	strb	r0, [r4, #1]
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 80114a4:	2280      	movs	r2, #128	; 0x80
        phost->device.address = USBH_DEVICE_ADDRESS;
 80114a6:	f884 531c 	strb.w	r5, [r4, #796]	; 0x31c
        USBH_OpenPipe(phost, phost->Control.pipe_in, 0x80U,  phost->device.address,
 80114aa:	4620      	mov	r0, r4
 80114ac:	9702      	str	r7, [sp, #8]
 80114ae:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 80114b2:	9700      	str	r7, [sp, #0]
 80114b4:	f000 ffaa 	bl	801240c <USBH_OpenPipe>
        USBH_OpenPipe(phost, phost->Control.pipe_out, 0x00U, phost->device.address,
 80114b8:	f894 c006 	ldrb.w	ip, [r4, #6]
 80114bc:	f894 731d 	ldrb.w	r7, [r4, #797]	; 0x31d
 80114c0:	4632      	mov	r2, r6
 80114c2:	f894 331c 	ldrb.w	r3, [r4, #796]	; 0x31c
 80114c6:	4620      	mov	r0, r4
 80114c8:	7961      	ldrb	r1, [r4, #5]
 80114ca:	9601      	str	r6, [sp, #4]
 80114cc:	f8cd c008 	str.w	ip, [sp, #8]
 80114d0:	9700      	str	r7, [sp, #0]
 80114d2:	f000 ff9b 	bl	801240c <USBH_OpenPipe>
  USBH_StatusTypeDef Status = USBH_BUSY;
 80114d6:	462b      	mov	r3, r5
 80114d8:	e6ed      	b.n	80112b6 <USBH_Process+0x2a2>
 80114da:	bf00      	nop

080114dc <USBH_LL_SetTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_SetTimer(USBH_HandleTypeDef *phost, uint32_t time)
{
  phost->Timer = time;
 80114dc:	f8c0 1534 	str.w	r1, [r0, #1332]	; 0x534
}
 80114e0:	4770      	bx	lr
 80114e2:	bf00      	nop

080114e4 <USBH_LL_IncTimer>:
  * @param  phost: Host Handle
  * @retval None
  */
void  USBH_LL_IncTimer(USBH_HandleTypeDef *phost)
{
  phost->Timer++;
 80114e4:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
 80114e8:	3201      	adds	r2, #1
 80114ea:	f8c0 2534 	str.w	r2, [r0, #1332]	; 0x534
  * @param  phost: Host Handle
  * @retval None
  */
static void  USBH_HandleSof(USBH_HandleTypeDef *phost)
{
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 80114ee:	7802      	ldrb	r2, [r0, #0]
 80114f0:	2a0b      	cmp	r2, #11
 80114f2:	d000      	beq.n	80114f6 <USBH_LL_IncTimer+0x12>
}
 80114f4:	4770      	bx	lr
  if ((phost->gState == HOST_CLASS) && (phost->pActiveClass != NULL))
 80114f6:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 80114fa:	2b00      	cmp	r3, #0
 80114fc:	d0fa      	beq.n	80114f4 <USBH_LL_IncTimer+0x10>
  {
    phost->pActiveClass->SOFProcess(phost);
 80114fe:	699b      	ldr	r3, [r3, #24]
 8011500:	4718      	bx	r3
 8011502:	bf00      	nop

08011504 <USBH_LL_PortEnabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortEnabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 1U;
 8011504:	2301      	movs	r3, #1
 8011506:	f880 3323 	strb.w	r3, [r0, #803]	; 0x323
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return;
}
 801150a:	4770      	bx	lr

0801150c <USBH_LL_PortDisabled>:
  * @param  phost: Host Handle
  * @retval None
  */
void USBH_LL_PortDisabled(USBH_HandleTypeDef *phost)
{
  phost->device.PortEnabled = 0U;
 801150c:	2300      	movs	r3, #0
 801150e:	f880 3323 	strb.w	r3, [r0, #803]	; 0x323

  return;
}
 8011512:	4770      	bx	lr

08011514 <USBH_LL_Connect>:
  *         Handle USB Host connexion event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Connect(USBH_HandleTypeDef *phost)
{
 8011514:	4603      	mov	r3, r0
  phost->device.is_connected = 1U;
  phost->device.is_disconnected = 0U;
 8011516:	2200      	movs	r2, #0
  phost->device.is_connected = 1U;
 8011518:	2101      	movs	r1, #1
 801151a:	f880 1320 	strb.w	r1, [r0, #800]	; 0x320
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
}
 801151e:	4610      	mov	r0, r2
  phost->device.is_disconnected = 0U;
 8011520:	f883 2321 	strb.w	r2, [r3, #801]	; 0x321
  phost->device.is_ReEnumerated = 0U;
 8011524:	f883 2322 	strb.w	r2, [r3, #802]	; 0x322
}
 8011528:	4770      	bx	lr
 801152a:	bf00      	nop

0801152c <USBH_LL_Disconnect>:
  *         Handle USB Host disconnection event
  * @param  phost: Host Handle
  * @retval USBH_Status
  */
USBH_StatusTypeDef  USBH_LL_Disconnect(USBH_HandleTypeDef *phost)
{
 801152c:	b538      	push	{r3, r4, r5, lr}
  /* update device connection states */
  phost->device.is_disconnected = 1U;
 801152e:	2301      	movs	r3, #1
  phost->device.is_connected = 0U;
 8011530:	2500      	movs	r5, #0
{
 8011532:	4604      	mov	r4, r0
  phost->device.is_disconnected = 1U;
 8011534:	f880 3321 	strb.w	r3, [r0, #801]	; 0x321
  phost->device.PortEnabled = 0U;
 8011538:	f880 5323 	strb.w	r5, [r0, #803]	; 0x323
  phost->device.is_connected = 0U;
 801153c:	f880 5320 	strb.w	r5, [r0, #800]	; 0x320

  /* Stop Host */
  USBH_LL_Stop(phost);
 8011540:	f010 fa64 	bl	8021a0c <USBH_LL_Stop>

  /* FRee Control Pipes */
  USBH_FreePipe(phost, phost->Control.pipe_in);
 8011544:	7921      	ldrb	r1, [r4, #4]
 8011546:	4620      	mov	r0, r4
 8011548:	f000 ffc0 	bl	80124cc <USBH_FreePipe>
  USBH_FreePipe(phost, phost->Control.pipe_out);
 801154c:	7961      	ldrb	r1, [r4, #5]
 801154e:	4620      	mov	r0, r4
 8011550:	f000 ffbc 	bl	80124cc <USBH_FreePipe>
  (void)osMessageQueuePut(phost->os_event, &phost->os_msg, 0U, NULL);
#endif
#endif

  return USBH_OK;
}
 8011554:	4628      	mov	r0, r5
 8011556:	bd38      	pop	{r3, r4, r5, pc}

08011558 <USBH_Get_DevDesc>:
  * @param  phost: Host Handle
  * @param  length: Length of the descriptor
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_Get_DevDesc(USBH_HandleTypeDef *phost, uint8_t length)
{
 8011558:	b570      	push	{r4, r5, r6, lr}
 801155a:	4604      	mov	r4, r0
                                      uint8_t  req_type,
                                      uint16_t value_idx,
                                      uint8_t *buff,
                                      uint16_t length)
{
  if (phost->RequestState == CMD_SEND)
 801155c:	7880      	ldrb	r0, [r0, #2]
{
 801155e:	b082      	sub	sp, #8
  if (phost->RequestState == CMD_SEND)
 8011560:	2801      	cmp	r0, #1
 8011562:	d011      	beq.n	8011588 <USBH_Get_DevDesc+0x30>
                               uint16_t length)
{
  USBH_StatusTypeDef status;
  status = USBH_BUSY;

  switch (phost->RequestState)
 8011564:	2802      	cmp	r0, #2
 8011566:	d002      	beq.n	801156e <USBH_Get_DevDesc+0x16>
  status = USBH_BUSY;
 8011568:	2001      	movs	r0, #1
}
 801156a:	b002      	add	sp, #8
 801156c:	bd70      	pop	{r4, r5, r6, pc}
{
  uint8_t direction;
  USBH_StatusTypeDef status = USBH_BUSY;
  USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;

  switch (phost->Control.state)
 801156e:	7e23      	ldrb	r3, [r4, #24]
 8011570:	460d      	mov	r5, r1
 8011572:	3b01      	subs	r3, #1
 8011574:	2b0a      	cmp	r3, #10
 8011576:	d8f7      	bhi.n	8011568 <USBH_Get_DevDesc+0x10>
 8011578:	e8df f003 	tbb	[pc, r3]
 801157c:	584b3c32 	.word	0x584b3c32
 8011580:	8f827263 	.word	0x8f827263
 8011584:	afa0      	.short	0xafa0
 8011586:	17          	.byte	0x17
 8011587:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8011588:	f44f 63d0 	mov.w	r3, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
 801158c:	2600      	movs	r6, #0
                                   USB_DESC_DEVICE, phost->device.Data,
 801158e:	f504 758e 	add.w	r5, r4, #284	; 0x11c
      phost->RequestState = CMD_WAIT;
 8011592:	2202      	movs	r2, #2
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8011594:	f2c0 1300 	movt	r3, #256	; 0x100
    phost->Control.setup.b.wLength.w = length;
 8011598:	82e1      	strh	r1, [r4, #22]
      phost->Control.length = length;
 801159a:	81a1      	strh	r1, [r4, #12]
      phost->Control.state = CTRL_SETUP;
 801159c:	7620      	strb	r0, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 801159e:	6123      	str	r3, [r4, #16]
    phost->Control.setup.b.wValue.w = value_idx;
 80115a0:	82a6      	strh	r6, [r4, #20]
      phost->Control.buff = buff;
 80115a2:	60a5      	str	r5, [r4, #8]
      phost->RequestState = CMD_WAIT;
 80115a4:	70a2      	strb	r2, [r4, #2]
}
 80115a6:	b002      	add	sp, #8
 80115a8:	bd70      	pop	{r4, r5, r6, pc}
      PID; i.e., recovery actions via some other pipe are not required for control
      endpoints. For the Default Control Pipe, a device reset will ultimately be
      required to clear the halt or error condition if the next Setup PID is not
      accepted.
      */
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80115aa:	7e63      	ldrb	r3, [r4, #25]
 80115ac:	3301      	adds	r3, #1
 80115ae:	b2db      	uxtb	r3, r3
 80115b0:	2b02      	cmp	r3, #2
 80115b2:	7663      	strb	r3, [r4, #25]
 80115b4:	f240 80d7 	bls.w	8011766 <USBH_Get_DevDesc+0x20e>
        phost->RequestState = CMD_SEND;
      }
      else
      {
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
        phost->Control.errorcount = 0U;
 80115b8:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 80115ba:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 80115be:	2106      	movs	r1, #6
 80115c0:	4620      	mov	r0, r4
 80115c2:	4798      	blx	r3
        USBH_ErrLog("Control error: Device not responding");

        /* Free control pipes */
        USBH_FreePipe(phost, phost->Control.pipe_out);
 80115c4:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 80115c6:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 80115c8:	4620      	mov	r0, r4
 80115ca:	f000 ff7f 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 80115ce:	7921      	ldrb	r1, [r4, #4]
 80115d0:	4620      	mov	r0, r4
 80115d2:	f000 ff7b 	bl	80124cc <USBH_FreePipe>

        phost->gState = HOST_IDLE;
 80115d6:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 80115d8:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 80115da:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 80115dc:	70a3      	strb	r3, [r4, #2]
 80115de:	e7c4      	b.n	801156a <USBH_Get_DevDesc+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 80115e0:	7962      	ldrb	r2, [r4, #5]
 80115e2:	f104 0110 	add.w	r1, r4, #16
 80115e6:	4620      	mov	r0, r4
 80115e8:	f000 fec4 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 80115ec:	2302      	movs	r3, #2
 80115ee:	2001      	movs	r0, #1
 80115f0:	7623      	strb	r3, [r4, #24]
 80115f2:	e7ba      	b.n	801156a <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80115f4:	7961      	ldrb	r1, [r4, #5]
 80115f6:	4620      	mov	r0, r4
 80115f8:	f010 fa86 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80115fc:	2801      	cmp	r0, #1
 80115fe:	f000 80a7 	beq.w	8011750 <USBH_Get_DevDesc+0x1f8>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8011602:	2804      	cmp	r0, #4
 8011604:	d001      	beq.n	801160a <USBH_Get_DevDesc+0xb2>
 8011606:	2802      	cmp	r0, #2
 8011608:	d1ae      	bne.n	8011568 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
 801160a:	230b      	movs	r3, #11
 801160c:	2001      	movs	r0, #1
 801160e:	7623      	strb	r3, [r4, #24]
 8011610:	e7ab      	b.n	801156a <USBH_Get_DevDesc+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011612:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011616:	4620      	mov	r0, r4
 8011618:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 801161a:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 801161c:	68a1      	ldr	r1, [r4, #8]
 801161e:	89a2      	ldrh	r2, [r4, #12]
 8011620:	f000 fed0 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8011624:	2304      	movs	r3, #4
 8011626:	2001      	movs	r0, #1
 8011628:	7623      	strb	r3, [r4, #24]
 801162a:	e79e      	b.n	801156a <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 801162c:	7921      	ldrb	r1, [r4, #4]
 801162e:	4620      	mov	r0, r4
 8011630:	f010 fa6a 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011634:	2801      	cmp	r0, #1
 8011636:	d058      	beq.n	80116ea <USBH_Get_DevDesc+0x192>
      if (URB_Status == USBH_URB_STALL)
 8011638:	2805      	cmp	r0, #5
 801163a:	d039      	beq.n	80116b0 <USBH_Get_DevDesc+0x158>
        if (URB_Status == USBH_URB_ERROR)
 801163c:	2804      	cmp	r0, #4
 801163e:	d193      	bne.n	8011568 <USBH_Get_DevDesc+0x10>
 8011640:	e7e3      	b.n	801160a <USBH_Get_DevDesc+0xb2>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8011642:	2501      	movs	r5, #1
 8011644:	7963      	ldrb	r3, [r4, #5]
 8011646:	89a2      	ldrh	r2, [r4, #12]
 8011648:	4620      	mov	r0, r4
 801164a:	68a1      	ldr	r1, [r4, #8]
 801164c:	9500      	str	r5, [sp, #0]
 801164e:	f000 fea1 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011652:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011656:	2306      	movs	r3, #6
 8011658:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 801165a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 801165c:	7623      	strb	r3, [r4, #24]
 801165e:	e784      	b.n	801156a <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011660:	7961      	ldrb	r1, [r4, #5]
 8011662:	4620      	mov	r0, r4
 8011664:	f010 fa50 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011668:	2801      	cmp	r0, #1
 801166a:	d06d      	beq.n	8011748 <USBH_Get_DevDesc+0x1f0>
      else if (URB_Status == USBH_URB_STALL)
 801166c:	2805      	cmp	r0, #5
 801166e:	d01f      	beq.n	80116b0 <USBH_Get_DevDesc+0x158>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011670:	2802      	cmp	r0, #2
 8011672:	d074      	beq.n	801175e <USBH_Get_DevDesc+0x206>
        if (URB_Status == USBH_URB_ERROR)
 8011674:	2804      	cmp	r0, #4
 8011676:	f47f af77 	bne.w	8011568 <USBH_Get_DevDesc+0x10>
          phost->Control.state = CTRL_ERROR;
 801167a:	230b      	movs	r3, #11
 801167c:	7623      	strb	r3, [r4, #24]
 801167e:	e7ab      	b.n	80115d8 <USBH_Get_DevDesc+0x80>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8011680:	2200      	movs	r2, #0
 8011682:	7923      	ldrb	r3, [r4, #4]
 8011684:	4620      	mov	r0, r4
 8011686:	4611      	mov	r1, r2
 8011688:	f000 fe9c 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801168c:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011690:	2308      	movs	r3, #8
 8011692:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8011694:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011696:	7623      	strb	r3, [r4, #24]
 8011698:	e767      	b.n	801156a <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 801169a:	7921      	ldrb	r1, [r4, #4]
 801169c:	4620      	mov	r0, r4
 801169e:	f010 fa33 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80116a2:	2801      	cmp	r0, #1
 80116a4:	d025      	beq.n	80116f2 <USBH_Get_DevDesc+0x19a>
      else if (URB_Status == USBH_URB_ERROR)
 80116a6:	2804      	cmp	r0, #4
 80116a8:	d0af      	beq.n	801160a <USBH_Get_DevDesc+0xb2>
        if (URB_Status == USBH_URB_STALL)
 80116aa:	2805      	cmp	r0, #5
 80116ac:	f47f af5c 	bne.w	8011568 <USBH_Get_DevDesc+0x10>
        phost->RequestState = CMD_SEND;
 80116b0:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 80116b2:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 80116b4:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 80116b6:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 80116b8:	7623      	strb	r3, [r4, #24]
 80116ba:	e756      	b.n	801156a <USBH_Get_DevDesc+0x12>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 80116bc:	2200      	movs	r2, #0
 80116be:	2501      	movs	r5, #1
 80116c0:	7963      	ldrb	r3, [r4, #5]
 80116c2:	4620      	mov	r0, r4
 80116c4:	4611      	mov	r1, r2
 80116c6:	9500      	str	r5, [sp, #0]
 80116c8:	f000 fe64 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80116cc:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80116d0:	230a      	movs	r3, #10
 80116d2:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80116d4:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80116d6:	7623      	strb	r3, [r4, #24]
 80116d8:	e747      	b.n	801156a <USBH_Get_DevDesc+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80116da:	7961      	ldrb	r1, [r4, #5]
 80116dc:	4620      	mov	r0, r4
 80116de:	f010 fa13 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80116e2:	2801      	cmp	r0, #1
 80116e4:	d005      	beq.n	80116f2 <USBH_Get_DevDesc+0x19a>
      else if (URB_Status == USBH_URB_NOTREADY)
 80116e6:	2802      	cmp	r0, #2
 80116e8:	d1a8      	bne.n	801163c <USBH_Get_DevDesc+0xe4>
            phost->Control.state = CTRL_STATUS_OUT;
 80116ea:	2309      	movs	r3, #9
 80116ec:	2001      	movs	r0, #1
 80116ee:	7623      	strb	r3, [r4, #24]
 80116f0:	e73b      	b.n	801156a <USBH_Get_DevDesc+0x12>
        phost->RequestState = CMD_SEND;
 80116f2:	2201      	movs	r2, #1
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 80116f4:	f894 311c 	ldrb.w	r3, [r4, #284]	; 0x11c
        phost->Control.state = CTRL_IDLE;
 80116f8:	2000      	movs	r0, #0
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
 80116fa:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
 80116fe:	70a2      	strb	r2, [r4, #2]
  if (length > 8U)
 8011700:	2d08      	cmp	r5, #8
  dev_desc->bcdUSB             = LE16(buf +  2);
 8011702:	f8b4 211e 	ldrh.w	r2, [r4, #286]	; 0x11e
  dev_desc->bLength            = *(uint8_t *)(buf +  0);
 8011706:	f884 3326 	strb.w	r3, [r4, #806]	; 0x326
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 801170a:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
        phost->Control.state = CTRL_IDLE;
 801170e:	7620      	strb	r0, [r4, #24]
  dev_desc->bDescriptorType    = *(uint8_t *)(buf +  1);
 8011710:	f884 1327 	strb.w	r1, [r4, #807]	; 0x327
  dev_desc->bcdUSB             = LE16(buf +  2);
 8011714:	f8a4 2328 	strh.w	r2, [r4, #808]	; 0x328
  dev_desc->bDeviceClass       = *(uint8_t *)(buf +  4);
 8011718:	f8c4 332a 	str.w	r3, [r4, #810]	; 0x32a
  if (length > 8U)
 801171c:	f67f af25 	bls.w	801156a <USBH_Get_DevDesc+0x12>
    dev_desc->idVendor           = LE16(buf +  8);
 8011720:	f8b4 5124 	ldrh.w	r5, [r4, #292]	; 0x124
    dev_desc->idProduct          = LE16(buf + 10);
 8011724:	f8b4 1126 	ldrh.w	r1, [r4, #294]	; 0x126
    dev_desc->bcdDevice          = LE16(buf + 12);
 8011728:	f8b4 2128 	ldrh.w	r2, [r4, #296]	; 0x128
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 801172c:	f8d4 312a 	ldr.w	r3, [r4, #298]	; 0x12a
    dev_desc->idVendor           = LE16(buf +  8);
 8011730:	f8a4 532e 	strh.w	r5, [r4, #814]	; 0x32e
    dev_desc->idProduct          = LE16(buf + 10);
 8011734:	f8a4 1330 	strh.w	r1, [r4, #816]	; 0x330
    dev_desc->bcdDevice          = LE16(buf + 12);
 8011738:	f8a4 2332 	strh.w	r2, [r4, #818]	; 0x332
    dev_desc->iManufacturer      = *(uint8_t *)(buf + 14);
 801173c:	f8c4 3334 	str.w	r3, [r4, #820]	; 0x334
}
 8011740:	b002      	add	sp, #8
 8011742:	bd70      	pop	{r4, r5, r6, pc}
          if (direction == USB_D2H)
 8011744:	2a00      	cmp	r2, #0
 8011746:	dbd0      	blt.n	80116ea <USBH_Get_DevDesc+0x192>
            phost->Control.state = CTRL_STATUS_IN;
 8011748:	2307      	movs	r3, #7
 801174a:	2001      	movs	r0, #1
 801174c:	7623      	strb	r3, [r4, #24]
 801174e:	e70c      	b.n	801156a <USBH_Get_DevDesc+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 8011750:	8ae3      	ldrh	r3, [r4, #22]
 8011752:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8011756:	2b00      	cmp	r3, #0
 8011758:	d0f4      	beq.n	8011744 <USBH_Get_DevDesc+0x1ec>
          if (direction == USB_D2H)
 801175a:	2a00      	cmp	r2, #0
 801175c:	db08      	blt.n	8011770 <USBH_Get_DevDesc+0x218>
            phost->Control.state = CTRL_DATA_OUT;
 801175e:	2305      	movs	r3, #5
 8011760:	2001      	movs	r0, #1
 8011762:	7623      	strb	r3, [r4, #24]
 8011764:	e701      	b.n	801156a <USBH_Get_DevDesc+0x12>
        phost->Control.state = CTRL_SETUP;
 8011766:	2301      	movs	r3, #1
 8011768:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 801176a:	4618      	mov	r0, r3
 801176c:	70a3      	strb	r3, [r4, #2]
 801176e:	e6fc      	b.n	801156a <USBH_Get_DevDesc+0x12>
            phost->Control.state = CTRL_DATA_IN;
 8011770:	2303      	movs	r3, #3
 8011772:	7623      	strb	r3, [r4, #24]
 8011774:	e6f9      	b.n	801156a <USBH_Get_DevDesc+0x12>
 8011776:	bf00      	nop

08011778 <USBH_Get_CfgDesc>:
{
 8011778:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if (phost->RequestState == CMD_SEND)
 801177c:	7883      	ldrb	r3, [r0, #2]
{
 801177e:	b083      	sub	sp, #12
 8011780:	4605      	mov	r5, r0
  uint8_t *pData = phost->device.CfgDesc_Raw;;
 8011782:	f100 041c 	add.w	r4, r0, #28
  if (phost->RequestState == CMD_SEND)
 8011786:	2b01      	cmp	r3, #1
 8011788:	d012      	beq.n	80117b0 <USBH_Get_CfgDesc+0x38>
  switch (phost->RequestState)
 801178a:	2b02      	cmp	r3, #2
 801178c:	d003      	beq.n	8011796 <USBH_Get_CfgDesc+0x1e>
  status = USBH_BUSY;
 801178e:	2001      	movs	r0, #1
}
 8011790:	b003      	add	sp, #12
 8011792:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  switch (phost->Control.state)
 8011796:	7e03      	ldrb	r3, [r0, #24]
 8011798:	460e      	mov	r6, r1
 801179a:	3b01      	subs	r3, #1
 801179c:	2b0a      	cmp	r3, #10
 801179e:	d8f6      	bhi.n	801178e <USBH_Get_CfgDesc+0x16>
 80117a0:	e8df f003 	tbb	[pc, r3]
 80117a4:	54483a31 	.word	0x54483a31
 80117a8:	897d6c5e 	.word	0x897d6c5e
 80117ac:	a799      	.short	0xa799
 80117ae:	17          	.byte	0x17
 80117af:	00          	.byte	0x00
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80117b0:	f44f 62d0 	mov.w	r2, #1664	; 0x680
    phost->Control.setup.b.wLength.w = length;
 80117b4:	82c1      	strh	r1, [r0, #22]
      phost->Control.buff = buff;
 80117b6:	6084      	str	r4, [r0, #8]
    phost->Control.setup.b.wValue.w = value_idx;
 80117b8:	2700      	movs	r7, #0
      phost->Control.length = length;
 80117ba:	8181      	strh	r1, [r0, #12]
      phost->RequestState = CMD_WAIT;
 80117bc:	2602      	movs	r6, #2
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80117be:	f2c0 2200 	movt	r2, #512	; 0x200
      status = USBH_BUSY;
 80117c2:	4618      	mov	r0, r3
      phost->Control.state = CTRL_SETUP;
 80117c4:	762b      	strb	r3, [r5, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 80117c6:	612a      	str	r2, [r5, #16]
    phost->Control.setup.b.wValue.w = value_idx;
 80117c8:	82af      	strh	r7, [r5, #20]
      phost->RequestState = CMD_WAIT;
 80117ca:	70ae      	strb	r6, [r5, #2]
}
 80117cc:	b003      	add	sp, #12
 80117ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80117d2:	7e43      	ldrb	r3, [r0, #25]
 80117d4:	3301      	adds	r3, #1
 80117d6:	b2db      	uxtb	r3, r3
 80117d8:	2b02      	cmp	r3, #2
 80117da:	7643      	strb	r3, [r0, #25]
 80117dc:	f240 811b 	bls.w	8011a16 <USBH_Get_CfgDesc+0x29e>
        phost->Control.errorcount = 0U;
 80117e0:	2400      	movs	r4, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 80117e2:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
 80117e6:	2106      	movs	r1, #6
 80117e8:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 80117ea:	7969      	ldrb	r1, [r5, #5]
        phost->Control.errorcount = 0U;
 80117ec:	766c      	strb	r4, [r5, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 80117ee:	4628      	mov	r0, r5
 80117f0:	f000 fe6c 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 80117f4:	7929      	ldrb	r1, [r5, #4]
 80117f6:	4628      	mov	r0, r5
 80117f8:	f000 fe68 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 80117fc:	702c      	strb	r4, [r5, #0]
        phost->RequestState = CMD_SEND;
 80117fe:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8011800:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8011802:	70ab      	strb	r3, [r5, #2]
 8011804:	e7c4      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8011806:	7942      	ldrb	r2, [r0, #5]
 8011808:	f100 0110 	add.w	r1, r0, #16
 801180c:	f000 fdb2 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8011810:	2302      	movs	r3, #2
 8011812:	2001      	movs	r0, #1
 8011814:	762b      	strb	r3, [r5, #24]
 8011816:	e7bb      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011818:	7941      	ldrb	r1, [r0, #5]
 801181a:	f010 f975 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801181e:	2801      	cmp	r0, #1
 8011820:	f000 80ee 	beq.w	8011a00 <USBH_Get_CfgDesc+0x288>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8011824:	2804      	cmp	r0, #4
 8011826:	d001      	beq.n	801182c <USBH_Get_CfgDesc+0xb4>
 8011828:	2802      	cmp	r0, #2
 801182a:	d1b0      	bne.n	801178e <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
 801182c:	230b      	movs	r3, #11
 801182e:	2001      	movs	r0, #1
 8011830:	762b      	strb	r3, [r5, #24]
 8011832:	e7ad      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011834:	f8d0 2534 	ldr.w	r2, [r0, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011838:	7903      	ldrb	r3, [r0, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 801183a:	81c2      	strh	r2, [r0, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 801183c:	6881      	ldr	r1, [r0, #8]
 801183e:	8982      	ldrh	r2, [r0, #12]
 8011840:	f000 fdc0 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8011844:	2304      	movs	r3, #4
 8011846:	2001      	movs	r0, #1
 8011848:	762b      	strb	r3, [r5, #24]
 801184a:	e7a1      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 801184c:	7901      	ldrb	r1, [r0, #4]
 801184e:	f010 f95b 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011852:	2801      	cmp	r0, #1
 8011854:	d054      	beq.n	8011900 <USBH_Get_CfgDesc+0x188>
      if (URB_Status == USBH_URB_STALL)
 8011856:	2805      	cmp	r0, #5
 8011858:	d037      	beq.n	80118ca <USBH_Get_CfgDesc+0x152>
        if (URB_Status == USBH_URB_ERROR)
 801185a:	2804      	cmp	r0, #4
 801185c:	d197      	bne.n	801178e <USBH_Get_CfgDesc+0x16>
 801185e:	e7e5      	b.n	801182c <USBH_Get_CfgDesc+0xb4>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8011860:	2401      	movs	r4, #1
 8011862:	7943      	ldrb	r3, [r0, #5]
 8011864:	8982      	ldrh	r2, [r0, #12]
 8011866:	6881      	ldr	r1, [r0, #8]
 8011868:	9400      	str	r4, [sp, #0]
 801186a:	f000 fd93 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801186e:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011872:	2306      	movs	r3, #6
 8011874:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
 8011876:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011878:	762b      	strb	r3, [r5, #24]
 801187a:	e789      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 801187c:	7941      	ldrb	r1, [r0, #5]
 801187e:	f010 f943 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011882:	2801      	cmp	r0, #1
 8011884:	f000 80b8 	beq.w	80119f8 <USBH_Get_CfgDesc+0x280>
      else if (URB_Status == USBH_URB_STALL)
 8011888:	2805      	cmp	r0, #5
 801188a:	d01e      	beq.n	80118ca <USBH_Get_CfgDesc+0x152>
      else if (URB_Status == USBH_URB_NOTREADY)
 801188c:	2802      	cmp	r0, #2
 801188e:	f000 80be 	beq.w	8011a0e <USBH_Get_CfgDesc+0x296>
        if (URB_Status == USBH_URB_ERROR)
 8011892:	2804      	cmp	r0, #4
 8011894:	f47f af7b 	bne.w	801178e <USBH_Get_CfgDesc+0x16>
          phost->Control.state = CTRL_ERROR;
 8011898:	230b      	movs	r3, #11
 801189a:	762b      	strb	r3, [r5, #24]
 801189c:	e7af      	b.n	80117fe <USBH_Get_CfgDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 801189e:	2200      	movs	r2, #0
 80118a0:	7903      	ldrb	r3, [r0, #4]
 80118a2:	4611      	mov	r1, r2
 80118a4:	f000 fd8e 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80118a8:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80118ac:	2308      	movs	r3, #8
 80118ae:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 80118b0:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80118b2:	762b      	strb	r3, [r5, #24]
 80118b4:	e76c      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80118b6:	7901      	ldrb	r1, [r0, #4]
 80118b8:	f010 f926 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80118bc:	2801      	cmp	r0, #1
 80118be:	d023      	beq.n	8011908 <USBH_Get_CfgDesc+0x190>
      else if (URB_Status == USBH_URB_ERROR)
 80118c0:	2804      	cmp	r0, #4
 80118c2:	d0b3      	beq.n	801182c <USBH_Get_CfgDesc+0xb4>
        if (URB_Status == USBH_URB_STALL)
 80118c4:	2805      	cmp	r0, #5
 80118c6:	f47f af62 	bne.w	801178e <USBH_Get_CfgDesc+0x16>
        phost->RequestState = CMD_SEND;
 80118ca:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 80118cc:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 80118ce:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 80118d0:	70aa      	strb	r2, [r5, #2]
        phost->Control.state = CTRL_IDLE;
 80118d2:	762b      	strb	r3, [r5, #24]
 80118d4:	e75c      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 80118d6:	2200      	movs	r2, #0
 80118d8:	2401      	movs	r4, #1
 80118da:	7943      	ldrb	r3, [r0, #5]
 80118dc:	4611      	mov	r1, r2
 80118de:	9400      	str	r4, [sp, #0]
 80118e0:	f000 fd58 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80118e4:	f8d5 2534 	ldr.w	r2, [r5, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80118e8:	230a      	movs	r3, #10
 80118ea:	4620      	mov	r0, r4
      phost->Control.timer = (uint16_t)phost->Timer;
 80118ec:	81ea      	strh	r2, [r5, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 80118ee:	762b      	strb	r3, [r5, #24]
 80118f0:	e74e      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80118f2:	7941      	ldrb	r1, [r0, #5]
 80118f4:	f010 f908 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80118f8:	2801      	cmp	r0, #1
 80118fa:	d005      	beq.n	8011908 <USBH_Get_CfgDesc+0x190>
      else if (URB_Status == USBH_URB_NOTREADY)
 80118fc:	2802      	cmp	r0, #2
 80118fe:	d1ac      	bne.n	801185a <USBH_Get_CfgDesc+0xe2>
            phost->Control.state = CTRL_STATUS_OUT;
 8011900:	2309      	movs	r3, #9
 8011902:	2001      	movs	r0, #1
 8011904:	762b      	strb	r3, [r5, #24]
 8011906:	e743      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8011908:	7f2a      	ldrb	r2, [r5, #28]
        phost->RequestState = CMD_SEND;
 801190a:	2101      	movs	r1, #1
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
 801190c:	7f6b      	ldrb	r3, [r5, #29]
        phost->Control.state = CTRL_IDLE;
 801190e:	2700      	movs	r7, #0
  cfg_desc->wTotalLength        = LE16(buf + 2);
 8011910:	8be8      	ldrh	r0, [r5, #30]
  if (length > USB_CONFIGURATION_DESC_SIZE)
 8011912:	2e09      	cmp	r6, #9
  cfg_desc->bLength             = *(uint8_t *)(buf + 0);
 8011914:	f885 2338 	strb.w	r2, [r5, #824]	; 0x338
  cfg_desc->bDescriptorType     = *(uint8_t *)(buf + 1);
 8011918:	f885 3339 	strb.w	r3, [r5, #825]	; 0x339
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 801191c:	6a2a      	ldr	r2, [r5, #32]
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 801191e:	f895 3024 	ldrb.w	r3, [r5, #36]	; 0x24
        phost->RequestState = CMD_SEND;
 8011922:	70a9      	strb	r1, [r5, #2]
        phost->Control.state = CTRL_IDLE;
 8011924:	762f      	strb	r7, [r5, #24]
  cfg_desc->wTotalLength        = LE16(buf + 2);
 8011926:	f8a5 033a 	strh.w	r0, [r5, #826]	; 0x33a
  cfg_desc->bNumInterfaces      = *(uint8_t *)(buf + 4);
 801192a:	f8c5 233c 	str.w	r2, [r5, #828]	; 0x33c
  cfg_desc->bMaxPower           = *(uint8_t *)(buf + 8);
 801192e:	f885 3340 	strb.w	r3, [r5, #832]	; 0x340
  if (length > USB_CONFIGURATION_DESC_SIZE)
 8011932:	d913      	bls.n	801195c <USBH_Get_CfgDesc+0x1e4>
 8011934:	46ac      	mov	ip, r5
    ptr = USB_LEN_CFG_DESC;
 8011936:	2209      	movs	r2, #9
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 8011938:	f04f 0e2a 	mov.w	lr, #42	; 0x2a
 801193c:	b2fe      	uxtb	r6, r7
 801193e:	2e09      	cmp	r6, #9
 8011940:	bf8c      	ite	hi
 8011942:	2600      	movhi	r6, #0
 8011944:	2601      	movls	r6, #1
 8011946:	e007      	b.n	8011958 <USBH_Get_CfgDesc+0x1e0>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 8011948:	b146      	cbz	r6, 801195c <USBH_Get_CfgDesc+0x1e4>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 801194a:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 801194c:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 801194e:	4413      	add	r3, r2
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
 8011950:	7861      	ldrb	r1, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 8011952:	b29a      	uxth	r2, r3
      if (pdesc->bDescriptorType   == USB_DESC_TYPE_INTERFACE)
 8011954:	2904      	cmp	r1, #4
 8011956:	d005      	beq.n	8011964 <USBH_Get_CfgDesc+0x1ec>
    while ((if_ix < USBH_MAX_NUM_INTERFACES) && (ptr < cfg_desc->wTotalLength))
 8011958:	4290      	cmp	r0, r2
 801195a:	d8f5      	bhi.n	8011948 <USBH_Get_CfgDesc+0x1d0>
        status = USBH_NOT_SUPPORTED;
 801195c:	2000      	movs	r0, #0
}
 801195e:	b003      	add	sp, #12
 8011960:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 8011964:	7823      	ldrb	r3, [r4, #0]
        ep_ix = 0U;
 8011966:	2100      	movs	r1, #0
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 8011968:	fb0e f907 	mul.w	r9, lr, r7
  if_descriptor->bLength            = *(uint8_t *)(buf + 0);
 801196c:	f88c 3342 	strb.w	r3, [ip, #834]	; 0x342
  if_descriptor->bDescriptorType    = *(uint8_t *)(buf + 1);
 8011970:	7863      	ldrb	r3, [r4, #1]
 8011972:	f88c 3343 	strb.w	r3, [ip, #835]	; 0x343
  if_descriptor->bInterfaceNumber   = *(uint8_t *)(buf + 2);
 8011976:	78a3      	ldrb	r3, [r4, #2]
 8011978:	f88c 3344 	strb.w	r3, [ip, #836]	; 0x344
  if_descriptor->bAlternateSetting  = *(uint8_t *)(buf + 3);
 801197c:	78e3      	ldrb	r3, [r4, #3]
 801197e:	f88c 3345 	strb.w	r3, [ip, #837]	; 0x345
  if_descriptor->bNumEndpoints      = *(uint8_t *)(buf + 4);
 8011982:	f894 8004 	ldrb.w	r8, [r4, #4]
 8011986:	f88c 8346 	strb.w	r8, [ip, #838]	; 0x346
  if_descriptor->bInterfaceClass    = *(uint8_t *)(buf + 5);
 801198a:	7963      	ldrb	r3, [r4, #5]
 801198c:	f88c 3347 	strb.w	r3, [ip, #839]	; 0x347
  if_descriptor->bInterfaceSubClass = *(uint8_t *)(buf + 6);
 8011990:	79a3      	ldrb	r3, [r4, #6]
 8011992:	f88c 3348 	strb.w	r3, [ip, #840]	; 0x348
  if_descriptor->bInterfaceProtocol = *(uint8_t *)(buf + 7);
 8011996:	79e3      	ldrb	r3, [r4, #7]
 8011998:	f88c 3349 	strb.w	r3, [ip, #841]	; 0x349
  if_descriptor->iInterface         = *(uint8_t *)(buf + 8);
 801199c:	7a23      	ldrb	r3, [r4, #8]
 801199e:	f88c 334a 	strb.w	r3, [ip, #842]	; 0x34a
        while ((ep_ix < pif->bNumEndpoints) && (ptr < cfg_desc->wTotalLength))
 80119a2:	4290      	cmp	r0, r2
 80119a4:	d922      	bls.n	80119ec <USBH_Get_CfgDesc+0x274>
 80119a6:	4541      	cmp	r1, r8
 80119a8:	d220      	bcs.n	80119ec <USBH_Get_CfgDesc+0x274>
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80119aa:	7823      	ldrb	r3, [r4, #0]
  pnext = (USBH_DescHeader_t *)(void *)((uint8_t *)(void *)pbuf + \
 80119ac:	441c      	add	r4, r3
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80119ae:	4413      	add	r3, r2
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
 80119b0:	7866      	ldrb	r6, [r4, #1]
  *ptr += ((USBH_DescHeader_t *)(void *)pbuf)->bLength;
 80119b2:	b29a      	uxth	r2, r3
          if (pdesc->bDescriptorType   == USB_DESC_TYPE_ENDPOINT)
 80119b4:	2e05      	cmp	r6, #5
 80119b6:	d1f4      	bne.n	80119a2 <USBH_Get_CfgDesc+0x22a>
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 80119b8:	3101      	adds	r1, #1
 80119ba:	7826      	ldrb	r6, [r4, #0]
 80119bc:	eb09 03c1 	add.w	r3, r9, r1, lsl #3
            ep_ix++;
 80119c0:	b2c9      	uxtb	r1, r1
  ep_descriptor->bLength          = *(uint8_t *)(buf + 0);
 80119c2:	442b      	add	r3, r5
 80119c4:	f883 6344 	strb.w	r6, [r3, #836]	; 0x344
  ep_descriptor->bDescriptorType  = *(uint8_t *)(buf + 1);
 80119c8:	7866      	ldrb	r6, [r4, #1]
 80119ca:	f883 6345 	strb.w	r6, [r3, #837]	; 0x345
  ep_descriptor->bEndpointAddress = *(uint8_t *)(buf + 2);
 80119ce:	78a6      	ldrb	r6, [r4, #2]
 80119d0:	f883 6346 	strb.w	r6, [r3, #838]	; 0x346
  ep_descriptor->bmAttributes     = *(uint8_t *)(buf + 3);
 80119d4:	78e6      	ldrb	r6, [r4, #3]
 80119d6:	f883 6347 	strb.w	r6, [r3, #839]	; 0x347
  ep_descriptor->wMaxPacketSize   = LE16(buf + 4);
 80119da:	88a6      	ldrh	r6, [r4, #4]
 80119dc:	f8a3 6348 	strh.w	r6, [r3, #840]	; 0x348
  ep_descriptor->bInterval        = *(uint8_t *)(buf + 6);
 80119e0:	79a6      	ldrb	r6, [r4, #6]
 80119e2:	f883 634a 	strb.w	r6, [r3, #842]	; 0x34a
 80119e6:	f89c 8346 	ldrb.w	r8, [ip, #838]	; 0x346
 80119ea:	e7da      	b.n	80119a2 <USBH_Get_CfgDesc+0x22a>
 80119ec:	3701      	adds	r7, #1
 80119ee:	f10c 0c2a 	add.w	ip, ip, #42	; 0x2a
 80119f2:	e7a3      	b.n	801193c <USBH_Get_CfgDesc+0x1c4>
          if (direction == USB_D2H)
 80119f4:	2b00      	cmp	r3, #0
 80119f6:	db83      	blt.n	8011900 <USBH_Get_CfgDesc+0x188>
            phost->Control.state = CTRL_STATUS_IN;
 80119f8:	2307      	movs	r3, #7
 80119fa:	2001      	movs	r0, #1
 80119fc:	762b      	strb	r3, [r5, #24]
 80119fe:	e6c7      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
        if (phost->Control.setup.b.wLength.w != 0U)
 8011a00:	8aea      	ldrh	r2, [r5, #22]
 8011a02:	f995 3010 	ldrsb.w	r3, [r5, #16]
 8011a06:	2a00      	cmp	r2, #0
 8011a08:	d0f4      	beq.n	80119f4 <USBH_Get_CfgDesc+0x27c>
          if (direction == USB_D2H)
 8011a0a:	2b00      	cmp	r3, #0
 8011a0c:	db08      	blt.n	8011a20 <USBH_Get_CfgDesc+0x2a8>
            phost->Control.state = CTRL_DATA_OUT;
 8011a0e:	2305      	movs	r3, #5
 8011a10:	2001      	movs	r0, #1
 8011a12:	762b      	strb	r3, [r5, #24]
 8011a14:	e6bc      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
        phost->Control.state = CTRL_SETUP;
 8011a16:	2301      	movs	r3, #1
 8011a18:	7603      	strb	r3, [r0, #24]
        phost->RequestState = CMD_SEND;
 8011a1a:	4618      	mov	r0, r3
 8011a1c:	70ab      	strb	r3, [r5, #2]
 8011a1e:	e6b7      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
            phost->Control.state = CTRL_DATA_IN;
 8011a20:	2303      	movs	r3, #3
 8011a22:	762b      	strb	r3, [r5, #24]
 8011a24:	e6b4      	b.n	8011790 <USBH_Get_CfgDesc+0x18>
 8011a26:	bf00      	nop

08011a28 <USBH_Get_StringDesc>:
{
 8011a28:	b5f0      	push	{r4, r5, r6, r7, lr}
  if (phost->RequestState == CMD_SEND)
 8011a2a:	7885      	ldrb	r5, [r0, #2]
{
 8011a2c:	b085      	sub	sp, #20
 8011a2e:	4604      	mov	r4, r0
                                   phost->device.Data, length)) == USBH_OK)
 8011a30:	f500 768e 	add.w	r6, r0, #284	; 0x11c
  if (phost->RequestState == CMD_SEND)
 8011a34:	2d01      	cmp	r5, #1
 8011a36:	d010      	beq.n	8011a5a <USBH_Get_StringDesc+0x32>
  switch (phost->RequestState)
 8011a38:	2d02      	cmp	r5, #2
 8011a3a:	d002      	beq.n	8011a42 <USBH_Get_StringDesc+0x1a>
  status = USBH_BUSY;
 8011a3c:	2001      	movs	r0, #1
}
 8011a3e:	b005      	add	sp, #20
 8011a40:	bdf0      	pop	{r4, r5, r6, r7, pc}
  switch (phost->Control.state)
 8011a42:	7e01      	ldrb	r1, [r0, #24]
 8011a44:	3901      	subs	r1, #1
 8011a46:	290a      	cmp	r1, #10
 8011a48:	d8f8      	bhi.n	8011a3c <USBH_Get_StringDesc+0x14>
 8011a4a:	e8df f001 	tbb	[pc, r1]
 8011a4e:	3e34      	.short	0x3e34
 8011a50:	74655a4d 	.word	0x74655a4d
 8011a54:	b5a69184 	.word	0xb5a69184
 8011a58:	19          	.byte	0x19
 8011a59:	00          	.byte	0x00
  if ((status = USBH_GetDescriptor(phost,
 8011a5a:	f441 7140 	orr.w	r1, r1, #768	; 0x300
    phost->Control.setup.b.wLength.w = length;
 8011a5e:	82c3      	strh	r3, [r0, #22]
      phost->Control.buff = buff;
 8011a60:	6086      	str	r6, [r0, #8]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8011a62:	f44f 6cd0 	mov.w	ip, #1664	; 0x680
    phost->Control.setup.b.wValue.w = value_idx;
 8011a66:	8241      	strh	r1, [r0, #18]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8011a68:	f240 4709 	movw	r7, #1033	; 0x409
      phost->Control.length = length;
 8011a6c:	8183      	strh	r3, [r0, #12]
      phost->RequestState = CMD_WAIT;
 8011a6e:	2202      	movs	r2, #2
      status = USBH_BUSY;
 8011a70:	4628      	mov	r0, r5
      phost->Control.state = CTRL_SETUP;
 8011a72:	7625      	strb	r5, [r4, #24]
    phost->Control.setup.b.bmRequestType = USB_D2H | req_type;
 8011a74:	f8a4 c010 	strh.w	ip, [r4, #16]
      phost->Control.setup.b.wIndex.w = 0x0409U;
 8011a78:	82a7      	strh	r7, [r4, #20]
      phost->RequestState = CMD_WAIT;
 8011a7a:	70a2      	strb	r2, [r4, #2]
}
 8011a7c:	b005      	add	sp, #20
 8011a7e:	bdf0      	pop	{r4, r5, r6, r7, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8011a80:	7e63      	ldrb	r3, [r4, #25]
 8011a82:	3301      	adds	r3, #1
 8011a84:	b2db      	uxtb	r3, r3
 8011a86:	2b02      	cmp	r3, #2
 8011a88:	7663      	strb	r3, [r4, #25]
 8011a8a:	f240 80d3 	bls.w	8011c34 <USBH_Get_StringDesc+0x20c>
        phost->Control.errorcount = 0U;
 8011a8e:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8011a90:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8011a94:	2106      	movs	r1, #6
 8011a96:	4620      	mov	r0, r4
 8011a98:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011a9a:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8011a9c:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011a9e:	4620      	mov	r0, r4
 8011aa0:	f000 fd14 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8011aa4:	7921      	ldrb	r1, [r4, #4]
 8011aa6:	4620      	mov	r0, r4
 8011aa8:	f000 fd10 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8011aac:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8011aae:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8011ab0:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8011ab2:	70a3      	strb	r3, [r4, #2]
 8011ab4:	e7c3      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8011ab6:	7962      	ldrb	r2, [r4, #5]
 8011ab8:	f104 0110 	add.w	r1, r4, #16
 8011abc:	4620      	mov	r0, r4
 8011abe:	f000 fc59 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8011ac2:	2302      	movs	r3, #2
 8011ac4:	2001      	movs	r0, #1
 8011ac6:	7623      	strb	r3, [r4, #24]
 8011ac8:	e7b9      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011aca:	7961      	ldrb	r1, [r4, #5]
 8011acc:	4620      	mov	r0, r4
 8011ace:	f010 f81b 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011ad2:	2801      	cmp	r0, #1
 8011ad4:	f000 80a3 	beq.w	8011c1e <USBH_Get_StringDesc+0x1f6>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8011ad8:	2804      	cmp	r0, #4
 8011ada:	d001      	beq.n	8011ae0 <USBH_Get_StringDesc+0xb8>
 8011adc:	2802      	cmp	r0, #2
 8011ade:	d1ad      	bne.n	8011a3c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
 8011ae0:	230b      	movs	r3, #11
 8011ae2:	2001      	movs	r0, #1
 8011ae4:	7623      	strb	r3, [r4, #24]
 8011ae6:	e7aa      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011ae8:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011aec:	4620      	mov	r0, r4
 8011aee:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8011af0:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011af2:	68a1      	ldr	r1, [r4, #8]
 8011af4:	89a2      	ldrh	r2, [r4, #12]
 8011af6:	f000 fc65 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8011afa:	2304      	movs	r3, #4
 8011afc:	2001      	movs	r0, #1
 8011afe:	7623      	strb	r3, [r4, #24]
 8011b00:	e79d      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011b02:	7921      	ldrb	r1, [r4, #4]
 8011b04:	4620      	mov	r0, r4
 8011b06:	f00f ffff 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011b0a:	2801      	cmp	r0, #1
 8011b0c:	d060      	beq.n	8011bd0 <USBH_Get_StringDesc+0x1a8>
      if (URB_Status == USBH_URB_STALL)
 8011b0e:	2805      	cmp	r0, #5
 8011b10:	d03d      	beq.n	8011b8e <USBH_Get_StringDesc+0x166>
        if (URB_Status == USBH_URB_ERROR)
 8011b12:	2804      	cmp	r0, #4
 8011b14:	d192      	bne.n	8011a3c <USBH_Get_StringDesc+0x14>
 8011b16:	e7e3      	b.n	8011ae0 <USBH_Get_StringDesc+0xb8>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8011b18:	2501      	movs	r5, #1
 8011b1a:	7963      	ldrb	r3, [r4, #5]
 8011b1c:	89a2      	ldrh	r2, [r4, #12]
 8011b1e:	4620      	mov	r0, r4
 8011b20:	68a1      	ldr	r1, [r4, #8]
 8011b22:	9500      	str	r5, [sp, #0]
 8011b24:	f000 fc36 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011b28:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011b2c:	2306      	movs	r3, #6
 8011b2e:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011b30:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011b32:	7623      	strb	r3, [r4, #24]
 8011b34:	e783      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011b36:	7961      	ldrb	r1, [r4, #5]
 8011b38:	4620      	mov	r0, r4
 8011b3a:	f00f ffe5 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011b3e:	2801      	cmp	r0, #1
 8011b40:	d069      	beq.n	8011c16 <USBH_Get_StringDesc+0x1ee>
      else if (URB_Status == USBH_URB_STALL)
 8011b42:	2805      	cmp	r0, #5
 8011b44:	d023      	beq.n	8011b8e <USBH_Get_StringDesc+0x166>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011b46:	2802      	cmp	r0, #2
 8011b48:	d070      	beq.n	8011c2c <USBH_Get_StringDesc+0x204>
        if (URB_Status == USBH_URB_ERROR)
 8011b4a:	2804      	cmp	r0, #4
 8011b4c:	f47f af76 	bne.w	8011a3c <USBH_Get_StringDesc+0x14>
          phost->Control.state = CTRL_ERROR;
 8011b50:	230b      	movs	r3, #11
 8011b52:	7623      	strb	r3, [r4, #24]
 8011b54:	e7ab      	b.n	8011aae <USBH_Get_StringDesc+0x86>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8011b56:	2200      	movs	r2, #0
 8011b58:	7923      	ldrb	r3, [r4, #4]
 8011b5a:	4620      	mov	r0, r4
 8011b5c:	4611      	mov	r1, r2
 8011b5e:	f000 fc31 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011b62:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011b66:	2308      	movs	r3, #8
 8011b68:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8011b6a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011b6c:	7623      	strb	r3, [r4, #24]
 8011b6e:	e766      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011b70:	7921      	ldrb	r1, [r4, #4]
 8011b72:	4620      	mov	r0, r4
 8011b74:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8011b78:	f00f ffc6 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011b7c:	2801      	cmp	r0, #1
 8011b7e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8011b82:	d029      	beq.n	8011bd8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_ERROR)
 8011b84:	2804      	cmp	r0, #4
 8011b86:	d0ab      	beq.n	8011ae0 <USBH_Get_StringDesc+0xb8>
        if (URB_Status == USBH_URB_STALL)
 8011b88:	2805      	cmp	r0, #5
 8011b8a:	f47f af57 	bne.w	8011a3c <USBH_Get_StringDesc+0x14>
        phost->RequestState = CMD_SEND;
 8011b8e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8011b90:	2300      	movs	r3, #0
        status = USBH_NOT_SUPPORTED;
 8011b92:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 8011b94:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8011b96:	7623      	strb	r3, [r4, #24]
 8011b98:	e751      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 8011b9a:	2200      	movs	r2, #0
 8011b9c:	2501      	movs	r5, #1
 8011b9e:	7963      	ldrb	r3, [r4, #5]
 8011ba0:	4620      	mov	r0, r4
 8011ba2:	4611      	mov	r1, r2
 8011ba4:	9500      	str	r5, [sp, #0]
 8011ba6:	f000 fbf5 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011baa:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011bae:	230a      	movs	r3, #10
 8011bb0:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011bb2:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011bb4:	7623      	strb	r3, [r4, #24]
 8011bb6:	e742      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011bb8:	7961      	ldrb	r1, [r4, #5]
 8011bba:	4620      	mov	r0, r4
 8011bbc:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8011bc0:	f00f ffa2 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011bc4:	2801      	cmp	r0, #1
 8011bc6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8011bca:	d005      	beq.n	8011bd8 <USBH_Get_StringDesc+0x1b0>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011bcc:	2802      	cmp	r0, #2
 8011bce:	d1a0      	bne.n	8011b12 <USBH_Get_StringDesc+0xea>
            phost->Control.state = CTRL_STATUS_OUT;
 8011bd0:	2309      	movs	r3, #9
 8011bd2:	2001      	movs	r0, #1
 8011bd4:	7623      	strb	r3, [r4, #24]
 8011bd6:	e732      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
  if (psrc[1] == USB_DESC_TYPE_STRING)
 8011bd8:	f894 111d 	ldrb.w	r1, [r4, #285]	; 0x11d
        phost->RequestState = CMD_SEND;
 8011bdc:	2501      	movs	r5, #1
        phost->Control.state = CTRL_IDLE;
 8011bde:	2000      	movs	r0, #0
  if (psrc[1] == USB_DESC_TYPE_STRING)
 8011be0:	2903      	cmp	r1, #3
        phost->RequestState = CMD_SEND;
 8011be2:	70a5      	strb	r5, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8011be4:	7620      	strb	r0, [r4, #24]
  if (psrc[1] == USB_DESC_TYPE_STRING)
 8011be6:	f47f af2a 	bne.w	8011a3e <USBH_Get_StringDesc+0x16>
    strlength = ((((uint16_t)psrc[0] - 2U) <= length) ? ((uint16_t)psrc[0] - 2U) : length);
 8011bea:	f894 111c 	ldrb.w	r1, [r4, #284]	; 0x11c
 8011bee:	3902      	subs	r1, #2
 8011bf0:	428b      	cmp	r3, r1
 8011bf2:	bf28      	it	cs
 8011bf4:	460b      	movcs	r3, r1
 8011bf6:	b299      	uxth	r1, r3
    for (idx = 0U; idx < strlength; idx += 2U)
 8011bf8:	b13b      	cbz	r3, 8011c0a <USBH_Get_StringDesc+0x1e2>
      *pdest =  psrc[idx];
 8011bfa:	1833      	adds	r3, r6, r0
    for (idx = 0U; idx < strlength; idx += 2U)
 8011bfc:	3002      	adds	r0, #2
 8011bfe:	b280      	uxth	r0, r0
      *pdest =  psrc[idx];
 8011c00:	789b      	ldrb	r3, [r3, #2]
    for (idx = 0U; idx < strlength; idx += 2U)
 8011c02:	4281      	cmp	r1, r0
      *pdest =  psrc[idx];
 8011c04:	f802 3b01 	strb.w	r3, [r2], #1
    for (idx = 0U; idx < strlength; idx += 2U)
 8011c08:	d8f7      	bhi.n	8011bfa <USBH_Get_StringDesc+0x1d2>
    *pdest = 0U; /* mark end of string */
 8011c0a:	2000      	movs	r0, #0
 8011c0c:	7010      	strb	r0, [r2, #0]
}
 8011c0e:	b005      	add	sp, #20
 8011c10:	bdf0      	pop	{r4, r5, r6, r7, pc}
          if (direction == USB_D2H)
 8011c12:	2a00      	cmp	r2, #0
 8011c14:	dbdc      	blt.n	8011bd0 <USBH_Get_StringDesc+0x1a8>
            phost->Control.state = CTRL_STATUS_IN;
 8011c16:	2307      	movs	r3, #7
 8011c18:	2001      	movs	r0, #1
 8011c1a:	7623      	strb	r3, [r4, #24]
 8011c1c:	e70f      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
        if (phost->Control.setup.b.wLength.w != 0U)
 8011c1e:	8ae3      	ldrh	r3, [r4, #22]
 8011c20:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8011c24:	2b00      	cmp	r3, #0
 8011c26:	d0f4      	beq.n	8011c12 <USBH_Get_StringDesc+0x1ea>
          if (direction == USB_D2H)
 8011c28:	2a00      	cmp	r2, #0
 8011c2a:	db08      	blt.n	8011c3e <USBH_Get_StringDesc+0x216>
            phost->Control.state = CTRL_DATA_OUT;
 8011c2c:	2305      	movs	r3, #5
 8011c2e:	2001      	movs	r0, #1
 8011c30:	7623      	strb	r3, [r4, #24]
 8011c32:	e704      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
        phost->Control.state = CTRL_SETUP;
 8011c34:	2301      	movs	r3, #1
 8011c36:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8011c38:	4618      	mov	r0, r3
 8011c3a:	70a3      	strb	r3, [r4, #2]
 8011c3c:	e6ff      	b.n	8011a3e <USBH_Get_StringDesc+0x16>
            phost->Control.state = CTRL_DATA_IN;
 8011c3e:	2303      	movs	r3, #3
 8011c40:	7623      	strb	r3, [r4, #24]
 8011c42:	e6fc      	b.n	8011a3e <USBH_Get_StringDesc+0x16>

08011c44 <USBH_SetAddress>:
{
 8011c44:	b530      	push	{r4, r5, lr}
 8011c46:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 8011c48:	7880      	ldrb	r0, [r0, #2]
{
 8011c4a:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 8011c4c:	2801      	cmp	r0, #1
 8011c4e:	d011      	beq.n	8011c74 <USBH_SetAddress+0x30>
  switch (phost->RequestState)
 8011c50:	2802      	cmp	r0, #2
 8011c52:	d002      	beq.n	8011c5a <USBH_SetAddress+0x16>
  status = USBH_BUSY;
 8011c54:	2001      	movs	r0, #1
}
 8011c56:	b003      	add	sp, #12
 8011c58:	bd30      	pop	{r4, r5, pc}
 8011c5a:	461c      	mov	r4, r3
  switch (phost->Control.state)
 8011c5c:	7e1b      	ldrb	r3, [r3, #24]
 8011c5e:	3b01      	subs	r3, #1
 8011c60:	2b0a      	cmp	r3, #10
 8011c62:	d8f7      	bhi.n	8011c54 <USBH_SetAddress+0x10>
 8011c64:	e8df f003 	tbb	[pc, r3]
 8011c68:	5447382e 	.word	0x5447382e
 8011c6c:	8b7e6e5f 	.word	0x8b7e6e5f
 8011c70:	ac9d      	.short	0xac9d
 8011c72:	13          	.byte	0x13
 8011c73:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 8011c74:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8011c76:	f44f 65a0 	mov.w	r5, #1280	; 0x500
      phost->RequestState = CMD_WAIT;
 8011c7a:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = (uint16_t)DeviceAddress;
 8011c7c:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 8011c7e:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE | \
 8011c80:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 8011c82:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 8011c84:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 8011c86:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8011c88:	709c      	strb	r4, [r3, #2]
}
 8011c8a:	b003      	add	sp, #12
 8011c8c:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8011c8e:	7e63      	ldrb	r3, [r4, #25]
 8011c90:	3301      	adds	r3, #1
 8011c92:	b2db      	uxtb	r3, r3
 8011c94:	2b02      	cmp	r3, #2
 8011c96:	7663      	strb	r3, [r4, #25]
 8011c98:	f240 80b1 	bls.w	8011dfe <USBH_SetAddress+0x1ba>
        phost->Control.errorcount = 0U;
 8011c9c:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8011c9e:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8011ca2:	2106      	movs	r1, #6
 8011ca4:	4620      	mov	r0, r4
 8011ca6:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011ca8:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8011caa:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011cac:	4620      	mov	r0, r4
 8011cae:	f000 fc0d 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8011cb2:	7921      	ldrb	r1, [r4, #4]
 8011cb4:	4620      	mov	r0, r4
 8011cb6:	f000 fc09 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8011cba:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8011cbc:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8011cbe:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8011cc0:	70a3      	strb	r3, [r4, #2]
 8011cc2:	e7c8      	b.n	8011c56 <USBH_SetAddress+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8011cc4:	7962      	ldrb	r2, [r4, #5]
 8011cc6:	f104 0110 	add.w	r1, r4, #16
 8011cca:	4620      	mov	r0, r4
 8011ccc:	f000 fb52 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8011cd0:	2302      	movs	r3, #2
 8011cd2:	2001      	movs	r0, #1
 8011cd4:	7623      	strb	r3, [r4, #24]
 8011cd6:	e7be      	b.n	8011c56 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011cd8:	7961      	ldrb	r1, [r4, #5]
 8011cda:	4620      	mov	r0, r4
 8011cdc:	f00f ff14 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011ce0:	2801      	cmp	r0, #1
 8011ce2:	f000 8081 	beq.w	8011de8 <USBH_SetAddress+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8011ce6:	2804      	cmp	r0, #4
 8011ce8:	d001      	beq.n	8011cee <USBH_SetAddress+0xaa>
 8011cea:	2802      	cmp	r0, #2
 8011cec:	d1b2      	bne.n	8011c54 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
 8011cee:	230b      	movs	r3, #11
 8011cf0:	2001      	movs	r0, #1
 8011cf2:	7623      	strb	r3, [r4, #24]
 8011cf4:	e7af      	b.n	8011c56 <USBH_SetAddress+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011cf6:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011cfa:	4620      	mov	r0, r4
 8011cfc:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8011cfe:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011d00:	68a1      	ldr	r1, [r4, #8]
 8011d02:	89a2      	ldrh	r2, [r4, #12]
 8011d04:	f000 fb5e 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8011d08:	2304      	movs	r3, #4
 8011d0a:	2001      	movs	r0, #1
 8011d0c:	7623      	strb	r3, [r4, #24]
 8011d0e:	e7a2      	b.n	8011c56 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011d10:	7921      	ldrb	r1, [r4, #4]
 8011d12:	4620      	mov	r0, r4
 8011d14:	f00f fef8 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011d18:	2801      	cmp	r0, #1
 8011d1a:	d059      	beq.n	8011dd0 <USBH_SetAddress+0x18c>
      if (URB_Status == USBH_URB_STALL)
 8011d1c:	2805      	cmp	r0, #5
 8011d1e:	d039      	beq.n	8011d94 <USBH_SetAddress+0x150>
        if (URB_Status == USBH_URB_ERROR)
 8011d20:	2804      	cmp	r0, #4
 8011d22:	d197      	bne.n	8011c54 <USBH_SetAddress+0x10>
 8011d24:	e7e3      	b.n	8011cee <USBH_SetAddress+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8011d26:	2501      	movs	r5, #1
 8011d28:	7963      	ldrb	r3, [r4, #5]
 8011d2a:	89a2      	ldrh	r2, [r4, #12]
 8011d2c:	4620      	mov	r0, r4
 8011d2e:	68a1      	ldr	r1, [r4, #8]
 8011d30:	9500      	str	r5, [sp, #0]
 8011d32:	f000 fb2f 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011d36:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011d3a:	2306      	movs	r3, #6
 8011d3c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011d3e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011d40:	7623      	strb	r3, [r4, #24]
 8011d42:	e788      	b.n	8011c56 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011d44:	7961      	ldrb	r1, [r4, #5]
 8011d46:	4620      	mov	r0, r4
 8011d48:	f00f fede 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011d4c:	2801      	cmp	r0, #1
 8011d4e:	d047      	beq.n	8011de0 <USBH_SetAddress+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 8011d50:	2805      	cmp	r0, #5
 8011d52:	d01f      	beq.n	8011d94 <USBH_SetAddress+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011d54:	2802      	cmp	r0, #2
 8011d56:	d04e      	beq.n	8011df6 <USBH_SetAddress+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 8011d58:	2804      	cmp	r0, #4
 8011d5a:	f47f af7b 	bne.w	8011c54 <USBH_SetAddress+0x10>
          phost->Control.state = CTRL_ERROR;
 8011d5e:	230b      	movs	r3, #11
 8011d60:	7623      	strb	r3, [r4, #24]
 8011d62:	e7ab      	b.n	8011cbc <USBH_SetAddress+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8011d64:	2200      	movs	r2, #0
 8011d66:	7923      	ldrb	r3, [r4, #4]
 8011d68:	4620      	mov	r0, r4
 8011d6a:	4611      	mov	r1, r2
 8011d6c:	f000 fb2a 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011d70:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011d74:	2308      	movs	r3, #8
 8011d76:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8011d78:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011d7a:	7623      	strb	r3, [r4, #24]
 8011d7c:	e76b      	b.n	8011c56 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011d7e:	7921      	ldrb	r1, [r4, #4]
 8011d80:	4620      	mov	r0, r4
 8011d82:	f00f fec1 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011d86:	2801      	cmp	r0, #1
 8011d88:	d026      	beq.n	8011dd8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 8011d8a:	2804      	cmp	r0, #4
 8011d8c:	d0af      	beq.n	8011cee <USBH_SetAddress+0xaa>
        if (URB_Status == USBH_URB_STALL)
 8011d8e:	2805      	cmp	r0, #5
 8011d90:	f47f af60 	bne.w	8011c54 <USBH_SetAddress+0x10>
        status = USBH_NOT_SUPPORTED;
 8011d94:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 8011d96:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8011d98:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8011d9a:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8011d9c:	7623      	strb	r3, [r4, #24]
}
 8011d9e:	b003      	add	sp, #12
 8011da0:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 8011da2:	2200      	movs	r2, #0
 8011da4:	2501      	movs	r5, #1
 8011da6:	7963      	ldrb	r3, [r4, #5]
 8011da8:	4620      	mov	r0, r4
 8011daa:	4611      	mov	r1, r2
 8011dac:	9500      	str	r5, [sp, #0]
 8011dae:	f000 faf1 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011db2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011db6:	230a      	movs	r3, #10
 8011db8:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011dba:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011dbc:	7623      	strb	r3, [r4, #24]
 8011dbe:	e74a      	b.n	8011c56 <USBH_SetAddress+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011dc0:	7961      	ldrb	r1, [r4, #5]
 8011dc2:	4620      	mov	r0, r4
 8011dc4:	f00f fea0 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011dc8:	2801      	cmp	r0, #1
 8011dca:	d005      	beq.n	8011dd8 <USBH_SetAddress+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011dcc:	2802      	cmp	r0, #2
 8011dce:	d1a7      	bne.n	8011d20 <USBH_SetAddress+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8011dd0:	2309      	movs	r3, #9
 8011dd2:	2001      	movs	r0, #1
 8011dd4:	7623      	strb	r3, [r4, #24]
 8011dd6:	e73e      	b.n	8011c56 <USBH_SetAddress+0x12>
        status = USBH_OK;
 8011dd8:	2000      	movs	r0, #0
 8011dda:	e7dc      	b.n	8011d96 <USBH_SetAddress+0x152>
          if (direction == USB_D2H)
 8011ddc:	2a00      	cmp	r2, #0
 8011dde:	dbf7      	blt.n	8011dd0 <USBH_SetAddress+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8011de0:	2307      	movs	r3, #7
 8011de2:	2001      	movs	r0, #1
 8011de4:	7623      	strb	r3, [r4, #24]
 8011de6:	e736      	b.n	8011c56 <USBH_SetAddress+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 8011de8:	8ae3      	ldrh	r3, [r4, #22]
 8011dea:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8011dee:	2b00      	cmp	r3, #0
 8011df0:	d0f4      	beq.n	8011ddc <USBH_SetAddress+0x198>
          if (direction == USB_D2H)
 8011df2:	2a00      	cmp	r2, #0
 8011df4:	db08      	blt.n	8011e08 <USBH_SetAddress+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 8011df6:	2305      	movs	r3, #5
 8011df8:	2001      	movs	r0, #1
 8011dfa:	7623      	strb	r3, [r4, #24]
 8011dfc:	e72b      	b.n	8011c56 <USBH_SetAddress+0x12>
        phost->Control.state = CTRL_SETUP;
 8011dfe:	2301      	movs	r3, #1
 8011e00:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8011e02:	4618      	mov	r0, r3
 8011e04:	70a3      	strb	r3, [r4, #2]
 8011e06:	e726      	b.n	8011c56 <USBH_SetAddress+0x12>
            phost->Control.state = CTRL_DATA_IN;
 8011e08:	2303      	movs	r3, #3
 8011e0a:	7623      	strb	r3, [r4, #24]
 8011e0c:	e723      	b.n	8011c56 <USBH_SetAddress+0x12>
 8011e0e:	bf00      	nop

08011e10 <USBH_SetCfg>:
{
 8011e10:	b530      	push	{r4, r5, lr}
 8011e12:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 8011e14:	7880      	ldrb	r0, [r0, #2]
{
 8011e16:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 8011e18:	2801      	cmp	r0, #1
 8011e1a:	d011      	beq.n	8011e40 <USBH_SetCfg+0x30>
  switch (phost->RequestState)
 8011e1c:	2802      	cmp	r0, #2
 8011e1e:	d002      	beq.n	8011e26 <USBH_SetCfg+0x16>
  status = USBH_BUSY;
 8011e20:	2001      	movs	r0, #1
}
 8011e22:	b003      	add	sp, #12
 8011e24:	bd30      	pop	{r4, r5, pc}
 8011e26:	461c      	mov	r4, r3
  switch (phost->Control.state)
 8011e28:	7e1b      	ldrb	r3, [r3, #24]
 8011e2a:	3b01      	subs	r3, #1
 8011e2c:	2b0a      	cmp	r3, #10
 8011e2e:	d8f7      	bhi.n	8011e20 <USBH_SetCfg+0x10>
 8011e30:	e8df f003 	tbb	[pc, r3]
 8011e34:	5447382e 	.word	0x5447382e
 8011e38:	8b7e6e5f 	.word	0x8b7e6e5f
 8011e3c:	ac9d      	.short	0xac9d
 8011e3e:	13          	.byte	0x13
 8011e3f:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 8011e40:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8011e42:	f44f 6510 	mov.w	r5, #2304	; 0x900
      phost->RequestState = CMD_WAIT;
 8011e46:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = cfg_idx;
 8011e48:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 8011e4a:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8011e4c:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 8011e4e:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 8011e50:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 8011e52:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8011e54:	709c      	strb	r4, [r3, #2]
}
 8011e56:	b003      	add	sp, #12
 8011e58:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8011e5a:	7e63      	ldrb	r3, [r4, #25]
 8011e5c:	3301      	adds	r3, #1
 8011e5e:	b2db      	uxtb	r3, r3
 8011e60:	2b02      	cmp	r3, #2
 8011e62:	7663      	strb	r3, [r4, #25]
 8011e64:	f240 80b1 	bls.w	8011fca <USBH_SetCfg+0x1ba>
        phost->Control.errorcount = 0U;
 8011e68:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8011e6a:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8011e6e:	2106      	movs	r1, #6
 8011e70:	4620      	mov	r0, r4
 8011e72:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011e74:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8011e76:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8011e78:	4620      	mov	r0, r4
 8011e7a:	f000 fb27 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8011e7e:	7921      	ldrb	r1, [r4, #4]
 8011e80:	4620      	mov	r0, r4
 8011e82:	f000 fb23 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8011e86:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8011e88:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8011e8a:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8011e8c:	70a3      	strb	r3, [r4, #2]
 8011e8e:	e7c8      	b.n	8011e22 <USBH_SetCfg+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8011e90:	7962      	ldrb	r2, [r4, #5]
 8011e92:	f104 0110 	add.w	r1, r4, #16
 8011e96:	4620      	mov	r0, r4
 8011e98:	f000 fa6c 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8011e9c:	2302      	movs	r3, #2
 8011e9e:	2001      	movs	r0, #1
 8011ea0:	7623      	strb	r3, [r4, #24]
 8011ea2:	e7be      	b.n	8011e22 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011ea4:	7961      	ldrb	r1, [r4, #5]
 8011ea6:	4620      	mov	r0, r4
 8011ea8:	f00f fe2e 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011eac:	2801      	cmp	r0, #1
 8011eae:	f000 8081 	beq.w	8011fb4 <USBH_SetCfg+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 8011eb2:	2804      	cmp	r0, #4
 8011eb4:	d001      	beq.n	8011eba <USBH_SetCfg+0xaa>
 8011eb6:	2802      	cmp	r0, #2
 8011eb8:	d1b2      	bne.n	8011e20 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
 8011eba:	230b      	movs	r3, #11
 8011ebc:	2001      	movs	r0, #1
 8011ebe:	7623      	strb	r3, [r4, #24]
 8011ec0:	e7af      	b.n	8011e22 <USBH_SetCfg+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011ec2:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011ec6:	4620      	mov	r0, r4
 8011ec8:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8011eca:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8011ecc:	68a1      	ldr	r1, [r4, #8]
 8011ece:	89a2      	ldrh	r2, [r4, #12]
 8011ed0:	f000 fa78 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 8011ed4:	2304      	movs	r3, #4
 8011ed6:	2001      	movs	r0, #1
 8011ed8:	7623      	strb	r3, [r4, #24]
 8011eda:	e7a2      	b.n	8011e22 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011edc:	7921      	ldrb	r1, [r4, #4]
 8011ede:	4620      	mov	r0, r4
 8011ee0:	f00f fe12 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011ee4:	2801      	cmp	r0, #1
 8011ee6:	d059      	beq.n	8011f9c <USBH_SetCfg+0x18c>
      if (URB_Status == USBH_URB_STALL)
 8011ee8:	2805      	cmp	r0, #5
 8011eea:	d039      	beq.n	8011f60 <USBH_SetCfg+0x150>
        if (URB_Status == USBH_URB_ERROR)
 8011eec:	2804      	cmp	r0, #4
 8011eee:	d197      	bne.n	8011e20 <USBH_SetCfg+0x10>
 8011ef0:	e7e3      	b.n	8011eba <USBH_SetCfg+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 8011ef2:	2501      	movs	r5, #1
 8011ef4:	7963      	ldrb	r3, [r4, #5]
 8011ef6:	89a2      	ldrh	r2, [r4, #12]
 8011ef8:	4620      	mov	r0, r4
 8011efa:	68a1      	ldr	r1, [r4, #8]
 8011efc:	9500      	str	r5, [sp, #0]
 8011efe:	f000 fa49 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f02:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011f06:	2306      	movs	r3, #6
 8011f08:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f0a:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 8011f0c:	7623      	strb	r3, [r4, #24]
 8011f0e:	e788      	b.n	8011e22 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011f10:	7961      	ldrb	r1, [r4, #5]
 8011f12:	4620      	mov	r0, r4
 8011f14:	f00f fdf8 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011f18:	2801      	cmp	r0, #1
 8011f1a:	d047      	beq.n	8011fac <USBH_SetCfg+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 8011f1c:	2805      	cmp	r0, #5
 8011f1e:	d01f      	beq.n	8011f60 <USBH_SetCfg+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011f20:	2802      	cmp	r0, #2
 8011f22:	d04e      	beq.n	8011fc2 <USBH_SetCfg+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 8011f24:	2804      	cmp	r0, #4
 8011f26:	f47f af7b 	bne.w	8011e20 <USBH_SetCfg+0x10>
          phost->Control.state = CTRL_ERROR;
 8011f2a:	230b      	movs	r3, #11
 8011f2c:	7623      	strb	r3, [r4, #24]
 8011f2e:	e7ab      	b.n	8011e88 <USBH_SetCfg+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 8011f30:	2200      	movs	r2, #0
 8011f32:	7923      	ldrb	r3, [r4, #4]
 8011f34:	4620      	mov	r0, r4
 8011f36:	4611      	mov	r1, r2
 8011f38:	f000 fa44 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f3c:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011f40:	2308      	movs	r3, #8
 8011f42:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f44:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8011f46:	7623      	strb	r3, [r4, #24]
 8011f48:	e76b      	b.n	8011e22 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8011f4a:	7921      	ldrb	r1, [r4, #4]
 8011f4c:	4620      	mov	r0, r4
 8011f4e:	f00f fddb 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011f52:	2801      	cmp	r0, #1
 8011f54:	d026      	beq.n	8011fa4 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 8011f56:	2804      	cmp	r0, #4
 8011f58:	d0af      	beq.n	8011eba <USBH_SetCfg+0xaa>
        if (URB_Status == USBH_URB_STALL)
 8011f5a:	2805      	cmp	r0, #5
 8011f5c:	f47f af60 	bne.w	8011e20 <USBH_SetCfg+0x10>
        status = USBH_NOT_SUPPORTED;
 8011f60:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 8011f62:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8011f64:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8011f66:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8011f68:	7623      	strb	r3, [r4, #24]
}
 8011f6a:	b003      	add	sp, #12
 8011f6c:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 8011f6e:	2200      	movs	r2, #0
 8011f70:	2501      	movs	r5, #1
 8011f72:	7963      	ldrb	r3, [r4, #5]
 8011f74:	4620      	mov	r0, r4
 8011f76:	4611      	mov	r1, r2
 8011f78:	9500      	str	r5, [sp, #0]
 8011f7a:	f000 fa0b 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f7e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011f82:	230a      	movs	r3, #10
 8011f84:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8011f86:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8011f88:	7623      	strb	r3, [r4, #24]
 8011f8a:	e74a      	b.n	8011e22 <USBH_SetCfg+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8011f8c:	7961      	ldrb	r1, [r4, #5]
 8011f8e:	4620      	mov	r0, r4
 8011f90:	f00f fdba 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8011f94:	2801      	cmp	r0, #1
 8011f96:	d005      	beq.n	8011fa4 <USBH_SetCfg+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8011f98:	2802      	cmp	r0, #2
 8011f9a:	d1a7      	bne.n	8011eec <USBH_SetCfg+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8011f9c:	2309      	movs	r3, #9
 8011f9e:	2001      	movs	r0, #1
 8011fa0:	7623      	strb	r3, [r4, #24]
 8011fa2:	e73e      	b.n	8011e22 <USBH_SetCfg+0x12>
        status = USBH_OK;
 8011fa4:	2000      	movs	r0, #0
 8011fa6:	e7dc      	b.n	8011f62 <USBH_SetCfg+0x152>
          if (direction == USB_D2H)
 8011fa8:	2a00      	cmp	r2, #0
 8011faa:	dbf7      	blt.n	8011f9c <USBH_SetCfg+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8011fac:	2307      	movs	r3, #7
 8011fae:	2001      	movs	r0, #1
 8011fb0:	7623      	strb	r3, [r4, #24]
 8011fb2:	e736      	b.n	8011e22 <USBH_SetCfg+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 8011fb4:	8ae3      	ldrh	r3, [r4, #22]
 8011fb6:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8011fba:	2b00      	cmp	r3, #0
 8011fbc:	d0f4      	beq.n	8011fa8 <USBH_SetCfg+0x198>
          if (direction == USB_D2H)
 8011fbe:	2a00      	cmp	r2, #0
 8011fc0:	db08      	blt.n	8011fd4 <USBH_SetCfg+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 8011fc2:	2305      	movs	r3, #5
 8011fc4:	2001      	movs	r0, #1
 8011fc6:	7623      	strb	r3, [r4, #24]
 8011fc8:	e72b      	b.n	8011e22 <USBH_SetCfg+0x12>
        phost->Control.state = CTRL_SETUP;
 8011fca:	2301      	movs	r3, #1
 8011fcc:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8011fce:	4618      	mov	r0, r3
 8011fd0:	70a3      	strb	r3, [r4, #2]
 8011fd2:	e726      	b.n	8011e22 <USBH_SetCfg+0x12>
            phost->Control.state = CTRL_DATA_IN;
 8011fd4:	2303      	movs	r3, #3
 8011fd6:	7623      	strb	r3, [r4, #24]
 8011fd8:	e723      	b.n	8011e22 <USBH_SetCfg+0x12>
 8011fda:	bf00      	nop

08011fdc <USBH_SetFeature>:
{
 8011fdc:	b530      	push	{r4, r5, lr}
 8011fde:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 8011fe0:	7880      	ldrb	r0, [r0, #2]
{
 8011fe2:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 8011fe4:	2801      	cmp	r0, #1
 8011fe6:	d011      	beq.n	801200c <USBH_SetFeature+0x30>
  switch (phost->RequestState)
 8011fe8:	2802      	cmp	r0, #2
 8011fea:	d002      	beq.n	8011ff2 <USBH_SetFeature+0x16>
  status = USBH_BUSY;
 8011fec:	2001      	movs	r0, #1
}
 8011fee:	b003      	add	sp, #12
 8011ff0:	bd30      	pop	{r4, r5, pc}
 8011ff2:	461c      	mov	r4, r3
  switch (phost->Control.state)
 8011ff4:	7e1b      	ldrb	r3, [r3, #24]
 8011ff6:	3b01      	subs	r3, #1
 8011ff8:	2b0a      	cmp	r3, #10
 8011ffa:	d8f7      	bhi.n	8011fec <USBH_SetFeature+0x10>
 8011ffc:	e8df f003 	tbb	[pc, r3]
 8012000:	5447382e 	.word	0x5447382e
 8012004:	8b7e6e5f 	.word	0x8b7e6e5f
 8012008:	ac9d      	.short	0xac9d
 801200a:	13          	.byte	0x13
 801200b:	00          	.byte	0x00
    phost->Control.setup.b.wIndex.w = 0U;
 801200c:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 801200e:	f44f 7540 	mov.w	r5, #768	; 0x300
      phost->RequestState = CMD_WAIT;
 8012012:	2402      	movs	r4, #2
    phost->Control.setup.b.wValue.w = wValue;
 8012014:	8259      	strh	r1, [r3, #18]
      phost->Control.state = CTRL_SETUP;
 8012016:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_DEVICE
 8012018:	821d      	strh	r5, [r3, #16]
    phost->Control.setup.b.wIndex.w = 0U;
 801201a:	615a      	str	r2, [r3, #20]
      phost->Control.buff = buff;
 801201c:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 801201e:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 8012020:	709c      	strb	r4, [r3, #2]
}
 8012022:	b003      	add	sp, #12
 8012024:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 8012026:	7e63      	ldrb	r3, [r4, #25]
 8012028:	3301      	adds	r3, #1
 801202a:	b2db      	uxtb	r3, r3
 801202c:	2b02      	cmp	r3, #2
 801202e:	7663      	strb	r3, [r4, #25]
 8012030:	f240 80b1 	bls.w	8012196 <USBH_SetFeature+0x1ba>
        phost->Control.errorcount = 0U;
 8012034:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8012036:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 801203a:	2106      	movs	r1, #6
 801203c:	4620      	mov	r0, r4
 801203e:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8012040:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 8012042:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8012044:	4620      	mov	r0, r4
 8012046:	f000 fa41 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 801204a:	7921      	ldrb	r1, [r4, #4]
 801204c:	4620      	mov	r0, r4
 801204e:	f000 fa3d 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 8012052:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8012054:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8012056:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8012058:	70a3      	strb	r3, [r4, #2]
 801205a:	e7c8      	b.n	8011fee <USBH_SetFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 801205c:	7962      	ldrb	r2, [r4, #5]
 801205e:	f104 0110 	add.w	r1, r4, #16
 8012062:	4620      	mov	r0, r4
 8012064:	f000 f986 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8012068:	2302      	movs	r3, #2
 801206a:	2001      	movs	r0, #1
 801206c:	7623      	strb	r3, [r4, #24]
 801206e:	e7be      	b.n	8011fee <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8012070:	7961      	ldrb	r1, [r4, #5]
 8012072:	4620      	mov	r0, r4
 8012074:	f00f fd48 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8012078:	2801      	cmp	r0, #1
 801207a:	f000 8081 	beq.w	8012180 <USBH_SetFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 801207e:	2804      	cmp	r0, #4
 8012080:	d001      	beq.n	8012086 <USBH_SetFeature+0xaa>
 8012082:	2802      	cmp	r0, #2
 8012084:	d1b2      	bne.n	8011fec <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 8012086:	230b      	movs	r3, #11
 8012088:	2001      	movs	r0, #1
 801208a:	7623      	strb	r3, [r4, #24]
 801208c:	e7af      	b.n	8011fee <USBH_SetFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 801208e:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8012092:	4620      	mov	r0, r4
 8012094:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8012096:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8012098:	68a1      	ldr	r1, [r4, #8]
 801209a:	89a2      	ldrh	r2, [r4, #12]
 801209c:	f000 f992 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 80120a0:	2304      	movs	r3, #4
 80120a2:	2001      	movs	r0, #1
 80120a4:	7623      	strb	r3, [r4, #24]
 80120a6:	e7a2      	b.n	8011fee <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80120a8:	7921      	ldrb	r1, [r4, #4]
 80120aa:	4620      	mov	r0, r4
 80120ac:	f00f fd2c 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80120b0:	2801      	cmp	r0, #1
 80120b2:	d059      	beq.n	8012168 <USBH_SetFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
 80120b4:	2805      	cmp	r0, #5
 80120b6:	d039      	beq.n	801212c <USBH_SetFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
 80120b8:	2804      	cmp	r0, #4
 80120ba:	d197      	bne.n	8011fec <USBH_SetFeature+0x10>
 80120bc:	e7e3      	b.n	8012086 <USBH_SetFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 80120be:	2501      	movs	r5, #1
 80120c0:	7963      	ldrb	r3, [r4, #5]
 80120c2:	89a2      	ldrh	r2, [r4, #12]
 80120c4:	4620      	mov	r0, r4
 80120c6:	68a1      	ldr	r1, [r4, #8]
 80120c8:	9500      	str	r5, [sp, #0]
 80120ca:	f000 f963 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80120ce:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80120d2:	2306      	movs	r3, #6
 80120d4:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80120d6:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80120d8:	7623      	strb	r3, [r4, #24]
 80120da:	e788      	b.n	8011fee <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80120dc:	7961      	ldrb	r1, [r4, #5]
 80120de:	4620      	mov	r0, r4
 80120e0:	f00f fd12 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80120e4:	2801      	cmp	r0, #1
 80120e6:	d047      	beq.n	8012178 <USBH_SetFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 80120e8:	2805      	cmp	r0, #5
 80120ea:	d01f      	beq.n	801212c <USBH_SetFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 80120ec:	2802      	cmp	r0, #2
 80120ee:	d04e      	beq.n	801218e <USBH_SetFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 80120f0:	2804      	cmp	r0, #4
 80120f2:	f47f af7b 	bne.w	8011fec <USBH_SetFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 80120f6:	230b      	movs	r3, #11
 80120f8:	7623      	strb	r3, [r4, #24]
 80120fa:	e7ab      	b.n	8012054 <USBH_SetFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 80120fc:	2200      	movs	r2, #0
 80120fe:	7923      	ldrb	r3, [r4, #4]
 8012100:	4620      	mov	r0, r4
 8012102:	4611      	mov	r1, r2
 8012104:	f000 f95e 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8012108:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 801210c:	2308      	movs	r3, #8
 801210e:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 8012110:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 8012112:	7623      	strb	r3, [r4, #24]
 8012114:	e76b      	b.n	8011fee <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8012116:	7921      	ldrb	r1, [r4, #4]
 8012118:	4620      	mov	r0, r4
 801211a:	f00f fcf5 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801211e:	2801      	cmp	r0, #1
 8012120:	d026      	beq.n	8012170 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 8012122:	2804      	cmp	r0, #4
 8012124:	d0af      	beq.n	8012086 <USBH_SetFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
 8012126:	2805      	cmp	r0, #5
 8012128:	f47f af60 	bne.w	8011fec <USBH_SetFeature+0x10>
        status = USBH_NOT_SUPPORTED;
 801212c:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 801212e:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 8012130:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 8012132:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8012134:	7623      	strb	r3, [r4, #24]
}
 8012136:	b003      	add	sp, #12
 8012138:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 801213a:	2200      	movs	r2, #0
 801213c:	2501      	movs	r5, #1
 801213e:	7963      	ldrb	r3, [r4, #5]
 8012140:	4620      	mov	r0, r4
 8012142:	4611      	mov	r1, r2
 8012144:	9500      	str	r5, [sp, #0]
 8012146:	f000 f925 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801214a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801214e:	230a      	movs	r3, #10
 8012150:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 8012152:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8012154:	7623      	strb	r3, [r4, #24]
 8012156:	e74a      	b.n	8011fee <USBH_SetFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8012158:	7961      	ldrb	r1, [r4, #5]
 801215a:	4620      	mov	r0, r4
 801215c:	f00f fcd4 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8012160:	2801      	cmp	r0, #1
 8012162:	d005      	beq.n	8012170 <USBH_SetFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8012164:	2802      	cmp	r0, #2
 8012166:	d1a7      	bne.n	80120b8 <USBH_SetFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8012168:	2309      	movs	r3, #9
 801216a:	2001      	movs	r0, #1
 801216c:	7623      	strb	r3, [r4, #24]
 801216e:	e73e      	b.n	8011fee <USBH_SetFeature+0x12>
        status = USBH_OK;
 8012170:	2000      	movs	r0, #0
 8012172:	e7dc      	b.n	801212e <USBH_SetFeature+0x152>
          if (direction == USB_D2H)
 8012174:	2a00      	cmp	r2, #0
 8012176:	dbf7      	blt.n	8012168 <USBH_SetFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8012178:	2307      	movs	r3, #7
 801217a:	2001      	movs	r0, #1
 801217c:	7623      	strb	r3, [r4, #24]
 801217e:	e736      	b.n	8011fee <USBH_SetFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 8012180:	8ae3      	ldrh	r3, [r4, #22]
 8012182:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8012186:	2b00      	cmp	r3, #0
 8012188:	d0f4      	beq.n	8012174 <USBH_SetFeature+0x198>
          if (direction == USB_D2H)
 801218a:	2a00      	cmp	r2, #0
 801218c:	db08      	blt.n	80121a0 <USBH_SetFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 801218e:	2305      	movs	r3, #5
 8012190:	2001      	movs	r0, #1
 8012192:	7623      	strb	r3, [r4, #24]
 8012194:	e72b      	b.n	8011fee <USBH_SetFeature+0x12>
        phost->Control.state = CTRL_SETUP;
 8012196:	2301      	movs	r3, #1
 8012198:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 801219a:	4618      	mov	r0, r3
 801219c:	70a3      	strb	r3, [r4, #2]
 801219e:	e726      	b.n	8011fee <USBH_SetFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
 80121a0:	2303      	movs	r3, #3
 80121a2:	7623      	strb	r3, [r4, #24]
 80121a4:	e723      	b.n	8011fee <USBH_SetFeature+0x12>
 80121a6:	bf00      	nop

080121a8 <USBH_ClrFeature>:
{
 80121a8:	b530      	push	{r4, r5, lr}
 80121aa:	4603      	mov	r3, r0
  if (phost->RequestState == CMD_SEND)
 80121ac:	7880      	ldrb	r0, [r0, #2]
{
 80121ae:	b083      	sub	sp, #12
  if (phost->RequestState == CMD_SEND)
 80121b0:	2801      	cmp	r0, #1
 80121b2:	d011      	beq.n	80121d8 <USBH_ClrFeature+0x30>
  switch (phost->RequestState)
 80121b4:	2802      	cmp	r0, #2
 80121b6:	d002      	beq.n	80121be <USBH_ClrFeature+0x16>
  status = USBH_BUSY;
 80121b8:	2001      	movs	r0, #1
}
 80121ba:	b003      	add	sp, #12
 80121bc:	bd30      	pop	{r4, r5, pc}
 80121be:	461c      	mov	r4, r3
  switch (phost->Control.state)
 80121c0:	7e1b      	ldrb	r3, [r3, #24]
 80121c2:	3b01      	subs	r3, #1
 80121c4:	2b0a      	cmp	r3, #10
 80121c6:	d8f7      	bhi.n	80121b8 <USBH_ClrFeature+0x10>
 80121c8:	e8df f003 	tbb	[pc, r3]
 80121cc:	5447382e 	.word	0x5447382e
 80121d0:	8b7e6e5f 	.word	0x8b7e6e5f
 80121d4:	ac9d      	.short	0xac9d
 80121d6:	13          	.byte	0x13
 80121d7:	00          	.byte	0x00
    phost->Control.setup.b.wLength.w = 0U;
 80121d8:	2200      	movs	r2, #0
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 80121da:	f44f 7581 	mov.w	r5, #258	; 0x102
      phost->RequestState = CMD_WAIT;
 80121de:	2402      	movs	r4, #2
    phost->Control.setup.b.wIndex.w = ep_num;
 80121e0:	8299      	strh	r1, [r3, #20]
      phost->Control.state = CTRL_SETUP;
 80121e2:	7618      	strb	r0, [r3, #24]
    phost->Control.setup.b.bmRequestType = USB_H2D | USB_REQ_RECIPIENT_ENDPOINT
 80121e4:	611d      	str	r5, [r3, #16]
    phost->Control.setup.b.wLength.w = 0U;
 80121e6:	82da      	strh	r2, [r3, #22]
      phost->Control.buff = buff;
 80121e8:	609a      	str	r2, [r3, #8]
      phost->Control.length = length;
 80121ea:	819a      	strh	r2, [r3, #12]
      phost->RequestState = CMD_WAIT;
 80121ec:	709c      	strb	r4, [r3, #2]
}
 80121ee:	b003      	add	sp, #12
 80121f0:	bd30      	pop	{r4, r5, pc}
      if (++phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
 80121f2:	7e63      	ldrb	r3, [r4, #25]
 80121f4:	3301      	adds	r3, #1
 80121f6:	b2db      	uxtb	r3, r3
 80121f8:	2b02      	cmp	r3, #2
 80121fa:	7663      	strb	r3, [r4, #25]
 80121fc:	f240 80b1 	bls.w	8012362 <USBH_ClrFeature+0x1ba>
        phost->Control.errorcount = 0U;
 8012200:	2500      	movs	r5, #0
        phost->pUser(phost, HOST_USER_UNRECOVERED_ERROR);
 8012202:	f8d4 3544 	ldr.w	r3, [r4, #1348]	; 0x544
 8012206:	2106      	movs	r1, #6
 8012208:	4620      	mov	r0, r4
 801220a:	4798      	blx	r3
        USBH_FreePipe(phost, phost->Control.pipe_out);
 801220c:	7961      	ldrb	r1, [r4, #5]
        phost->Control.errorcount = 0U;
 801220e:	7665      	strb	r5, [r4, #25]
        USBH_FreePipe(phost, phost->Control.pipe_out);
 8012210:	4620      	mov	r0, r4
 8012212:	f000 f95b 	bl	80124cc <USBH_FreePipe>
        USBH_FreePipe(phost, phost->Control.pipe_in);
 8012216:	7921      	ldrb	r1, [r4, #4]
 8012218:	4620      	mov	r0, r4
 801221a:	f000 f957 	bl	80124cc <USBH_FreePipe>
        phost->gState = HOST_IDLE;
 801221e:	7025      	strb	r5, [r4, #0]
        phost->RequestState = CMD_SEND;
 8012220:	2301      	movs	r3, #1
      status = USBH_HandleControl(phost);
 8012222:	2002      	movs	r0, #2
        phost->RequestState = CMD_SEND;
 8012224:	70a3      	strb	r3, [r4, #2]
 8012226:	e7c8      	b.n	80121ba <USBH_ClrFeature+0x12>
      USBH_CtlSendSetup(phost, (uint8_t *)(void *)phost->Control.setup.d8,
 8012228:	7962      	ldrb	r2, [r4, #5]
 801222a:	f104 0110 	add.w	r1, r4, #16
 801222e:	4620      	mov	r0, r4
 8012230:	f000 f8a0 	bl	8012374 <USBH_CtlSendSetup>
      phost->Control.state = CTRL_SETUP_WAIT;
 8012234:	2302      	movs	r3, #2
 8012236:	2001      	movs	r0, #1
 8012238:	7623      	strb	r3, [r4, #24]
 801223a:	e7be      	b.n	80121ba <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 801223c:	7961      	ldrb	r1, [r4, #5]
 801223e:	4620      	mov	r0, r4
 8012240:	f00f fc62 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 8012244:	2801      	cmp	r0, #1
 8012246:	f000 8081 	beq.w	801234c <USBH_ClrFeature+0x1a4>
        if ((URB_Status == USBH_URB_ERROR) || (URB_Status == USBH_URB_NOTREADY))
 801224a:	2804      	cmp	r0, #4
 801224c:	d001      	beq.n	8012252 <USBH_ClrFeature+0xaa>
 801224e:	2802      	cmp	r0, #2
 8012250:	d1b2      	bne.n	80121b8 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 8012252:	230b      	movs	r3, #11
 8012254:	2001      	movs	r0, #1
 8012256:	7623      	strb	r3, [r4, #24]
 8012258:	e7af      	b.n	80121ba <USBH_ClrFeature+0x12>
      phost->Control.timer = (uint16_t)phost->Timer;
 801225a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 801225e:	4620      	mov	r0, r4
 8012260:	7923      	ldrb	r3, [r4, #4]
      phost->Control.timer = (uint16_t)phost->Timer;
 8012262:	81e2      	strh	r2, [r4, #14]
      USBH_CtlReceiveData(phost, phost->Control.buff, phost->Control.length,
 8012264:	68a1      	ldr	r1, [r4, #8]
 8012266:	89a2      	ldrh	r2, [r4, #12]
 8012268:	f000 f8ac 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.state = CTRL_DATA_IN_WAIT;
 801226c:	2304      	movs	r3, #4
 801226e:	2001      	movs	r0, #1
 8012270:	7623      	strb	r3, [r4, #24]
 8012272:	e7a2      	b.n	80121ba <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 8012274:	7921      	ldrb	r1, [r4, #4]
 8012276:	4620      	mov	r0, r4
 8012278:	f00f fc46 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801227c:	2801      	cmp	r0, #1
 801227e:	d059      	beq.n	8012334 <USBH_ClrFeature+0x18c>
      if (URB_Status == USBH_URB_STALL)
 8012280:	2805      	cmp	r0, #5
 8012282:	d039      	beq.n	80122f8 <USBH_ClrFeature+0x150>
        if (URB_Status == USBH_URB_ERROR)
 8012284:	2804      	cmp	r0, #4
 8012286:	d197      	bne.n	80121b8 <USBH_ClrFeature+0x10>
 8012288:	e7e3      	b.n	8012252 <USBH_ClrFeature+0xaa>
      USBH_CtlSendData(phost, phost->Control.buff, phost->Control.length,
 801228a:	2501      	movs	r5, #1
 801228c:	7963      	ldrb	r3, [r4, #5]
 801228e:	89a2      	ldrh	r2, [r4, #12]
 8012290:	4620      	mov	r0, r4
 8012292:	68a1      	ldr	r1, [r4, #8]
 8012294:	9500      	str	r5, [sp, #0]
 8012296:	f000 f87d 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 801229a:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 801229e:	2306      	movs	r3, #6
 80122a0:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 80122a2:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_DATA_OUT_WAIT;
 80122a4:	7623      	strb	r3, [r4, #24]
 80122a6:	e788      	b.n	80121ba <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 80122a8:	7961      	ldrb	r1, [r4, #5]
 80122aa:	4620      	mov	r0, r4
 80122ac:	f00f fc2c 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80122b0:	2801      	cmp	r0, #1
 80122b2:	d047      	beq.n	8012344 <USBH_ClrFeature+0x19c>
      else if (URB_Status == USBH_URB_STALL)
 80122b4:	2805      	cmp	r0, #5
 80122b6:	d01f      	beq.n	80122f8 <USBH_ClrFeature+0x150>
      else if (URB_Status == USBH_URB_NOTREADY)
 80122b8:	2802      	cmp	r0, #2
 80122ba:	d04e      	beq.n	801235a <USBH_ClrFeature+0x1b2>
        if (URB_Status == USBH_URB_ERROR)
 80122bc:	2804      	cmp	r0, #4
 80122be:	f47f af7b 	bne.w	80121b8 <USBH_ClrFeature+0x10>
          phost->Control.state = CTRL_ERROR;
 80122c2:	230b      	movs	r3, #11
 80122c4:	7623      	strb	r3, [r4, #24]
 80122c6:	e7ab      	b.n	8012220 <USBH_ClrFeature+0x78>
      USBH_CtlReceiveData(phost, 0U, 0U, phost->Control.pipe_in);
 80122c8:	2200      	movs	r2, #0
 80122ca:	7923      	ldrb	r3, [r4, #4]
 80122cc:	4620      	mov	r0, r4
 80122ce:	4611      	mov	r1, r2
 80122d0:	f000 f878 	bl	80123c4 <USBH_CtlReceiveData>
      phost->Control.timer = (uint16_t)phost->Timer;
 80122d4:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80122d8:	2308      	movs	r3, #8
 80122da:	2001      	movs	r0, #1
      phost->Control.timer = (uint16_t)phost->Timer;
 80122dc:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_IN_WAIT;
 80122de:	7623      	strb	r3, [r4, #24]
 80122e0:	e76b      	b.n	80121ba <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_in);
 80122e2:	7921      	ldrb	r1, [r4, #4]
 80122e4:	4620      	mov	r0, r4
 80122e6:	f00f fc0f 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 80122ea:	2801      	cmp	r0, #1
 80122ec:	d026      	beq.n	801233c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_ERROR)
 80122ee:	2804      	cmp	r0, #4
 80122f0:	d0af      	beq.n	8012252 <USBH_ClrFeature+0xaa>
        if (URB_Status == USBH_URB_STALL)
 80122f2:	2805      	cmp	r0, #5
 80122f4:	f47f af60 	bne.w	80121b8 <USBH_ClrFeature+0x10>
        status = USBH_NOT_SUPPORTED;
 80122f8:	2003      	movs	r0, #3
        phost->RequestState = CMD_SEND;
 80122fa:	2201      	movs	r2, #1
        phost->Control.state = CTRL_IDLE;
 80122fc:	2300      	movs	r3, #0
        phost->RequestState = CMD_SEND;
 80122fe:	70a2      	strb	r2, [r4, #2]
        phost->Control.state = CTRL_IDLE;
 8012300:	7623      	strb	r3, [r4, #24]
}
 8012302:	b003      	add	sp, #12
 8012304:	bd30      	pop	{r4, r5, pc}
      USBH_CtlSendData(phost, 0U, 0U, phost->Control.pipe_out, 1U);
 8012306:	2200      	movs	r2, #0
 8012308:	2501      	movs	r5, #1
 801230a:	7963      	ldrb	r3, [r4, #5]
 801230c:	4620      	mov	r0, r4
 801230e:	4611      	mov	r1, r2
 8012310:	9500      	str	r5, [sp, #0]
 8012312:	f000 f83f 	bl	8012394 <USBH_CtlSendData>
      phost->Control.timer = (uint16_t)phost->Timer;
 8012316:	f8d4 2534 	ldr.w	r2, [r4, #1332]	; 0x534
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 801231a:	230a      	movs	r3, #10
 801231c:	4628      	mov	r0, r5
      phost->Control.timer = (uint16_t)phost->Timer;
 801231e:	81e2      	strh	r2, [r4, #14]
      phost->Control.state = CTRL_STATUS_OUT_WAIT;
 8012320:	7623      	strb	r3, [r4, #24]
 8012322:	e74a      	b.n	80121ba <USBH_ClrFeature+0x12>
      URB_Status = USBH_LL_GetURBState(phost, phost->Control.pipe_out);
 8012324:	7961      	ldrb	r1, [r4, #5]
 8012326:	4620      	mov	r0, r4
 8012328:	f00f fbee 	bl	8021b08 <USBH_LL_GetURBState>
      if (URB_Status == USBH_URB_DONE)
 801232c:	2801      	cmp	r0, #1
 801232e:	d005      	beq.n	801233c <USBH_ClrFeature+0x194>
      else if (URB_Status == USBH_URB_NOTREADY)
 8012330:	2802      	cmp	r0, #2
 8012332:	d1a7      	bne.n	8012284 <USBH_ClrFeature+0xdc>
            phost->Control.state = CTRL_STATUS_OUT;
 8012334:	2309      	movs	r3, #9
 8012336:	2001      	movs	r0, #1
 8012338:	7623      	strb	r3, [r4, #24]
 801233a:	e73e      	b.n	80121ba <USBH_ClrFeature+0x12>
        status = USBH_OK;
 801233c:	2000      	movs	r0, #0
 801233e:	e7dc      	b.n	80122fa <USBH_ClrFeature+0x152>
          if (direction == USB_D2H)
 8012340:	2a00      	cmp	r2, #0
 8012342:	dbf7      	blt.n	8012334 <USBH_ClrFeature+0x18c>
            phost->Control.state = CTRL_STATUS_IN;
 8012344:	2307      	movs	r3, #7
 8012346:	2001      	movs	r0, #1
 8012348:	7623      	strb	r3, [r4, #24]
 801234a:	e736      	b.n	80121ba <USBH_ClrFeature+0x12>
        if (phost->Control.setup.b.wLength.w != 0U)
 801234c:	8ae3      	ldrh	r3, [r4, #22]
 801234e:	f994 2010 	ldrsb.w	r2, [r4, #16]
 8012352:	2b00      	cmp	r3, #0
 8012354:	d0f4      	beq.n	8012340 <USBH_ClrFeature+0x198>
          if (direction == USB_D2H)
 8012356:	2a00      	cmp	r2, #0
 8012358:	db08      	blt.n	801236c <USBH_ClrFeature+0x1c4>
            phost->Control.state = CTRL_DATA_OUT;
 801235a:	2305      	movs	r3, #5
 801235c:	2001      	movs	r0, #1
 801235e:	7623      	strb	r3, [r4, #24]
 8012360:	e72b      	b.n	80121ba <USBH_ClrFeature+0x12>
        phost->Control.state = CTRL_SETUP;
 8012362:	2301      	movs	r3, #1
 8012364:	7623      	strb	r3, [r4, #24]
        phost->RequestState = CMD_SEND;
 8012366:	4618      	mov	r0, r3
 8012368:	70a3      	strb	r3, [r4, #2]
 801236a:	e726      	b.n	80121ba <USBH_ClrFeature+0x12>
            phost->Control.state = CTRL_DATA_IN;
 801236c:	2303      	movs	r3, #3
 801236e:	7623      	strb	r3, [r4, #24]
 8012370:	e723      	b.n	80121ba <USBH_ClrFeature+0x12>
 8012372:	bf00      	nop

08012374 <USBH_CtlSendSetup>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_CtlSendSetup(USBH_HandleTypeDef *phost,
                                     uint8_t *buff,
                                     uint8_t pipe_num)
{
 8012374:	b530      	push	{r4, r5, lr}

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 8012376:	2400      	movs	r4, #0
{
 8012378:	b085      	sub	sp, #20
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 801237a:	2508      	movs	r5, #8
 801237c:	9101      	str	r1, [sp, #4]
 801237e:	4623      	mov	r3, r4
 8012380:	4611      	mov	r1, r2
 8012382:	9403      	str	r4, [sp, #12]
 8012384:	9400      	str	r4, [sp, #0]
 8012386:	4622      	mov	r2, r4
 8012388:	9502      	str	r5, [sp, #8]
 801238a:	f00f fb9f 	bl	8021acc <USBH_LL_SubmitURB>
                    USBH_PID_SETUP,       /* Type setup       */
                    buff,                 /* data buffer      */
                    USBH_SETUP_PKT_SIZE,  /* data length      */
                    0U);
  return USBH_OK;
}
 801238e:	4620      	mov	r0, r4
 8012390:	b005      	add	sp, #20
 8012392:	bd30      	pop	{r4, r5, pc}

08012394 <USBH_CtlSendData>:
USBH_StatusTypeDef USBH_CtlSendData(USBH_HandleTypeDef *phost,
                                    uint8_t *buff,
                                    uint16_t length,
                                    uint8_t pipe_num,
                                    uint8_t do_ping)
{
 8012394:	b570      	push	{r4, r5, r6, lr}
  if (phost->device.speed != USBH_SPEED_HIGH)
 8012396:	f890 631d 	ldrb.w	r6, [r0, #797]	; 0x31d
{
 801239a:	b084      	sub	sp, #16
 801239c:	461d      	mov	r5, r3
  {
    do_ping = 0U;
  }

  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 801239e:	2300      	movs	r3, #0
  if (phost->device.speed != USBH_SPEED_HIGH)
 80123a0:	2e00      	cmp	r6, #0
{
 80123a2:	f89d 4020 	ldrb.w	r4, [sp, #32]
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80123a6:	f04f 0601 	mov.w	r6, #1
 80123aa:	9202      	str	r2, [sp, #8]
    do_ping = 0U;
 80123ac:	bf18      	it	ne
 80123ae:	461c      	movne	r4, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80123b0:	461a      	mov	r2, r3
 80123b2:	e9cd 6100 	strd	r6, r1, [sp]
 80123b6:	9403      	str	r4, [sp, #12]
 80123b8:	4629      	mov	r1, r5
 80123ba:	f00f fb87 	bl	8021acc <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    do_ping);             /* do ping (HS Only)*/

  return USBH_OK;
}
 80123be:	2000      	movs	r0, #0
 80123c0:	b004      	add	sp, #16
 80123c2:	bd70      	pop	{r4, r5, r6, pc}

080123c4 <USBH_CtlReceiveData>:
  */
USBH_StatusTypeDef USBH_CtlReceiveData(USBH_HandleTypeDef *phost,
                                       uint8_t *buff,
                                       uint16_t length,
                                       uint8_t pipe_num)
{
 80123c4:	b570      	push	{r4, r5, r6, lr}
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80123c6:	2400      	movs	r4, #0
{
 80123c8:	b084      	sub	sp, #16
 80123ca:	461e      	mov	r6, r3
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80123cc:	2501      	movs	r5, #1
 80123ce:	4623      	mov	r3, r4
 80123d0:	9403      	str	r4, [sp, #12]
 80123d2:	9500      	str	r5, [sp, #0]
 80123d4:	e9cd 1201 	strd	r1, r2, [sp, #4]
 80123d8:	4631      	mov	r1, r6
 80123da:	462a      	mov	r2, r5
 80123dc:	f00f fb76 	bl	8021acc <USBH_LL_SubmitURB>
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;

}
 80123e0:	4620      	mov	r0, r4
 80123e2:	b004      	add	sp, #16
 80123e4:	bd70      	pop	{r4, r5, r6, pc}
 80123e6:	bf00      	nop

080123e8 <USBH_BulkReceiveData>:
  */
USBH_StatusTypeDef USBH_BulkReceiveData(USBH_HandleTypeDef *phost,
                                        uint8_t *buff,
                                        uint16_t length,
                                        uint8_t pipe_num)
{
 80123e8:	b570      	push	{r4, r5, r6, lr}
 80123ea:	461e      	mov	r6, r3
 80123ec:	b084      	sub	sp, #16
  USBH_LL_SubmitURB(phost,                      /* Driver handle    */
 80123ee:	2400      	movs	r4, #0
 80123f0:	2501      	movs	r5, #1
 80123f2:	2302      	movs	r3, #2
 80123f4:	9403      	str	r4, [sp, #12]
 80123f6:	9500      	str	r5, [sp, #0]
 80123f8:	e9cd 1201 	strd	r1, r2, [sp, #4]
 80123fc:	4631      	mov	r1, r6
 80123fe:	462a      	mov	r2, r5
 8012400:	f00f fb64 	bl	8021acc <USBH_LL_SubmitURB>
                    USBH_PID_DATA,        /* Type Data        */
                    buff,                 /* data buffer      */
                    length,               /* data length      */
                    0U);
  return USBH_OK;
}
 8012404:	4620      	mov	r0, r4
 8012406:	b004      	add	sp, #16
 8012408:	bd70      	pop	{r4, r5, r6, pc}
 801240a:	bf00      	nop

0801240c <USBH_OpenPipe>:
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num,
                                 uint8_t epnum, uint8_t dev_address,
                                 uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 801240c:	b530      	push	{r4, r5, lr}
 801240e:	b085      	sub	sp, #20
 8012410:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8012414:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 8012418:	9400      	str	r4, [sp, #0]
{
 801241a:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  USBH_LL_OpenPipe(phost, pipe_num, epnum, dev_address, speed, ep_type, mps);
 801241e:	e9cd 5401 	strd	r5, r4, [sp, #4]
 8012422:	f00f fb27 	bl	8021a74 <USBH_LL_OpenPipe>

  return USBH_OK;
}
 8012426:	2000      	movs	r0, #0
 8012428:	b005      	add	sp, #20
 801242a:	bd30      	pop	{r4, r5, pc}

0801242c <USBH_ClosePipe>:
  * @param  phost: Host Handle
  * @param  pipe_num: Pipe Number
  * @retval USBH Status
  */
USBH_StatusTypeDef USBH_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe_num)
{
 801242c:	b508      	push	{r3, lr}
  USBH_LL_ClosePipe(phost, pipe_num);
 801242e:	f00f fb3d 	bl	8021aac <USBH_LL_ClosePipe>

  return USBH_OK;
}
 8012432:	2000      	movs	r0, #0
 8012434:	bd08      	pop	{r3, pc}
 8012436:	bf00      	nop

08012438 <USBH_AllocPipe>:
  * @param  phost: Host Handle
  * @param  ep_addr: End point for which the Pipe to be allocated
  * @retval Pipe number
  */
uint8_t USBH_AllocPipe(USBH_HandleTypeDef *phost, uint8_t ep_addr)
{
 8012438:	4603      	mov	r3, r0
{
  uint8_t idx = 0U;

  for (idx = 0U ; idx < 11U ; idx++)
  {
    if ((phost->Pipes[idx] & 0x8000U) == 0U)
 801243a:	f8d0 04f4 	ldr.w	r0, [r0, #1268]	; 0x4f4
 801243e:	f410 4000 	ands.w	r0, r0, #32768	; 0x8000
 8012442:	d02a      	beq.n	801249a <USBH_AllocPipe+0x62>
 8012444:	f8d3 24f8 	ldr.w	r2, [r3, #1272]	; 0x4f8
 8012448:	0410      	lsls	r0, r2, #16
 801244a:	d52d      	bpl.n	80124a8 <USBH_AllocPipe+0x70>
 801244c:	f8d3 24fc 	ldr.w	r2, [r3, #1276]	; 0x4fc
 8012450:	0412      	lsls	r2, r2, #16
 8012452:	d52b      	bpl.n	80124ac <USBH_AllocPipe+0x74>
 8012454:	f8d3 2500 	ldr.w	r2, [r3, #1280]	; 0x500
 8012458:	0410      	lsls	r0, r2, #16
 801245a:	d529      	bpl.n	80124b0 <USBH_AllocPipe+0x78>
 801245c:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
 8012460:	0412      	lsls	r2, r2, #16
 8012462:	d527      	bpl.n	80124b4 <USBH_AllocPipe+0x7c>
 8012464:	f8d3 2508 	ldr.w	r2, [r3, #1288]	; 0x508
 8012468:	0410      	lsls	r0, r2, #16
 801246a:	d525      	bpl.n	80124b8 <USBH_AllocPipe+0x80>
 801246c:	f8d3 250c 	ldr.w	r2, [r3, #1292]	; 0x50c
 8012470:	0412      	lsls	r2, r2, #16
 8012472:	d525      	bpl.n	80124c0 <USBH_AllocPipe+0x88>
 8012474:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
 8012478:	0410      	lsls	r0, r2, #16
 801247a:	d523      	bpl.n	80124c4 <USBH_AllocPipe+0x8c>
 801247c:	f8d3 2514 	ldr.w	r2, [r3, #1300]	; 0x514
 8012480:	0412      	lsls	r2, r2, #16
 8012482:	d51b      	bpl.n	80124bc <USBH_AllocPipe+0x84>
 8012484:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 8012488:	0410      	lsls	r0, r2, #16
 801248a:	d505      	bpl.n	8012498 <USBH_AllocPipe+0x60>
 801248c:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
 8012490:	0412      	lsls	r2, r2, #16
 8012492:	d519      	bpl.n	80124c8 <USBH_AllocPipe+0x90>
 8012494:	20ff      	movs	r0, #255	; 0xff
}
 8012496:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
 8012498:	2009      	movs	r0, #9
    phost->Pipes[pipe & 0xFU] = 0x8000U | ep_addr;
 801249a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 801249e:	f441 4100 	orr.w	r1, r1, #32768	; 0x8000
 80124a2:	f8c3 14f4 	str.w	r1, [r3, #1268]	; 0x4f4
 80124a6:	4770      	bx	lr
  for (idx = 0U ; idx < 11U ; idx++)
 80124a8:	2001      	movs	r0, #1
 80124aa:	e7f6      	b.n	801249a <USBH_AllocPipe+0x62>
 80124ac:	2002      	movs	r0, #2
 80124ae:	e7f4      	b.n	801249a <USBH_AllocPipe+0x62>
 80124b0:	2003      	movs	r0, #3
 80124b2:	e7f2      	b.n	801249a <USBH_AllocPipe+0x62>
 80124b4:	2004      	movs	r0, #4
 80124b6:	e7f0      	b.n	801249a <USBH_AllocPipe+0x62>
 80124b8:	2005      	movs	r0, #5
 80124ba:	e7ee      	b.n	801249a <USBH_AllocPipe+0x62>
 80124bc:	2008      	movs	r0, #8
 80124be:	e7ec      	b.n	801249a <USBH_AllocPipe+0x62>
 80124c0:	2006      	movs	r0, #6
 80124c2:	e7ea      	b.n	801249a <USBH_AllocPipe+0x62>
 80124c4:	2007      	movs	r0, #7
 80124c6:	e7e8      	b.n	801249a <USBH_AllocPipe+0x62>
 80124c8:	200a      	movs	r0, #10
 80124ca:	e7e6      	b.n	801249a <USBH_AllocPipe+0x62>

080124cc <USBH_FreePipe>:
  if (idx < 11U)
 80124cc:	290a      	cmp	r1, #10
 80124ce:	d807      	bhi.n	80124e0 <USBH_FreePipe+0x14>
 80124d0:	eb00 0081 	add.w	r0, r0, r1, lsl #2
    phost->Pipes[idx] &= 0x7FFFU;
 80124d4:	f8d0 34f4 	ldr.w	r3, [r0, #1268]	; 0x4f4
 80124d8:	f3c3 030e 	ubfx	r3, r3, #0, #15
 80124dc:	f8c0 34f4 	str.w	r3, [r0, #1268]	; 0x4f4
}
 80124e0:	2000      	movs	r0, #0
 80124e2:	4770      	bx	lr

080124e4 <FATFS_LinkDriver>:
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 80124e4:	f240 43c0 	movw	r3, #1216	; 0x4c0
 80124e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80124ec:	7a5a      	ldrb	r2, [r3, #9]
 80124ee:	b10a      	cbz	r2, 80124f4 <FATFS_LinkDriver+0x10>
  uint8_t ret = 1;
 80124f0:	2001      	movs	r0, #1
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
}
 80124f2:	4770      	bx	lr
{
 80124f4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80124f6:	f002 04ff 	and.w	r4, r2, #255	; 0xff
    disk.is_initialized[disk.nbr] = 0;
 80124fa:	f893 e009 	ldrb.w	lr, [r3, #9]
    disk.drv[disk.nbr] = drv;
 80124fe:	7a5e      	ldrb	r6, [r3, #9]
    path[1] = ':';
 8012500:	f04f 0c3a 	mov.w	ip, #58	; 0x3a
    disk.lun[disk.nbr] = lun;
 8012504:	7a5d      	ldrb	r5, [r3, #9]
    path[2] = '/';
 8012506:	272f      	movs	r7, #47	; 0x2f
    DiskNum = disk.nbr++;
 8012508:	7a5a      	ldrb	r2, [r3, #9]
    disk.drv[disk.nbr] = drv;
 801250a:	eb03 0686 	add.w	r6, r3, r6, lsl #2
    disk.lun[disk.nbr] = lun;
 801250e:	441d      	add	r5, r3
    disk.is_initialized[disk.nbr] = 0;
 8012510:	f803 400e 	strb.w	r4, [r3, lr]
    DiskNum = disk.nbr++;
 8012514:	b2d2      	uxtb	r2, r2
    disk.drv[disk.nbr] = drv;
 8012516:	6070      	str	r0, [r6, #4]
    disk.lun[disk.nbr] = lun;
 8012518:	722c      	strb	r4, [r5, #8]
    DiskNum = disk.nbr++;
 801251a:	1c50      	adds	r0, r2, #1
    path[0] = DiskNum + '0';
 801251c:	3230      	adds	r2, #48	; 0x30
    DiskNum = disk.nbr++;
 801251e:	b2c0      	uxtb	r0, r0
 8012520:	7258      	strb	r0, [r3, #9]
    path[3] = 0;
 8012522:	4620      	mov	r0, r4
    path[0] = DiskNum + '0';
 8012524:	700a      	strb	r2, [r1, #0]
    path[3] = 0;
 8012526:	70cc      	strb	r4, [r1, #3]
    path[1] = ':';
 8012528:	f881 c001 	strb.w	ip, [r1, #1]
    path[2] = '/';
 801252c:	708f      	strb	r7, [r1, #2]
}
 801252e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08012530 <MIDI_Application>:
 * @brief  Main routine for MIDI application, looped in main.c
 * @param  None
 * @retval none
 */
void MIDI_Application(void)
{
 8012530:	b510      	push	{r4, lr}
	if(Appli_state == APPLICATION_READY)
 8012532:	f240 6458 	movw	r4, #1624	; 0x658
 8012536:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801253a:	7823      	ldrb	r3, [r4, #0]
 801253c:	2b02      	cmp	r3, #2
 801253e:	d019      	beq.n	8012574 <MIDI_Application+0x44>
	if(Appli_state == APPLICATION_RUNNING)
	{
			//....pffff......grrrrr......
	}

	if(Appli_state == APPLICATION_DISCONNECT)
 8012540:	2b04      	cmp	r3, #4
 8012542:	d000      	beq.n	8012546 <MIDI_Application+0x16>
		HAL_Delay(10);
		MX_USB_HOST_Init();

	}

}
 8012544:	bd10      	pop	{r4, pc}
		Appli_state = APPLICATION_IDLE;
 8012546:	2300      	movs	r3, #0
		setLED_USB(0);
 8012548:	4618      	mov	r0, r3
		Appli_state = APPLICATION_IDLE;
 801254a:	7023      	strb	r3, [r4, #0]
		setLED_USB(0);
 801254c:	f003 f99e 	bl	801588c <setLED_USB>
		USBH_MIDI_Stop(&hUsbHostFS);
 8012550:	f241 00a0 	movw	r0, #4256	; 0x10a0
 8012554:	f2c3 0000 	movt	r0, #12288	; 0x3000
 8012558:	f00f f994 	bl	8021884 <USBH_MIDI_Stop>
		HAL_Delay(10);
 801255c:	200a      	movs	r0, #10
 801255e:	f7ee fa73 	bl	8000a48 <HAL_Delay>
		MX_USB_HOST_DeInit();
 8012562:	f00f f80b 	bl	802157c <MX_USB_HOST_DeInit>
		HAL_Delay(10);
 8012566:	200a      	movs	r0, #10
 8012568:	f7ee fa6e 	bl	8000a48 <HAL_Delay>
}
 801256c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		MX_USB_HOST_Init();
 8012570:	f00e bfd8 	b.w	8021524 <MX_USB_HOST_Init>
		USBH_MIDI_Receive(&hUsbHostFS, MIDI_RX_Buffer[MIDI_write_buffer], RX_BUFF_SIZE); // just once at the beginning, start the first reception
 8012574:	f240 0108 	movw	r1, #8
 8012578:	f240 0300 	movw	r3, #0
 801257c:	f241 00a0 	movw	r0, #4256	; 0x10a0
 8012580:	2240      	movs	r2, #64	; 0x40
 8012582:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8012586:	f2c3 0300 	movt	r3, #12288	; 0x3000
 801258a:	f2c3 0000 	movt	r0, #12288	; 0x3000
 801258e:	7809      	ldrb	r1, [r1, #0]
 8012590:	eb03 1181 	add.w	r1, r3, r1, lsl #6
 8012594:	f00f f98c 	bl	80218b0 <USBH_MIDI_Receive>
		Appli_state = APPLICATION_RUNNING;
 8012598:	2303      	movs	r3, #3
		setLED_USB(1);
 801259a:	2001      	movs	r0, #1
		Appli_state = APPLICATION_RUNNING;
 801259c:	7023      	strb	r3, [r4, #0]
		setLED_USB(1);
 801259e:	f003 f975 	bl	801588c <setLED_USB>
 80125a2:	7823      	ldrb	r3, [r4, #0]
 80125a4:	e7cc      	b.n	8012540 <MIDI_Application+0x10>
 80125a6:	bf00      	nop

080125a8 <ProcessReceivedMidiDatas>:

}
volatile testInt = 0;
/*-----------------------------------------------------------------------------*/
void ProcessReceivedMidiDatas(void)
{
 80125a8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80125ac:	f240 645a 	movw	r4, #1626	; 0x65a
 80125b0:	f240 675c 	movw	r7, #1628	; 0x65c
	uint8_t miniBufferPosition = 0;
	uint8_t processed = 0;
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 80125b4:	f240 6859 	movw	r8, #1625	; 0x659
			(processed < 32)) // maximum notes to process in a frame * 4
	{

		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 80125b8:	f249 09dc 	movw	r9, #37084	; 0x90dc
 80125bc:	f240 7608 	movw	r6, #1800	; 0x708
 80125c0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80125c4:	f2c2 0700 	movt	r7, #8192	; 0x2000
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 80125c8:	f2c2 0800 	movt	r8, #8192	; 0x2000
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 80125cc:	f2c2 0901 	movt	r9, #8193	; 0x2001
 80125d0:	f2c2 0600 	movt	r6, #8192	; 0x2000
	uint8_t processed = 0;
 80125d4:	2500      	movs	r5, #0
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 80125d6:	e008      	b.n	80125ea <ProcessReceivedMidiDatas+0x42>
		myUSB_FIFO_readPointer++;
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
		{
			parse_MIDI_Message();
		}
		if (myUSB_FIFO_readPointer >= USB_FIFO_SIZE)
 80125d8:	8823      	ldrh	r3, [r4, #0]
 80125da:	2bff      	cmp	r3, #255	; 0xff
 80125dc:	d903      	bls.n	80125e6 <ProcessReceivedMidiDatas+0x3e>
		{
			myUSB_FIFO_overflowBit = 0;
 80125de:	2300      	movs	r3, #0
 80125e0:	f888 3000 	strb.w	r3, [r8]
			myUSB_FIFO_readPointer = 0;
 80125e4:	8023      	strh	r3, [r4, #0]
		}
		processed++;
 80125e6:	3501      	adds	r5, #1
 80125e8:	b2ed      	uxtb	r5, r5
	while (((myUSB_FIFO_writePointer > myUSB_FIFO_readPointer) || (myUSB_FIFO_overflowBit)) &&
 80125ea:	883b      	ldrh	r3, [r7, #0]
 80125ec:	8822      	ldrh	r2, [r4, #0]
 80125ee:	429a      	cmp	r2, r3
 80125f0:	d303      	bcc.n	80125fa <ProcessReceivedMidiDatas+0x52>
 80125f2:	f898 3000 	ldrb.w	r3, [r8]
 80125f6:	2b00      	cmp	r3, #0
 80125f8:	d069      	beq.n	80126ce <ProcessReceivedMidiDatas+0x126>
 80125fa:	2d20      	cmp	r5, #32
 80125fc:	d06b      	beq.n	80126d6 <ProcessReceivedMidiDatas+0x12e>
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
 80125fe:	8822      	ldrh	r2, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 8012600:	8823      	ldrh	r3, [r4, #0]
		miniBufferPosition = (myUSB_FIFO_readPointer % 4);
 8012602:	f002 0203 	and.w	r2, r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 8012606:	b29b      	uxth	r3, r3
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
 8012608:	2a03      	cmp	r2, #3
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 801260a:	f819 1003 	ldrb.w	r1, [r9, r3]
		myUSB_FIFO_readPointer++;
 801260e:	8823      	ldrh	r3, [r4, #0]
		USB_message[miniBufferPosition] = myUSB_FIFO[myUSB_FIFO_readPointer];
 8012610:	54b1      	strb	r1, [r6, r2]
		myUSB_FIFO_readPointer++;
 8012612:	f103 0301 	add.w	r3, r3, #1
 8012616:	b29b      	uxth	r3, r3
 8012618:	8023      	strh	r3, [r4, #0]
		if (miniBufferPosition == 3) //we must have reached the end of a 4-byte message
 801261a:	d1dd      	bne.n	80125d8 <ProcessReceivedMidiDatas+0x30>
	switch(USB_message[1])
 801261c:	7873      	ldrb	r3, [r6, #1]
 801261e:	2b90      	cmp	r3, #144	; 0x90
 8012620:	d020      	beq.n	8012664 <ProcessReceivedMidiDatas+0xbc>
 8012622:	d90a      	bls.n	801263a <ProcessReceivedMidiDatas+0x92>
 8012624:	2bb0      	cmp	r3, #176	; 0xb0
 8012626:	d030      	beq.n	801268a <ProcessReceivedMidiDatas+0xe2>
 8012628:	2be0      	cmp	r3, #224	; 0xe0
 801262a:	d1d5      	bne.n	80125d8 <ProcessReceivedMidiDatas+0x30>
			pitchBend((USB_message[2]) + (USB_message[3] << 7));
 801262c:	78f0      	ldrb	r0, [r6, #3]
 801262e:	78b3      	ldrb	r3, [r6, #2]
 8012630:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
 8012634:	f00c fb9a 	bl	801ed6c <pitchBend>
 8012638:	e7ce      	b.n	80125d8 <ProcessReceivedMidiDatas+0x30>
	switch(USB_message[1])
 801263a:	2b80      	cmp	r3, #128	; 0x80
 801263c:	d1cc      	bne.n	80125d8 <ProcessReceivedMidiDatas+0x30>
			key = USB_message[2];
 801263e:	f240 720c 	movw	r2, #1804	; 0x70c
			velocity = USB_message[3];
 8012642:	f240 7304 	movw	r3, #1796	; 0x704
			key = USB_message[2];
 8012646:	78b1      	ldrb	r1, [r6, #2]
			velocity = USB_message[3];
 8012648:	f896 c003 	ldrb.w	ip, [r6, #3]
			key = USB_message[2];
 801264c:	f2c2 0200 	movt	r2, #8192	; 0x2000
			velocity = USB_message[3];
 8012650:	f2c2 0300 	movt	r3, #8192	; 0x2000
			noteOff(key, velocity);
 8012654:	4608      	mov	r0, r1
			key = USB_message[2];
 8012656:	7011      	strb	r1, [r2, #0]
			noteOff(key, velocity);
 8012658:	4661      	mov	r1, ip
			velocity = USB_message[3];
 801265a:	f883 c000 	strb.w	ip, [r3]
			noteOff(key, velocity);
 801265e:	f00c f973 	bl	801e948 <noteOff>
 8012662:	e7b9      	b.n	80125d8 <ProcessReceivedMidiDatas+0x30>
			key = USB_message[2];
 8012664:	f240 720c 	movw	r2, #1804	; 0x70c
			velocity = USB_message[3];
 8012668:	f240 7304 	movw	r3, #1796	; 0x704
			key = USB_message[2];
 801266c:	78b1      	ldrb	r1, [r6, #2]
			velocity = USB_message[3];
 801266e:	f896 c003 	ldrb.w	ip, [r6, #3]
			key = USB_message[2];
 8012672:	f2c2 0200 	movt	r2, #8192	; 0x2000
			velocity = USB_message[3];
 8012676:	f2c2 0300 	movt	r3, #8192	; 0x2000
			noteOn(key, velocity);
 801267a:	4608      	mov	r0, r1
			key = USB_message[2];
 801267c:	7011      	strb	r1, [r2, #0]
			noteOn(key, velocity);
 801267e:	4661      	mov	r1, ip
			velocity = USB_message[3];
 8012680:	f883 c000 	strb.w	ip, [r3]
			noteOn(key, velocity);
 8012684:	f00c fa3c 	bl	801eb00 <noteOn>
 8012688:	e7a6      	b.n	80125d8 <ProcessReceivedMidiDatas+0x30>
			ctrl = USB_message[2];
 801268a:	78b3      	ldrb	r3, [r6, #2]
 801268c:	f240 6081 	movw	r0, #1665	; 0x681
			CCs[ctrl] = data;
 8012690:	f240 6184 	movw	r1, #1668	; 0x684
			data = USB_message[3];
 8012694:	f240 7205 	movw	r2, #1797	; 0x705
 8012698:	f896 c003 	ldrb.w	ip, [r6, #3]
			ctrl = USB_message[2];
 801269c:	f2c2 0000 	movt	r0, #8192	; 0x2000
			CCs[ctrl] = data;
 80126a0:	f2c2 0100 	movt	r1, #8192	; 0x2000
			data = USB_message[3];
 80126a4:	f2c2 0200 	movt	r2, #8192	; 0x2000
			switch(ctrl)
 80126a8:	2b40      	cmp	r3, #64	; 0x40
			ctrl = USB_message[2];
 80126aa:	7003      	strb	r3, [r0, #0]
			CCs[ctrl] = data;
 80126ac:	f801 c003 	strb.w	ip, [r1, r3]
			data = USB_message[3];
 80126b0:	f882 c000 	strb.w	ip, [r2]
			switch(ctrl)
 80126b4:	d190      	bne.n	80125d8 <ProcessReceivedMidiDatas+0x30>
 80126b6:	f240 6380 	movw	r3, #1664	; 0x680
 80126ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80126be:	781b      	ldrb	r3, [r3, #0]
					if (data)
 80126c0:	f1bc 0f00 	cmp.w	ip, #0
 80126c4:	d00f      	beq.n	80126e6 <ProcessReceivedMidiDatas+0x13e>
						if (sustainInverted) 	sustainOff();
 80126c6:	b183      	cbz	r3, 80126ea <ProcessReceivedMidiDatas+0x142>
 80126c8:	f00c fb5e 	bl	801ed88 <sustainOff>
 80126cc:	e784      	b.n	80125d8 <ProcessReceivedMidiDatas+0x30>
	}
	if (processed >= 32)
 80126ce:	2d20      	cmp	r5, #32
 80126d0:	d001      	beq.n	80126d6 <ProcessReceivedMidiDatas+0x12e>
	{
		testInt = 1;
	}
}
 80126d2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		testInt = 1;
 80126d6:	f240 43d0 	movw	r3, #1232	; 0x4d0
 80126da:	2201      	movs	r2, #1
 80126dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80126e0:	601a      	str	r2, [r3, #0]
}
 80126e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
						if (sustainInverted) 	sustainOn();
 80126e6:	2b00      	cmp	r3, #0
 80126e8:	d0ee      	beq.n	80126c8 <ProcessReceivedMidiDatas+0x120>
						else					sustainOn();
 80126ea:	f00c fb4f 	bl	801ed8c <sustainOn>
 80126ee:	e773      	b.n	80125d8 <ProcessReceivedMidiDatas+0x30>

080126f0 <MX_ADC1_Init>:
  ADC_MultiModeTypeDef multimode = {0};
  ADC_ChannelConfTypeDef sConfig = {0};

  /** Common config 
  */
  hadc1.Instance = ADC1;
 80126f0:	f240 7310 	movw	r3, #1808	; 0x710
 80126f4:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
 80126f8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.NbrOfConversion = 6;
 80126fc:	2106      	movs	r1, #6
  hadc1.Instance = ADC1;
 80126fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012702:	f2c4 0202 	movt	r2, #16386	; 0x4002
{
 8012706:	b570      	push	{r4, r5, r6, lr}
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
  hadc1.Init.OversamplingMode = ENABLE;
  hadc1.Init.Oversampling.Ratio = 64;
 8012708:	2440      	movs	r4, #64	; 0x40
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV4;
 801270a:	6058      	str	r0, [r3, #4]
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
 801270c:	20c0      	movs	r0, #192	; 0xc0
{
 801270e:	b08a      	sub	sp, #40	; 0x28
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 8012710:	2608      	movs	r6, #8
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 8012712:	2503      	movs	r5, #3
  hadc1.Instance = ADC1;
 8012714:	601a      	str	r2, [r3, #0]
  ADC_MultiModeTypeDef multimode = {0};
 8012716:	2200      	movs	r2, #0
  hadc1.Init.NbrOfConversion = 6;
 8012718:	6199      	str	r1, [r3, #24]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 801271a:	2101      	movs	r1, #1
  hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 801271c:	611e      	str	r6, [r3, #16]
  hadc1.Init.ConversionDataManagement = ADC_CONVERSIONDATA_DMA_CIRCULAR;
 801271e:	62dd      	str	r5, [r3, #44]	; 0x2c
  hadc1.Init.Resolution = ADC_RESOLUTION_16B;
 8012720:	609a      	str	r2, [r3, #8]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8012722:	751a      	strb	r2, [r3, #20]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 8012724:	771a      	strb	r2, [r3, #28]
  hadc1.Init.Oversampling.TriggeredMode = ADC_TRIGGEREDMODE_SINGLE_TRIGGER;
 8012726:	645a      	str	r2, [r3, #68]	; 0x44
  ADC_MultiModeTypeDef multimode = {0};
 8012728:	9200      	str	r2, [sp, #0]
  ADC_ChannelConfTypeDef sConfig = {0};
 801272a:	9203      	str	r2, [sp, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
 801272c:	60d9      	str	r1, [r3, #12]
  hadc1.Init.ContinuousConvMode = ENABLE;
 801272e:	7559      	strb	r1, [r3, #21]
  hadc1.Init.OversamplingMode = ENABLE;
 8012730:	f883 1038 	strb.w	r1, [r3, #56]	; 0x38
  hadc1.Init.Oversampling.OversamplingStopReset = ADC_REGOVERSAMPLING_CONTINUED_MODE;
 8012734:	6499      	str	r1, [r3, #72]	; 0x48
  hadc1.Init.Oversampling.RightBitShift = ADC_RIGHTBITSHIFT_6;
 8012736:	e9c3 400f 	strd	r4, r0, [r3, #60]	; 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 801273a:	4618      	mov	r0, r3
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 801273c:	e9c3 2209 	strd	r2, r2, [r3, #36]	; 0x24
  hadc1.Init.LeftBitShift = ADC_LEFTBITSHIFT_NONE;
 8012740:	e9c3 220c 	strd	r2, r2, [r3, #48]	; 0x30
  ADC_MultiModeTypeDef multimode = {0};
 8012744:	e9cd 2201 	strd	r2, r2, [sp, #4]
  ADC_ChannelConfTypeDef sConfig = {0};
 8012748:	e9cd 2204 	strd	r2, r2, [sp, #16]
 801274c:	e9cd 2206 	strd	r2, r2, [sp, #24]
 8012750:	e9cd 2208 	strd	r2, r2, [sp, #32]
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8012754:	f7ef fab2 	bl	8001cbc <HAL_ADC_Init>
 8012758:	2800      	cmp	r0, #0
 801275a:	f040 8086 	bne.w	801286a <MX_ADC1_Init+0x17a>
    Error_Handler();
  }
  /** Configure the ADC multi-mode 
  */
  multimode.Mode = ADC_MODE_INDEPENDENT;
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 801275e:	f240 7010 	movw	r0, #1808	; 0x710
  multimode.Mode = ADC_MODE_INDEPENDENT;
 8012762:	2300      	movs	r3, #0
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 8012764:	4669      	mov	r1, sp
 8012766:	f2c2 0000 	movt	r0, #8192	; 0x2000
  multimode.Mode = ADC_MODE_INDEPENDENT;
 801276a:	9300      	str	r3, [sp, #0]
  if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
 801276c:	f7ef fe1c 	bl	80023a8 <HAL_ADCEx_MultiModeConfigChannel>
 8012770:	2800      	cmp	r0, #0
 8012772:	d177      	bne.n	8012864 <MX_ADC1_Init+0x174>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_7;
 8012774:	2380      	movs	r3, #128	; 0x80
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8012776:	2206      	movs	r2, #6
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
 8012778:	2105      	movs	r1, #5
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 801277a:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Channel = ADC_CHANNEL_7;
 801277e:	f6c1 5350 	movt	r3, #7504	; 0x1d50
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8012782:	f240 74ff 	movw	r4, #2047	; 0x7ff
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8012786:	9204      	str	r2, [sp, #16]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8012788:	2204      	movs	r2, #4
  sConfig.Channel = ADC_CHANNEL_7;
 801278a:	9303      	str	r3, [sp, #12]
  sConfig.Offset = 0;
 801278c:	2300      	movs	r3, #0
  sConfig.SamplingTime = ADC_SAMPLETIME_64CYCLES_5;
 801278e:	9105      	str	r1, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012790:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012794:	a903      	add	r1, sp, #12
  sConfig.Offset = 0;
 8012796:	9308      	str	r3, [sp, #32]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8012798:	e9cd 4206 	strd	r4, r2, [sp, #24]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 801279c:	f7ee fc88 	bl	80010b0 <HAL_ADC_ConfigChannel>
 80127a0:	2800      	cmp	r0, #0
 80127a2:	d15c      	bne.n	801285e <MX_ADC1_Init+0x16e>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_19;
 80127a4:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_2;
 80127a6:	220c      	movs	r2, #12
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127a8:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Channel = ADC_CHANNEL_19;
 80127ac:	f6c4 73b8 	movt	r3, #20408	; 0x4fb8
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127b0:	eb0d 0102 	add.w	r1, sp, r2
 80127b4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  sConfig.Channel = ADC_CHANNEL_19;
 80127b8:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127bc:	f7ee fc78 	bl	80010b0 <HAL_ADC_ConfigChannel>
 80127c0:	2800      	cmp	r0, #0
 80127c2:	d149      	bne.n	8012858 <MX_ADC1_Init+0x168>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_14;
 80127c4:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  sConfig.Rank = ADC_REGULAR_RANK_3;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127c8:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Rank = ADC_REGULAR_RANK_3;
 80127cc:	2212      	movs	r2, #18
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127ce:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_14;
 80127d0:	f6c3 23c0 	movt	r3, #15040	; 0x3ac0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
  sConfig.Channel = ADC_CHANNEL_14;
 80127d8:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127dc:	f7ee fc68 	bl	80010b0 <HAL_ADC_ConfigChannel>
 80127e0:	bbb8      	cbnz	r0, 8012852 <MX_ADC1_Init+0x162>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_16;
 80127e2:	2300      	movs	r3, #0
  sConfig.Rank = ADC_REGULAR_RANK_4;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127e4:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Rank = ADC_REGULAR_RANK_4;
 80127e8:	2218      	movs	r2, #24
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127ea:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_16;
 80127ec:	f2c4 3321 	movt	r3, #17185	; 0x4321
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127f0:	f2c2 0000 	movt	r0, #8192	; 0x2000
  sConfig.Channel = ADC_CHANNEL_16;
 80127f4:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 80127f8:	f7ee fc5a 	bl	80010b0 <HAL_ADC_ConfigChannel>
 80127fc:	bb30      	cbnz	r0, 801284c <MX_ADC1_Init+0x15c>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_15;
 80127fe:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  sConfig.Rank = ADC_REGULAR_RANK_5;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012802:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Rank = ADC_REGULAR_RANK_5;
 8012806:	f44f 7280 	mov.w	r2, #256	; 0x100
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 801280a:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_15;
 801280c:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012810:	f2c2 0000 	movt	r0, #8192	; 0x2000
  sConfig.Channel = ADC_CHANNEL_15;
 8012814:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012818:	f7ee fc4a 	bl	80010b0 <HAL_ADC_ConfigChannel>
 801281c:	b998      	cbnz	r0, 8012846 <MX_ADC1_Init+0x156>
  {
    Error_Handler();
  }
  /** Configure Regular Channel 
  */
  sConfig.Channel = ADC_CHANNEL_8;
 801281e:	f44f 7380 	mov.w	r3, #256	; 0x100
  sConfig.Rank = ADC_REGULAR_RANK_6;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012822:	f240 7010 	movw	r0, #1808	; 0x710
  sConfig.Rank = ADC_REGULAR_RANK_6;
 8012826:	f44f 7283 	mov.w	r2, #262	; 0x106
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 801282a:	a903      	add	r1, sp, #12
  sConfig.Channel = ADC_CHANNEL_8;
 801282c:	f2c2 1380 	movt	r3, #8576	; 0x2180
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012830:	f2c2 0000 	movt	r0, #8192	; 0x2000
  sConfig.Channel = ADC_CHANNEL_8;
 8012834:	e9cd 3203 	strd	r3, r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8012838:	f7ee fc3a 	bl	80010b0 <HAL_ADC_ConfigChannel>
 801283c:	b108      	cbz	r0, 8012842 <MX_ADC1_Init+0x152>
  {
    Error_Handler();
 801283e:	f003 f811 	bl	8015864 <Error_Handler>
  }

}
 8012842:	b00a      	add	sp, #40	; 0x28
 8012844:	bd70      	pop	{r4, r5, r6, pc}
    Error_Handler();
 8012846:	f003 f80d 	bl	8015864 <Error_Handler>
 801284a:	e7e8      	b.n	801281e <MX_ADC1_Init+0x12e>
    Error_Handler();
 801284c:	f003 f80a 	bl	8015864 <Error_Handler>
 8012850:	e7d5      	b.n	80127fe <MX_ADC1_Init+0x10e>
    Error_Handler();
 8012852:	f003 f807 	bl	8015864 <Error_Handler>
 8012856:	e7c4      	b.n	80127e2 <MX_ADC1_Init+0xf2>
    Error_Handler();
 8012858:	f003 f804 	bl	8015864 <Error_Handler>
 801285c:	e7b2      	b.n	80127c4 <MX_ADC1_Init+0xd4>
    Error_Handler();
 801285e:	f003 f801 	bl	8015864 <Error_Handler>
 8012862:	e79f      	b.n	80127a4 <MX_ADC1_Init+0xb4>
    Error_Handler();
 8012864:	f002 fffe 	bl	8015864 <Error_Handler>
 8012868:	e784      	b.n	8012774 <MX_ADC1_Init+0x84>
    Error_Handler();
 801286a:	f002 fffb 	bl	8015864 <Error_Handler>
 801286e:	e776      	b.n	801275e <MX_ADC1_Init+0x6e>

08012870 <HAL_ADC_MspInit>:
void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
  if(adcHandle->Instance==ADC1)
 8012870:	f44f 5300 	mov.w	r3, #8192	; 0x2000
{
 8012874:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if(adcHandle->Instance==ADC1)
 8012878:	f2c4 0302 	movt	r3, #16386	; 0x4002
 801287c:	6802      	ldr	r2, [r0, #0]
{
 801287e:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012880:	2400      	movs	r4, #0
  if(adcHandle->Instance==ADC1)
 8012882:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8012884:	940d      	str	r4, [sp, #52]	; 0x34
 8012886:	e9cd 4409 	strd	r4, r4, [sp, #36]	; 0x24
 801288a:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_DMA_MuxSyncConfigTypeDef pSyncConfig= {0};
 801288e:	e9cd 4404 	strd	r4, r4, [sp, #16]
 8012892:	e9cd 4406 	strd	r4, r4, [sp, #24]
  if(adcHandle->Instance==ADC1)
 8012896:	d002      	beq.n	801289e <HAL_ADC_MspInit+0x2e>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 8012898:	b00f      	add	sp, #60	; 0x3c
 801289a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    __HAL_RCC_ADC12_CLK_ENABLE();
 801289e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
 80128a2:	2122      	movs	r1, #34	; 0x22
 80128a4:	4606      	mov	r6, r0
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80128a6:	f44f 6000 	mov.w	r0, #2048	; 0x800
    __HAL_RCC_ADC12_CLK_ENABLE();
 80128aa:	f6c5 0302 	movt	r3, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 80128ae:	2703      	movs	r7, #3
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80128b0:	f6c5 0002 	movt	r0, #22530	; 0x5802
    hdma_adc1.Instance = DMA2_Stream0;
 80128b4:	f240 7574 	movw	r5, #1908	; 0x774
    __HAL_RCC_ADC12_CLK_ENABLE();
 80128b8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
    hdma_adc1.Instance = DMA2_Stream0;
 80128bc:	f2c2 0500 	movt	r5, #8192	; 0x2000
    __HAL_RCC_ADC12_CLK_ENABLE();
 80128c0:	f042 0220 	orr.w	r2, r2, #32
 80128c4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
 80128c8:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 80128cc:	f002 0220 	and.w	r2, r2, #32
 80128d0:	9201      	str	r2, [sp, #4]
 80128d2:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 80128d4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80128d8:	f042 0204 	orr.w	r2, r2, #4
 80128dc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80128e0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80128e4:	f002 0204 	and.w	r2, r2, #4
 80128e8:	9202      	str	r2, [sp, #8]
 80128ea:	9a02      	ldr	r2, [sp, #8]
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80128ec:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80128f0:	f042 0201 	orr.w	r2, r2, #1
 80128f4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80128f8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_5;
 80128fc:	9109      	str	r1, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80128fe:	a909      	add	r1, sp, #36	; 0x24
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012900:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012904:	970a      	str	r7, [sp, #40]	; 0x28
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8012906:	9303      	str	r3, [sp, #12]
 8012908:	9b03      	ldr	r3, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801290a:	f7f3 faeb 	bl	8005ee4 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801290e:	4620      	mov	r0, r4
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
 8012910:	23ad      	movs	r3, #173	; 0xad
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8012912:	a909      	add	r1, sp, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8012914:	970a      	str	r7, [sp, #40]	; 0x28
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8012916:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_5 
 801291a:	9309      	str	r3, [sp, #36]	; 0x24
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801291c:	940b      	str	r4, [sp, #44]	; 0x2c
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 801291e:	f7f3 fae1 	bl	8005ee4 <HAL_GPIO_Init>
    hdma_adc1.Instance = DMA2_Stream0;
 8012922:	f44f 6382 	mov.w	r3, #1040	; 0x410
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8012926:	f44f 6080 	mov.w	r0, #1024	; 0x400
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 801292a:	f04f 0e09 	mov.w	lr, #9
    hdma_adc1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
 801292e:	f44f 6c00 	mov.w	ip, #2048	; 0x800
    hdma_adc1.Instance = DMA2_Stream0;
 8012932:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 8012936:	f44f 5700 	mov.w	r7, #8192	; 0x2000
    hdma_adc1.Init.Mode = DMA_CIRCULAR;
 801293a:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
 801293e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    hdma_adc1.Instance = DMA2_Stream0;
 8012942:	602b      	str	r3, [r5, #0]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8012944:	2304      	movs	r3, #4
    hdma_adc1.Init.MemInc = DMA_MINC_ENABLE;
 8012946:	6128      	str	r0, [r5, #16]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8012948:	4628      	mov	r0, r5
    hdma_adc1.Init.Direction = DMA_PERIPH_TO_MEMORY;
 801294a:	60ac      	str	r4, [r5, #8]
    hdma_adc1.Init.PeriphInc = DMA_PINC_DISABLE;
 801294c:	60ec      	str	r4, [r5, #12]
    hdma_adc1.Init.PeriphBurst = DMA_PBURST_SINGLE;
 801294e:	632c      	str	r4, [r5, #48]	; 0x30
    hdma_adc1.Init.Request = DMA_REQUEST_ADC1;
 8012950:	f8c5 e004 	str.w	lr, [r5, #4]
    hdma_adc1.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8012954:	626b      	str	r3, [r5, #36]	; 0x24
    hdma_adc1.Init.MemBurst = DMA_MBURST_SINGLE;
 8012956:	e9c5 440a 	strd	r4, r4, [r5, #40]	; 0x28
    hdma_adc1.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
 801295a:	e9c5 c705 	strd	ip, r7, [r5, #20]
    hdma_adc1.Init.Priority = DMA_PRIORITY_HIGH;
 801295e:	e9c5 1207 	strd	r1, r2, [r5, #28]
    if (HAL_DMA_Init(&hdma_adc1) != HAL_OK)
 8012962:	f7f0 f851 	bl	8002a08 <HAL_DMA_Init>
 8012966:	bb18      	cbnz	r0, 80129b0 <HAL_ADC_MspInit+0x140>
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
 8012968:	f04f 0900 	mov.w	r9, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
 801296c:	f240 7074 	movw	r0, #1908	; 0x774
    pSyncConfig.EventEnable = ENABLE;
 8012970:	2301      	movs	r3, #1
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
 8012972:	f04f 0806 	mov.w	r8, #6
 8012976:	f2c0 0902 	movt	r9, #2
    pSyncConfig.SyncEnable = DISABLE;
 801297a:	2200      	movs	r2, #0
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
 801297c:	a904      	add	r1, sp, #16
 801297e:	f2c2 0000 	movt	r0, #8192	; 0x2000
    pSyncConfig.SyncEnable = DISABLE;
 8012982:	f88d 2018 	strb.w	r2, [sp, #24]
    pSyncConfig.EventEnable = ENABLE;
 8012986:	f88d 3019 	strb.w	r3, [sp, #25]
    pSyncConfig.RequestNumber = 1;
 801298a:	9307      	str	r3, [sp, #28]
    pSyncConfig.SyncSignalID = HAL_DMAMUX1_SYNC_EXTI0;
 801298c:	e9cd 8904 	strd	r8, r9, [sp, #16]
    if (HAL_DMAEx_ConfigMuxSync(&hdma_adc1, &pSyncConfig) != HAL_OK)
 8012990:	f7f2 fd58 	bl	8005444 <HAL_DMAEx_ConfigMuxSync>
 8012994:	b978      	cbnz	r0, 80129b6 <HAL_ADC_MspInit+0x146>
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 8012996:	2200      	movs	r2, #0
 8012998:	2105      	movs	r1, #5
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 801299a:	64f5      	str	r5, [r6, #76]	; 0x4c
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 801299c:	2012      	movs	r0, #18
    __HAL_LINKDMA(adcHandle,DMA_Handle,hdma_adc1);
 801299e:	63ae      	str	r6, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(ADC_IRQn, 5, 0);
 80129a0:	f7ef fe0e 	bl	80025c0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(ADC_IRQn);
 80129a4:	2012      	movs	r0, #18
 80129a6:	f7ef fe5b 	bl	8002660 <HAL_NVIC_EnableIRQ>
}
 80129aa:	b00f      	add	sp, #60	; 0x3c
 80129ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      Error_Handler();
 80129b0:	f002 ff58 	bl	8015864 <Error_Handler>
 80129b4:	e7d8      	b.n	8012968 <HAL_ADC_MspInit+0xf8>
      Error_Handler();
 80129b6:	f002 ff55 	bl	8015864 <Error_Handler>
 80129ba:	e7ec      	b.n	8012996 <HAL_ADC_MspInit+0x126>

080129bc <audioFrame>:
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
}

void audioFrame(uint16_t buffer_offset)
{
 80129bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80129c0:	ed2d 8b04 	vpush	{d8-d9}
 80129c4:	b089      	sub	sp, #36	; 0x24
 80129c6:	9000      	str	r0, [sp, #0]
	//int32_t current_sample;
	uint32_t clipCatcher = 0;

	//tempCount5 = DWT->CYCCNT;

	buttonCheck();
 80129c8:	f00d fc06 	bl	80201d8 <buttonCheck>

	adcCheck();
 80129cc:	f00d ffe4 	bl	8020998 <adcCheck>

	// if the USB write pointer has advanced (indicating unread data is in the buffer),
	// or the overflow bit is set, meaning that the write pointer wrapped around and the read pointer hasn't caught up to it yet
	// then process that new data this frame
	if ((myUSB_FIFO_overflowBit) || (myUSB_FIFO_writePointer > myUSB_FIFO_readPointer))
 80129d0:	f240 6359 	movw	r3, #1625	; 0x659
 80129d4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80129d8:	781b      	ldrb	r3, [r3, #0]
 80129da:	2b00      	cmp	r3, #0
 80129dc:	f040 81bc 	bne.w	8012d58 <audioFrame+0x39c>
 80129e0:	f240 625c 	movw	r2, #1628	; 0x65c
 80129e4:	f240 635a 	movw	r3, #1626	; 0x65a
 80129e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80129ec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80129f0:	8812      	ldrh	r2, [r2, #0]
 80129f2:	881b      	ldrh	r3, [r3, #0]
 80129f4:	4293      	cmp	r3, r2
 80129f6:	f0c0 81af 	bcc.w	8012d58 <audioFrame+0x39c>
	{
		ProcessReceivedMidiDatas();
	}


	if (!loadingPreset)
 80129fa:	f240 6357 	movw	r3, #1623	; 0x657
 80129fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012a02:	9303      	str	r3, [sp, #12]
 8012a04:	781b      	ldrb	r3, [r3, #0]
 8012a06:	2b00      	cmp	r3, #0
 8012a08:	d163      	bne.n	8012ad2 <audioFrame+0x116>
 8012a0a:	f648 0424 	movw	r4, #34852	; 0x8824
 8012a0e:	f248 77f8 	movw	r7, #34808	; 0x87f8
 8012a12:	f240 6555 	movw	r5, #1621	; 0x655
 8012a16:	f240 6a56 	movw	sl, #1622	; 0x656
 8012a1a:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8012a1e:	f642 5610 	movw	r6, #11536	; 0x2d10
 8012a22:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8012a26:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8012a2a:	46a0      	mov	r8, r4
 8012a2c:	f104 0918 	add.w	r9, r4, #24
 8012a30:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8012a34:	f2c2 0600 	movt	r6, #8192	; 0x2000
	{

		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
		{
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
 8012a38:	4638      	mov	r0, r7
 8012a3a:	3704      	adds	r7, #4
 8012a3c:	f013 fab2 	bl	8025fa4 <tExpSmooth_tick>
			for (int i = 0; i < KNOB_PAGE_SIZE; i++)
			{
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
 8012a40:	f895 b000 	ldrb.w	fp, [r5]
 8012a44:	f89a 3000 	ldrb.w	r3, [sl]
 8012a48:	eb0b 028b 	add.w	r2, fp, fp, lsl #2
			smoothedADC[i] = tExpSmooth_tick(&adc[i]);
 8012a4c:	eca8 0a01 	vstmia	r8!, {s0}
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
 8012a50:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8012a54:	ed94 7a00 	vldr	s14, [r4]
 8012a58:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 8012a5c:	edd4 7a01 	vldr	s15, [r4, #4]
 8012a60:	f103 0c01 	add.w	ip, r3, #1
 8012a64:	1c98      	adds	r0, r3, #2
 8012a66:	eb02 0e03 	add.w	lr, r2, r3
 8012a6a:	1cd9      	adds	r1, r3, #3
 8012a6c:	4494      	add	ip, r2
 8012a6e:	3304      	adds	r3, #4
 8012a70:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
 8012a74:	4410      	add	r0, r2
 8012a76:	eb06 0c8c 	add.w	ip, r6, ip, lsl #2
 8012a7a:	4411      	add	r1, r2
 8012a7c:	ed8e 7a00 	vstr	s14, [lr]
 8012a80:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 8012a84:	4413      	add	r3, r2
 8012a86:	f8d4 e008 	ldr.w	lr, [r4, #8]
 8012a8a:	edcc 7a00 	vstr	s15, [ip]
 8012a8e:	eb06 0181 	add.w	r1, r6, r1, lsl #2
 8012a92:	f8c0 e000 	str.w	lr, [r0]
 8012a96:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8012a9a:	f8d4 c00c 	ldr.w	ip, [r4, #12]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8012a9e:	45c1      	cmp	r9, r8
				presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)] = smoothedADC[i];
 8012aa0:	6920      	ldr	r0, [r4, #16]
 8012aa2:	f8c1 c000 	str.w	ip, [r1]
 8012aa6:	6018      	str	r0, [r3, #0]
		for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8012aa8:	d1c6      	bne.n	8012a38 <audioFrame+0x7c>
			}
		}


		if (cvAddParam[currentPreset] >= 0)
 8012aaa:	f648 1338 	movw	r3, #35128	; 0x8938
 8012aae:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8012ab2:	f913 300b 	ldrsb.w	r3, [r3, fp]
 8012ab6:	2b00      	cmp	r3, #0
 8012ab8:	db04      	blt.n	8012ac4 <audioFrame+0x108>
		{
			presetKnobValues[currentPreset][cvAddParam[currentPreset]] = smoothedADC[5];
 8012aba:	441a      	add	r2, r3
 8012abc:	6963      	ldr	r3, [r4, #20]
 8012abe:	eb06 0282 	add.w	r2, r6, r2, lsl #2
 8012ac2:	6013      	str	r3, [r2, #0]
		}

		frameFunctions[currentPreset]();
 8012ac4:	f640 03d8 	movw	r3, #2264	; 0x8d8
 8012ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012acc:	f853 302b 	ldr.w	r3, [r3, fp, lsl #2]
 8012ad0:	4798      	blx	r3
	//if the codec isn't ready, keep the buffer as all zeros
	//otherwise, start computing audio!

	bufferCleared = TRUE;

	if (codecReady)
 8012ad2:	f240 43f8 	movw	r3, #1272	; 0x4f8
	bufferCleared = TRUE;
 8012ad6:	f240 0109 	movw	r1, #9
 8012ada:	2201      	movs	r2, #1
	if (codecReady)
 8012adc:	f2c2 0300 	movt	r3, #8192	; 0x2000
	bufferCleared = TRUE;
 8012ae0:	f2c2 0100 	movt	r1, #8192	; 0x2000
	if (codecReady)
 8012ae4:	781b      	ldrb	r3, [r3, #0]
	bufferCleared = TRUE;
 8012ae6:	9105      	str	r1, [sp, #20]
 8012ae8:	700a      	strb	r2, [r1, #0]
	if (codecReady)
 8012aea:	2b00      	cmp	r3, #0
 8012aec:	f000 8137 	beq.w	8012d5e <audioFrame+0x3a2>
	//uint32_t tempCount5 = DWT->CYCCNT;

	//cycleCountVals[1][2] = 0;


	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012af0:	f64f 71ef 	movw	r1, #65519	; 0xffef
 8012af4:	9c00      	ldr	r4, [sp, #0]
	{
		clips |= 2;
	}


	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012af6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8012afa:	f240 0a80 	movw	sl, #128	; 0x80
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012afe:	460a      	mov	r2, r1
 8012b00:	1c65      	adds	r5, r4, #1
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012b02:	f2c4 33ff 	movt	r3, #17407	; 0x43ff
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b06:	f64f 70f6 	movw	r0, #65526	; 0xfff6
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012b0a:	f640 1420 	movw	r4, #2336	; 0x920
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012b0e:	f6cb 717f 	movt	r1, #49023	; 0xbf7f
 8012b12:	f2c3 0a00 	movt	sl, #12288	; 0x3000
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b16:	f6c2 70ff 	movt	r0, #12287	; 0x2fff
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012b1a:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
	uint32_t clipCatcher = 0;
 8012b1e:	2600      	movs	r6, #0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012b20:	ee08 3a90 	vmov	s17, r3
 8012b24:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8012b28:	9b03      	ldr	r3, [sp, #12]
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012b2a:	ee09 1a90 	vmov	s19, r1
	uint32_t clipCatcher = 0;
 8012b2e:	9601      	str	r6, [sp, #4]
 8012b30:	f50a 6b00 	add.w	fp, sl, #2048	; 0x800
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b34:	ee08 0a10 	vmov	s16, r0
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012b38:	ee09 2a10 	vmov	s18, r2
 8012b3c:	00ad      	lsls	r5, r5, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012b3e:	9404      	str	r4, [sp, #16]
 8012b40:	7819      	ldrb	r1, [r3, #0]
 8012b42:	e00b      	b.n	8012b5c <audioFrame+0x1a0>
	if (loadingPreset)
 8012b44:	2300      	movs	r3, #0
 8012b46:	461a      	mov	r2, r3
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
 8012b48:	3602      	adds	r6, #2
			audioOutBuffer[buffer_offset + i] = (int32_t)(theSamples[1] * TWO_TO_23);
 8012b4a:	f84b 2024 	str.w	r2, [fp, r4, lsl #2]
			audioOutBuffer[buffer_offset + i + 1] = (int32_t)(theSamples[0] * TWO_TO_23);
 8012b4e:	f84b 3005 	str.w	r3, [fp, r5]
 8012b52:	3508      	adds	r5, #8
		for (i = 0; i < (HALF_BUFFER_SIZE); i += 2)
 8012b54:	f5b6 7f80 	cmp.w	r6, #256	; 0x100
 8012b58:	f000 8154 	beq.w	8012e04 <audioFrame+0x448>
 8012b5c:	9b00      	ldr	r3, [sp, #0]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8012b5e:	f85a 2005 	ldr.w	r2, [sl, r5]
 8012b62:	18f4      	adds	r4, r6, r3
 8012b64:	0212      	lsls	r2, r2, #8
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b66:	f85a 3024 	ldr.w	r3, [sl, r4, lsl #2]
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8012b6a:	ee00 2a90 	vmov	s1, r2
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b6e:	021b      	lsls	r3, r3, #8
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8012b70:	eef8 0ae0 	vcvt.f32.s32	s1, s1
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b74:	ee07 3a90 	vmov	s15, r3
 8012b78:	eef8 7ae7 	vcvt.f32.s32	s15, s15
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8012b7c:	ee60 0a88 	vmul.f32	s1, s1, s16
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b80:	ee67 7a88 	vmul.f32	s15, s15, s16
			theSamples[1] = ((float)(audioInBuffer[buffer_offset + i + 1] << 8)) * INV_TWO_TO_31;
 8012b84:	edcd 0a07 	vstr	s1, [sp, #28]
			theSamples[0] = ((float)(audioInBuffer[buffer_offset + i] << 8)) * INV_TWO_TO_31;
 8012b88:	edcd 7a06 	vstr	s15, [sp, #24]
	if (loadingPreset)
 8012b8c:	2900      	cmp	r1, #0
 8012b8e:	d1d9      	bne.n	8012b44 <audioFrame+0x188>
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012b90:	eef4 0ae9 	vcmpe.f32	s1, s19
 8012b94:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012b98:	eef4 0ac9 	vcmpe.f32	s1, s18
 8012b9c:	bf94      	ite	ls
 8012b9e:	f04f 0801 	movls.w	r8, #1
 8012ba2:	f04f 0800 	movhi.w	r8, #0
 8012ba6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8012baa:	eef4 7ac9 	vcmpe.f32	s15, s18
	uint32_t clips = 0;
 8012bae:	bfa8      	it	ge
 8012bb0:	f048 0801 	orrge.w	r8, r8, #1
	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8012bb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012bb8:	da04      	bge.n	8012bc4 <audioFrame+0x208>
 8012bba:	eef4 7a69 	vcmp.f32	s15, s19
 8012bbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012bc2:	d801      	bhi.n	8012bc8 <audioFrame+0x20c>
		clips |= 2;
 8012bc4:	f048 0802 	orr.w	r8, r8, #2
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012bc8:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8012bcc:	f640 1730 	movw	r7, #2352	; 0x930
 8012bd0:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8012bd4:	f248 6940 	movw	r9, #34368	; 0x8640
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012bd8:	f014 feee 	bl	80279b8 <LEAF_clip>
 8012bdc:	9804      	ldr	r0, [sp, #16]
 8012bde:	f00f fb07 	bl	80221f0 <tEnvelopeFollower_tick>
 8012be2:	ee20 0a28 	vmul.f32	s0, s0, s17
 8012be6:	f2c2 0700 	movt	r7, #8192	; 0x2000
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8012bea:	f248 6280 	movw	r2, #34432	; 0x8680
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012bee:	a906      	add	r1, sp, #24
 8012bf0:	eddd 0a06 	vldr	s1, [sp, #24]
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012bf4:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8012bf8:	f2c2 0201 	movt	r2, #8193	; 0x2001
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012bfc:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8012c00:	9102      	str	r1, [sp, #8]
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8012c02:	6810      	ldr	r0, [r2, #0]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c04:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c08:	ee17 3a90 	vmov	r3, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8012c0c:	f2c2 0901 	movt	r9, #8193	; 0x2001
	uint16_t current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[0], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c10:	eb07 0383 	add.w	r3, r7, r3, lsl #2
 8012c14:	edd3 7a00 	vldr	s15, [r3]
 8012c18:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim3, TIM_CHANNEL_2, current_env);
 8012c1c:	ee17 3a90 	vmov	r3, s15
 8012c20:	b29b      	uxth	r3, r3
 8012c22:	6383      	str	r3, [r0, #56]	; 0x38
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c24:	f014 fec8 	bl	80279b8 <LEAF_clip>
 8012c28:	f640 1028 	movw	r0, #2344	; 0x928
 8012c2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012c30:	f00f fade 	bl	80221f0 <tEnvelopeFollower_tick>
 8012c34:	ee20 0a28 	vmul.f32	s0, s0, s17

	tickFunctions[currentPreset](samples);
 8012c38:	9902      	ldr	r1, [sp, #8]
 8012c3a:	f240 6e55 	movw	lr, #1621	; 0x655
 8012c3e:	f240 7cf4 	movw	ip, #2036	; 0x7f4
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8012c42:	f8d9 3000 	ldr.w	r3, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c46:	eefc 7ac0 	vcvt.u32.f32	s15, s0
	tickFunctions[currentPreset](samples);
 8012c4a:	4608      	mov	r0, r1
 8012c4c:	f2c2 0e00 	movt	lr, #8192	; 0x2000
 8012c50:	f2c2 0c00 	movt	ip, #8192	; 0x2000
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c54:	ee17 1a90 	vmov	r1, s15
	tickFunctions[currentPreset](samples);
 8012c58:	f89e e000 	ldrb.w	lr, [lr]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[2], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012c5c:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8012c60:	edd1 7a00 	vldr	s15, [r1]
 8012c64:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, current_env);
 8012c68:	ee17 2a90 	vmov	r2, s15
 8012c6c:	b291      	uxth	r1, r2
 8012c6e:	6399      	str	r1, [r3, #56]	; 0x38
	tickFunctions[currentPreset](samples);
 8012c70:	f85c 302e 	ldr.w	r3, [ip, lr, lsl #2]
 8012c74:	4798      	blx	r3

	//now the samples array is output
	if ((samples[1] >= 0.999999f) || (samples[1] <= -0.999999f))
 8012c76:	eddd 0a07 	vldr	s1, [sp, #28]
 8012c7a:	eef4 0ac9 	vcmpe.f32	s1, s18
 8012c7e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012c82:	da04      	bge.n	8012c8e <audioFrame+0x2d2>
 8012c84:	eef4 0a69 	vcmp.f32	s1, s19
 8012c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012c8c:	d801      	bhi.n	8012c92 <audioFrame+0x2d6>
	{
		clips |= 4;
 8012c8e:	f048 0804 	orr.w	r8, r8, #4
	}

	if ((samples[0] >= 0.999999f) || (samples[0] <= -0.999999f))
 8012c92:	eddd 7a06 	vldr	s15, [sp, #24]
 8012c96:	eef4 7ae9 	vcmpe.f32	s15, s19
 8012c9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012c9e:	d904      	bls.n	8012caa <audioFrame+0x2ee>
 8012ca0:	eef4 7a49 	vcmp.f32	s15, s18
 8012ca4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8012ca8:	db01      	blt.n	8012cae <audioFrame+0x2f2>
	{
		clips |= 8;
 8012caa:	f048 0808 	orr.w	r8, r8, #8
 8012cae:	9b01      	ldr	r3, [sp, #4]
	}
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012cb0:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8012cb4:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8012cb8:	ea43 0308 	orr.w	r3, r3, r8
 8012cbc:	9301      	str	r3, [sp, #4]
 8012cbe:	f014 fe7b 	bl	80279b8 <LEAF_clip>
 8012cc2:	f640 1024 	movw	r0, #2340	; 0x924
 8012cc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012cca:	f00f fa91 	bl	80221f0 <tEnvelopeFollower_tick>
 8012cce:	ee60 7a28 	vmul.f32	s15, s0, s17
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
 8012cd2:	f8d9 3000 	ldr.w	r3, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012cd6:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8012cda:	eddd 0a06 	vldr	s1, [sp, #24]
 8012cde:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[1], LEAF_clip(-1.0f, samples[1], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012ce2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012ce6:	ee17 1a90 	vmov	r1, s15
 8012cea:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8012cee:	edd1 7a00 	vldr	s15, [r1]
 8012cf2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, current_env);
 8012cf6:	ee17 2a90 	vmov	r2, s15
 8012cfa:	b291      	uxth	r1, r2
 8012cfc:	63d9      	str	r1, [r3, #60]	; 0x3c
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012cfe:	f014 fe5b 	bl	80279b8 <LEAF_clip>
 8012d02:	f640 102c 	movw	r0, #2348	; 0x92c
 8012d06:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012d0a:	f00f fa71 	bl	80221f0 <tEnvelopeFollower_tick>
 8012d0e:	ee20 0a28 	vmul.f32	s0, s0, s17
 8012d12:	9b03      	ldr	r3, [sp, #12]
 8012d14:	ed9d 7a07 	vldr	s14, [sp, #28]
 8012d18:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 8012d1c:	7819      	ldrb	r1, [r3, #0]
 8012d1e:	eddd 7a06 	vldr	s15, [sp, #24]
 8012d22:	eef0 6a47 	vmov.f32	s13, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
 8012d26:	f8d9 0000 	ldr.w	r0, [r9]
	current_env = atodbTable[(uint32_t)(tEnvelopeFollower_tick(&LED_envelope[3], LEAF_clip(-1.0f, samples[0], 1.0f)) * ATODB_TABLE_SIZE_MINUS_ONE)];
 8012d2a:	ee10 3a10 	vmov	r3, s0
 8012d2e:	eeb0 7a67 	vmov.f32	s14, s15
 8012d32:	eefe 6ae4 	vcvt.s32.f32	s13, s13, #23
 8012d36:	eb07 0783 	add.w	r7, r7, r3, lsl #2
 8012d3a:	eebe 7ae4 	vcvt.s32.f32	s14, s14, #23
 8012d3e:	edd7 7a00 	vldr	s15, [r7]
 8012d42:	ee16 2a90 	vmov	r2, s13
 8012d46:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8012d4a:	ee17 3a10 	vmov	r3, s14
	__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, current_env);
 8012d4e:	ee17 7a90 	vmov	r7, s15
 8012d52:	b2bf      	uxth	r7, r7
 8012d54:	6347      	str	r7, [r0, #52]	; 0x34
 8012d56:	e6f7      	b.n	8012b48 <audioFrame+0x18c>
		ProcessReceivedMidiDatas();
 8012d58:	f7ff fc26 	bl	80125a8 <ProcessReceivedMidiDatas>
 8012d5c:	e64d      	b.n	80129fa <audioFrame+0x3e>
	uint32_t clipCatcher = 0;
 8012d5e:	9301      	str	r3, [sp, #4]
		numBuffersCleared++;
 8012d60:	f240 43fc 	movw	r3, #1276	; 0x4fc
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8012d64:	f240 010c 	movw	r1, #12
		numBuffersCleared++;
 8012d68:	f2c2 0300 	movt	r3, #8192	; 0x2000
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8012d6c:	f2c2 0100 	movt	r1, #8192	; 0x2000
		numBuffersCleared++;
 8012d70:	681a      	ldr	r2, [r3, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8012d72:	6809      	ldr	r1, [r1, #0]
		numBuffersCleared++;
 8012d74:	3201      	adds	r2, #1
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8012d76:	428a      	cmp	r2, r1
		numBuffersCleared++;
 8012d78:	601a      	str	r2, [r3, #0]
		if (numBuffersCleared >= numBuffersToClearOnLoad)
 8012d7a:	da50      	bge.n	8012e1e <audioFrame+0x462>
 8012d7c:	f240 45d4 	movw	r5, #1236	; 0x4d4
 8012d80:	f240 46f4 	movw	r6, #1268	; 0x4f4
			clipHappened[i] = 0;
 8012d84:	f240 48e4 	movw	r8, #1252	; 0x4e4
	uint32_t clipCatcher = 0;
 8012d88:	2400      	movs	r4, #0
 8012d8a:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8012d8e:	f2c2 0600 	movt	r6, #8192	; 0x2000
			clipHappened[i] = 0;
 8012d92:	f2c2 0800 	movt	r8, #8192	; 0x2000
			clipCounter[i] = 80;
 8012d96:	2750      	movs	r7, #80	; 0x50
 8012d98:	f8dd 9004 	ldr.w	r9, [sp, #4]
		if ((clipCatcher >> i) & 1)
 8012d9c:	fa29 f304 	lsr.w	r3, r9, r4
 8012da0:	07db      	lsls	r3, r3, #31
 8012da2:	d51c      	bpl.n	8012dde <audioFrame+0x422>
			switch (i)
 8012da4:	2c02      	cmp	r4, #2
 8012da6:	f000 8082 	beq.w	8012eae <audioFrame+0x4f2>
 8012daa:	2c03      	cmp	r4, #3
 8012dac:	d07b      	beq.n	8012ea6 <audioFrame+0x4ea>
 8012dae:	2c01      	cmp	r4, #1
 8012db0:	d075      	beq.n	8012e9e <audioFrame+0x4e2>
					setLED_leftin_clip(1);
 8012db2:	2001      	movs	r0, #1
 8012db4:	f002 fde8 	bl	8015988 <setLED_leftin_clip>
			clipped[i] = 1;
 8012db8:	2101      	movs	r1, #1
			clipHappened[i] = 0;
 8012dba:	2200      	movs	r2, #0
 8012dbc:	00a3      	lsls	r3, r4, #2
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 8012dbe:	2050      	movs	r0, #80	; 0x50
			clipCounter[i] = 80;
 8012dc0:	f845 7024 	str.w	r7, [r5, r4, lsl #2]
			clipped[i] = 1;
 8012dc4:	5531      	strb	r1, [r6, r4]
			clipHappened[i] = 0;
 8012dc6:	f848 2024 	str.w	r2, [r8, r4, lsl #2]
			clipCounter[i]--;
 8012dca:	3801      	subs	r0, #1
 8012dcc:	50e8      	str	r0, [r5, r3]
	for (int i = 0; i < 4; i++)
 8012dce:	3401      	adds	r4, #1
 8012dd0:	2c04      	cmp	r4, #4
 8012dd2:	d1e3      	bne.n	8012d9c <audioFrame+0x3e0>
}
 8012dd4:	b009      	add	sp, #36	; 0x24
 8012dd6:	ecbd 8b04 	vpop	{d8-d9}
 8012dda:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 8012dde:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 8012de2:	00a3      	lsls	r3, r4, #2
 8012de4:	5d32      	ldrb	r2, [r6, r4]
 8012de6:	2800      	cmp	r0, #0
 8012de8:	d16e      	bne.n	8012ec8 <audioFrame+0x50c>
		else if ((clipCounter[i] == 0) && (clipped[i] == 1))
 8012dea:	2a01      	cmp	r2, #1
 8012dec:	d1ef      	bne.n	8012dce <audioFrame+0x412>
			switch (i)
 8012dee:	2c02      	cmp	r4, #2
 8012df0:	d061      	beq.n	8012eb6 <audioFrame+0x4fa>
 8012df2:	2c03      	cmp	r4, #3
 8012df4:	d065      	beq.n	8012ec2 <audioFrame+0x506>
 8012df6:	2c01      	cmp	r4, #1
 8012df8:	d060      	beq.n	8012ebc <audioFrame+0x500>
					setLED_leftin_clip(0);
 8012dfa:	f002 fdc5 	bl	8015988 <setLED_leftin_clip>
			clipped[i] = 0;
 8012dfe:	2300      	movs	r3, #0
 8012e00:	5533      	strb	r3, [r6, r4]
 8012e02:	e7e4      	b.n	8012dce <audioFrame+0x412>
			bufferCleared = 0;
 8012e04:	9b05      	ldr	r3, [sp, #20]
		if (!loadingPreset)
 8012e06:	2900      	cmp	r1, #0
 8012e08:	d047      	beq.n	8012e9a <audioFrame+0x4de>
	if (bufferCleared)
 8012e0a:	781b      	ldrb	r3, [r3, #0]
 8012e0c:	2b00      	cmp	r3, #0
 8012e0e:	d1a7      	bne.n	8012d60 <audioFrame+0x3a4>
	else numBuffersCleared = 0;
 8012e10:	f240 43fc 	movw	r3, #1276	; 0x4fc
 8012e14:	2200      	movs	r2, #0
 8012e16:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012e1a:	601a      	str	r2, [r3, #0]
 8012e1c:	e7ae      	b.n	8012d7c <audioFrame+0x3c0>
			if (loadingPreset)
 8012e1e:	9a03      	ldr	r2, [sp, #12]
			numBuffersCleared = numBuffersToClearOnLoad;
 8012e20:	6019      	str	r1, [r3, #0]
			if (loadingPreset)
 8012e22:	7812      	ldrb	r2, [r2, #0]
 8012e24:	2a00      	cmp	r2, #0
 8012e26:	d0a9      	beq.n	8012d7c <audioFrame+0x3c0>
				if (previousPreset != PresetNil)
 8012e28:	f240 23cc 	movw	r3, #716	; 0x2cc
 8012e2c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012e30:	781a      	ldrb	r2, [r3, #0]
 8012e32:	2a12      	cmp	r2, #18
 8012e34:	d006      	beq.n	8012e44 <audioFrame+0x488>
					freeFunctions[previousPreset]();
 8012e36:	f640 0340 	movw	r3, #2112	; 0x840
 8012e3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012e3e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8012e42:	4798      	blx	r3
				setLED_A(0);
 8012e44:	2000      	movs	r0, #0
				knobPage = 0;
 8012e46:	4604      	mov	r4, r0
				setLED_A(0);
 8012e48:	f002 fd50 	bl	80158ec <setLED_A>
				setLED_B(0);
 8012e4c:	4620      	mov	r0, r4
 8012e4e:	f002 fd5d 	bl	801590c <setLED_B>
				setLED_C(0);
 8012e52:	4620      	mov	r0, r4
 8012e54:	f002 fd6a 	bl	801592c <setLED_C>
				setLED_Edit(0);
 8012e58:	4620      	mov	r0, r4
 8012e5a:	f002 fd07 	bl	801586c <setLED_Edit>
				setLED_1(0);
 8012e5e:	4620      	mov	r0, r4
 8012e60:	f002 fd24 	bl	80158ac <setLED_1>
				knobPage = 0;
 8012e64:	f240 6356 	movw	r3, #1622	; 0x656
 8012e68:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012e6c:	701c      	strb	r4, [r3, #0]
				resetKnobValues();
 8012e6e:	f00d feb5 	bl	8020bdc <resetKnobValues>
				allocFunctions[currentPreset]();
 8012e72:	f240 6155 	movw	r1, #1621	; 0x655
				leaf.clearOnAllocation = 0;
 8012e76:	f249 42a0 	movw	r2, #38048	; 0x94a0
				allocFunctions[currentPreset]();
 8012e7a:	f640 038c 	movw	r3, #2188	; 0x88c
 8012e7e:	f2c2 0100 	movt	r1, #8192	; 0x2000
				leaf.clearOnAllocation = 0;
 8012e82:	f2c2 0201 	movt	r2, #8193	; 0x2001
				allocFunctions[currentPreset]();
 8012e86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012e8a:	7809      	ldrb	r1, [r1, #0]
				leaf.clearOnAllocation = 0;
 8012e8c:	6154      	str	r4, [r2, #20]
				allocFunctions[currentPreset]();
 8012e8e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8012e92:	4798      	blx	r3
				loadingPreset = 0;
 8012e94:	9b03      	ldr	r3, [sp, #12]
 8012e96:	701c      	strb	r4, [r3, #0]
 8012e98:	e770      	b.n	8012d7c <audioFrame+0x3c0>
			bufferCleared = 0;
 8012e9a:	7019      	strb	r1, [r3, #0]
 8012e9c:	e7b8      	b.n	8012e10 <audioFrame+0x454>
					setLED_rightin_clip(1);
 8012e9e:	4620      	mov	r0, r4
 8012ea0:	f002 fd82 	bl	80159a8 <setLED_rightin_clip>
					break;
 8012ea4:	e788      	b.n	8012db8 <audioFrame+0x3fc>
					setLED_rightout_clip(1);
 8012ea6:	2001      	movs	r0, #1
 8012ea8:	f002 fd60 	bl	801596c <setLED_rightout_clip>
					break;
 8012eac:	e784      	b.n	8012db8 <audioFrame+0x3fc>
					setLED_leftout_clip(1);
 8012eae:	2001      	movs	r0, #1
 8012eb0:	f002 fd4e 	bl	8015950 <setLED_leftout_clip>
					break;
 8012eb4:	e780      	b.n	8012db8 <audioFrame+0x3fc>
					setLED_leftout_clip(0);
 8012eb6:	f002 fd4b 	bl	8015950 <setLED_leftout_clip>
					break;
 8012eba:	e7a0      	b.n	8012dfe <audioFrame+0x442>
					setLED_rightin_clip(0);
 8012ebc:	f002 fd74 	bl	80159a8 <setLED_rightin_clip>
					break;
 8012ec0:	e79d      	b.n	8012dfe <audioFrame+0x442>
					setLED_rightout_clip(0);
 8012ec2:	f002 fd53 	bl	801596c <setLED_rightout_clip>
					break;
 8012ec6:	e79a      	b.n	8012dfe <audioFrame+0x442>
		if ((clipCounter[i] > 0) && (clipped[i] == 1))
 8012ec8:	2a01      	cmp	r2, #1
 8012eca:	d180      	bne.n	8012dce <audioFrame+0x412>
 8012ecc:	e77d      	b.n	8012dca <audioFrame+0x40e>
 8012ece:	bf00      	nop

08012ed0 <initFunctionPointers>:
}

*/

void initFunctionPointers(void)
{
 8012ed0:	b4f0      	push	{r4, r5, r6, r7}
	allocFunctions[Vocoder] = SFXVocoderAlloc;
 8012ed2:	f640 008c 	movw	r0, #2188	; 0x88c
 8012ed6:	f646 64c9 	movw	r4, #28361	; 0x6ec9
	frameFunctions[Vocoder] = SFXVocoderFrame;
	tickFunctions[Vocoder] = SFXVocoderTick;
	freeFunctions[Vocoder] = SFXVocoderFree;

	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
 8012eda:	f247 51d9 	movw	r1, #30169	; 0x75d9
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
	tickFunctions[VocoderCh] = SFXVocoderChTick;
	freeFunctions[VocoderCh] = SFXVocoderChFree;

	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
 8012ede:	f248 63a9 	movw	r3, #34473	; 0x86a9
	allocFunctions[Vocoder] = SFXVocoderAlloc;
 8012ee2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8012ee6:	f6c0 0401 	movt	r4, #2049	; 0x801
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
	freeFunctions[Pitchshift] = SFXPitchShiftFree;

	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
 8012eea:	f648 2701 	movw	r7, #35329	; 0x8a01
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
	freeFunctions[AutotuneMono] = SFXNeartuneFree;

	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
 8012eee:	f648 4201 	movw	r2, #35841	; 0x8c01
	allocFunctions[Vocoder] = SFXVocoderAlloc;
 8012ef2:	6004      	str	r4, [r0, #0]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
	freeFunctions[AutotunePoly] = SFXAutotuneFree;

	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
 8012ef4:	f648 6629 	movw	r6, #36393	; 0x8e29
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;

	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
 8012ef8:	f249 253d 	movw	r5, #37437	; 0x923d
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;

	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
 8012efc:	f649 64b9 	movw	r4, #40633	; 0x9eb9
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
 8012f00:	f6c0 0101 	movt	r1, #2049	; 0x801
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
 8012f04:	f6c0 0301 	movt	r3, #2049	; 0x801
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
 8012f08:	f6c0 0701 	movt	r7, #2049	; 0x801
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
 8012f0c:	f6c0 0201 	movt	r2, #2049	; 0x801
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
 8012f10:	f6c0 0601 	movt	r6, #2049	; 0x801
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
 8012f14:	f6c0 0501 	movt	r5, #2049	; 0x801
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
 8012f18:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[VocoderCh] = SFXVocoderChAlloc;
 8012f1c:	6041      	str	r1, [r0, #4]
	allocFunctions[Pitchshift] = SFXPitchShiftAlloc;
 8012f1e:	6083      	str	r3, [r0, #8]
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8012f20:	f640 01d8 	movw	r1, #2264	; 0x8d8
	allocFunctions[AutotuneMono] = SFXNeartuneAlloc;
 8012f24:	60c7      	str	r7, [r0, #12]
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8012f26:	f247 0379 	movw	r3, #28793	; 0x7079
	allocFunctions[AutotunePoly] = SFXAutotuneAlloc;
 8012f2a:	6102      	str	r2, [r0, #16]
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
 8012f2c:	f647 27f5 	movw	r7, #31477	; 0x7af5
	allocFunctions[SamplerButtonPress] = SFXSamplerBPAlloc;
 8012f30:	6146      	str	r6, [r0, #20]
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
 8012f32:	f248 7279 	movw	r2, #34681	; 0x8779
	allocFunctions[SamplerKeyboard] = SFXSamplerKAlloc;
 8012f36:	6185      	str	r5, [r0, #24]
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
 8012f38:	f648 26f1 	movw	r6, #35569	; 0x8af1
	allocFunctions[SamplerAutoGrab] = SFXSamplerAutoAlloc;
 8012f3c:	61c4      	str	r4, [r0, #28]
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
 8012f3e:	f648 452d 	movw	r5, #35885	; 0x8c2d
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
 8012f42:	f648 64e1 	movw	r4, #36577	; 0x8ee1
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8012f46:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8012f4a:	f6c0 0301 	movt	r3, #2049	; 0x801
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
 8012f4e:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
 8012f52:	f6c0 0201 	movt	r2, #2049	; 0x801
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
 8012f56:	f6c0 0601 	movt	r6, #2049	; 0x801
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
 8012f5a:	f6c0 0501 	movt	r5, #2049	; 0x801
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
 8012f5e:	f6c0 0401 	movt	r4, #2049	; 0x801
	frameFunctions[Vocoder] = SFXVocoderFrame;
 8012f62:	600b      	str	r3, [r1, #0]
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
 8012f64:	f249 33f5 	movw	r3, #37877	; 0x93f5
	frameFunctions[VocoderCh] = SFXVocoderChFrame;
 8012f68:	604f      	str	r7, [r1, #4]
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
 8012f6a:	f24a 0715 	movw	r7, #40981	; 0xa015
	frameFunctions[Pitchshift] = SFXPitchShiftFrame;
 8012f6e:	608a      	str	r2, [r1, #8]
	tickFunctions[Vocoder] = SFXVocoderTick;
 8012f70:	f240 72f4 	movw	r2, #2036	; 0x7f4
	frameFunctions[AutotuneMono] = SFXNeartuneFrame;
 8012f74:	60ce      	str	r6, [r1, #12]
	tickFunctions[Vocoder] = SFXVocoderTick;
 8012f76:	f247 363d 	movw	r6, #29501	; 0x733d
	frameFunctions[AutotunePoly] = SFXAutotuneFrame;
 8012f7a:	610d      	str	r5, [r1, #16]
	tickFunctions[VocoderCh] = SFXVocoderChTick;
 8012f7c:	f248 2589 	movw	r5, #33417	; 0x8289
	frameFunctions[SamplerButtonPress] = SFXSamplerBPFrame;
 8012f80:	614c      	str	r4, [r1, #20]
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
 8012f82:	f248 747d 	movw	r4, #34685	; 0x877d
	tickFunctions[Vocoder] = SFXVocoderTick;
 8012f86:	f2c2 0200 	movt	r2, #8192	; 0x2000
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
 8012f8a:	f6c0 0301 	movt	r3, #2049	; 0x801
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
 8012f8e:	f6c0 0701 	movt	r7, #2049	; 0x801
	tickFunctions[Vocoder] = SFXVocoderTick;
 8012f92:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[VocoderCh] = SFXVocoderChTick;
 8012f96:	f6c0 0501 	movt	r5, #2049	; 0x801
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
 8012f9a:	f6c0 0401 	movt	r4, #2049	; 0x801
	frameFunctions[SamplerKeyboard] = SFXSamplerKFrame;
 8012f9e:	618b      	str	r3, [r1, #24]
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
 8012fa0:	f24e 63c9 	movw	r3, #59081	; 0xe6c9
	frameFunctions[SamplerAutoGrab] = SFXSamplerAutoFrame;
 8012fa4:	61cf      	str	r7, [r1, #28]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
 8012fa6:	f648 573d 	movw	r7, #36157	; 0x8d3d
	tickFunctions[Vocoder] = SFXVocoderTick;
 8012faa:	6016      	str	r6, [r2, #0]
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
 8012fac:	f648 66e5 	movw	r6, #36581	; 0x8ee5
	tickFunctions[VocoderCh] = SFXVocoderChTick;
 8012fb0:	6055      	str	r5, [r2, #4]
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
 8012fb2:	f249 7521 	movw	r5, #38689	; 0x9721
	tickFunctions[Pitchshift] = SFXPitchShiftTick;
 8012fb6:	6094      	str	r4, [r2, #8]
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
 8012fb8:	f24a 0441 	movw	r4, #41025	; 0xa041
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
 8012fbc:	f6c0 0301 	movt	r3, #2049	; 0x801
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
 8012fc0:	f6c0 0701 	movt	r7, #2049	; 0x801
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
 8012fc4:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
 8012fc8:	f6c0 0501 	movt	r5, #2049	; 0x801
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
 8012fcc:	f6c0 0401 	movt	r4, #2049	; 0x801
	tickFunctions[AutotuneMono] = SFXNeartuneTick;
 8012fd0:	60d3      	str	r3, [r2, #12]
	tickFunctions[AutotunePoly] = SFXAutotuneTick;
 8012fd2:	6117      	str	r7, [r2, #16]
	freeFunctions[Vocoder] = SFXVocoderFree;
 8012fd4:	f640 0340 	movw	r3, #2112	; 0x840
	tickFunctions[SamplerButtonPress] = SFXSamplerBPTick;
 8012fd8:	6156      	str	r6, [r2, #20]
	freeFunctions[Vocoder] = SFXVocoderFree;
 8012fda:	f247 5751 	movw	r7, #30033	; 0x7551
	tickFunctions[SamplerKeyboard] = SFXSamplerKTick;
 8012fde:	6195      	str	r5, [r2, #24]
	freeFunctions[VocoderCh] = SFXVocoderChFree;
 8012fe0:	f248 56d9 	movw	r6, #34265	; 0x85d9
	tickFunctions[SamplerAutoGrab] = SFXSamplerAutoTick;
 8012fe4:	61d4      	str	r4, [r2, #28]
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
 8012fe6:	f648 15a5 	movw	r5, #35237	; 0x89a5
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
 8012fea:	f648 34d5 	movw	r4, #35797	; 0x8bd5
	freeFunctions[Vocoder] = SFXVocoderFree;
 8012fee:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8012ff2:	f6c0 0701 	movt	r7, #2049	; 0x801
	freeFunctions[VocoderCh] = SFXVocoderChFree;
 8012ff6:	f6c0 0601 	movt	r6, #2049	; 0x801
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
 8012ffa:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
 8012ffe:	f6c0 0401 	movt	r4, #2049	; 0x801
	freeFunctions[Vocoder] = SFXVocoderFree;
 8013002:	601f      	str	r7, [r3, #0]
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
 8013004:	f648 671d 	movw	r7, #36381	; 0x8e1d
	freeFunctions[VocoderCh] = SFXVocoderChFree;
 8013008:	605e      	str	r6, [r3, #4]
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
 801300a:	f249 2605 	movw	r6, #37381	; 0x9205
	freeFunctions[Pitchshift] = SFXPitchShiftFree;
 801300e:	609d      	str	r5, [r3, #8]
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
 8013010:	f649 6581 	movw	r5, #40577	; 0x9e81
	freeFunctions[AutotuneMono] = SFXNeartuneFree;
 8013014:	60dc      	str	r4, [r3, #12]
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
 8013016:	f24a 64f1 	movw	r4, #42737	; 0xa6f1
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
 801301a:	f6c0 0701 	movt	r7, #2049	; 0x801
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
 801301e:	f6c0 0601 	movt	r6, #2049	; 0x801
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
 8013022:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
 8013026:	f6c0 0401 	movt	r4, #2049	; 0x801
	freeFunctions[AutotunePoly] = SFXAutotuneFree;
 801302a:	611f      	str	r7, [r3, #16]

	allocFunctions[Distortion] = SFXDistortionAlloc;
 801302c:	f24a 7739 	movw	r7, #42809	; 0xa739
	freeFunctions[SamplerButtonPress] = SFXSamplerBPFree;
 8013030:	615e      	str	r6, [r3, #20]
	frameFunctions[Distortion] = SFXDistortionFrame;
 8013032:	f64a 062d 	movw	r6, #43053	; 0xa82d
	freeFunctions[SamplerKeyboard] = SFXSamplerKFree;
 8013036:	619d      	str	r5, [r3, #24]
	tickFunctions[Distortion] = SFXDistortionTick;
 8013038:	f64a 150d 	movw	r5, #43277	; 0xa90d
	freeFunctions[SamplerAutoGrab] = SFXSamplerAutoFree;
 801303c:	61dc      	str	r4, [r3, #28]
	freeFunctions[Distortion] = SFXDistortionFree;
 801303e:	f64a 2419 	movw	r4, #43545	; 0xaa19
	allocFunctions[Distortion] = SFXDistortionAlloc;
 8013042:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Distortion] = SFXDistortionFrame;
 8013046:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Distortion] = SFXDistortionTick;
 801304a:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Distortion] = SFXDistortionFree;
 801304e:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Distortion] = SFXDistortionAlloc;
 8013052:	6207      	str	r7, [r0, #32]

	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
 8013054:	f64a 2751 	movw	r7, #43601	; 0xaa51
	frameFunctions[Distortion] = SFXDistortionFrame;
 8013058:	620e      	str	r6, [r1, #32]
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
 801305a:	f64a 26bd 	movw	r6, #43709	; 0xaabd
	tickFunctions[Distortion] = SFXDistortionTick;
 801305e:	6215      	str	r5, [r2, #32]
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
 8013060:	f64a 25e9 	movw	r5, #43753	; 0xaae9
	freeFunctions[Distortion] = SFXDistortionFree;
 8013064:	621c      	str	r4, [r3, #32]
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
 8013066:	f64a 4429 	movw	r4, #44073	; 0xac29
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
 801306a:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
 801306e:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
 8013072:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
 8013076:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Wavefolder] = SFXWaveFolderAlloc;
 801307a:	6247      	str	r7, [r0, #36]	; 0x24

	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
 801307c:	f64a 4761 	movw	r7, #44129	; 0xac61
	frameFunctions[Wavefolder] = SFXWaveFolderFrame;
 8013080:	624e      	str	r6, [r1, #36]	; 0x24
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
 8013082:	f64a 4699 	movw	r6, #44185	; 0xac99
	tickFunctions[Wavefolder] = SFXWaveFolderTick;
 8013086:	6255      	str	r5, [r2, #36]	; 0x24
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
 8013088:	f64a 45c5 	movw	r5, #44229	; 0xacc5
	freeFunctions[Wavefolder] = SFXWaveFolderFree;
 801308c:	625c      	str	r4, [r3, #36]	; 0x24
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
 801308e:	f64a 6475 	movw	r4, #44661	; 0xae75
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
 8013092:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
 8013096:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
 801309a:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
 801309e:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[BitCrusher] = SFXBitcrusherAlloc;
 80130a2:	6287      	str	r7, [r0, #40]	; 0x28

	allocFunctions[Delay] = SFXDelayAlloc;
 80130a4:	f64a 6795 	movw	r7, #44693	; 0xae95
	frameFunctions[BitCrusher] = SFXBitcrusherFrame;
 80130a8:	628e      	str	r6, [r1, #40]	; 0x28
	frameFunctions[Delay] = SFXDelayFrame;
 80130aa:	f64a 76b1 	movw	r6, #44977	; 0xafb1
	tickFunctions[BitCrusher] = SFXBitcrusherTick;
 80130ae:	6295      	str	r5, [r2, #40]	; 0x28
	tickFunctions[Delay] = SFXDelayTick;
 80130b0:	f24b 051d 	movw	r5, #45085	; 0xb01d
	freeFunctions[BitCrusher] = SFXBitcrusherFree;
 80130b4:	629c      	str	r4, [r3, #40]	; 0x28
	freeFunctions[Delay] = SFXDelayFree;
 80130b6:	f24b 3419 	movw	r4, #45849	; 0xb319
	allocFunctions[Delay] = SFXDelayAlloc;
 80130ba:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Delay] = SFXDelayFrame;
 80130be:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Delay] = SFXDelayTick;
 80130c2:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Delay] = SFXDelayFree;
 80130c6:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Delay] = SFXDelayAlloc;
 80130ca:	62c7      	str	r7, [r0, #44]	; 0x2c

	allocFunctions[Reverb] = SFXReverbAlloc;
 80130cc:	f24b 3781 	movw	r7, #45953	; 0xb381
	frameFunctions[Delay] = SFXDelayFrame;
 80130d0:	62ce      	str	r6, [r1, #44]	; 0x2c
	frameFunctions[Reverb] = SFXReverbFrame;
 80130d2:	f24b 36dd 	movw	r6, #46045	; 0xb3dd
	tickFunctions[Delay] = SFXDelayTick;
 80130d6:	62d5      	str	r5, [r2, #44]	; 0x2c
	tickFunctions[Reverb] = SFXReverbTick;
 80130d8:	f24b 4589 	movw	r5, #46217	; 0xb489
	freeFunctions[Delay] = SFXDelayFree;
 80130dc:	62dc      	str	r4, [r3, #44]	; 0x2c
	freeFunctions[Reverb] = SFXReverbFree;
 80130de:	f24b 54b9 	movw	r4, #46521	; 0xb5b9
	allocFunctions[Reverb] = SFXReverbAlloc;
 80130e2:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Reverb] = SFXReverbFrame;
 80130e6:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Reverb] = SFXReverbTick;
 80130ea:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Reverb] = SFXReverbFree;
 80130ee:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Reverb] = SFXReverbAlloc;
 80130f2:	6307      	str	r7, [r0, #48]	; 0x30

	allocFunctions[Reverb2] = SFXReverb2Alloc;
 80130f4:	f24b 57d9 	movw	r7, #46553	; 0xb5d9
	frameFunctions[Reverb] = SFXReverbFrame;
 80130f8:	630e      	str	r6, [r1, #48]	; 0x30
	frameFunctions[Reverb2] = SFXReverb2Frame;
 80130fa:	f24b 66c1 	movw	r6, #46785	; 0xb6c1
	tickFunctions[Reverb] = SFXReverbTick;
 80130fe:	6315      	str	r5, [r2, #48]	; 0x30
	tickFunctions[Reverb2] = SFXReverb2Tick;
 8013100:	f24b 65c5 	movw	r5, #46789	; 0xb6c5
	freeFunctions[Reverb] = SFXReverbFree;
 8013104:	631c      	str	r4, [r3, #48]	; 0x30
	freeFunctions[Reverb2] = SFXReverb2Free;
 8013106:	f64b 04b5 	movw	r4, #47285	; 0xb8b5
	allocFunctions[Reverb2] = SFXReverb2Alloc;
 801310a:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Reverb2] = SFXReverb2Frame;
 801310e:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Reverb2] = SFXReverb2Tick;
 8013112:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Reverb2] = SFXReverb2Free;
 8013116:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Reverb2] = SFXReverb2Alloc;
 801311a:	6347      	str	r7, [r0, #52]	; 0x34

	allocFunctions[LivingString] = SFXLivingStringAlloc;
 801311c:	f64b 1711 	movw	r7, #47377	; 0xb911
	frameFunctions[Reverb2] = SFXReverb2Frame;
 8013120:	634e      	str	r6, [r1, #52]	; 0x34
	frameFunctions[LivingString] = SFXLivingStringFrame;
 8013122:	f64b 2631 	movw	r6, #47665	; 0xba31
	tickFunctions[Reverb2] = SFXReverb2Tick;
 8013126:	6355      	str	r5, [r2, #52]	; 0x34
	tickFunctions[LivingString] = SFXLivingStringTick;
 8013128:	f64b 65f5 	movw	r5, #48885	; 0xbef5
	freeFunctions[Reverb2] = SFXReverb2Free;
 801312c:	635c      	str	r4, [r3, #52]	; 0x34
	freeFunctions[LivingString] = SFXLivingStringFree;
 801312e:	f64b 7451 	movw	r4, #48977	; 0xbf51
	allocFunctions[LivingString] = SFXLivingStringAlloc;
 8013132:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[LivingString] = SFXLivingStringFrame;
 8013136:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[LivingString] = SFXLivingStringTick;
 801313a:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[LivingString] = SFXLivingStringFree;
 801313e:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[LivingString] = SFXLivingStringAlloc;
 8013142:	6387      	str	r7, [r0, #56]	; 0x38

	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
 8013144:	f64b 7779 	movw	r7, #49017	; 0xbf79
	frameFunctions[LivingString] = SFXLivingStringFrame;
 8013148:	638e      	str	r6, [r1, #56]	; 0x38
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
 801314a:	f24c 162d 	movw	r6, #49453	; 0xc12d
	tickFunctions[LivingString] = SFXLivingStringTick;
 801314e:	6395      	str	r5, [r2, #56]	; 0x38
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
 8013150:	f24c 45f9 	movw	r5, #50425	; 0xc4f9
	freeFunctions[LivingString] = SFXLivingStringFree;
 8013154:	639c      	str	r4, [r3, #56]	; 0x38
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
 8013156:	f24c 54d1 	movw	r4, #50641	; 0xc5d1
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
 801315a:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
 801315e:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
 8013162:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
 8013166:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[LivingStringSynth] = SFXLivingStringSynthAlloc;
 801316a:	63c7      	str	r7, [r0, #60]	; 0x3c

	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
 801316c:	f24c 6735 	movw	r7, #50741	; 0xc635
	frameFunctions[LivingStringSynth] = SFXLivingStringSynthFrame;
 8013170:	63ce      	str	r6, [r1, #60]	; 0x3c
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
 8013172:	f64c 16c1 	movw	r6, #51649	; 0xc9c1
	tickFunctions[LivingStringSynth] = SFXLivingStringSynthTick;
 8013176:	63d5      	str	r5, [r2, #60]	; 0x3c
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
 8013178:	f24d 15e9 	movw	r5, #53737	; 0xd1e9
	freeFunctions[LivingStringSynth] = SFXLivingStringSynthFree;
 801317c:	63dc      	str	r4, [r3, #60]	; 0x3c
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
 801317e:	f24d 3439 	movw	r4, #54073	; 0xd339
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
 8013182:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
 8013186:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
 801318a:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
 801318e:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[ClassicSynth] = SFXClassicSynthAlloc;
 8013192:	6407      	str	r7, [r0, #64]	; 0x40

	allocFunctions[Rhodes] = SFXRhodesAlloc;
 8013194:	f24d 37c1 	movw	r7, #54209	; 0xd3c1
	frameFunctions[ClassicSynth] = SFXClassicSynthFrame;
 8013198:	640e      	str	r6, [r1, #64]	; 0x40
	frameFunctions[Rhodes] = SFXRhodesFrame;
 801319a:	f24d 5669 	movw	r6, #54633	; 0xd569
	tickFunctions[ClassicSynth] = SFXClassicSynthTick;
 801319e:	6415      	str	r5, [r2, #64]	; 0x40
	tickFunctions[Rhodes] = SFXRhodesTick;
 80131a0:	f24e 0511 	movw	r5, #57361	; 0xe011
	freeFunctions[ClassicSynth] = SFXClassicSynthFree;
 80131a4:	641c      	str	r4, [r3, #64]	; 0x40
	freeFunctions[Rhodes] = SFXRhodesFree;
 80131a6:	f24e 34b1 	movw	r4, #58289	; 0xe3b1
	allocFunctions[Rhodes] = SFXRhodesAlloc;
 80131aa:	f6c0 0701 	movt	r7, #2049	; 0x801
	frameFunctions[Rhodes] = SFXRhodesFrame;
 80131ae:	f6c0 0601 	movt	r6, #2049	; 0x801
	tickFunctions[Rhodes] = SFXRhodesTick;
 80131b2:	f6c0 0501 	movt	r5, #2049	; 0x801
	freeFunctions[Rhodes] = SFXRhodesFree;
 80131b6:	f6c0 0401 	movt	r4, #2049	; 0x801
	allocFunctions[Rhodes] = SFXRhodesAlloc;
 80131ba:	6447      	str	r7, [r0, #68]	; 0x44
	frameFunctions[Rhodes] = SFXRhodesFrame;
 80131bc:	644e      	str	r6, [r1, #68]	; 0x44
	tickFunctions[Rhodes] = SFXRhodesTick;
 80131be:	6455      	str	r5, [r2, #68]	; 0x44
	freeFunctions[Rhodes] = SFXRhodesFree;
 80131c0:	645c      	str	r4, [r3, #68]	; 0x44
}
 80131c2:	bcf0      	pop	{r4, r5, r6, r7}
 80131c4:	4770      	bx	lr
 80131c6:	bf00      	nop

080131c8 <audioInit>:
{
 80131c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
 80131cc:	f44f 4400 	mov.w	r4, #32768	; 0x8000
{
 80131d0:	4688      	mov	r8, r1
 80131d2:	4617      	mov	r7, r2
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
 80131d4:	f245 5351 	movw	r3, #21841	; 0x5551
 80131d8:	f2c4 743b 	movt	r4, #18235	; 0x473b
 80131dc:	f64e 3258 	movw	r2, #60248	; 0xeb58
 80131e0:	f240 0100 	movw	r1, #0
 80131e4:	f6c0 0301 	movt	r3, #2049	; 0x801
 80131e8:	ee00 4a10 	vmov	s0, r4
 80131ec:	f2c0 0207 	movt	r2, #7
 80131f0:	f2c2 4100 	movt	r1, #9216	; 0x2400
{
 80131f4:	4606      	mov	r6, r0
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
 80131f6:	2080      	movs	r0, #128	; 0x80
 80131f8:	f248 74f8 	movw	r4, #34808	; 0x87f8
{
 80131fc:	ed2d 8b02 	vpush	{d8}
 8013200:	b086      	sub	sp, #24
 8013202:	f2c2 0401 	movt	r4, #8193	; 0x2001
	LEAF_init(SAMPLE_RATE, AUDIO_FRAME_SIZE, medium_memory, MED_MEM_SIZE, &randomNumber);
 8013206:	f017 fcfd 	bl	802ac04 <LEAF_init>
	tMempool_init (&smallPool, small_memory, SMALL_MEM_SIZE);
 801320a:	f643 12c8 	movw	r2, #14792	; 0x39c8
 801320e:	f243 615c 	movw	r1, #13916	; 0x365c
 8013212:	f248 20f8 	movw	r0, #33528	; 0x82f8
 8013216:	f2c0 0201 	movt	r2, #1
 801321a:	f104 0518 	add.w	r5, r4, #24
 801321e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8013222:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8013226:	f014 fef9 	bl	802801c <tMempool_init>
	tMempool_init (&largePool, large_memory, LARGE_MEM_SIZE);
 801322a:	f240 0100 	movw	r1, #0
 801322e:	f247 5010 	movw	r0, #29968	; 0x7510
 8013232:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 8013236:	f2c6 0100 	movt	r1, #24576	; 0x6000
 801323a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801323e:	f014 feed 	bl	802801c <tMempool_init>
	initFunctionPointers();
 8013242:	f7ff fe45 	bl	8012ed0 <initFunctionPointers>
		tExpSmooth_init(&adc[i], 0.0f, 0.2f);
 8013246:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801324a:	2200      	movs	r2, #0
 801324c:	f6c3 634c 	movt	r3, #15948	; 0x3e4c
 8013250:	ee08 2a90 	vmov	s17, r2
 8013254:	ee08 3a10 	vmov	s16, r3
 8013258:	4620      	mov	r0, r4
 801325a:	3404      	adds	r4, #4
 801325c:	eef0 0a48 	vmov.f32	s1, s16
 8013260:	eeb0 0a68 	vmov.f32	s0, s17
 8013264:	f012 fe2e 	bl	8025ec4 <tExpSmooth_init>
	for (int i = 0; i < 6; i++)
 8013268:	42ac      	cmp	r4, r5
 801326a:	d1f5      	bne.n	8013258 <audioInit+0x90>
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
 801326c:	f64d 723b 	movw	r2, #57147	; 0xdf3b
 8013270:	f24b 7317 	movw	r3, #46871	; 0xb717
 8013274:	f640 1020 	movw	r0, #2336	; 0x920
	loadingPreset = 1;
 8013278:	2401      	movs	r4, #1
		tEnvelopeFollower_init(&LED_envelope[i], 0.0001f, .9995f);
 801327a:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
 801327e:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8013282:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013286:	ee00 2a90 	vmov	s1, r2
 801328a:	ee00 3a10 	vmov	s0, r3
 801328e:	f00e ff77 	bl	8022180 <tEnvelopeFollower_init>
 8013292:	f64d 723b 	movw	r2, #57147	; 0xdf3b
 8013296:	f24b 7317 	movw	r3, #46871	; 0xb717
 801329a:	f640 1024 	movw	r0, #2340	; 0x924
 801329e:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
 80132a2:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 80132a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80132aa:	ee00 2a90 	vmov	s1, r2
 80132ae:	ee00 3a10 	vmov	s0, r3
 80132b2:	f00e ff65 	bl	8022180 <tEnvelopeFollower_init>
 80132b6:	f64d 723b 	movw	r2, #57147	; 0xdf3b
 80132ba:	f24b 7317 	movw	r3, #46871	; 0xb717
 80132be:	f640 1028 	movw	r0, #2344	; 0x928
 80132c2:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
 80132c6:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 80132ca:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80132ce:	ee00 2a90 	vmov	s1, r2
 80132d2:	ee00 3a10 	vmov	s0, r3
 80132d6:	f00e ff53 	bl	8022180 <tEnvelopeFollower_init>
 80132da:	f64d 723b 	movw	r2, #57147	; 0xdf3b
 80132de:	f24b 7317 	movw	r3, #46871	; 0xb717
 80132e2:	f640 102c 	movw	r0, #2348	; 0x92c
 80132e6:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
 80132ea:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 80132ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80132f2:	ee00 2a90 	vmov	s1, r2
 80132f6:	ee00 3a10 	vmov	s0, r3
 80132fa:	f00e ff41 	bl	8022180 <tEnvelopeFollower_init>
	LEAF_generate_atodbPositiveClipped(atodbTable, -120.0f, 380.f, ATODB_TABLE_SIZE);
 80132fe:	2200      	movs	r2, #0
 8013300:	f640 1030 	movw	r0, #2352	; 0x930
 8013304:	f44f 7100 	mov.w	r1, #512	; 0x200
 8013308:	4613      	mov	r3, r2
 801330a:	f2c4 32be 	movt	r2, #17342	; 0x43be
 801330e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013312:	f2cc 23f0 	movt	r3, #49904	; 0xc2f0
 8013316:	ee00 2a90 	vmov	s1, r2
 801331a:	ee00 3a10 	vmov	s0, r3
 801331e:	f014 fbe9 	bl	8027af4 <LEAF_generate_atodbPositiveClipped>
	initGlobalSFXObjects();
 8013322:	f003 faf3 	bl	801690c <initGlobalSFXObjects>
	loadingPreset = 1;
 8013326:	f240 6257 	movw	r2, #1623	; 0x657
	previousPreset = PresetNil;
 801332a:	f240 23cc 	movw	r3, #716	; 0x2cc
 801332e:	2112      	movs	r1, #18
	loadingPreset = 1;
 8013330:	f2c2 0200 	movt	r2, #8192	; 0x2000
	HAL_Delay(10);
 8013334:	200a      	movs	r0, #10
	previousPreset = PresetNil;
 8013336:	f2c2 0300 	movt	r3, #8192	; 0x2000
	loadingPreset = 1;
 801333a:	7014      	strb	r4, [r2, #0]
	previousPreset = PresetNil;
 801333c:	7019      	strb	r1, [r3, #0]
	HAL_Delay(10);
 801333e:	f7ed fb83 	bl	8000a48 <HAL_Delay>
 8013342:	f640 0080 	movw	r0, #2176	; 0x880
 8013346:	f44f 6200 	mov.w	r2, #2048	; 0x800
 801334a:	2100      	movs	r1, #0
 801334c:	f2c3 0000 	movt	r0, #12288	; 0x3000
 8013350:	f017 fcd3 	bl	802acfa <memset>
	HAL_Delay(1);
 8013354:	4620      	mov	r0, r4
 8013356:	f7ed fb77 	bl	8000a48 <HAL_Delay>
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
 801335a:	f640 0180 	movw	r1, #2176	; 0x880
 801335e:	4640      	mov	r0, r8
 8013360:	f44f 7200 	mov.w	r2, #512	; 0x200
 8013364:	f2c3 0100 	movt	r1, #12288	; 0x3000
 8013368:	f7f9 f834 	bl	800c3d4 <HAL_SAI_Transmit_DMA>
 801336c:	f640 033c 	movw	r3, #2108	; 0x83c
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
 8013370:	f240 0180 	movw	r1, #128	; 0x80
 8013374:	f44f 7200 	mov.w	r2, #512	; 0x200
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
 8013378:	f2c2 0300 	movt	r3, #8192	; 0x2000
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
 801337c:	f2c3 0100 	movt	r1, #12288	; 0x3000
	transmit_status = HAL_SAI_Transmit_DMA(hsaiOut, (uint8_t *)&audioOutBuffer[0], AUDIO_BUFFER_SIZE);
 8013380:	7018      	strb	r0, [r3, #0]
	receive_status = HAL_SAI_Receive_DMA(hsaiIn, (uint8_t *)&audioInBuffer[0], AUDIO_BUFFER_SIZE);
 8013382:	4638      	mov	r0, r7
 8013384:	f7f9 f8ba 	bl	800c4fc <HAL_SAI_Receive_DMA>
 8013388:	f640 03d4 	movw	r3, #2260	; 0x8d4
 801338c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013390:	7018      	strb	r0, [r3, #0]
	AudioCodec_init(hi2c);
 8013392:	4630      	mov	r0, r6
 8013394:	f000 f8b4 	bl	8013500 <AudioCodec_init>
	HAL_Delay(1);
 8013398:	4620      	mov	r0, r4
 801339a:	f7ed fb55 	bl	8000a48 <HAL_Delay>
	HAL_I2C_MspDeInit(hi2c);
 801339e:	4630      	mov	r0, r6
 80133a0:	f001 ff62 	bl	8015268 <HAL_I2C_MspDeInit>
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80133a4:	f44f 6080 	mov.w	r0, #1024	; 0x400
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 80133a8:	2300      	movs	r3, #0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80133aa:	f44f 6240 	mov.w	r2, #3072	; 0xc00
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80133ae:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80133b2:	a901      	add	r1, sp, #4
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 80133b4:	9302      	str	r3, [sp, #8]
 80133b6:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 80133b8:	9201      	str	r2, [sp, #4]
	GPIO_InitTypeDef GPIO_InitStruct = {0};
 80133ba:	e9cd 4303 	strd	r4, r3, [sp, #12]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 80133be:	f7f2 fd91 	bl	8005ee4 <HAL_GPIO_Init>
}
 80133c2:	b006      	add	sp, #24
 80133c4:	ecbd 8b02 	vpop	{d8}
 80133c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080133cc <HAL_SAI_ErrorCallback>:



void HAL_SAI_ErrorCallback(SAI_HandleTypeDef *hsai)
{
	setLED_Edit(1);
 80133cc:	2001      	movs	r0, #1
 80133ce:	f002 ba4d 	b.w	801586c <setLED_Edit>
 80133d2:	bf00      	nop

080133d4 <HAL_SAI_TxCpltCallback>:
 80133d4:	4770      	bx	lr
 80133d6:	bf00      	nop

080133d8 <HAL_SAI_TxHalfCpltCallback>:
}

void HAL_SAI_TxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{

}
 80133d8:	4770      	bx	lr
 80133da:	bf00      	nop

080133dc <HAL_SAI_RxCpltCallback>:


void HAL_SAI_RxCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(HALF_BUFFER_SIZE);
 80133dc:	f44f 7080 	mov.w	r0, #256	; 0x100
 80133e0:	f7ff baec 	b.w	80129bc <audioFrame>

080133e4 <HAL_SAI_RxHalfCpltCallback>:
}

void HAL_SAI_RxHalfCpltCallback(SAI_HandleTypeDef *hsai)
{
	audioFrame(0);
 80133e4:	2000      	movs	r0, #0
 80133e6:	f7ff bae9 	b.w	80129bc <audioFrame>
 80133ea:	bf00      	nop

080133ec <MX_BDMA_Init>:
  */
void MX_BDMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_BDMA_CLK_ENABLE();
 80133ec:	f44f 4388 	mov.w	r3, #17408	; 0x4400

  /* DMA interrupt init */
  /* BDMA_Channel0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
 80133f0:	2200      	movs	r2, #0
 80133f2:	2081      	movs	r0, #129	; 0x81
  __HAL_RCC_BDMA_CLK_ENABLE();
 80133f4:	f6c5 0302 	movt	r3, #22530	; 0x5802
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
 80133f8:	4611      	mov	r1, r2
{
 80133fa:	b510      	push	{r4, lr}
  __HAL_RCC_BDMA_CLK_ENABLE();
 80133fc:	f8d3 40e0 	ldr.w	r4, [r3, #224]	; 0xe0
{
 8013400:	b082      	sub	sp, #8
  __HAL_RCC_BDMA_CLK_ENABLE();
 8013402:	f444 1400 	orr.w	r4, r4, #2097152	; 0x200000
 8013406:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
 801340a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 801340e:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8013412:	9301      	str	r3, [sp, #4]
 8013414:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(BDMA_Channel0_IRQn, 0, 0);
 8013416:	f7ef f8d3 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel0_IRQn);
 801341a:	2081      	movs	r0, #129	; 0x81
 801341c:	f7ef f920 	bl	8002660 <HAL_NVIC_EnableIRQ>
  /* BDMA_Channel1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BDMA_Channel1_IRQn, 0, 0);
 8013420:	2200      	movs	r2, #0
 8013422:	2082      	movs	r0, #130	; 0x82
 8013424:	4611      	mov	r1, r2
 8013426:	f7ef f8cb 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
 801342a:	2082      	movs	r0, #130	; 0x82

}
 801342c:	b002      	add	sp, #8
 801342e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(BDMA_Channel1_IRQn);
 8013432:	f7ef b915 	b.w	8002660 <HAL_NVIC_EnableIRQ>
 8013436:	bf00      	nop

08013438 <BSP_SD_ReadBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to read
  * @param  Timeout: Timeout for read operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_ReadBlocks(uint32_t *pData, uint32_t ReadAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 8013438:	b500      	push	{lr}
 801343a:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
 801343c:	9300      	str	r3, [sp, #0]
 801343e:	4613      	mov	r3, r2
 8013440:	460a      	mov	r2, r1
 8013442:	4601      	mov	r1, r0
 8013444:	f641 60c8 	movw	r0, #7880	; 0x1ec8
 8013448:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801344c:	f7f9 fae6 	bl	800ca1c <HAL_SD_ReadBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
 8013450:	3000      	adds	r0, #0
 8013452:	bf18      	it	ne
 8013454:	2001      	movne	r0, #1
 8013456:	b003      	add	sp, #12
 8013458:	f85d fb04 	ldr.w	pc, [sp], #4

0801345c <BSP_SD_WriteBlocks>:
  * @param  NumOfBlocks: Number of SD blocks to write
  * @param  Timeout: Timeout for write operation
  * @retval SD status
  */
__weak uint8_t BSP_SD_WriteBlocks(uint32_t *pData, uint32_t WriteAddr, uint32_t NumOfBlocks, uint32_t Timeout)
{
 801345c:	b500      	push	{lr}
 801345e:	b083      	sub	sp, #12
  uint8_t sd_state = MSD_OK;

  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
 8013460:	9300      	str	r3, [sp, #0]
 8013462:	4613      	mov	r3, r2
 8013464:	460a      	mov	r2, r1
 8013466:	4601      	mov	r1, r0
 8013468:	f641 60c8 	movw	r0, #7880	; 0x1ec8
 801346c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8013470:	f7f9 fbf0 	bl	800cc54 <HAL_SD_WriteBlocks>
  {
    sd_state = MSD_ERROR;
  }

  return sd_state;  
}
 8013474:	3000      	adds	r0, #0
 8013476:	bf18      	it	ne
 8013478:	2001      	movne	r0, #1
 801347a:	b003      	add	sp, #12
 801347c:	f85d fb04 	ldr.w	pc, [sp], #4

08013480 <BSP_SD_GetCardState>:
  *            @arg  SD_TRANSFER_OK: No data transfer is acting
  *            @arg  SD_TRANSFER_BUSY: Data transfer is acting
  */
__weak uint8_t BSP_SD_GetCardState(void)
{
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 8013480:	f641 60c8 	movw	r0, #7880	; 0x1ec8
{
 8013484:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 8013486:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801348a:	f7fa f9bd 	bl	800d808 <HAL_SD_GetCardState>
}
 801348e:	3804      	subs	r0, #4
 8013490:	bf18      	it	ne
 8013492:	2001      	movne	r0, #1
 8013494:	bd08      	pop	{r3, pc}
 8013496:	bf00      	nop

08013498 <BSP_SD_GetCardInfo>:
  * @retval None 
  */
__weak void BSP_SD_GetCardInfo(HAL_SD_CardInfoTypeDef *CardInfo)
{
  /* Get SD card Information */
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
 8013498:	4601      	mov	r1, r0
 801349a:	f641 60c8 	movw	r0, #7880	; 0x1ec8
 801349e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80134a2:	f7fa b80d 	b.w	800d4c0 <HAL_SD_GetCardInfo>
 80134a6:	bf00      	nop

080134a8 <BSP_SD_IsDetected>:
 * @brief  Detects if SD card is correctly plugged in the memory slot or not.
 * @param  None
 * @retval Returns if SD is detected or not
 */
__weak uint8_t BSP_SD_IsDetected(void)
{
 80134a8:	b500      	push	{lr}
  __IO uint8_t status = SD_PRESENT;
 80134aa:	2301      	movs	r3, #1
{
 80134ac:	b083      	sub	sp, #12
  __IO uint8_t status = SD_PRESENT;
 80134ae:	f88d 3007 	strb.w	r3, [sp, #7]

  if (BSP_PlatformIsDetected() == 0x0) 
 80134b2:	f000 fcc3 	bl	8013e3c <BSP_PlatformIsDetected>
 80134b6:	b908      	cbnz	r0, 80134bc <BSP_SD_IsDetected+0x14>
  {
    status = SD_NOT_PRESENT;
 80134b8:	f88d 0007 	strb.w	r0, [sp, #7]
  }

  return status;
 80134bc:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 80134c0:	b003      	add	sp, #12
 80134c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80134c6:	bf00      	nop

080134c8 <BSP_SD_Init>:
{
 80134c8:	b508      	push	{r3, lr}
  if (BSP_SD_IsDetected() != SD_PRESENT)
 80134ca:	f7ff ffed 	bl	80134a8 <BSP_SD_IsDetected>
 80134ce:	2801      	cmp	r0, #1
 80134d0:	d001      	beq.n	80134d6 <BSP_SD_Init+0xe>
    return MSD_ERROR_SD_NOT_PRESENT;
 80134d2:	2002      	movs	r0, #2
}
 80134d4:	bd08      	pop	{r3, pc}
  sd_state = HAL_SD_Init(&hsd1);
 80134d6:	f641 60c8 	movw	r0, #7880	; 0x1ec8
 80134da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80134de:	f7fa f8b9 	bl	800d654 <HAL_SD_Init>
  if (sd_state == MSD_OK)
 80134e2:	2800      	cmp	r0, #0
 80134e4:	d1f6      	bne.n	80134d4 <BSP_SD_Init+0xc>
    if (HAL_SD_ConfigWideBusOperation(&hsd1, SDMMC_BUS_WIDE_4B) != HAL_OK)
 80134e6:	f641 60c8 	movw	r0, #7880	; 0x1ec8
 80134ea:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 80134ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80134f2:	f7f9 fff9 	bl	800d4e8 <HAL_SD_ConfigWideBusOperation>
    return MSD_ERROR_SD_NOT_PRESENT;
 80134f6:	3000      	adds	r0, #0
 80134f8:	bf18      	it	ne
 80134fa:	2001      	movne	r0, #1
}
 80134fc:	bd08      	pop	{r3, pc}
 80134fe:	bf00      	nop

08013500 <AudioCodec_init>:

volatile int blankCount = 0;
uint16_t addressCounter = 0;


void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
 8013500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8013504:	4680      	mov	r8, r0

	HAL_Delay(2);
	//enable control port and put part in power-down mode while loading registers
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x03;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013506:	f240 0510 	movw	r5, #16
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
 801350a:	f44f 6000 	mov.w	r0, #2048	; 0x800
void AudioCodec_init(I2C_HandleTypeDef* hi2c) {
 801350e:	b082      	sub	sp, #8
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013510:	f2c2 0500 	movt	r5, #8192	; 0x2000
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
 8013514:	2201      	movs	r2, #1
 8013516:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 801351a:	f6c5 0002 	movt	r0, #22530	; 0x5802
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801351e:	f240 0614 	movw	r6, #20
	myI2cData[0] = 0x07;
 8013522:	f240 5400 	movw	r4, #1280	; 0x500
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_SET);
 8013526:	f7f3 f887 	bl	8006638 <HAL_GPIO_WritePin>
	HAL_Delay(2);
 801352a:	2002      	movs	r0, #2
	myI2cData[0] = 0x07;
 801352c:	f2c2 0400 	movt	r4, #8192	; 0x2000
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013530:	f2c2 0600 	movt	r6, #8192	; 0x2000
	HAL_Delay(2);
 8013534:	f7ed fa88 	bl	8000a48 <HAL_Delay>
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013538:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x07;
 801353a:	f240 3c07 	movw	ip, #775	; 0x307
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801353e:	f241 1730 	movw	r7, #4400	; 0x1130
 8013542:	8833      	ldrh	r3, [r6, #0]
 8013544:	4622      	mov	r2, r4
 8013546:	9100      	str	r1, [sp, #0]
 8013548:	4640      	mov	r0, r8
 801354a:	2120      	movs	r1, #32
 801354c:	f2c2 0700 	movt	r7, #8192	; 0x2000
	myI2cData[0] = 0x07;
 8013550:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013554:	f7f3 ff56 	bl	8007404 <HAL_I2C_Master_Transmit>
	//HAL_Delay(2);

	myI2cData[0] = 0x01;
	myI2cData[1] = 0x41;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013558:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x01;
 801355a:	f244 1c01 	movw	ip, #16641	; 0x4101
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801355e:	8833      	ldrh	r3, [r6, #0]
 8013560:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013562:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013564:	4640      	mov	r0, r8
 8013566:	9100      	str	r1, [sp, #0]
 8013568:	2120      	movs	r1, #32
	myI2cData[0] = 0x01;
 801356a:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801356e:	f7f3 ff49 	bl	8007404 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x02;
	myI2cData[1] = 0x00;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013572:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x02;
 8013574:	f04f 0c02 	mov.w	ip, #2
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013578:	8833      	ldrh	r3, [r6, #0]
 801357a:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801357c:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801357e:	4640      	mov	r0, r8
 8013580:	9200      	str	r2, [sp, #0]
 8013582:	4622      	mov	r2, r4
	myI2cData[0] = 0x02;
 8013584:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013588:	f7f3 ff3c 	bl	8007404 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x03;
	myI2cData[1] = 0x79;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 801358c:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x03;
 801358e:	f647 1c03 	movw	ip, #30979	; 0x7903
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013592:	8833      	ldrh	r3, [r6, #0]
 8013594:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013596:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013598:	4640      	mov	r0, r8
 801359a:	9100      	str	r1, [sp, #0]
 801359c:	2120      	movs	r1, #32
	myI2cData[0] = 0x03;
 801359e:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135a2:	f7f3 ff2f 	bl	8007404 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x04;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135a6:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x04;
 80135a8:	f44f 7c82 	mov.w	ip, #260	; 0x104
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135ac:	8833      	ldrh	r3, [r6, #0]
 80135ae:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135b0:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135b2:	4640      	mov	r0, r8
 80135b4:	9200      	str	r2, [sp, #0]
 80135b6:	4622      	mov	r2, r4
	myI2cData[0] = 0x04;
 80135b8:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135bc:	f7f3 ff22 	bl	8007404 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x05;
	myI2cData[1] = 0x01;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135c0:	6829      	ldr	r1, [r5, #0]
	myI2cData[0] = 0x05;
 80135c2:	f240 1c05 	movw	ip, #261	; 0x105
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135c6:	8833      	ldrh	r3, [r6, #0]
 80135c8:	4622      	mov	r2, r4
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135ca:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135cc:	4640      	mov	r0, r8
 80135ce:	9100      	str	r1, [sp, #0]
 80135d0:	2120      	movs	r1, #32
	myI2cData[0] = 0x05;
 80135d2:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135d6:	f7f3 ff15 	bl	8007404 <HAL_I2C_Master_Transmit>

	//HAL_Delay(1); // might not be necessary

	myI2cData[0] = 0x06;
	myI2cData[1] = 0x10;
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135da:	682a      	ldr	r2, [r5, #0]
	myI2cData[0] = 0x06;
 80135dc:	f241 0c06 	movw	ip, #4102	; 0x1006
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135e0:	8833      	ldrh	r3, [r6, #0]
 80135e2:	2120      	movs	r1, #32
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135e4:	7038      	strb	r0, [r7, #0]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135e6:	4640      	mov	r0, r8
 80135e8:	9200      	str	r2, [sp, #0]
 80135ea:	4622      	mov	r2, r4
	myI2cData[0] = 0x06;
 80135ec:	f8a4 c000 	strh.w	ip, [r4]
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135f0:	f7f3 ff08 	bl	8007404 <HAL_I2C_Master_Transmit>
	//HAL_Delay(1); // might not be necessary

	//turn off power down bit to start things cookin'
	myI2cData[0] = 0x07;
	myI2cData[1] = 0x02;
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135f4:	6829      	ldr	r1, [r5, #0]
 80135f6:	4622      	mov	r2, r4
 80135f8:	8833      	ldrh	r3, [r6, #0]
	myI2cData[0] = 0x07;
 80135fa:	f240 2607 	movw	r6, #519	; 0x207
	testVal = HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 80135fe:	7038      	strb	r0, [r7, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013600:	4640      	mov	r0, r8
 8013602:	9100      	str	r1, [sp, #0]
 8013604:	2120      	movs	r1, #32
	myI2cData[0] = 0x07;
 8013606:	8026      	strh	r6, [r4, #0]
	HAL_I2C_Master_Transmit(hi2c, CODEC_I2C_ADDRESS, myI2cData, i2cDataSize, I2Ctimeout);
 8013608:	f7f3 fefc 	bl	8007404 <HAL_I2C_Master_Transmit>


	//HAL_Delay(1); // might not be necessary
	codecReady = 1;
 801360c:	f240 43f8 	movw	r3, #1272	; 0x4f8
 8013610:	2201      	movs	r2, #1
 8013612:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013616:	701a      	strb	r2, [r3, #0]

}
 8013618:	b002      	add	sp, #8
 801361a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801361e:	bf00      	nop

08013620 <MX_DMA_Init>:
  */
void MX_DMA_Init(void) 
{

  /* DMA controller clock enable */
  __HAL_RCC_DMA2_CLK_ENABLE();
 8013620:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  __HAL_RCC_DMA1_CLK_ENABLE();

  /* DMA interrupt init */
  /* DMA1_Stream1_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
 8013624:	2200      	movs	r2, #0
 8013626:	2103      	movs	r1, #3
 8013628:	200c      	movs	r0, #12
  __HAL_RCC_DMA2_CLK_ENABLE();
 801362a:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
 801362e:	b510      	push	{r4, lr}
  __HAL_RCC_DMA2_CLK_ENABLE();
 8013630:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
{
 8013634:	b082      	sub	sp, #8
  __HAL_RCC_DMA2_CLK_ENABLE();
 8013636:	f044 0402 	orr.w	r4, r4, #2
 801363a:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
 801363e:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
 8013642:	f004 0402 	and.w	r4, r4, #2
 8013646:	9400      	str	r4, [sp, #0]
 8013648:	9c00      	ldr	r4, [sp, #0]
  __HAL_RCC_DMA1_CLK_ENABLE();
 801364a:	f8d3 40d8 	ldr.w	r4, [r3, #216]	; 0xd8
 801364e:	f044 0401 	orr.w	r4, r4, #1
 8013652:	f8c3 40d8 	str.w	r4, [r3, #216]	; 0xd8
 8013656:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 801365a:	f003 0301 	and.w	r3, r3, #1
 801365e:	9301      	str	r3, [sp, #4]
 8013660:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 3, 0);
 8013662:	f7ee ffad 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
 8013666:	200c      	movs	r0, #12
 8013668:	f7ee fffa 	bl	8002660 <HAL_NVIC_EnableIRQ>
  /* DMA1_Stream2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA1_Stream2_IRQn, 3, 0);
 801366c:	2200      	movs	r2, #0
 801366e:	2103      	movs	r1, #3
 8013670:	200d      	movs	r0, #13
 8013672:	f7ee ffa5 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Stream2_IRQn);
 8013676:	200d      	movs	r0, #13
 8013678:	f7ee fff2 	bl	8002660 <HAL_NVIC_EnableIRQ>
  /* DMA2_Stream0_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 4, 0);
 801367c:	2200      	movs	r2, #0
 801367e:	2104      	movs	r1, #4
 8013680:	2038      	movs	r0, #56	; 0x38
 8013682:	f7ee ff9d 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
 8013686:	2038      	movs	r0, #56	; 0x38
 8013688:	f7ee ffea 	bl	8002660 <HAL_NVIC_EnableIRQ>
  /* DMAMUX1_OVR_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DMAMUX1_OVR_IRQn, 0, 0);
 801368c:	2200      	movs	r2, #0
 801368e:	2066      	movs	r0, #102	; 0x66
 8013690:	4611      	mov	r1, r2
 8013692:	f7ee ff95 	bl	80025c0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
 8013696:	2066      	movs	r0, #102	; 0x66

}
 8013698:	b002      	add	sp, #8
 801369a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_NVIC_EnableIRQ(DMAMUX1_OVR_IRQn);
 801369e:	f7ee bfdf 	b.w	8002660 <HAL_NVIC_EnableIRQ>
 80136a2:	bf00      	nop

080136a4 <EE_VerifyPageFullWriteVariable>:
  *           - PAGE_FULL: if valid page is full
  *           - NO_VALID_PAGE: if no valid page was found
  *           - Flash error code: on write Flash error
  */
static uint16_t EE_VerifyPageFullWriteVariable(uint16_t VirtAddress, uint16_t Data)
{
 80136a4:	b510      	push	{r4, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80136a6:	2400      	movs	r4, #0
{
 80136a8:	b090      	sub	sp, #64	; 0x40
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80136aa:	4622      	mov	r2, r4
  HAL_StatusTypeDef FlashStatus = HAL_OK;
  uint16_t ValidPage = PAGE0;
  uint32_t Address = EEPROM_START_ADDRESS, PageEndAddress = EEPROM_START_ADDRESS+PAGE_SIZE;

  uint32_t data32[8] = {Data};
 80136ac:	4623      	mov	r3, r4
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80136ae:	f6c0 041c 	movt	r4, #2076	; 0x81c
  uint32_t data32[8] = {Data};
 80136b2:	9100      	str	r1, [sp, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80136b4:	f6c0 021e 	movt	r2, #2078	; 0x81e
  uint32_t VirtAddress1[8] = {VirtAddress};
 80136b8:	9008      	str	r0, [sp, #32]
  uint32_t data32[8] = {Data};
 80136ba:	9307      	str	r3, [sp, #28]
  uint32_t VirtAddress1[8] = {VirtAddress};
 80136bc:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t data32[8] = {Data};
 80136be:	e9cd 3301 	strd	r3, r3, [sp, #4]
 80136c2:	e9cd 3303 	strd	r3, r3, [sp, #12]
 80136c6:	e9cd 3305 	strd	r3, r3, [sp, #20]
  uint32_t VirtAddress1[8] = {VirtAddress};
 80136ca:	e9cd 3309 	strd	r3, r3, [sp, #36]	; 0x24
 80136ce:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 80136d2:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80136d6:	8824      	ldrh	r4, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80136d8:	8813      	ldrh	r3, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80136da:	b2a4      	uxth	r4, r4
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80136dc:	b29b      	uxth	r3, r3
      if (PageStatus1 == VALID_PAGE)
 80136de:	bb03      	cbnz	r3, 8013722 <EE_VerifyPageFullWriteVariable+0x7e>
        if (PageStatus0 == RECEIVE_DATA)
 80136e0:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
 80136e4:	1ae4      	subs	r4, r4, r3
 80136e6:	bf18      	it	ne
 80136e8:	2401      	movne	r4, #1

  /* Get the valid Page start Address */
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));

  /* Get the valid Page end Address */
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 80136ea:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80136ee:	1c63      	adds	r3, r4, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80136f0:	f204 440e 	addw	r4, r4, #1038	; 0x40e
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 80136f4:	f6c0 021b 	movt	r2, #2075	; 0x81b
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 80136f8:	0464      	lsls	r4, r4, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 80136fa:	eb02 4243 	add.w	r2, r2, r3, lsl #17

  /* Check each active page address starting from begining */
  while (Address < PageEndAddress)
 80136fe:	4294      	cmp	r4, r2
 8013700:	d303      	bcc.n	801370a <EE_VerifyPageFullWriteVariable+0x66>
 8013702:	e016      	b.n	8013732 <EE_VerifyPageFullWriteVariable+0x8e>
     return FlashStatus;
    }
    else
    {
      /* Next address location */
      Address = Address + 64;
 8013704:	3440      	adds	r4, #64	; 0x40
  while (Address < PageEndAddress)
 8013706:	42a2      	cmp	r2, r4
 8013708:	d913      	bls.n	8013732 <EE_VerifyPageFullWriteVariable+0x8e>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 801370a:	6823      	ldr	r3, [r4, #0]
 801370c:	3301      	adds	r3, #1
 801370e:	d1f9      	bne.n	8013704 <EE_VerifyPageFullWriteVariable+0x60>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
 8013710:	466a      	mov	r2, sp
 8013712:	4621      	mov	r1, r4
 8013714:	2001      	movs	r0, #1
 8013716:	f7f2 f913 	bl	8005940 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
 801371a:	b180      	cbz	r0, 801373e <EE_VerifyPageFullWriteVariable+0x9a>
     return FlashStatus;
 801371c:	b280      	uxth	r0, r0
    }
  }

  /* Return PAGE_FULL in case the valid page is full */
  return PAGE_FULL;
}
 801371e:	b010      	add	sp, #64	; 0x40
 8013720:	bd10      	pop	{r4, pc}
      else if (PageStatus0 == VALID_PAGE)
 8013722:	b94c      	cbnz	r4, 8013738 <EE_VerifyPageFullWriteVariable+0x94>
        if (PageStatus1 == RECEIVE_DATA)
 8013724:	f64e 64ee 	movw	r4, #61166	; 0xeeee
          return PAGE0;         /* Page0 valid */
 8013728:	1b1c      	subs	r4, r3, r4
 801372a:	fab4 f484 	clz	r4, r4
 801372e:	0964      	lsrs	r4, r4, #5
 8013730:	e7db      	b.n	80136ea <EE_VerifyPageFullWriteVariable+0x46>
  return PAGE_FULL;
 8013732:	2080      	movs	r0, #128	; 0x80
}
 8013734:	b010      	add	sp, #64	; 0x40
 8013736:	bd10      	pop	{r4, pc}
    return  NO_VALID_PAGE;
 8013738:	20ab      	movs	r0, #171	; 0xab
}
 801373a:	b010      	add	sp, #64	; 0x40
 801373c:	bd10      	pop	{r4, pc}
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
 801373e:	f104 0120 	add.w	r1, r4, #32
 8013742:	aa08      	add	r2, sp, #32
 8013744:	2001      	movs	r0, #1
 8013746:	f7f2 f8fb 	bl	8005940 <HAL_FLASH_Program>
 801374a:	e7e7      	b.n	801371c <EE_VerifyPageFullWriteVariable+0x78>

0801374c <EE_Init>:
{
 801374c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013750:	2400      	movs	r4, #0
{
 8013752:	b09f      	sub	sp, #124	; 0x7c
  uint32_t valid[8] = {0x0000};
 8013754:	f04f 0920 	mov.w	r9, #32
  pEraseInit.Sector = PAGE0_ID;
 8013758:	f04f 0b06 	mov.w	fp, #6
  uint32_t SectorError = 0;
 801375c:	46a0      	mov	r8, r4
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801375e:	f6c0 041c 	movt	r4, #2076	; 0x81c
  uint32_t valid[8] = {0x0000};
 8013762:	464a      	mov	r2, r9
 8013764:	a80e      	add	r0, sp, #56	; 0x38
 8013766:	4641      	mov	r1, r8
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013768:	4645      	mov	r5, r8
  uint32_t SectorError = 0;
 801376a:	f8cd 8008 	str.w	r8, [sp, #8]
  uint32_t valid[8] = {0x0000};
 801376e:	f017 fac4 	bl	802acfa <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013772:	8826      	ldrh	r6, [r4, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013774:	f6c0 051e 	movt	r5, #2078	; 0x81e
  switch (PageStatus0)
 8013778:	f64e 62ee 	movw	r2, #61166	; 0xeeee
  pEraseInit.Banks = FLASH_BANK_2 ;
 801377c:	2302      	movs	r3, #2
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801377e:	b2b6      	uxth	r6, r6
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013780:	8828      	ldrh	r0, [r5, #0]
  pEraseInit.NbSectors = 1;
 8013782:	f04f 0a01 	mov.w	sl, #1
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8013786:	f8cd 8010 	str.w	r8, [sp, #16]
  switch (PageStatus0)
 801378a:	4296      	cmp	r6, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 801378c:	b287      	uxth	r7, r0
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 801378e:	f8cd 9020 	str.w	r9, [sp, #32]
  pEraseInit.NbSectors = 1;
 8013792:	f8cd a01c 	str.w	sl, [sp, #28]
  pEraseInit.Sector = PAGE0_ID;
 8013796:	e9cd 3b05 	strd	r3, fp, [sp, #20]
  switch (PageStatus0)
 801379a:	f000 80dd 	beq.w	8013958 <EE_Init+0x20c>
 801379e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80137a2:	428e      	cmp	r6, r1
 80137a4:	f000 80ac 	beq.w	8013900 <EE_Init+0x1b4>
 80137a8:	b376      	cbz	r6, 8013808 <EE_Init+0xbc>
 80137aa:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 80137ac:	ab16      	add	r3, sp, #88	; 0x58
 80137ae:	464a      	mov	r2, r9
 80137b0:	4641      	mov	r1, r8
 80137b2:	4618      	mov	r0, r3
 80137b4:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 80137b6:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 80137ba:	f017 fa9e 	bl	802acfa <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 80137be:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
 80137c0:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 80137c4:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 80137c8:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80137cc:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 80137d0:	e001      	b.n	80137d6 <EE_Init+0x8a>
  while (Address <= PAGE0_END_ADDRESS)
 80137d2:	42ac      	cmp	r4, r5
 80137d4:	d00a      	beq.n	80137ec <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
 80137d6:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 80137d8:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 80137da:	429a      	cmp	r2, r3
 80137dc:	d0f9      	beq.n	80137d2 <EE_Init+0x86>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 80137de:	a903      	add	r1, sp, #12
 80137e0:	a809      	add	r0, sp, #36	; 0x24
 80137e2:	f7f2 fa67 	bl	8005cb4 <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
 80137e6:	2800      	cmp	r0, #0
 80137e8:	f040 8085 	bne.w	80138f6 <EE_Init+0x1aa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
 80137ec:	2100      	movs	r1, #0
 80137ee:	9a00      	ldr	r2, [sp, #0]
 80137f0:	2001      	movs	r0, #1
 80137f2:	f6c0 011c 	movt	r1, #2076	; 0x81c
 80137f6:	f7f2 f8a3 	bl	8005940 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 80137fa:	2800      	cmp	r0, #0
 80137fc:	d17b      	bne.n	80138f6 <EE_Init+0x1aa>
  return HAL_OK;
 80137fe:	2700      	movs	r7, #0
}
 8013800:	4638      	mov	r0, r7
 8013802:	b01f      	add	sp, #124	; 0x7c
 8013804:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Invalid state -> format eeprom */
 8013808:	2f00      	cmp	r7, #0
 801380a:	f000 8135 	beq.w	8013a78 <EE_Init+0x32c>
      else if (PageStatus1 == ERASED) /* Page0 valid, Page1 erased */
 801380e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8013812:	429f      	cmp	r7, r3
 8013814:	d0f3      	beq.n	80137fe <EE_Init+0xb2>
      if (PageStatus0 == VALID_PAGE)
 8013816:	f04f 0920 	mov.w	r9, #32
 801381a:	f240 0518 	movw	r5, #24
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 801381e:	2406      	movs	r4, #6
      if (PageStatus0 == VALID_PAGE)
 8013820:	f64f 7ac0 	movw	sl, #65472	; 0xffc0
      else if (PageStatus1 == VALID_PAGE)
 8013824:	46cb      	mov	fp, r9
      if (PageStatus0 == VALID_PAGE)
 8013826:	f64f 78e0 	movw	r8, #65504	; 0xffe0
 801382a:	f2c2 0500 	movt	r5, #8192	; 0x2000
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 801382e:	f6c0 041e 	movt	r4, #2078	; 0x81e
      if (PageStatus0 == VALID_PAGE)
 8013832:	f6c0 0a1d 	movt	sl, #2077	; 0x81d
 8013836:	f6c0 081d 	movt	r8, #2077	; 0x81d
 801383a:	f6c0 091c 	movt	r9, #2076	; 0x81c
      else if (PageStatus1 == VALID_PAGE)
 801383e:	f6c0 0b1e 	movt	fp, #2078	; 0x81e
  int16_t x = -1;
 8013842:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
          if ((*(__IO uint16_t*)(PAGE1_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8013846:	8823      	ldrh	r3, [r4, #0]
 8013848:	f835 0016 	ldrh.w	r0, [r5, r6, lsl #1]
 801384c:	4298      	cmp	r0, r3
            x = VarIdx;
 801384e:	bf08      	it	eq
 8013850:	b232      	sxtheq	r2, r6
          if (VarIdx != x)
 8013852:	4296      	cmp	r6, r2
 8013854:	d027      	beq.n	80138a6 <EE_Init+0x15a>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013856:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013858:	4619      	mov	r1, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 801385a:	f6c0 031c 	movt	r3, #2076	; 0x81c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 801385e:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013862:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013864:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013866:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013868:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 801386a:	2b00      	cmp	r3, #0
 801386c:	f000 8133 	beq.w	8013ad6 <EE_Init+0x38a>
      else if (PageStatus1 == VALID_PAGE)
 8013870:	2900      	cmp	r1, #0
 8013872:	f040 816b 	bne.w	8013b4c <EE_Init+0x400>
 8013876:	f64f 71e0 	movw	r1, #65504	; 0xffe0
 801387a:	f64f 77c0 	movw	r7, #65472	; 0xffc0
 801387e:	46dc      	mov	ip, fp
 8013880:	f6c0 011f 	movt	r1, #2079	; 0x81f
 8013884:	f6c0 071f 	movt	r7, #2079	; 0x81f
 8013888:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 801388a:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 801388c:	4288      	cmp	r0, r1
 801388e:	d106      	bne.n	801389e <EE_Init+0x152>
 8013890:	e13a      	b.n	8013b08 <EE_Init+0x3bc>
    AddressValue = (*(__IO uint16_t*)Address);
 8013892:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
 8013896:	42b8      	cmp	r0, r7
 8013898:	f000 8134 	beq.w	8013b04 <EE_Init+0x3b8>
 801389c:	460b      	mov	r3, r1
      Address = Address - 32;
 801389e:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 80138a2:	458c      	cmp	ip, r1
 80138a4:	d3f5      	bcc.n	8013892 <EE_Init+0x146>
 80138a6:	3601      	adds	r6, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80138a8:	2e03      	cmp	r6, #3
 80138aa:	d1cc      	bne.n	8013846 <EE_Init+0xfa>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
 80138ac:	2100      	movs	r1, #0
 80138ae:	aa0e      	add	r2, sp, #56	; 0x38
 80138b0:	2001      	movs	r0, #1
 80138b2:	f6c0 011e 	movt	r1, #2078	; 0x81e
 80138b6:	f7f2 f843 	bl	8005940 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 80138ba:	b9e0      	cbnz	r0, 80138f6 <EE_Init+0x1aa>
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80138bc:	2300      	movs	r3, #0
        pEraseInit.Sector = PAGE0_ID;
 80138be:	2006      	movs	r0, #6
        pEraseInit.Banks = FLASH_BANK_2 ;
 80138c0:	2502      	movs	r5, #2
        pEraseInit.NbSectors = 1;
 80138c2:	2401      	movs	r4, #1
  while (Address <= PAGE0_END_ADDRESS)
 80138c4:	4619      	mov	r1, r3
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80138c6:	2220      	movs	r2, #32
        pEraseInit.Sector = PAGE0_ID;
 80138c8:	9006      	str	r0, [sp, #24]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80138ca:	f6c0 031c 	movt	r3, #2076	; 0x81c
  while (Address <= PAGE0_END_ADDRESS)
 80138ce:	f6c0 011e 	movt	r1, #2078	; 0x81e
    if (AddressValue != ERASED)
 80138d2:	f64f 70ff 	movw	r0, #65535	; 0xffff
        pEraseInit.Banks = FLASH_BANK_2 ;
 80138d6:	9505      	str	r5, [sp, #20]
        pEraseInit.VoltageRange = VOLTAGE_RANGE;
 80138d8:	e9cd 4207 	strd	r4, r2, [sp, #28]
 80138dc:	e001      	b.n	80138e2 <EE_Init+0x196>
  while (Address <= PAGE0_END_ADDRESS)
 80138de:	428b      	cmp	r3, r1
 80138e0:	d08d      	beq.n	80137fe <EE_Init+0xb2>
    AddressValue = (*(__IO uint16_t*)Address);
 80138e2:	881a      	ldrh	r2, [r3, #0]
    Address = Address + 4;
 80138e4:	3304      	adds	r3, #4
    if (AddressValue != ERASED)
 80138e6:	4290      	cmp	r0, r2
 80138e8:	d0f9      	beq.n	80138de <EE_Init+0x192>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 80138ea:	a902      	add	r1, sp, #8
 80138ec:	a804      	add	r0, sp, #16
 80138ee:	f7f2 f9e1 	bl	8005cb4 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 80138f2:	2800      	cmp	r0, #0
 80138f4:	d083      	beq.n	80137fe <EE_Init+0xb2>
        return FlashStatus;
 80138f6:	b287      	uxth	r7, r0
}
 80138f8:	4638      	mov	r0, r7
 80138fa:	b01f      	add	sp, #124	; 0x7c
 80138fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus1 == VALID_PAGE) /* Page0 erased, Page1 valid */
 8013900:	b1ff      	cbz	r7, 8013942 <EE_Init+0x1f6>
      else if (PageStatus1 == RECEIVE_DATA) /* Page0 erased, Page1 receive */
 8013902:	4297      	cmp	r7, r2
 8013904:	f000 80a2 	beq.w	8013a4c <EE_Init+0x300>
 8013908:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 801390a:	ab16      	add	r3, sp, #88	; 0x58
 801390c:	464a      	mov	r2, r9
 801390e:	4641      	mov	r1, r8
 8013910:	4618      	mov	r0, r3
 8013912:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8013914:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8013918:	f017 f9ef 	bl	802acfa <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 801391c:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 801391e:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8013922:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8013926:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 801392a:	e002      	b.n	8013932 <EE_Init+0x1e6>
  while (Address <= PAGE0_END_ADDRESS)
 801392c:	42ac      	cmp	r4, r5
 801392e:	f43f af5d 	beq.w	80137ec <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
 8013932:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8013934:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8013936:	429e      	cmp	r6, r3
 8013938:	d0f8      	beq.n	801392c <EE_Init+0x1e0>
 801393a:	e750      	b.n	80137de <EE_Init+0x92>
  while (Address <= PAGE0_END_ADDRESS)
 801393c:	42ac      	cmp	r4, r5
 801393e:	f43f af5e 	beq.w	80137fe <EE_Init+0xb2>
    AddressValue = (*(__IO uint16_t*)Address);
 8013942:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8013944:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8013946:	429e      	cmp	r6, r3
 8013948:	d0f8      	beq.n	801393c <EE_Init+0x1f0>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 801394a:	a902      	add	r1, sp, #8
 801394c:	a804      	add	r0, sp, #16
 801394e:	f7f2 f9b1 	bl	8005cb4 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 8013952:	2800      	cmp	r0, #0
 8013954:	d1cf      	bne.n	80138f6 <EE_Init+0x1aa>
 8013956:	e752      	b.n	80137fe <EE_Init+0xb2>
      if (PageStatus1 == VALID_PAGE) /* Page0 receive, Page1 valid */
 8013958:	2f00      	cmp	r7, #0
 801395a:	d156      	bne.n	8013a0a <EE_Init+0x2be>
      if (PageStatus0 == VALID_PAGE)
 801395c:	f04f 0a20 	mov.w	sl, #32
 8013960:	f240 0518 	movw	r5, #24
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8013964:	2606      	movs	r6, #6
      if (PageStatus0 == VALID_PAGE)
 8013966:	f64f 7bc0 	movw	fp, #65472	; 0xffc0
      else if (PageStatus1 == VALID_PAGE)
 801396a:	4652      	mov	r2, sl
      if (PageStatus0 == VALID_PAGE)
 801396c:	f64f 79e0 	movw	r9, #65504	; 0xffe0
 8013970:	463c      	mov	r4, r7
 8013972:	f2c2 0500 	movt	r5, #8192	; 0x2000
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 8013976:	f6c0 061c 	movt	r6, #2076	; 0x81c
      if (PageStatus0 == VALID_PAGE)
 801397a:	f6c0 0b1d 	movt	fp, #2077	; 0x81d
 801397e:	f6c0 0a1c 	movt	sl, #2076	; 0x81c
 8013982:	f6c0 091d 	movt	r9, #2077	; 0x81d
      else if (PageStatus1 == VALID_PAGE)
 8013986:	f6c0 021e 	movt	r2, #2078	; 0x81e
  int16_t x = -1;
 801398a:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
          if (( *(__IO uint16_t*)(PAGE0_BASE_ADDRESS + 6)) == VirtAddVarTab[VarIdx])
 801398e:	8833      	ldrh	r3, [r6, #0]
 8013990:	f835 0014 	ldrh.w	r0, [r5, r4, lsl #1]
 8013994:	4298      	cmp	r0, r3
            x = VarIdx;
 8013996:	bf08      	it	eq
 8013998:	fa0f f884 	sxtheq.w	r8, r4
          if (VarIdx != x)
 801399c:	4544      	cmp	r4, r8
 801399e:	d026      	beq.n	80139ee <EE_Init+0x2a2>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80139a0:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80139a2:	4619      	mov	r1, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80139a4:	f6c0 031c 	movt	r3, #2076	; 0x81c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80139a8:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80139ac:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80139ae:	8809      	ldrh	r1, [r1, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 80139b0:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 80139b2:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 80139b4:	2b00      	cmp	r3, #0
 80139b6:	f000 8089 	beq.w	8013acc <EE_Init+0x380>
      else if (PageStatus1 == VALID_PAGE)
 80139ba:	2900      	cmp	r1, #0
 80139bc:	f040 80c0 	bne.w	8013b40 <EE_Init+0x3f4>
 80139c0:	f64f 71e0 	movw	r1, #65504	; 0xffe0
 80139c4:	f64f 77c0 	movw	r7, #65472	; 0xffc0
 80139c8:	4694      	mov	ip, r2
 80139ca:	f6c0 011f 	movt	r1, #2079	; 0x81f
 80139ce:	f6c0 071f 	movt	r7, #2079	; 0x81f
 80139d2:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 80139d4:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 80139d6:	4288      	cmp	r0, r1
 80139d8:	d105      	bne.n	80139e6 <EE_Init+0x29a>
 80139da:	e083      	b.n	8013ae4 <EE_Init+0x398>
    AddressValue = (*(__IO uint16_t*)Address);
 80139dc:	f833 7c20 	ldrh.w	r7, [r3, #-32]
    if (AddressValue == VirtAddress)
 80139e0:	42b8      	cmp	r0, r7
 80139e2:	d07d      	beq.n	8013ae0 <EE_Init+0x394>
 80139e4:	460b      	mov	r3, r1
      Address = Address - 32;
 80139e6:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 80139ea:	4561      	cmp	r1, ip
 80139ec:	d8f6      	bhi.n	80139dc <EE_Init+0x290>
 80139ee:	3401      	adds	r4, #1
        for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 80139f0:	2c03      	cmp	r4, #3
 80139f2:	d1cc      	bne.n	801398e <EE_Init+0x242>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 80139f4:	2100      	movs	r1, #0
 80139f6:	aa0e      	add	r2, sp, #56	; 0x38
 80139f8:	2001      	movs	r0, #1
 80139fa:	f6c0 011c 	movt	r1, #2076	; 0x81c
 80139fe:	f7f1 ff9f 	bl	8005940 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8013a02:	2800      	cmp	r0, #0
 8013a04:	f43f aefb 	beq.w	80137fe <EE_Init+0xb2>
 8013a08:	e775      	b.n	80138f6 <EE_Init+0x1aa>
      else if (PageStatus1 == ERASED) /* Page0 receive, Page1 erased */
 8013a0a:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8013a0e:	42b7      	cmp	r7, r6
 8013a10:	f000 808a 	beq.w	8013b28 <EE_Init+0x3dc>
 8013a14:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 8013a16:	ab16      	add	r3, sp, #88	; 0x58
 8013a18:	464a      	mov	r2, r9
 8013a1a:	4641      	mov	r1, r8
 8013a1c:	4618      	mov	r0, r3
 8013a1e:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8013a20:	f8cd 800c 	str.w	r8, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8013a24:	f017 f969 	bl	802acfa <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 8013a28:	9b01      	ldr	r3, [sp, #4]
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8013a2a:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8013a2e:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8013a32:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 8013a36:	e002      	b.n	8013a3e <EE_Init+0x2f2>
  while (Address <= PAGE0_END_ADDRESS)
 8013a38:	42ac      	cmp	r4, r5
 8013a3a:	f43f aed7 	beq.w	80137ec <EE_Init+0xa0>
    AddressValue = (*(__IO uint16_t*)Address);
 8013a3e:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8013a40:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8013a42:	429e      	cmp	r6, r3
 8013a44:	d0f8      	beq.n	8013a38 <EE_Init+0x2ec>
 8013a46:	e6ca      	b.n	80137de <EE_Init+0x92>
  while (Address <= PAGE0_END_ADDRESS)
 8013a48:	42ac      	cmp	r4, r5
 8013a4a:	d00a      	beq.n	8013a62 <EE_Init+0x316>
    AddressValue = (*(__IO uint16_t*)Address);
 8013a4c:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8013a4e:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8013a50:	429e      	cmp	r6, r3
 8013a52:	d0f9      	beq.n	8013a48 <EE_Init+0x2fc>
          FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8013a54:	a902      	add	r1, sp, #8
 8013a56:	a804      	add	r0, sp, #16
 8013a58:	f7f2 f92c 	bl	8005cb4 <HAL_FLASHEx_Erase>
          if (FlashStatus != HAL_OK)
 8013a5c:	2800      	cmp	r0, #0
 8013a5e:	f47f af4a 	bne.w	80138f6 <EE_Init+0x1aa>
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE1_BASE_ADDRESS, ((uint32_t)valid));
 8013a62:	2100      	movs	r1, #0
 8013a64:	aa0e      	add	r2, sp, #56	; 0x38
 8013a66:	2001      	movs	r0, #1
 8013a68:	f6c0 011e 	movt	r1, #2078	; 0x81e
 8013a6c:	f7f1 ff68 	bl	8005940 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8013a70:	2800      	cmp	r0, #0
 8013a72:	f43f aec4 	beq.w	80137fe <EE_Init+0xb2>
 8013a76:	e73e      	b.n	80138f6 <EE_Init+0x1aa>
 8013a78:	9301      	str	r3, [sp, #4]
  uint32_t valid[8] = {0x0000};
 8013a7a:	ab16      	add	r3, sp, #88	; 0x58
 8013a7c:	464a      	mov	r2, r9
 8013a7e:	4639      	mov	r1, r7
 8013a80:	4618      	mov	r0, r3
 8013a82:	9300      	str	r3, [sp, #0]
  uint32_t SectorError = 0;
 8013a84:	9703      	str	r7, [sp, #12]
  uint32_t valid[8] = {0x0000};
 8013a86:	f017 f938 	bl	802acfa <memset>
  pEraseInit.Banks = FLASH_BANK_2 ;
 8013a8a:	9b01      	ldr	r3, [sp, #4]
    if (AddressValue != ERASED)
 8013a8c:	f64f 72ff 	movw	r2, #65535	; 0xffff
  pEraseInit.TypeErase = FLASH_TYPEERASE_SECTORS;
 8013a90:	9709      	str	r7, [sp, #36]	; 0x24
  pEraseInit.Sector = PAGE0_ID;
 8013a92:	e9cd 3b0a 	strd	r3, fp, [sp, #40]	; 0x28
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8013a96:	e9cd a90c 	strd	sl, r9, [sp, #48]	; 0x30
 8013a9a:	e001      	b.n	8013aa0 <EE_Init+0x354>
  while (Address <= PAGE0_END_ADDRESS)
 8013a9c:	42ac      	cmp	r4, r5
 8013a9e:	d00a      	beq.n	8013ab6 <EE_Init+0x36a>
    AddressValue = (*(__IO uint16_t*)Address);
 8013aa0:	8823      	ldrh	r3, [r4, #0]
    Address = Address + 4;
 8013aa2:	3404      	adds	r4, #4
    if (AddressValue != ERASED)
 8013aa4:	429a      	cmp	r2, r3
 8013aa6:	d0f9      	beq.n	8013a9c <EE_Init+0x350>
    FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8013aa8:	a903      	add	r1, sp, #12
 8013aaa:	a809      	add	r0, sp, #36	; 0x24
 8013aac:	f7f2 f902 	bl	8005cb4 <HAL_FLASHEx_Erase>
    if (FlashStatus != HAL_OK)
 8013ab0:	2800      	cmp	r0, #0
 8013ab2:	f47f af20 	bne.w	80138f6 <EE_Init+0x1aa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS,((uint32_t)valid));
 8013ab6:	2100      	movs	r1, #0
 8013ab8:	9a00      	ldr	r2, [sp, #0]
 8013aba:	2001      	movs	r0, #1
 8013abc:	f6c0 011c 	movt	r1, #2076	; 0x81c
 8013ac0:	f7f1 ff3e 	bl	8005940 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 8013ac4:	2800      	cmp	r0, #0
 8013ac6:	f43f ae9b 	beq.w	8013800 <EE_Init+0xb4>
 8013aca:	e714      	b.n	80138f6 <EE_Init+0x1aa>
      if (PageStatus0 == VALID_PAGE)
 8013acc:	465f      	mov	r7, fp
 8013ace:	46d4      	mov	ip, sl
 8013ad0:	4649      	mov	r1, r9
 8013ad2:	464b      	mov	r3, r9
 8013ad4:	e77e      	b.n	80139d4 <EE_Init+0x288>
 8013ad6:	4657      	mov	r7, sl
 8013ad8:	4641      	mov	r1, r8
 8013ada:	4643      	mov	r3, r8
 8013adc:	46cc      	mov	ip, r9
 8013ade:	e6d4      	b.n	801388a <EE_Init+0x13e>
 8013ae0:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8013ae4:	8839      	ldrh	r1, [r7, #0]
 8013ae6:	f240 5302 	movw	r3, #1282	; 0x502
 8013aea:	b289      	uxth	r1, r1
 8013aec:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013af0:	8019      	strh	r1, [r3, #0]
 8013af2:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8013af4:	f7ff fdd6 	bl	80136a4 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
 8013af8:	9a00      	ldr	r2, [sp, #0]
 8013afa:	4607      	mov	r7, r0
 8013afc:	2800      	cmp	r0, #0
 8013afe:	f43f af76 	beq.w	80139ee <EE_Init+0x2a2>
 8013b02:	e67d      	b.n	8013800 <EE_Init+0xb4>
 8013b04:	f1a3 0740 	sub.w	r7, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8013b08:	8839      	ldrh	r1, [r7, #0]
 8013b0a:	f240 5302 	movw	r3, #1282	; 0x502
 8013b0e:	b289      	uxth	r1, r1
 8013b10:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013b14:	8019      	strh	r1, [r3, #0]
 8013b16:	9200      	str	r2, [sp, #0]
              EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8013b18:	f7ff fdc4 	bl	80136a4 <EE_VerifyPageFullWriteVariable>
              if (EepromStatus != HAL_OK)
 8013b1c:	9a00      	ldr	r2, [sp, #0]
 8013b1e:	4607      	mov	r7, r0
 8013b20:	2800      	cmp	r0, #0
 8013b22:	f43f aec0 	beq.w	80138a6 <EE_Init+0x15a>
 8013b26:	e66b      	b.n	8013800 <EE_Init+0xb4>
        pEraseInit.Sector = PAGE1_ID;
 8013b28:	2307      	movs	r3, #7
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 8013b2a:	aa0e      	add	r2, sp, #56	; 0x38
 8013b2c:	4621      	mov	r1, r4
 8013b2e:	4650      	mov	r0, sl
        pEraseInit.Sector = PAGE1_ID;
 8013b30:	e9cd a305 	strd	sl, r3, [sp, #20]
        FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, PAGE0_BASE_ADDRESS, ((uint32_t)valid));
 8013b34:	f7f1 ff04 	bl	8005940 <HAL_FLASH_Program>
        if (FlashStatus != HAL_OK)
 8013b38:	2800      	cmp	r0, #0
 8013b3a:	f43f ae60 	beq.w	80137fe <EE_Init+0xb2>
 8013b3e:	e6da      	b.n	80138f6 <EE_Init+0x1aa>
 8013b40:	f240 5302 	movw	r3, #1282	; 0x502
 8013b44:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013b48:	8819      	ldrh	r1, [r3, #0]
 8013b4a:	e7d2      	b.n	8013af2 <EE_Init+0x3a6>
 8013b4c:	f240 5302 	movw	r3, #1282	; 0x502
 8013b50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013b54:	8819      	ldrh	r1, [r3, #0]
 8013b56:	e7de      	b.n	8013b16 <EE_Init+0x3ca>

08013b58 <EE_ReadVariable>:
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013b58:	2300      	movs	r3, #0
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013b5a:	461a      	mov	r2, r3
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013b5c:	f6c0 031c 	movt	r3, #2076	; 0x81c
{
 8013b60:	b430      	push	{r4, r5}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013b62:	881b      	ldrh	r3, [r3, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013b64:	f6c0 021e 	movt	r2, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013b68:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013b6a:	8812      	ldrh	r2, [r2, #0]
      if (PageStatus0 == VALID_PAGE)
 8013b6c:	b173      	cbz	r3, 8013b8c <EE_ReadVariable+0x34>
 8013b6e:	b292      	uxth	r2, r2
      else if (PageStatus1 == VALID_PAGE)
 8013b70:	bb7a      	cbnz	r2, 8013bd2 <EE_ReadVariable+0x7a>
 8013b72:	f64f 73e0 	movw	r3, #65504	; 0xffe0
 8013b76:	f64f 72c0 	movw	r2, #65472	; 0xffc0
 8013b7a:	2520      	movs	r5, #32
 8013b7c:	f6c0 031f 	movt	r3, #2079	; 0x81f
 8013b80:	f6c0 021f 	movt	r2, #2079	; 0x81f
 8013b84:	f6c0 051e 	movt	r5, #2078	; 0x81e
 8013b88:	461c      	mov	r4, r3
 8013b8a:	e00b      	b.n	8013ba4 <EE_ReadVariable+0x4c>
      if (PageStatus0 == VALID_PAGE)
 8013b8c:	f64f 73e0 	movw	r3, #65504	; 0xffe0
 8013b90:	f64f 72c0 	movw	r2, #65472	; 0xffc0
 8013b94:	2520      	movs	r5, #32
 8013b96:	f6c0 031d 	movt	r3, #2077	; 0x81d
 8013b9a:	f6c0 021d 	movt	r2, #2077	; 0x81d
 8013b9e:	f6c0 051c 	movt	r5, #2076	; 0x81c
 8013ba2:	461c      	mov	r4, r3
    AddressValue = (*(__IO uint16_t*)Address);
 8013ba4:	8824      	ldrh	r4, [r4, #0]
    if (AddressValue == VirtAddress)
 8013ba6:	42a0      	cmp	r0, r4
 8013ba8:	d105      	bne.n	8013bb6 <EE_ReadVariable+0x5e>
 8013baa:	e00d      	b.n	8013bc8 <EE_ReadVariable+0x70>
    AddressValue = (*(__IO uint16_t*)Address);
 8013bac:	f833 4c20 	ldrh.w	r4, [r3, #-32]
    if (AddressValue == VirtAddress)
 8013bb0:	42a0      	cmp	r0, r4
 8013bb2:	d007      	beq.n	8013bc4 <EE_ReadVariable+0x6c>
 8013bb4:	4613      	mov	r3, r2
      Address = Address - 32;
 8013bb6:	f1a3 0220 	sub.w	r2, r3, #32
  while (Address > (PageStartAddress + 32))
 8013bba:	42aa      	cmp	r2, r5
 8013bbc:	d8f6      	bhi.n	8013bac <EE_ReadVariable+0x54>
  uint16_t AddressValue = 0x5555, ReadStatus = 1;
 8013bbe:	2001      	movs	r0, #1
}
 8013bc0:	bc30      	pop	{r4, r5}
 8013bc2:	4770      	bx	lr
 8013bc4:	f1a3 0240 	sub.w	r2, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8013bc8:	8813      	ldrh	r3, [r2, #0]
      ReadStatus = 0;
 8013bca:	2000      	movs	r0, #0
      *Data = (*(__IO uint16_t*)(Address - 32));
 8013bcc:	800b      	strh	r3, [r1, #0]
}
 8013bce:	bc30      	pop	{r4, r5}
 8013bd0:	4770      	bx	lr
    return  NO_VALID_PAGE;
 8013bd2:	20ab      	movs	r0, #171	; 0xab
}
 8013bd4:	bc30      	pop	{r4, r5}
 8013bd6:	4770      	bx	lr

08013bd8 <EE_WriteVariable>:
{
 8013bd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013bdc:	2500      	movs	r5, #0
{
 8013bde:	b09b      	sub	sp, #108	; 0x6c
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013be0:	462a      	mov	r2, r5
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013be2:	f6c0 051c 	movt	r5, #2076	; 0x81c
  uint32_t VirtAddress1[8] = {VirtAddress};
 8013be6:	9012      	str	r0, [sp, #72]	; 0x48
  uint32_t data32[8] = {Data};
 8013be8:	4613      	mov	r3, r2
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013bea:	f6c0 021e 	movt	r2, #2078	; 0x81e
  uint32_t data32[8] = {Data};
 8013bee:	910a      	str	r1, [sp, #40]	; 0x28
 8013bf0:	9311      	str	r3, [sp, #68]	; 0x44
  uint32_t VirtAddress1[8] = {VirtAddress};
 8013bf2:	9319      	str	r3, [sp, #100]	; 0x64
  uint32_t data32[8] = {Data};
 8013bf4:	e9cd 330b 	strd	r3, r3, [sp, #44]	; 0x2c
 8013bf8:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
 8013bfc:	e9cd 330f 	strd	r3, r3, [sp, #60]	; 0x3c
  uint32_t VirtAddress1[8] = {VirtAddress};
 8013c00:	e9cd 3313 	strd	r3, r3, [sp, #76]	; 0x4c
 8013c04:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
 8013c08:	e9cd 3317 	strd	r3, r3, [sp, #92]	; 0x5c
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013c0c:	882f      	ldrh	r7, [r5, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013c0e:	8813      	ldrh	r3, [r2, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013c10:	b2bf      	uxth	r7, r7
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013c12:	b29b      	uxth	r3, r3
      if (PageStatus1 == VALID_PAGE)
 8013c14:	bb43      	cbnz	r3, 8013c68 <EE_WriteVariable+0x90>
        if (PageStatus0 == RECEIVE_DATA)
 8013c16:	f64e 63ee 	movw	r3, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
 8013c1a:	1aff      	subs	r7, r7, r3
 8013c1c:	bf18      	it	ne
 8013c1e:	2701      	movne	r7, #1
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 8013c20:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013c24:	1c7b      	adds	r3, r7, #1
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8013c26:	f207 470e 	addw	r7, r7, #1038	; 0x40e
 8013c2a:	4688      	mov	r8, r1
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 8013c2c:	f6c0 021b 	movt	r2, #2075	; 0x81b
 8013c30:	4604      	mov	r4, r0
  Address = (uint32_t)(EEPROM_START_ADDRESS + (uint32_t)(ValidPage * PAGE_SIZE));
 8013c32:	047f      	lsls	r7, r7, #17
  PageEndAddress = (uint32_t)((EEPROM_START_ADDRESS - 1) + (uint32_t)((ValidPage + 1) * PAGE_SIZE));
 8013c34:	eb02 4243 	add.w	r2, r2, r3, lsl #17
  while (Address < PageEndAddress)
 8013c38:	4297      	cmp	r7, r2
 8013c3a:	d303      	bcc.n	8013c44 <EE_WriteVariable+0x6c>
 8013c3c:	e021      	b.n	8013c82 <EE_WriteVariable+0xaa>
      Address = Address + 64;
 8013c3e:	3740      	adds	r7, #64	; 0x40
  while (Address < PageEndAddress)
 8013c40:	42ba      	cmp	r2, r7
 8013c42:	d91e      	bls.n	8013c82 <EE_WriteVariable+0xaa>
    if ((*(__IO uint32_t*)Address) == 0xFFFFFFFF)
 8013c44:	683b      	ldr	r3, [r7, #0]
 8013c46:	3301      	adds	r3, #1
 8013c48:	d1f9      	bne.n	8013c3e <EE_WriteVariable+0x66>
      FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address, ((uint32_t)data32));
 8013c4a:	ae0a      	add	r6, sp, #40	; 0x28
 8013c4c:	4639      	mov	r1, r7
 8013c4e:	2001      	movs	r0, #1
 8013c50:	4632      	mov	r2, r6
 8013c52:	f7f1 fe75 	bl	8005940 <HAL_FLASH_Program>
      if (FlashStatus != HAL_OK)
 8013c56:	2800      	cmp	r0, #0
 8013c58:	d043      	beq.n	8013ce2 <EE_WriteVariable+0x10a>
     return FlashStatus;
 8013c5a:	b285      	uxth	r5, r0
  if (Status == PAGE_FULL)
 8013c5c:	2d80      	cmp	r5, #128	; 0x80
 8013c5e:	d011      	beq.n	8013c84 <EE_WriteVariable+0xac>
}
 8013c60:	4628      	mov	r0, r5
 8013c62:	b01b      	add	sp, #108	; 0x6c
 8013c64:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      else if (PageStatus0 == VALID_PAGE)
 8013c68:	b937      	cbnz	r7, 8013c78 <EE_WriteVariable+0xa0>
        if (PageStatus1 == RECEIVE_DATA)
 8013c6a:	f64e 67ee 	movw	r7, #61166	; 0xeeee
          return PAGE1;         /* Page1 valid */
 8013c6e:	1bdf      	subs	r7, r3, r7
 8013c70:	fab7 f787 	clz	r7, r7
 8013c74:	097f      	lsrs	r7, r7, #5
 8013c76:	e7d3      	b.n	8013c20 <EE_WriteVariable+0x48>
    /* Old page ID where variable will be taken from */
    OldPageId = PAGE0_ID;
  }
  else
  {
    return NO_VALID_PAGE;       /* No valid Page */
 8013c78:	25ab      	movs	r5, #171	; 0xab
}
 8013c7a:	4628      	mov	r0, r5
 8013c7c:	b01b      	add	sp, #108	; 0x6c
 8013c7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8013c82:	ae0a      	add	r6, sp, #40	; 0x28
  uint32_t SectorError = 0;
 8013c84:	2500      	movs	r5, #0
  uint32_t valid[8] = {0x0000};
 8013c86:	2220      	movs	r2, #32
 8013c88:	4630      	mov	r0, r6
 8013c8a:	4629      	mov	r1, r5
  uint32_t SectorError = 0;
 8013c8c:	9504      	str	r5, [sp, #16]
  uint32_t valid[8] = {0x0000};
 8013c8e:	f017 f834 	bl	802acfa <memset>
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013c92:	4629      	mov	r1, r5
  uint32_t receive[8] = {0xEEEE};
 8013c94:	f64e 63ee 	movw	r3, #61166	; 0xeeee
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013c98:	462f      	mov	r7, r5
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013c9a:	f6c0 011c 	movt	r1, #2076	; 0x81c
  uint32_t receive[8] = {0xEEEE};
 8013c9e:	9519      	str	r5, [sp, #100]	; 0x64
 8013ca0:	9312      	str	r3, [sp, #72]	; 0x48
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013ca2:	f6c0 071e 	movt	r7, #2078	; 0x81e
  uint32_t receive[8] = {0xEEEE};
 8013ca6:	e9cd 5513 	strd	r5, r5, [sp, #76]	; 0x4c
 8013caa:	e9cd 5515 	strd	r5, r5, [sp, #84]	; 0x54
 8013cae:	e9cd 5517 	strd	r5, r5, [sp, #92]	; 0x5c
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013cb2:	880b      	ldrh	r3, [r1, #0]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013cb4:	883a      	ldrh	r2, [r7, #0]
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013cb6:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013cb8:	b292      	uxth	r2, r2
      if (PageStatus0 == VALID_PAGE)
 8013cba:	b17b      	cbz	r3, 8013cdc <EE_WriteVariable+0x104>
      else if (PageStatus1 == VALID_PAGE)
 8013cbc:	2a00      	cmp	r2, #0
 8013cbe:	d1db      	bne.n	8013c78 <EE_WriteVariable+0xa0>
    NewPageAddress = PAGE0_BASE_ADDRESS;
 8013cc0:	460f      	mov	r7, r1
      else if (PageStatus1 == VALID_PAGE)
 8013cc2:	f04f 0907 	mov.w	r9, #7
  }

  /* Set the new Page status to RECEIVE_DATA status */

  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)receive));
 8013cc6:	aa12      	add	r2, sp, #72	; 0x48
 8013cc8:	4639      	mov	r1, r7
 8013cca:	2001      	movs	r0, #1
 8013ccc:	f7f1 fe38 	bl	8005940 <HAL_FLASH_Program>

  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
 8013cd0:	b170      	cbz	r0, 8013cf0 <EE_WriteVariable+0x118>
  /* Set new Page status to VALID_PAGE status */
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
  /* If program operation was failed, a Flash error code is returned */
  if (FlashStatus != HAL_OK)
  {
    return FlashStatus;
 8013cd2:	b285      	uxth	r5, r0
}
 8013cd4:	4628      	mov	r0, r5
 8013cd6:	b01b      	add	sp, #108	; 0x6c
 8013cd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (PageStatus0 == VALID_PAGE)
 8013cdc:	f04f 0906 	mov.w	r9, #6
 8013ce0:	e7f1      	b.n	8013cc6 <EE_WriteVariable+0xee>
     FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, Address + 32, ((uint32_t)VirtAddress1));
 8013ce2:	f107 0120 	add.w	r1, r7, #32
 8013ce6:	aa12      	add	r2, sp, #72	; 0x48
 8013ce8:	2001      	movs	r0, #1
 8013cea:	f7f1 fe29 	bl	8005940 <HAL_FLASH_Program>
 8013cee:	e7b4      	b.n	8013c5a <EE_WriteVariable+0x82>
  EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddress, Data);
 8013cf0:	4641      	mov	r1, r8
 8013cf2:	4620      	mov	r0, r4
 8013cf4:	f7ff fcd6 	bl	80136a4 <EE_VerifyPageFullWriteVariable>
  if (EepromStatus != HAL_OK)
 8013cf8:	4605      	mov	r5, r0
 8013cfa:	2800      	cmp	r0, #0
 8013cfc:	d1b0      	bne.n	8013c60 <EE_WriteVariable+0x88>
      if (PageStatus0 == VALID_PAGE)
 8013cfe:	2320      	movs	r3, #32
 8013d00:	f64f 72c0 	movw	r2, #65472	; 0xffc0
 8013d04:	f240 0818 	movw	r8, #24
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013d08:	f04f 0b00 	mov.w	fp, #0
      else if (PageStatus1 == VALID_PAGE)
 8013d0c:	4619      	mov	r1, r3
      if (PageStatus0 == VALID_PAGE)
 8013d0e:	f6c0 021d 	movt	r2, #2077	; 0x81d
 8013d12:	f6c0 031c 	movt	r3, #2076	; 0x81c
 8013d16:	f64f 7ae0 	movw	sl, #65504	; 0xffe0
      else if (PageStatus1 == VALID_PAGE)
 8013d1a:	f6c0 011e 	movt	r1, #2078	; 0x81e
 8013d1e:	f2c2 0800 	movt	r8, #8192	; 0x2000
      if (PageStatus0 == VALID_PAGE)
 8013d22:	9301      	str	r3, [sp, #4]
      else if (PageStatus1 == VALID_PAGE)
 8013d24:	4613      	mov	r3, r2
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013d26:	f6c0 0b1c 	movt	fp, #2076	; 0x81c
      else if (PageStatus1 == VALID_PAGE)
 8013d2a:	4632      	mov	r2, r6
      if (PageStatus0 == VALID_PAGE)
 8013d2c:	f6c0 0a1d 	movt	sl, #2077	; 0x81d
      else if (PageStatus1 == VALID_PAGE)
 8013d30:	4606      	mov	r6, r0
 8013d32:	461d      	mov	r5, r3
 8013d34:	9103      	str	r1, [sp, #12]
    if (VirtAddVarTab[VarIdx] != VirtAddress)  /* Check each variable except the one passed as parameter */
 8013d36:	f838 0b02 	ldrh.w	r0, [r8], #2
 8013d3a:	4284      	cmp	r4, r0
 8013d3c:	d023      	beq.n	8013d86 <EE_WriteVariable+0x1ae>
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013d3e:	2100      	movs	r1, #0
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013d40:	f8bb 3000 	ldrh.w	r3, [fp]
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013d44:	f6c0 011e 	movt	r1, #2078	; 0x81e
  PageStatus0 = (*(__IO uint16_t*)PAGE0_BASE_ADDRESS);
 8013d48:	b29b      	uxth	r3, r3
  PageStatus1 = (*(__IO uint16_t*)PAGE1_BASE_ADDRESS);
 8013d4a:	8809      	ldrh	r1, [r1, #0]
 8013d4c:	b289      	uxth	r1, r1
      if (PageStatus0 == VALID_PAGE)
 8013d4e:	2b00      	cmp	r3, #0
 8013d50:	d043      	beq.n	8013dda <EE_WriteVariable+0x202>
      else if (PageStatus1 == VALID_PAGE)
 8013d52:	2900      	cmp	r1, #0
 8013d54:	d159      	bne.n	8013e0a <EE_WriteVariable+0x232>
 8013d56:	f64f 71e0 	movw	r1, #65504	; 0xffe0
 8013d5a:	f64f 7cc0 	movw	ip, #65472	; 0xffc0
 8013d5e:	f8dd e00c 	ldr.w	lr, [sp, #12]
 8013d62:	f6c0 011f 	movt	r1, #2079	; 0x81f
 8013d66:	f6c0 0c1f 	movt	ip, #2079	; 0x81f
 8013d6a:	460b      	mov	r3, r1
    AddressValue = (*(__IO uint16_t*)Address);
 8013d6c:	8809      	ldrh	r1, [r1, #0]
    if (AddressValue == VirtAddress)
 8013d6e:	4288      	cmp	r0, r1
 8013d70:	d105      	bne.n	8013d7e <EE_WriteVariable+0x1a6>
 8013d72:	e03a      	b.n	8013dea <EE_WriteVariable+0x212>
    AddressValue = (*(__IO uint16_t*)Address);
 8013d74:	f833 cc20 	ldrh.w	ip, [r3, #-32]
    if (AddressValue == VirtAddress)
 8013d78:	4560      	cmp	r0, ip
 8013d7a:	d034      	beq.n	8013de6 <EE_WriteVariable+0x20e>
 8013d7c:	460b      	mov	r3, r1
      Address = Address - 32;
 8013d7e:	f1a3 0120 	sub.w	r1, r3, #32
  while (Address > (PageStartAddress + 32))
 8013d82:	458e      	cmp	lr, r1
 8013d84:	d3f6      	bcc.n	8013d74 <EE_WriteVariable+0x19c>
  for (VarIdx = 0; VarIdx < NB_OF_VAR; VarIdx++)
 8013d86:	f240 031e 	movw	r3, #30
 8013d8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013d8e:	4598      	cmp	r8, r3
 8013d90:	d1d1      	bne.n	8013d36 <EE_WriteVariable+0x15e>
 8013d92:	4635      	mov	r5, r6
 8013d94:	4616      	mov	r6, r2
  HAL_FLASH_Unlock();
 8013d96:	f7f1 fe59 	bl	8005a4c <HAL_FLASH_Unlock>
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8013d9a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8013d9e:	f44f 008e 	mov.w	r0, #4653056	; 0x470000
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8013da2:	2100      	movs	r1, #0
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8013da4:	f2c5 2300 	movt	r3, #20992	; 0x5200
  pEraseInit.Banks = FLASH_BANK_2 ;
 8013da8:	2202      	movs	r2, #2
  pEraseInit.NbSectors = 1;
 8013daa:	2401      	movs	r4, #1
  __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR |
 8013dac:	6158      	str	r0, [r3, #20]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8013dae:	2320      	movs	r3, #32
  pEraseInit.TypeErase = TYPEERASE_SECTORS;
 8013db0:	9105      	str	r1, [sp, #20]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8013db2:	a805      	add	r0, sp, #20
 8013db4:	a904      	add	r1, sp, #16
  pEraseInit.Sector = OldPageId;
 8013db6:	f8cd 901c 	str.w	r9, [sp, #28]
  pEraseInit.Banks = FLASH_BANK_2 ;
 8013dba:	9206      	str	r2, [sp, #24]
  pEraseInit.VoltageRange = VOLTAGE_RANGE;
 8013dbc:	e9cd 4308 	strd	r4, r3, [sp, #32]
  FlashStatus = HAL_FLASHEx_Erase(&pEraseInit, &SectorError);
 8013dc0:	f7f1 ff78 	bl	8005cb4 <HAL_FLASHEx_Erase>
  if (FlashStatus != HAL_OK)
 8013dc4:	2800      	cmp	r0, #0
 8013dc6:	d184      	bne.n	8013cd2 <EE_WriteVariable+0xfa>
  FlashStatus = HAL_FLASH_Program(FLASH_TYPEPROGRAM_FLASHWORD, NewPageAddress, ((uint32_t)valid));
 8013dc8:	4632      	mov	r2, r6
 8013dca:	4639      	mov	r1, r7
 8013dcc:	4620      	mov	r0, r4
 8013dce:	f7f1 fdb7 	bl	8005940 <HAL_FLASH_Program>
  if (FlashStatus != HAL_OK)
 8013dd2:	2800      	cmp	r0, #0
 8013dd4:	f47f af7d 	bne.w	8013cd2 <EE_WriteVariable+0xfa>
 8013dd8:	e742      	b.n	8013c60 <EE_WriteVariable+0x88>
      if (PageStatus0 == VALID_PAGE)
 8013dda:	46ac      	mov	ip, r5
 8013ddc:	4651      	mov	r1, sl
 8013dde:	4653      	mov	r3, sl
 8013de0:	f8dd e004 	ldr.w	lr, [sp, #4]
 8013de4:	e7c2      	b.n	8013d6c <EE_WriteVariable+0x194>
 8013de6:	f1a3 0c40 	sub.w	ip, r3, #64	; 0x40
      *Data = (*(__IO uint16_t*)(Address - 32));
 8013dea:	f8bc 1000 	ldrh.w	r1, [ip]
 8013dee:	f240 5302 	movw	r3, #1282	; 0x502
 8013df2:	b289      	uxth	r1, r1
 8013df4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013df8:	8019      	strh	r1, [r3, #0]
 8013dfa:	9202      	str	r2, [sp, #8]
        EepromStatus = EE_VerifyPageFullWriteVariable(VirtAddVarTab[VarIdx], DataVar);
 8013dfc:	f7ff fc52 	bl	80136a4 <EE_VerifyPageFullWriteVariable>
        if (EepromStatus != HAL_OK)
 8013e00:	9a02      	ldr	r2, [sp, #8]
 8013e02:	2800      	cmp	r0, #0
 8013e04:	d0bf      	beq.n	8013d86 <EE_WriteVariable+0x1ae>
 8013e06:	4605      	mov	r5, r0
  return Status;
 8013e08:	e72a      	b.n	8013c60 <EE_WriteVariable+0x88>
 8013e0a:	f240 5302 	movw	r3, #1282	; 0x502
 8013e0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e12:	8819      	ldrh	r1, [r3, #0]
 8013e14:	e7f1      	b.n	8013dfa <EE_WriteVariable+0x222>
 8013e16:	bf00      	nop

08013e18 <MX_FATFS_Init>:
/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 8013e18:	f241 1138 	movw	r1, #4408	; 0x1138
 8013e1c:	f64e 2068 	movw	r0, #60008	; 0xea68
{
 8013e20:	b508      	push	{r3, lr}
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 8013e22:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8013e26:	f6c0 0002 	movt	r0, #2050	; 0x802
 8013e2a:	f7fe fb5b 	bl	80124e4 <FATFS_LinkDriver>
 8013e2e:	f241 1334 	movw	r3, #4404	; 0x1134
 8013e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e36:	7018      	strb	r0, [r3, #0]

  /* USER CODE BEGIN Init */
  /* additional user code for init */     
  /* USER CODE END Init */
}
 8013e38:	bd08      	pop	{r3, pc}
 8013e3a:	bf00      	nop

08013e3c <BSP_PlatformIsDetected>:
#include "fatfs_platform.h"

uint8_t	BSP_PlatformIsDetected(void) {
    uint8_t status = SD_PRESENT;
    /* Check SD card detect pin */
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8013e3c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8013e40:	f44f 5100 	mov.w	r1, #8192	; 0x2000
uint8_t	BSP_PlatformIsDetected(void) {
 8013e44:	b508      	push	{r3, lr}
    if(HAL_GPIO_ReadPin(SD_DETECT_GPIO_PORT, SD_DETECT_PIN) != GPIO_PIN_RESET)
 8013e46:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8013e4a:	f7f2 fbe1 	bl	8006610 <HAL_GPIO_ReadPin>
    }
    /* USER CODE BEGIN 1 */
    /* user code can be inserted here */
    /* USER CODE END 1 */ 
    return status;
}  
 8013e4e:	fab0 f080 	clz	r0, r0
 8013e52:	0940      	lsrs	r0, r0, #5
 8013e54:	bd08      	pop	{r3, pc}
 8013e56:	bf00      	nop

08013e58 <MX_FMC_Init>:
{
  FMC_SDRAM_TimingTypeDef SdramTiming = {0};

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8013e58:	f241 539c 	movw	r3, #5532	; 0x159c
 8013e5c:	f244 1240 	movw	r2, #16704	; 0x4140
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8013e60:	2001      	movs	r0, #1
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8013e62:	2108      	movs	r1, #8
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8013e64:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8013e68:	f2c5 2200 	movt	r2, #20992	; 0x5200
{
 8013e6c:	b570      	push	{r4, r5, r6, lr}
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8013e6e:	2640      	movs	r6, #64	; 0x40
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8013e70:	2410      	movs	r4, #16
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8013e72:	f44f 7580 	mov.w	r5, #256	; 0x100
{
 8013e76:	b088      	sub	sp, #32
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
 8013e78:	6098      	str	r0, [r3, #8]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
 8013e7a:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 8013e7e:	60d9      	str	r1, [r3, #12]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8013e80:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 8013e84:	615e      	str	r6, [r3, #20]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 2;
  SdramTiming.ExitSelfRefreshDelay = 6;
  SdramTiming.SelfRefreshTime = 4;
 8013e86:	2604      	movs	r6, #4
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 8013e88:	601a      	str	r2, [r3, #0]
  SdramTiming.LoadToActiveDelay = 2;
 8013e8a:	2202      	movs	r2, #2
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_16;
 8013e8c:	611c      	str	r4, [r3, #16]
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8013e8e:	2400      	movs	r4, #0
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
 8013e90:	619d      	str	r5, [r3, #24]
  SdramTiming.ExitSelfRefreshDelay = 6;
 8013e92:	2506      	movs	r5, #6
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_3;
 8013e94:	6218      	str	r0, [r3, #32]
  SdramTiming.RowCycleDelay = 6;
  SdramTiming.WriteRecoveryTime = 2;
  SdramTiming.RPDelay = 2;
  SdramTiming.RCDDelay = 2;

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8013e96:	4618      	mov	r0, r3
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
 8013e98:	6259      	str	r1, [r3, #36]	; 0x24
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8013e9a:	eb0d 0106 	add.w	r1, sp, r6
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 8013e9e:	605c      	str	r4, [r3, #4]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8013ea0:	61dc      	str	r4, [r3, #28]
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 8013ea2:	629c      	str	r4, [r3, #40]	; 0x28
  SdramTiming.LoadToActiveDelay = 2;
 8013ea4:	9201      	str	r2, [sp, #4]
  SdramTiming.RCDDelay = 2;
 8013ea6:	9207      	str	r2, [sp, #28]
  SdramTiming.ExitSelfRefreshDelay = 6;
 8013ea8:	9502      	str	r5, [sp, #8]
  SdramTiming.RPDelay = 2;
 8013eaa:	e9cd 2205 	strd	r2, r2, [sp, #20]
  SdramTiming.SelfRefreshTime = 4;
 8013eae:	e9cd 6503 	strd	r6, r5, [sp, #12]
  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 8013eb2:	f7f9 fcbd 	bl	800d830 <HAL_SDRAM_Init>
 8013eb6:	b108      	cbz	r0, 8013ebc <MX_FMC_Init+0x64>
  {
    Error_Handler( );
 8013eb8:	f001 fcd4 	bl	8015864 <Error_Handler>
  }

  HAL_SetFMCMemorySwappingConfig(FMC_SWAPBMAP_SDRAM_SRAM);
 8013ebc:	f04f 7080 	mov.w	r0, #16777216	; 0x1000000
 8013ec0:	f7ec fdde 	bl	8000a80 <HAL_SetFMCMemorySwappingConfig>

}
 8013ec4:	b008      	add	sp, #32
 8013ec6:	bd70      	pop	{r4, r5, r6, pc}

08013ec8 <HAL_SDRAM_MspInit>:
static void HAL_FMC_MspInit(void){
  /* USER CODE BEGIN FMC_MspInit 0 */

  /* USER CODE END FMC_MspInit 0 */
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if (FMC_Initialized) {
 8013ec8:	f240 5204 	movw	r2, #1284	; 0x504
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8013ecc:	2300      	movs	r3, #0
  if (FMC_Initialized) {
 8013ece:	f2c2 0200 	movt	r2, #8192	; 0x2000
  /* USER CODE BEGIN FMC_MspInit 1 */

  /* USER CODE END FMC_MspInit 1 */
}

void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef* sdramHandle){
 8013ed2:	b5f0      	push	{r4, r5, r6, r7, lr}
 8013ed4:	b087      	sub	sp, #28
  if (FMC_Initialized) {
 8013ed6:	6814      	ldr	r4, [r2, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8013ed8:	9302      	str	r3, [sp, #8]
 8013eda:	9301      	str	r3, [sp, #4]
 8013edc:	9305      	str	r3, [sp, #20]
 8013ede:	e9cd 3303 	strd	r3, r3, [sp, #12]
  if (FMC_Initialized) {
 8013ee2:	b10c      	cbz	r4, 8013ee8 <HAL_SDRAM_MspInit+0x20>
  /* USER CODE END SDRAM_MspInit 0 */
  HAL_FMC_MspInit();
  /* USER CODE BEGIN SDRAM_MspInit 1 */

  /* USER CODE END SDRAM_MspInit 1 */
}
 8013ee4:	b007      	add	sp, #28
 8013ee6:	bdf0      	pop	{r4, r5, r6, r7, pc}
  __HAL_RCC_FMC_CLK_ENABLE();
 8013ee8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  FMC_Initialized = 1;
 8013eec:	2501      	movs	r5, #1
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 8013eee:	f64f 013f 	movw	r1, #63551	; 0xf83f
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8013ef2:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
  __HAL_RCC_FMC_CLK_ENABLE();
 8013ef6:	f6c5 0302 	movt	r3, #22530	; 0x5802
  FMC_Initialized = 1;
 8013efa:	6015      	str	r5, [r2, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013efc:	2702      	movs	r7, #2
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8013efe:	2603      	movs	r6, #3
  __HAL_RCC_FMC_CLK_ENABLE();
 8013f00:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f04:	250c      	movs	r5, #12
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8013f06:	f6c5 0002 	movt	r0, #22530	; 0x5802
  __HAL_RCC_FMC_CLK_ENABLE();
 8013f0a:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8013f0e:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 8013f12:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3 
 8013f16:	9101      	str	r1, [sp, #4]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8013f18:	a901      	add	r1, sp, #4
  __HAL_RCC_FMC_CLK_ENABLE();
 8013f1a:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013f1e:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8013f20:	9604      	str	r6, [sp, #16]
  __HAL_RCC_FMC_CLK_ENABLE();
 8013f22:	9300      	str	r3, [sp, #0]
 8013f24:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f26:	9505      	str	r5, [sp, #20]
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8013f28:	f7f1 ffdc 	bl	8005ee4 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8013f2c:	f44f 6000 	mov.w	r0, #2048	; 0x800
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
 8013f30:	230d      	movs	r3, #13
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8013f32:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013f34:	9702      	str	r7, [sp, #8]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8013f36:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_2|GPIO_PIN_3;
 8013f3a:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013f3c:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f3e:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8013f42:	f7f1 ffcf 	bl	8005ee4 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8013f46:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
 8013f4a:	f248 1337 	movw	r3, #33079	; 0x8137
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8013f4e:	a901      	add	r1, sp, #4
 8013f50:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013f54:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_4 
 8013f56:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013f58:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f5a:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8013f5e:	f7f1 ffc1 	bl	8005ee4 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8013f62:	f44f 5080 	mov.w	r0, #4096	; 0x1000
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
 8013f66:	f64f 7383 	movw	r3, #65411	; 0xff83
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8013f6a:	a901      	add	r1, sp, #4
 8013f6c:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013f70:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10 
 8013f72:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013f74:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f76:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8013f7a:	f7f1 ffb3 	bl	8005ee4 <HAL_GPIO_Init>
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013f7e:	f44f 6040 	mov.w	r0, #3072	; 0xc00
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
 8013f82:	f24c 7303 	movw	r3, #50947	; 0xc703
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013f86:	a901      	add	r1, sp, #4
 8013f88:	f6c5 0002 	movt	r0, #22530	; 0x5802
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8013f8c:	9702      	str	r7, [sp, #8]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8013f8e:	9403      	str	r4, [sp, #12]
  GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_14 
 8013f90:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Alternate = GPIO_AF12_FMC;
 8013f92:	e9cd 6504 	strd	r6, r5, [sp, #16]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8013f96:	f7f1 ffa5 	bl	8005ee4 <HAL_GPIO_Init>
}
 8013f9a:	b007      	add	sp, #28
 8013f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8013f9e:	bf00      	nop

08013fa0 <GFXdrawPixel.part.0>:
void GFXstartWrite(GFX* myGFX){
    // Overwrite in subclasses if desired!
}

// the most basic function, set a single pixel
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
 8013fa0:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
    return;

  // check rotation, move pixel around if necessary
  switch (GFXgetRotation(myGFX)) {
 8013fa2:	7a04      	ldrb	r4, [r0, #8]
 8013fa4:	2c02      	cmp	r4, #2
 8013fa6:	d057      	beq.n	8014058 <GFXdrawPixel.part.0+0xb8>
 8013fa8:	2c03      	cmp	r4, #3
 8013faa:	d04f      	beq.n	801404c <GFXdrawPixel.part.0+0xac>
 8013fac:	2c01      	cmp	r4, #1
 8013fae:	d01a      	beq.n	8013fe6 <GFXdrawPixel.part.0+0x46>
    y = myGFX->HEIGHT - y - 1;
    break;
  }

  // x is which column
    switch (color)
 8013fb0:	2b01      	cmp	r3, #1
 8013fb2:	d020      	beq.n	8013ff6 <GFXdrawPixel.part.0+0x56>
 8013fb4:	d334      	bcc.n	8014020 <GFXdrawPixel.part.0+0x80>
 8013fb6:	2b02      	cmp	r3, #2
 8013fb8:	d113      	bne.n	8013fe2 <GFXdrawPixel.part.0+0x42>
    {
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
 8013fba:	2a00      	cmp	r2, #0
 8013fbc:	4613      	mov	r3, r2
 8013fbe:	8804      	ldrh	r4, [r0, #0]
 8013fc0:	f248 4034 	movw	r0, #33844	; 0x8434
 8013fc4:	bfb8      	it	lt
 8013fc6:	1dd3      	addlt	r3, r2, #7
 8013fc8:	f002 0207 	and.w	r2, r2, #7
 8013fcc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8013fd0:	10db      	asrs	r3, r3, #3
 8013fd2:	fb13 1104 	smlabb	r1, r3, r4, r1
 8013fd6:	2301      	movs	r3, #1
 8013fd8:	fa03 f202 	lsl.w	r2, r3, r2
 8013fdc:	5c43      	ldrb	r3, [r0, r1]
 8013fde:	405a      	eors	r2, r3
 8013fe0:	5442      	strb	r2, [r0, r1]
    }

}
 8013fe2:	bc30      	pop	{r4, r5}
 8013fe4:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
 8013fe6:	43d4      	mvns	r4, r2
 8013fe8:	8805      	ldrh	r5, [r0, #0]
    _swap_int16_t(x, y);
 8013fea:	460a      	mov	r2, r1
    switch (color)
 8013fec:	2b01      	cmp	r3, #1
    x = myGFX->WIDTH - x - 1;
 8013fee:	eb04 0105 	add.w	r1, r4, r5
 8013ff2:	b209      	sxth	r1, r1
    switch (color)
 8013ff4:	d1de      	bne.n	8013fb4 <GFXdrawPixel.part.0+0x14>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
 8013ff6:	2a00      	cmp	r2, #0
 8013ff8:	4613      	mov	r3, r2
 8013ffa:	8805      	ldrh	r5, [r0, #0]
 8013ffc:	f248 4034 	movw	r0, #33844	; 0x8434
 8014000:	bfb8      	it	lt
 8014002:	1dd3      	addlt	r3, r2, #7
 8014004:	f002 0407 	and.w	r4, r2, #7
 8014008:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801400c:	2201      	movs	r2, #1
 801400e:	10db      	asrs	r3, r3, #3
 8014010:	40a2      	lsls	r2, r4
 8014012:	fb13 1105 	smlabb	r1, r3, r5, r1
 8014016:	5c43      	ldrb	r3, [r0, r1]
 8014018:	431a      	orrs	r2, r3
 801401a:	5442      	strb	r2, [r0, r1]
}
 801401c:	bc30      	pop	{r4, r5}
 801401e:	4770      	bx	lr
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
 8014020:	2a00      	cmp	r2, #0
 8014022:	4613      	mov	r3, r2
 8014024:	8804      	ldrh	r4, [r0, #0]
 8014026:	f248 4034 	movw	r0, #33844	; 0x8434
 801402a:	bfb8      	it	lt
 801402c:	1dd3      	addlt	r3, r2, #7
 801402e:	f002 0207 	and.w	r2, r2, #7
 8014032:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8014036:	10db      	asrs	r3, r3, #3
 8014038:	fb13 1104 	smlabb	r1, r3, r4, r1
 801403c:	2301      	movs	r3, #1
 801403e:	4093      	lsls	r3, r2
 8014040:	5c42      	ldrb	r2, [r0, r1]
 8014042:	ea22 0203 	bic.w	r2, r2, r3
 8014046:	5442      	strb	r2, [r0, r1]
}
 8014048:	bc30      	pop	{r4, r5}
 801404a:	4770      	bx	lr
    y = myGFX->HEIGHT - y - 1;
 801404c:	43cc      	mvns	r4, r1
 801404e:	8845      	ldrh	r5, [r0, #2]
	_swap_int16_t(x, y);
 8014050:	4611      	mov	r1, r2
    y = myGFX->HEIGHT - y - 1;
 8014052:	1962      	adds	r2, r4, r5
 8014054:	b212      	sxth	r2, r2
 8014056:	e7ab      	b.n	8013fb0 <GFXdrawPixel.part.0+0x10>
 8014058:	43c9      	mvns	r1, r1
 801405a:	43d2      	mvns	r2, r2
    x = myGFX->WIDTH - x - 1;
 801405c:	8805      	ldrh	r5, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
 801405e:	8844      	ldrh	r4, [r0, #2]
    x = myGFX->WIDTH - x - 1;
 8014060:	fa05 f181 	sxtah	r1, r5, r1
    y = myGFX->HEIGHT - y - 1;
 8014064:	4422      	add	r2, r4
    x = myGFX->WIDTH - x - 1;
 8014066:	b209      	sxth	r1, r1
    y = myGFX->HEIGHT - y - 1;
 8014068:	b212      	sxth	r2, r2
 801406a:	e7a1      	b.n	8013fb0 <GFXdrawPixel.part.0+0x10>

0801406c <GFXinit>:
	myGfx->WIDTH = w;
 801406c:	2300      	movs	r3, #0
	myGfx->_width    = w;
 801406e:	8081      	strh	r1, [r0, #4]
	myGfx->_height   = h;
 8014070:	80c2      	strh	r2, [r0, #6]
	myGfx->WIDTH = w;
 8014072:	f361 030f 	bfi	r3, r1, #0, #16
	myGfx->rotation  = 0;
 8014076:	2101      	movs	r1, #1
	myGfx->WIDTH = w;
 8014078:	f362 431f 	bfi	r3, r2, #16, #16
	myGfx->fontHeight = 8;
 801407c:	2208      	movs	r2, #8
	myGfx->rotation  = 0;
 801407e:	6141      	str	r1, [r0, #20]
	myGfx->WIDTH = w;
 8014080:	6003      	str	r3, [r0, #0]
	myGfx->rotation  = 0;
 8014082:	2300      	movs	r3, #0
	myGfx->fontHeight = 8;
 8014084:	61c2      	str	r2, [r0, #28]
	myGfx->rotation  = 0;
 8014086:	6083      	str	r3, [r0, #8]
	myGfx->gfxFont   = NULL;
 8014088:	6183      	str	r3, [r0, #24]
{
 801408a:	b430      	push	{r4, r5}
	myGfx->rotation  = 0;
 801408c:	f44f 3580 	mov.w	r5, #65536	; 0x10000
 8014090:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 8014094:	e9c0 5403 	strd	r5, r4, [r0, #12]
}
 8014098:	bc30      	pop	{r4, r5}
 801409a:	4770      	bx	lr

0801409c <GFXwriteLine>:
        uint16_t color) {
 801409c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80140a0:	b083      	sub	sp, #12
 80140a2:	460e      	mov	r6, r1
 80140a4:	4614      	mov	r4, r2
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80140a6:	4694      	mov	ip, r2
        uint16_t color) {
 80140a8:	f9bd 7030 	ldrsh.w	r7, [sp, #48]	; 0x30
 80140ac:	4683      	mov	fp, r0
 80140ae:	f8bd 0034 	ldrh.w	r0, [sp, #52]	; 0x34
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80140b2:	1ab9      	subs	r1, r7, r2
 80140b4:	1b9a      	subs	r2, r3, r6
        uint16_t color) {
 80140b6:	9001      	str	r0, [sp, #4]
    int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80140b8:	2900      	cmp	r1, #0
 80140ba:	bfb8      	it	lt
 80140bc:	4249      	neglt	r1, r1
 80140be:	2a00      	cmp	r2, #0
 80140c0:	bfb8      	it	lt
 80140c2:	4252      	neglt	r2, r2
    if (steep) {
 80140c4:	4291      	cmp	r1, r2
 80140c6:	dc6d      	bgt.n	80141a4 <GFXwriteLine+0x108>
 80140c8:	46be      	mov	lr, r7
 80140ca:	463d      	mov	r5, r7
 80140cc:	46a0      	mov	r8, r4
 80140ce:	461f      	mov	r7, r3
 80140d0:	4634      	mov	r4, r6
 80140d2:	4673      	mov	r3, lr
 80140d4:	4666      	mov	r6, ip
 80140d6:	4689      	mov	r9, r1
    if (x0 > x1) {
 80140d8:	42bc      	cmp	r4, r7
 80140da:	dd0b      	ble.n	80140f4 <GFXwriteLine+0x58>
 80140dc:	eba8 0005 	sub.w	r0, r8, r5
 80140e0:	46b6      	mov	lr, r6
 80140e2:	46a4      	mov	ip, r4
        _swap_int16_t(y0, y1);
 80140e4:	461e      	mov	r6, r3
 80140e6:	ea80 79e0 	eor.w	r9, r0, r0, asr #31
    if (x0 > x1) {
 80140ea:	463c      	mov	r4, r7
        _swap_int16_t(y0, y1);
 80140ec:	4673      	mov	r3, lr
    if (x0 > x1) {
 80140ee:	4667      	mov	r7, ip
 80140f0:	eba9 79e0 	sub.w	r9, r9, r0, asr #31
    dx = x1 - x0;
 80140f4:	eba7 0804 	sub.w	r8, r7, r4
    dy = abs(y1 - y0);
 80140f8:	fa0f f989 	sxth.w	r9, r9
    dx = x1 - x0;
 80140fc:	fa0f f888 	sxth.w	r8, r8
    int16_t err = dx / 2;
 8014100:	f1b8 0f00 	cmp.w	r8, #0
 8014104:	4645      	mov	r5, r8
 8014106:	bfb8      	it	lt
 8014108:	f108 0501 	addlt.w	r5, r8, #1
        ystep = -1;
 801410c:	429e      	cmp	r6, r3
 801410e:	bfb4      	ite	lt
 8014110:	f04f 0a01 	movlt.w	sl, #1
 8014114:	f04f 3aff 	movge.w	sl, #4294967295	; 0xffffffff
 8014118:	4291      	cmp	r1, r2
    int16_t err = dx / 2;
 801411a:	ea4f 0565 	mov.w	r5, r5, asr #1
 801411e:	dc38      	bgt.n	8014192 <GFXwriteLine+0xf6>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8014120:	2c00      	cmp	r4, #0
 8014122:	db0f      	blt.n	8014144 <GFXwriteLine+0xa8>
 8014124:	f8bb 3004 	ldrh.w	r3, [fp, #4]
 8014128:	42a3      	cmp	r3, r4
 801412a:	dd0b      	ble.n	8014144 <GFXwriteLine+0xa8>
 801412c:	0432      	lsls	r2, r6, #16
 801412e:	d409      	bmi.n	8014144 <GFXwriteLine+0xa8>
 8014130:	f8bb 0006 	ldrh.w	r0, [fp, #6]
 8014134:	4632      	mov	r2, r6
 8014136:	4621      	mov	r1, r4
 8014138:	9b01      	ldr	r3, [sp, #4]
 801413a:	42b0      	cmp	r0, r6
 801413c:	4658      	mov	r0, fp
 801413e:	dd01      	ble.n	8014144 <GFXwriteLine+0xa8>
 8014140:	f7ff ff2e 	bl	8013fa0 <GFXdrawPixel.part.0>
        err -= dy;
 8014144:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 8014148:	3401      	adds	r4, #1
        err -= dy;
 801414a:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801414c:	b224      	sxth	r4, r4
        if (err < 0) {
 801414e:	2d00      	cmp	r5, #0
 8014150:	da03      	bge.n	801415a <GFXwriteLine+0xbe>
            y0 += ystep;
 8014152:	4456      	add	r6, sl
            err += dx;
 8014154:	4445      	add	r5, r8
            y0 += ystep;
 8014156:	b236      	sxth	r6, r6
            err += dx;
 8014158:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801415a:	42bc      	cmp	r4, r7
 801415c:	dde0      	ble.n	8014120 <GFXwriteLine+0x84>
}
 801415e:	b003      	add	sp, #12
 8014160:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8014164:	f8bb 0006 	ldrh.w	r0, [fp, #6]
 8014168:	4622      	mov	r2, r4
 801416a:	4631      	mov	r1, r6
 801416c:	9b01      	ldr	r3, [sp, #4]
 801416e:	4284      	cmp	r4, r0
 8014170:	4658      	mov	r0, fp
 8014172:	da01      	bge.n	8014178 <GFXwriteLine+0xdc>
 8014174:	f7ff ff14 	bl	8013fa0 <GFXdrawPixel.part.0>
        err -= dy;
 8014178:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 801417c:	3401      	adds	r4, #1
        err -= dy;
 801417e:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 8014180:	b224      	sxth	r4, r4
        if (err < 0) {
 8014182:	2d00      	cmp	r5, #0
 8014184:	da03      	bge.n	801418e <GFXwriteLine+0xf2>
            y0 += ystep;
 8014186:	4456      	add	r6, sl
            err += dx;
 8014188:	4445      	add	r5, r8
            y0 += ystep;
 801418a:	b236      	sxth	r6, r6
            err += dx;
 801418c:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801418e:	42bc      	cmp	r4, r7
 8014190:	dce5      	bgt.n	801415e <GFXwriteLine+0xc2>
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8014192:	2e00      	cmp	r6, #0
 8014194:	dbf0      	blt.n	8014178 <GFXwriteLine+0xdc>
 8014196:	f8bb 3004 	ldrh.w	r3, [fp, #4]
 801419a:	429e      	cmp	r6, r3
 801419c:	daec      	bge.n	8014178 <GFXwriteLine+0xdc>
 801419e:	0423      	lsls	r3, r4, #16
 80141a0:	d4ea      	bmi.n	8014178 <GFXwriteLine+0xdc>
 80141a2:	e7df      	b.n	8014164 <GFXwriteLine+0xc8>
 80141a4:	461d      	mov	r5, r3
 80141a6:	46b0      	mov	r8, r6
 80141a8:	4691      	mov	r9, r2
 80141aa:	e795      	b.n	80140d8 <GFXwriteLine+0x3c>

080141ac <GFXdrawPixel>:
 80141ac:	2900      	cmp	r1, #0
 80141ae:	db2a      	blt.n	8014206 <GFXdrawPixel+0x5a>
void GFXdrawPixel(GFX* myGFX, int16_t x, int16_t y, uint16_t color) {
 80141b0:	b430      	push	{r4, r5}
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80141b2:	8884      	ldrh	r4, [r0, #4]
 80141b4:	42a1      	cmp	r1, r4
 80141b6:	da24      	bge.n	8014202 <GFXdrawPixel+0x56>
 80141b8:	2a00      	cmp	r2, #0
 80141ba:	db22      	blt.n	8014202 <GFXdrawPixel+0x56>
 80141bc:	88c4      	ldrh	r4, [r0, #6]
 80141be:	42a2      	cmp	r2, r4
 80141c0:	da1f      	bge.n	8014202 <GFXdrawPixel+0x56>
  switch (GFXgetRotation(myGFX)) {
 80141c2:	7a04      	ldrb	r4, [r0, #8]
 80141c4:	2c02      	cmp	r4, #2
 80141c6:	d055      	beq.n	8014274 <GFXdrawPixel+0xc8>
 80141c8:	2c03      	cmp	r4, #3
 80141ca:	d04d      	beq.n	8014268 <GFXdrawPixel+0xbc>
 80141cc:	2c01      	cmp	r4, #1
 80141ce:	d01b      	beq.n	8014208 <GFXdrawPixel+0x5c>
    switch (color)
 80141d0:	2b01      	cmp	r3, #1
 80141d2:	d035      	beq.n	8014240 <GFXdrawPixel+0x94>
 80141d4:	d31e      	bcc.n	8014214 <GFXdrawPixel+0x68>
 80141d6:	2b02      	cmp	r3, #2
 80141d8:	d113      	bne.n	8014202 <GFXdrawPixel+0x56>
      case INVERSE: buffer[x+ (y/8)*myGFX->WIDTH] ^=  (1 << (y&7)); break;
 80141da:	2a00      	cmp	r2, #0
 80141dc:	4613      	mov	r3, r2
 80141de:	8804      	ldrh	r4, [r0, #0]
 80141e0:	f248 4034 	movw	r0, #33844	; 0x8434
 80141e4:	bfb8      	it	lt
 80141e6:	1dd3      	addlt	r3, r2, #7
 80141e8:	f002 0207 	and.w	r2, r2, #7
 80141ec:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80141f0:	10db      	asrs	r3, r3, #3
 80141f2:	fb13 1104 	smlabb	r1, r3, r4, r1
 80141f6:	2301      	movs	r3, #1
 80141f8:	fa03 f202 	lsl.w	r2, r3, r2
 80141fc:	5c43      	ldrb	r3, [r0, r1]
 80141fe:	405a      	eors	r2, r3
 8014200:	5442      	strb	r2, [r0, r1]
}
 8014202:	bc30      	pop	{r4, r5}
 8014204:	4770      	bx	lr
 8014206:	4770      	bx	lr
    x = myGFX->WIDTH - x - 1;
 8014208:	43d4      	mvns	r4, r2
 801420a:	8805      	ldrh	r5, [r0, #0]
 801420c:	460a      	mov	r2, r1
 801420e:	1961      	adds	r1, r4, r5
 8014210:	b209      	sxth	r1, r1
 8014212:	e7dd      	b.n	80141d0 <GFXdrawPixel+0x24>
      case BLACK:   buffer[x+ (y/8)*myGFX->WIDTH] &= ~(1 << (y&7)); break;
 8014214:	2a00      	cmp	r2, #0
 8014216:	4613      	mov	r3, r2
 8014218:	8804      	ldrh	r4, [r0, #0]
 801421a:	f248 4034 	movw	r0, #33844	; 0x8434
 801421e:	bfb8      	it	lt
 8014220:	1dd3      	addlt	r3, r2, #7
 8014222:	f002 0207 	and.w	r2, r2, #7
 8014226:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801422a:	10db      	asrs	r3, r3, #3
 801422c:	fb13 1104 	smlabb	r1, r3, r4, r1
 8014230:	2301      	movs	r3, #1
 8014232:	fa03 f202 	lsl.w	r2, r3, r2
 8014236:	5c43      	ldrb	r3, [r0, r1]
 8014238:	ea23 0302 	bic.w	r3, r3, r2
 801423c:	5443      	strb	r3, [r0, r1]
 801423e:	e7e0      	b.n	8014202 <GFXdrawPixel+0x56>
      case WHITE:   buffer[x+ (y/8)*myGFX->WIDTH] |=  (1 << (y&7)); break;
 8014240:	2a00      	cmp	r2, #0
 8014242:	4613      	mov	r3, r2
 8014244:	8804      	ldrh	r4, [r0, #0]
 8014246:	f248 4034 	movw	r0, #33844	; 0x8434
 801424a:	bfb8      	it	lt
 801424c:	1dd3      	addlt	r3, r2, #7
 801424e:	f002 0207 	and.w	r2, r2, #7
 8014252:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8014256:	10db      	asrs	r3, r3, #3
 8014258:	fb13 1104 	smlabb	r1, r3, r4, r1
 801425c:	2301      	movs	r3, #1
 801425e:	4093      	lsls	r3, r2
 8014260:	5c42      	ldrb	r2, [r0, r1]
 8014262:	4313      	orrs	r3, r2
 8014264:	5443      	strb	r3, [r0, r1]
 8014266:	e7cc      	b.n	8014202 <GFXdrawPixel+0x56>
    y = myGFX->HEIGHT - y - 1;
 8014268:	8844      	ldrh	r4, [r0, #2]
 801426a:	3c01      	subs	r4, #1
 801426c:	1a64      	subs	r4, r4, r1
 801426e:	4611      	mov	r1, r2
 8014270:	b222      	sxth	r2, r4
 8014272:	e7ad      	b.n	80141d0 <GFXdrawPixel+0x24>
    x = myGFX->WIDTH - x - 1;
 8014274:	8804      	ldrh	r4, [r0, #0]
    y = myGFX->HEIGHT - y - 1;
 8014276:	43d2      	mvns	r2, r2
 8014278:	8845      	ldrh	r5, [r0, #2]
    x = myGFX->WIDTH - x - 1;
 801427a:	3c01      	subs	r4, #1
    y = myGFX->HEIGHT - y - 1;
 801427c:	442a      	add	r2, r5
    x = myGFX->WIDTH - x - 1;
 801427e:	1a61      	subs	r1, r4, r1
    y = myGFX->HEIGHT - y - 1;
 8014280:	b212      	sxth	r2, r2
    x = myGFX->WIDTH - x - 1;
 8014282:	b209      	sxth	r1, r1
 8014284:	e7a4      	b.n	80141d0 <GFXdrawPixel+0x24>
 8014286:	bf00      	nop

08014288 <GFXfillRect>:
 8014288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801428c:	440b      	add	r3, r1
 801428e:	b089      	sub	sp, #36	; 0x24
 8014290:	428b      	cmp	r3, r1
 8014292:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
 8014296:	f9bd 4048 	ldrsh.w	r4, [sp, #72]	; 0x48
 801429a:	9301      	str	r3, [sp, #4]
 801429c:	9502      	str	r5, [sp, #8]
 801429e:	dd2a      	ble.n	80142f6 <GFXfillRect+0x6e>
 80142a0:	1e66      	subs	r6, r4, #1
 80142a2:	f248 4934 	movw	r9, #33844	; 0x8434
 80142a6:	4416      	add	r6, r2
 80142a8:	f2c2 0901 	movt	r9, #8193	; 0x2001
 80142ac:	b236      	sxth	r6, r6
 80142ae:	42b2      	cmp	r2, r6
 80142b0:	bfcb      	itete	gt
 80142b2:	4614      	movgt	r4, r2
 80142b4:	4634      	movle	r4, r6
 80142b6:	4633      	movgt	r3, r6
 80142b8:	4613      	movle	r3, r2
 80142ba:	9406      	str	r4, [sp, #24]
 80142bc:	9305      	str	r3, [sp, #20]
 80142be:	1ae3      	subs	r3, r4, r3
 80142c0:	b21b      	sxth	r3, r3
 80142c2:	2b00      	cmp	r3, #0
 80142c4:	461c      	mov	r4, r3
 80142c6:	9304      	str	r3, [sp, #16]
 80142c8:	bfb8      	it	lt
 80142ca:	1c5c      	addlt	r4, r3, #1
 80142cc:	1ab3      	subs	r3, r6, r2
 80142ce:	2b00      	cmp	r3, #0
 80142d0:	ea4f 0464 	mov.w	r4, r4, asr #1
 80142d4:	bfb8      	it	lt
 80142d6:	425b      	neglt	r3, r3
 80142d8:	9407      	str	r4, [sp, #28]
 80142da:	b21b      	sxth	r3, r3
 80142dc:	9303      	str	r3, [sp, #12]
 80142de:	42b2      	cmp	r2, r6
 80142e0:	d00c      	beq.n	80142fc <GFXfillRect+0x74>
 80142e2:	e9dd 3405 	ldrd	r3, r4, [sp, #20]
 80142e6:	42a3      	cmp	r3, r4
 80142e8:	f340 80f5 	ble.w	80144d6 <GFXfillRect+0x24e>
 80142ec:	3101      	adds	r1, #1
 80142ee:	9b01      	ldr	r3, [sp, #4]
 80142f0:	b209      	sxth	r1, r1
 80142f2:	4299      	cmp	r1, r3
 80142f4:	dbf3      	blt.n	80142de <GFXfillRect+0x56>
 80142f6:	b009      	add	sp, #36	; 0x24
 80142f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80142fc:	f04f 0800 	mov.w	r8, #0
 8014300:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8014304:	460f      	mov	r7, r1
 8014306:	460c      	mov	r4, r1
 8014308:	4643      	mov	r3, r8
 801430a:	4615      	mov	r5, r2
 801430c:	9100      	str	r1, [sp, #0]
 801430e:	e044      	b.n	801439a <GFXfillRect+0x112>
 8014310:	2d00      	cmp	r5, #0
 8014312:	db35      	blt.n	8014380 <GFXfillRect+0xf8>
 8014314:	f8b0 e004 	ldrh.w	lr, [r0, #4]
 8014318:	4575      	cmp	r5, lr
 801431a:	da31      	bge.n	8014380 <GFXfillRect+0xf8>
 801431c:	0421      	lsls	r1, r4, #16
 801431e:	d42f      	bmi.n	8014380 <GFXfillRect+0xf8>
 8014320:	f8b0 e006 	ldrh.w	lr, [r0, #6]
 8014324:	4574      	cmp	r4, lr
 8014326:	da2b      	bge.n	8014380 <GFXfillRect+0xf8>
 8014328:	f890 e008 	ldrb.w	lr, [r0, #8]
 801432c:	f1be 0f02 	cmp.w	lr, #2
 8014330:	f000 80c0 	beq.w	80144b4 <GFXfillRect+0x22c>
 8014334:	f1be 0f03 	cmp.w	lr, #3
 8014338:	f000 80b2 	beq.w	80144a0 <GFXfillRect+0x218>
 801433c:	f1be 0f01 	cmp.w	lr, #1
 8014340:	f000 80a4 	beq.w	801448c <GFXfillRect+0x204>
 8014344:	46a6      	mov	lr, r4
 8014346:	46aa      	mov	sl, r5
 8014348:	9902      	ldr	r1, [sp, #8]
 801434a:	2901      	cmp	r1, #1
 801434c:	d043      	beq.n	80143d6 <GFXfillRect+0x14e>
 801434e:	d361      	bcc.n	8014414 <GFXfillRect+0x18c>
 8014350:	2902      	cmp	r1, #2
 8014352:	d115      	bne.n	8014380 <GFXfillRect+0xf8>
 8014354:	f1be 0f00 	cmp.w	lr, #0
 8014358:	46f3      	mov	fp, lr
 801435a:	8801      	ldrh	r1, [r0, #0]
 801435c:	bfb8      	it	lt
 801435e:	f10e 0b07 	addlt.w	fp, lr, #7
 8014362:	f00e 0e07 	and.w	lr, lr, #7
 8014366:	ea4f 0beb 	mov.w	fp, fp, asr #3
 801436a:	fb1b aa01 	smlabb	sl, fp, r1, sl
 801436e:	2101      	movs	r1, #1
 8014370:	f819 b00a 	ldrb.w	fp, [r9, sl]
 8014374:	fa01 fe0e 	lsl.w	lr, r1, lr
 8014378:	ea8e 0e0b 	eor.w	lr, lr, fp
 801437c:	f809 e00a 	strb.w	lr, [r9, sl]
 8014380:	eba3 030c 	sub.w	r3, r3, ip
 8014384:	b21b      	sxth	r3, r3
 8014386:	2b00      	cmp	r3, #0
 8014388:	da03      	bge.n	8014392 <GFXfillRect+0x10a>
 801438a:	3d01      	subs	r5, #1
 801438c:	4443      	add	r3, r8
 801438e:	b22d      	sxth	r5, r5
 8014390:	b21b      	sxth	r3, r3
 8014392:	3401      	adds	r4, #1
 8014394:	b224      	sxth	r4, r4
 8014396:	42bc      	cmp	r4, r7
 8014398:	dc34      	bgt.n	8014404 <GFXfillRect+0x17c>
 801439a:	42b2      	cmp	r2, r6
 801439c:	d1b8      	bne.n	8014310 <GFXfillRect+0x88>
 801439e:	2c00      	cmp	r4, #0
 80143a0:	dbee      	blt.n	8014380 <GFXfillRect+0xf8>
 80143a2:	f8b0 e004 	ldrh.w	lr, [r0, #4]
 80143a6:	4574      	cmp	r4, lr
 80143a8:	daea      	bge.n	8014380 <GFXfillRect+0xf8>
 80143aa:	0429      	lsls	r1, r5, #16
 80143ac:	d4e8      	bmi.n	8014380 <GFXfillRect+0xf8>
 80143ae:	f8b0 e006 	ldrh.w	lr, [r0, #6]
 80143b2:	4575      	cmp	r5, lr
 80143b4:	dae4      	bge.n	8014380 <GFXfillRect+0xf8>
 80143b6:	f890 e008 	ldrb.w	lr, [r0, #8]
 80143ba:	f1be 0f02 	cmp.w	lr, #2
 80143be:	d04a      	beq.n	8014456 <GFXfillRect+0x1ce>
 80143c0:	f1be 0f03 	cmp.w	lr, #3
 80143c4:	d03d      	beq.n	8014442 <GFXfillRect+0x1ba>
 80143c6:	f1be 0f01 	cmp.w	lr, #1
 80143ca:	d055      	beq.n	8014478 <GFXfillRect+0x1f0>
 80143cc:	9902      	ldr	r1, [sp, #8]
 80143ce:	46ae      	mov	lr, r5
 80143d0:	46a2      	mov	sl, r4
 80143d2:	2901      	cmp	r1, #1
 80143d4:	d1bb      	bne.n	801434e <GFXfillRect+0xc6>
 80143d6:	f1be 0f00 	cmp.w	lr, #0
 80143da:	46f3      	mov	fp, lr
 80143dc:	8801      	ldrh	r1, [r0, #0]
 80143de:	bfb8      	it	lt
 80143e0:	f10e 0b07 	addlt.w	fp, lr, #7
 80143e4:	f00e 0e07 	and.w	lr, lr, #7
 80143e8:	ea4f 0beb 	mov.w	fp, fp, asr #3
 80143ec:	fb1b aa01 	smlabb	sl, fp, r1, sl
 80143f0:	2101      	movs	r1, #1
 80143f2:	f819 b00a 	ldrb.w	fp, [r9, sl]
 80143f6:	fa01 fe0e 	lsl.w	lr, r1, lr
 80143fa:	ea4e 0e0b 	orr.w	lr, lr, fp
 80143fe:	f809 e00a 	strb.w	lr, [r9, sl]
 8014402:	e7bd      	b.n	8014380 <GFXfillRect+0xf8>
 8014404:	9900      	ldr	r1, [sp, #0]
 8014406:	9b01      	ldr	r3, [sp, #4]
 8014408:	3101      	adds	r1, #1
 801440a:	b209      	sxth	r1, r1
 801440c:	4299      	cmp	r1, r3
 801440e:	f6ff af66 	blt.w	80142de <GFXfillRect+0x56>
 8014412:	e770      	b.n	80142f6 <GFXfillRect+0x6e>
 8014414:	f1be 0f00 	cmp.w	lr, #0
 8014418:	46f3      	mov	fp, lr
 801441a:	8801      	ldrh	r1, [r0, #0]
 801441c:	bfb8      	it	lt
 801441e:	f10e 0b07 	addlt.w	fp, lr, #7
 8014422:	f00e 0e07 	and.w	lr, lr, #7
 8014426:	ea4f 0beb 	mov.w	fp, fp, asr #3
 801442a:	fb1b aa01 	smlabb	sl, fp, r1, sl
 801442e:	2101      	movs	r1, #1
 8014430:	f819 b00a 	ldrb.w	fp, [r9, sl]
 8014434:	fa01 fe0e 	lsl.w	lr, r1, lr
 8014438:	ea2b 0e0e 	bic.w	lr, fp, lr
 801443c:	f809 e00a 	strb.w	lr, [r9, sl]
 8014440:	e79e      	b.n	8014380 <GFXfillRect+0xf8>
 8014442:	f8b0 e002 	ldrh.w	lr, [r0, #2]
 8014446:	46aa      	mov	sl, r5
 8014448:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 801444c:	ebae 0e04 	sub.w	lr, lr, r4
 8014450:	fa0f fe8e 	sxth.w	lr, lr
 8014454:	e778      	b.n	8014348 <GFXfillRect+0xc0>
 8014456:	f8b0 a000 	ldrh.w	sl, [r0]
 801445a:	f8b0 e002 	ldrh.w	lr, [r0, #2]
 801445e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8014462:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 8014466:	ebaa 0a04 	sub.w	sl, sl, r4
 801446a:	ebae 0e05 	sub.w	lr, lr, r5
 801446e:	fa0f fa8a 	sxth.w	sl, sl
 8014472:	fa0f fe8e 	sxth.w	lr, lr
 8014476:	e767      	b.n	8014348 <GFXfillRect+0xc0>
 8014478:	f8b0 a000 	ldrh.w	sl, [r0]
 801447c:	46a6      	mov	lr, r4
 801447e:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8014482:	ebaa 0a05 	sub.w	sl, sl, r5
 8014486:	fa0f fa8a 	sxth.w	sl, sl
 801448a:	e75d      	b.n	8014348 <GFXfillRect+0xc0>
 801448c:	f8b0 a000 	ldrh.w	sl, [r0]
 8014490:	46ae      	mov	lr, r5
 8014492:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 8014496:	ebaa 0a04 	sub.w	sl, sl, r4
 801449a:	fa0f fa8a 	sxth.w	sl, sl
 801449e:	e753      	b.n	8014348 <GFXfillRect+0xc0>
 80144a0:	f8b0 e002 	ldrh.w	lr, [r0, #2]
 80144a4:	46a2      	mov	sl, r4
 80144a6:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 80144aa:	ebae 0e05 	sub.w	lr, lr, r5
 80144ae:	fa0f fe8e 	sxth.w	lr, lr
 80144b2:	e749      	b.n	8014348 <GFXfillRect+0xc0>
 80144b4:	f8b0 a000 	ldrh.w	sl, [r0]
 80144b8:	f8b0 e002 	ldrh.w	lr, [r0, #2]
 80144bc:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80144c0:	f10e 3eff 	add.w	lr, lr, #4294967295	; 0xffffffff
 80144c4:	ebaa 0a05 	sub.w	sl, sl, r5
 80144c8:	ebae 0e04 	sub.w	lr, lr, r4
 80144cc:	fa0f fa8a 	sxth.w	sl, sl
 80144d0:	fa0f fe8e 	sxth.w	lr, lr
 80144d4:	e738      	b.n	8014348 <GFXfillRect+0xc0>
 80144d6:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80144da:	460d      	mov	r5, r1
 80144dc:	9c05      	ldr	r4, [sp, #20]
 80144de:	f04f 0c00 	mov.w	ip, #0
 80144e2:	9100      	str	r1, [sp, #0]
 80144e4:	e9dd 7306 	ldrd	r7, r3, [sp, #24]
 80144e8:	e757      	b.n	801439a <GFXfillRect+0x112>
 80144ea:	bf00      	nop

080144ec <GFXdrawChar>:

// TEXT- AND CHARACTER-HANDLING FUNCTIONS ----------------------------------

// Draw a character
void GFXdrawChar(GFX* myGFX, int16_t x, int16_t y, unsigned char c,
  uint16_t color, uint16_t bg, uint8_t size) {
 80144ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80144f0:	b09d      	sub	sp, #116	; 0x74
 80144f2:	4682      	mov	sl, r0

    if(!myGFX->gfxFont) { // 'Classic' built-in font
 80144f4:	6980      	ldr	r0, [r0, #24]
  uint16_t color, uint16_t bg, uint8_t size) {
 80144f6:	9212      	str	r2, [sp, #72]	; 0x48
 80144f8:	f8bd 2098 	ldrh.w	r2, [sp, #152]	; 0x98
 80144fc:	9103      	str	r1, [sp, #12]
 80144fe:	9208      	str	r2, [sp, #32]
 8014500:	f8bd 209c 	ldrh.w	r2, [sp, #156]	; 0x9c
 8014504:	9202      	str	r2, [sp, #8]
 8014506:	f89d 20a0 	ldrb.w	r2, [sp, #160]	; 0xa0
 801450a:	920c      	str	r2, [sp, #48]	; 0x30
    if(!myGFX->gfxFont) { // 'Classic' built-in font
 801450c:	2800      	cmp	r0, #0
 801450e:	f000 80f4 	beq.w	80146fa <GFXdrawChar+0x20e>

        // Character is assumed previously filtered by write() to eliminate
        // newlines, returns, non-printable characters, etc.  Calling
        // drawChar() directly with 'bad' characters of font may cause mayhem!

        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
 8014512:	7a01      	ldrb	r1, [r0, #8]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 8014514:	6842      	ldr	r2, [r0, #4]
        c -= (uint8_t)pgm_read_byte(&myGFX->gfxFont->first);
 8014516:	1a5b      	subs	r3, r3, r1
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
 8014518:	6801      	ldr	r1, [r0, #0]
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 801451a:	b2db      	uxtb	r3, r3
        uint8_t  *bitmap = (uint8_t *)pgm_read_pointer(&myGFX->gfxFont->bitmap);
 801451c:	910f      	str	r1, [sp, #60]	; 0x3c
        GFXglyph *glyph  = &(((GFXglyph *)pgm_read_pointer(&myGFX->gfxFont->glyph))[c]);
 801451e:	eb02 03c3 	add.w	r3, r2, r3, lsl #3

        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 8014522:	881a      	ldrh	r2, [r3, #0]
        uint8_t  w  = pgm_read_byte(&glyph->width),
                 h  = pgm_read_byte(&glyph->height);
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
                 yo = pgm_read_byte(&glyph->yOffset);
 8014524:	f993 1006 	ldrsb.w	r1, [r3, #6]
        uint16_t bo = pgm_read_word(&glyph->bitmapOffset);
 8014528:	9209      	str	r2, [sp, #36]	; 0x24
        uint8_t  w  = pgm_read_byte(&glyph->width),
 801452a:	789a      	ldrb	r2, [r3, #2]
                 yo = pgm_read_byte(&glyph->yOffset);
 801452c:	911b      	str	r1, [sp, #108]	; 0x6c
        uint8_t  w  = pgm_read_byte(&glyph->width),
 801452e:	9207      	str	r2, [sp, #28]
                 h  = pgm_read_byte(&glyph->height);
 8014530:	78da      	ldrb	r2, [r3, #3]
 8014532:	9213      	str	r2, [sp, #76]	; 0x4c
        int8_t   xo = pgm_read_byte(&glyph->xOffset),
 8014534:	f993 2005 	ldrsb.w	r2, [r3, #5]
        uint8_t  xx, yy, bits = 0, bit = 0;
        int16_t  xo16 = 0, yo16 = 0;

        if(size > 1) {
 8014538:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801453a:	2b01      	cmp	r3, #1
 801453c:	f240 80a7 	bls.w	801468e <GFXdrawChar+0x1a2>
            xo16 = xo;
            yo16 = yo;
 8014540:	b209      	sxth	r1, r1
            xo16 = xo;
 8014542:	b213      	sxth	r3, r2
            yo16 = yo;
 8014544:	9115      	str	r1, [sp, #84]	; 0x54
        // this (a canvas object type for MCUs that can afford the RAM and
        // displays supporting setAddrWindow() and pushColors()), but haven't
        // implemented this yet.

        //startWrite();
        for(yy=0; yy<h; yy++) {
 8014546:	9913      	ldr	r1, [sp, #76]	; 0x4c
 8014548:	2900      	cmp	r1, #0
 801454a:	f000 80a6 	beq.w	801469a <GFXdrawChar+0x1ae>
 801454e:	9907      	ldr	r1, [sp, #28]
 8014550:	2900      	cmp	r1, #0
 8014552:	f000 80a2 	beq.w	801469a <GFXdrawChar+0x1ae>
 8014556:	9c03      	ldr	r4, [sp, #12]
        uint8_t  xx, yy, bits = 0, bit = 0;
 8014558:	2000      	movs	r0, #0
                }
                if(bits & 0x80) {
                    if(size == 1) {
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
                    } else {
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 801455a:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 801455c:	18a2      	adds	r2, r4, r2
        uint8_t  xx, yy, bits = 0, bit = 0;
 801455e:	9006      	str	r0, [sp, #24]
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8014560:	b229      	sxth	r1, r5
        uint8_t  xx, yy, bits = 0, bit = 0;
 8014562:	9002      	str	r0, [sp, #8]
 8014564:	921a      	str	r2, [sp, #104]	; 0x68
 8014566:	b2aa      	uxth	r2, r5
 8014568:	fb01 4303 	mla	r3, r1, r3, r4
 801456c:	920a      	str	r2, [sp, #40]	; 0x28
 801456e:	1e4a      	subs	r2, r1, #1
 8014570:	b29b      	uxth	r3, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8014572:	9116      	str	r1, [sp, #88]	; 0x58
 8014574:	9218      	str	r2, [sp, #96]	; 0x60
 8014576:	4602      	mov	r2, r0
        for(yy=0; yy<h; yy++) {
 8014578:	900e      	str	r0, [sp, #56]	; 0x38
 801457a:	9317      	str	r3, [sp, #92]	; 0x5c
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 801457c:	9b15      	ldr	r3, [sp, #84]	; 0x54
    int16_t err = dx / 2;
 801457e:	2700      	movs	r7, #0
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8014580:	9912      	ldr	r1, [sp, #72]	; 0x48
 8014582:	4413      	add	r3, r2
 8014584:	9a16      	ldr	r2, [sp, #88]	; 0x58
 8014586:	fb03 1302 	mla	r3, r3, r2, r1
 801458a:	b21a      	sxth	r2, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801458c:	9b18      	ldr	r3, [sp, #96]	; 0x60
 801458e:	18d3      	adds	r3, r2, r3
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8014590:	9210      	str	r2, [sp, #64]	; 0x40
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8014592:	b219      	sxth	r1, r3
 8014594:	4613      	mov	r3, r2
 8014596:	428a      	cmp	r2, r1
 8014598:	9104      	str	r1, [sp, #16]
 801459a:	bfa8      	it	ge
 801459c:	460a      	movge	r2, r1
 801459e:	428b      	cmp	r3, r1
 80145a0:	bfb8      	it	lt
 80145a2:	460b      	movlt	r3, r1
 80145a4:	920b      	str	r2, [sp, #44]	; 0x2c
 80145a6:	9910      	ldr	r1, [sp, #64]	; 0x40
 80145a8:	4698      	mov	r8, r3
    dx = x1 - x0;
 80145aa:	1a9b      	subs	r3, r3, r2
 80145ac:	b21b      	sxth	r3, r3
    int16_t err = dx / 2;
 80145ae:	2b00      	cmp	r3, #0
 80145b0:	461a      	mov	r2, r3
    dx = x1 - x0;
 80145b2:	9314      	str	r3, [sp, #80]	; 0x50
    int16_t err = dx / 2;
 80145b4:	bfb8      	it	lt
 80145b6:	1c5a      	addlt	r2, r3, #1
 80145b8:	9b04      	ldr	r3, [sp, #16]
 80145ba:	1a5b      	subs	r3, r3, r1
 80145bc:	1052      	asrs	r2, r2, #1
 80145be:	2b00      	cmp	r3, #0
 80145c0:	9219      	str	r2, [sp, #100]	; 0x64
 80145c2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80145c4:	bfb8      	it	lt
 80145c6:	425b      	neglt	r3, r3
 80145c8:	9203      	str	r2, [sp, #12]
    dy = abs(y1 - y0);
 80145ca:	fa0f f983 	sxth.w	r9, r3
 80145ce:	e00e      	b.n	80145ee <GFXdrawChar+0x102>
                          size, size, color);
                    }
                }
                bits <<= 1;
 80145d0:	9b02      	ldr	r3, [sp, #8]
 80145d2:	3701      	adds	r7, #1
 80145d4:	9a03      	ldr	r2, [sp, #12]
 80145d6:	990a      	ldr	r1, [sp, #40]	; 0x28
 80145d8:	005b      	lsls	r3, r3, #1
 80145da:	b2bf      	uxth	r7, r7
 80145dc:	440a      	add	r2, r1
 80145de:	b2db      	uxtb	r3, r3
 80145e0:	b292      	uxth	r2, r2
 80145e2:	9302      	str	r3, [sp, #8]
            for(xx=0; xx<w; xx++) {
 80145e4:	b2fb      	uxtb	r3, r7
 80145e6:	9203      	str	r2, [sp, #12]
 80145e8:	9a07      	ldr	r2, [sp, #28]
 80145ea:	429a      	cmp	r2, r3
 80145ec:	d958      	bls.n	80146a0 <GFXdrawChar+0x1b4>
                if(!(bit++ & 7)) {
 80145ee:	9b06      	ldr	r3, [sp, #24]
 80145f0:	443b      	add	r3, r7
 80145f2:	0759      	lsls	r1, r3, #29
 80145f4:	d106      	bne.n	8014604 <GFXdrawChar+0x118>
                    bits = pgm_read_byte(&bitmap[bo++]);
 80145f6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80145f8:	990f      	ldr	r1, [sp, #60]	; 0x3c
 80145fa:	1c53      	adds	r3, r2, #1
 80145fc:	5c8a      	ldrb	r2, [r1, r2]
 80145fe:	b29b      	uxth	r3, r3
 8014600:	9202      	str	r2, [sp, #8]
 8014602:	9309      	str	r3, [sp, #36]	; 0x24
                if(bits & 0x80) {
 8014604:	9b02      	ldr	r3, [sp, #8]
 8014606:	061a      	lsls	r2, r3, #24
 8014608:	d5e2      	bpl.n	80145d0 <GFXdrawChar+0xe4>
                    if(size == 1) {
 801460a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801460c:	2b01      	cmp	r3, #1
 801460e:	d057      	beq.n	80146c0 <GFXdrawChar+0x1d4>
                    	GFXwriteFillRect(myGFX,x+(xo16+xx)*size, y+(yo16+yy)*size,
 8014610:	f9bd 600c 	ldrsh.w	r6, [sp, #12]
    for (int16_t i=x; i<x+w; i++) {
 8014614:	4433      	add	r3, r6
 8014616:	42b3      	cmp	r3, r6
 8014618:	9305      	str	r3, [sp, #20]
 801461a:	ddd9      	ble.n	80145d0 <GFXdrawChar+0xe4>
 801461c:	9711      	str	r7, [sp, #68]	; 0x44
 801461e:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8014620:	e008      	b.n	8014634 <GFXdrawChar+0x148>
    for (; x0<=x1; x0++) {
 8014622:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014624:	4543      	cmp	r3, r8
 8014626:	f340 8140 	ble.w	80148aa <GFXdrawChar+0x3be>
    for (int16_t i=x; i<x+w; i++) {
 801462a:	3601      	adds	r6, #1
 801462c:	9b05      	ldr	r3, [sp, #20]
 801462e:	b236      	sxth	r6, r6
 8014630:	429e      	cmp	r6, r3
 8014632:	da2a      	bge.n	801468a <GFXdrawChar+0x19e>
    if (steep) {
 8014634:	9b04      	ldr	r3, [sp, #16]
 8014636:	429f      	cmp	r7, r3
 8014638:	d1f3      	bne.n	8014622 <GFXdrawChar+0x136>
    dy = abs(y1 - y0);
 801463a:	4634      	mov	r4, r6
 801463c:	46bb      	mov	fp, r7
    int16_t err = dx / 2;
 801463e:	2500      	movs	r5, #0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 8014640:	2c00      	cmp	r4, #0
 8014642:	db10      	blt.n	8014666 <GFXdrawChar+0x17a>
 8014644:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 8014648:	42a3      	cmp	r3, r4
 801464a:	dd0c      	ble.n	8014666 <GFXdrawChar+0x17a>
 801464c:	f1bb 0f00 	cmp.w	fp, #0
 8014650:	db09      	blt.n	8014666 <GFXdrawChar+0x17a>
 8014652:	f8ba 0006 	ldrh.w	r0, [sl, #6]
 8014656:	465a      	mov	r2, fp
 8014658:	4621      	mov	r1, r4
 801465a:	9b08      	ldr	r3, [sp, #32]
 801465c:	4558      	cmp	r0, fp
 801465e:	4650      	mov	r0, sl
 8014660:	dd01      	ble.n	8014666 <GFXdrawChar+0x17a>
 8014662:	f7ff fc9d 	bl	8013fa0 <GFXdrawPixel.part.0>
        err -= dy;
 8014666:	eba5 0509 	sub.w	r5, r5, r9
    for (; x0<=x1; x0++) {
 801466a:	3401      	adds	r4, #1
        err -= dy;
 801466c:	b22d      	sxth	r5, r5
    for (; x0<=x1; x0++) {
 801466e:	b224      	sxth	r4, r4
        if (err < 0) {
 8014670:	2d00      	cmp	r5, #0
 8014672:	da03      	bge.n	801467c <GFXdrawChar+0x190>
            y0 += ystep;
 8014674:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 8014678:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
 801467c:	42a6      	cmp	r6, r4
 801467e:	dadf      	bge.n	8014640 <GFXdrawChar+0x154>
    for (int16_t i=x; i<x+w; i++) {
 8014680:	3601      	adds	r6, #1
 8014682:	9b05      	ldr	r3, [sp, #20]
 8014684:	b236      	sxth	r6, r6
 8014686:	429e      	cmp	r6, r3
 8014688:	dbd4      	blt.n	8014634 <GFXdrawChar+0x148>
 801468a:	9f11      	ldr	r7, [sp, #68]	; 0x44
 801468c:	e7a0      	b.n	80145d0 <GFXdrawChar+0xe4>
        int16_t  xo16 = 0, yo16 = 0;
 801468e:	2300      	movs	r3, #0
        for(yy=0; yy<h; yy++) {
 8014690:	9913      	ldr	r1, [sp, #76]	; 0x4c
        int16_t  xo16 = 0, yo16 = 0;
 8014692:	9315      	str	r3, [sp, #84]	; 0x54
        for(yy=0; yy<h; yy++) {
 8014694:	2900      	cmp	r1, #0
 8014696:	f47f af5a 	bne.w	801454e <GFXdrawChar+0x62>
            }
        }
        //endWrite();

    } // End classic vs custom font
}
 801469a:	b01d      	add	sp, #116	; 0x74
 801469c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80146a0:	4611      	mov	r1, r2
 80146a2:	9b06      	ldr	r3, [sp, #24]
        for(yy=0; yy<h; yy++) {
 80146a4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 80146a6:	440b      	add	r3, r1
 80146a8:	3201      	adds	r2, #1
 80146aa:	b2db      	uxtb	r3, r3
 80146ac:	b2d2      	uxtb	r2, r2
 80146ae:	9306      	str	r3, [sp, #24]
 80146b0:	9b13      	ldr	r3, [sp, #76]	; 0x4c
 80146b2:	920e      	str	r2, [sp, #56]	; 0x38
 80146b4:	4293      	cmp	r3, r2
 80146b6:	f63f af61 	bhi.w	801457c <GFXdrawChar+0x90>
}
 80146ba:	b01d      	add	sp, #116	; 0x74
 80146bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80146c0:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 80146c2:	18f9      	adds	r1, r7, r3
 80146c4:	b209      	sxth	r1, r1
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80146c6:	2900      	cmp	r1, #0
 80146c8:	db82      	blt.n	80145d0 <GFXdrawChar+0xe4>
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80146ca:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80146cc:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80146ce:	980e      	ldr	r0, [sp, #56]	; 0x38
 80146d0:	189a      	adds	r2, r3, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80146d2:	f8ba 3004 	ldrh.w	r3, [sl, #4]
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80146d6:	4402      	add	r2, r0
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80146d8:	4299      	cmp	r1, r3
                        GFXwritePixel(myGFX,x+xo+xx, y+yo+yy, color);
 80146da:	b212      	sxth	r2, r2
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80146dc:	f6bf af78 	bge.w	80145d0 <GFXdrawChar+0xe4>
 80146e0:	2a00      	cmp	r2, #0
 80146e2:	f6ff af75 	blt.w	80145d0 <GFXdrawChar+0xe4>
 80146e6:	f8ba 3006 	ldrh.w	r3, [sl, #6]
 80146ea:	429a      	cmp	r2, r3
 80146ec:	f6bf af70 	bge.w	80145d0 <GFXdrawChar+0xe4>
 80146f0:	9b08      	ldr	r3, [sp, #32]
 80146f2:	4650      	mov	r0, sl
 80146f4:	f7ff fc54 	bl	8013fa0 <GFXdrawPixel.part.0>
 80146f8:	e76a      	b.n	80145d0 <GFXdrawChar+0xe4>
        if((x >= myGFX->_width)            || // Clip right
 80146fa:	f8ba 2004 	ldrh.w	r2, [sl, #4]
 80146fe:	4291      	cmp	r1, r2
 8014700:	dacb      	bge.n	801469a <GFXdrawChar+0x1ae>
           (y >= myGFX->_height)           || // Clip bottom
 8014702:	f8ba 2006 	ldrh.w	r2, [sl, #6]
        if((x >= myGFX->_width)            || // Clip right
 8014706:	9c12      	ldr	r4, [sp, #72]	; 0x48
 8014708:	4294      	cmp	r4, r2
 801470a:	dac6      	bge.n	801469a <GFXdrawChar+0x1ae>
           ((x + 6 * size - 1) < 0) || // Clip left
 801470c:	3901      	subs	r1, #1
 801470e:	2206      	movs	r2, #6
 8014710:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8014712:	fb12 1205 	smlabb	r2, r2, r5, r1
           (y >= myGFX->_height)           || // Clip bottom
 8014716:	2a00      	cmp	r2, #0
 8014718:	dbbf      	blt.n	801469a <GFXdrawChar+0x1ae>
           ((y + 8 * size - 1) < 0))   // Clip top
 801471a:	1e62      	subs	r2, r4, #1
 801471c:	9211      	str	r2, [sp, #68]	; 0x44
           ((x + 6 * size - 1) < 0) || // Clip left
 801471e:	eb12 02c5 	adds.w	r2, r2, r5, lsl #3
 8014722:	d4ba      	bmi.n	801469a <GFXdrawChar+0x1ae>
        if(!myGFX->_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
 8014724:	f8ba 2016 	ldrh.w	r2, [sl, #22]
 8014728:	b91a      	cbnz	r2, 8014732 <GFXdrawChar+0x246>
 801472a:	2baf      	cmp	r3, #175	; 0xaf
 801472c:	d901      	bls.n	8014732 <GFXdrawChar+0x246>
 801472e:	3301      	adds	r3, #1
 8014730:	b2db      	uxtb	r3, r3
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 8014732:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8014736:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 8014738:	2200      	movs	r2, #0
 801473a:	f8bd 100c 	ldrh.w	r1, [sp, #12]
 801473e:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8014742:	9206      	str	r2, [sp, #24]
 8014744:	b2a2      	uxth	r2, r4
 8014746:	009b      	lsls	r3, r3, #2
 8014748:	910f      	str	r1, [sp, #60]	; 0x3c
 801474a:	9204      	str	r2, [sp, #16]
 801474c:	3a01      	subs	r2, #1
 801474e:	9309      	str	r3, [sp, #36]	; 0x24
 8014750:	b223      	sxth	r3, r4
 8014752:	9107      	str	r1, [sp, #28]
 8014754:	9310      	str	r3, [sp, #64]	; 0x40
 8014756:	f8bd 3048 	ldrh.w	r3, [sp, #72]	; 0x48
 801475a:	920b      	str	r2, [sp, #44]	; 0x2c
 801475c:	930a      	str	r3, [sp, #40]	; 0x28
 801475e:	460b      	mov	r3, r1
 8014760:	9906      	ldr	r1, [sp, #24]
    GFXdrawPixel(myGFX, x, y, color);
 8014762:	440b      	add	r3, r1
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 8014764:	9909      	ldr	r1, [sp, #36]	; 0x24
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 8014766:	f9bd 201c 	ldrsh.w	r2, [sp, #28]
    for (int16_t i=x; i<x+w; i++) {
 801476a:	2700      	movs	r7, #0
            uint8_t line = pgm_read_byte(&myGFX->gfxFont[c * 5 + i]);
 801476c:	f810 9001 	ldrb.w	r9, [r0, r1]
    GFXdrawPixel(myGFX, x, y, color);
 8014770:	b21b      	sxth	r3, r3
    for (int16_t i=x; i<x+w; i++) {
 8014772:	990c      	ldr	r1, [sp, #48]	; 0x30
 8014774:	46b8      	mov	r8, r7
 8014776:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8014778:	188e      	adds	r6, r1, r2
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 801477a:	9205      	str	r2, [sp, #20]
    GFXdrawPixel(myGFX, x, y, color);
 801477c:	930e      	str	r3, [sp, #56]	; 0x38
                if(line & 1) {
 801477e:	f019 0f01 	tst.w	r9, #1
 8014782:	d035      	beq.n	80147f0 <GFXdrawChar+0x304>
                    if(size == 1)
 8014784:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8014786:	2b01      	cmp	r3, #1
 8014788:	d055      	beq.n	8014836 <GFXdrawChar+0x34a>
    for (int16_t i=x; i<x+w; i++) {
 801478a:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, color);
 801478c:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
 8014790:	42b4      	cmp	r4, r6
 8014792:	da11      	bge.n	80147b8 <GFXdrawChar+0x2cc>
 8014794:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8014796:	950d      	str	r5, [sp, #52]	; 0x34
 8014798:	18ef      	adds	r7, r5, r3
 801479a:	9d08      	ldr	r5, [sp, #32]
 801479c:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801479e:	4623      	mov	r3, r4
 80147a0:	4621      	mov	r1, r4
    for (int16_t i=x; i<x+w; i++) {
 80147a2:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80147a4:	9501      	str	r5, [sp, #4]
 80147a6:	9700      	str	r7, [sp, #0]
 80147a8:	465a      	mov	r2, fp
    for (int16_t i=x; i<x+w; i++) {
 80147aa:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80147ac:	4650      	mov	r0, sl
 80147ae:	f7ff fc75 	bl	801409c <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 80147b2:	42b4      	cmp	r4, r6
 80147b4:	dbf3      	blt.n	801479e <GFXdrawChar+0x2b2>
 80147b6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 80147b8:	9b04      	ldr	r3, [sp, #16]
 80147ba:	f108 0801 	add.w	r8, r8, #1
            for(int8_t j=0; j<8; j++, line >>= 1) {
 80147be:	ea4f 0959 	mov.w	r9, r9, lsr #1
 80147c2:	441d      	add	r5, r3
 80147c4:	f1b8 0f08 	cmp.w	r8, #8
 80147c8:	b2ad      	uxth	r5, r5
 80147ca:	d1d8      	bne.n	801477e <GFXdrawChar+0x292>
 80147cc:	461a      	mov	r2, r3
 80147ce:	9b07      	ldr	r3, [sp, #28]
 80147d0:	9909      	ldr	r1, [sp, #36]	; 0x24
 80147d2:	4413      	add	r3, r2
 80147d4:	9a06      	ldr	r2, [sp, #24]
 80147d6:	310c      	adds	r1, #12
 80147d8:	3201      	adds	r2, #1
 80147da:	b29b      	uxth	r3, r3
 80147dc:	9109      	str	r1, [sp, #36]	; 0x24
        for(int8_t i=0; i<5; i++ ) { // Char bitmap = 5 columns
 80147de:	2a05      	cmp	r2, #5
 80147e0:	9206      	str	r2, [sp, #24]
 80147e2:	9307      	str	r3, [sp, #28]
 80147e4:	d03b      	beq.n	801485e <GFXdrawChar+0x372>
 80147e6:	f8da 0018 	ldr.w	r0, [sl, #24]
 80147ea:	4611      	mov	r1, r2
 80147ec:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80147ee:	e7b8      	b.n	8014762 <GFXdrawChar+0x276>
                } else if(bg != color) {
 80147f0:	9b08      	ldr	r3, [sp, #32]
 80147f2:	9a02      	ldr	r2, [sp, #8]
 80147f4:	4293      	cmp	r3, r2
 80147f6:	d0df      	beq.n	80147b8 <GFXdrawChar+0x2cc>
                    if(size == 1)
 80147f8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80147fa:	2b01      	cmp	r3, #1
 80147fc:	d025      	beq.n	801484a <GFXdrawChar+0x35e>
    for (int16_t i=x; i<x+w; i++) {
 80147fe:	9c05      	ldr	r4, [sp, #20]
                    	GFXwriteFillRect(myGFX,x+i*size, y+j*size, size, size, bg);
 8014800:	fa0f fb85 	sxth.w	fp, r5
    for (int16_t i=x; i<x+w; i++) {
 8014804:	42b4      	cmp	r4, r6
 8014806:	dad7      	bge.n	80147b8 <GFXdrawChar+0x2cc>
 8014808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801480a:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
 801480e:	46a9      	mov	r9, r5
 8014810:	18ef      	adds	r7, r5, r3
 8014812:	9d02      	ldr	r5, [sp, #8]
 8014814:	b23f      	sxth	r7, r7
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8014816:	4623      	mov	r3, r4
 8014818:	4621      	mov	r1, r4
    for (int16_t i=x; i<x+w; i++) {
 801481a:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801481c:	9501      	str	r5, [sp, #4]
 801481e:	9700      	str	r7, [sp, #0]
 8014820:	465a      	mov	r2, fp
    for (int16_t i=x; i<x+w; i++) {
 8014822:	b224      	sxth	r4, r4
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8014824:	4650      	mov	r0, sl
 8014826:	f7ff fc39 	bl	801409c <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 801482a:	42b4      	cmp	r4, r6
 801482c:	dbf3      	blt.n	8014816 <GFXdrawChar+0x32a>
 801482e:	464d      	mov	r5, r9
 8014830:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
 8014834:	e7c0      	b.n	80147b8 <GFXdrawChar+0x2cc>
    GFXdrawPixel(myGFX, x, y, color);
 8014836:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8014838:	4650      	mov	r0, sl
 801483a:	990e      	ldr	r1, [sp, #56]	; 0x38
 801483c:	eb03 0208 	add.w	r2, r3, r8
 8014840:	9b08      	ldr	r3, [sp, #32]
 8014842:	b212      	sxth	r2, r2
 8014844:	f7ff fcb2 	bl	80141ac <GFXdrawPixel>
 8014848:	e7b6      	b.n	80147b8 <GFXdrawChar+0x2cc>
 801484a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801484c:	4650      	mov	r0, sl
 801484e:	990e      	ldr	r1, [sp, #56]	; 0x38
 8014850:	eb03 0208 	add.w	r2, r3, r8
 8014854:	9b02      	ldr	r3, [sp, #8]
 8014856:	b212      	sxth	r2, r2
 8014858:	f7ff fca8 	bl	80141ac <GFXdrawPixel>
 801485c:	e7ac      	b.n	80147b8 <GFXdrawChar+0x2cc>
        if(bg != color) { // If opaque, draw vertical line for last column
 801485e:	9b08      	ldr	r3, [sp, #32]
 8014860:	9a02      	ldr	r2, [sp, #8]
 8014862:	4293      	cmp	r3, r2
 8014864:	f43f af19 	beq.w	801469a <GFXdrawChar+0x1ae>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8014868:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801486a:	2b01      	cmp	r3, #1
 801486c:	d043      	beq.n	80148f6 <GFXdrawChar+0x40a>
            else          GFXwriteFillRect(myGFX,x+5*size, y, size, 8*size, bg);
 801486e:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8014870:	eb03 0483 	add.w	r4, r3, r3, lsl #2
 8014874:	00dd      	lsls	r5, r3, #3
 8014876:	9b03      	ldr	r3, [sp, #12]
 8014878:	4423      	add	r3, r4
 801487a:	b21c      	sxth	r4, r3
    for (int16_t i=x; i<x+w; i++) {
 801487c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 801487e:	4423      	add	r3, r4
 8014880:	42a3      	cmp	r3, r4
 8014882:	461e      	mov	r6, r3
 8014884:	f77f af09 	ble.w	801469a <GFXdrawChar+0x1ae>
 8014888:	9b11      	ldr	r3, [sp, #68]	; 0x44
 801488a:	441d      	add	r5, r3
 801488c:	b22d      	sxth	r5, r5
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801488e:	9b02      	ldr	r3, [sp, #8]
 8014890:	4621      	mov	r1, r4
 8014892:	9500      	str	r5, [sp, #0]
 8014894:	4650      	mov	r0, sl
 8014896:	9301      	str	r3, [sp, #4]
 8014898:	4623      	mov	r3, r4
    for (int16_t i=x; i<x+w; i++) {
 801489a:	3401      	adds	r4, #1
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 801489c:	9a12      	ldr	r2, [sp, #72]	; 0x48
 801489e:	f7ff fbfd 	bl	801409c <GFXwriteLine>
    for (int16_t i=x; i<x+w; i++) {
 80148a2:	b224      	sxth	r4, r4
 80148a4:	42a6      	cmp	r6, r4
 80148a6:	dcf2      	bgt.n	801488e <GFXdrawChar+0x3a2>
 80148a8:	e6f7      	b.n	801469a <GFXdrawChar+0x1ae>
    for (; x0<=x1; x0++) {
 80148aa:	4635      	mov	r5, r6
 80148ac:	960d      	str	r6, [sp, #52]	; 0x34
    int16_t err = dx / 2;
 80148ae:	f8dd b064 	ldr.w	fp, [sp, #100]	; 0x64
    for (; x0<=x1; x0++) {
 80148b2:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
 80148b4:	9e14      	ldr	r6, [sp, #80]	; 0x50
  if ((x < 0) || (x >= myGFX->_width) || (y < 0) || (y >= myGFX->_height))
 80148b6:	2d00      	cmp	r5, #0
 80148b8:	db0f      	blt.n	80148da <GFXdrawChar+0x3ee>
 80148ba:	f8ba 3004 	ldrh.w	r3, [sl, #4]
 80148be:	429d      	cmp	r5, r3
 80148c0:	da0b      	bge.n	80148da <GFXdrawChar+0x3ee>
 80148c2:	0423      	lsls	r3, r4, #16
 80148c4:	d409      	bmi.n	80148da <GFXdrawChar+0x3ee>
 80148c6:	f8ba 0006 	ldrh.w	r0, [sl, #6]
 80148ca:	4622      	mov	r2, r4
 80148cc:	4629      	mov	r1, r5
 80148ce:	9b08      	ldr	r3, [sp, #32]
 80148d0:	4284      	cmp	r4, r0
 80148d2:	4650      	mov	r0, sl
 80148d4:	da01      	bge.n	80148da <GFXdrawChar+0x3ee>
 80148d6:	f7ff fb63 	bl	8013fa0 <GFXdrawPixel.part.0>
    for (; x0<=x1; x0++) {
 80148da:	3401      	adds	r4, #1
        if (err < 0) {
 80148dc:	f1bb 0f00 	cmp.w	fp, #0
    for (; x0<=x1; x0++) {
 80148e0:	b224      	sxth	r4, r4
        if (err < 0) {
 80148e2:	da04      	bge.n	80148ee <GFXdrawChar+0x402>
            y0 += ystep;
 80148e4:	3d01      	subs	r5, #1
            err += dx;
 80148e6:	44b3      	add	fp, r6
            y0 += ystep;
 80148e8:	b22d      	sxth	r5, r5
            err += dx;
 80148ea:	fa0f fb8b 	sxth.w	fp, fp
    for (; x0<=x1; x0++) {
 80148ee:	4544      	cmp	r4, r8
 80148f0:	dde1      	ble.n	80148b6 <GFXdrawChar+0x3ca>
 80148f2:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80148f4:	e699      	b.n	801462a <GFXdrawChar+0x13e>
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 80148f6:	9b03      	ldr	r3, [sp, #12]
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80148f8:	4650      	mov	r0, sl
 80148fa:	9a12      	ldr	r2, [sp, #72]	; 0x48
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 80148fc:	3305      	adds	r3, #5
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 80148fe:	9902      	ldr	r1, [sp, #8]
 8014900:	1dd4      	adds	r4, r2, #7
            if(size == 1) GFXwriteFastVLine(myGFX,x+5, y, 8, bg);
 8014902:	b21b      	sxth	r3, r3
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8014904:	9127      	str	r1, [sp, #156]	; 0x9c
 8014906:	b224      	sxth	r4, r4
 8014908:	4619      	mov	r1, r3
 801490a:	9426      	str	r4, [sp, #152]	; 0x98
}
 801490c:	b01d      	add	sp, #116	; 0x74
 801490e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    GFXwriteLine(myGFX,x, y, x, y+h-1, color);
 8014912:	f7ff bbc3 	b.w	801409c <GFXwriteLine>
 8014916:	bf00      	nop

08014918 <GFXwrite>:
        }
  }
}


void GFXwrite(GFX* myGFX, uint8_t c) {
 8014918:	b5f0      	push	{r4, r5, r6, r7, lr}
	if(!myGFX->gfxFont) { // 'Classic' built-in font
 801491a:	6983      	ldr	r3, [r0, #24]
void GFXwrite(GFX* myGFX, uint8_t c) {
 801491c:	b085      	sub	sp, #20
 801491e:	4604      	mov	r4, r0
	if(!myGFX->gfxFont) { // 'Classic' built-in font
 8014920:	b32b      	cbz	r3, 801496e <GFXwrite+0x56>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
		}

	} else { // Custom font

		if(c == '\n') {
 8014922:	290a      	cmp	r1, #10
 8014924:	d018      	beq.n	8014958 <GFXwrite+0x40>
			myGFX->cursor_x  = 0;
			myGFX->cursor_y += (int16_t)myGFX->textsize *
						(uint8_t)pgm_read_byte(&myGFX->gfxFont->yAdvance);
		} else if(c != '\r') {
 8014926:	290d      	cmp	r1, #13
 8014928:	d01f      	beq.n	801496a <GFXwrite+0x52>
			uint8_t first = pgm_read_byte(&myGFX->gfxFont->first);
 801492a:	7a1a      	ldrb	r2, [r3, #8]
			if((c >= first) && (c <= (uint8_t)pgm_read_byte(&myGFX->gfxFont->last))) {
 801492c:	4291      	cmp	r1, r2
 801492e:	d31c      	bcc.n	801496a <GFXwrite+0x52>
 8014930:	7a58      	ldrb	r0, [r3, #9]
 8014932:	4288      	cmp	r0, r1
 8014934:	d319      	bcc.n	801496a <GFXwrite+0x52>
				GFXglyph *glyph = &(((GFXglyph *)pgm_read_pointer(
				  &myGFX->gfxFont->glyph))[c - first]);
 8014936:	1a8a      	subs	r2, r1, r2
 8014938:	685d      	ldr	r5, [r3, #4]
 801493a:	89e0      	ldrh	r0, [r4, #14]
 801493c:	eb05 05c2 	add.w	r5, r5, r2, lsl #3
 8014940:	b203      	sxth	r3, r0
				uint8_t   w     = pgm_read_byte(&glyph->width),
						  h     = pgm_read_byte(&glyph->height);
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
 8014942:	78ea      	ldrb	r2, [r5, #3]
				uint8_t   w     = pgm_read_byte(&glyph->width),
 8014944:	78ae      	ldrb	r6, [r5, #2]
				if((w > 0) && (h > 0)) { // Is there an associated bitmap?
 8014946:	b10a      	cbz	r2, 801494c <GFXwrite+0x34>
 8014948:	2e00      	cmp	r6, #0
 801494a:	d157      	bne.n	80149fc <GFXwrite+0xe4>
					//     cursor_y += (int16_t)textsize *
					//       (uint8_t)pgm_read_byte(&gfxFont->yAdvance);
					// }
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
				}
				myGFX->cursor_x += (uint8_t)pgm_read_byte(&glyph->xAdvance) * (int16_t)myGFX->textsize;
 801494c:	7929      	ldrb	r1, [r5, #4]
 801494e:	89a2      	ldrh	r2, [r4, #12]
 8014950:	fb01 2303 	mla	r3, r1, r3, r2
 8014954:	81a3      	strh	r3, [r4, #12]
			}
		}

	}
}
 8014956:	e008      	b.n	801496a <GFXwrite+0x52>
			myGFX->cursor_x  = 0;
 8014958:	2000      	movs	r0, #0
			myGFX->cursor_y += (int16_t)myGFX->textsize *
 801495a:	8962      	ldrh	r2, [r4, #10]
 801495c:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
			myGFX->cursor_x  = 0;
 8014960:	81a0      	strh	r0, [r4, #12]
			myGFX->cursor_y += (int16_t)myGFX->textsize *
 8014962:	7a9b      	ldrb	r3, [r3, #10]
 8014964:	fb01 2303 	mla	r3, r1, r3, r2
 8014968:	8163      	strh	r3, [r4, #10]
}
 801496a:	b005      	add	sp, #20
 801496c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if(c == '\n') {                        // Newline?
 801496e:	290a      	cmp	r1, #10
 8014970:	d03c      	beq.n	80149ec <GFXwrite+0xd4>
		} else if(c != '\r') {                 // Ignore carriage returns
 8014972:	290d      	cmp	r1, #13
 8014974:	d0f9      	beq.n	801496a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8014976:	8a85      	ldrh	r5, [r0, #20]
 8014978:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
 801497c:	89c0      	ldrh	r0, [r0, #14]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 801497e:	b135      	cbz	r5, 801498e <GFXwrite+0x76>
 8014980:	89a7      	ldrh	r7, [r4, #12]
			GFXcheckScrollWrap(myGFX, myGFX->textsize * 6 - myGFX->textsize * 2);
 8014982:	0085      	lsls	r5, r0, #2
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8014984:	88a6      	ldrh	r6, [r4, #4]
 8014986:	fa07 f585 	sxtah	r5, r7, r5
 801498a:	42b5      	cmp	r5, r6
 801498c:	da6d      	bge.n	8014a6a <GFXwrite+0x152>
    if (myGFX->autoscroll) {
 801498e:	8c23      	ldrh	r3, [r4, #32]
 8014990:	b1b3      	cbz	r3, 80149c0 <GFXwrite+0xa8>
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8014992:	8ba5      	ldrh	r5, [r4, #28]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8014994:	8be3      	ldrh	r3, [r4, #30]
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 8014996:	fb15 f500 	smulbb	r5, r5, r0
        if (cursor >= myGFX->_height) {
 801499a:	88e7      	ldrh	r7, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 801499c:	fb13 f300 	smulbb	r3, r3, r0
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 80149a0:	3d01      	subs	r5, #1
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 80149a2:	b21b      	sxth	r3, r3
            fontOffset = (myGFX->fontHeight * myGFX->textsize)-1; // cursor defines upper left corner of char
 80149a4:	b22d      	sxth	r5, r5
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 80149a6:	18ee      	adds	r6, r5, r3
 80149a8:	4416      	add	r6, r2
        if (cursor >= myGFX->_height) {
 80149aa:	b2b6      	uxth	r6, r6
 80149ac:	42be      	cmp	r6, r7
 80149ae:	d307      	bcc.n	80149c0 <GFXwrite+0xa8>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 80149b0:	43da      	mvns	r2, r3
            myGFX->cursor_x  = 0;
 80149b2:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 80149b4:	443a      	add	r2, r7
            myGFX->cursor_x  = 0;
 80149b6:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 80149b8:	1b52      	subs	r2, r2, r5
 80149ba:	b212      	sxth	r2, r2
 80149bc:	8162      	strh	r2, [r4, #10]
 80149be:	e001      	b.n	80149c4 <GFXwrite+0xac>
 80149c0:	f9b4 600c 	ldrsh.w	r6, [r4, #12]
			GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
 80149c4:	8a67      	ldrh	r7, [r4, #18]
 80149c6:	b2c0      	uxtb	r0, r0
 80149c8:	8a25      	ldrh	r5, [r4, #16]
 80149ca:	460b      	mov	r3, r1
 80149cc:	9002      	str	r0, [sp, #8]
 80149ce:	4631      	mov	r1, r6
 80149d0:	4620      	mov	r0, r4
 80149d2:	e9cd 5700 	strd	r5, r7, [sp]
 80149d6:	f7ff fd89 	bl	80144ec <GFXdrawChar>
			myGFX->cursor_x += myGFX->textsize * 6;          // Advance x one char
 80149da:	89e3      	ldrh	r3, [r4, #14]
 80149dc:	89a2      	ldrh	r2, [r4, #12]
 80149de:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80149e2:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80149e6:	81a3      	strh	r3, [r4, #12]
}
 80149e8:	b005      	add	sp, #20
 80149ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
 80149ec:	8b82      	ldrh	r2, [r0, #28]
 80149ee:	8961      	ldrh	r1, [r4, #10]
 80149f0:	89c0      	ldrh	r0, [r0, #14]
			myGFX->cursor_x  = 0;                     // Reset x to zero,
 80149f2:	81a3      	strh	r3, [r4, #12]
			myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize;
 80149f4:	fb12 1300 	smlabb	r3, r2, r0, r1
 80149f8:	8163      	strh	r3, [r4, #10]
 80149fa:	e7b6      	b.n	801496a <GFXwrite+0x52>
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 80149fc:	8aa7      	ldrh	r7, [r4, #20]
 80149fe:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
 8014a02:	b197      	cbz	r7, 8014a2a <GFXwrite+0x112>
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8014a04:	f995 7005 	ldrsb.w	r7, [r5, #5]
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8014a08:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8014a0c:	443e      	add	r6, r7
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8014a0e:	88a7      	ldrh	r7, [r4, #4]
					GFXcheckScrollWrap(myGFX, myGFX->textsize * (xo + w));
 8014a10:	fb16 f303 	smulbb	r3, r6, r3
    if(myGFX->wrap && ((myGFX->cursor_x + fontWidth) >= myGFX->_width)) { // Heading off edge?
 8014a14:	fa0c f383 	sxtah	r3, ip, r3
 8014a18:	42bb      	cmp	r3, r7
 8014a1a:	db06      	blt.n	8014a2a <GFXwrite+0x112>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8014a1c:	8ba3      	ldrh	r3, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8014a1e:	2600      	movs	r6, #0
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8014a20:	fb13 2200 	smlabb	r2, r3, r0, r2
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8014a24:	81a6      	strh	r6, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8014a26:	b212      	sxth	r2, r2
 8014a28:	8162      	strh	r2, [r4, #10]
    if (myGFX->autoscroll) {
 8014a2a:	8c23      	ldrh	r3, [r4, #32]
 8014a2c:	b323      	cbz	r3, 8014a78 <GFXwrite+0x160>
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8014a2e:	8be3      	ldrh	r3, [r4, #30]
        if (cursor >= myGFX->_height) {
 8014a30:	88e6      	ldrh	r6, [r4, #6]
        uint16_t cursor = myGFX->cursor_y + fontOffset + myGFX->fontDesc * myGFX->textsize;
 8014a32:	fb13 f300 	smulbb	r3, r3, r0
 8014a36:	b21b      	sxth	r3, r3
 8014a38:	189f      	adds	r7, r3, r2
        if (cursor >= myGFX->_height) {
 8014a3a:	b2bf      	uxth	r7, r7
 8014a3c:	42b7      	cmp	r7, r6
 8014a3e:	d31b      	bcc.n	8014a78 <GFXwrite+0x160>
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8014a40:	1e72      	subs	r2, r6, #1
            myGFX->cursor_x  = 0;
 8014a42:	2600      	movs	r6, #0
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8014a44:	1ad3      	subs	r3, r2, r3
 8014a46:	46b4      	mov	ip, r6
            myGFX->cursor_x  = 0;
 8014a48:	81a6      	strh	r6, [r4, #12]
            myGFX->cursor_y = myGFX->_height - fontOffset-1 - myGFX->fontDesc * myGFX->textsize;
 8014a4a:	b21a      	sxth	r2, r3
 8014a4c:	8162      	strh	r2, [r4, #10]
					GFXdrawChar(myGFX, myGFX->cursor_x, myGFX->cursor_y, c, myGFX->textcolor, myGFX->textbgcolor, myGFX->textsize);
 8014a4e:	8a67      	ldrh	r7, [r4, #18]
 8014a50:	b2c0      	uxtb	r0, r0
 8014a52:	8a26      	ldrh	r6, [r4, #16]
 8014a54:	460b      	mov	r3, r1
 8014a56:	9002      	str	r0, [sp, #8]
 8014a58:	4661      	mov	r1, ip
 8014a5a:	4620      	mov	r0, r4
 8014a5c:	e9cd 6700 	strd	r6, r7, [sp]
 8014a60:	f7ff fd44 	bl	80144ec <GFXdrawChar>
 8014a64:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8014a68:	e770      	b.n	801494c <GFXwrite+0x34>
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8014a6a:	8ba5      	ldrh	r5, [r4, #28]
    	myGFX->cursor_x  = 0;            // Reset x to zero
 8014a6c:	81a3      	strh	r3, [r4, #12]
    	myGFX->cursor_y += myGFX->fontHeight * myGFX->textsize; // Advance y one line
 8014a6e:	fb15 2200 	smlabb	r2, r5, r0, r2
 8014a72:	b212      	sxth	r2, r2
 8014a74:	8162      	strh	r2, [r4, #10]
 8014a76:	e78a      	b.n	801498e <GFXwrite+0x76>
 8014a78:	f9b4 c00c 	ldrsh.w	ip, [r4, #12]
 8014a7c:	e7e7      	b.n	8014a4e <GFXwrite+0x136>
 8014a7e:	bf00      	nop

08014a80 <GFXsetCursor>:

void GFXsetCursor(GFX* myGFX, int16_t x, int16_t y) {
	myGFX->cursor_x = x;
 8014a80:	8181      	strh	r1, [r0, #12]
	myGFX->cursor_y = y;
 8014a82:	8142      	strh	r2, [r0, #10]
}
 8014a84:	4770      	bx	lr
 8014a86:	bf00      	nop

08014a88 <GFXgetCursorX>:

int16_t GFXgetCursorX(GFX* myGFX)
{
    return myGFX->cursor_x;
}
 8014a88:	f9b0 000c 	ldrsh.w	r0, [r0, #12]
 8014a8c:	4770      	bx	lr
 8014a8e:	bf00      	nop

08014a90 <GFXsetTextSize>:
{
    return myGFX->cursor_y;
}

void GFXsetTextSize(GFX* myGFX, uint8_t s) {
	myGFX->textsize = (s > 0) ? s : 1;
 8014a90:	2900      	cmp	r1, #0
 8014a92:	bf08      	it	eq
 8014a94:	2101      	moveq	r1, #1
 8014a96:	81c1      	strh	r1, [r0, #14]
}
 8014a98:	4770      	bx	lr
 8014a9a:	bf00      	nop

08014a9c <GFXsetTextColor>:

void GFXsetTextColor(GFX* myGFX, uint16_t c, uint16_t b) {
	myGFX->textcolor   = c;
 8014a9c:	8201      	strh	r1, [r0, #16]
	myGFX->textbgcolor = b;
 8014a9e:	8242      	strh	r2, [r0, #18]
}
 8014aa0:	4770      	bx	lr
 8014aa2:	bf00      	nop

08014aa4 <GFXsetFont>:
// to this function to use correct CP437 character values in your code.
void GFXcp437(GFX* myGFX, uint8_t x) {
	myGFX->_cp437 = x;
}

void GFXsetFont(GFX* myGFX, const GFXfont *f) {
 8014aa4:	6983      	ldr	r3, [r0, #24]

	if(f)
 8014aa6:	b139      	cbz	r1, 8014ab8 <GFXsetFont+0x14>
    {            // Font struct pointer passed in?
        if(!myGFX->gfxFont) { // And no current font struct?
 8014aa8:	b10b      	cbz	r3, 8014aae <GFXsetFont+0xa>
		}

		myGFX->fontHeight = 8;
		myGFX->fontDesc = 0;
	}
    myGFX->gfxFont = (GFXfont *)f;
 8014aaa:	6181      	str	r1, [r0, #24]
}
 8014aac:	4770      	bx	lr
        	myGFX->cursor_y += 6;
 8014aae:	8943      	ldrh	r3, [r0, #10]
    myGFX->gfxFont = (GFXfont *)f;
 8014ab0:	6181      	str	r1, [r0, #24]
        	myGFX->cursor_y += 6;
 8014ab2:	3306      	adds	r3, #6
 8014ab4:	8143      	strh	r3, [r0, #10]
}
 8014ab6:	4770      	bx	lr
	else if(myGFX->gfxFont)
 8014ab8:	b113      	cbz	r3, 8014ac0 <GFXsetFont+0x1c>
		myGFX->fontDesc = 0;
 8014aba:	83c1      	strh	r1, [r0, #30]
		uint8_t first  = (uint8_t) pgm_read_byte(&f->first);
 8014abc:	7a0b      	ldrb	r3, [r1, #8]
 8014abe:	deff      	udf	#255	; 0xff
		myGFX->fontHeight = 8;
 8014ac0:	2308      	movs	r3, #8
 8014ac2:	61c3      	str	r3, [r0, #28]
 8014ac4:	e7f1      	b.n	8014aaa <GFXsetFont+0x6>
 8014ac6:	bf00      	nop

08014ac8 <OLEDparseInt>:
	'A', '#',
	'B', ' '
};

int OLEDparseInt(char* buffer, uint32_t myNumber, uint8_t numDigits)
{
 8014ac8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	for (int i = 0; i < numDigits; i++)
 8014aca:	4617      	mov	r7, r2
 8014acc:	b1ca      	cbz	r2, 8014b02 <OLEDparseInt+0x3a>
 8014ace:	460d      	mov	r5, r1
 8014ad0:	4606      	mov	r6, r0
 8014ad2:	1e54      	subs	r4, r2, #1
	{
		int whichPlace = (uint32_t)(powf(10.0f,(numDigits - 1) - i));
 8014ad4:	ee07 4a90 	vmov	s15, r4
 8014ad8:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8014adc:	3c01      	subs	r4, #1
 8014ade:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8014ae2:	f016 fbd9 	bl	802b298 <powf>
 8014ae6:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8014aea:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
 8014aee:	fbb5 f2f3 	udiv	r2, r5, r3
		buffer[i] = thisDigit + 48;
 8014af2:	f102 0130 	add.w	r1, r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
 8014af6:	fb02 5513 	mls	r5, r2, r3, r5
	for (int i = 0; i < numDigits; i++)
 8014afa:	1c63      	adds	r3, r4, #1
		buffer[i] = thisDigit + 48;
 8014afc:	f806 1b01 	strb.w	r1, [r6], #1
	for (int i = 0; i < numDigits; i++)
 8014b00:	d1e8      	bne.n	8014ad4 <OLEDparseInt+0xc>
	}

	return numDigits;
}
 8014b02:	4638      	mov	r0, r7
 8014b04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8014b06:	bf00      	nop

08014b08 <OLEDparsePitch>:

int OLEDparsePitch(char* buffer, float midi, uint8_t showCents)
{
	int pclass, octave, note, neg = 0; float offset;

	note = (int)midi;
 8014b08:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	offset = midi - note;

	if ((midi + 0.5f) > (note+1))
 8014b0c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
	note = (int)midi;
 8014b10:	ee17 3a10 	vmov	r3, s14
	offset = midi - note;
 8014b14:	eef8 6ac7 	vcvt.f32.s32	s13, s14
	if ((midi + 0.5f) > (note+1))
 8014b18:	ee70 7a27 	vadd.f32	s15, s0, s15
{
 8014b1c:	b470      	push	{r4, r5, r6}
	if ((midi + 0.5f) > (note+1))
 8014b1e:	1c5c      	adds	r4, r3, #1
	offset = midi - note;
 8014b20:	ee30 0a66 	vsub.f32	s0, s0, s13
	if ((midi + 0.5f) > (note+1))
 8014b24:	ee07 4a10 	vmov	s14, r4
 8014b28:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8014b2c:	eef4 7ac7 	vcmpe.f32	s15, s14
 8014b30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014b34:	dd4a      	ble.n	8014bcc <OLEDparsePitch+0xc4>
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
 8014b36:	f244 72ae 	movw	r2, #18350	; 0x47ae
		note += 1;
 8014b3a:	4623      	mov	r3, r4
		neg = 1;
 8014b3c:	2601      	movs	r6, #1
		offset = (1.0f - offset) + 0.01f;
 8014b3e:	f6c3 7281 	movt	r2, #16257	; 0x3f81
 8014b42:	ee07 2a90 	vmov	s15, r2
 8014b46:	ee37 0ac0 	vsub.f32	s0, s15, s0
	}

	pclass = (note % 12);
 8014b4a:	f64a 25ab 	movw	r5, #43691	; 0xaaab
 8014b4e:	17da      	asrs	r2, r3, #31
	octave = (int)(note / 12) - 1;

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
 8014b50:	f240 0420 	movw	r4, #32
	pclass = (note % 12);
 8014b54:	f6c2 25aa 	movt	r5, #10922	; 0x2aaa
	buffer[idx++] = pitches[pclass*2];
 8014b58:	f2c2 0400 	movt	r4, #8192	; 0x2000
	pclass = (note % 12);
 8014b5c:	fb85 c503 	smull	ip, r5, r5, r3
 8014b60:	ebc2 0265 	rsb	r2, r2, r5, asr #1
 8014b64:	eb02 0542 	add.w	r5, r2, r2, lsl #1
		buffer[i] = thisDigit + 48;
 8014b68:	322f      	adds	r2, #47	; 0x2f
	pclass = (note % 12);
 8014b6a:	eba3 0385 	sub.w	r3, r3, r5, lsl #2
	buffer[idx++] = pitches[pclass*2];
 8014b6e:	f814 5013 	ldrb.w	r5, [r4, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
 8014b72:	eb04 0343 	add.w	r3, r4, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
 8014b76:	7005      	strb	r5, [r0, #0]
	buffer[idx++] = pitches[pclass*2+1];
 8014b78:	785b      	ldrb	r3, [r3, #1]
		buffer[i] = thisDigit + 48;
 8014b7a:	7082      	strb	r2, [r0, #2]
	buffer[idx++] = pitches[pclass*2+1];
 8014b7c:	7043      	strb	r3, [r0, #1]

	OLEDparseInt(&buffer[idx++], octave, 1);

	if (showCents)
 8014b7e:	b339      	cbz	r1, 8014bd0 <OLEDparsePitch+0xc8>
		if (neg == 1)
			buffer[idx++] = '-';
		else
			buffer[idx++] = '+';

		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8014b80:	2300      	movs	r3, #0
		if (neg == 1)
 8014b82:	2e01      	cmp	r6, #1
		int thisDigit = (myNumber / whichPlace);
 8014b84:	f64c 42cd 	movw	r2, #52429	; 0xcccd
		buffer[idx++] = ' ';
 8014b88:	f04f 0120 	mov.w	r1, #32
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8014b8c:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
			buffer[idx++] = '+';
 8014b90:	bf0c      	ite	eq
 8014b92:	242d      	moveq	r4, #45	; 0x2d
 8014b94:	242b      	movne	r4, #43	; 0x2b
		int thisDigit = (myNumber / whichPlace);
 8014b96:	f6cc 42cc 	movt	r2, #52428	; 0xcccc
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8014b9a:	ee07 3a90 	vmov	s15, r3
		buffer[idx++] = ' ';
 8014b9e:	70c1      	strb	r1, [r0, #3]
 8014ba0:	7104      	strb	r4, [r0, #4]
		idx += 2;
 8014ba2:	2107      	movs	r1, #7
		OLEDparseInt(&buffer[idx], (uint32_t) (offset * 100.0f), 2);
 8014ba4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8014ba8:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8014bac:	ee17 3a90 	vmov	r3, s15
		int thisDigit = (myNumber / whichPlace);
 8014bb0:	fba2 4203 	umull	r4, r2, r2, r3
 8014bb4:	08d2      	lsrs	r2, r2, #3
		myNumber -= thisDigit * whichPlace;
 8014bb6:	eb02 0482 	add.w	r4, r2, r2, lsl #2
		buffer[i] = thisDigit + 48;
 8014bba:	3230      	adds	r2, #48	; 0x30
		myNumber -= thisDigit * whichPlace;
 8014bbc:	eba3 0344 	sub.w	r3, r3, r4, lsl #1
		buffer[i] = thisDigit + 48;
 8014bc0:	7142      	strb	r2, [r0, #5]
 8014bc2:	3330      	adds	r3, #48	; 0x30
 8014bc4:	7183      	strb	r3, [r0, #6]
	}

	return idx;
}
 8014bc6:	4608      	mov	r0, r1
 8014bc8:	bc70      	pop	{r4, r5, r6}
 8014bca:	4770      	bx	lr
	int pclass, octave, note, neg = 0; float offset;
 8014bcc:	2600      	movs	r6, #0
 8014bce:	e7bc      	b.n	8014b4a <OLEDparsePitch+0x42>
	OLEDparseInt(&buffer[idx++], octave, 1);
 8014bd0:	2103      	movs	r1, #3
}
 8014bd2:	bc70      	pop	{r4, r5, r6}
 8014bd4:	4608      	mov	r0, r1
 8014bd6:	4770      	bx	lr

08014bd8 <OLEDparsePitchClass>:
int OLEDparsePitchClass(char* buffer, float midi)
{
	int pclass, note;
	float offset;

	note = (int)midi;
 8014bd8:	eebd 7ac0 	vcvt.s32.f32	s14, s0
	{
		note += 1;
		offset = (1.0f - offset) + 0.01f;
	}

	pclass = (note % 12);
 8014bdc:	f64a 21ab 	movw	r1, #43691	; 0xaaab
	if ((midi + 0.5f) > (note+1))
 8014be0:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5

	int idx = 0;

	buffer[idx++] = pitches[pclass*2];
 8014be4:	f240 0220 	movw	r2, #32
	pclass = (note % 12);
 8014be8:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
	note = (int)midi;
 8014bec:	ee17 3a10 	vmov	r3, s14
	buffer[idx++] = pitches[pclass*2];
 8014bf0:	f2c2 0200 	movt	r2, #8192	; 0x2000
	if ((midi + 0.5f) > (note+1))
 8014bf4:	ee30 0a27 	vadd.f32	s0, s0, s15
{
 8014bf8:	b430      	push	{r4, r5}
	if ((midi + 0.5f) > (note+1))
 8014bfa:	1c5c      	adds	r4, r3, #1
{
 8014bfc:	4605      	mov	r5, r0
	buffer[idx++] = pitches[pclass*2+1];

	return idx;
}
 8014bfe:	2002      	movs	r0, #2
	if ((midi + 0.5f) > (note+1))
 8014c00:	ee07 4a90 	vmov	s15, r4
 8014c04:	eef8 7ae7 	vcvt.f32.s32	s15, s15
		note += 1;
 8014c08:	eeb4 0a67 	vcmp.f32	s0, s15
 8014c0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8014c10:	bfc8      	it	gt
 8014c12:	4623      	movgt	r3, r4
	pclass = (note % 12);
 8014c14:	fb81 1403 	smull	r1, r4, r1, r3
 8014c18:	17d9      	asrs	r1, r3, #31
 8014c1a:	ebc1 0164 	rsb	r1, r1, r4, asr #1
 8014c1e:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 8014c22:	eba3 0381 	sub.w	r3, r3, r1, lsl #2
	buffer[idx++] = pitches[pclass*2];
 8014c26:	f812 1013 	ldrb.w	r1, [r2, r3, lsl #1]
	buffer[idx++] = pitches[pclass*2+1];
 8014c2a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	buffer[idx++] = pitches[pclass*2];
 8014c2e:	7029      	strb	r1, [r5, #0]
	buffer[idx++] = pitches[pclass*2+1];
 8014c30:	785b      	ldrb	r3, [r3, #1]
 8014c32:	706b      	strb	r3, [r5, #1]
}
 8014c34:	bc30      	pop	{r4, r5}
 8014c36:	4770      	bx	lr

08014c38 <OLEDparseFixedFloat>:

int OLEDparseFixedFloat(char* buffer, float input, uint8_t numDigits, uint8_t numDecimal)
{
	float power = powf(10.0f, numDecimal);
 8014c38:	ee07 2a90 	vmov	s15, r2
{
 8014c3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8014c40:	ed2d 8b02 	vpush	{d8}
 8014c44:	b085      	sub	sp, #20
 8014c46:	eeb0 8a40 	vmov.f32	s16, s0
	float power = powf(10.0f, numDecimal);
 8014c4a:	eef8 0a67 	vcvt.f32.u32	s1, s15
{
 8014c4e:	4680      	mov	r8, r0
	float power = powf(10.0f, numDecimal);
 8014c50:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
{
 8014c54:	9201      	str	r2, [sp, #4]
 8014c56:	9102      	str	r1, [sp, #8]
	float power = powf(10.0f, numDecimal);
 8014c58:	f016 fb1e 	bl	802b298 <powf>
	float f = ((float)(int)(input * power + 0.5f)) / power;
 8014c5c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8014c60:	eee0 7a08 	vfma.f32	s15, s0, s16
 8014c64:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8014c68:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8014c6c:	ee87 7a80 	vdiv.f32	s14, s15, s0

	int nonzeroHasHappened = 0, decimalHasHappened = 0;

	int myNumber = (int)(f * power);
 8014c70:	ee27 0a00 	vmul.f32	s0, s14, s0
 8014c74:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8014c78:	ee17 5a90 	vmov	r5, s15

	int idx = 0, i = 0;

	if (myNumber < 0)
 8014c7c:	2d00      	cmp	r5, #0
 8014c7e:	f2c0 8082 	blt.w	8014d86 <OLEDparseFixedFloat+0x14e>
	int idx = 0, i = 0;
 8014c82:	2600      	movs	r6, #0
		myNumber *= -1;
		buffer[idx++] = '-';
		i++;
	}

	while (i < numDigits)
 8014c84:	9b02      	ldr	r3, [sp, #8]
 8014c86:	429e      	cmp	r6, r3
 8014c88:	da3e      	bge.n	8014d08 <OLEDparseFixedFloat+0xd0>
 8014c8a:	2400      	movs	r4, #0
 8014c8c:	1b9f      	subs	r7, r3, r6
 8014c8e:	9603      	str	r6, [sp, #12]
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
		{
			if (nonzeroHasHappened == 0)
			{
				idx++; //get past the negative if there is one - this is hacky should figure out how to do it right
				buffer[idx-1] = '0';
 8014c90:	46a9      	mov	r9, r5
			decimalHasHappened = 1;
		}
		else
		{

			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014c92:	f107 3aff 	add.w	sl, r7, #4294967295	; 0xffffffff
	while (i < numDigits)
 8014c96:	9400      	str	r4, [sp, #0]
				buffer[idx-1] = '0';
 8014c98:	46a3      	mov	fp, r4
 8014c9a:	e00d      	b.n	8014cb8 <OLEDparseFixedFloat+0x80>
			int thisDigit = (myNumber / whichPlace);

			if (nonzeroHasHappened == 0)
			{
				if (thisDigit > 0)
 8014c9c:	2b00      	cmp	r3, #0
 8014c9e:	dd63      	ble.n	8014d68 <OLEDparseFixedFloat+0x130>
				{
					buffer[idx++] = thisDigit + 48;
 8014ca0:	f103 0e30 	add.w	lr, r3, #48	; 0x30
 8014ca4:	462e      	mov	r6, r5
					nonzeroHasHappened = 1;
 8014ca6:	f04f 0b01 	mov.w	fp, #1
					buffer[idx++] = thisDigit + 48;
 8014caa:	f88c e000 	strb.w	lr, [ip]
 8014cae:	3401      	adds	r4, #1
 8014cb0:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
 8014cb4:	42bc      	cmp	r4, r7
 8014cb6:	d027      	beq.n	8014d08 <OLEDparseFixedFloat+0xd0>
		if ((decimalHasHappened == 0) && ((numDigits-i) == numDecimal))
 8014cb8:	9b00      	ldr	r3, [sp, #0]
 8014cba:	1c75      	adds	r5, r6, #1
 8014cbc:	b91b      	cbnz	r3, 8014cc6 <OLEDparseFixedFloat+0x8e>
 8014cbe:	1b3b      	subs	r3, r7, r4
 8014cc0:	9a01      	ldr	r2, [sp, #4]
 8014cc2:	429a      	cmp	r2, r3
 8014cc4:	d026      	beq.n	8014d14 <OLEDparseFixedFloat+0xdc>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014cc6:	ebaa 0304 	sub.w	r3, sl, r4
 8014cca:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 8014cce:	ee07 3a90 	vmov	s15, r3
 8014cd2:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8014cd6:	f016 fadf 	bl	802b298 <powf>
 8014cda:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8014cde:	eb08 0c06 	add.w	ip, r8, r6
 8014ce2:	ee17 2a90 	vmov	r2, s15
			int thisDigit = (myNumber / whichPlace);
 8014ce6:	fb99 f3f2 	sdiv	r3, r9, r2
			if (nonzeroHasHappened == 0)
 8014cea:	f1bb 0f00 	cmp.w	fp, #0
 8014cee:	d0d5      	beq.n	8014c9c <OLEDparseFixedFloat+0x64>
					buffer[idx++] = ' ';
				}
			}
			else
			{
				buffer[idx++] = thisDigit + 48;
 8014cf0:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8014cf4:	462e      	mov	r6, r5
 8014cf6:	f04f 0b01 	mov.w	fp, #1
 8014cfa:	f88c 1000 	strb.w	r1, [ip]
 8014cfe:	3401      	adds	r4, #1
 8014d00:	fb02 9913 	mls	r9, r2, r3, r9
	while (i < numDigits)
 8014d04:	42bc      	cmp	r4, r7
 8014d06:	d1d7      	bne.n	8014cb8 <OLEDparseFixedFloat+0x80>
			i++;
		}
	}

	return idx;
}
 8014d08:	4630      	mov	r0, r6
 8014d0a:	b005      	add	sp, #20
 8014d0c:	ecbd 8b02 	vpop	{d8}
 8014d10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			if (nonzeroHasHappened == 0)
 8014d14:	f1bb 0f00 	cmp.w	fp, #0
 8014d18:	d02c      	beq.n	8014d74 <OLEDparseFixedFloat+0x13c>
 8014d1a:	4632      	mov	r2, r6
	while (i < numDigits)
 8014d1c:	9b03      	ldr	r3, [sp, #12]
			buffer[idx++] = '.';
 8014d1e:	f04f 012e 	mov.w	r1, #46	; 0x2e
	while (i < numDigits)
 8014d22:	4423      	add	r3, r4
			buffer[idx++] = '.';
 8014d24:	f808 1002 	strb.w	r1, [r8, r2]
	while (i < numDigits)
 8014d28:	9a02      	ldr	r2, [sp, #8]
 8014d2a:	4293      	cmp	r3, r2
 8014d2c:	da31      	bge.n	8014d92 <OLEDparseFixedFloat+0x15a>
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014d2e:	ebaa 0304 	sub.w	r3, sl, r4
			decimalHasHappened = 1;
 8014d32:	2201      	movs	r2, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014d34:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
				buffer[idx++] = thisDigit + 48;
 8014d38:	f04f 0b01 	mov.w	fp, #1
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014d3c:	ee07 3a90 	vmov	s15, r3
			decimalHasHappened = 1;
 8014d40:	9200      	str	r2, [sp, #0]
			int whichPlace = (uint32_t) powf(10.0f,(numDigits - 1 - i));
 8014d42:	eef8 0ae7 	vcvt.f32.s32	s1, s15
 8014d46:	f016 faa7 	bl	802b298 <powf>
 8014d4a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8014d4e:	eb08 0c05 	add.w	ip, r8, r5
 8014d52:	3501      	adds	r5, #1
 8014d54:	ee17 2a90 	vmov	r2, s15
				buffer[idx++] = thisDigit + 48;
 8014d58:	462e      	mov	r6, r5
			int thisDigit = (myNumber / whichPlace);
 8014d5a:	fb99 f3f2 	sdiv	r3, r9, r2
				buffer[idx++] = thisDigit + 48;
 8014d5e:	f103 0130 	add.w	r1, r3, #48	; 0x30
 8014d62:	f88c 1000 	strb.w	r1, [ip]
 8014d66:	e7ca      	b.n	8014cfe <OLEDparseFixedFloat+0xc6>
					buffer[idx++] = ' ';
 8014d68:	f04f 0120 	mov.w	r1, #32
 8014d6c:	462e      	mov	r6, r5
 8014d6e:	f88c 1000 	strb.w	r1, [ip]
 8014d72:	e79c      	b.n	8014cae <OLEDparseFixedFloat+0x76>
				buffer[idx-1] = '0';
 8014d74:	eb08 0305 	add.w	r3, r8, r5
 8014d78:	f04f 0130 	mov.w	r1, #48	; 0x30
 8014d7c:	462a      	mov	r2, r5
 8014d7e:	1cb5      	adds	r5, r6, #2
 8014d80:	f803 1c01 	strb.w	r1, [r3, #-1]
 8014d84:	e7ca      	b.n	8014d1c <OLEDparseFixedFloat+0xe4>
		buffer[idx++] = '-';
 8014d86:	232d      	movs	r3, #45	; 0x2d
		myNumber *= -1;
 8014d88:	426d      	negs	r5, r5
		buffer[idx++] = '-';
 8014d8a:	2601      	movs	r6, #1
 8014d8c:	f888 3000 	strb.w	r3, [r8]
 8014d90:	e778      	b.n	8014c84 <OLEDparseFixedFloat+0x4c>
			buffer[idx++] = '.';
 8014d92:	462e      	mov	r6, r5
}
 8014d94:	4630      	mov	r0, r6
 8014d96:	b005      	add	sp, #20
 8014d98:	ecbd 8b02 	vpop	{d8}
 8014d9c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08014da0 <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8014da0:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014da4:	f244 01d0 	movw	r1, #16592	; 0x40d0
{
 8014da8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8014dac:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
 8014db0:	b08f      	sub	sp, #60	; 0x3c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014db2:	2400      	movs	r4, #0
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014db4:	f44f 6900 	mov.w	r9, #2048	; 0x800

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
 8014db8:	f44f 5ba0 	mov.w	fp, #5120	; 0x1400
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
                          |GPIO_PIN_10, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
 8014dbc:	f44f 6880 	mov.w	r8, #1024	; 0x400
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014dc0:	940a      	str	r4, [sp, #40]	; 0x28
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014dc2:	f6c5 0902 	movt	r9, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014dc6:	9409      	str	r4, [sp, #36]	; 0x24
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8014dc8:	46a2      	mov	sl, r4
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014dca:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
 8014dcc:	f6c5 0b02 	movt	fp, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014dd0:	940c      	str	r4, [sp, #48]	; 0x30
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8014dd2:	f6c5 0a02 	movt	sl, #22530	; 0x5802
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8014dd6:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014dd8:	4648      	mov	r0, r9
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8014dda:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014dde:	4622      	mov	r2, r4

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
 8014de0:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
 8014de4:	f6c5 0802 	movt	r8, #22530	; 0x5802
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8014de8:	f045 0510 	orr.w	r5, r5, #16
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);

  /*Configure GPIO pins : PF7 PF8 PF9 PF10 */
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8014dec:	2703      	movs	r7, #3
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
 8014dee:	f6c5 0602 	movt	r6, #22530	; 0x5802
  __HAL_RCC_GPIOE_CLK_ENABLE();
 8014df2:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014df6:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014dfa:	f005 0510 	and.w	r5, r5, #16
 8014dfe:	9501      	str	r5, [sp, #4]
 8014e00:	9d01      	ldr	r5, [sp, #4]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8014e02:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e06:	f045 0504 	orr.w	r5, r5, #4
 8014e0a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e0e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e12:	f005 0504 	and.w	r5, r5, #4
 8014e16:	9502      	str	r5, [sp, #8]
 8014e18:	9d02      	ldr	r5, [sp, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8014e1a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e1e:	f045 0520 	orr.w	r5, r5, #32
 8014e22:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e26:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e2a:	f005 0520 	and.w	r5, r5, #32
 8014e2e:	9503      	str	r5, [sp, #12]
 8014e30:	9d03      	ldr	r5, [sp, #12]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8014e32:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e36:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 8014e3a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e3e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e42:	f005 0580 	and.w	r5, r5, #128	; 0x80
 8014e46:	9504      	str	r5, [sp, #16]
 8014e48:	9d04      	ldr	r5, [sp, #16]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8014e4a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e4e:	f045 0501 	orr.w	r5, r5, #1
 8014e52:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e56:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e5a:	f005 0501 	and.w	r5, r5, #1
 8014e5e:	9505      	str	r5, [sp, #20]
 8014e60:	9d05      	ldr	r5, [sp, #20]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8014e62:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e66:	f045 0502 	orr.w	r5, r5, #2
 8014e6a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e6e:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e72:	f005 0502 	and.w	r5, r5, #2
 8014e76:	9506      	str	r5, [sp, #24]
 8014e78:	9d06      	ldr	r5, [sp, #24]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 8014e7a:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e7e:	f045 0540 	orr.w	r5, r5, #64	; 0x40
 8014e82:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
 8014e86:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e8a:	f005 0540 	and.w	r5, r5, #64	; 0x40
 8014e8e:	9507      	str	r5, [sp, #28]
 8014e90:	9d07      	ldr	r5, [sp, #28]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8014e92:	f8d3 50e0 	ldr.w	r5, [r3, #224]	; 0xe0
 8014e96:	f045 0508 	orr.w	r5, r5, #8
 8014e9a:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8014e9e:	2501      	movs	r5, #1
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8014ea0:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8014ea4:	f003 0308 	and.w	r3, r3, #8
 8014ea8:	9308      	str	r3, [sp, #32]
 8014eaa:	9b08      	ldr	r3, [sp, #32]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
 8014eac:	f7f1 fbc4 	bl	8006638 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOF, GPIO_PIN_6, GPIO_PIN_RESET);
 8014eb0:	4658      	mov	r0, fp
 8014eb2:	4622      	mov	r2, r4
 8014eb4:	2140      	movs	r1, #64	; 0x40
 8014eb6:	f7f1 fbbf 	bl	8006638 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8014eba:	4650      	mov	r0, sl
 8014ebc:	4622      	mov	r2, r4
 8014ebe:	f44f 61ea 	mov.w	r1, #1872	; 0x750
 8014ec2:	f7f1 fbb9 	bl	8006638 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);
 8014ec6:	4640      	mov	r0, r8
 8014ec8:	4622      	mov	r2, r4
 8014eca:	2111      	movs	r1, #17
 8014ecc:	f7f1 fbb4 	bl	8006638 <HAL_GPIO_WritePin>
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10, GPIO_PIN_RESET);
 8014ed0:	4622      	mov	r2, r4
 8014ed2:	4630      	mov	r0, r6
 8014ed4:	f44f 6198 	mov.w	r1, #1216	; 0x4c0
 8014ed8:	f7f1 fbae 	bl	8006638 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8014edc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014ee0:	4648      	mov	r0, r9
 8014ee2:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_13;
 8014ee4:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014ee6:	e9cd 440a 	strd	r4, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014eea:	f7f0 fffb 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 8014eee:	f244 03d0 	movw	r3, #16592	; 0x40d0
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014ef2:	4648      	mov	r0, r9
 8014ef4:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_7;
 8014ef6:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8014ef8:	950a      	str	r5, [sp, #40]	; 0x28
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8014efa:	e9cd 440b 	strd	r4, r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014efe:	f7f0 fff1 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8014f02:	4623      	mov	r3, r4
  GPIO_InitStruct.Pin = GPIO_PIN_15;
 8014f04:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014f08:	4648      	mov	r0, r9
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8014f0a:	f2c1 1311 	movt	r3, #4369	; 0x1111
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014f0e:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_15;
 8014f10:	9209      	str	r2, [sp, #36]	; 0x24

  /*Configure GPIO pins : PD11 PD7 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014f12:	f44f 6940 	mov.w	r9, #3072	; 0xc00
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 8014f16:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f18:	940b      	str	r4, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8014f1a:	f7f0 ffe3 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8014f1e:	2340      	movs	r3, #64	; 0x40
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8014f20:	4658      	mov	r0, fp
 8014f22:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8014f24:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8014f26:	9309      	str	r3, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014f28:	f6c5 0902 	movt	r9, #22530	; 0x5802
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f2c:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8014f30:	f7f0 ffd8 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
 8014f34:	f44f 63f0 	mov.w	r3, #1920	; 0x780
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8014f38:	4658      	mov	r0, fp
 8014f3a:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10;
 8014f3c:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f3e:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8014f40:	970a      	str	r7, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 8014f42:	f7f0 ffcf 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
 8014f46:	f248 0302 	movw	r3, #32770	; 0x8002
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8014f4a:	4650      	mov	r0, sl
 8014f4c:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_15;
 8014f4e:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f50:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8014f54:	f7f0 ffc6 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8014f58:	f44f 63ea 	mov.w	r3, #1872	; 0x750
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8014f5c:	4650      	mov	r0, sl
 8014f5e:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6|GPIO_PIN_8|GPIO_PIN_9 
 8014f60:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8014f62:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f64:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8014f68:	f7f0 ffbc 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 8014f6c:	2311      	movs	r3, #17
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f6e:	4640      	mov	r0, r8
 8014f70:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4;
 8014f72:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8014f74:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f76:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f7a:	f7f0 ffb3 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
 8014f7e:	f24f 0302 	movw	r3, #61442	; 0xf002
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f82:	4640      	mov	r0, r8
 8014f84:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14 
 8014f86:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8014f88:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f8c:	f7f0 ffaa 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
 8014f90:	f44f 7301 	mov.w	r3, #516	; 0x204
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f94:	4640      	mov	r0, r8
 8014f96:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_9;
 8014f98:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014f9a:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8014f9e:	f7f0 ffa1 	bl	8005ee4 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
 8014fa2:	f44f 6308 	mov.w	r3, #2176	; 0x880
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014fa6:	4648      	mov	r0, r9
 8014fa8:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_7;
 8014faa:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8014fac:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014fb0:	f7f0 ff98 	bl	8005ee4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG3 PG9 PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
 8014fb4:	f246 2308 	movw	r3, #25096	; 0x6208
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014fb8:	4630      	mov	r0, r6
 8014fba:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_13|GPIO_PIN_14;
 8014fbc:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014fbe:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014fc2:	f7f0 ff8f 	bl	8005ee4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG6 PG7 PG10 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
 8014fc6:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014fca:	4630      	mov	r0, r6
 8014fcc:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_10;
 8014fce:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8014fd0:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014fd2:	e9cd 540a 	strd	r5, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014fd6:	f7f0 ff85 	bl	8005ee4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PD3 PD4 PD5 PD6 */
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 8014fda:	2378      	movs	r3, #120	; 0x78
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014fdc:	4648      	mov	r0, r9
 8014fde:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
 8014fe0:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8014fe2:	e9cd 740a 	strd	r7, r4, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8014fe6:	f7f0 ff7d 	bl	8005ee4 <HAL_GPIO_Init>

  /*Configure GPIO pins : PG11 PG12 */
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8014fea:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014fee:	4630      	mov	r0, r6
 8014ff0:	a909      	add	r1, sp, #36	; 0x24
  GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 8014ff2:	9309      	str	r3, [sp, #36]	; 0x24
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8014ff4:	e9cd 450a 	strd	r4, r5, [sp, #40]	; 0x28
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8014ff8:	f7f0 ff74 	bl	8005ee4 <HAL_GPIO_Init>

}
 8014ffc:	b00f      	add	sp, #60	; 0x3c
 8014ffe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8015002:	bf00      	nop

08015004 <MX_I2C2_Init>:
DMA_HandleTypeDef hdma_i2c4_rx;
DMA_HandleTypeDef hdma_i2c4_tx;

/* I2C2 init function */
void MX_I2C2_Init(void)
{
 8015004:	b538      	push	{r3, r4, r5, lr}

  hi2c2.Instance = I2C2;
 8015006:	f241 6394 	movw	r3, #5780	; 0x1694
 801500a:	f44f 44b0 	mov.w	r4, #22528	; 0x5800
  hi2c2.Init.Timing = 0x505097F4;
 801500e:	f249 71f4 	movw	r1, #38900	; 0x97f4
  hi2c2.Init.OwnAddress1 = 0;
 8015012:	2200      	movs	r2, #0
  hi2c2.Instance = I2C2;
 8015014:	f2c2 0300 	movt	r3, #8192	; 0x2000
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8015018:	2501      	movs	r5, #1
  hi2c2.Instance = I2C2;
 801501a:	f2c4 0400 	movt	r4, #16384	; 0x4000
  hi2c2.Init.Timing = 0x505097F4;
 801501e:	f2c5 0150 	movt	r1, #20560	; 0x5050
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c2.Init.OwnAddress2 = 0;
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8015022:	4618      	mov	r0, r3
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8015024:	621a      	str	r2, [r3, #32]
  hi2c2.Init.Timing = 0x505097F4;
 8015026:	e9c3 4100 	strd	r4, r1, [r3]
  hi2c2.Init.OwnAddress1 = 0;
 801502a:	e9c3 2502 	strd	r2, r5, [r3, #8]
  hi2c2.Init.OwnAddress2 = 0;
 801502e:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8015032:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8015036:	f7f2 f8d7 	bl	80071e8 <HAL_I2C_Init>
 801503a:	b9b8      	cbnz	r0, 801506c <MX_I2C2_Init+0x68>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 801503c:	f241 6094 	movw	r0, #5780	; 0x1694
 8015040:	2100      	movs	r1, #0
 8015042:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015046:	f7f3 fe8f 	bl	8008d68 <HAL_I2CEx_ConfigAnalogFilter>
 801504a:	b960      	cbnz	r0, 8015066 <MX_I2C2_Init+0x62>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 801504c:	f241 6094 	movw	r0, #5780	; 0x1694
 8015050:	2100      	movs	r1, #0
 8015052:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015056:	f7f3 fee7 	bl	8008e28 <HAL_I2CEx_ConfigDigitalFilter>
 801505a:	b900      	cbnz	r0, 801505e <MX_I2C2_Init+0x5a>
  {
    Error_Handler();
  }

}
 801505c:	bd38      	pop	{r3, r4, r5, pc}
 801505e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 8015062:	f000 bbff 	b.w	8015864 <Error_Handler>
    Error_Handler();
 8015066:	f000 fbfd 	bl	8015864 <Error_Handler>
 801506a:	e7ef      	b.n	801504c <MX_I2C2_Init+0x48>
    Error_Handler();
 801506c:	f000 fbfa 	bl	8015864 <Error_Handler>
 8015070:	e7e4      	b.n	801503c <MX_I2C2_Init+0x38>
 8015072:	bf00      	nop

08015074 <MX_I2C4_Init>:
/* I2C4 init function */
void MX_I2C4_Init(void)
{
 8015074:	b538      	push	{r3, r4, r5, lr}

  hi2c4.Instance = I2C4;
 8015076:	f241 6348 	movw	r3, #5704	; 0x1648
 801507a:	f44f 54e0 	mov.w	r4, #7168	; 0x1c00
  hi2c4.Init.Timing = 0x307075B1;
 801507e:	f247 51b1 	movw	r1, #30129	; 0x75b1
  hi2c4.Init.OwnAddress1 = 0;
 8015082:	2200      	movs	r2, #0
  hi2c4.Instance = I2C4;
 8015084:	f2c2 0300 	movt	r3, #8192	; 0x2000
  hi2c4.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8015088:	2501      	movs	r5, #1
  hi2c4.Instance = I2C4;
 801508a:	f6c5 0400 	movt	r4, #22528	; 0x5800
  hi2c4.Init.Timing = 0x307075B1;
 801508e:	f2c3 0170 	movt	r1, #12400	; 0x3070
  hi2c4.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c4.Init.OwnAddress2 = 0;
  hi2c4.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 8015092:	4618      	mov	r0, r3
  hi2c4.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8015094:	621a      	str	r2, [r3, #32]
  hi2c4.Init.Timing = 0x307075B1;
 8015096:	e9c3 4100 	strd	r4, r1, [r3]
  hi2c4.Init.OwnAddress1 = 0;
 801509a:	e9c3 2502 	strd	r2, r5, [r3, #8]
  hi2c4.Init.OwnAddress2 = 0;
 801509e:	e9c3 2204 	strd	r2, r2, [r3, #16]
  hi2c4.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 80150a2:	e9c3 2206 	strd	r2, r2, [r3, #24]
  if (HAL_I2C_Init(&hi2c4) != HAL_OK)
 80150a6:	f7f2 f89f 	bl	80071e8 <HAL_I2C_Init>
 80150aa:	b9b8      	cbnz	r0, 80150dc <MX_I2C4_Init+0x68>
  {
    Error_Handler();
  }
  /** Configure Analogue filter 
  */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c4, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 80150ac:	f241 6048 	movw	r0, #5704	; 0x1648
 80150b0:	2100      	movs	r1, #0
 80150b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80150b6:	f7f3 fe57 	bl	8008d68 <HAL_I2CEx_ConfigAnalogFilter>
 80150ba:	b960      	cbnz	r0, 80150d6 <MX_I2C4_Init+0x62>
  {
    Error_Handler();
  }
  /** Configure Digital filter 
  */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c4, 0) != HAL_OK)
 80150bc:	f241 6048 	movw	r0, #5704	; 0x1648
 80150c0:	2100      	movs	r1, #0
 80150c2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80150c6:	f7f3 feaf 	bl	8008e28 <HAL_I2CEx_ConfigDigitalFilter>
 80150ca:	b900      	cbnz	r0, 80150ce <MX_I2C4_Init+0x5a>
  {
    Error_Handler();
  }

}
 80150cc:	bd38      	pop	{r3, r4, r5, pc}
 80150ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    Error_Handler();
 80150d2:	f000 bbc7 	b.w	8015864 <Error_Handler>
    Error_Handler();
 80150d6:	f000 fbc5 	bl	8015864 <Error_Handler>
 80150da:	e7ef      	b.n	80150bc <MX_I2C4_Init+0x48>
    Error_Handler();
 80150dc:	f000 fbc2 	bl	8015864 <Error_Handler>
 80150e0:	e7e4      	b.n	80150ac <MX_I2C4_Init+0x38>
 80150e2:	bf00      	nop

080150e4 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(i2cHandle->Instance==I2C2)
 80150e4:	f44f 43b0 	mov.w	r3, #22528	; 0x5800
{
 80150e8:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(i2cHandle->Instance==I2C2)
 80150ea:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80150ee:	6802      	ldr	r2, [r0, #0]
{
 80150f0:	b08b      	sub	sp, #44	; 0x2c
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80150f2:	2400      	movs	r4, #0
  if(i2cHandle->Instance==I2C2)
 80150f4:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80150f6:	9409      	str	r4, [sp, #36]	; 0x24
 80150f8:	e9cd 4405 	strd	r4, r4, [sp, #20]
 80150fc:	e9cd 4407 	strd	r4, r4, [sp, #28]
  if(i2cHandle->Instance==I2C2)
 8015100:	d07f      	beq.n	8015202 <HAL_I2C_MspInit+0x11e>
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
 8015102:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 8015106:	f6c5 0300 	movt	r3, #22528	; 0x5800
 801510a:	429a      	cmp	r2, r3
 801510c:	d001      	beq.n	8015112 <HAL_I2C_MspInit+0x2e>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
  /* USER CODE BEGIN I2C4_MspInit 1 */

  /* USER CODE END I2C4_MspInit 1 */
  }
}
 801510e:	b00b      	add	sp, #44	; 0x2c
 8015110:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8015112:	f44f 4788 	mov.w	r7, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 8015116:	f44f 5640 	mov.w	r6, #12288	; 0x3000
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 801511a:	2212      	movs	r2, #18
 801511c:	4605      	mov	r5, r0
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801511e:	f6c5 0702 	movt	r7, #22530	; 0x5802
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8015122:	f44f 6040 	mov.w	r0, #3072	; 0xc00
 8015126:	a905      	add	r1, sp, #20
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8015128:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 801512c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8015130:	f043 0308 	orr.w	r3, r3, #8
 8015134:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
 8015138:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
 801513c:	9605      	str	r6, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 801513e:	2601      	movs	r6, #1
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8015140:	f003 0308 	and.w	r3, r3, #8
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8015144:	9206      	str	r2, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 8015146:	2204      	movs	r2, #4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
 8015148:	9608      	str	r6, [sp, #32]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 801514a:	9303      	str	r3, [sp, #12]
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 801514c:	f241 66e0 	movw	r6, #5856	; 0x16e0
    __HAL_RCC_GPIOD_CLK_ENABLE();
 8015150:	9b03      	ldr	r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 8015152:	9209      	str	r2, [sp, #36]	; 0x24
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8015154:	f7f0 fec6 	bl	8005ee4 <HAL_GPIO_Init>
    __HAL_RCC_I2C4_CLK_ENABLE();
 8015158:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 801515c:	f245 4208 	movw	r2, #21512	; 0x5408
 8015160:	f2c2 0600 	movt	r6, #8192	; 0x2000
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
 8015164:	f04f 0c0d 	mov.w	ip, #13
    __HAL_RCC_I2C4_CLK_ENABLE();
 8015168:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Instance = BDMA_Channel0;
 801516c:	f6c5 0202 	movt	r2, #22530	; 0x5802
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
 8015170:	f44f 6180 	mov.w	r1, #1024	; 0x400
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
 8015174:	4630      	mov	r0, r6
    __HAL_RCC_I2C4_CLK_ENABLE();
 8015176:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
 801517a:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
    hdma_i2c4_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
 801517e:	60b4      	str	r4, [r6, #8]
    __HAL_RCC_I2C4_CLK_ENABLE();
 8015180:	f003 0380 	and.w	r3, r3, #128	; 0x80
    hdma_i2c4_rx.Init.PeriphInc = DMA_PINC_DISABLE;
 8015184:	60f4      	str	r4, [r6, #12]
    hdma_i2c4_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
 8015186:	6174      	str	r4, [r6, #20]
    __HAL_RCC_I2C4_CLK_ENABLE();
 8015188:	9304      	str	r3, [sp, #16]
 801518a:	9b04      	ldr	r3, [sp, #16]
    hdma_i2c4_rx.Init.Priority = DMA_PRIORITY_LOW;
 801518c:	6234      	str	r4, [r6, #32]
    hdma_i2c4_rx.Init.MemInc = DMA_MINC_ENABLE;
 801518e:	6131      	str	r1, [r6, #16]
    hdma_i2c4_rx.Init.Mode = DMA_NORMAL;
 8015190:	e9c6 4406 	strd	r4, r4, [r6, #24]
    hdma_i2c4_rx.Init.Request = BDMA_REQUEST_I2C4_RX;
 8015194:	e9c6 2c00 	strd	r2, ip, [r6]
    if (HAL_DMA_Init(&hdma_i2c4_rx) != HAL_OK)
 8015198:	f7ed fc36 	bl	8002a08 <HAL_DMA_Init>
 801519c:	2800      	cmp	r0, #0
 801519e:	d15f      	bne.n	8015260 <HAL_I2C_MspInit+0x17c>
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 80151a0:	f241 54d0 	movw	r4, #5584	; 0x15d0
 80151a4:	f245 431c 	movw	r3, #21532	; 0x541c
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
 80151a8:	200e      	movs	r0, #14
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80151aa:	2140      	movs	r1, #64	; 0x40
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 80151ac:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80151b0:	f6c5 0302 	movt	r3, #22530	; 0x5802
    hdma_i2c4_tx.Init.MemInc = DMA_MINC_ENABLE;
 80151b4:	f44f 6280 	mov.w	r2, #1024	; 0x400
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
 80151b8:	63ee      	str	r6, [r5, #60]	; 0x3c
    hdma_i2c4_tx.Instance = BDMA_Channel1;
 80151ba:	6023      	str	r3, [r4, #0]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80151bc:	2300      	movs	r3, #0
    hdma_i2c4_tx.Init.Request = BDMA_REQUEST_I2C4_TX;
 80151be:	6060      	str	r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
 80151c0:	4620      	mov	r0, r4
    __HAL_LINKDMA(i2cHandle,hdmarx,hdma_i2c4_rx);
 80151c2:	63b5      	str	r5, [r6, #56]	; 0x38
    hdma_i2c4_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
 80151c4:	60a1      	str	r1, [r4, #8]
    hdma_i2c4_tx.Init.PeriphInc = DMA_PINC_DISABLE;
 80151c6:	e9c4 3203 	strd	r3, r2, [r4, #12]
    hdma_i2c4_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
 80151ca:	e9c4 3305 	strd	r3, r3, [r4, #20]
    hdma_i2c4_tx.Init.Priority = DMA_PRIORITY_LOW;
 80151ce:	e9c4 3307 	strd	r3, r3, [r4, #28]
    if (HAL_DMA_Init(&hdma_i2c4_tx) != HAL_OK)
 80151d2:	f7ed fc19 	bl	8002a08 <HAL_DMA_Init>
 80151d6:	2800      	cmp	r0, #0
 80151d8:	d13f      	bne.n	801525a <HAL_I2C_MspInit+0x176>
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
 80151da:	63ac      	str	r4, [r5, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
 80151dc:	2200      	movs	r2, #0
 80151de:	2107      	movs	r1, #7
 80151e0:	205f      	movs	r0, #95	; 0x5f
    __HAL_LINKDMA(i2cHandle,hdmatx,hdma_i2c4_tx);
 80151e2:	63a5      	str	r5, [r4, #56]	; 0x38
    HAL_NVIC_SetPriority(I2C4_EV_IRQn, 7, 0);
 80151e4:	f7ed f9ec 	bl	80025c0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_EV_IRQn);
 80151e8:	205f      	movs	r0, #95	; 0x5f
 80151ea:	f7ed fa39 	bl	8002660 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(I2C4_ER_IRQn, 7, 0);
 80151ee:	2200      	movs	r2, #0
 80151f0:	2107      	movs	r1, #7
 80151f2:	2060      	movs	r0, #96	; 0x60
 80151f4:	f7ed f9e4 	bl	80025c0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(I2C4_ER_IRQn);
 80151f8:	2060      	movs	r0, #96	; 0x60
 80151fa:	f7ed fa31 	bl	8002660 <HAL_NVIC_EnableIRQ>
}
 80151fe:	b00b      	add	sp, #44	; 0x2c
 8015200:	bdf0      	pop	{r4, r5, r6, r7, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8015202:	f44f 4488 	mov.w	r4, #17408	; 0x4400
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8015206:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 801520a:	2204      	movs	r2, #4
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 801520c:	f44f 6640 	mov.w	r6, #3072	; 0xc00
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8015210:	f6c5 0402 	movt	r4, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8015214:	2512      	movs	r5, #18
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8015216:	a905      	add	r1, sp, #20
 8015218:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801521c:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
 8015220:	f043 0302 	orr.w	r3, r3, #2
 8015224:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 8015228:	f8d4 30e0 	ldr.w	r3, [r4, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 801522c:	9605      	str	r6, [sp, #20]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801522e:	f003 0302 	and.w	r3, r3, #2
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8015232:	9506      	str	r5, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8015234:	9209      	str	r2, [sp, #36]	; 0x24
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8015236:	9301      	str	r3, [sp, #4]
 8015238:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801523a:	f7f0 fe53 	bl	8005ee4 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 801523e:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 8015242:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8015246:	f8c4 30e8 	str.w	r3, [r4, #232]	; 0xe8
 801524a:	f8d4 30e8 	ldr.w	r3, [r4, #232]	; 0xe8
 801524e:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8015252:	9302      	str	r3, [sp, #8]
 8015254:	9b02      	ldr	r3, [sp, #8]
}
 8015256:	b00b      	add	sp, #44	; 0x2c
 8015258:	bdf0      	pop	{r4, r5, r6, r7, pc}
      Error_Handler();
 801525a:	f000 fb03 	bl	8015864 <Error_Handler>
 801525e:	e7bc      	b.n	80151da <HAL_I2C_MspInit+0xf6>
      Error_Handler();
 8015260:	f000 fb00 	bl	8015864 <Error_Handler>
 8015264:	e79c      	b.n	80151a0 <HAL_I2C_MspInit+0xbc>
 8015266:	bf00      	nop

08015268 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C2)
 8015268:	f44f 43b0 	mov.w	r3, #22528	; 0x5800
 801526c:	6802      	ldr	r2, [r0, #0]
 801526e:	f2c4 0300 	movt	r3, #16384	; 0x4000
 8015272:	429a      	cmp	r2, r3
 8015274:	d028      	beq.n	80152c8 <HAL_I2C_MspDeInit+0x60>

  /* USER CODE BEGIN I2C2_MspDeInit 1 */

  /* USER CODE END I2C2_MspDeInit 1 */
  }
  else if(i2cHandle->Instance==I2C4)
 8015276:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 801527a:	f6c5 0300 	movt	r3, #22528	; 0x5800
 801527e:	429a      	cmp	r2, r3
 8015280:	d000      	beq.n	8015284 <HAL_I2C_MspDeInit+0x1c>
 8015282:	4770      	bx	lr
  {
  /* USER CODE BEGIN I2C4_MspDeInit 0 */

  /* USER CODE END I2C4_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C4_CLK_DISABLE();
 8015284:	f44f 4388 	mov.w	r3, #17408	; 0x4400
  
    /**I2C4 GPIO Configuration    
    PD12     ------> I2C4_SCL
    PD13     ------> I2C4_SDA 
    */
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 8015288:	f44f 5140 	mov.w	r1, #12288	; 0x3000
    __HAL_RCC_I2C4_CLK_DISABLE();
 801528c:	f6c5 0302 	movt	r3, #22530	; 0x5802
{
 8015290:	b510      	push	{r4, lr}
    __HAL_RCC_I2C4_CLK_DISABLE();
 8015292:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 8015296:	4604      	mov	r4, r0
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 8015298:	f44f 6040 	mov.w	r0, #3072	; 0xc00
    __HAL_RCC_I2C4_CLK_DISABLE();
 801529c:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 80152a0:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_I2C4_CLK_DISABLE();
 80152a4:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_12|GPIO_PIN_13);
 80152a8:	f7f1 f866 	bl	8006378 <HAL_GPIO_DeInit>

    /* I2C4 DMA DeInit */
    HAL_DMA_DeInit(i2cHandle->hdmarx);
 80152ac:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80152ae:	f7ee f899 	bl	80033e4 <HAL_DMA_DeInit>
    HAL_DMA_DeInit(i2cHandle->hdmatx);
 80152b2:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80152b4:	f7ee f896 	bl	80033e4 <HAL_DMA_DeInit>

    /* I2C4 interrupt Deinit */
    HAL_NVIC_DisableIRQ(I2C4_EV_IRQn);
 80152b8:	205f      	movs	r0, #95	; 0x5f
 80152ba:	f7ed f9e7 	bl	800268c <HAL_NVIC_DisableIRQ>
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
 80152be:	2060      	movs	r0, #96	; 0x60
  /* USER CODE BEGIN I2C4_MspDeInit 1 */

  /* USER CODE END I2C4_MspDeInit 1 */
  }
} 
 80152c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_NVIC_DisableIRQ(I2C4_ER_IRQn);
 80152c4:	f7ed b9e2 	b.w	800268c <HAL_NVIC_DisableIRQ>
    __HAL_RCC_I2C2_CLK_DISABLE();
 80152c8:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 80152cc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80152d0:	f44f 6140 	mov.w	r1, #3072	; 0xc00
    __HAL_RCC_I2C2_CLK_DISABLE();
 80152d4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 80152d8:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_I2C2_CLK_DISABLE();
 80152dc:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 80152e0:	f422 0280 	bic.w	r2, r2, #4194304	; 0x400000
 80152e4:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 80152e8:	f7f1 b846 	b.w	8006378 <HAL_GPIO_DeInit>

080152ec <SCB_EnableDCache>:
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80152ec:	f44f 406d 	mov.w	r0, #60672	; 0xed00
 80152f0:	2300      	movs	r3, #0
 80152f2:	f2ce 0000 	movt	r0, #57344	; 0xe000
{
 80152f6:	b4f0      	push	{r4, r5, r6, r7}
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 80152f8:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
 80152fc:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 8015300:	f8d0 5080 	ldr.w	r5, [r0, #128]	; 0x80
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8015304:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8015308:	f3c5 06c9 	ubfx	r6, r5, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 801530c:	f3c5 354e 	ubfx	r5, r5, #13, #15
 8015310:	07b7      	lsls	r7, r6, #30
 8015312:	016d      	lsls	r5, r5, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8015314:	ea05 040c 	and.w	r4, r5, ip
 8015318:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 801531a:	4632      	mov	r2, r6
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 801531c:	ea44 0301 	orr.w	r3, r4, r1
      } while (ways-- != 0U);
 8015320:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8015322:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
 8015326:	f8c0 3260 	str.w	r3, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 801532a:	1c53      	adds	r3, r2, #1
 801532c:	d1f6      	bne.n	801531c <SCB_EnableDCache+0x30>
 801532e:	3d20      	subs	r5, #32
    } while(sets-- != 0U);
 8015330:	f115 0f20 	cmn.w	r5, #32
 8015334:	d1ee      	bne.n	8015314 <SCB_EnableDCache+0x28>
 8015336:	f3bf 8f4f 	dsb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 801533a:	6943      	ldr	r3, [r0, #20]
 801533c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8015340:	6143      	str	r3, [r0, #20]
 8015342:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8015346:	f3bf 8f6f 	isb	sy
}
 801534a:	bcf0      	pop	{r4, r5, r6, r7}
 801534c:	4770      	bx	lr
 801534e:	bf00      	nop

08015350 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8015350:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8015354:	b0cc      	sub	sp, #304	; 0x130
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8015356:	224c      	movs	r2, #76	; 0x4c
 8015358:	2100      	movs	r1, #0
 801535a:	a80a      	add	r0, sp, #40	; 0x28
 801535c:	f015 fccd 	bl	802acfa <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8015360:	2220      	movs	r2, #32
 8015362:	2100      	movs	r1, #0
 8015364:	a802      	add	r0, sp, #8
 8015366:	f015 fcc8 	bl	802acfa <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 801536a:	22bc      	movs	r2, #188	; 0xbc
 801536c:	2100      	movs	r1, #0
 801536e:	a81d      	add	r0, sp, #116	; 0x74
 8015370:	f015 fcc3 	bl	802acfa <memset>

  /** Supply configuration update enable 
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
 8015374:	2002      	movs	r0, #2
 8015376:	f7f3 fdb5 	bl	8008ee4 <HAL_PWREx_ConfigSupply>
  /** Configure the main internal regulator output voltage 
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 801537a:	f44f 4390 	mov.w	r3, #18432	; 0x4800
 801537e:	2100      	movs	r1, #0
 8015380:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8015384:	f6c5 0302 	movt	r3, #22530	; 0x5802
 8015388:	9101      	str	r1, [sp, #4]
 801538a:	f6c5 0200 	movt	r2, #22528	; 0x5800
 801538e:	6999      	ldr	r1, [r3, #24]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 8015390:	4618      	mov	r0, r3
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
 8015392:	f441 4140 	orr.w	r1, r1, #49152	; 0xc000
 8015396:	6199      	str	r1, [r3, #24]
 8015398:	699b      	ldr	r3, [r3, #24]
 801539a:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 801539e:	9301      	str	r3, [sp, #4]
 80153a0:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80153a2:	f043 0301 	orr.w	r3, r3, #1
 80153a6:	62d3      	str	r3, [r2, #44]	; 0x2c
 80153a8:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80153aa:	f003 0301 	and.w	r3, r3, #1
 80153ae:	9301      	str	r3, [sp, #4]
 80153b0:	9b01      	ldr	r3, [sp, #4]
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 80153b2:	6983      	ldr	r3, [r0, #24]
 80153b4:	049b      	lsls	r3, r3, #18
 80153b6:	d5fc      	bpl.n	80153b2 <SystemClock_Config+0x62>
  /** Macro to configure the PLL clock source 
  */
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 80153b8:	f44f 4288 	mov.w	r2, #17408	; 0x4400
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80153bc:	2402      	movs	r4, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80153be:	f44f 3080 	mov.w	r0, #65536	; 0x10000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 80153c2:	f04f 0c21 	mov.w	ip, #33	; 0x21
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 80153c6:	f6c5 0202 	movt	r2, #22530	; 0x5802
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 80153ca:	2501      	movs	r5, #1
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 10;
 80153cc:	210a      	movs	r1, #10
  RCC_OscInitStruct.PLL.PLLN = 384;
 80153ce:	f44f 76c0 	mov.w	r6, #384	; 0x180
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 80153d2:	6a93      	ldr	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 3;
 80153d4:	2703      	movs	r7, #3
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_1;
 80153d6:	f04f 0804 	mov.w	r8, #4
  __HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
 80153da:	f023 0303 	bic.w	r3, r3, #3
 80153de:	4323      	orrs	r3, r4
 80153e0:	6293      	str	r3, [r2, #40]	; 0x28
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 80153e2:	2300      	movs	r3, #0
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80153e4:	900b      	str	r0, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 80153e6:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_HSE;
 80153e8:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 80153ec:	9510      	str	r5, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLP = 2;
 80153ee:	9417      	str	r4, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLR = 2;
 80153f0:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.PLL.PLLQ = 3;
 80153f2:	9718      	str	r7, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 80153f4:	931c      	str	r3, [sp, #112]	; 0x70
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80153f6:	e9cd 4413 	strd	r4, r4, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLN = 384;
 80153fa:	e9cd 1615 	strd	r1, r6, [sp, #84]	; 0x54
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 80153fe:	e9cd 831a 	strd	r8, r3, [sp, #104]	; 0x68
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8015402:	f7f3 fdb5 	bl	8008f70 <HAL_RCC_OscConfig>
 8015406:	b100      	cbz	r0, 801540a <SystemClock_Config+0xba>
 8015408:	e7fe      	b.n	8015408 <SystemClock_Config+0xb8>
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB busses clocks 
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 801540a:	223f      	movs	r2, #63	; 0x3f
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 801540c:	9703      	str	r7, [sp, #12]
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 801540e:	2708      	movs	r7, #8
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 8015410:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8015412:	9202      	str	r2, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 8015414:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
 8015418:	9004      	str	r0, [sp, #16]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 801541a:	4641      	mov	r1, r8
 801541c:	eb0d 0007 	add.w	r0, sp, r7
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8015420:	9705      	str	r7, [sp, #20]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 8015422:	e9cd 3306 	strd	r3, r3, [sp, #24]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 8015426:	e9cd 2308 	strd	r2, r3, [sp, #32]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 801542a:	f7f4 fa5b 	bl	80098e4 <HAL_RCC_ClockConfig>
 801542e:	4603      	mov	r3, r0
 8015430:	b100      	cbz	r0, 8015434 <SystemClock_Config+0xe4>
 8015432:	e7fe      	b.n	8015432 <SystemClock_Config+0xe2>
  {
    Error_Handler();
  }
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
 8015434:	f44f 718c 	mov.w	r1, #280	; 0x118
                              |RCC_PERIPHCLK_SDMMC|RCC_PERIPHCLK_I2C2
                              |RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_I2C4
                              |RCC_PERIPHCLK_USB|RCC_PERIPHCLK_FMC;
  PeriphClkInitStruct.PLL2.PLL2M = 25;
 8015438:	2219      	movs	r2, #25
  PeriphClkInitStruct.PLL2.PLL2N = 344;
 801543a:	f44f 7eac 	mov.w	lr, #344	; 0x158
  PeriphClkInitStruct.PLL2.PLL2R = 1;
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_0;
  PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOWIDE;
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
  PeriphClkInitStruct.PLL3.PLL3M = 25;
  PeriphClkInitStruct.PLL3.PLL3N = 384;
 801543e:	9627      	str	r6, [sp, #156]	; 0x9c
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_SAI1
 8015440:	f2c0 110f 	movt	r1, #271	; 0x10f
  PeriphClkInitStruct.PLL2.PLL2P = 7;
 8015444:	f04f 0c07 	mov.w	ip, #7
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
  PeriphClkInitStruct.RngClockSelection = RCC_RNGCLKSOURCE_HSI48;
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 8015448:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801544c:	a81d      	add	r0, sp, #116	; 0x74
  PeriphClkInitStruct.PLL2.PLL2Q = 2;
 801544e:	9421      	str	r4, [sp, #132]	; 0x84
  PeriphClkInitStruct.FmcClockSelection = RCC_FMCCLKSOURCE_D1HCLK;
 8015450:	932e      	str	r3, [sp, #184]	; 0xb8
  PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
 8015452:	9330      	str	r3, [sp, #192]	; 0xc0
  PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL2;
 8015454:	9532      	str	r5, [sp, #200]	; 0xc8
  PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_D3PCLK1;
 8015456:	9342      	str	r3, [sp, #264]	; 0x108
  PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
 8015458:	9345      	str	r3, [sp, #276]	; 0x114
  PeriphClkInitStruct.PLL3.PLL3M = 25;
 801545a:	9226      	str	r2, [sp, #152]	; 0x98
  PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL3;
 801545c:	963e      	str	r6, [sp, #248]	; 0xf8
  PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_0;
 801545e:	e9cd 5322 	strd	r5, r3, [sp, #136]	; 0x88
  PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
 8015462:	e9cd 3324 	strd	r3, r3, [sp, #144]	; 0x90
  PeriphClkInitStruct.PLL3.PLL3Q = 8;
 8015466:	e9cd 4728 	strd	r4, r7, [sp, #160]	; 0xa0
  PeriphClkInitStruct.PLL3.PLL3RGE = RCC_PLL3VCIRANGE_0;
 801546a:	e9cd 432a 	strd	r4, r3, [sp, #168]	; 0xa8
  PeriphClkInitStruct.PLL3.PLL3FRACN = 0;
 801546e:	e9cd 332c 	strd	r3, r3, [sp, #176]	; 0xb0
  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;
 8015472:	e9cd 333c 	strd	r3, r3, [sp, #240]	; 0xf0
  PeriphClkInitStruct.PLL2.PLL2M = 25;
 8015476:	e9cd 121d 	strd	r1, r2, [sp, #116]	; 0x74
  PeriphClkInitStruct.PLL2.PLL2P = 7;
 801547a:	e9cd ec1f 	strd	lr, ip, [sp, #124]	; 0x7c
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 801547e:	f7f4 ff8b 	bl	800a398 <HAL_RCCEx_PeriphCLKConfig>
 8015482:	b100      	cbz	r0, 8015486 <SystemClock_Config+0x136>
 8015484:	e7fe      	b.n	8015484 <SystemClock_Config+0x134>
  {
    Error_Handler();
  }
  /** Enable USB Voltage detector 
  */
  HAL_PWREx_EnableUSBVoltageDetector();
 8015486:	f7f3 fd5f 	bl	8008f48 <HAL_PWREx_EnableUSBVoltageDetector>
}
 801548a:	b04c      	add	sp, #304	; 0x130
 801548c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08015490 <HAL_ADC_ConvCpltCallback>:

/* USER CODE BEGIN 4 */
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
	//HAL_MDMA_Start_IT(&hmdma_mdma_channel40_dma1_stream0_tc_0, (uint32_t)&ADC_valuesDMA, (uint32_t)&ADC_values, 10, 1);
}
 8015490:	4770      	bx	lr
 8015492:	bf00      	nop

08015494 <HAL_ADC_ConvHalfCpltCallback>:
 8015494:	4770      	bx	lr
 8015496:	bf00      	nop

08015498 <SDRAM_Initialization_sequence>:
#define SDRAM_MODEREG_WRITEBURST_MODE_SINGLE     ((uint16_t)0x0200)

//#define SDRAM_REFRESH_COUNT                   	 ((uint32_t)956)// 7.9us in cycles of 8.333333ns + 20 cycles as recommended by datasheet page 866/3289 for STM32H743
#define SDRAM_REFRESH_COUNT                   	 ((uint32_t)0x0569)// 7.9us in cycles of 8.333333ns + 20 cycles as recommended by datasheet page 866/3289 for STM32H743
void SDRAM_Initialization_sequence(void)
{
 8015498:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 1;
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801549c:	f241 549c 	movw	r4, #5532	; 0x159c
{
 80154a0:	b087      	sub	sp, #28
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 80154a2:	2501      	movs	r5, #1
    __IO uint32_t tmpmrd = 0;
 80154a4:	2600      	movs	r6, #0
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154a6:	f2c2 0400 	movt	r4, #8192	; 0x2000
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 80154aa:	2710      	movs	r7, #16
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154ac:	a902      	add	r1, sp, #8
 80154ae:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80154b2:	4620      	mov	r0, r4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);

    /* Step 4: Configure the 1st Auto Refresh command */
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 8;
 80154b4:	f04f 0808 	mov.w	r8, #8
    __IO uint32_t tmpmrd = 0;
 80154b8:	9601      	str	r6, [sp, #4]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 80154ba:	f04f 0903 	mov.w	r9, #3
    Command.ModeRegisterDefinition = 0;
 80154be:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_CLK_ENABLE;
 80154c0:	9502      	str	r5, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 80154c2:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154c6:	f7f8 f9dd 	bl	800d884 <HAL_SDRAM_SendCommand>
    HAL_Delay(1);
 80154ca:	4628      	mov	r0, r5
 80154cc:	f7eb fabc 	bl	8000a48 <HAL_Delay>
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
 80154d0:	2302      	movs	r3, #2
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154d2:	eb0d 0108 	add.w	r1, sp, r8
 80154d6:	4620      	mov	r0, r4
 80154d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_PALL;
 80154dc:	9302      	str	r3, [sp, #8]
    Command.ModeRegisterDefinition = 0;
 80154de:	9605      	str	r6, [sp, #20]
    Command.AutoRefreshNumber = 1;
 80154e0:	e9cd 7503 	strd	r7, r5, [sp, #12]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154e4:	f7f8 f9ce 	bl	800d884 <HAL_SDRAM_SendCommand>
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
 80154e8:	f240 2222 	movw	r2, #546	; 0x222
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 80154ec:	2304      	movs	r3, #4
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154ee:	eb0d 0108 	add.w	r1, sp, r8
    tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_4 | SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL
 80154f2:	9201      	str	r2, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154f4:	4620      	mov	r0, r4
    Command.ModeRegisterDefinition = tmpmrd;
 80154f6:	f8dd c004 	ldr.w	ip, [sp, #4]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 80154fa:	f64f 72ff 	movw	r2, #65535	; 0xffff
    Command.CommandMode = FMC_SDRAM_CMD_LOAD_MODE;
 80154fe:	9302      	str	r3, [sp, #8]
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 8015500:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = tmpmrd;
 8015502:	e9cd 5c04 	strd	r5, ip, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8015506:	f7f8 f9bd 	bl	800d884 <HAL_SDRAM_SendCommand>
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801550a:	eb0d 0108 	add.w	r1, sp, r8
 801550e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8015512:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 8015514:	9703      	str	r7, [sp, #12]
    Command.ModeRegisterDefinition = 0;
 8015516:	9605      	str	r6, [sp, #20]
    Command.CommandMode = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8015518:	f8cd 9008 	str.w	r9, [sp, #8]
    Command.AutoRefreshNumber = 8;
 801551c:	f8cd 8010 	str.w	r8, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 8015520:	f7f8 f9b0 	bl	800d884 <HAL_SDRAM_SendCommand>

    /* Step 2: Insert 100 us minimum delay */
    /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
    HAL_Delay(1);
 8015524:	4628      	mov	r0, r5
 8015526:	f7eb fa8f 	bl	8000a48 <HAL_Delay>
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
    Command.AutoRefreshNumber = 8;
    Command.ModeRegisterDefinition = 0;

    /* Send the command */
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801552a:	eb0d 0108 	add.w	r1, sp, r8
 801552e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8015532:	4620      	mov	r0, r4
    Command.CommandTarget = FMC_SDRAM_CMD_TARGET_BANK1;
 8015534:	e9cd 9702 	strd	r9, r7, [sp, #8]
    Command.ModeRegisterDefinition = 0;
 8015538:	e9cd 8604 	strd	r8, r6, [sp, #16]
    HAL_SDRAM_SendCommand(&hsdram1, &Command, SDRAM_TIMEOUT);
 801553c:	f7f8 f9a2 	bl	800d884 <HAL_SDRAM_SendCommand>

    /* Step 6: Set the refresh rate counter */
    /* Set the device refresh rate */
    HAL_SDRAM_ProgramRefreshRate(&hsdram1, SDRAM_REFRESH_COUNT);
 8015540:	f240 5169 	movw	r1, #1385	; 0x569
 8015544:	4620      	mov	r0, r4
 8015546:	f7f8 f9bf 	bl	800d8c8 <HAL_SDRAM_ProgramRefreshRate>
}
 801554a:	b007      	add	sp, #28
 801554c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08015550 <randomNumber>:

float randomNumber(void) {
 8015550:	b500      	push	{lr}

	uint32_t rand;
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
 8015552:	f641 4094 	movw	r0, #7316	; 0x1c94
float randomNumber(void) {
 8015556:	b083      	sub	sp, #12
	HAL_RNG_GenerateRandomNumber(&hrng, &rand);
 8015558:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801555c:	a901      	add	r1, sp, #4
 801555e:	f7f6 f9a7 	bl	800b8b0 <HAL_RNG_GenerateRandomNumber>
	float num = (float)rand * INV_TWO_TO_32;
 8015562:	230d      	movs	r3, #13
 8015564:	eddd 7a01 	vldr	s15, [sp, #4]
 8015568:	f6c2 7380 	movt	r3, #12160	; 0x2f80
 801556c:	eeb8 0a67 	vcvt.f32.u32	s0, s15
 8015570:	ee07 3a90 	vmov	s15, r3
	return num;
}
 8015574:	ee20 0a27 	vmul.f32	s0, s0, s15
 8015578:	b003      	add	sp, #12
 801557a:	f85d fb04 	ldr.w	pc, [sp], #4
 801557e:	bf00      	nop

08015580 <MPU_Conf>:


void MPU_Conf(void)
{
 8015580:	b510      	push	{r4, lr}
 8015582:	b084      	sub	sp, #16
  // So a buffer size for read/write of 4096 would take up 64k = 4096*8 * 2 (read and write).
  // I increased that to 256k so that there would be room for the ADC knob inputs and other peripherals that might require DMA access.
  // we have a total of 256k in SRAM1 (128k, 0x30000000-0x30020000) and SRAM2 (128k, 0x30020000-0x3004000) of D2 domain.
  // There is an SRAM3 in D2 domain as well (32k, 0x30040000-0x3004800) that is currently not mapped by the MPU (memory protection unit) controller.

  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8015584:	2400      	movs	r4, #0
	HAL_MPU_Disable();
 8015586:	f7ed f8b7 	bl	80026f8 <HAL_MPU_Disable>
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 801558a:	2311      	movs	r3, #17
  MPU_InitStruct.BaseAddress = 0x30000000;
 801558c:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8015590:	f240 1201 	movw	r2, #257	; 0x101
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 8015594:	f2c0 3301 	movt	r3, #769	; 0x301


  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;


  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8015598:	4668      	mov	r0, sp
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 801559a:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
 801559e:	9403      	str	r4, [sp, #12]
  MPU_InitStruct.BaseAddress = 0x30000000;
 80155a0:	e9cd 1301 	strd	r1, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80155a4:	f7ed f8ce 	bl	8002744 <HAL_MPU_ConfigRegion>

  //D3 DomainSRAM1
  MPU_InitStruct.BaseAddress = 0x38000000;


  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 80155a8:	230f      	movs	r3, #15
  MPU_InitStruct.BaseAddress = 0x38000000;
 80155aa:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80155ae:	f240 2201 	movw	r2, #513	; 0x201
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 80155b2:	f2c0 3301 	movt	r3, #769	; 0x301


  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;


  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80155b6:	4668      	mov	r0, sp
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 80155b8:	f8ad 2000 	strh.w	r2, [sp]
  MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
 80155bc:	9403      	str	r4, [sp, #12]
 80155be:	e9cd 1301 	strd	r1, r3, [sp, #4]
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 80155c2:	f7ed f8bf 	bl	8002744 <HAL_MPU_ConfigRegion>
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  */



  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 80155c6:	2004      	movs	r0, #4
 80155c8:	f7ed f8a8 	bl	800271c <HAL_MPU_Enable>
}
 80155cc:	b004      	add	sp, #16
 80155ce:	bd10      	pop	{r4, pc}

080155d0 <main>:
{
 80155d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  MPU_Conf();
 80155d2:	f7ff ffd5 	bl	8015580 <MPU_Conf>
  __ASM volatile ("dsb 0xF":::"memory");
 80155d6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80155da:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80155de:	f44f 446d 	mov.w	r4, #60672	; 0xed00
 80155e2:	2500      	movs	r5, #0
 80155e4:	f2ce 0400 	movt	r4, #57344	; 0xe000
 80155e8:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80155ec:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80155f0:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80155f4:	6963      	ldr	r3, [r4, #20]
 80155f6:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80155fa:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80155fc:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8015600:	f3bf 8f6f 	isb	sy
  SCB_EnableDCache();
 8015604:	f7ff fe72 	bl	80152ec <SCB_EnableDCache>
  HAL_Init();
 8015608:	f7eb f9d4 	bl	80009b4 <HAL_Init>
  __ASM volatile ("dsb 0xF":::"memory");
 801560c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8015610:	f3bf 8f6f 	isb	sy
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
 8015614:	6963      	ldr	r3, [r4, #20]
 8015616:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 801561a:	6163      	str	r3, [r4, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 801561c:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8015620:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8015624:	f3bf 8f6f 	isb	sy
    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8015628:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 801562c:	f3bf 8f4f 	dsb	sy
    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
 8015630:	6963      	ldr	r3, [r4, #20]
 8015632:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8015636:	6163      	str	r3, [r4, #20]
 8015638:	f3bf 8f4f 	dsb	sy
    ccsidr = SCB->CCSIDR;
 801563c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8015640:	f643 7ce0 	movw	ip, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8015644:	f3c3 06c9 	ubfx	r6, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8015648:	f3c3 334e 	ubfx	r3, r3, #13, #15
 801564c:	07b7      	lsls	r7, r6, #30
 801564e:	0158      	lsls	r0, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8015650:	ea00 050c 	and.w	r5, r0, ip
 8015654:	4639      	mov	r1, r7
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8015656:	4632      	mov	r2, r6
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8015658:	ea41 0305 	orr.w	r3, r1, r5
      } while (ways-- != 0U);
 801565c:	3a01      	subs	r2, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 801565e:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
 8015662:	f8c4 3274 	str.w	r3, [r4, #628]	; 0x274
      } while (ways-- != 0U);
 8015666:	1c53      	adds	r3, r2, #1
 8015668:	d1f6      	bne.n	8015658 <main+0x88>
 801566a:	3820      	subs	r0, #32
    } while(sets-- != 0U);
 801566c:	f110 0f20 	cmn.w	r0, #32
 8015670:	d1ee      	bne.n	8015650 <main+0x80>
 8015672:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8015676:	f3bf 8f6f 	isb	sy
  SystemClock_Config();
 801567a:	f7ff fe69 	bl	8015350 <SystemClock_Config>
  MX_GPIO_Init();
 801567e:	f7ff fb8f 	bl	8014da0 <MX_GPIO_Init>
  MX_BDMA_Init();
 8015682:	f7fd feb3 	bl	80133ec <MX_BDMA_Init>
  MX_DMA_Init();
 8015686:	f7fd ffcb 	bl	8013620 <MX_DMA_Init>
  MX_FMC_Init();
 801568a:	f7fe fbe5 	bl	8013e58 <MX_FMC_Init>
  MX_ADC1_Init();
 801568e:	f7fd f82f 	bl	80126f0 <MX_ADC1_Init>
  MX_I2C2_Init();
 8015692:	f7ff fcb7 	bl	8015004 <MX_I2C2_Init>
  MX_SDMMC1_SD_Init();
 8015696:	f001 f8b1 	bl	80167fc <MX_SDMMC1_SD_Init>
  MX_FATFS_Init();
 801569a:	f7fe fbbd 	bl	8013e18 <MX_FATFS_Init>
  MX_SAI1_Init();
 801569e:	f000 ff03 	bl	80164a8 <MX_SAI1_Init>
  MX_RNG_Init();
 80156a2:	f000 fecf 	bl	8016444 <MX_RNG_Init>
  MX_I2C4_Init();
 80156a6:	f7ff fce5 	bl	8015074 <MX_I2C4_Init>
  MX_USB_HOST_Init();
 80156aa:	f00b ff3b 	bl	8021524 <MX_USB_HOST_Init>
  MX_TIM3_Init();
 80156ae:	f009 feff 	bl	801f4b0 <MX_TIM3_Init>
  MX_TIM4_Init();
 80156b2:	f009 ff8d 	bl	801f5d0 <MX_TIM4_Init>
  __ASM volatile ("dsb 0xF":::"memory");
 80156b6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80156ba:	f3bf 8f6f 	isb	sy
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80156be:	2500      	movs	r5, #0
 80156c0:	f8c4 5250 	str.w	r5, [r4, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80156c4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80156c8:	f3bf 8f6f 	isb	sy
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 80156cc:	6963      	ldr	r3, [r4, #20]
 80156ce:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80156d2:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 80156d4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80156d8:	f3bf 8f6f 	isb	sy
  SCB_EnableDCache();
 80156dc:	f7ff fe06 	bl	80152ec <SCB_EnableDCache>
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
 80156e0:	f248 6080 	movw	r0, #34432	; 0x8680
 80156e4:	2104      	movs	r1, #4
 80156e6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80156ea:	f7f8 fcc1 	bl	800e070 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);
 80156ee:	f248 6040 	movw	r0, #34368	; 0x8640
 80156f2:	4629      	mov	r1, r5
 80156f4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80156f8:	f7f8 fcba 	bl	800e070 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);
 80156fc:	f248 6040 	movw	r0, #34368	; 0x8640
 8015700:	2104      	movs	r1, #4
 8015702:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8015706:	f7f8 fcb3 	bl	800e070 <HAL_TIM_PWM_Start>
  HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);
 801570a:	f248 6040 	movw	r0, #34368	; 0x8640
 801570e:	2108      	movs	r1, #8
 8015710:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8015714:	f7f8 fcac 	bl	800e070 <HAL_TIM_PWM_Start>
  HAL_FLASH_Unlock();
 8015718:	f7f0 f998 	bl	8005a4c <HAL_FLASH_Unlock>
  if( EE_Init() != EE_OK)
 801571c:	f7fe f816 	bl	801374c <EE_Init>
 8015720:	4605      	mov	r5, r0
 8015722:	b100      	cbz	r0, 8015726 <main+0x156>
 8015724:	e7fe      	b.n	8015724 <main+0x154>
  if((EE_ReadVariable(VirtAddVarTab[0],  &VarDataTab)) != HAL_OK) // read what the preset was before last power-off
 8015726:	f240 0418 	movw	r4, #24
 801572a:	f240 5108 	movw	r1, #1288	; 0x508
 801572e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8015732:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8015736:	8820      	ldrh	r0, [r4, #0]
 8015738:	f7fe fa0e 	bl	8013b58 <EE_ReadVariable>
 801573c:	2800      	cmp	r0, #0
 801573e:	d163      	bne.n	8015808 <main+0x238>
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 8015740:	f240 5308 	movw	r3, #1288	; 0x508
 8015744:	f240 6155 	movw	r1, #1621	; 0x655

// helper function to initialize measuring unit (cycle counter) */
static void CycleCounterInit( void )
{
  /* Enable TRC */
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8015748:	f64e 52f0 	movw	r2, #60912	; 0xedf0

  /* Unlock DWT registers */
  if ((*(uint32_t*)0xE0001FB4) & 1)
 801574c:	f641 70b4 	movw	r0, #8116	; 0x1fb4
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 8015750:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8015754:	f2c2 0100 	movt	r1, #8192	; 0x2000
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8015758:	f2ce 0200 	movt	r2, #57344	; 0xe000
  if ((*(uint32_t*)0xE0001FB4) & 1)
 801575c:	f2ce 0000 	movt	r0, #57344	; 0xe000
  if (VarDataTab < PresetNil) //make sure the stored data is a number not past the number of available presets
 8015760:	881b      	ldrh	r3, [r3, #0]
 8015762:	2b12      	cmp	r3, #18
 8015764:	bf28      	it	cs
 8015766:	2300      	movcs	r3, #0
 8015768:	700b      	strb	r3, [r1, #0]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 801576a:	68d3      	ldr	r3, [r2, #12]
 801576c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8015770:	60d3      	str	r3, [r2, #12]
  if ((*(uint32_t*)0xE0001FB4) & 1)
 8015772:	6803      	ldr	r3, [r0, #0]
 8015774:	07db      	lsls	r3, r3, #31
 8015776:	d508      	bpl.n	801578a <main+0x1ba>
    *(uint32_t*)0xE0001FB0 = 0xC5ACCE55;
 8015778:	f641 73b0 	movw	r3, #8112	; 0x1fb0
 801577c:	f64c 6255 	movw	r2, #52821	; 0xce55
 8015780:	f2ce 0300 	movt	r3, #57344	; 0xe000
 8015784:	f2cc 52ac 	movt	r2, #50604	; 0xc5ac
 8015788:	601a      	str	r2, [r3, #0]

  /* clear the cycle counter */
  DWT->CYCCNT = 0;
 801578a:	f44f 5280 	mov.w	r2, #4096	; 0x1000

  /* start the cycle counter */
  DWT->CTRL = 0x40000001;
 801578e:	2101      	movs	r1, #1

  for (int i = 0; i < 4; i++)
  {
	  cycleCountAverages[i][0] = 0.0f;
 8015790:	f641 3360 	movw	r3, #7008	; 0x1b60
 8015794:	2400      	movs	r4, #0
  DWT->CYCCNT = 0;
 8015796:	f2ce 0200 	movt	r2, #57344	; 0xe000
  DWT->CTRL = 0x40000001;
 801579a:	f2c4 0100 	movt	r1, #16384	; 0x4000
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 801579e:	f44f 6000 	mov.w	r0, #2048	; 0x800
	  cycleCountAverages[i][0] = 0.0f;
 80157a2:	f2c2 0300 	movt	r3, #8192	; 0x2000
  DWT->CYCCNT = 0;
 80157a6:	6054      	str	r4, [r2, #4]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80157a8:	f6c5 0002 	movt	r0, #22530	; 0x5802
  DWT->CTRL = 0x40000001;
 80157ac:	6011      	str	r1, [r2, #0]
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80157ae:	4622      	mov	r2, r4
 80157b0:	f44f 4180 	mov.w	r1, #16384	; 0x4000
	  cycleCountAverages[i][0] = 0.0f;
 80157b4:	601c      	str	r4, [r3, #0]
	  cycleCountAverages[i][1] = 0.0f;
 80157b6:	605c      	str	r4, [r3, #4]
	  cycleCountAverages[i][2] = 0.0f;
 80157b8:	609c      	str	r4, [r3, #8]
	  cycleCountAverages[i][0] = 0.0f;
 80157ba:	60dc      	str	r4, [r3, #12]
	  cycleCountAverages[i][1] = 0.0f;
 80157bc:	611c      	str	r4, [r3, #16]
	  cycleCountAverages[i][2] = 0.0f;
 80157be:	615c      	str	r4, [r3, #20]
	  cycleCountAverages[i][0] = 0.0f;
 80157c0:	619c      	str	r4, [r3, #24]
	  cycleCountAverages[i][1] = 0.0f;
 80157c2:	61dc      	str	r4, [r3, #28]
	  cycleCountAverages[i][2] = 0.0f;
 80157c4:	621c      	str	r4, [r3, #32]
	  cycleCountAverages[i][0] = 0.0f;
 80157c6:	625c      	str	r4, [r3, #36]	; 0x24
	  cycleCountAverages[i][1] = 0.0f;
 80157c8:	629c      	str	r4, [r3, #40]	; 0x28
	  cycleCountAverages[i][2] = 0.0f;
 80157ca:	62dc      	str	r4, [r3, #44]	; 0x2c
  HAL_GPIO_WritePin(GPIOC, GPIO_PIN_14, GPIO_PIN_RESET);
 80157cc:	f7f0 ff34 	bl	8006638 <HAL_GPIO_WritePin>
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 80157d0:	eef1 3a10 	vmrs	r3, fpscr
  tempFPURegisterVal |= (1<<24); // set the FTZ (flush-to-zero) bit in the FPU control register  // this makes checking for denormals not necessary as they are automatically set to zero by the hardware
 80157d4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 80157d8:	eee1 3a10 	vmsr	fpscr, r3
  HAL_ADCEx_Calibration_Start(&hadc1, ADC_CALIB_OFFSET, ADC_SINGLE_ENDED);
 80157dc:	f240 7010 	movw	r0, #1808	; 0x710
 80157e0:	4621      	mov	r1, r4
 80157e2:	f240 72ff 	movw	r2, #2047	; 0x7ff
 80157e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80157ea:	f7ec fd49 	bl	8002280 <HAL_ADCEx_Calibration_Start>
  if (HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_values, NUM_ADC_CHANNELS) != HAL_OK)
 80157ee:	f241 0180 	movw	r1, #4224	; 0x1080
 80157f2:	f240 7010 	movw	r0, #1808	; 0x710
 80157f6:	2206      	movs	r2, #6
 80157f8:	f2c3 0100 	movt	r1, #12288	; 0x3000
 80157fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015800:	f7eb f95a 	bl	8000ab8 <HAL_ADC_Start_DMA>
 8015804:	b138      	cbz	r0, 8015816 <main+0x246>
 8015806:	e7fe      	b.n	8015806 <main+0x236>
	  if((EE_WriteVariable(VirtAddVarTab[0],  0)) != HAL_OK)
 8015808:	4629      	mov	r1, r5
 801580a:	8820      	ldrh	r0, [r4, #0]
 801580c:	f7fe f9e4 	bl	8013bd8 <EE_WriteVariable>
 8015810:	2800      	cmp	r0, #0
 8015812:	d095      	beq.n	8015740 <main+0x170>
 8015814:	e7fe      	b.n	8015814 <main+0x244>
 8015816:	f241 6448 	movw	r4, #5704	; 0x1648
  HAL_Delay(10);
 801581a:	200a      	movs	r0, #10
 801581c:	f7eb f914 	bl	8000a48 <HAL_Delay>
 8015820:	f2c2 0400 	movt	r4, #8192	; 0x2000
  OLED_init(&hi2c4);
 8015824:	4620      	mov	r0, r4
 8015826:	f000 f96d 	bl	8015b04 <OLED_init>
  SDRAM_Initialization_sequence();
 801582a:	f7ff fe35 	bl	8015498 <SDRAM_Initialization_sequence>
  audioInit(&hi2c2, &hsai_BlockA1, &hsai_BlockB1);
 801582e:	f641 42a8 	movw	r2, #7336	; 0x1ca8
 8015832:	f641 6130 	movw	r1, #7728	; 0x1e30
 8015836:	f241 6094 	movw	r0, #5780	; 0x1694
 801583a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801583e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8015842:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015846:	f7fd fcbf 	bl	80131c8 <audioInit>
  OLED_writePreset();
 801584a:	f000 f8bf 	bl	80159cc <OLED_writePreset>
    MX_USB_HOST_Process();
 801584e:	f00b fead 	bl	80215ac <MX_USB_HOST_Process>
    OLED_process(); // process what to write to the screen but don't actually draw
 8015852:	f000 fd6f 	bl	8016334 <OLED_process>
 	if (hi2c4.State == HAL_I2C_STATE_READY)
 8015856:	f894 3041 	ldrb.w	r3, [r4, #65]	; 0x41
 801585a:	2b20      	cmp	r3, #32
 801585c:	d1f7      	bne.n	801584e <main+0x27e>
	  OLED_draw();
 801585e:	f000 fae5 	bl	8015e2c <OLED_draw>
 8015862:	e7f4      	b.n	801584e <main+0x27e>

08015864 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 8015864:	e7fe      	b.n	8015864 <Error_Handler>
 8015866:	bf00      	nop

08015868 <assert_failed>:
{ 
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
 8015868:	4770      	bx	lr
 801586a:	bf00      	nop

0801586c <setLED_Edit>:
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
}

void setLED_Edit(uint8_t onOff)
{
	if (onOff)
 801586c:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
 801586e:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
 8015872:	b922      	cbnz	r2, 801587e <setLED_Edit+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
 8015874:	2180      	movs	r1, #128	; 0x80
 8015876:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801587a:	f7f0 bedd 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
 801587e:	2201      	movs	r2, #1
 8015880:	2180      	movs	r1, #128	; 0x80
 8015882:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015886:	f7f0 bed7 	b.w	8006638 <HAL_GPIO_WritePin>
 801588a:	bf00      	nop

0801588c <setLED_USB>:
}


void setLED_USB(uint8_t onOff)
{
	if (onOff)
 801588c:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
 801588e:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
 8015892:	b922      	cbnz	r2, 801589e <setLED_USB+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 8015894:	2140      	movs	r1, #64	; 0x40
 8015896:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801589a:	f7f0 becd 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
 801589e:	2201      	movs	r2, #1
 80158a0:	2140      	movs	r1, #64	; 0x40
 80158a2:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158a6:	f7f0 bec7 	b.w	8006638 <HAL_GPIO_WritePin>
 80158aa:	bf00      	nop

080158ac <setLED_1>:
}


void setLED_1(uint8_t onOff)
{
	if (onOff)
 80158ac:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
 80158ae:	2000      	movs	r0, #0
	if (onOff)
 80158b0:	b92a      	cbnz	r2, 80158be <setLED_1+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_RESET);
 80158b2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80158b6:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158ba:	f7f0 bebd 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10, GPIO_PIN_SET);
 80158be:	2201      	movs	r2, #1
 80158c0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80158c4:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158c8:	f7f0 beb6 	b.w	8006638 <HAL_GPIO_WritePin>

080158cc <setLED_2>:
	}
}

void setLED_2(uint8_t onOff)
{
	if (onOff)
 80158cc:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 80158ce:	2000      	movs	r0, #0
	if (onOff)
 80158d0:	b92a      	cbnz	r2, 80158de <setLED_2+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
 80158d2:	f44f 7180 	mov.w	r1, #256	; 0x100
 80158d6:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158da:	f7f0 bead 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
 80158de:	2201      	movs	r2, #1
 80158e0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80158e4:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158e8:	f7f0 bea6 	b.w	8006638 <HAL_GPIO_WritePin>

080158ec <setLED_A>:
}


void setLED_A(uint8_t onOff)
{
	if (onOff)
 80158ec:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
 80158ee:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
 80158f2:	b922      	cbnz	r2, 80158fe <setLED_A+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_RESET);
 80158f4:	2140      	movs	r1, #64	; 0x40
 80158f6:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80158fa:	f7f0 be9d 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_6, GPIO_PIN_SET);
 80158fe:	2201      	movs	r2, #1
 8015900:	2140      	movs	r1, #64	; 0x40
 8015902:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015906:	f7f0 be97 	b.w	8006638 <HAL_GPIO_WritePin>
 801590a:	bf00      	nop

0801590c <setLED_B>:
	}
}

void setLED_B(uint8_t onOff)
{
	if (onOff)
 801590c:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
 801590e:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
 8015912:	b922      	cbnz	r2, 801591e <setLED_B+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_RESET);
 8015914:	2180      	movs	r1, #128	; 0x80
 8015916:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801591a:	f7f0 be8d 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_7, GPIO_PIN_SET);
 801591e:	2201      	movs	r2, #1
 8015920:	2180      	movs	r1, #128	; 0x80
 8015922:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015926:	f7f0 be87 	b.w	8006638 <HAL_GPIO_WritePin>
 801592a:	bf00      	nop

0801592c <setLED_C>:
	}
}

void setLED_C(uint8_t onOff)
{
	if (onOff)
 801592c:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
 801592e:	f44f 50c0 	mov.w	r0, #6144	; 0x1800
	if (onOff)
 8015932:	b92a      	cbnz	r2, 8015940 <setLED_C+0x14>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_RESET);
 8015934:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8015938:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801593c:	f7f0 be7c 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOG, GPIO_PIN_10, GPIO_PIN_SET);
 8015940:	2201      	movs	r2, #1
 8015942:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8015946:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801594a:	f7f0 be75 	b.w	8006638 <HAL_GPIO_WritePin>
 801594e:	bf00      	nop

08015950 <setLED_leftout_clip>:
	}
}

void setLED_leftout_clip(uint8_t onOff)
{
	if (onOff)
 8015950:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 8015952:	2000      	movs	r0, #0
	if (onOff)
 8015954:	b922      	cbnz	r2, 8015960 <setLED_leftout_clip+0x10>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
 8015956:	2110      	movs	r1, #16
 8015958:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801595c:	f7f0 be6c 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);
 8015960:	2201      	movs	r2, #1
 8015962:	2110      	movs	r1, #16
 8015964:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015968:	f7f0 be66 	b.w	8006638 <HAL_GPIO_WritePin>

0801596c <setLED_rightout_clip>:
	}
}

void setLED_rightout_clip(uint8_t onOff)
{
	if (onOff)
 801596c:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
 801596e:	2000      	movs	r0, #0
	if (onOff)
 8015970:	b922      	cbnz	r2, 801597c <setLED_rightout_clip+0x10>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
 8015972:	2140      	movs	r1, #64	; 0x40
 8015974:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015978:	f7f0 be5e 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
 801597c:	2201      	movs	r2, #1
 801597e:	2140      	movs	r1, #64	; 0x40
 8015980:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015984:	f7f0 be58 	b.w	8006638 <HAL_GPIO_WritePin>

08015988 <setLED_leftin_clip>:
	}
}

void setLED_leftin_clip(uint8_t onOff)
{
	if (onOff)
 8015988:	4602      	mov	r2, r0
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
 801598a:	f44f 6000 	mov.w	r0, #2048	; 0x800
	if (onOff)
 801598e:	b922      	cbnz	r2, 801599a <setLED_leftin_clip+0x12>
	}
	else
	{
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_RESET);
 8015990:	2110      	movs	r1, #16
 8015992:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8015996:	f7f0 be4f 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4, GPIO_PIN_SET);
 801599a:	2201      	movs	r2, #1
 801599c:	2110      	movs	r1, #16
 801599e:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80159a2:	f7f0 be49 	b.w	8006638 <HAL_GPIO_WritePin>
 80159a6:	bf00      	nop

080159a8 <setLED_rightin_clip>:
	}
}

void setLED_rightin_clip(uint8_t onOff)
{
	if (onOff)
 80159a8:	4602      	mov	r2, r0
 80159aa:	b930      	cbnz	r0, 80159ba <setLED_rightin_clip+0x12>
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
	}
	else
	{
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
 80159ac:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80159b0:	2101      	movs	r1, #1
 80159b2:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80159b6:	f7f0 be3f 	b.w	8006638 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET);
 80159ba:	2201      	movs	r2, #1
 80159bc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80159c0:	4611      	mov	r1, r2
 80159c2:	f6c5 0002 	movt	r0, #22530	; 0x5802
 80159c6:	f7f0 be37 	b.w	8006638 <HAL_GPIO_WritePin>
 80159ca:	bf00      	nop

080159cc <OLED_writePreset>:
//	OLED_draw();
}

void OLED_writePreset()
{
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 80159cc:	f24e 31cc 	movw	r1, #58316	; 0xe3cc
 80159d0:	f641 4070 	movw	r0, #7280	; 0x1c70
{
 80159d4:	b5f0      	push	{r4, r5, r6, r7, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 80159d6:	f6c0 0102 	movt	r1, #2050	; 0x802
{
 80159da:	b089      	sub	sp, #36	; 0x24
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 80159dc:	f2c2 0000 	movt	r0, #8192	; 0x2000
	OLEDclear();
	char tempString[24];
	itoa((currentPreset+1), tempString, 10);
 80159e0:	f240 6755 	movw	r7, #1621	; 0x655
	GFXsetFont(&theGFX, &EuphemiaCAS8pt7b);
 80159e4:	f7ff f85e 	bl	8014aa4 <GFXsetFont>
}


void OLEDclear()
{
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 80159e8:	2600      	movs	r6, #0
 80159ea:	2320      	movs	r3, #32
 80159ec:	f641 4070 	movw	r0, #7280	; 0x1c70
	itoa((currentPreset+1), tempString, 10);
 80159f0:	f2c2 0700 	movt	r7, #8192	; 0x2000
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 80159f4:	4632      	mov	r2, r6
 80159f6:	4631      	mov	r1, r6
 80159f8:	9300      	str	r3, [sp, #0]
 80159fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80159fe:	2380      	movs	r3, #128	; 0x80
 8015a00:	9601      	str	r6, [sp, #4]
	itoa((currentPreset+1), tempString, 10);
 8015a02:	ac02      	add	r4, sp, #8
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8015a04:	f7fe fc40 	bl	8014288 <GFXfillRect>
	itoa((currentPreset+1), tempString, 10);
 8015a08:	7838      	ldrb	r0, [r7, #0]
 8015a0a:	220a      	movs	r2, #10
 8015a0c:	4621      	mov	r1, r4
 8015a0e:	3001      	adds	r0, #1
 8015a10:	f015 f966 	bl	802ace0 <itoa>
	strcat(tempString, ":");
 8015a14:	4620      	mov	r0, r4
 8015a16:	f7ea fc5f 	bl	80002d8 <strlen>
 8015a1a:	f64e 2264 	movw	r2, #60004	; 0xea64
	strcat(tempString, modeNames[currentPreset]);
 8015a1e:	f248 7310 	movw	r3, #34576	; 0x8710
	strcat(tempString, ":");
 8015a22:	4605      	mov	r5, r0
 8015a24:	f6c0 0202 	movt	r2, #2050	; 0x802
	strcat(tempString, modeNames[currentPreset]);
 8015a28:	7839      	ldrb	r1, [r7, #0]
 8015a2a:	f2c2 0301 	movt	r3, #8193	; 0x2001
	strcat(tempString, ":");
 8015a2e:	3001      	adds	r0, #1
 8015a30:	8812      	ldrh	r2, [r2, #0]
	strcat(tempString, modeNames[currentPreset]);
 8015a32:	f853 1021 	ldr.w	r1, [r3, r1, lsl #2]
 8015a36:	4420      	add	r0, r4
	strcat(tempString, ":");
 8015a38:	5362      	strh	r2, [r4, r5]
	strcat(tempString, modeNames[currentPreset]);
 8015a3a:	f015 f966 	bl	802ad0a <stpcpy>
	int myLength = strlen(tempString);
 8015a3e:	1b05      	subs	r5, r0, r4

void OLEDwriteString(const char* myCharArray, uint8_t arrayLength, uint8_t startCursor, OLEDLine line)
{
	uint8_t cursorX = startCursor;
	uint8_t cursorY = 12 + (16 * (line%2));
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015a40:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015a44:	4631      	mov	r1, r6

	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015a46:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015a48:	220c      	movs	r2, #12
 8015a4a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015a4e:	f7ff f817 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015a52:	f04f 0c10 	mov.w	ip, #16
 8015a56:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015a5a:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015a5e:	9601      	str	r6, [sp, #4]
 8015a60:	4632      	mov	r2, r6
 8015a62:	009b      	lsls	r3, r3, #2
 8015a64:	4631      	mov	r1, r6
 8015a66:	f8cd c000 	str.w	ip, [sp]
 8015a6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015a6e:	f7fe fc0b 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015a72:	b15d      	cbz	r5, 8015a8c <OLED_writePreset+0xc0>
	{
		GFXwrite(&theGFX, myCharArray[i]);
 8015a74:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015a78:	4425      	add	r5, r4
 8015a7a:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015a7e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015a82:	4630      	mov	r0, r6
 8015a84:	f7fe ff48 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015a88:	42a5      	cmp	r5, r4
 8015a8a:	d1f8      	bne.n	8015a7e <OLED_writePreset+0xb2>
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015a8c:	f64d 6118 	movw	r1, #56856	; 0xde18
 8015a90:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015a94:	f6c0 0102 	movt	r1, #2050	; 0x802
 8015a98:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015a9c:	f7ff f802 	bl	8014aa4 <GFXsetFont>
	OLEDwriteString(modeNamesDetails[currentPreset], strlen(modeNamesDetails[currentPreset]), 0, SecondLine);
 8015aa0:	f648 03f0 	movw	r3, #35056	; 0x88f0
 8015aa4:	783a      	ldrb	r2, [r7, #0]
 8015aa6:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8015aaa:	f853 4022 	ldr.w	r4, [r3, r2, lsl #2]
 8015aae:	4620      	mov	r0, r4
 8015ab0:	f7ea fc12 	bl	80002d8 <strlen>
 8015ab4:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015ab6:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015aba:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015abc:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015abe:	2100      	movs	r1, #0
 8015ac0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015ac4:	f7fe ffdc 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015ac8:	2220      	movs	r2, #32
 8015aca:	2100      	movs	r1, #0
 8015acc:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015ad0:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015ad4:	9200      	str	r2, [sp, #0]
 8015ad6:	9101      	str	r1, [sp, #4]
 8015ad8:	009b      	lsls	r3, r3, #2
 8015ada:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015ade:	2210      	movs	r2, #16
 8015ae0:	f7fe fbd2 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015ae4:	b165      	cbz	r5, 8015b00 <OLED_writePreset+0x134>
 8015ae6:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 8015ae8:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015aec:	4425      	add	r5, r4
 8015aee:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015af2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8015af6:	4630      	mov	r0, r6
 8015af8:	f7fe ff0e 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015afc:	42ac      	cmp	r4, r5
 8015afe:	d1f8      	bne.n	8015af2 <OLED_writePreset+0x126>
}
 8015b00:	b009      	add	sp, #36	; 0x24
 8015b02:	bdf0      	pop	{r4, r5, r6, r7, pc}

08015b04 <OLED_init>:
{
 8015b04:	b5f0      	push	{r4, r5, r6, r7, lr}
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8015b06:	2278      	movs	r2, #120	; 0x78
{
 8015b08:	b083      	sub	sp, #12
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8015b0a:	2102      	movs	r1, #2
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8015b0c:	f640 47a1 	movw	r7, #3233	; 0xca1
	  ssd1306_begin(hi2c, SSD1306_SWITCHCAPVCC, SSD1306_I2C_ADDRESS);
 8015b10:	f009 f93e 	bl	801ed90 <ssd1306_begin>
 8015b14:	f248 4034 	movw	r0, #33844	; 0x8434
 8015b18:	f44f 7200 	mov.w	r2, #512	; 0x200
 8015b1c:	2100      	movs	r1, #0
 8015b1e:	f2c2 0001 	movt	r0, #8193	; 0x2001
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
 8015b22:	f640 5639 	movw	r6, #3385	; 0xd39
 8015b26:	f015 f8e8 	bl	802acfa <memset>
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
 8015b2a:	f640 55d1 	movw	r5, #3537	; 0xdd1
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8015b2e:	f249 0378 	movw	r3, #36984	; 0x9078
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
 8015b32:	f640 50dd 	movw	r0, #3549	; 0xddd
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
 8015b36:	f640 6149 	movw	r1, #3657	; 0xe49
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
 8015b3a:	f640 6255 	movw	r2, #3669	; 0xe55
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8015b3e:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8015b42:	f6c0 0702 	movt	r7, #2050	; 0x802
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
 8015b46:	f6c0 0602 	movt	r6, #2050	; 0x802
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
 8015b4a:	f6c0 0502 	movt	r5, #2050	; 0x802
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
 8015b4e:	f6c0 0002 	movt	r0, #2050	; 0x802
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
 8015b52:	f6c0 0102 	movt	r1, #2050	; 0x802
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
 8015b56:	f6c0 0202 	movt	r2, #2050	; 0x802
	buttonActionFunctions[Vocoder] = UIVocoderButtons;
 8015b5a:	601f      	str	r7, [r3, #0]
	buttonActionFunctions[VocoderCh] = UIVocoderChButtons;
 8015b5c:	605e      	str	r6, [r3, #4]
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
 8015b5e:	f640 7779 	movw	r7, #3961	; 0xf79
	buttonActionFunctions[Pitchshift] = UIPitchShiftButtons;
 8015b62:	609d      	str	r5, [r3, #8]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
 8015b64:	f241 061d 	movw	r6, #4125	; 0x101d
	buttonActionFunctions[AutotuneMono] = UINeartuneButtons;
 8015b68:	60d8      	str	r0, [r3, #12]
	buttonActionFunctions[Distortion] = UIDistortionButtons;
 8015b6a:	f241 05bd 	movw	r5, #4285	; 0x10bd
	buttonActionFunctions[AutotunePoly] = UIAutotuneButtons;
 8015b6e:	6119      	str	r1, [r3, #16]
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
 8015b70:	f241 1001 	movw	r0, #4353	; 0x1101
	buttonActionFunctions[SamplerButtonPress] = UISamplerBPButtons;
 8015b74:	615a      	str	r2, [r3, #20]
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
 8015b76:	f241 1145 	movw	r1, #4421	; 0x1145
	buttonActionFunctions[Delay] = UIDelayButtons;
 8015b7a:	f241 1289 	movw	r2, #4489	; 0x1189
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
 8015b7e:	f6c0 0702 	movt	r7, #2050	; 0x802
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
 8015b82:	f6c0 0602 	movt	r6, #2050	; 0x802
	buttonActionFunctions[Distortion] = UIDistortionButtons;
 8015b86:	f6c0 0502 	movt	r5, #2050	; 0x802
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
 8015b8a:	f6c0 0002 	movt	r0, #2050	; 0x802
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
 8015b8e:	f6c0 0102 	movt	r1, #2050	; 0x802
	buttonActionFunctions[Delay] = UIDelayButtons;
 8015b92:	f6c0 0202 	movt	r2, #2050	; 0x802
	buttonActionFunctions[SamplerKeyboard] = UISamplerKButtons;
 8015b96:	619f      	str	r7, [r3, #24]
	buttonActionFunctions[SamplerAutoGrab] = UISamplerAutoButtons;
 8015b98:	61de      	str	r6, [r3, #28]
	  GFXinit(&theGFX, 128, 32);
 8015b9a:	f641 4470 	movw	r4, #7280	; 0x1c70
	buttonActionFunctions[Distortion] = UIDistortionButtons;
 8015b9e:	621d      	str	r5, [r3, #32]
	buttonActionFunctions[Reverb] = UIReverbButtons;
 8015ba0:	f241 17f5 	movw	r7, #4597	; 0x11f5
	buttonActionFunctions[Wavefolder] = UIWaveFolderButtons;
 8015ba4:	6258      	str	r0, [r3, #36]	; 0x24
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
 8015ba6:	f241 2661 	movw	r6, #4705	; 0x1261
	buttonActionFunctions[BitCrusher] = UIBitcrusherButtons;
 8015baa:	6299      	str	r1, [r3, #40]	; 0x28
	buttonActionFunctions[LivingString] = UILivingStringButtons;
 8015bac:	f241 25a5 	movw	r5, #4773	; 0x12a5
	buttonActionFunctions[Delay] = UIDelayButtons;
 8015bb0:	62da      	str	r2, [r3, #44]	; 0x2c
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
 8015bb2:	f241 303d 	movw	r0, #4925	; 0x133d
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
 8015bb6:	f241 31d5 	movw	r1, #5077	; 0x13d5
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
 8015bba:	f241 422d 	movw	r2, #5165	; 0x142d
	  GFXinit(&theGFX, 128, 32);
 8015bbe:	f2c2 0400 	movt	r4, #8192	; 0x2000
	buttonActionFunctions[LivingStringSynth] = UILivingStringSynthButtons;
 8015bc2:	f6c0 0002 	movt	r0, #2050	; 0x802
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
 8015bc6:	f6c0 0102 	movt	r1, #2050	; 0x802
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
 8015bca:	f6c0 0202 	movt	r2, #2050	; 0x802
	buttonActionFunctions[Reverb] = UIReverbButtons;
 8015bce:	f6c0 0702 	movt	r7, #2050	; 0x802
	buttonActionFunctions[Reverb2] = UIReverb2Buttons;
 8015bd2:	f6c0 0602 	movt	r6, #2050	; 0x802
	buttonActionFunctions[LivingString] = UILivingStringButtons;
 8015bd6:	f6c0 0502 	movt	r5, #2050	; 0x802
	buttonActionFunctions[Rhodes] = UIRhodesButtons;
 8015bda:	645a      	str	r2, [r3, #68]	; 0x44
	buttonActionFunctions[Reverb] = UIReverbButtons;
 8015bdc:	631f      	str	r7, [r3, #48]	; 0x30
	buttonActionFunctions[ClassicSynth] = UIClassicSynthButtons;
 8015bde:	e9c3 010f 	strd	r0, r1, [r3, #60]	; 0x3c
	buttonActionFunctions[LivingString] = UILivingStringButtons;
 8015be2:	e9c3 650d 	strd	r6, r5, [r3, #52]	; 0x34
	  initModeNames();
 8015be6:	f009 fdf5 	bl	801f7d4 <initModeNames>
	  GFXinit(&theGFX, 128, 32);
 8015bea:	4620      	mov	r0, r4
 8015bec:	2220      	movs	r2, #32
 8015bee:	2180      	movs	r1, #128	; 0x80
 8015bf0:	f7fe fa3c 	bl	801406c <GFXinit>
	  GFXsetFont(&theGFX, &EuphemiaCAS8pt7b); //this one is elegant but definitely not monospaced can fit 9 Ms
 8015bf4:	f24e 31cc 	movw	r1, #58316	; 0xe3cc
 8015bf8:	4620      	mov	r0, r4
 8015bfa:	f6c0 0102 	movt	r1, #2050	; 0x802
 8015bfe:	f7fe ff51 	bl	8014aa4 <GFXsetFont>
	  GFXsetTextColor(&theGFX, 1, 0);
 8015c02:	4620      	mov	r0, r4
 8015c04:	2200      	movs	r2, #0
 8015c06:	2101      	movs	r1, #1
 8015c08:	f7fe ff48 	bl	8014a9c <GFXsetTextColor>
	  GFXsetTextSize(&theGFX, 1);
 8015c0c:	4620      	mov	r0, r4
 8015c0e:	2101      	movs	r1, #1
 8015c10:	f7fe ff3e 	bl	8014a90 <GFXsetTextSize>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8015c14:	2200      	movs	r2, #0
 8015c16:	2320      	movs	r3, #32
 8015c18:	4620      	mov	r0, r4
 8015c1a:	4611      	mov	r1, r2
 8015c1c:	9201      	str	r2, [sp, #4]
 8015c1e:	9300      	str	r3, [sp, #0]
 8015c20:	2380      	movs	r3, #128	; 0x80
 8015c22:	f7fe fb31 	bl	8014288 <GFXfillRect>
	  OLED_writePreset();
 8015c26:	f7ff fed1 	bl	80159cc <OLED_writePreset>
}
 8015c2a:	b003      	add	sp, #12
 8015c2c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	ssd1306_display_full_buffer();
 8015c30:	f009 ba12 	b.w	801f058 <ssd1306_display_full_buffer>

08015c34 <OLED_writeEditScreen>:
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015c34:	f64d 6118 	movw	r1, #56856	; 0xde18
 8015c38:	f641 4070 	movw	r0, #7280	; 0x1c70
{
 8015c3c:	b570      	push	{r4, r5, r6, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015c3e:	f6c0 0102 	movt	r1, #2050	; 0x802
{
 8015c42:	b082      	sub	sp, #8
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015c44:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8015c48:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015c4a:	f7fe ff2b 	bl	8014aa4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, 0, 128, 32, 0);
 8015c4e:	2320      	movs	r3, #32
 8015c50:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015c54:	4632      	mov	r2, r6
 8015c56:	4631      	mov	r1, r6
 8015c58:	9601      	str	r6, [sp, #4]
 8015c5a:	9300      	str	r3, [sp, #0]
 8015c5c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015c60:	2380      	movs	r3, #128	; 0x80
 8015c62:	f64e 243f 	movw	r4, #59967	; 0xea3f
 8015c66:	f7fe fb0f 	bl	8014288 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015c6a:	f641 4070 	movw	r0, #7280	; 0x1c70
		GFXwrite(&theGFX, myCharArray[i]);
 8015c6e:	f641 4570 	movw	r5, #7280	; 0x1c70
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015c72:	4631      	mov	r1, r6
 8015c74:	220c      	movs	r2, #12
 8015c76:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015c7a:	f6c0 0402 	movt	r4, #2050	; 0x802
 8015c7e:	f7fe feff 	bl	8014a80 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
 8015c82:	f2c2 0500 	movt	r5, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015c86:	2310      	movs	r3, #16
 8015c88:	9601      	str	r6, [sp, #4]
 8015c8a:	4632      	mov	r2, r6
 8015c8c:	4631      	mov	r1, r6
 8015c8e:	f104 060f 	add.w	r6, r4, #15
 8015c92:	9300      	str	r3, [sp, #0]
 8015c94:	4628      	mov	r0, r5
 8015c96:	23b4      	movs	r3, #180	; 0xb4
 8015c98:	f7fe faf6 	bl	8014288 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8015c9c:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8015ca0:	4628      	mov	r0, r5
 8015ca2:	f7fe fe39 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015ca6:	42a6      	cmp	r6, r4
 8015ca8:	d1f8      	bne.n	8015c9c <OLED_writeEditScreen+0x68>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015caa:	f641 4070 	movw	r0, #7280	; 0x1c70
		GFXwrite(&theGFX, myCharArray[i]);
 8015cae:	f641 4570 	movw	r5, #7280	; 0x1c70
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015cb2:	221c      	movs	r2, #28
 8015cb4:	2100      	movs	r1, #0
 8015cb6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015cba:	f64e 244f 	movw	r4, #59983	; 0xea4f
 8015cbe:	f7fe fedf 	bl	8014a80 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
 8015cc2:	f2c2 0500 	movt	r5, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015cc6:	2320      	movs	r3, #32
 8015cc8:	2100      	movs	r1, #0
 8015cca:	f6c0 0402 	movt	r4, #2050	; 0x802
 8015cce:	2210      	movs	r2, #16
 8015cd0:	4628      	mov	r0, r5
 8015cd2:	18a6      	adds	r6, r4, r2
 8015cd4:	e9cd 3100 	strd	r3, r1, [sp]
 8015cd8:	23c0      	movs	r3, #192	; 0xc0
 8015cda:	f7fe fad5 	bl	8014288 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8015cde:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8015ce2:	4628      	mov	r0, r5
 8015ce4:	f7fe fe18 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015ce8:	42b4      	cmp	r4, r6
 8015cea:	d1f8      	bne.n	8015cde <OLED_writeEditScreen+0xaa>
}
 8015cec:	b002      	add	sp, #8
 8015cee:	bd70      	pop	{r4, r5, r6, pc}

08015cf0 <OLED_writeTuning>:
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015cf0:	f64d 6118 	movw	r1, #56856	; 0xde18
 8015cf4:	f641 4070 	movw	r0, #7280	; 0x1c70
{
 8015cf8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015cfc:	f6c0 0102 	movt	r1, #2050	; 0x802
{
 8015d00:	b083      	sub	sp, #12
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015d02:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015d06:	2600      	movs	r6, #0
	GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8015d08:	f7fe fecc 	bl	8014aa4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015d0c:	f04f 0810 	mov.w	r8, #16
 8015d10:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d14:	2380      	movs	r3, #128	; 0x80
 8015d16:	4631      	mov	r1, r6
 8015d18:	4642      	mov	r2, r8
 8015d1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015d1e:	9601      	str	r6, [sp, #4]
 8015d20:	f8cd 8000 	str.w	r8, [sp]
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d24:	f04f 0920 	mov.w	r9, #32
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015d28:	f7fe faae 	bl	8014288 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015d2c:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d30:	4631      	mov	r1, r6
 8015d32:	221c      	movs	r2, #28
 8015d34:	f2c2 0000 	movt	r0, #8192	; 0x2000
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
 8015d38:	f240 6750 	movw	r7, #1616	; 0x650
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015d3c:	f7fe fea0 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d40:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d44:	2318      	movs	r3, #24
 8015d46:	4642      	mov	r2, r8
 8015d48:	4631      	mov	r1, r6
 8015d4a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015d4e:	9601      	str	r6, [sp, #4]
	}
}

void OLEDwriteInt(uint32_t myNumber, uint8_t numDigits, uint8_t startCursor, OLEDLine line)
{
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015d50:	f641 4450 	movw	r4, #7248	; 0x1c50
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d54:	f8cd 9000 	str.w	r9, [sp]
	OLEDwriteInt(currentTuning, 2, 12, SecondLine);
 8015d58:	f2c2 0700 	movt	r7, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d5c:	f7fe fa94 	bl	8014288 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8015d60:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d64:	2154      	movs	r1, #84	; 0x54
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015d66:	f2c2 0400 	movt	r4, #8192	; 0x2000
		GFXwrite(&theGFX, myCharArray[i]);
 8015d6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015d6e:	f7fe fdd3 	bl	8014918 <GFXwrite>
 8015d72:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d76:	4631      	mov	r1, r6
 8015d78:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015d7c:	f7fe fdcc 	bl	8014918 <GFXwrite>
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015d80:	6839      	ldr	r1, [r7, #0]
 8015d82:	2202      	movs	r2, #2
 8015d84:	4620      	mov	r0, r4
 8015d86:	f7fe fe9f 	bl	8014ac8 <OLEDparseInt>
 8015d8a:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015d8c:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015d90:	221c      	movs	r2, #28
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d92:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015d94:	210c      	movs	r1, #12
 8015d96:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015d9a:	f7fe fe71 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015d9e:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015da2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015da6:	4642      	mov	r2, r8
 8015da8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015dac:	210c      	movs	r1, #12
 8015dae:	009b      	lsls	r3, r3, #2
 8015db0:	e9cd 9600 	strd	r9, r6, [sp]
 8015db4:	f7fe fa68 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015db8:	b15d      	cbz	r5, 8015dd2 <OLED_writeTuning+0xe2>
		GFXwrite(&theGFX, myCharArray[i]);
 8015dba:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015dbe:	4425      	add	r5, r4
 8015dc0:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015dc4:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015dc8:	4630      	mov	r0, r6
 8015dca:	f7fe fda5 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015dce:	42ac      	cmp	r4, r5
 8015dd0:	d1f8      	bne.n	8015dc4 <OLED_writeTuning+0xd4>
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8015dd2:	683b      	ldr	r3, [r7, #0]
 8015dd4:	f64e 24d0 	movw	r4, #60112	; 0xead0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015dd8:	f641 4070 	movw	r0, #7280	; 0x1c70
		GFXwrite(&theGFX, myCharArray[i]);
 8015ddc:	f641 4670 	movw	r6, #7280	; 0x1c70
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8015de0:	eb03 0543 	add.w	r5, r3, r3, lsl #1
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015de4:	221c      	movs	r2, #28
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8015de6:	f6c0 0402 	movt	r4, #2050	; 0x802
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015dea:	f2c2 0000 	movt	r0, #8192	; 0x2000
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8015dee:	eb03 0585 	add.w	r5, r3, r5, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015df2:	2124      	movs	r1, #36	; 0x24
 8015df4:	f7fe fe44 	bl	8014a80 <GFXsetCursor>
		GFXwrite(&theGFX, myCharArray[i]);
 8015df8:	f2c2 0600 	movt	r6, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015dfc:	2200      	movs	r2, #0
 8015dfe:	2320      	movs	r3, #32
	OLEDwriteString(tuningNames[currentTuning], 12, 36, SecondLine);
 8015e00:	4425      	add	r5, r4
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015e02:	4630      	mov	r0, r6
 8015e04:	9201      	str	r2, [sp, #4]
 8015e06:	2124      	movs	r1, #36	; 0x24
 8015e08:	9300      	str	r3, [sp, #0]
 8015e0a:	2210      	movs	r2, #16
 8015e0c:	2390      	movs	r3, #144	; 0x90
 8015e0e:	1e6c      	subs	r4, r5, #1
 8015e10:	350b      	adds	r5, #11
 8015e12:	f7fe fa39 	bl	8014288 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 8015e16:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8015e1a:	4630      	mov	r0, r6
 8015e1c:	f7fe fd7c 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015e20:	42a5      	cmp	r5, r4
 8015e22:	d1f8      	bne.n	8015e16 <OLED_writeTuning+0x126>
}
 8015e24:	b003      	add	sp, #12
 8015e26:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8015e2a:	bf00      	nop

08015e2c <OLED_draw>:
	ssd1306_display_full_buffer();
 8015e2c:	f009 b914 	b.w	801f058 <ssd1306_display_full_buffer>

08015e30 <OLEDclearLine>:
{
 8015e30:	4602      	mov	r2, r0
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015e32:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015e36:	2100      	movs	r1, #0
 8015e38:	2380      	movs	r3, #128	; 0x80
 8015e3a:	f2c2 0000 	movt	r0, #8192	; 0x2000
{
 8015e3e:	b510      	push	{r4, lr}
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015e40:	0854      	lsrs	r4, r2, #1
 8015e42:	f002 0201 	and.w	r2, r2, #1
{
 8015e46:	b082      	sub	sp, #8
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8015e48:	3401      	adds	r4, #1
 8015e4a:	0112      	lsls	r2, r2, #4
 8015e4c:	9101      	str	r1, [sp, #4]
 8015e4e:	0124      	lsls	r4, r4, #4
 8015e50:	9400      	str	r4, [sp, #0]
 8015e52:	f7fe fa19 	bl	8014288 <GFXfillRect>
}
 8015e56:	b002      	add	sp, #8
 8015e58:	bd10      	pop	{r4, pc}
 8015e5a:	bf00      	nop

08015e5c <OLEDwriteString>:
{
 8015e5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015e60:	4690      	mov	r8, r2
	uint8_t cursorY = 12 + (16 * (line%2));
 8015e62:	f003 0201 	and.w	r2, r3, #1
{
 8015e66:	461f      	mov	r7, r3
 8015e68:	4604      	mov	r4, r0
	uint8_t cursorY = 12 + (16 * (line%2));
 8015e6a:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015e6c:	f641 4070 	movw	r0, #7280	; 0x1c70
{
 8015e70:	460d      	mov	r5, r1
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015e72:	1c7e      	adds	r6, r7, #1
{
 8015e74:	b082      	sub	sp, #8
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015e76:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015e7a:	4641      	mov	r1, r8
 8015e7c:	320c      	adds	r2, #12
 8015e7e:	f7fe fdff 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015e82:	f04f 0c00 	mov.w	ip, #0
 8015e86:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015e8a:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015e8e:	0136      	lsls	r6, r6, #4
 8015e90:	4641      	mov	r1, r8
 8015e92:	013a      	lsls	r2, r7, #4
 8015e94:	f8cd c004 	str.w	ip, [sp, #4]
 8015e98:	9600      	str	r6, [sp, #0]
 8015e9a:	009b      	lsls	r3, r3, #2
 8015e9c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015ea0:	f7fe f9f2 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015ea4:	b15d      	cbz	r5, 8015ebe <OLEDwriteString+0x62>
		GFXwrite(&theGFX, myCharArray[i]);
 8015ea6:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015eaa:	4425      	add	r5, r4
 8015eac:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015eb0:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015eb4:	4630      	mov	r0, r6
 8015eb6:	f7fe fd2f 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015eba:	42a5      	cmp	r5, r4
 8015ebc:	d1f8      	bne.n	8015eb0 <OLEDwriteString+0x54>
}
 8015ebe:	b002      	add	sp, #8
 8015ec0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08015ec4 <OLEDwriteInt>:
{
 8015ec4:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015ec6:	f641 4450 	movw	r4, #7248	; 0x1c50
{
 8015eca:	461f      	mov	r7, r3
 8015ecc:	b083      	sub	sp, #12
 8015ece:	4616      	mov	r6, r2
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015ed0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8015ed4:	460a      	mov	r2, r1
 8015ed6:	4601      	mov	r1, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015ed8:	b236      	sxth	r6, r6
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015eda:	4620      	mov	r0, r4
 8015edc:	f7fe fdf4 	bl	8014ac8 <OLEDparseInt>
	uint8_t cursorY = 12 + (16 * (line%2));
 8015ee0:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseInt(oled_buffer, myNumber, numDigits);
 8015ee4:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015ee6:	f641 4070 	movw	r0, #7280	; 0x1c70
	uint8_t cursorY = 12 + (16 * (line%2));
 8015eea:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015eec:	4631      	mov	r1, r6
 8015eee:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015ef2:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015ef4:	320c      	adds	r2, #12
 8015ef6:	f7fe fdc3 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015efa:	1c7a      	adds	r2, r7, #1
 8015efc:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015f00:	f04f 0c00 	mov.w	ip, #0
 8015f04:	0112      	lsls	r2, r2, #4
 8015f06:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015f0a:	4631      	mov	r1, r6
 8015f0c:	009b      	lsls	r3, r3, #2
 8015f0e:	9200      	str	r2, [sp, #0]
 8015f10:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015f14:	013a      	lsls	r2, r7, #4
 8015f16:	f8cd c004 	str.w	ip, [sp, #4]
 8015f1a:	f7fe f9b5 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015f1e:	b15d      	cbz	r5, 8015f38 <OLEDwriteInt+0x74>
		GFXwrite(&theGFX, myCharArray[i]);
 8015f20:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015f24:	4425      	add	r5, r4
 8015f26:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015f2a:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015f2e:	4630      	mov	r0, r6
 8015f30:	f7fe fcf2 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015f34:	42a5      	cmp	r5, r4
 8015f36:	d1f8      	bne.n	8015f2a <OLEDwriteInt+0x66>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8015f38:	b003      	add	sp, #12
 8015f3a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08015f3c <OLEDwritePitch>:

	OLEDwriteLine(oled_buffer, len, line);
}

void OLEDwritePitch(float midi, uint8_t startCursor, OLEDLine line, uint8_t showCents)
{
 8015f3c:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8015f3e:	f641 4450 	movw	r4, #7248	; 0x1c50
{
 8015f42:	460f      	mov	r7, r1
 8015f44:	b083      	sub	sp, #12
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8015f46:	4611      	mov	r1, r2
 8015f48:	f2c2 0400 	movt	r4, #8192	; 0x2000
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015f4c:	b206      	sxth	r6, r0
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8015f4e:	4620      	mov	r0, r4
 8015f50:	f7fe fdda 	bl	8014b08 <OLEDparsePitch>
	uint8_t cursorY = 12 + (16 * (line%2));
 8015f54:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparsePitch(oled_buffer, midi, showCents);
 8015f58:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015f5a:	f641 4070 	movw	r0, #7280	; 0x1c70
	uint8_t cursorY = 12 + (16 * (line%2));
 8015f5e:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015f60:	4631      	mov	r1, r6
 8015f62:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015f66:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015f68:	320c      	adds	r2, #12
 8015f6a:	f7fe fd89 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015f6e:	1c7a      	adds	r2, r7, #1
 8015f70:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015f74:	f04f 0c00 	mov.w	ip, #0
 8015f78:	0112      	lsls	r2, r2, #4
 8015f7a:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015f7e:	4631      	mov	r1, r6
 8015f80:	009b      	lsls	r3, r3, #2
 8015f82:	9200      	str	r2, [sp, #0]
 8015f84:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015f88:	013a      	lsls	r2, r7, #4
 8015f8a:	f8cd c004 	str.w	ip, [sp, #4]
 8015f8e:	f7fe f97b 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8015f92:	b15d      	cbz	r5, 8015fac <OLEDwritePitch+0x70>
		GFXwrite(&theGFX, myCharArray[i]);
 8015f94:	f641 4670 	movw	r6, #7280	; 0x1c70
 8015f98:	4425      	add	r5, r4
 8015f9a:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8015f9e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8015fa2:	4630      	mov	r0, r6
 8015fa4:	f7fe fcb8 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 8015fa8:	42a5      	cmp	r5, r4
 8015faa:	d1f8      	bne.n	8015f9e <OLEDwritePitch+0x62>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 8015fac:	b003      	add	sp, #12
 8015fae:	bdf0      	pop	{r4, r5, r6, r7, pc}

08015fb0 <OLEDwritePitchClass>:

void OLEDwritePitchClass(float midi, uint8_t startCursor, OLEDLine line)
{
 8015fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8015fb2:	f641 4450 	movw	r4, #7248	; 0x1c50
{
 8015fb6:	460f      	mov	r7, r1
 8015fb8:	b083      	sub	sp, #12
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015fba:	b206      	sxth	r6, r0
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8015fbc:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8015fc0:	4620      	mov	r0, r4
 8015fc2:	f7fe fe09 	bl	8014bd8 <OLEDparsePitchClass>
	uint8_t cursorY = 12 + (16 * (line%2));
 8015fc6:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparsePitchClass(oled_buffer, midi);
 8015fca:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015fcc:	f641 4070 	movw	r0, #7280	; 0x1c70
	uint8_t cursorY = 12 + (16 * (line%2));
 8015fd0:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015fd2:	4631      	mov	r1, r6
 8015fd4:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015fd8:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8015fda:	320c      	adds	r2, #12
 8015fdc:	f7fe fd50 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8015fe0:	1c7a      	adds	r2, r7, #1
 8015fe2:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8015fe6:	f04f 0c00 	mov.w	ip, #0
 8015fea:	0112      	lsls	r2, r2, #4
 8015fec:	f641 4070 	movw	r0, #7280	; 0x1c70
 8015ff0:	4631      	mov	r1, r6
 8015ff2:	009b      	lsls	r3, r3, #2
 8015ff4:	9200      	str	r2, [sp, #0]
 8015ff6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8015ffa:	013a      	lsls	r2, r7, #4
 8015ffc:	f8cd c004 	str.w	ip, [sp, #4]
 8016000:	f7fe f942 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8016004:	b15d      	cbz	r5, 801601e <OLEDwritePitchClass+0x6e>
		GFXwrite(&theGFX, myCharArray[i]);
 8016006:	f641 4670 	movw	r6, #7280	; 0x1c70
 801600a:	4425      	add	r5, r4
 801600c:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8016010:	f814 1b01 	ldrb.w	r1, [r4], #1
 8016014:	4630      	mov	r0, r6
 8016016:	f7fe fc7f 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 801601a:	42a5      	cmp	r5, r4
 801601c:	d1f8      	bne.n	8016010 <OLEDwritePitchClass+0x60>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 801601e:	b003      	add	sp, #12
 8016020:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8016022:	bf00      	nop

08016024 <OLEDwriteFloat>:
	OLEDwriteLine(oled_buffer, len, line);
}


void OLEDwriteFloat(float input, uint8_t startCursor, OLEDLine line)
{
 8016024:	b5f0      	push	{r4, r5, r6, r7, lr}
 8016026:	ed2d 8b02 	vpush	{d8}
 801602a:	b083      	sub	sp, #12
 801602c:	4606      	mov	r6, r0
 801602e:	460f      	mov	r7, r1
 8016030:	eeb0 8a40 	vmov.f32	s16, s0
	int numDigits = 5;
	int numDecimal = 1;

	if (fastabsf(input)<1.0f)
 8016034:	f011 fbd4 	bl	80277e0 <fastabsf>
 8016038:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801603c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016040:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016044:	d446      	bmi.n	80160d4 <OLEDwriteFloat+0xb0>
	{
		numDigits = 3;
		numDecimal = 2;
	}

	else if (fastabsf(input)<10.0f)
 8016046:	eeb0 0a48 	vmov.f32	s0, s16
 801604a:	f011 fbc9 	bl	80277e0 <fastabsf>
 801604e:	eef2 7a04 	vmov.f32	s15, #36	; 0x41200000  10.0
 8016052:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016056:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801605a:	d53e      	bpl.n	80160da <OLEDwriteFloat+0xb6>
 801605c:	2202      	movs	r2, #2
 801605e:	2104      	movs	r1, #4
	{
		numDigits = 8;
		numDecimal = 0;
	}

	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 8016060:	f641 4450 	movw	r4, #7248	; 0x1c50
 8016064:	eeb0 0a48 	vmov.f32	s0, s16
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8016068:	b236      	sxth	r6, r6
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 801606a:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801606e:	4620      	mov	r0, r4
 8016070:	f7fe fde2 	bl	8014c38 <OLEDparseFixedFloat>
	uint8_t cursorY = 12 + (16 * (line%2));
 8016074:	f007 0201 	and.w	r2, r7, #1
	int len = OLEDparseFixedFloat(oled_buffer, input, numDigits, numDecimal);
 8016078:	4605      	mov	r5, r0
	GFXsetCursor(&theGFX, cursorX, cursorY);
 801607a:	f641 4070 	movw	r0, #7280	; 0x1c70
	uint8_t cursorY = 12 + (16 * (line%2));
 801607e:	0112      	lsls	r2, r2, #4
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8016080:	4631      	mov	r1, r6
 8016082:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 8016086:	b2ed      	uxtb	r5, r5
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8016088:	320c      	adds	r2, #12
 801608a:	f7fe fcf9 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 801608e:	1c7a      	adds	r2, r7, #1
 8016090:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8016094:	f04f 0c00 	mov.w	ip, #0
 8016098:	0112      	lsls	r2, r2, #4
 801609a:	f641 4070 	movw	r0, #7280	; 0x1c70
 801609e:	4631      	mov	r1, r6
 80160a0:	009b      	lsls	r3, r3, #2
 80160a2:	9200      	str	r2, [sp, #0]
 80160a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80160a8:	013a      	lsls	r2, r7, #4
 80160aa:	f8cd c004 	str.w	ip, [sp, #4]
 80160ae:	f7fe f8eb 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 80160b2:	b15d      	cbz	r5, 80160cc <OLEDwriteFloat+0xa8>
		GFXwrite(&theGFX, myCharArray[i]);
 80160b4:	f641 4670 	movw	r6, #7280	; 0x1c70
 80160b8:	4425      	add	r5, r4
 80160ba:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80160be:	f814 1b01 	ldrb.w	r1, [r4], #1
 80160c2:	4630      	mov	r0, r6
 80160c4:	f7fe fc28 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 80160c8:	42ac      	cmp	r4, r5
 80160ca:	d1f8      	bne.n	80160be <OLEDwriteFloat+0x9a>

	OLEDwriteString(oled_buffer, len, startCursor, line);
}
 80160cc:	b003      	add	sp, #12
 80160ce:	ecbd 8b02 	vpop	{d8}
 80160d2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80160d4:	2202      	movs	r2, #2
 80160d6:	2103      	movs	r1, #3
 80160d8:	e7c2      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100.0f)
 80160da:	eeb0 0a48 	vmov.f32	s0, s16
 80160de:	f011 fb7f 	bl	80277e0 <fastabsf>
 80160e2:	2300      	movs	r3, #0
 80160e4:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
 80160e8:	ee07 3a90 	vmov	s15, r3
 80160ec:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80160f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80160f4:	d502      	bpl.n	80160fc <OLEDwriteFloat+0xd8>
 80160f6:	2202      	movs	r2, #2
 80160f8:	2105      	movs	r1, #5
 80160fa:	e7b1      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000.0f)
 80160fc:	eeb0 0a48 	vmov.f32	s0, s16
 8016100:	f011 fb6e 	bl	80277e0 <fastabsf>
 8016104:	2300      	movs	r3, #0
 8016106:	f2c4 437a 	movt	r3, #17530	; 0x447a
 801610a:	ee07 3a90 	vmov	s15, r3
 801610e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016112:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016116:	d502      	bpl.n	801611e <OLEDwriteFloat+0xfa>
 8016118:	2201      	movs	r2, #1
 801611a:	2105      	movs	r1, #5
 801611c:	e7a0      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000.0f)
 801611e:	eeb0 0a48 	vmov.f32	s0, s16
 8016122:	f011 fb5d 	bl	80277e0 <fastabsf>
 8016126:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801612a:	f2c4 631c 	movt	r3, #17948	; 0x461c
 801612e:	ee07 3a90 	vmov	s15, r3
 8016132:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8016136:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801613a:	d502      	bpl.n	8016142 <OLEDwriteFloat+0x11e>
 801613c:	2200      	movs	r2, #0
 801613e:	2105      	movs	r1, #5
 8016140:	e78e      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<100000.0f)
 8016142:	eeb0 0a48 	vmov.f32	s0, s16
 8016146:	f011 fb4b 	bl	80277e0 <fastabsf>
 801614a:	f44f 43a0 	mov.w	r3, #20480	; 0x5000
 801614e:	f2c4 73c3 	movt	r3, #18371	; 0x47c3
 8016152:	ee07 3a90 	vmov	s15, r3
 8016156:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801615a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801615e:	d502      	bpl.n	8016166 <OLEDwriteFloat+0x142>
 8016160:	2200      	movs	r2, #0
 8016162:	2106      	movs	r1, #6
 8016164:	e77c      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<1000000.0f)
 8016166:	eeb0 0a48 	vmov.f32	s0, s16
 801616a:	f011 fb39 	bl	80277e0 <fastabsf>
 801616e:	f44f 5310 	mov.w	r3, #9216	; 0x2400
 8016172:	f6c4 1374 	movt	r3, #18804	; 0x4974
 8016176:	ee07 3a90 	vmov	s15, r3
 801617a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 801617e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8016182:	d502      	bpl.n	801618a <OLEDwriteFloat+0x166>
 8016184:	2200      	movs	r2, #0
 8016186:	2107      	movs	r1, #7
 8016188:	e76a      	b.n	8016060 <OLEDwriteFloat+0x3c>
	else if (fastabsf(input)<10000000.0f)
 801618a:	eeb0 0a48 	vmov.f32	s0, s16
 801618e:	f011 fb27 	bl	80277e0 <fastabsf>
 8016192:	f249 6380 	movw	r3, #38528	; 0x9680
 8016196:	f6c4 3318 	movt	r3, #19224	; 0x4b18
 801619a:	ee07 3a90 	vmov	s15, r3
 801619e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80161a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80161a6:	d5b7      	bpl.n	8016118 <OLEDwriteFloat+0xf4>
 80161a8:	2200      	movs	r2, #0
 80161aa:	2108      	movs	r1, #8
 80161ac:	e758      	b.n	8016060 <OLEDwriteFloat+0x3c>
 80161ae:	bf00      	nop

080161b0 <OLED_writeKnobParameter.part.0>:
void OLED_writeKnobParameter(uint8_t whichKnob)
 80161b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161b4:	f240 6b55 	movw	fp, #1621	; 0x655
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80161b8:	f240 6656 	movw	r6, #1622	; 0x656
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161bc:	f648 0124 	movw	r1, #34852	; 0x8824
void OLED_writeKnobParameter(uint8_t whichKnob)
 80161c0:	4680      	mov	r8, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161c2:	f2c2 0b00 	movt	fp, #8192	; 0x2000
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80161c6:	f2c2 0600 	movt	r6, #8192	; 0x2000
 80161ca:	2705      	movs	r7, #5
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161cc:	0080      	lsls	r0, r0, #2
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161ce:	f89b 3000 	ldrb.w	r3, [fp]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161d2:	f2c2 0101 	movt	r1, #8193	; 0x2001
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80161d6:	7835      	ldrb	r5, [r6, #0]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161d8:	f648 023c 	movw	r2, #34876	; 0x883c
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161dc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80161e0:	f648 1464 	movw	r4, #35172	; 0x8964
		int whichParam = whichKnob + (knobPage * KNOB_PAGE_SIZE);
 80161e4:	fb17 8705 	smlabb	r7, r7, r5, r8
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161e8:	4401      	add	r1, r0
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161ea:	eb03 0383 	add.w	r3, r3, r3, lsl #2
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161ee:	f2c2 0201 	movt	r2, #8193	; 0x2001
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 80161f2:	f2c2 0401 	movt	r4, #8193	; 0x2001
 80161f6:	443b      	add	r3, r7
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161f8:	4402      	add	r2, r0
void OLED_writeKnobParameter(uint8_t whichKnob)
 80161fa:	ed2d 8b02 	vpush	{d8}
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 80161fe:	6809      	ldr	r1, [r1, #0]
void OLED_writeKnobParameter(uint8_t whichKnob)
 8016200:	b083      	sub	sp, #12
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 8016202:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
		floatADCUI[whichKnob] = smoothedADC[whichKnob];
 8016206:	6011      	str	r1, [r2, #0]
		int len = strlen(knobParamNames[currentPreset][whichParam]);
 8016208:	f7ea f866 	bl	80002d8 <strlen>
		if (len > 0)
 801620c:	2800      	cmp	r0, #0
 801620e:	f000 808b 	beq.w	8016328 <OLED_writeKnobParameter.part.0+0x178>
 8016212:	4605      	mov	r5, r0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8016214:	f64d 6118 	movw	r1, #56856	; 0xde18
 8016218:	f641 4070 	movw	r0, #7280	; 0x1c70
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 801621c:	f04f 0900 	mov.w	r9, #0
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8016220:	f6c0 0102 	movt	r1, #2050	; 0x802
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8016224:	f04f 0a10 	mov.w	sl, #16
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 8016228:	f2c2 0000 	movt	r0, #8192	; 0x2000
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 801622c:	b2ed      	uxtb	r5, r5
			GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 801622e:	f7fe fc39 	bl	8014aa4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 8016232:	f641 4070 	movw	r0, #7280	; 0x1c70
 8016236:	4649      	mov	r1, r9
 8016238:	4652      	mov	r2, sl
 801623a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801623e:	2380      	movs	r3, #128	; 0x80
 8016240:	f8cd 9004 	str.w	r9, [sp, #4]
 8016244:	f8cd a000 	str.w	sl, [sp]
 8016248:	f7fe f81e 	bl	8014288 <GFXfillRect>
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 801624c:	f89b 3000 	ldrb.w	r3, [fp]
	GFXsetCursor(&theGFX, cursorX, cursorY);
 8016250:	f641 4070 	movw	r0, #7280	; 0x1c70
 8016254:	4649      	mov	r1, r9
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 8016256:	eb03 0383 	add.w	r3, r3, r3, lsl #2
	GFXsetCursor(&theGFX, cursorX, cursorY);
 801625a:	221c      	movs	r2, #28
 801625c:	f2c2 0000 	movt	r0, #8192	; 0x2000
			OLEDwriteString(knobParamNames[currentPreset][whichParam], len, 0, SecondLine);
 8016260:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8016264:	441f      	add	r7, r3
 8016266:	f854 4027 	ldr.w	r4, [r4, r7, lsl #2]
	GFXsetCursor(&theGFX, cursorX, cursorY);
 801626a:	f7fe fc09 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 801626e:	2720      	movs	r7, #32
 8016270:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 8016274:	f641 4070 	movw	r0, #7280	; 0x1c70
 8016278:	f8cd 9004 	str.w	r9, [sp, #4]
 801627c:	4652      	mov	r2, sl
 801627e:	4649      	mov	r1, r9
 8016280:	009b      	lsls	r3, r3, #2
 8016282:	9700      	str	r7, [sp, #0]
 8016284:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016288:	f7fd fffe 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 801628c:	b165      	cbz	r5, 80162a8 <OLED_writeKnobParameter.part.0+0xf8>
 801628e:	3c01      	subs	r4, #1
		GFXwrite(&theGFX, myCharArray[i]);
 8016290:	f641 4770 	movw	r7, #7280	; 0x1c70
 8016294:	4425      	add	r5, r4
 8016296:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801629a:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 801629e:	4638      	mov	r0, r7
 80162a0:	f7fe fb3a 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 80162a4:	42ac      	cmp	r4, r5
 80162a6:	d1f8      	bne.n	801629a <OLED_writeKnobParameter.part.0+0xea>
	return GFXgetCursorX(&theGFX);
 80162a8:	f641 4070 	movw	r0, #7280	; 0x1c70
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 80162ac:	2420      	movs	r4, #32
	return GFXgetCursorX(&theGFX);
 80162ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80162b2:	f7fe fbe9 	bl	8014a88 <GFXgetCursorX>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 80162b6:	221c      	movs	r2, #28
 80162b8:	b2c5      	uxtb	r5, r0
 80162ba:	f641 4070 	movw	r0, #7280	; 0x1c70
 80162be:	4629      	mov	r1, r5
 80162c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80162c4:	f7fe fbdc 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 80162c8:	2300      	movs	r3, #0
 80162ca:	f641 4070 	movw	r0, #7280	; 0x1c70
 80162ce:	4629      	mov	r1, r5
 80162d0:	9301      	str	r3, [sp, #4]
 80162d2:	2210      	movs	r2, #16
 80162d4:	230c      	movs	r3, #12
 80162d6:	9400      	str	r4, [sp, #0]
 80162d8:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80162dc:	f7fd ffd4 	bl	8014288 <GFXfillRect>
		GFXwrite(&theGFX, myCharArray[i]);
 80162e0:	f641 4070 	movw	r0, #7280	; 0x1c70
 80162e4:	4621      	mov	r1, r4
 80162e6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80162ea:	f7fe fb15 	bl	8014918 <GFXwrite>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 80162ee:	7831      	ldrb	r1, [r6, #0]
 80162f0:	2205      	movs	r2, #5
 80162f2:	f248 7394 	movw	r3, #34708	; 0x8794
	return GFXgetCursorX(&theGFX);
 80162f6:	f641 4070 	movw	r0, #7280	; 0x1c70
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 80162fa:	fb12 8801 	smlabb	r8, r2, r1, r8
 80162fe:	f2c2 0301 	movt	r3, #8193	; 0x2001
	return GFXgetCursorX(&theGFX);
 8016302:	f2c2 0000 	movt	r0, #8192	; 0x2000
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 8016306:	eb03 0388 	add.w	r3, r3, r8, lsl #2
 801630a:	ed93 8a00 	vldr	s16, [r3]
	return GFXgetCursorX(&theGFX);
 801630e:	f7fe fbbb 	bl	8014a88 <GFXgetCursorX>
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 8016312:	2101      	movs	r1, #1
 8016314:	b2c0      	uxtb	r0, r0
 8016316:	eeb0 0a48 	vmov.f32	s0, s16
}
 801631a:	b003      	add	sp, #12
 801631c:	ecbd 8b02 	vpop	{d8}
 8016320:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			OLEDwriteFloat(displayValues[whichKnob + (knobPage * KNOB_PAGE_SIZE)], getCursorX(), SecondLine);
 8016324:	f7ff be7e 	b.w	8016024 <OLEDwriteFloat>
}
 8016328:	b003      	add	sp, #12
 801632a:	ecbd 8b02 	vpop	{d8}
 801632e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016332:	bf00      	nop

08016334 <OLED_process>:
{
 8016334:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (writeKnobFlag >= 0)
 8016338:	f240 24cf 	movw	r4, #719	; 0x2cf
{
 801633c:	b083      	sub	sp, #12
	if (writeKnobFlag >= 0)
 801633e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8016342:	f994 0000 	ldrsb.w	r0, [r4]
 8016346:	2800      	cmp	r0, #0
 8016348:	db03      	blt.n	8016352 <OLED_process+0x1e>
	if (whichKnob < KNOB_PAGE_SIZE)
 801634a:	2804      	cmp	r0, #4
 801634c:	dd6f      	ble.n	801642e <OLED_process+0xfa>
		writeKnobFlag = -1;
 801634e:	23ff      	movs	r3, #255	; 0xff
 8016350:	7023      	strb	r3, [r4, #0]
	if (writeButtonFlag >= 0 && writeActionFlag >= 0) //These should always be set together
 8016352:	f240 24ce 	movw	r4, #718	; 0x2ce
 8016356:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801635a:	f994 0000 	ldrsb.w	r0, [r4]
 801635e:	2800      	cmp	r0, #0
 8016360:	db62      	blt.n	8016428 <OLED_process+0xf4>
 8016362:	f240 27cd 	movw	r7, #717	; 0x2cd
 8016366:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801636a:	f997 1000 	ldrsb.w	r1, [r7]
 801636e:	2900      	cmp	r1, #0
 8016370:	db5a      	blt.n	8016428 <OLED_process+0xf4>
	char* str = buttonActionFunctions[currentPreset](whichButton, whichAction);
 8016372:	f240 6255 	movw	r2, #1621	; 0x655
 8016376:	f249 0378 	movw	r3, #36984	; 0x9078
 801637a:	b2c9      	uxtb	r1, r1
 801637c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8016380:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8016384:	b2c0      	uxtb	r0, r0
 8016386:	7812      	ldrb	r2, [r2, #0]
 8016388:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 801638c:	4798      	blx	r3
 801638e:	4605      	mov	r5, r0
	int len = strlen(str);
 8016390:	f7e9 ffa2 	bl	80002d8 <strlen>
	if (len > 0)
 8016394:	4606      	mov	r6, r0
 8016396:	2800      	cmp	r0, #0
 8016398:	d043      	beq.n	8016422 <OLED_process+0xee>
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 801639a:	f64d 6118 	movw	r1, #56856	; 0xde18
 801639e:	f641 4070 	movw	r0, #7280	; 0x1c70
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 80163a2:	f04f 0800 	mov.w	r8, #0
 80163a6:	f04f 0910 	mov.w	r9, #16
		GFXsetFont(&theGFX, &EuphemiaCAS7pt7b);
 80163aa:	f6c0 0102 	movt	r1, #2050	; 0x802
 80163ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80163b2:	f7fe fb77 	bl	8014aa4 <GFXsetFont>
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 80163b6:	f641 4070 	movw	r0, #7280	; 0x1c70
 80163ba:	2380      	movs	r3, #128	; 0x80
 80163bc:	4641      	mov	r1, r8
 80163be:	464a      	mov	r2, r9
 80163c0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80163c4:	f8cd 8004 	str.w	r8, [sp, #4]
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 80163c8:	b2f6      	uxtb	r6, r6
	GFXfillRect(&theGFX, 0, (line%2)*16, 128, 16*((line/2)+1), 0);
 80163ca:	f8cd 9000 	str.w	r9, [sp]
 80163ce:	f7fd ff5b 	bl	8014288 <GFXfillRect>
	GFXsetCursor(&theGFX, cursorX, cursorY);
 80163d2:	f641 4070 	movw	r0, #7280	; 0x1c70
 80163d6:	4641      	mov	r1, r8
 80163d8:	221c      	movs	r2, #28
 80163da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80163de:	f7fe fb4f 	bl	8014a80 <GFXsetCursor>
	GFXfillRect(&theGFX, startCursor, line*16, arrayLength*12, (line*16)+16, 0);
 80163e2:	f04f 0c20 	mov.w	ip, #32
 80163e6:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 80163ea:	f641 4070 	movw	r0, #7280	; 0x1c70
 80163ee:	f8cd 8004 	str.w	r8, [sp, #4]
 80163f2:	464a      	mov	r2, r9
 80163f4:	4641      	mov	r1, r8
 80163f6:	009b      	lsls	r3, r3, #2
 80163f8:	f8cd c000 	str.w	ip, [sp]
 80163fc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016400:	f7fd ff42 	bl	8014288 <GFXfillRect>
	for (int i = 0; i < arrayLength; ++i)
 8016404:	b16e      	cbz	r6, 8016422 <OLED_process+0xee>
 8016406:	442e      	add	r6, r5
		GFXwrite(&theGFX, myCharArray[i]);
 8016408:	f641 4870 	movw	r8, #7280	; 0x1c70
 801640c:	3d01      	subs	r5, #1
 801640e:	3e01      	subs	r6, #1
 8016410:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8016414:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8016418:	4640      	mov	r0, r8
 801641a:	f7fe fa7d 	bl	8014918 <GFXwrite>
	for (int i = 0; i < arrayLength; ++i)
 801641e:	42b5      	cmp	r5, r6
 8016420:	d1f8      	bne.n	8016414 <OLED_process+0xe0>
		writeButtonFlag = -1;
 8016422:	23ff      	movs	r3, #255	; 0xff
 8016424:	7023      	strb	r3, [r4, #0]
		writeActionFlag = -1;
 8016426:	703b      	strb	r3, [r7, #0]
}
 8016428:	b003      	add	sp, #12
 801642a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 801642e:	b2c0      	uxtb	r0, r0
 8016430:	f7ff febe 	bl	80161b0 <OLED_writeKnobParameter.part.0>
 8016434:	e78b      	b.n	801634e <OLED_process+0x1a>
 8016436:	bf00      	nop

08016438 <OLEDgetCursor>:
	}
}

int16_t OLEDgetCursor()
{
	return GFXgetCursorX(&theGFX);
 8016438:	f641 4070 	movw	r0, #7280	; 0x1c70
 801643c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016440:	f7fe bb22 	b.w	8014a88 <GFXgetCursorX>

08016444 <MX_RNG_Init>:

RNG_HandleTypeDef hrng;

/* RNG init function */
void MX_RNG_Init(void)
{
 8016444:	b508      	push	{r3, lr}

  hrng.Instance = RNG;
 8016446:	f641 4394 	movw	r3, #7316	; 0x1c94
 801644a:	f44f 52c0 	mov.w	r2, #6144	; 0x1800
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 801644e:	2100      	movs	r1, #0
  hrng.Instance = RNG;
 8016450:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016454:	f6c4 0202 	movt	r2, #18434	; 0x4802
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 8016458:	4618      	mov	r0, r3
  hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
 801645a:	e9c3 2100 	strd	r2, r1, [r3]
  if (HAL_RNG_Init(&hrng) != HAL_OK)
 801645e:	f7f5 f9c9 	bl	800b7f4 <HAL_RNG_Init>
 8016462:	b900      	cbnz	r0, 8016466 <MX_RNG_Init+0x22>
  {
    Error_Handler();
  }

}
 8016464:	bd08      	pop	{r3, pc}
 8016466:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 801646a:	f7ff b9fb 	b.w	8015864 <Error_Handler>
 801646e:	bf00      	nop

08016470 <HAL_RNG_MspInit>:

void HAL_RNG_MspInit(RNG_HandleTypeDef* rngHandle)
{

  if(rngHandle->Instance==RNG)
 8016470:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
 8016474:	6802      	ldr	r2, [r0, #0]
 8016476:	f6c4 0302 	movt	r3, #18434	; 0x4802
 801647a:	429a      	cmp	r2, r3
 801647c:	d000      	beq.n	8016480 <HAL_RNG_MspInit+0x10>
 801647e:	4770      	bx	lr
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* RNG clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 8016480:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
 8016484:	b082      	sub	sp, #8
    __HAL_RCC_RNG_CLK_ENABLE();
 8016486:	f6c5 0302 	movt	r3, #22530	; 0x5802
 801648a:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 801648e:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8016492:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
 8016496:	f8d3 30dc 	ldr.w	r3, [r3, #220]	; 0xdc
 801649a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 801649e:	9301      	str	r3, [sp, #4]
 80164a0:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }
}
 80164a2:	b002      	add	sp, #8
 80164a4:	4770      	bx	lr
 80164a6:	bf00      	nop

080164a8 <MX_SAI1_Init>:
DMA_HandleTypeDef hdma_sai1_a;
DMA_HandleTypeDef hdma_sai1_b;

/* SAI1 init function */
void MX_SAI1_Init(void)
{
 80164a8:	b570      	push	{r4, r5, r6, lr}

  hsai_BlockA1.Instance = SAI1_Block_A;
 80164aa:	f645 0204 	movw	r2, #22532	; 0x5804
 80164ae:	f641 6430 	movw	r4, #7728	; 0x1e30
  hsai_BlockA1.Init.AudioMode = SAI_MODEMASTER_TX;
 80164b2:	2500      	movs	r5, #0
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
  hsai_BlockA1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 80164b4:	2101      	movs	r1, #1
  hsai_BlockA1.Instance = SAI1_Block_A;
 80164b6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80164ba:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockA1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 80164be:	2302      	movs	r3, #2
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 80164c0:	f64b 3680 	movw	r6, #48000	; 0xbb80
  hsai_BlockA1.Instance = SAI1_Block_A;
 80164c4:	6022      	str	r2, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 80164c6:	4620      	mov	r0, r4
  hsai_BlockA1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 80164c8:	61e1      	str	r1, [r4, #28]
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 80164ca:	461a      	mov	r2, r3
 80164cc:	4629      	mov	r1, r5
  hsai_BlockA1.Init.AudioFrequency = SAI_AUDIO_FREQUENCY_48K;
 80164ce:	6226      	str	r6, [r4, #32]
  hsai_BlockA1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 80164d0:	60e5      	str	r5, [r4, #12]
  hsai_BlockA1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 80164d2:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockA1.Init.Synchro = SAI_ASYNCHRONOUS;
 80164d4:	e9c4 5501 	strd	r5, r5, [r4, #4]
  hsai_BlockA1.Init.NoDivider = SAI_MASTERDIVIDER_ENABLE;
 80164d8:	e9c4 5505 	strd	r5, r5, [r4, #20]
  hsai_BlockA1.Init.CompandingMode = SAI_NOCOMPANDING;
 80164dc:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockA1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 80164e0:	f7f5 fa16 	bl	800b910 <HAL_SAI_InitProtocol>
 80164e4:	b9f8      	cbnz	r0, 8016526 <MX_SAI1_Init+0x7e>
  {
    Error_Handler();
  }

  hsai_BlockB1.Instance = SAI1_Block_B;
 80164e6:	f641 44a8 	movw	r4, #7336	; 0x1ca8
 80164ea:	f645 0224 	movw	r2, #22564	; 0x5824
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 80164ee:	2500      	movs	r5, #0
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
 80164f0:	2103      	movs	r1, #3
  hsai_BlockB1.Instance = SAI1_Block_B;
 80164f2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80164f6:	f2c4 0201 	movt	r2, #16385	; 0x4001
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
  hsai_BlockB1.Init.MonoStereoMode = SAI_STEREOMODE;
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 80164fa:	2302      	movs	r3, #2
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
 80164fc:	2601      	movs	r6, #1
  hsai_BlockB1.Instance = SAI1_Block_B;
 80164fe:	6022      	str	r2, [r4, #0]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8016500:	4620      	mov	r0, r4
  hsai_BlockB1.Init.AudioMode = SAI_MODESLAVE_RX;
 8016502:	6061      	str	r1, [r4, #4]
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8016504:	461a      	mov	r2, r3
 8016506:	4629      	mov	r1, r5
  hsai_BlockB1.Init.Synchro = SAI_SYNCHRONOUS;
 8016508:	60a6      	str	r6, [r4, #8]
  hsai_BlockB1.Init.FIFOThreshold = SAI_FIFOTHRESHOLD_1QF;
 801650a:	61e6      	str	r6, [r4, #28]
  hsai_BlockB1.Init.OutputDrive = SAI_OUTPUTDRIVE_DISABLE;
 801650c:	6165      	str	r5, [r4, #20]
  hsai_BlockB1.Init.SynchroExt = SAI_SYNCEXT_DISABLE;
 801650e:	60e5      	str	r5, [r4, #12]
  hsai_BlockB1.Init.TriState = SAI_OUTPUT_NOTRELEASED;
 8016510:	6365      	str	r5, [r4, #52]	; 0x34
  hsai_BlockB1.Init.CompandingMode = SAI_NOCOMPANDING;
 8016512:	e9c4 550b 	strd	r5, r5, [r4, #44]	; 0x2c
  if (HAL_SAI_InitProtocol(&hsai_BlockB1, SAI_I2S_STANDARD, SAI_PROTOCOL_DATASIZE_24BIT, 2) != HAL_OK)
 8016516:	f7f5 f9fb 	bl	800b910 <HAL_SAI_InitProtocol>
 801651a:	b900      	cbnz	r0, 801651e <MX_SAI1_Init+0x76>
  {
    Error_Handler();
  }

}
 801651c:	bd70      	pop	{r4, r5, r6, pc}
 801651e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Error_Handler();
 8016522:	f7ff b99f 	b.w	8015864 <Error_Handler>
    Error_Handler();
 8016526:	f7ff f99d 	bl	8015864 <Error_Handler>
 801652a:	e7dc      	b.n	80164e6 <MX_SAI1_Init+0x3e>

0801652c <HAL_SAI_MspInit>:
void HAL_SAI_MspInit(SAI_HandleTypeDef* hsai)
{

  GPIO_InitTypeDef GPIO_InitStruct;
/* SAI1 */
    if(hsai->Instance==SAI1_Block_A)
 801652c:	f645 0204 	movw	r2, #22532	; 0x5804
{
 8016530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    if(hsai->Instance==SAI1_Block_A)
 8016534:	f2c4 0201 	movt	r2, #16385	; 0x4001
 8016538:	6803      	ldr	r3, [r0, #0]
{
 801653a:	b088      	sub	sp, #32
 801653c:	4605      	mov	r5, r0
    if(hsai->Instance==SAI1_Block_A)
 801653e:	4293      	cmp	r3, r2
 8016540:	d051      	beq.n	80165e6 <HAL_SAI_MspInit+0xba>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
    }
    if(hsai->Instance==SAI1_Block_B)
 8016542:	f645 0224 	movw	r2, #22564	; 0x5824
 8016546:	f2c4 0201 	movt	r2, #16385	; 0x4001
 801654a:	4293      	cmp	r3, r2
 801654c:	d002      	beq.n	8016554 <HAL_SAI_MspInit+0x28>
    /* Several peripheral DMA handle pointers point to the same DMA handle.
     Be aware that there is only one channel to perform all the requested DMAs. */
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
    }
}
 801654e:	b008      	add	sp, #32
 8016550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (SAI1_client == 0)
 8016554:	f240 540c 	movw	r4, #1292	; 0x50c
 8016558:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801655c:	6822      	ldr	r2, [r4, #0]
 801655e:	2a00      	cmp	r2, #0
 8016560:	f000 8098 	beq.w	8016694 <HAL_SAI_MspInit+0x168>
    SAI1_client ++;
 8016564:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8016566:	2108      	movs	r1, #8
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016568:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801656c:	2600      	movs	r6, #0
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801656e:	2302      	movs	r3, #2
    SAI1_client ++;
 8016570:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8016572:	2206      	movs	r2, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016574:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Pin = GPIO_PIN_3;
 8016578:	9103      	str	r1, [sp, #12]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801657a:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801657c:	9304      	str	r3, [sp, #16]
    hdma_sai1_b.Instance = DMA1_Stream2;
 801657e:	f641 54b8 	movw	r4, #7608	; 0x1db8
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8016582:	9207      	str	r2, [sp, #28]
    hdma_sai1_b.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 8016584:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_b.Instance = DMA1_Stream2;
 8016588:	f2c2 0400 	movt	r4, #8192	; 0x2000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 801658c:	e9cd 6305 	strd	r6, r3, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016590:	f7ef fca8 	bl	8005ee4 <HAL_GPIO_Init>
    hdma_sai1_b.Instance = DMA1_Stream2;
 8016594:	2340      	movs	r3, #64	; 0x40
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8016596:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    hdma_sai1_b.Init.MemInc = DMA_MINC_ENABLE;
 801659a:	f44f 6c80 	mov.w	ip, #1024	; 0x400
    hdma_sai1_b.Instance = DMA1_Stream2;
 801659e:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
 80165a2:	f04f 0e58 	mov.w	lr, #88	; 0x58
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
 80165a6:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_b.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 80165aa:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_b.Instance = DMA1_Stream2;
 80165ae:	6023      	str	r3, [r4, #0]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80165b0:	2304      	movs	r3, #4
    hdma_sai1_b.Init.Direction = DMA_PERIPH_TO_MEMORY;
 80165b2:	60a6      	str	r6, [r4, #8]
    hdma_sai1_b.Init.PeriphInc = DMA_PINC_DISABLE;
 80165b4:	60e6      	str	r6, [r4, #12]
    hdma_sai1_b.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
 80165b6:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_b.Init.MemBurst = DMA_MBURST_SINGLE;
 80165b8:	62e6      	str	r6, [r4, #44]	; 0x2c
    hdma_sai1_b.Init.PeriphBurst = DMA_PBURST_SINGLE;
 80165ba:	6326      	str	r6, [r4, #48]	; 0x30
    hdma_sai1_b.Init.Request = DMA_REQUEST_SAI1_B;
 80165bc:	f8c4 e004 	str.w	lr, [r4, #4]
    hdma_sai1_b.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 80165c0:	e9c4 c004 	strd	ip, r0, [r4, #16]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
 80165c4:	4620      	mov	r0, r4
    hdma_sai1_b.Init.Mode = DMA_CIRCULAR;
 80165c6:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_b.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 80165ca:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_b) != HAL_OK)
 80165ce:	f7ec fa1b 	bl	8002a08 <HAL_DMA_Init>
 80165d2:	2800      	cmp	r0, #0
 80165d4:	d177      	bne.n	80166c6 <HAL_SAI_MspInit+0x19a>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_b);
 80165d6:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
 80165da:	63a5      	str	r5, [r4, #56]	; 0x38
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_b);
 80165dc:	f8c5 4080 	str.w	r4, [r5, #128]	; 0x80
}
 80165e0:	b008      	add	sp, #32
 80165e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (SAI1_client == 0)
 80165e6:	f240 540c 	movw	r4, #1292	; 0x50c
 80165ea:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80165ee:	6822      	ldr	r2, [r4, #0]
 80165f0:	2a00      	cmp	r2, #0
 80165f2:	d06e      	beq.n	80166d2 <HAL_SAI_MspInit+0x1a6>
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 80165f4:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80165f8:	2600      	movs	r6, #0
    SAI1_client ++;
 80165fa:	3201      	adds	r2, #1
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
 80165fc:	f04f 0c24 	mov.w	ip, #36	; 0x24
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8016600:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8016602:	2303      	movs	r3, #3
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8016604:	f04f 0806 	mov.w	r8, #6
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016608:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801660c:	a903      	add	r1, sp, #12
    SAI1_client ++;
 801660e:	6022      	str	r2, [r4, #0]
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_5;
 8016610:	f8cd c00c 	str.w	ip, [sp, #12]
    hdma_sai1_a.Instance = DMA1_Stream1;
 8016614:	f641 5440 	movw	r4, #7488	; 0x1d40
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8016618:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 801661a:	f8cd 801c 	str.w	r8, [sp, #28]
    hdma_sai1_a.Instance = DMA1_Stream1;
 801661e:	f2c2 0400 	movt	r4, #8192	; 0x2000
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8016622:	e9cd 7604 	strd	r7, r6, [sp, #16]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016626:	f7ef fc5d 	bl	8005ee4 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 801662a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
 801662e:	2350      	movs	r3, #80	; 0x50
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016630:	a903      	add	r1, sp, #12
 8016632:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8016636:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 8016638:	f8cd 801c 	str.w	r8, [sp, #28]
    hdma_sai1_a.Init.Request = DMA_REQUEST_SAI1_A;
 801663c:	f04f 0857 	mov.w	r8, #87	; 0x57
    GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_6;
 8016640:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8016642:	e9cd 6705 	strd	r6, r7, [sp, #20]
    HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 8016646:	f7ef fc4d 	bl	8005ee4 <HAL_GPIO_Init>
    hdma_sai1_a.Instance = DMA1_Stream1;
 801664a:	2328      	movs	r3, #40	; 0x28
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801664c:	2040      	movs	r0, #64	; 0x40
    hdma_sai1_a.Init.MemInc = DMA_MINC_ENABLE;
 801664e:	f44f 6e80 	mov.w	lr, #1024	; 0x400
    hdma_sai1_a.Instance = DMA1_Stream1;
 8016652:	f2c4 0302 	movt	r3, #16386	; 0x4002
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8016656:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    hdma_sai1_a.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
 801665a:	f44f 4780 	mov.w	r7, #16384	; 0x4000
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 801665e:	f44f 7180 	mov.w	r1, #256	; 0x100
    hdma_sai1_a.Init.Priority = DMA_PRIORITY_VERY_HIGH;
 8016662:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    hdma_sai1_a.Instance = DMA1_Stream1;
 8016666:	6023      	str	r3, [r4, #0]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8016668:	2304      	movs	r3, #4
    hdma_sai1_a.Init.PeriphInc = DMA_PINC_DISABLE;
 801666a:	60e6      	str	r6, [r4, #12]
    hdma_sai1_a.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
 801666c:	62a6      	str	r6, [r4, #40]	; 0x28
    hdma_sai1_a.Init.Direction = DMA_MEMORY_TO_PERIPH;
 801666e:	e9c4 8001 	strd	r8, r0, [r4, #4]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 8016672:	4620      	mov	r0, r4
    hdma_sai1_a.Init.PeriphBurst = DMA_PBURST_SINGLE;
 8016674:	e9c4 660b 	strd	r6, r6, [r4, #44]	; 0x2c
    hdma_sai1_a.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8016678:	e9c4 ec04 	strd	lr, ip, [r4, #16]
    hdma_sai1_a.Init.Mode = DMA_CIRCULAR;
 801667c:	e9c4 7106 	strd	r7, r1, [r4, #24]
    hdma_sai1_a.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
 8016680:	e9c4 2308 	strd	r2, r3, [r4, #32]
    if (HAL_DMA_Init(&hdma_sai1_a) != HAL_OK)
 8016684:	f7ec f9c0 	bl	8002a08 <HAL_DMA_Init>
 8016688:	bb00      	cbnz	r0, 80166cc <HAL_SAI_MspInit+0x1a0>
    __HAL_LINKDMA(hsai,hdmarx,hdma_sai1_a);
 801668a:	63a5      	str	r5, [r4, #56]	; 0x38
 801668c:	682b      	ldr	r3, [r5, #0]
    __HAL_LINKDMA(hsai,hdmatx,hdma_sai1_a);
 801668e:	e9c5 4420 	strd	r4, r4, [r5, #128]	; 0x80
 8016692:	e756      	b.n	8016542 <HAL_SAI_MspInit+0x16>
       __HAL_RCC_SAI1_CLK_ENABLE();
 8016694:	f44f 4388 	mov.w	r3, #17408	; 0x4400
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 8016698:	2102      	movs	r1, #2
 801669a:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
 801669c:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80166a0:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
 80166a4:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
 80166a8:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
 80166ac:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80166b0:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80166b4:	9302      	str	r3, [sp, #8]
 80166b6:	9b02      	ldr	r3, [sp, #8]
      HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 80166b8:	f7eb ff82 	bl	80025c0 <HAL_NVIC_SetPriority>
      HAL_NVIC_EnableIRQ(SAI1_IRQn);
 80166bc:	2057      	movs	r0, #87	; 0x57
 80166be:	f7eb ffcf 	bl	8002660 <HAL_NVIC_EnableIRQ>
 80166c2:	6822      	ldr	r2, [r4, #0]
 80166c4:	e74e      	b.n	8016564 <HAL_SAI_MspInit+0x38>
      Error_Handler();
 80166c6:	f7ff f8cd 	bl	8015864 <Error_Handler>
 80166ca:	e784      	b.n	80165d6 <HAL_SAI_MspInit+0xaa>
      Error_Handler();
 80166cc:	f7ff f8ca 	bl	8015864 <Error_Handler>
 80166d0:	e7db      	b.n	801668a <HAL_SAI_MspInit+0x15e>
       __HAL_RCC_SAI1_CLK_ENABLE();
 80166d2:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 80166d6:	2102      	movs	r1, #2
 80166d8:	2057      	movs	r0, #87	; 0x57
       __HAL_RCC_SAI1_CLK_ENABLE();
 80166da:	f6c5 0302 	movt	r3, #22530	; 0x5802
 80166de:	f8d3 60f0 	ldr.w	r6, [r3, #240]	; 0xf0
 80166e2:	f446 0680 	orr.w	r6, r6, #4194304	; 0x400000
 80166e6:	f8c3 60f0 	str.w	r6, [r3, #240]	; 0xf0
 80166ea:	f8d3 30f0 	ldr.w	r3, [r3, #240]	; 0xf0
 80166ee:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 80166f2:	9301      	str	r3, [sp, #4]
 80166f4:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(SAI1_IRQn, 2, 0);
 80166f6:	f7eb ff63 	bl	80025c0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(SAI1_IRQn);
 80166fa:	2057      	movs	r0, #87	; 0x57
 80166fc:	f7eb ffb0 	bl	8002660 <HAL_NVIC_EnableIRQ>
 8016700:	6822      	ldr	r2, [r4, #0]
 8016702:	e777      	b.n	80165f4 <HAL_SAI_MspInit+0xc8>

08016704 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8016704:	b538      	push	{r3, r4, r5, lr}
Stat = STA_NOINIT;  
 8016706:	f240 0438 	movw	r4, #56	; 0x38
 801670a:	2501      	movs	r5, #1
 801670c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8016710:	7025      	strb	r5, [r4, #0]

#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
 8016712:	f7fc fed9 	bl	80134c8 <BSP_SD_Init>
 8016716:	b108      	cbz	r0, 801671c <SD_initialize+0x18>

#else
  Stat = SD_CheckStatus(lun);
#endif

  return Stat;
 8016718:	7820      	ldrb	r0, [r4, #0]
}
 801671a:	bd38      	pop	{r3, r4, r5, pc}
  Stat = STA_NOINIT;
 801671c:	7025      	strb	r5, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 801671e:	f7fc feaf 	bl	8013480 <BSP_SD_GetCardState>
 8016722:	b918      	cbnz	r0, 801672c <SD_initialize+0x28>
    Stat &= ~STA_NOINIT;
 8016724:	7823      	ldrb	r3, [r4, #0]
 8016726:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 801672a:	7023      	strb	r3, [r4, #0]
  return Stat;
 801672c:	7823      	ldrb	r3, [r4, #0]
 801672e:	b2db      	uxtb	r3, r3
    Stat = SD_CheckStatus(lun);
 8016730:	7023      	strb	r3, [r4, #0]
  return Stat;
 8016732:	7820      	ldrb	r0, [r4, #0]
}
 8016734:	bd38      	pop	{r3, r4, r5, pc}
 8016736:	bf00      	nop

08016738 <SD_status>:
  * @brief  Gets Disk Status
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
 8016738:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 801673a:	f240 0438 	movw	r4, #56	; 0x38
 801673e:	2301      	movs	r3, #1
 8016740:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8016744:	7023      	strb	r3, [r4, #0]
  if(BSP_SD_GetCardState() == MSD_OK)
 8016746:	f7fc fe9b 	bl	8013480 <BSP_SD_GetCardState>
 801674a:	b918      	cbnz	r0, 8016754 <SD_status+0x1c>
    Stat &= ~STA_NOINIT;
 801674c:	7823      	ldrb	r3, [r4, #0]
 801674e:	f003 03fe 	and.w	r3, r3, #254	; 0xfe
 8016752:	7023      	strb	r3, [r4, #0]
  return Stat;
 8016754:	7820      	ldrb	r0, [r4, #0]
  return SD_CheckStatus(lun);
}
 8016756:	bd10      	pop	{r4, pc}

08016758 <SD_read>:
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
              
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8016758:	b508      	push	{r3, lr}
 801675a:	4608      	mov	r0, r1
 801675c:	4611      	mov	r1, r2
 801675e:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
 8016760:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8016764:	f7fc fe68 	bl	8013438 <BSP_SD_ReadBlocks>
 8016768:	b920      	cbnz	r0, 8016774 <SD_read+0x1c>
                       (uint32_t) (sector),
                       count, SD_TIMEOUT) == MSD_OK)
  {
    /* wait until the read operation is finished */
    while(BSP_SD_GetCardState()!= MSD_OK)
 801676a:	f7fc fe89 	bl	8013480 <BSP_SD_GetCardState>
 801676e:	2800      	cmp	r0, #0
 8016770:	d1fb      	bne.n	801676a <SD_read+0x12>
    }
    res = RES_OK;
  }

  return res;
}
 8016772:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 8016774:	2001      	movs	r0, #1
}
 8016776:	bd08      	pop	{r3, pc}

08016778 <SD_ioctl>:
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8016778:	f240 0338 	movw	r3, #56	; 0x38
 801677c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8016780:	781b      	ldrb	r3, [r3, #0]
 8016782:	07db      	lsls	r3, r3, #31
 8016784:	d408      	bmi.n	8016798 <SD_ioctl+0x20>
{
 8016786:	b510      	push	{r4, lr}
 8016788:	4614      	mov	r4, r2
 801678a:	b08a      	sub	sp, #40	; 0x28

  switch (cmd)
 801678c:	2903      	cmp	r1, #3
 801678e:	d821      	bhi.n	80167d4 <SD_ioctl+0x5c>
 8016790:	e8df f001 	tbb	[pc, r1]
 8016794:	170f0704 	.word	0x170f0704
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8016798:	2003      	movs	r0, #3
  default:
    res = RES_PARERR;
  }

  return res;
}
 801679a:	4770      	bx	lr
    res = RES_OK;
 801679c:	2000      	movs	r0, #0
}
 801679e:	b00a      	add	sp, #40	; 0x28
 80167a0:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80167a2:	a801      	add	r0, sp, #4
 80167a4:	f7fc fe78 	bl	8013498 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80167a8:	9b07      	ldr	r3, [sp, #28]
    res = RES_OK;
 80167aa:	2000      	movs	r0, #0
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 80167ac:	6023      	str	r3, [r4, #0]
}
 80167ae:	b00a      	add	sp, #40	; 0x28
 80167b0:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80167b2:	a801      	add	r0, sp, #4
 80167b4:	f7fc fe70 	bl	8013498 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 80167b8:	9b08      	ldr	r3, [sp, #32]
    res = RES_OK;
 80167ba:	2000      	movs	r0, #0
    *(WORD*)buff = CardInfo.LogBlockSize;
 80167bc:	8023      	strh	r3, [r4, #0]
}
 80167be:	b00a      	add	sp, #40	; 0x28
 80167c0:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 80167c2:	a801      	add	r0, sp, #4
 80167c4:	f7fc fe68 	bl	8013498 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 80167c8:	9b08      	ldr	r3, [sp, #32]
 80167ca:	2000      	movs	r0, #0
 80167cc:	0a5b      	lsrs	r3, r3, #9
 80167ce:	6023      	str	r3, [r4, #0]
}
 80167d0:	b00a      	add	sp, #40	; 0x28
 80167d2:	bd10      	pop	{r4, pc}
    res = RES_PARERR;
 80167d4:	2004      	movs	r0, #4
}
 80167d6:	b00a      	add	sp, #40	; 0x28
 80167d8:	bd10      	pop	{r4, pc}
 80167da:	bf00      	nop

080167dc <SD_write>:
{
 80167dc:	b508      	push	{r3, lr}
 80167de:	4608      	mov	r0, r1
 80167e0:	4611      	mov	r1, r2
 80167e2:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
 80167e4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80167e8:	f7fc fe38 	bl	801345c <BSP_SD_WriteBlocks>
 80167ec:	b920      	cbnz	r0, 80167f8 <SD_write+0x1c>
    while(BSP_SD_GetCardState()!= MSD_OK)
 80167ee:	f7fc fe47 	bl	8013480 <BSP_SD_GetCardState>
 80167f2:	2800      	cmp	r0, #0
 80167f4:	d1fb      	bne.n	80167ee <SD_write+0x12>
}
 80167f6:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 80167f8:	2001      	movs	r0, #1
}
 80167fa:	bd08      	pop	{r3, pc}

080167fc <MX_SDMMC1_SD_Init>:
/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{

  hsd1.Instance = SDMMC1;
 80167fc:	f641 63c8 	movw	r3, #7880	; 0x1ec8
 8016800:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
  hsd1.Init.ClockDiv = 0;
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
 8016804:	2001      	movs	r0, #1
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 8016806:	2200      	movs	r2, #0
  hsd1.Instance = SDMMC1;
 8016808:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801680c:	f2c5 2100 	movt	r1, #20992	; 0x5200
{
 8016810:	b410      	push	{r4}
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 8016812:	f44f 4480 	mov.w	r4, #16384	; 0x4000
  hsd1.Instance = SDMMC1;
 8016816:	6019      	str	r1, [r3, #0]
  hsd1.Init.TranceiverPresent = SDMMC_TRANSCEIVER_NOT_PRESENT;
 8016818:	6198      	str	r0, [r3, #24]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
 801681a:	60dc      	str	r4, [r3, #12]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 801681c:	e9c3 2201 	strd	r2, r2, [r3, #4]
  hsd1.Init.ClockDiv = 0;
 8016820:	e9c3 2204 	strd	r2, r2, [r3, #16]

}
 8016824:	f85d 4b04 	ldr.w	r4, [sp], #4
 8016828:	4770      	bx	lr
 801682a:	bf00      	nop

0801682c <HAL_SD_MspInit>:

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(sdHandle->Instance==SDMMC1)
 801682c:	f44f 43e0 	mov.w	r3, #28672	; 0x7000
{
 8016830:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if(sdHandle->Instance==SDMMC1)
 8016834:	f2c5 2300 	movt	r3, #20992	; 0x5200
 8016838:	6802      	ldr	r2, [r0, #0]
{
 801683a:	b088      	sub	sp, #32
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801683c:	2400      	movs	r4, #0
  if(sdHandle->Instance==SDMMC1)
 801683e:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8016840:	9407      	str	r4, [sp, #28]
 8016842:	e9cd 4403 	strd	r4, r4, [sp, #12]
 8016846:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(sdHandle->Instance==SDMMC1)
 801684a:	d002      	beq.n	8016852 <HAL_SD_MspInit+0x26>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
 801684c:	b008      	add	sp, #32
 801684e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8016852:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 8016856:	250c      	movs	r5, #12
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 8016858:	f44f 6170 	mov.w	r1, #3840	; 0xf00
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 801685c:	f44f 6000 	mov.w	r0, #2048	; 0x800
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8016860:	f6c5 0302 	movt	r3, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8016864:	2702      	movs	r7, #2
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8016866:	2603      	movs	r6, #3
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8016868:	f04f 0801 	mov.w	r8, #1
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 801686c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8016870:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8016874:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8016878:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
 801687c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 8016880:	f402 3280 	and.w	r2, r2, #65536	; 0x10000
 8016884:	9200      	str	r2, [sp, #0]
 8016886:	9a00      	ldr	r2, [sp, #0]
    __HAL_RCC_GPIOC_CLK_ENABLE();
 8016888:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801688c:	f042 0204 	orr.w	r2, r2, #4
 8016890:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8016894:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8016898:	f002 0204 	and.w	r2, r2, #4
 801689c:	9201      	str	r2, [sp, #4]
 801689e:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80168a0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80168a4:	f042 0208 	orr.w	r2, r2, #8
 80168a8:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80168ac:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 80168b0:	9103      	str	r1, [sp, #12]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80168b2:	eb0d 0105 	add.w	r1, sp, r5
    __HAL_RCC_GPIOD_CLK_ENABLE();
 80168b6:	f003 0308 	and.w	r3, r3, #8
 80168ba:	9302      	str	r3, [sp, #8]
 80168bc:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 80168be:	e9cd 7804 	strd	r7, r8, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 80168c2:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80168c6:	f7ef fb0d 	bl	8005ee4 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80168ca:	f44f 6000 	mov.w	r0, #2048	; 0x800
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80168ce:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80168d2:	eb0d 0105 	add.w	r1, sp, r5
 80168d6:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80168da:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Pin = GPIO_PIN_12;
 80168dc:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80168de:	9405      	str	r4, [sp, #20]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 80168e0:	e9cd 6506 	strd	r6, r5, [sp, #24]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80168e4:	f7ef fafe 	bl	8005ee4 <HAL_GPIO_Init>
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80168e8:	f44f 6040 	mov.w	r0, #3072	; 0xc00
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80168ec:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 80168ee:	eb0d 0105 	add.w	r1, sp, r5
 80168f2:	f6c5 0002 	movt	r0, #22530	; 0x5802
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80168f6:	9704      	str	r7, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;
 80168f8:	9507      	str	r5, [sp, #28]
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 80168fa:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80168fc:	e9cd 8605 	strd	r8, r6, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8016900:	f7ef faf0 	bl	8005ee4 <HAL_GPIO_Init>
}
 8016904:	b008      	add	sp, #32
 8016906:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 801690a:	bf00      	nop

0801690c <initGlobalSFXObjects>:
        void calculateNoteArray()
        {
            for (int i = 0; i < 128; i++)
            {
                float tempNote = i;
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801690c:	f240 6354 	movw	r3, #1620	; 0x654
            for (int i = 0; i < 128; i++)
 8016910:	2000      	movs	r0, #0
        {
 8016912:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8016916:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801691a:	f642 2448 	movw	r4, #10824	; 0x2a48
 801691e:	f240 6520 	movw	r5, #1568	; 0x620
 8016922:	f64a 26ab 	movw	r6, #43691	; 0xaaab
        {
 8016926:	b083      	sub	sp, #12
 8016928:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801692c:	f2c2 0500 	movt	r5, #8192	; 0x2000
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8016930:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
 8016934:	781f      	ldrb	r7, [r3, #0]
                float tempNote = i;
 8016936:	ee07 0a90 	vmov	s15, r0
            for (int i = 0; i < 128; i++)
 801693a:	3001      	adds	r0, #1
                float tempNote = i;
 801693c:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 8016940:	2880      	cmp	r0, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8016942:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8016946:	ee17 3a90 	vmov	r3, s15
 801694a:	eba3 0307 	sub.w	r3, r3, r7
 801694e:	fb86 2103 	smull	r2, r1, r6, r3
 8016952:	ea4f 72e3 	mov.w	r2, r3, asr #31
 8016956:	ebc2 0261 	rsb	r2, r2, r1, asr #1
 801695a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801695e:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8016962:	ee07 3a90 	vmov	s15, r3
 8016966:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801696a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801696e:	ee17 3a90 	vmov	r3, s15
 8016972:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8016976:	edd3 7a00 	vldr	s15, [r3]
 801697a:	ee37 7a87 	vadd.f32	s14, s15, s14
                notes[i] = tunedNote;
 801697e:	eca4 7a01 	vstmia	r4!, {s14}
            for (int i = 0; i < 128; i++)
 8016982:	d1d8      	bne.n	8016936 <initGlobalSFXObjects+0x2a>
 8016984:	f647 141c 	movw	r4, #31004	; 0x791c
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
 8016988:	f24d 770a 	movw	r7, #55050	; 0xd70a
 801698c:	f248 26f8 	movw	r6, #33528	; 0x82f8
            tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
 8016990:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016994:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8016998:	f247 5020 	movw	r0, #29984	; 0x7520
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
 801699c:	2500      	movs	r5, #0
 801699e:	f6c3 47a3 	movt	r7, #15523	; 0x3ca3
 80169a2:	f104 0820 	add.w	r8, r4, #32
 80169a6:	f2c2 0601 	movt	r6, #8193	; 0x2001
            tSimplePoly_initToPool(&poly, NUM_VOC_VOICES, &smallPool);
 80169aa:	2108      	movs	r1, #8
 80169ac:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80169b0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80169b4:	f011 fbac 	bl	8028110 <tSimplePoly_initToPool>
                tExpSmooth_initToPool(&polyRamp[i], 0.0f, 0.02f, &smallPool);
 80169b8:	f24d 730a 	movw	r3, #55050	; 0xd70a
 80169bc:	2200      	movs	r2, #0
 80169be:	4620      	mov	r0, r4
 80169c0:	3404      	adds	r4, #4
 80169c2:	f6c3 43a3 	movt	r3, #15523	; 0x3ca3
 80169c6:	ee00 2a10 	vmov	s0, r2
 80169ca:	4631      	mov	r1, r6
 80169cc:	ee00 3a90 	vmov	s1, r3
 80169d0:	f00f faa2 	bl	8025f18 <tExpSmooth_initToPool>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80169d4:	45a0      	cmp	r8, r4
 80169d6:	d1ef      	bne.n	80169b8 <initGlobalSFXObjects+0xac>
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 80169d8:	f24d 730a 	movw	r3, #55050	; 0xd70a
 80169dc:	f247 205c 	movw	r0, #29276	; 0x725c
 80169e0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
 80169e4:	f649 189a 	movw	r8, #39322	; 0x999a
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 80169e8:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 80169ec:	f2c2 0001 	movt	r0, #8193	; 0x2001
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
 80169f0:	f24f 5ac3 	movw	sl, #62915	; 0xf5c3
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
 80169f4:	f243 3933 	movw	r9, #13107	; 0x3333
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 80169f8:	ee00 3a90 	vmov	s1, r3
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 80169fc:	f246 6666 	movw	r6, #26214	; 0x6666
            tExpSmooth_init(&comp, 1.0f, 0.01f);
 8016a00:	f00f fa60 	bl	8025ec4 <tExpSmooth_init>
            LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
 8016a04:	2300      	movs	r3, #0
 8016a06:	f24b 7217 	movw	r2, #46871	; 0xb717
 8016a0a:	f247 0044 	movw	r0, #28740	; 0x7044
 8016a0e:	4619      	mov	r1, r3
 8016a10:	f2c4 437a 	movt	r3, #17530	; 0x447a
 8016a14:	f6cb 2251 	movt	r2, #47697	; 0xba51
 8016a18:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016a1c:	ee01 1a10 	vmov	s2, r1
 8016a20:	ee00 3a10 	vmov	s0, r3
 8016a24:	ee01 2a90 	vmov	s3, r2
 8016a28:	2180      	movs	r1, #128	; 0x80
 8016a2a:	eeff 0a00 	vmov.f32	s1, #240	; 0xbf800000 -1.0
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
 8016a2e:	f6c3 7a28 	movt	sl, #16168	; 0x3f28
            LEAF_generate_exp(expBuffer, 1000.0f, -1.0f, 0.0f, -0.0008f, EXP_BUFFER_SIZE); //exponential buffer rising from 0 to 1
 8016a32:	f011 f837 	bl	8027aa4 <LEAF_generate_exp>
            LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
 8016a36:	f24b 7217 	movw	r2, #46871	; 0xb717
 8016a3a:	f241 236f 	movw	r3, #4719	; 0x126f
 8016a3e:	2100      	movs	r1, #0
 8016a40:	f6cb 2251 	movt	r2, #47697	; 0xba51
 8016a44:	f647 103c 	movw	r0, #31036	; 0x793c
 8016a48:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 8016a4c:	ee00 1a90 	vmov	s1, r1
 8016a50:	ee01 2a90 	vmov	s3, r2
 8016a54:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016a58:	ee00 3a10 	vmov	s0, r3
 8016a5c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8016a60:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
 8016a64:	f6c3 7973 	movt	r9, #16243	; 0x3f73
            LEAF_generate_exp(decayExpBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, DECAY_EXP_BUFFER_SIZE); // exponential decay buffer falling from 1 to 0
 8016a68:	f011 f81c 	bl	8027aa4 <LEAF_generate_exp>
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 8016a6c:	f64c 40cd 	movw	r0, #52429	; 0xcccd
 8016a70:	f641 7368 	movw	r3, #8040	; 0x1f68
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
 8016a74:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
 8016a78:	4684      	mov	ip, r0
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
 8016a7a:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
 8016a7e:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 8016a82:	f2c2 0300 	movt	r3, #8192	; 0x2000
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
 8016a86:	f6c3 6c4c 	movt	ip, #15948	; 0x3e4c
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
 8016a8a:	4602      	mov	r2, r0
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8016a8c:	4641      	mov	r1, r8
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 8016a8e:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
 8016a92:	f6c3 7859 	movt	r8, #16217	; 0x3f59
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
 8016a96:	eeb6 6a08 	vmov.f32	s12, #104	; 0x3f400000  0.750
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
 8016a9a:	f6c3 52cc 	movt	r2, #15820	; 0x3dcc
            defaultPresetKnobValues[Vocoder][0] = 0.4f; // volume
 8016a9e:	6018      	str	r0, [r3, #0]
            defaultPresetKnobValues[VocoderCh][0] = 0.4f; // volume
 8016aa0:	6658      	str	r0, [r3, #100]	; 0x64
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8016aa2:	f6c3 6199 	movt	r1, #16025	; 0x3e99
            defaultPresetKnobValues[Vocoder][5] = 0.02f; // breathiness
 8016aa6:	615f      	str	r7, [r3, #20]
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8016aa8:	f6c3 7666 	movt	r6, #16230	; 0x3f66
            defaultPresetKnobValues[VocoderCh][9] = 0.66f; // envelope speed
 8016aac:	f8c3 a088 	str.w	sl, [r3, #136]	; 0x88
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8016ab0:	f64c 4ecd 	movw	lr, #52429	; 0xcccd
            defaultPresetKnobValues[Vocoder][2] = 0.85f; // quality
 8016ab4:	f8c3 8008 	str.w	r8, [r3, #8]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8016ab8:	f24c 2b8f 	movw	fp, #49807	; 0xc28f
            defaultPresetKnobValues[Vocoder][4] = 0.2f; // noise threshold
 8016abc:	f8c3 c010 	str.w	ip, [r3, #16]
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8016ac0:	f6c3 7e4c 	movt	lr, #16204	; 0x3f4c
            defaultPresetKnobValues[VocoderCh][4] = 0.2f; //noise thresh
 8016ac4:	f8c3 c074 	str.w	ip, [r3, #116]	; 0x74
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8016ac8:	f6c3 5b75 	movt	fp, #15733	; 0x3d75
            defaultPresetKnobValues[Pitchshift][5] = 0.25f; //offset
 8016acc:	ed83 7a37 	vstr	s14, [r3, #220]	; 0xdc
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8016ad0:	f64c 47cd 	movw	r7, #52429	; 0xcccd
            defaultPresetKnobValues[Pitchshift][6] = 0.25f;
 8016ad4:	ed83 7a38 	vstr	s14, [r3, #224]	; 0xe0
 8016ad8:	f642 5410 	movw	r4, #11536	; 0x2d10
            defaultPresetKnobValues[Vocoder][3] = 0.0f; // sawToPulse
 8016adc:	60dd      	str	r5, [r3, #12]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8016ade:	f6c3 574c 	movt	r7, #15692	; 0x3d4c
            defaultPresetKnobValues[Vocoder][9] = 0.0f;
 8016ae2:	625d      	str	r5, [r3, #36]	; 0x24
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8016ae4:	f643 3acd 	movw	sl, #15309	; 0x3bcd
            defaultPresetKnobValues[VocoderCh][5] = 0.0f;// saw->pulse fade
 8016ae8:	679d      	str	r5, [r3, #120]	; 0x78
 8016aea:	f2c2 0400 	movt	r4, #8192	; 0x2000
            defaultPresetKnobValues[VocoderCh][8] = 0.0f; // breathiness
 8016aee:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8016af2:	f6c3 5ace 	movt	sl, #15822	; 0x3dce
            defaultPresetKnobValues[VocoderCh][13] = 0.0f; // stereo
 8016af6:	f8c3 5098 	str.w	r5, [r3, #152]	; 0x98
            defaultPresetKnobValues[VocoderCh][14] = 0.0f; // barkpull
 8016afa:	f8c3 509c 	str.w	r5, [r3, #156]	; 0x9c
            defaultPresetKnobValues[Pitchshift][2] = 0.0f; // f amount
 8016afe:	f8c3 50d0 	str.w	r5, [r3, #208]	; 0xd0
            defaultPresetKnobValues[Vocoder][1] = 0.5f; // warp factor
 8016b02:	edc3 7a01 	vstr	s15, [r3, #4]
            defaultPresetKnobValues[Vocoder][6] = 0.5f; // tilt
 8016b06:	edc3 7a06 	vstr	s15, [r3, #24]
            defaultPresetKnobValues[Vocoder][7] = 0.5f; // pulse width
 8016b0a:	edc3 7a07 	vstr	s15, [r3, #28]
            defaultPresetKnobValues[Vocoder][8] = 0.5f; // pulse shape
 8016b0e:	edc3 7a08 	vstr	s15, [r3, #32]
            defaultPresetKnobValues[VocoderCh][1] = 0.5f; // warp factor
 8016b12:	edc3 7a1a 	vstr	s15, [r3, #104]	; 0x68
            defaultPresetKnobValues[VocoderCh][3] = 0.5f; //band width
 8016b16:	edc3 7a1c 	vstr	s15, [r3, #112]	; 0x70
            defaultPresetKnobValues[VocoderCh][6] = 0.5f; // pulse length
 8016b1a:	edc3 7a1f 	vstr	s15, [r3, #124]	; 0x7c
            defaultPresetKnobValues[VocoderCh][7] = 0.5f; // pulse width
 8016b1e:	edc3 7a20 	vstr	s15, [r3, #128]	; 0x80
            defaultPresetKnobValues[VocoderCh][10] = 0.5f;// squish
 8016b22:	edc3 7a23 	vstr	s15, [r3, #140]	; 0x8c
            defaultPresetKnobValues[VocoderCh][11] = 0.5f; // offset
 8016b26:	edc3 7a24 	vstr	s15, [r3, #144]	; 0x90
            defaultPresetKnobValues[VocoderCh][12] = 0.5f; // tilt
 8016b2a:	edc3 7a25 	vstr	s15, [r3, #148]	; 0x94
            defaultPresetKnobValues[Pitchshift][0] = 0.5f; // pitch
 8016b2e:	edc3 7a32 	vstr	s15, [r3, #200]	; 0xc8
            defaultPresetKnobValues[Pitchshift][1] = 0.5f; // fine pitch
 8016b32:	edc3 7a33 	vstr	s15, [r3, #204]	; 0xcc
            defaultPresetKnobValues[Pitchshift][3] = 0.5f; // formant
 8016b36:	edc3 7a35 	vstr	s15, [r3, #212]	; 0xd4
            defaultPresetKnobValues[Pitchshift][4] = 0.5f; //range
 8016b3a:	edc3 7a36 	vstr	s15, [r3, #216]	; 0xd8
            defaultPresetKnobValues[VocoderCh][2] = 1.0f; // quality
 8016b3e:	edc3 6a1b 	vstr	s13, [r3, #108]	; 0x6c
            defaultPresetKnobValues[Pitchshift][7] = 0.25f;
 8016b42:	ed83 7a39 	vstr	s14, [r3, #228]	; 0xe4
            defaultPresetKnobValues[SamplerAutoGrab][0] = 0.95f; // thresh
 8016b46:	f8c3 92bc 	str.w	r9, [r3, #700]	; 0x2bc
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
 8016b4a:	f203 5914 	addw	r9, r3, #1300	; 0x514
            defaultPresetKnobValues[SamplerButtonPress][4] = 0.4f;//crossfade
 8016b4e:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
            defaultPresetKnobValues[SamplerKeyboard][5] = 0.4f;//crossfade
 8016b52:	f8c3 026c 	str.w	r0, [r3, #620]	; 0x26c
            defaultPresetKnobValues[Pitchshift][8] = 0.25f;
 8016b56:	ed83 7a3a 	vstr	s14, [r3, #232]	; 0xe8
            defaultPresetKnobValues[Pitchshift][9] = 0.25f;
 8016b5a:	ed83 7a3b 	vstr	s14, [r3, #236]	; 0xec
            defaultPresetKnobValues[AutotuneMono][4] = 0.25f; // hysteresis
 8016b5e:	ed83 7a4f 	vstr	s14, [r3, #316]	; 0x13c
            defaultPresetKnobValues[SamplerAutoGrab][3] = 0.25f; // crossfade
 8016b62:	ed83 7ab2 	vstr	s14, [r3, #712]	; 0x2c8
            defaultPresetKnobValues[AutotunePoly][2] = 0.1f;
 8016b66:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
            defaultPresetKnobValues[AutotuneMono][0] = 0.0f; // pickiness
 8016b6a:	f8c3 512c 	str.w	r5, [r3, #300]	; 0x12c
            defaultPresetKnobValues[AutotuneMono][1] = 1.0f; // amount
 8016b6e:	edc3 6a4c 	vstr	s13, [r3, #304]	; 0x130
            defaultPresetKnobValues[AutotuneMono][2] = 0.5f; // speed
 8016b72:	edc3 7a4d 	vstr	s15, [r3, #308]	; 0x134
            defaultPresetKnobValues[AutotuneMono][3] = 1.0f; // leap allow
 8016b76:	edc3 6a4e 	vstr	s13, [r3, #312]	; 0x138
            defaultPresetKnobValues[AutotunePoly][0] = 1.0f; // fidelity thresh
 8016b7a:	edc3 6a64 	vstr	s13, [r3, #400]	; 0x190
            defaultPresetKnobValues[AutotunePoly][1] = 0.5f;
 8016b7e:	edc3 7a65 	vstr	s15, [r3, #404]	; 0x194
            defaultPresetKnobValues[AutotunePoly][3] = 0.0f;
 8016b82:	f8c3 519c 	str.w	r5, [r3, #412]	; 0x19c
            defaultPresetKnobValues[AutotunePoly][4] = 0.0f;
 8016b86:	f8c3 51a0 	str.w	r5, [r3, #416]	; 0x1a0
            defaultPresetKnobValues[SamplerButtonPress][0] = 0.0f; // start
 8016b8a:	f8c3 51f4 	str.w	r5, [r3, #500]	; 0x1f4
            defaultPresetKnobValues[SamplerButtonPress][1] = 1.0f; // end
 8016b8e:	edc3 6a7e 	vstr	s13, [r3, #504]	; 0x1f8
            defaultPresetKnobValues[SamplerButtonPress][3] = 0.5f; // speed mult
 8016b92:	edc3 7a80 	vstr	s15, [r3, #512]	; 0x200
            defaultPresetKnobValues[SamplerKeyboard][0] = 0.0f; // start
 8016b96:	f8c3 5258 	str.w	r5, [r3, #600]	; 0x258
            defaultPresetKnobValues[SamplerKeyboard][1] = 1.0f; // end
 8016b9a:	edc3 6a97 	vstr	s13, [r3, #604]	; 0x25c
            defaultPresetKnobValues[SamplerKeyboard][3] = 0.5f; // speed mult
 8016b9e:	edc3 7a99 	vstr	s15, [r3, #612]	; 0x264
            defaultPresetKnobValues[SamplerKeyboard][4] = 0.0f; //looping on
 8016ba2:	f8c3 5268 	str.w	r5, [r3, #616]	; 0x268
            defaultPresetKnobValues[SamplerKeyboard][6] = 0.0f;//velocity sensitivity
 8016ba6:	f8c3 5270 	str.w	r5, [r3, #624]	; 0x270
            defaultPresetKnobValues[SamplerAutoGrab][1] = 0.5f; // window
 8016baa:	edc3 7ab0 	vstr	s15, [r3, #704]	; 0x2c0
            defaultPresetKnobValues[SamplerAutoGrab][4] = 0.0f;
 8016bae:	f8c3 52cc 	str.w	r5, [r3, #716]	; 0x2cc
            defaultPresetKnobValues[SamplerAutoGrab][5] = 0.0f; // len rand
 8016bb2:	f8c3 52d0 	str.w	r5, [r3, #720]	; 0x2d0
            defaultPresetKnobValues[SamplerAutoGrab][6] = 0.0f; // speed rand
 8016bb6:	f8c3 52d4 	str.w	r5, [r3, #724]	; 0x2d4
            defaultPresetKnobValues[SamplerAutoGrab][7] = 0.0f;
 8016bba:	f8c3 52d8 	str.w	r5, [r3, #728]	; 0x2d8
            defaultPresetKnobValues[SamplerButtonPress][2] = 0.75f; // speed
 8016bbe:	ed83 6a7f 	vstr	s12, [r3, #508]	; 0x1fc
            defaultPresetKnobValues[SamplerKeyboard][2] = 0.75f; // speed
 8016bc2:	ed83 6a98 	vstr	s12, [r3, #608]	; 0x260
            defaultPresetKnobValues[SamplerAutoGrab][2] = 0.75f; // speed
 8016bc6:	ed83 6ab1 	vstr	s12, [r3, #708]	; 0x2c4
            defaultPresetKnobValues[SamplerAutoGrab][8] = 0.0f;
 8016bca:	f8c3 52dc 	str.w	r5, [r3, #732]	; 0x2dc
            defaultPresetKnobValues[Reverb2][0] = 0.2f; // size
 8016bce:	f8c9 c000 	str.w	ip, [r9]
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8016bd2:	f649 199a 	movw	r9, #39322	; 0x999a
            defaultPresetKnobValues[Wavefolder][0] = 0.4f; // gain
 8016bd6:	f8c3 0384 	str.w	r0, [r3, #900]	; 0x384
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8016bda:	f6c3 7919 	movt	r9, #16153	; 0x3f19
            defaultPresetKnobValues[BitCrusher][0] = 0.1f; // quality
 8016bde:	f8c3 23e8 	str.w	r2, [r3, #1000]	; 0x3e8
            defaultPresetKnobValues[Distortion][0] = .25f; // pre gain
 8016be2:	ed83 7ac8 	vstr	s14, [r3, #800]	; 0x320
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8016be6:	f8cd 9004 	str.w	r9, [sp, #4]
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
 8016bea:	f203 494c 	addw	r9, r3, #1100	; 0x44c
            defaultPresetKnobValues[Distortion][4] = 0.25f; //post gain
 8016bee:	ed83 7acc 	vstr	s14, [r3, #816]	; 0x330
            defaultPresetKnobValues[Delay][0] = 0.25f; // delayL
 8016bf2:	ed89 7a00 	vstr	s14, [r9]
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
 8016bf6:	f503 698a 	add.w	r9, r3, #1104	; 0x450
            defaultPresetKnobValues[SamplerAutoGrab][9] = 0.0f;
 8016bfa:	f8c3 52e0 	str.w	r5, [r3, #736]	; 0x2e0
            defaultPresetKnobValues[Delay][1] = 0.25f; // delayR
 8016bfe:	ed89 7a00 	vstr	s14, [r9]
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
 8016c02:	f503 698b 	add.w	r9, r3, #1112	; 0x458
            defaultPresetKnobValues[Distortion][1] = 0.5f; // tilt (low and high shelves, opposing gains)
 8016c06:	edc3 7ac9 	vstr	s15, [r3, #804]	; 0x324
            defaultPresetKnobValues[Delay][3] = 1.0f; // lowpass
 8016c0a:	edc9 6a00 	vstr	s13, [r9]
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
 8016c0e:	f203 495c 	addw	r9, r3, #1116	; 0x45c
            defaultPresetKnobValues[Distortion][2] = 0.5f; // mid gain
 8016c12:	edc3 7aca 	vstr	s15, [r3, #808]	; 0x328
            defaultPresetKnobValues[Delay][4] = 0.5f; // feedback
 8016c16:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
 8016c1a:	f503 698c 	add.w	r9, r3, #1120	; 0x460
            defaultPresetKnobValues[Distortion][3] = 0.5f; // mid freq
 8016c1e:	edc3 7acb 	vstr	s15, [r3, #812]	; 0x32c
            defaultPresetKnobValues[Delay][5] = 1.0f; // post gain
 8016c22:	edc9 6a00 	vstr	s13, [r9]
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
 8016c26:	f503 6996 	add.w	r9, r3, #1200	; 0x4b0
            defaultPresetKnobValues[Wavefolder][1] = 0.5f; // offset1
 8016c2a:	edc3 7ae2 	vstr	s15, [r3, #904]	; 0x388
            defaultPresetKnobValues[Reverb][0] = 0.5f; // size
 8016c2e:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
 8016c32:	f203 49b4 	addw	r9, r3, #1204	; 0x4b4
            defaultPresetKnobValues[Wavefolder][2] = 0.5f; // offset2
 8016c36:	edc3 7ae3 	vstr	s15, [r3, #908]	; 0x38c
            defaultPresetKnobValues[Reverb][1] = 0.5f; // in lowpass
 8016c3a:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
 8016c3e:	f503 6997 	add.w	r9, r3, #1208	; 0x4b8
            defaultPresetKnobValues[Wavefolder][3] = 0.75f; // post gain
 8016c42:	ed83 6ae4 	vstr	s12, [r3, #912]	; 0x390
            defaultPresetKnobValues[Reverb][2] = 0.5f; // in highpass
 8016c46:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
 8016c4a:	f203 49bc 	addw	r9, r3, #1212	; 0x4bc
            defaultPresetKnobValues[Wavefolder][4] = 0.0f;
 8016c4e:	f8c3 5394 	str.w	r5, [r3, #916]	; 0x394
            defaultPresetKnobValues[Reverb][3] = 0.5f; // fb lowpass
 8016c52:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
 8016c56:	f503 6998 	add.w	r9, r3, #1216	; 0x4c0
            defaultPresetKnobValues[BitCrusher][1] = 0.5f; // samp ratio
 8016c5a:	edc3 7afb 	vstr	s15, [r3, #1004]	; 0x3ec
            defaultPresetKnobValues[Reverb][4] = 0.5f; // fb gain
 8016c5e:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
 8016c62:	f503 69a3 	add.w	r9, r3, #1304	; 0x518
            defaultPresetKnobValues[BitCrusher][2] = 0.0f; // rounding
 8016c66:	f8c3 53f0 	str.w	r5, [r3, #1008]	; 0x3f0
            defaultPresetKnobValues[Reverb2][1] = 0.5f; // lowpass
 8016c6a:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
 8016c6e:	f203 591c 	addw	r9, r3, #1308	; 0x51c
            defaultPresetKnobValues[BitCrusher][3] = 0.0f; // operation
 8016c72:	f8c3 53f4 	str.w	r5, [r3, #1012]	; 0x3f4
            defaultPresetKnobValues[Reverb2][2] = 0.5f; // highpass
 8016c76:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
 8016c7a:	f503 69a4 	add.w	r9, r3, #1312	; 0x520
            defaultPresetKnobValues[BitCrusher][4] = 0.5f; // post gain
 8016c7e:	edc3 7afe 	vstr	s15, [r3, #1016]	; 0x3f8
            defaultPresetKnobValues[Reverb2][3] = 0.5f; // peak freq
 8016c82:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
 8016c86:	f203 4954 	addw	r9, r3, #1108	; 0x454
            defaultPresetKnobValues[BitCrusher][5] = 0.0f; // pre gain
 8016c8a:	f8c3 53fc 	str.w	r5, [r3, #1020]	; 0x3fc
            defaultPresetKnobValues[Delay][2] = 0.0f; // highpass
 8016c8e:	f8c9 5000 	str.w	r5, [r9]
            defaultPresetKnobValues[Reverb2][4] = 0.5f; // peak gain
 8016c92:	f203 5924 	addw	r9, r3, #1316	; 0x524
 8016c96:	edc9 7a00 	vstr	s15, [r9]
            defaultPresetKnobValues[LivingStringSynth][4] = 0.4f; // pick pos
 8016c9a:	f203 59ec 	addw	r9, r3, #1516	; 0x5ec
 8016c9e:	f8c9 0000 	str.w	r0, [r9]
            defaultPresetKnobValues[LivingString][1] = 0.1f; // detune
 8016ca2:	f203 597c 	addw	r9, r3, #1404	; 0x57c
 8016ca6:	f8c9 2000 	str.w	r2, [r9]
            defaultPresetKnobValues[LivingStringSynth][2] = .85f; // decay
 8016caa:	f203 59e4 	addw	r9, r3, #1508	; 0x5e4
 8016cae:	f8c9 8000 	str.w	r8, [r9]
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
 8016cb2:	f503 68c0 	add.w	r8, r3, #1536	; 0x600
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
 8016cb6:	f203 69fc 	addw	r9, r3, #1788	; 0x6fc
            defaultPresetKnobValues[LivingStringSynth][9] = 0.4f; // release time
 8016cba:	f8c8 0000 	str.w	r0, [r8]
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
 8016cbe:	f503 68c9 	add.w	r8, r3, #1608	; 0x648
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
 8016cc2:	f243 3033 	movw	r0, #13107	; 0x3333
            defaultPresetKnobValues[ClassicSynth][2] = 0.2f; // detune
 8016cc6:	f8c8 c000 	str.w	ip, [r8]
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
 8016cca:	f503 6cb1 	add.w	ip, r3, #1416	; 0x588
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
 8016cce:	f6c3 7033 	movt	r0, #16179	; 0x3f33
 8016cd2:	f503 68dd 	add.w	r8, r3, #1768	; 0x6e8
            defaultPresetKnobValues[LivingString][4] = 0.5f; // pick pos
 8016cd6:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[LivingString][5] = 0.25f; // prep pos
 8016cda:	f203 5c8c 	addw	ip, r3, #1420	; 0x58c
 8016cde:	ed8c 7a00 	vstr	s14, [ip]
            defaultPresetKnobValues[LivingString][9] = 0.5f;
 8016ce2:	f203 5c9c 	addw	ip, r3, #1436	; 0x59c
 8016ce6:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[LivingStringSynth][0] = 0.5f;
 8016cea:	f203 5cdc 	addw	ip, r3, #1500	; 0x5dc
 8016cee:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[LivingStringSynth][1] = 0.5f;
 8016cf2:	f503 6cbc 	add.w	ip, r3, #1504	; 0x5e0
 8016cf6:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[LivingStringSynth][3] = 1.0f; // damping
 8016cfa:	f503 6cbd 	add.w	ip, r3, #1512	; 0x5e8
 8016cfe:	edcc 6a00 	vstr	s13, [ip]
            defaultPresetKnobValues[LivingStringSynth][5] = 0.25f; // prep pos
 8016d02:	f503 6cbe 	add.w	ip, r3, #1520	; 0x5f0
 8016d06:	ed8c 7a00 	vstr	s14, [ip]
            defaultPresetKnobValues[ClassicSynth][0] = 0.5f; // volume
 8016d0a:	f503 6cc8 	add.w	ip, r3, #1600	; 0x640
 8016d0e:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[ClassicSynth][1] = 0.5f; // lowpass
 8016d12:	f203 6c44 	addw	ip, r3, #1604	; 0x644
 8016d16:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[LivingString][0] = 0.3f; // freq 1
 8016d1a:	f503 6caf 	add.w	ip, r3, #1400	; 0x578
 8016d1e:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][2] = 0.3f; // decay
 8016d22:	f503 6cb0 	add.w	ip, r3, #1408	; 0x580
 8016d26:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][10] = 0.3f;// freq 2
 8016d2a:	f503 6cb4 	add.w	ip, r3, #1440	; 0x5a0
 8016d2e:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][11] = 0.3f;// freq 3
 8016d32:	f203 5ca4 	addw	ip, r3, #1444	; 0x5a4
 8016d36:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][12] = 0.3f;// freq 4
 8016d3a:	f503 6cb5 	add.w	ip, r3, #1448	; 0x5a8
 8016d3e:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][13] = 0.3f;// freq 5
 8016d42:	f203 5cac 	addw	ip, r3, #1452	; 0x5ac
 8016d46:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][14] = 0.3f;// freq 6
 8016d4a:	f503 6cb6 	add.w	ip, r3, #1456	; 0x5b0
 8016d4e:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingStringSynth][8] = 0.3f; // feedback volume
 8016d52:	f203 5cfc 	addw	ip, r3, #1532	; 0x5fc
 8016d56:	f8cc 1000 	str.w	r1, [ip]
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8016d5a:	f203 5184 	addw	r1, r3, #1412	; 0x584
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
 8016d5e:	f503 6cd1 	add.w	ip, r3, #1672	; 0x688
            defaultPresetKnobValues[LivingString][3] = 0.9f; // damping
 8016d62:	600e      	str	r6, [r1, #0]
            defaultPresetKnobValues[LivingString][6] = 0.0f; // prep index
 8016d64:	f503 61b2 	add.w	r1, r3, #1424	; 0x590
 8016d68:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[LivingString][7] = 0.0f; // let ring
 8016d6a:	f203 5194 	addw	r1, r3, #1428	; 0x594
 8016d6e:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[LivingString][8] = 0.8f;
 8016d70:	f503 61b3 	add.w	r1, r3, #1432	; 0x598
 8016d74:	f8c1 e000 	str.w	lr, [r1]
            defaultPresetKnobValues[LivingStringSynth][6] = 0.0f; // prep index
 8016d78:	f203 51f4 	addw	r1, r3, #1524	; 0x5f4
 8016d7c:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[LivingStringSynth][7] = 0.0f; // let ring
 8016d7e:	f503 61bf 	add.w	r1, r3, #1528	; 0x5f8
 8016d82:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][3] = 0.0f;
 8016d84:	f203 614c 	addw	r1, r3, #1612	; 0x64c
 8016d88:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][4] = 0.0f;
 8016d8a:	f503 61ca 	add.w	r1, r3, #1616	; 0x650
 8016d8e:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][5] = 0.0f;
 8016d90:	f203 6154 	addw	r1, r3, #1620	; 0x654
 8016d94:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][6] = 0.06f;
 8016d96:	f503 61cb 	add.w	r1, r3, #1624	; 0x658
 8016d9a:	f8c1 b000 	str.w	fp, [r1]
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
 8016d9e:	f203 615c 	addw	r1, r3, #1628	; 0x65c
            defaultPresetKnobValues[ClassicSynth][18] = 0.1f;
 8016da2:	f8cc 2000 	str.w	r2, [ip]
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
 8016da6:	f503 6cd8 	add.w	ip, r3, #1728	; 0x6c0
            defaultPresetKnobValues[ClassicSynth][7] = 0.9f;
 8016daa:	600e      	str	r6, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
 8016dac:	f503 61cc 	add.w	r1, r3, #1632	; 0x660
            defaultPresetKnobValues[Rhodes][7] = 0.9f;
 8016db0:	f8cc 6000 	str.w	r6, [ip]
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
 8016db4:	f203 6cec 	addw	ip, r3, #1772	; 0x6ec
            defaultPresetKnobValues[ClassicSynth][8] = 0.1f;
 8016db8:	600a      	str	r2, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
 8016dba:	f203 6164 	addw	r1, r3, #1636	; 0x664
            defaultPresetKnobValues[Rhodes][18] = 0.5f;
 8016dbe:	edcc 7a00 	vstr	s15, [ip]
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
 8016dc2:	f203 6cb4 	addw	ip, r3, #1716	; 0x6b4
            defaultPresetKnobValues[ClassicSynth][9] = 0.1f;
 8016dc6:	600a      	str	r2, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
 8016dc8:	f203 616c 	addw	r1, r3, #1644	; 0x66c
            defaultPresetKnobValues[Rhodes][4] = 0.0f; //stereo spread
 8016dcc:	f8cc 5000 	str.w	r5, [ip]
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
 8016dd0:	f503 6cda 	add.w	ip, r3, #1744	; 0x6d0
            defaultPresetKnobValues[ClassicSynth][11] = 0.06f;
 8016dd4:	f8c1 b000 	str.w	fp, [r1]
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
 8016dd8:	f503 61ce 	add.w	r1, r3, #1648	; 0x670
            defaultPresetKnobValues[Rhodes][11] = 0.05f;
 8016ddc:	f8cc 7000 	str.w	r7, [ip]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
 8016de0:	f503 6cdf 	add.w	ip, r3, #1784	; 0x6f8
            defaultPresetKnobValues[ClassicSynth][12] = 0.9f;
 8016de4:	600e      	str	r6, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][13] = 0.1f;
 8016de6:	f203 6174 	addw	r1, r3, #1652	; 0x674
 8016dea:	600a      	str	r2, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][14] = 0.1f;
 8016dec:	f503 61cf 	add.w	r1, r3, #1656	; 0x678
 8016df0:	600a      	str	r2, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][16] = 0.06f;
 8016df2:	f503 61d0 	add.w	r1, r3, #1664	; 0x680
 8016df6:	f8c1 b000 	str.w	fp, [r1]
            defaultPresetKnobValues[ClassicSynth][17] = 0.9f;
 8016dfa:	f203 6184 	addw	r1, r3, #1668	; 0x684
 8016dfe:	600e      	str	r6, [r1, #0]
            defaultPresetKnobValues[ClassicSynth][19] = 0.1f;
 8016e00:	f203 618c 	addw	r1, r3, #1676	; 0x68c
 8016e04:	600a      	str	r2, [r1, #0]
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
 8016e06:	f203 61d4 	addw	r1, r3, #1748	; 0x6d4
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
 8016e0a:	f503 62dc 	add.w	r2, r3, #1760	; 0x6e0
            defaultPresetKnobValues[Rhodes][12] = 0.9f;
 8016e0e:	600e      	str	r6, [r1, #0]
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
 8016e10:	f203 66a4 	addw	r6, r3, #1700	; 0x6a4
            defaultPresetKnobValues[Rhodes][15] = 0.8f;
 8016e14:	f8c2 e000 	str.w	lr, [r2]
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
 8016e18:	f503 61d5 	add.w	r1, r3, #1704	; 0x6a8
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
 8016e1c:	f203 62ac 	addw	r2, r3, #1708	; 0x6ac
            defaultPresetKnobValues[Rhodes][0] = 0.25f;
 8016e20:	ed86 7a00 	vstr	s14, [r6]
            defaultPresetKnobValues[Rhodes][1] = 0.25f;
 8016e24:	ed81 7a00 	vstr	s14, [r1]
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
 8016e28:	f503 66d6 	add.w	r6, r3, #1712	; 0x6b0
            defaultPresetKnobValues[Rhodes][2] = 0.25f;
 8016e2c:	ed82 7a00 	vstr	s14, [r2]
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
 8016e30:	f503 61d9 	add.w	r1, r3, #1736	; 0x6c8
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
 8016e34:	f203 62dc 	addw	r2, r3, #1756	; 0x6dc
            defaultPresetKnobValues[Rhodes][3] = 0.5f;
 8016e38:	edc6 7a00 	vstr	s15, [r6]
            defaultPresetKnobValues[Rhodes][9] = 0.5f;
 8016e3c:	edc1 7a00 	vstr	s15, [r1]
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
 8016e40:	f503 66de 	add.w	r6, r3, #1776	; 0x6f0
            defaultPresetKnobValues[Rhodes][14] = 0.5f;
 8016e44:	edc2 7a00 	vstr	s15, [r2]
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
 8016e48:	f503 61cd 	add.w	r1, r3, #1640	; 0x668
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
 8016e4c:	f203 627c 	addw	r2, r3, #1660	; 0x67c
            defaultPresetKnobValues[Rhodes][19] = 0.5f;
 8016e50:	edc6 7a00 	vstr	s15, [r6]
            defaultPresetKnobValues[ClassicSynth][10] = 0.0f;
 8016e54:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8016e56:	f503 66d7 	add.w	r6, r3, #1720	; 0x6b8
            defaultPresetKnobValues[ClassicSynth][15] = 0.0f;
 8016e5a:	6015      	str	r5, [r2, #0]
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
 8016e5c:	f203 61bc 	addw	r1, r3, #1724	; 0x6bc
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
 8016e60:	f203 62cc 	addw	r2, r3, #1740	; 0x6cc
            defaultPresetKnobValues[Rhodes][5] = 0.05f;
 8016e64:	6037      	str	r7, [r6, #0]
            defaultPresetKnobValues[Rhodes][6] = 0.05f;
 8016e66:	600f      	str	r7, [r1, #0]
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8016e68:	f203 66c4 	addw	r6, r3, #1732	; 0x6c4
            defaultPresetKnobValues[Rhodes][10] = 0.05f;
 8016e6c:	6017      	str	r7, [r2, #0]
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
 8016e6e:	f503 61db 	add.w	r1, r3, #1752	; 0x6d8
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8016e72:	f203 62e4 	addw	r2, r3, #1764	; 0x6e4
 8016e76:	ed9d 7a01 	vldr	s14, [sp, #4]
            defaultPresetKnobValues[Rhodes][8] = 0.1007f;
 8016e7a:	f8c6 a000 	str.w	sl, [r6]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
 8016e7e:	f203 6ef4 	addw	lr, r3, #1780	; 0x6f4
            defaultPresetKnobValues[Rhodes][13] = 0.1007f;
 8016e82:	f8c1 a000 	str.w	sl, [r1]
 8016e86:	461e      	mov	r6, r3
            defaultPresetKnobValues[Rhodes][16] = 0.6f;
 8016e88:	ed82 7a00 	vstr	s14, [r2]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
 8016e8c:	f503 61e0 	add.w	r1, r3, #1792	; 0x700
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
 8016e90:	f203 7204 	addw	r2, r3, #1796	; 0x704
 8016e94:	f504 67e1 	add.w	r7, r4, #1800	; 0x708
            defaultPresetKnobValues[Rhodes][17] = 0.7f;
 8016e98:	f8c8 0000 	str.w	r0, [r8]
            defaultPresetKnobValues[Rhodes][20] = 0.5f;
 8016e9c:	edce 7a00 	vstr	s15, [lr]
            defaultPresetKnobValues[Rhodes][21] = 0.0f;
 8016ea0:	f8cc 5000 	str.w	r5, [ip]
            defaultPresetKnobValues[Rhodes][22] = 0.00f;
 8016ea4:	f8c9 5000 	str.w	r5, [r9]
            defaultPresetKnobValues[Rhodes][23] = 0.00f;
 8016ea8:	600d      	str	r5, [r1, #0]
            defaultPresetKnobValues[Rhodes][24] = 0.00f;
 8016eaa:	6015      	str	r5, [r2, #0]
 8016eac:	4620      	mov	r0, r4
 8016eae:	3464      	adds	r4, #100	; 0x64
 8016eb0:	4631      	mov	r1, r6
 8016eb2:	2264      	movs	r2, #100	; 0x64
 8016eb4:	f013 ff16 	bl	802ace4 <memcpy>
            for (int p = 0; p < PresetNil; p++)
 8016eb8:	42a7      	cmp	r7, r4
 8016eba:	f106 0664 	add.w	r6, r6, #100	; 0x64
 8016ebe:	d1f5      	bne.n	8016eac <initGlobalSFXObjects+0x5a0>
        }
 8016ec0:	b003      	add	sp, #12
 8016ec2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8016ec6:	bf00      	nop

08016ec8 <SFXVocoderAlloc>:
            tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
 8016ec8:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016ecc:	f248 1040 	movw	r0, #33088	; 0x8140
 8016ed0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8016ed4:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8016ed8:	f2c2 0001 	movt	r0, #8193	; 0x2001
        {
 8016edc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8016ee0:	ed2d 8b02 	vpush	{d8}
            tTalkboxFloat_initToPool(&vocoder, 1024,  &smallPool);
 8016ee4:	f00c ff94 	bl	8023e10 <tTalkboxFloat_initToPool>
            tTalkboxFloat_setWarpOn(&vocoder, 1);
 8016ee8:	f248 1040 	movw	r0, #33088	; 0x8140
 8016eec:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
            tSimplePoly_setNumVoices(&poly, numVoices);
 8016ef0:	f240 2950 	movw	r9, #592	; 0x250
            tTalkboxFloat_setWarpOn(&vocoder, 1);
 8016ef4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016ef8:	f247 28dc 	movw	r8, #29404	; 0x72dc
 8016efc:	f00d fa62 	bl	80243c4 <tTalkboxFloat_setWarpOn>
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
 8016f00:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016f04:	f243 4064 	movw	r0, #13412	; 0x3464
 8016f08:	2100      	movs	r1, #0
 8016f0a:	f2c2 0201 	movt	r2, #8193	; 0x2001
            tSimplePoly_setNumVoices(&poly, numVoices);
 8016f0e:	f2c2 0900 	movt	r9, #8192	; 0x2000
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
 8016f12:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016f16:	f642 0748 	movw	r7, #10312	; 0x2848
 8016f1a:	f011 fd4b 	bl	80289b4 <tNoise_initToPool>
            tZeroCrossing_initToPool(&zerox, 16, &smallPool);
 8016f1e:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016f22:	f247 6090 	movw	r0, #30352	; 0x7690
 8016f26:	2110      	movs	r1, #16
 8016f28:	f2c2 0201 	movt	r2, #8193	; 0x2001
                tSawtooth_initToPool(&osc[i], &smallPool);
 8016f2c:	f248 26f8 	movw	r6, #33528	; 0x82f8
            tZeroCrossing_initToPool(&zerox, 16, &smallPool);
 8016f30:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016f34:	f2c2 0801 	movt	r8, #8193	; 0x2001
 8016f38:	f00b f984 	bl	8022244 <tZeroCrossing_initToPool>
            tSimplePoly_setNumVoices(&poly, numVoices);
 8016f3c:	f247 5020 	movw	r0, #29984	; 0x7520
 8016f40:	f899 1000 	ldrb.w	r1, [r9]
 8016f44:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8016f48:	f2c2 0001 	movt	r0, #8193	; 0x2001
                tSawtooth_initToPool(&osc[i], &smallPool);
 8016f4c:	f2c2 0601 	movt	r6, #8193	; 0x2001
            tSimplePoly_setNumVoices(&poly, numVoices);
 8016f50:	f011 fbb8 	bl	80286c4 <tSimplePoly_setNumVoices>
            tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.005f, &smallPool);
 8016f54:	f24d 730a 	movw	r3, #55050	; 0xd70a
 8016f58:	2200      	movs	r2, #0
 8016f5a:	f248 21f8 	movw	r1, #33528	; 0x82f8
 8016f5e:	f6c3 33a3 	movt	r3, #15267	; 0x3ba3
 8016f62:	f248 2028 	movw	r0, #33320	; 0x8228
 8016f66:	ee00 2a10 	vmov	s0, r2
 8016f6a:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8016f6e:	ee00 3a90 	vmov	s1, r3
 8016f72:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016f76:	f00e ffcf 	bl	8025f18 <tExpSmooth_initToPool>
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
 8016f7a:	2300      	movs	r3, #0
 8016f7c:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016f80:	f247 40fc 	movw	r0, #29948	; 0x74fc
 8016f84:	f2c4 23a0 	movt	r3, #17056	; 0x42a0
 8016f88:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8016f8c:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8016f90:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016f94:	ee00 3a10 	vmov	s0, r3
 8016f98:	2106      	movs	r1, #6
 8016f9a:	f00f fb5b 	bl	8026654 <tVZFilter_initToPool>
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
 8016f9e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8016fa2:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016fa6:	f247 4024 	movw	r0, #29732	; 0x7424
 8016faa:	f2c4 633b 	movt	r3, #17979	; 0x463b
 8016fae:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 8016fb2:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8016fb6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8016fba:	ee00 3a10 	vmov	s0, r3
 8016fbe:	2107      	movs	r1, #7
 8016fc0:	f00f fb48 	bl	8026654 <tVZFilter_initToPool>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
 8016fc4:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8016fc8:	f642 0018 	movw	r0, #10264	; 0x2818
 8016fcc:	2100      	movs	r1, #0
 8016fce:	f2c2 0201 	movt	r2, #8193	; 0x2001
            tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
 8016fd2:	2400      	movs	r4, #0
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
 8016fd4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016fd8:	f011 fcec 	bl	80289b4 <tNoise_initToPool>
            tHighpass_initToPool(&noiseHP, 4500.0f, &smallPool);
 8016fdc:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 8016fe0:	f248 21f8 	movw	r1, #33528	; 0x82f8
 8016fe4:	f243 405c 	movw	r0, #13404	; 0x345c
 8016fe8:	f2c4 538c 	movt	r3, #17804	; 0x458c
 8016fec:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8016ff0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8016ff4:	ee00 3a10 	vmov	s0, r3
 8016ff8:	f00f fae6 	bl	80265c8 <tHighpass_initToPool>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
 8016ffc:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 8017000:	f649 139a 	movw	r3, #39322	; 0x999a
 8017004:	f6c3 62cc 	movt	r2, #16076	; 0x3ecc
 8017008:	f6c3 6399 	movt	r3, #16025	; 0x3e99
 801700c:	ee08 2a90 	vmov	s17, r2
 8017010:	ee08 3a10 	vmov	s16, r3
 8017014:	193d      	adds	r5, r7, r4
                tSawtooth_initToPool(&osc[i], &smallPool);
 8017016:	eb08 0004 	add.w	r0, r8, r4
 801701a:	4631      	mov	r1, r6
 801701c:	3404      	adds	r4, #4
 801701e:	f011 fc11 	bl	8028844 <tSawtooth_initToPool>
                tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
 8017022:	4628      	mov	r0, r5
 8017024:	4631      	mov	r1, r6
 8017026:	f00d f9d9 	bl	80243dc <tRosenbergGlottalPulse_initToPool>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], 0.3f, 0.4f);
 801702a:	eef0 0a68 	vmov.f32	s1, s17
 801702e:	eeb0 0a48 	vmov.f32	s0, s16
 8017032:	4628      	mov	r0, r5
 8017034:	f00d faf4 	bl	8024620 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 8017038:	2c20      	cmp	r4, #32
 801703a:	d1eb      	bne.n	8017014 <SFXVocoderAlloc+0x14c>
            setLED_A(numVoices == 1);
 801703c:	f899 0000 	ldrb.w	r0, [r9]
 8017040:	f1a0 0001 	sub.w	r0, r0, #1
 8017044:	fab0 f080 	clz	r0, r0
 8017048:	0940      	lsrs	r0, r0, #5
 801704a:	f7fe fc4f 	bl	80158ec <setLED_A>
            setLED_B(internalExternal);
 801704e:	f240 539c 	movw	r3, #1436	; 0x59c
 8017052:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017056:	7818      	ldrb	r0, [r3, #0]
 8017058:	f7fe fc58 	bl	801590c <setLED_B>
            vocFreezeLPC = 0;
 801705c:	f240 6314 	movw	r3, #1556	; 0x614
 8017060:	2200      	movs	r2, #0
 8017062:	f2c2 0300 	movt	r3, #8192	; 0x2000
            setLED_C(vocFreezeLPC);
 8017066:	4610      	mov	r0, r2
            vocFreezeLPC = 0;
 8017068:	601a      	str	r2, [r3, #0]
        }
 801706a:	ecbd 8b02 	vpop	{d8}
 801706e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(vocFreezeLPC);
 8017072:	f7fe bc5b 	b.w	801592c <setLED_C>
 8017076:	bf00      	nop

08017078 <SFXVocoderFrame>:
        {
 8017078:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801707c:	f248 64e4 	movw	r4, #34532	; 0x86e4
 8017080:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 8017084:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8017088:	7d23      	ldrb	r3, [r4, #20]
 801708a:	2b01      	cmp	r3, #1
 801708c:	d119      	bne.n	80170c2 <SFXVocoderFrame+0x4a>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801708e:	f240 2550 	movw	r5, #592	; 0x250
                tSimplePoly_setNumVoices(&poly, numVoices);
 8017092:	f247 5020 	movw	r0, #29984	; 0x7520
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8017096:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tSimplePoly_setNumVoices(&poly, numVoices);
 801709a:	f2c2 0001 	movt	r0, #8193	; 0x2001
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801709e:	782a      	ldrb	r2, [r5, #0]
 80170a0:	2a01      	cmp	r2, #1
 80170a2:	bf98      	it	ls
 80170a4:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
 80170a6:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 80170a8:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 80170aa:	f011 fb0b 	bl	80286c4 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 80170ae:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80170b0:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 80170b2:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 80170b6:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 80170b8:	fab0 f080 	clz	r0, r0
 80170bc:	0940      	lsrs	r0, r0, #5
 80170be:	f7fe fc15 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 80170c2:	7e23      	ldrb	r3, [r4, #24]
 80170c4:	2b01      	cmp	r3, #1
 80170c6:	f000 8129 	beq.w	801731c <SFXVocoderFrame+0x2a4>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 80170ca:	7f23      	ldrb	r3, [r4, #28]
 80170cc:	2b01      	cmp	r3, #1
 80170ce:	f000 810c 	beq.w	80172ea <SFXVocoderFrame+0x272>
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 80170d2:	f64c 40cd 	movw	r0, #52429	; 0xcccd
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 80170d6:	f642 5310 	movw	r3, #11536	; 0x2d10
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 80170da:	eef3 5a0e 	vmov.f32	s11, #62	; 0x41f00000  30.0
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 80170de:	f248 7594 	movw	r5, #34708	; 0x8794
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 80170e2:	4602      	mov	r2, r0
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 80170e4:	f2c2 0300 	movt	r3, #8192	; 0x2000
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 80170e8:	4601      	mov	r1, r0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 80170ea:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
 80170ee:	f6cb 624c 	movt	r2, #48716	; 0xbe4c
 80170f2:	ed93 6a01 	vldr	s12, [r3, #4]
 80170f6:	ee07 0a10 	vmov	s14, r0
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 80170fa:	eefa 6a0e 	vmov.f32	s13, #174	; 0xc1700000 -15.0
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 80170fe:	ee07 2a90 	vmov	s15, r2
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8017102:	ed93 5a06 	vldr	s10, [r3, #24]
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8017106:	f6c3 718c 	movt	r1, #16268	; 0x3f8c
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 801710a:	f2c2 0501 	movt	r5, #8193	; 0x2001
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 801710e:	eee6 7a07 	vfma.f32	s15, s12, s14
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8017112:	ed93 6a02 	vldr	s12, [r3, #8]
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8017116:	eee5 6a25 	vfma.f32	s13, s10, s11
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 801711a:	ee07 1a10 	vmov	s14, r1
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
 801711e:	68da      	ldr	r2, [r3, #12]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8017120:	f248 1040 	movw	r0, #33088	; 0x8140
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8017124:	ee26 7a07 	vmul.f32	s14, s12, s14
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 8017128:	681e      	ldr	r6, [r3, #0]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
 801712a:	691c      	ldr	r4, [r3, #16]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 801712c:	f2c2 0001 	movt	r0, #8193	; 0x2001
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
 8017130:	6959      	ldr	r1, [r3, #20]
 8017132:	f243 473c 	movw	r7, #13372	; 0x343c
            displayValues[3] = presetKnobValues[Vocoder][3]; //crossfade between sawtooth and glottal pulse
 8017136:	60ea      	str	r2, [r5, #12]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8017138:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
 801713c:	69da      	ldr	r2, [r3, #28]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801713e:	f64a 28ab 	movw	r8, #43691	; 0xaaab
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
 8017142:	6a1b      	ldr	r3, [r3, #32]
 8017144:	f2c2 0700 	movt	r7, #8192	; 0x2000
            displayValues[1] = (presetKnobValues[Vocoder][1] * 0.4f) - 0.2f; //warp factor
 8017148:	edc5 7a01 	vstr	s15, [r5, #4]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801714c:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
            displayValues[0] = presetKnobValues[Vocoder][0]; //vocoder volume
 8017150:	602e      	str	r6, [r5, #0]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017152:	f247 5620 	movw	r6, #29984	; 0x7520
            displayValues[2] = presetKnobValues[Vocoder][2] * 1.1f; //quality
 8017156:	ed85 7a02 	vstr	s14, [r5, #8]
            displayValues[4] = presetKnobValues[Vocoder][4]; //noise thresh
 801715a:	612c      	str	r4, [r5, #16]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801715c:	2400      	movs	r4, #0
            displayValues[5] = presetKnobValues[Vocoder][5]; //breathy
 801715e:	6169      	str	r1, [r5, #20]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017160:	f2c2 0601 	movt	r6, #8193	; 0x2001
            displayValues[6] = (presetKnobValues[Vocoder][6] * 30.0f) - 15.0f;; //tilt filter
 8017164:	edc5 6a06 	vstr	s13, [r5, #24]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017168:	46a1      	mov	r9, r4
            displayValues[7] = presetKnobValues[Vocoder][7]; //pulse length
 801716a:	61ea      	str	r2, [r5, #28]
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 801716c:	ee08 4a10 	vmov	s16, r4
            displayValues[8] = presetKnobValues[Vocoder][8]; //open length
 8017170:	622b      	str	r3, [r5, #32]
            tTalkboxFloat_setWarpFactor(&vocoder, displayValues[1]);
 8017172:	f00d f923 	bl	80243bc <tTalkboxFloat_setWarpFactor>
            tTalkboxFloat_setQuality(&vocoder, displayValues[2]);
 8017176:	f248 1040 	movw	r0, #33088	; 0x8140
 801717a:	ed95 0a02 	vldr	s0, [r5, #8]
 801717e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017182:	f00d f8f9 	bl	8024378 <tTalkboxFloat_setQuality>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017186:	e060      	b.n	801724a <SFXVocoderFrame+0x1d2>
 8017188:	eb04 0b03 	add.w	fp, r4, r3
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 801718c:	f011 faca 	bl	8028724 <tSimplePoly_getVelocity>
 8017190:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8017194:	2800      	cmp	r0, #0
 8017196:	4658      	mov	r0, fp
 8017198:	fe30 0a08 	vselgt.f32	s0, s0, s16
 801719c:	f00e fef8 	bl	8025f90 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80171a0:	4651      	mov	r1, sl
 80171a2:	4630      	mov	r0, r6
 80171a4:	f011 fab2 	bl	802870c <tSimplePoly_getPitch>
 80171a8:	f240 52d8 	movw	r2, #1496	; 0x5d8
 80171ac:	ee07 0a90 	vmov	s15, r0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80171b0:	f240 6354 	movw	r3, #1620	; 0x654
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80171b4:	f2c2 0200 	movt	r2, #8192	; 0x2000
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 80171b8:	f240 6120 	movw	r1, #1568	; 0x620
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80171bc:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80171c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80171c4:	ed92 0a00 	vldr	s0, [r2]
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 80171c8:	f2c2 0100 	movt	r1, #8192	; 0x2000
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80171cc:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 80171ce:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 80171d2:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80171d6:	ee17 3a90 	vmov	r3, s15
 80171da:	1a9b      	subs	r3, r3, r2
 80171dc:	fb88 2003 	smull	r2, r0, r8, r3
 80171e0:	17da      	asrs	r2, r3, #31
 80171e2:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 80171e6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80171ea:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 80171ee:	ee07 3a90 	vmov	s15, r3
 80171f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 80171f6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80171fa:	ee17 3a90 	vmov	r3, s15
 80171fe:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8017202:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8017206:	ee37 0a00 	vadd.f32	s0, s14, s0
 801720a:	f010 fcbf 	bl	8027b8c <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
 801720e:	f247 20dc 	movw	r0, #29404	; 0x72dc
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8017212:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
 8017216:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801721a:	4420      	add	r0, r4
 801721c:	f011 fb3c 	bl	8028898 <tSawtooth_setFreq>
 8017220:	f642 0048 	movw	r0, #10312	; 0x2848
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
 8017224:	ecb7 0a01 	vldmia	r7!, {s0}
 8017228:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801722c:	eb04 0a00 	add.w	sl, r4, r0
 8017230:	3404      	adds	r4, #4
 8017232:	4650      	mov	r0, sl
 8017234:	f00d f9ca 	bl	80245cc <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[8] * displayValues[7], displayValues[7]);
 8017238:	edd5 0a07 	vldr	s1, [r5, #28]
 801723c:	ed95 0a08 	vldr	s0, [r5, #32]
 8017240:	4650      	mov	r0, sl
 8017242:	ee20 0a80 	vmul.f32	s0, s1, s0
 8017246:	f00d f9eb 	bl	8024620 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801724a:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 801724c:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017250:	f011 fa40 	bl	80286d4 <tSimplePoly_getNumVoices>
 8017254:	f647 131c 	movw	r3, #31004	; 0x791c
 8017258:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 801725a:	4651      	mov	r1, sl
 801725c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8017260:	4630      	mov	r0, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017262:	f109 0901 	add.w	r9, r9, #1
 8017266:	dc8f      	bgt.n	8017188 <SFXVocoderFrame+0x110>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
 8017268:	f247 5020 	movw	r0, #29984	; 0x7520
 801726c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017270:	f011 fa34 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 8017274:	bb10      	cbnz	r0, 80172bc <SFXVocoderFrame+0x244>
                tExpSmooth_setDest(&comp, 0.0f);
 8017276:	2300      	movs	r3, #0
 8017278:	f247 205c 	movw	r0, #29276	; 0x725c
 801727c:	ee00 3a10 	vmov	s0, r3
 8017280:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017284:	f00e fe84 	bl	8025f90 <tExpSmooth_setDest>
            tVZFilter_setGain(&shelf1, fasterdbtoa(-1.0f * displayValues[6]));
 8017288:	ed95 0a06 	vldr	s0, [r5, #24]
 801728c:	eeb1 0a40 	vneg.f32	s0, s0
 8017290:	f010 fd70 	bl	8027d74 <fasterdbtoa>
 8017294:	f247 40fc 	movw	r0, #29948	; 0x74fc
 8017298:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801729c:	f010 f854 	bl	8027348 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
 80172a0:	ed95 0a06 	vldr	s0, [r5, #24]
 80172a4:	f010 fd5c 	bl	8027d60 <fastdbtoa>
 80172a8:	f247 4024 	movw	r0, #29732	; 0x7424
        }
 80172ac:	ecbd 8b02 	vpop	{d8}
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
 80172b0:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 80172b4:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[6]));
 80172b8:	f010 b846 	b.w	8027348 <tVZFilter_setGain>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
 80172bc:	f247 5020 	movw	r0, #29984	; 0x7520
 80172c0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80172c4:	f011 fa0a 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 80172c8:	ee07 0a90 	vmov	s15, r0
 80172cc:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80172d0:	f247 205c 	movw	r0, #29276	; 0x725c
 80172d4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80172d8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80172dc:	ee87 0a27 	vdiv.f32	s0, s14, s15
 80172e0:	eeb1 0ac0 	vsqrt.f32	s0, s0
 80172e4:	f00e fe54 	bl	8025f90 <tExpSmooth_setDest>
 80172e8:	e7ce      	b.n	8017288 <SFXVocoderFrame+0x210>
                vocFreezeLPC = !vocFreezeLPC;
 80172ea:	f240 6514 	movw	r5, #1556	; 0x614
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 80172ee:	f248 1040 	movw	r0, #33088	; 0x8140
                vocFreezeLPC = !vocFreezeLPC;
 80172f2:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 80172f6:	f2c2 0001 	movt	r0, #8193	; 0x2001
                vocFreezeLPC = !vocFreezeLPC;
 80172fa:	682b      	ldr	r3, [r5, #0]
 80172fc:	fab3 f383 	clz	r3, r3
 8017300:	095b      	lsrs	r3, r3, #5
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 8017302:	ee07 3a90 	vmov	s15, r3
                vocFreezeLPC = !vocFreezeLPC;
 8017306:	602b      	str	r3, [r5, #0]
                tTalkboxFloat_setFreeze(&vocoder, vocFreezeLPC);
 8017308:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 801730c:	f00d f860 	bl	80243d0 <tTalkboxFloat_setFreeze>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8017310:	2300      	movs	r3, #0
                setLED_C(vocFreezeLPC);
 8017312:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8017314:	7723      	strb	r3, [r4, #28]
                setLED_C(vocFreezeLPC);
 8017316:	f7fe fb09 	bl	801592c <setLED_C>
 801731a:	e6da      	b.n	80170d2 <SFXVocoderFrame+0x5a>
                internalExternal = !internalExternal;
 801731c:	f240 529c 	movw	r2, #1436	; 0x59c
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8017320:	2300      	movs	r3, #0
                internalExternal = !internalExternal;
 8017322:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8017326:	7623      	strb	r3, [r4, #24]
                internalExternal = !internalExternal;
 8017328:	7813      	ldrb	r3, [r2, #0]
 801732a:	fab3 f383 	clz	r3, r3
 801732e:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
 8017330:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
 8017332:	7013      	strb	r3, [r2, #0]
                setLED_B(internalExternal);
 8017334:	f7fe faea 	bl	801590c <setLED_B>
 8017338:	e6c7      	b.n	80170ca <SFXVocoderFrame+0x52>
 801733a:	bf00      	nop

0801733c <SFXVocoderTick>:
            if (internalExternal == 1)
 801733c:	f240 539c 	movw	r3, #1436	; 0x59c
 8017340:	f2c2 0300 	movt	r3, #8192	; 0x2000
        {
 8017344:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8017348:	ed2d 8b08 	vpush	{d8-d11}
            if (internalExternal == 1)
 801734c:	781b      	ldrb	r3, [r3, #0]
        {
 801734e:	4682      	mov	sl, r0
 8017350:	ed90 8a01 	vldr	s16, [r0, #4]
            if (internalExternal == 1)
 8017354:	2b01      	cmp	r3, #1
 8017356:	f000 80f4 	beq.w	8017542 <SFXVocoderTick+0x206>
                zerocross = tZeroCrossing_tick(&zerox, input[1]);
 801735a:	f247 6090 	movw	r0, #30352	; 0x7690
 801735e:	eeb0 0a48 	vmov.f32	s0, s16
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8017362:	f248 7694 	movw	r6, #34708	; 0x8794
                zerocross = tZeroCrossing_tick(&zerox, input[1]);
 8017366:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801736a:	f00a ffa1 	bl	80222b0 <tZeroCrossing_tick>
                if (!vocChFreeze)
 801736e:	f240 6310 	movw	r3, #1552	; 0x610
 8017372:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017376:	681b      	ldr	r3, [r3, #0]
 8017378:	2b00      	cmp	r3, #0
 801737a:	f000 80c1 	beq.w	8017500 <SFXVocoderTick+0x1c4>
 801737e:	f2c2 0601 	movt	r6, #8193	; 0x2001
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8017382:	f248 2028 	movw	r0, #33320	; 0x8228
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017386:	2500      	movs	r5, #0
 8017388:	f247 5920 	movw	r9, #29984	; 0x7520
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 801738c:	f247 28dc 	movw	r8, #29404	; 0x72dc
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8017390:	f2c2 0001 	movt	r0, #8193	; 0x2001
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017394:	462f      	mov	r7, r5
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 8017396:	f00e fe05 	bl	8025fa4 <tExpSmooth_tick>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 801739a:	f243 4064 	movw	r0, #13412	; 0x3464
                noiseRampVal = tExpSmooth_tick(&noiseRamp);
 801739e:	eeb0 ba40 	vmov.f32	s22, s0
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80173a2:	f2c2 0901 	movt	r9, #8193	; 0x2001
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 80173a6:	f2c2 0000 	movt	r0, #8192	; 0x2000
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80173aa:	f2c2 0801 	movt	r8, #8193	; 0x2001
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 80173ae:	f011 fb17 	bl	80289e0 <tNoise_tick>
 80173b2:	f649 139a 	movw	r3, #39322	; 0x999a
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80173b6:	f243 3233 	movw	r2, #13107	; 0x3333
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 80173ba:	ee20 0a0b 	vmul.f32	s0, s0, s22
 80173be:	f6c3 7319 	movt	r3, #16153	; 0x3f19
            float sample = 0.0f;
 80173c2:	ee09 5a10 	vmov	s18, r5
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80173c6:	f6c3 72f3 	movt	r2, #16371	; 0x3ff3
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 80173ca:	ee07 3a90 	vmov	s15, r3
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80173ce:	ee0a 2a90 	vmov	s21, r2
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal * 0.6f;
 80173d2:	ee20 aa27 	vmul.f32	s20, s0, s15
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80173d6:	e02c      	b.n	8017432 <SFXVocoderTick+0xf6>
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80173d8:	f011 fa92 	bl	8028900 <tSawtooth_tick>
 80173dc:	f647 101c 	movw	r0, #31004	; 0x791c
 80173e0:	eef0 8a40 	vmov.f32	s17, s0
 80173e4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80173e8:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 80173ec:	182c      	adds	r4, r5, r0
 80173ee:	4620      	mov	r0, r4
 80173f0:	f00e fdd8 	bl	8025fa4 <tExpSmooth_tick>
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 80173f4:	f642 0048 	movw	r0, #10312	; 0x2848
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 80173f8:	edd6 7a03 	vldr	s15, [r6, #12]
 80173fc:	ee68 8a80 	vmul.f32	s17, s17, s0
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 8017400:	f2c2 0000 	movt	r0, #8192	; 0x2000
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 8017404:	ee38 8a67 	vsub.f32	s16, s16, s15
                    sample += tRosenbergGlottalPulse_tickHQ(&glottal[i]) * tExpSmooth_tick(&polyRamp[i]) * 1.9f * displayValues[3];
 8017408:	4428      	add	r0, r5
 801740a:	3504      	adds	r5, #4
 801740c:	f00d f86a 	bl	80244e4 <tRosenbergGlottalPulse_tickHQ>
 8017410:	4620      	mov	r0, r4
 8017412:	eef0 9a40 	vmov.f32	s19, s0
 8017416:	f00e fdc5 	bl	8025fa4 <tExpSmooth_tick>
 801741a:	edd6 7a03 	vldr	s15, [r6, #12]
 801741e:	ee67 7aaa 	vmul.f32	s15, s15, s21
 8017422:	ee67 7aa9 	vmul.f32	s15, s15, s19
 8017426:	ee27 0a80 	vmul.f32	s0, s15, s0
 801742a:	eea8 0a88 	vfma.f32	s0, s17, s16
 801742e:	ee39 9a00 	vadd.f32	s18, s18, s0
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017432:	4648      	mov	r0, r9
 8017434:	f011 f94e 	bl	80286d4 <tSimplePoly_getNumVoices>
 8017438:	42b8      	cmp	r0, r7
                    sample += tSawtooth_tick(&osc[i]) * tExpSmooth_tick(&polyRamp[i]) * (1.0f - displayValues[3]);
 801743a:	eb08 0005 	add.w	r0, r8, r5
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801743e:	f107 0701 	add.w	r7, r7, #1
 8017442:	dcc9      	bgt.n	80173d8 <SFXVocoderTick+0x9c>
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
 8017444:	f649 139a 	movw	r3, #39322	; 0x999a
 8017448:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801744c:	edd6 6a05 	vldr	s13, [r6, #20]
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8017450:	f642 0018 	movw	r0, #10264	; 0x2818
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
 8017454:	f6c3 6399 	movt	r3, #16025	; 0x3e99
 8017458:	ee37 8acb 	vsub.f32	s16, s15, s22
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 801745c:	f2c2 0000 	movt	r0, #8192	; 0x2000
                sample = (sample * (1.0f - (0.3f * displayValues[5])) * (1.0f-noiseRampVal)) + noiseSample;
 8017460:	ee07 3a10 	vmov	s14, r3
 8017464:	eee6 7ac7 	vfms.f32	s15, s13, s14
 8017468:	ee27 8a88 	vmul.f32	s16, s15, s16
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 801746c:	f011 fab8 	bl	80289e0 <tNoise_tick>
 8017470:	f243 405c 	movw	r0, #13404	; 0x345c
 8017474:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017478:	f00f f8dc 	bl	8026634 <tHighpass_tick>
 801747c:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
 8017480:	edd6 7a05 	vldr	s15, [r6, #20]
                sample *= tExpSmooth_tick(&comp);
 8017484:	f247 205c 	movw	r0, #29276	; 0x725c
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8017488:	ee67 7a87 	vmul.f32	s15, s15, s14
                sample *= tExpSmooth_tick(&comp);
 801748c:	f2c2 0001 	movt	r0, #8193	; 0x2001
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[5] * 1.5f);
 8017490:	ee27 0a80 	vmul.f32	s0, s15, s0
 8017494:	eea9 0a08 	vfma.f32	s0, s18, s16
 8017498:	ee3a aa00 	vadd.f32	s20, s20, s0
                sample *= tExpSmooth_tick(&comp);
 801749c:	f00e fd82 	bl	8025fa4 <tExpSmooth_tick>
 80174a0:	ed9a 8a01 	vldr	s16, [sl, #4]
 80174a4:	ee2a 0a00 	vmul.f32	s0, s20, s0
            sample = tanhf(sample);
 80174a8:	f014 f85c 	bl	802b564 <tanhf>
            sample = tTalkboxFloat_tick(&vocoder, sample, input[1]);
 80174ac:	f248 1040 	movw	r0, #33088	; 0x8140
 80174b0:	eef0 0a48 	vmov.f32	s1, s16
 80174b4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80174b8:	f00c fe7a 	bl	80241b0 <tTalkboxFloat_tick>
            sample = tVZFilter_tick(&shelf1, sample); //put it through the low shelf
 80174bc:	f247 40fc 	movw	r0, #29948	; 0x74fc
 80174c0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80174c4:	f00f fada 	bl	8026a7c <tVZFilter_tick>
            sample = tVZFilter_tick(&shelf2, sample); // now put that result through the high shelf
 80174c8:	f247 4024 	movw	r0, #29732	; 0x7424
 80174cc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80174d0:	f00f fad4 	bl	8026a7c <tVZFilter_tick>
            sample *= displayValues[0] * 0.6f;
 80174d4:	f649 139a 	movw	r3, #39322	; 0x999a
 80174d8:	ed96 7a00 	vldr	s14, [r6]
 80174dc:	f6c3 7319 	movt	r3, #16153	; 0x3f19
 80174e0:	ee07 3a90 	vmov	s15, r3
 80174e4:	ee67 7a27 	vmul.f32	s15, s14, s15
            sample = tanhf(sample);
 80174e8:	ee27 0a80 	vmul.f32	s0, s15, s0
 80174ec:	f014 f83a 	bl	802b564 <tanhf>
            input[0] = sample;
 80174f0:	ed8a 0a00 	vstr	s0, [sl]
            input[1] = sample;
 80174f4:	ed8a 0a01 	vstr	s0, [sl, #4]
        }
 80174f8:	ecbd 8b08 	vpop	{d8-d11}
 80174fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 8017500:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8017504:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8017508:	2200      	movs	r2, #0
 801750a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801750e:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 8017512:	edd6 6a04 	vldr	s13, [r6, #16]
 8017516:	ee07 2a10 	vmov	s14, r2
 801751a:	f248 2028 	movw	r0, #33320	; 0x8228
 801751e:	ee07 3a90 	vmov	s15, r3
 8017522:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017526:	ee76 7ae7 	vsub.f32	s15, s13, s15
 801752a:	eef4 7ac0 	vcmpe.f32	s15, s0
 801752e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8017532:	bf54      	ite	pl
 8017534:	eeb0 0a47 	vmovpl.f32	s0, s14
 8017538:	eeb0 0a46 	vmovmi.f32	s0, s12
 801753c:	f00e fd28 	bl	8025f90 <tExpSmooth_setDest>
 8017540:	e71f      	b.n	8017382 <SFXVocoderTick+0x46>
 8017542:	f248 7694 	movw	r6, #34708	; 0x8794
                sample = input[0];
 8017546:	ed90 0a00 	vldr	s0, [r0]
 801754a:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801754e:	e7ab      	b.n	80174a8 <SFXVocoderTick+0x16c>

08017550 <SFXVocoderFree>:
            tTalkboxFloat_free(&vocoder);
 8017550:	f248 1040 	movw	r0, #33088	; 0x8140
        {
 8017554:	b570      	push	{r4, r5, r6, lr}
            tTalkboxFloat_free(&vocoder);
 8017556:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801755a:	f247 26dc 	movw	r6, #29404	; 0x72dc
 801755e:	f00c fba1 	bl	8023ca4 <tTalkboxFloat_free>
            tNoise_free(&vocoderNoise);
 8017562:	f243 4064 	movw	r0, #13412	; 0x3464
 8017566:	f642 0548 	movw	r5, #10312	; 0x2848
            tVZFilter_free(&shelf2);
 801756a:	2400      	movs	r4, #0
            tNoise_free(&vocoderNoise);
 801756c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017570:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8017574:	f011 fa30 	bl	80289d8 <tNoise_free>
            tZeroCrossing_free(&zerox);
 8017578:	f247 6090 	movw	r0, #30352	; 0x7690
 801757c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8017580:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017584:	f00a fe84 	bl	8022290 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
 8017588:	f248 2028 	movw	r0, #33320	; 0x8228
 801758c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017590:	f00e fce8 	bl	8025f64 <tExpSmooth_free>
            tNoise_free(&breathNoise);
 8017594:	f642 0018 	movw	r0, #10264	; 0x2818
 8017598:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801759c:	f011 fa1c 	bl	80289d8 <tNoise_free>
            tHighpass_free(&noiseHP);
 80175a0:	f243 405c 	movw	r0, #13404	; 0x345c
 80175a4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80175a8:	f00f f830 	bl	802660c <tHighpass_free>
            tVZFilter_free(&shelf1);
 80175ac:	f247 40fc 	movw	r0, #29948	; 0x74fc
 80175b0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80175b4:	f00f fa54 	bl	8026a60 <tVZFilter_free>
            tVZFilter_free(&shelf2);
 80175b8:	f247 4024 	movw	r0, #29732	; 0x7424
 80175bc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80175c0:	f00f fa4e 	bl	8026a60 <tVZFilter_free>
                tSawtooth_free(&osc[i]);
 80175c4:	1930      	adds	r0, r6, r4
 80175c6:	f011 f963 	bl	8028890 <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
 80175ca:	1928      	adds	r0, r5, r4
 80175cc:	3404      	adds	r4, #4
 80175ce:	f00c ff15 	bl	80243fc <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80175d2:	2c20      	cmp	r4, #32
 80175d4:	d1f6      	bne.n	80175c4 <SFXVocoderFree+0x74>
        }
 80175d6:	bd70      	pop	{r4, r5, r6, pc}

080175d8 <SFXVocoderChAlloc>:
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80175d8:	f240 2151 	movw	r1, #593	; 0x251
 80175dc:	f247 02a4 	movw	r2, #28836	; 0x70a4
 80175e0:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80175e4:	f243 3333 	movw	r3, #13107	; 0x3333
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80175e8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80175ec:	f6c3 727d 	movt	r2, #16253	; 0x3f7d
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80175f0:	f2c4 1387 	movt	r3, #16775	; 0x4187
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80175f4:	f64c 40cd 	movw	r0, #52429	; 0xcccd
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 80175f8:	ee06 2a90 	vmov	s13, r2
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80175fc:	eeb0 2a00 	vmov.f32	s4, #0	; 0x40000000  2.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017600:	ee07 3a10 	vmov	s14, r3
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017604:	f64a 23ab 	movw	r3, #43691	; 0xaaab
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8017608:	2200      	movs	r2, #0
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 801760a:	eeff 3a00 	vmov.f32	s7, #240	; 0xbf800000 -1.0
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801760e:	f6c3 53aa 	movt	r3, #15786	; 0x3daa
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017612:	eef2 1a00 	vmov.f32	s3, #32	; 0x41000000  8.0
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8017616:	f2c4 22c6 	movt	r2, #17094	; 0x42c6
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801761a:	f240 2c44 	movw	ip, #580	; 0x244
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 801761e:	eef0 0a08 	vmov.f32	s1, #8	; 0x40400000  3.0
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017622:	f2c2 0c00 	movt	ip, #8192	; 0x2000
        {
 8017626:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801762a:	ed2d 8b04 	vpush	{d8-d9}
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801762e:	7809      	ldrb	r1, [r1, #0]
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017630:	f642 5410 	movw	r4, #11536	; 0x2d10
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017634:	f64c 45cd 	movw	r5, #52429	; 0xcccd
        {
 8017638:	b083      	sub	sp, #12
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 801763a:	ee07 1a90 	vmov	s15, r1
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 801763e:	f2c2 0400 	movt	r4, #8192	; 0x2000
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017642:	f6c3 55cc 	movt	r5, #15820	; 0x3dcc
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017646:	4601      	mov	r1, r0
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017648:	eef8 7a67 	vcvt.f32.u32	s15, s15
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801764c:	ed94 6a1b 	vldr	s12, [r4, #108]	; 0x6c
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017650:	ee04 5a10 	vmov	s8, r5
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017654:	f6c3 704c 	movt	r0, #16204	; 0x3f4c
 8017658:	f6cb 61cc 	movt	r1, #48844	; 0xbecc
 801765c:	ed94 5a1a 	vldr	s10, [r4, #104]	; 0x68
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017660:	ee77 7ae6 	vsub.f32	s15, s15, s13
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017664:	ee04 0a90 	vmov	s9, r0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017668:	ee66 6a07 	vmul.f32	s13, s12, s14
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 801766c:	ee06 1a10 	vmov	s12, r1
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8017670:	ee07 2a10 	vmov	s14, r2
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017674:	2200      	movs	r2, #0
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017676:	eec5 2aa7 	vdiv.f32	s5, s11, s15
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 801767a:	edd4 7a1c 	vldr	s15, [r4, #112]	; 0x70
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 801767e:	ed94 1a25 	vldr	s2, [r4, #148]	; 0x94
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017682:	f243 4568 	movw	r5, #13416	; 0x3468
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8017686:	6fe7      	ldr	r7, [r4, #124]	; 0x7c
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017688:	f2c4 2270 	movt	r2, #17008	; 0x4270
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801768c:	f2c2 0500 	movt	r5, #8192	; 0x2000
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017690:	ed94 3a24 	vldr	s6, [r4, #144]	; 0x90
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 8017694:	edd4 5a23 	vldr	s11, [r4, #140]	; 0x8c
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017698:	f44f 4100 	mov.w	r1, #32768	; 0x8000
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 801769c:	eefc 6ae6 	vcvt.u32.f32	s13, s13
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 80176a0:	9501      	str	r5, [sp, #4]
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 80176a2:	eea7 4a82 	vfma.f32	s8, s15, s4
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 80176a6:	ee07 3a90 	vmov	s15, r3
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 80176aa:	eea5 6a24 	vfma.f32	s12, s10, s9
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 80176ae:	ee05 2a10 	vmov	s10, r2
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80176b2:	edcd 6a00 	vstr	s13, [sp]
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 80176b6:	eef0 4a63 	vmov.f32	s9, s7
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80176ba:	f89d 3000 	ldrb.w	r3, [sp]
 80176be:	f247 4528 	movw	r5, #29736	; 0x7428
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 80176c2:	ee75 5aa5 	vadd.f32	s11, s11, s11
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 80176c6:	f8d4 e078 	ldr.w	lr, [r4, #120]	; 0x78
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80176ca:	ee06 3a90 	vmov	s13, r3
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 80176ce:	f248 7394 	movw	r3, #34708	; 0x8794
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 80176d2:	eee1 4a02 	vfma.f32	s9, s2, s4
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 80176d6:	f8d4 9064 	ldr.w	r9, [r4, #100]	; 0x64
 80176da:	f2c2 0301 	movt	r3, #8193	; 0x2001
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80176de:	eef8 6ae6 	vcvt.f32.s32	s13, s13
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 80176e2:	ee23 5a05 	vmul.f32	s10, s6, s10
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 80176e6:	f8d4 8074 	ldr.w	r8, [r4, #116]	; 0x74
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 80176ea:	619f      	str	r7, [r3, #24]
 80176ec:	f2c2 0501 	movt	r5, #8193	; 0x2001
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 80176f0:	ee22 7a87 	vmul.f32	s14, s5, s14
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 80176f4:	f8d4 7080 	ldr.w	r7, [r4, #128]	; 0x80
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 80176f8:	ee76 6aa1 	vadd.f32	s13, s13, s3
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 80176fc:	f247 5a14 	movw	sl, #29972	; 0x7514
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 8017700:	61df      	str	r7, [r3, #28]
            thisBandwidth = bandWidthInOctaves * myQ;
 8017702:	f642 0640 	movw	r6, #10304	; 0x2840
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017706:	ee67 7a27 	vmul.f32	s15, s14, s15
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 801770a:	f8d4 7084 	ldr.w	r7, [r4, #132]	; 0x84
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 801770e:	f2c4 51bb 	movt	r1, #17851	; 0x45bb
 8017712:	f248 22f8 	movw	r2, #33528	; 0x82f8
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 8017716:	621f      	str	r7, [r3, #32]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017718:	f247 50f0 	movw	r0, #30192	; 0x75f0
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 801771c:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
            thisBandwidth = bandWidthInOctaves * myQ;
 8017720:	ee64 3a27 	vmul.f32	s7, s8, s15
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017724:	f8c3 9000 	str.w	r9, [r3]
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 8017728:	f2c2 0a01 	movt	sl, #8193	; 0x2001
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 801772c:	f8c3 8010 	str.w	r8, [r3, #16]
            thisBandwidth = bandWidthInOctaves * myQ;
 8017730:	f2c2 0600 	movt	r6, #8192	; 0x2000
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017734:	edc3 6a02 	vstr	s13, [r3, #8]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017738:	ee00 1a10 	vmov	s0, r1
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 801773c:	ed83 6a01 	vstr	s12, [r3, #4]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017740:	f2c2 0201 	movt	r2, #8193	; 0x2001
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8017744:	f8c3 e014 	str.w	lr, [r3, #20]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017748:	f2c2 0001 	movt	r0, #8193	; 0x2001
            displayValues[10] = presetKnobValues[VocoderCh][10] * 2.0f; //bandsquish
 801774c:	edc3 5a0a 	vstr	s11, [r3, #40]	; 0x28
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 8017750:	2107      	movs	r1, #7
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017752:	ed83 5a0b 	vstr	s10, [r3, #44]	; 0x2c
 8017756:	f248 2b38 	movw	fp, #33336	; 0x8238
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 2.0f) - 1.0f; //tilt
 801775a:	edc3 4a0c 	vstr	s9, [r3, #48]	; 0x30
 801775e:	f247 2978 	movw	r9, #29304	; 0x7278
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 8017762:	625f      	str	r7, [r3, #36]	; 0x24
 8017764:	f2c2 0b01 	movt	fp, #8193	; 0x2001
 8017768:	9500      	str	r5, [sp, #0]
 801776a:	f2c2 0901 	movt	r9, #8193	; 0x2001
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 801776e:	f8d4 7098 	ldr.w	r7, [r4, #152]	; 0x98
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 8017772:	f04f 0801 	mov.w	r8, #1
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
 8017776:	f8d4 409c 	ldr.w	r4, [r4, #156]	; 0x9c
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801777a:	9d01      	ldr	r5, [sp, #4]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 801777c:	635f      	str	r7, [r3, #52]	; 0x34
 801777e:	f247 672c 	movw	r7, #30252	; 0x762c
            displayValues[14] = presetKnobValues[VocoderCh][14]; //odd/even
 8017782:	639c      	str	r4, [r3, #56]	; 0x38
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 8017784:	2400      	movs	r4, #0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017786:	ed83 4a03 	vstr	s8, [r3, #12]
 801778a:	f2c2 0701 	movt	r7, #8193	; 0x2001
            bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 801778e:	edc5 7a00 	vstr	s15, [r5]
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
 8017792:	ee09 4a10 	vmov	s18, r4
            invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017796:	edcc 2a00 	vstr	s5, [ip]
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 801779a:	4625      	mov	r5, r4
            bandWidthInSemitones = 99.0f * invNumberOfVocoderBands;
 801779c:	ed8a 7a00 	vstr	s14, [sl]
            thisBandwidth = bandWidthInOctaves * myQ;
 80177a0:	edc6 3a00 	vstr	s7, [r6]
            tVZFilter_initToPool(&vocodec_highshelf, Highshelf, 6000.0f, 3.0f, &smallPool);
 80177a4:	f00e ff56 	bl	8026654 <tVZFilter_initToPool>
            tVZFilter_setGain(&vocodec_highshelf, 4.0f);
 80177a8:	f247 50f0 	movw	r0, #30192	; 0x75f0
 80177ac:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 80177b0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80177b4:	f00f fdc8 	bl	8027348 <tVZFilter_setGain>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
 80177b8:	f241 236f 	movw	r3, #4719	; 0x126f
 80177bc:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 80177c0:	ee08 3a90 	vmov	s17, r3
 80177c4:	e004      	b.n	80177d0 <SFXVocoderChAlloc+0x1f8>
 80177c6:	3501      	adds	r5, #1
 80177c8:	f108 0801 	add.w	r8, r8, #1
 80177cc:	3704      	adds	r7, #4
 80177ce:	3408      	adds	r4, #8
                float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 80177d0:	ee07 5a90 	vmov	s15, r5
 80177d4:	eeb3 0a0e 	vmov.f32	s0, #62	; 0x41f00000  30.0
 80177d8:	ed9a 7a00 	vldr	s14, [sl]
 80177dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80177e0:	eea7 0a87 	vfma.f32	s0, s15, s14
 80177e4:	f010 fa64 	bl	8027cb0 <faster_mtof>
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 80177e8:	f248 22f8 	movw	r2, #33528	; 0x82f8
                bandGains[i] = 1.0f;
 80177ec:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
                float bandFreq = faster_mtof((i * bandWidthInSemitones) + 30.0f); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 80177f0:	eeb0 8a40 	vmov.f32	s16, s0
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 80177f4:	eb0b 0004 	add.w	r0, fp, r4
 80177f8:	2103      	movs	r1, #3
 80177fa:	f2c2 0201 	movt	r2, #8193	; 0x2001
                bandGains[i] = 1.0f;
 80177fe:	f849 3b04 	str.w	r3, [r9], #4
                if (i == 0)
 8017802:	2d00      	cmp	r5, #0
 8017804:	f000 8136 	beq.w	8017a74 <SFXVocoderChAlloc+0x49c>
 8017808:	edd6 7a00 	vldr	s15, [r6]
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
 801780c:	2d17      	cmp	r5, #23
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 801780e:	eef0 0a67 	vmov.f32	s1, s15
                else if (i == (MAX_NUM_VOCODER_BANDS-1))
 8017812:	f000 80e6 	beq.w	80179e2 <SFXVocoderChAlloc+0x40a>
                    tVZFilter_initToPool(&analysisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 8017816:	f00e ff1d 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 801781a:	f248 233c 	movw	r3, #33340	; 0x823c
 801781e:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017822:	edd6 0a00 	vldr	s1, [r6]
 8017826:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801782a:	eeb0 0a48 	vmov.f32	s0, s16
 801782e:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017832:	2103      	movs	r1, #3
 8017834:	1918      	adds	r0, r3, r4
 8017836:	f00e ff0d 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 801783a:	9b00      	ldr	r3, [sp, #0]
 801783c:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017840:	edd6 0a00 	vldr	s1, [r6]
 8017844:	1918      	adds	r0, r3, r4
 8017846:	eeb0 0a48 	vmov.f32	s0, s16
 801784a:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801784e:	2103      	movs	r1, #3
 8017850:	f00e ff00 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], BandpassPeak, bandFreq, thisBandwidth, &smallPool);
 8017854:	f247 432c 	movw	r3, #29740	; 0x742c
 8017858:	f248 22f8 	movw	r2, #33528	; 0x82f8
 801785c:	eeb0 0a48 	vmov.f32	s0, s16
 8017860:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8017864:	edd6 0a00 	vldr	s1, [r6]
 8017868:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801786c:	2103      	movs	r1, #3
 801786e:	1918      	adds	r0, r3, r4
 8017870:	f00e fef0 	bl	8026654 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
 8017874:	f248 21f8 	movw	r1, #33528	; 0x82f8
 8017878:	eef0 0a68 	vmov.f32	s1, s17
 801787c:	4638      	mov	r0, r7
 801787e:	eeb0 0a49 	vmov.f32	s0, s18
 8017882:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8017886:	f00e fb47 	bl	8025f18 <tExpSmooth_initToPool>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
 801788a:	f1b8 0f18 	cmp.w	r8, #24
 801788e:	d19a      	bne.n	80177c6 <SFXVocoderChAlloc+0x1ee>
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
 8017890:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017894:	f642 0018 	movw	r0, #10264	; 0x2818
 8017898:	2100      	movs	r1, #0
            tSimplePoly_setNumVoices(&poly, numVoices);
 801789a:	f240 2950 	movw	r9, #592	; 0x250
            tNoise_initToPool(&breathNoise, WhiteNoise, &smallPool);
 801789e:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80178a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80178a6:	f011 f885 	bl	80289b4 <tNoise_initToPool>
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
 80178aa:	f248 22f8 	movw	r2, #33528	; 0x82f8
 80178ae:	f243 4064 	movw	r0, #13412	; 0x3464
 80178b2:	2100      	movs	r1, #0
 80178b4:	f2c2 0201 	movt	r2, #8193	; 0x2001
            tSimplePoly_setNumVoices(&poly, numVoices);
 80178b8:	f2c2 0900 	movt	r9, #8192	; 0x2000
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
 80178bc:	f2c2 0000 	movt	r0, #8192	; 0x2000
                tSawtooth_initToPool(&osc[i], &smallPool);
 80178c0:	f248 26f8 	movw	r6, #33528	; 0x82f8
            tNoise_initToPool(&vocoderNoise, WhiteNoise, &smallPool);
 80178c4:	f011 f876 	bl	80289b4 <tNoise_initToPool>
            tZeroCrossing_initToPool(&zerox, 256, &smallPool);
 80178c8:	f248 22f8 	movw	r2, #33528	; 0x82f8
 80178cc:	f247 6090 	movw	r0, #30352	; 0x7690
 80178d0:	f44f 7180 	mov.w	r1, #256	; 0x100
 80178d4:	f2c2 0201 	movt	r2, #8193	; 0x2001
                tSawtooth_initToPool(&osc[i], &smallPool);
 80178d8:	f2c2 0601 	movt	r6, #8193	; 0x2001
            tZeroCrossing_initToPool(&zerox, 256, &smallPool);
 80178dc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80178e0:	f247 28dc 	movw	r8, #29404	; 0x72dc
 80178e4:	f00a fcae 	bl	8022244 <tZeroCrossing_initToPool>
            tSimplePoly_setNumVoices(&poly, numVoices);
 80178e8:	f247 5020 	movw	r0, #29984	; 0x7520
 80178ec:	f899 1000 	ldrb.w	r1, [r9]
 80178f0:	f642 0748 	movw	r7, #10312	; 0x2848
 80178f4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80178f8:	f2c2 0801 	movt	r8, #8193	; 0x2001
 80178fc:	f010 fee2 	bl	80286c4 <tSimplePoly_setNumVoices>
            tExpSmooth_initToPool(&noiseRamp, 0.0f, 0.05f, &smallPool);
 8017900:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8017904:	2200      	movs	r2, #0
 8017906:	f248 2028 	movw	r0, #33320	; 0x8228
 801790a:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
 801790e:	4631      	mov	r1, r6
 8017910:	ee00 2a10 	vmov	s0, r2
 8017914:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017918:	ee00 3a90 	vmov	s1, r3
 801791c:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8017920:	f00e fafa 	bl	8025f18 <tExpSmooth_initToPool>
            tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
 8017924:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8017928:	f243 405c 	movw	r0, #13404	; 0x345c
 801792c:	4631      	mov	r1, r6
 801792e:	f2c4 539c 	movt	r3, #17820	; 0x459c
            tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
 8017932:	2400      	movs	r4, #0
            tHighpass_initToPool(&noiseHP, 5000.0f, &smallPool);
 8017934:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017938:	ee00 3a10 	vmov	s0, r3
 801793c:	f00e fe44 	bl	80265c8 <tHighpass_initToPool>
            tHighpass_initToPool(&chVocFinalHP1, 20.0f, &smallPool);
 8017940:	f642 003c 	movw	r0, #10300	; 0x283c
 8017944:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8017948:	4631      	mov	r1, r6
 801794a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801794e:	f00e fe3b 	bl	80265c8 <tHighpass_initToPool>
            tHighpass_initToPool(&chVocFinalHP2, 20.0f, &smallPool);
 8017952:	f248 202c 	movw	r0, #33324	; 0x822c
 8017956:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801795a:	4631      	mov	r1, r6
 801795c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017960:	f00e fe32 	bl	80265c8 <tHighpass_initToPool>
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 8017964:	f649 129a 	movw	r2, #39322	; 0x999a
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 8017968:	f64c 43cd 	movw	r3, #52429	; 0xcccd
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 801796c:	f6c3 6299 	movt	r2, #16025	; 0x3e99
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 8017970:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 8017974:	ee08 2a90 	vmov	s17, r2
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 8017978:	ee08 3a10 	vmov	s16, r3
 801797c:	193d      	adds	r5, r7, r4
                tSawtooth_initToPool(&osc[i], &smallPool);
 801797e:	eb08 0004 	add.w	r0, r8, r4
 8017982:	4631      	mov	r1, r6
 8017984:	3404      	adds	r4, #4
 8017986:	f010 ff5d 	bl	8028844 <tSawtooth_initToPool>
                tRosenbergGlottalPulse_initToPool(&glottal[i], &smallPool);
 801798a:	4631      	mov	r1, r6
 801798c:	4628      	mov	r0, r5
 801798e:	f00c fd25 	bl	80243dc <tRosenbergGlottalPulse_initToPool>
                tRosenbergGlottalPulse_setOpenLength(&glottal[i], 0.3f);
 8017992:	eeb0 0a68 	vmov.f32	s0, s17
 8017996:	4628      	mov	r0, r5
 8017998:	f00c fe26 	bl	80245e8 <tRosenbergGlottalPulse_setOpenLength>
                tRosenbergGlottalPulse_setPulseLength(&glottal[i], 0.4f);
 801799c:	eeb0 0a48 	vmov.f32	s0, s16
 80179a0:	4628      	mov	r0, r5
 80179a2:	f00c fe2f 	bl	8024604 <tRosenbergGlottalPulse_setPulseLength>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80179a6:	2c20      	cmp	r4, #32
 80179a8:	d1e8      	bne.n	801797c <SFXVocoderChAlloc+0x3a4>
            setLED_A(numVoices == 1);
 80179aa:	f899 0000 	ldrb.w	r0, [r9]
 80179ae:	f1a0 0001 	sub.w	r0, r0, #1
 80179b2:	fab0 f080 	clz	r0, r0
 80179b6:	0940      	lsrs	r0, r0, #5
 80179b8:	f7fd ff98 	bl	80158ec <setLED_A>
            setLED_B(internalExternal);
 80179bc:	f240 539c 	movw	r3, #1436	; 0x59c
 80179c0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80179c4:	7818      	ldrb	r0, [r3, #0]
 80179c6:	f7fd ffa1 	bl	801590c <setLED_B>
            setLED_C(vocChFreeze);
 80179ca:	f240 6310 	movw	r3, #1552	; 0x610
 80179ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80179d2:	7818      	ldrb	r0, [r3, #0]
        }
 80179d4:	b003      	add	sp, #12
 80179d6:	ecbd 8b04 	vpop	{d8-d9}
 80179da:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            setLED_C(vocChFreeze);
 80179de:	f7fd bfa5 	b.w	801592c <setLED_C>
                    tVZFilter_initToPool(&analysisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
 80179e2:	f248 22f8 	movw	r2, #33528	; 0x82f8
 80179e6:	f248 20f0 	movw	r0, #33520	; 0x82f0
 80179ea:	2100      	movs	r1, #0
 80179ec:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80179f0:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80179f4:	f00e fe2e 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
 80179f8:	f248 22f8 	movw	r2, #33528	; 0x82f8
 80179fc:	f248 20f4 	movw	r0, #33524	; 0x82f4
 8017a00:	edd6 0a00 	vldr	s1, [r6]
 8017a04:	eeb0 0a48 	vmov.f32	s0, s16
 8017a08:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017a0c:	2100      	movs	r1, #0
 8017a0e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017a12:	f00e fe1f 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], Highpass, bandFreq, thisBandwidth, &smallPool);
 8017a16:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017a1a:	f247 40e0 	movw	r0, #29920	; 0x74e0
 8017a1e:	edd6 0a00 	vldr	s1, [r6]
 8017a22:	eeb0 0a48 	vmov.f32	s0, s16
 8017a26:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017a2a:	2100      	movs	r1, #0
 8017a2c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017a30:	f00e fe10 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], Highpass, bandFreq, thisBandwidth, &smallPool);
 8017a34:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017a38:	f247 40e4 	movw	r0, #29924	; 0x74e4
 8017a3c:	eeb0 0a48 	vmov.f32	s0, s16
 8017a40:	edd6 0a00 	vldr	s1, [r6]
 8017a44:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017a48:	2100      	movs	r1, #0
 8017a4a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017a4e:	f00e fe01 	bl	8026654 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
 8017a52:	f241 236f 	movw	r3, #4719	; 0x126f
 8017a56:	2200      	movs	r2, #0
 8017a58:	f248 21f8 	movw	r1, #33528	; 0x82f8
 8017a5c:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 8017a60:	4638      	mov	r0, r7
 8017a62:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8017a66:	ee00 2a10 	vmov	s0, r2
 8017a6a:	ee00 3a90 	vmov	s1, r3
 8017a6e:	f00e fa53 	bl	8025f18 <tExpSmooth_initToPool>
 8017a72:	e70d      	b.n	8017890 <SFXVocoderChAlloc+0x2b8>
                    tVZFilter_initToPool(&analysisBands[i][0], Lowpass, bandFreq, thisBandwidth, &smallPool);
 8017a74:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017a78:	edd6 0a00 	vldr	s1, [r6]
 8017a7c:	4658      	mov	r0, fp
 8017a7e:	2101      	movs	r1, #1
 8017a80:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017a84:	f00e fde6 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&analysisBands[i][1], Lowpass, bandFreq, thisBandwidth, &smallPool);
 8017a88:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017a8c:	f248 203c 	movw	r0, #33340	; 0x823c
 8017a90:	edd6 0a00 	vldr	s1, [r6]
 8017a94:	eeb0 0a48 	vmov.f32	s0, s16
 8017a98:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017a9c:	2101      	movs	r1, #1
 8017a9e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017aa2:	f00e fdd7 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][0], Lowpass, bandFreq,thisBandwidth, &smallPool);
 8017aa6:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017aaa:	edd6 0a00 	vldr	s1, [r6]
 8017aae:	eeb0 0a48 	vmov.f32	s0, s16
 8017ab2:	9800      	ldr	r0, [sp, #0]
 8017ab4:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017ab8:	2101      	movs	r1, #1
 8017aba:	f00e fdcb 	bl	8026654 <tVZFilter_initToPool>
                    tVZFilter_initToPool(&synthesisBands[i][1], Lowpass, bandFreq,thisBandwidth, &smallPool);
 8017abe:	f248 22f8 	movw	r2, #33528	; 0x82f8
 8017ac2:	f247 402c 	movw	r0, #29740	; 0x742c
 8017ac6:	eeb0 0a48 	vmov.f32	s0, s16
 8017aca:	edd6 0a00 	vldr	s1, [r6]
 8017ace:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8017ad2:	2101      	movs	r1, #1
 8017ad4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017ad8:	f00e fdbc 	bl	8026654 <tVZFilter_initToPool>
                tExpSmooth_initToPool(&envFollowers[i], 0.0f, 0.001f, &smallPool); // factor of .001 is 10 ms?
 8017adc:	f248 21f8 	movw	r1, #33528	; 0x82f8
 8017ae0:	eef0 0a68 	vmov.f32	s1, s17
 8017ae4:	4638      	mov	r0, r7
 8017ae6:	eeb0 0a49 	vmov.f32	s0, s18
 8017aea:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8017aee:	f00e fa13 	bl	8025f18 <tExpSmooth_initToPool>
 8017af2:	e668      	b.n	80177c6 <SFXVocoderChAlloc+0x1ee>

08017af4 <SFXVocoderChFrame>:
        {
 8017af4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8017af8:	f248 64e4 	movw	r4, #34532	; 0x86e4
 8017afc:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 8017b00:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8017b04:	7d23      	ldrb	r3, [r4, #20]
        {
 8017b06:	b089      	sub	sp, #36	; 0x24
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 8017b08:	2b01      	cmp	r3, #1
 8017b0a:	d119      	bne.n	8017b40 <SFXVocoderChFrame+0x4c>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8017b0c:	f240 2550 	movw	r5, #592	; 0x250
                tSimplePoly_setNumVoices(&poly, numVoices);
 8017b10:	f247 5020 	movw	r0, #29984	; 0x7520
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8017b14:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tSimplePoly_setNumVoices(&poly, numVoices);
 8017b18:	f2c2 0001 	movt	r0, #8193	; 0x2001
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8017b1c:	782a      	ldrb	r2, [r5, #0]
 8017b1e:	2a01      	cmp	r2, #1
 8017b20:	bf98      	it	ls
 8017b22:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
 8017b24:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 8017b26:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 8017b28:	f010 fdcc 	bl	80286c4 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 8017b2c:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017b2e:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 8017b30:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8017b34:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 8017b36:	fab0 f080 	clz	r0, r0
 8017b3a:	0940      	lsrs	r0, r0, #5
 8017b3c:	f7fd fed6 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 8017b40:	7e23      	ldrb	r3, [r4, #24]
 8017b42:	2b01      	cmp	r3, #1
 8017b44:	f000 82b8 	beq.w	80180b8 <SFXVocoderChFrame+0x5c4>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 8017b48:	7f23      	ldrb	r3, [r4, #28]
 8017b4a:	2b01      	cmp	r3, #1
 8017b4c:	f000 82c6 	beq.w	80180dc <SFXVocoderChFrame+0x5e8>
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017b50:	f642 5310 	movw	r3, #11536	; 0x2d10
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017b54:	f243 3033 	movw	r0, #13107	; 0x3333
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017b58:	f64c 44cd 	movw	r4, #52429	; 0xcccd
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017b5c:	eeb0 3a00 	vmov.f32	s6, #0	; 0x40000000  2.0
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017b60:	f2c2 0300 	movt	r3, #8192	; 0x2000
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017b64:	f2c4 1087 	movt	r0, #16775	; 0x4187
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017b68:	4621      	mov	r1, r4
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017b6a:	4622      	mov	r2, r4
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017b6c:	ed93 7a1b 	vldr	s14, [r3, #108]	; 0x6c
 8017b70:	ee07 0a90 	vmov	s15, r0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017b74:	f6c3 744c 	movt	r4, #16204	; 0x3f4c
 8017b78:	f6cb 61cc 	movt	r1, #48844	; 0xbecc
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017b7c:	ee67 7a27 	vmul.f32	s15, s14, s15
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017b80:	f6c3 52cc 	movt	r2, #15820	; 0x3dcc
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017b84:	2000      	movs	r0, #0
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017b86:	ed93 6a1a 	vldr	s12, [r3, #104]	; 0x68
 8017b8a:	ee05 4a90 	vmov	s11, r4
 8017b8e:	ee06 1a90 	vmov	s13, r1
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017b92:	eefc 7ae7 	vcvt.u32.f32	s15, s15
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017b96:	ee07 2a10 	vmov	s14, r2
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017b9a:	f2c4 2070 	movt	r0, #17008	; 0x4270
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017b9e:	f248 7494 	movw	r4, #34708	; 0x8794
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8017ba2:	eeb1 5a00 	vmov.f32	s10, #16	; 0x40800000  4.0
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017ba6:	edd3 2a1c 	vldr	s5, [r3, #112]	; 0x70
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017baa:	edcd 7a00 	vstr	s15, [sp]
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8017bae:	eef8 4a00 	vmov.f32	s9, #128	; 0xc0000000 -2.0
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017bb2:	f89d 2000 	ldrb.w	r2, [sp]
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017bb6:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8017bba:	ed93 1a25 	vldr	s2, [r3, #148]	; 0x94
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017bbe:	eee6 6a25 	vfma.f32	s13, s12, s11
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017bc2:	ee07 2a90 	vmov	s15, r2
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017bc6:	ee06 0a10 	vmov	s12, r0
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8017bca:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017bcc:	eea2 7a83 	vfma.f32	s14, s5, s6
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8017bd0:	eee1 4a05 	vfma.f32	s9, s2, s10
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017bd4:	edd3 2a19 	vldr	s5, [r3, #100]	; 0x64
            displayValues[6] = presetKnobValues[VocoderCh][6]; //pulse width
 8017bd8:	61a0      	str	r0, [r4, #24]
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017bda:	eef2 1a00 	vmov.f32	s3, #32	; 0x41000000  8.0
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 8017bde:	f8d3 0080 	ldr.w	r0, [r3, #128]	; 0x80
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017be2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 8017be6:	eeb6 2a00 	vmov.f32	s4, #96	; 0x3f000000  0.5
 8017bea:	edd3 3a23 	vldr	s7, [r3, #140]	; 0x8c
            chVocOutputGain = 9.0f * displayValues[0];
 8017bee:	eeb2 5a02 	vmov.f32	s10, #34	; 0x41100000  9.0
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017bf2:	ed93 4a24 	vldr	s8, [r3, #144]	; 0x90
            oneMinusStereo = 1.0f - displayValues[13];
 8017bf6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 8017bfa:	ed93 3a26 	vldr	s6, [r3, #152]	; 0x98
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 8017bfe:	6f5e      	ldr	r6, [r3, #116]	; 0x74
            chVocOutputGain = 9.0f * displayValues[0];
 8017c00:	f240 11ec 	movw	r1, #492	; 0x1ec
            displayValues[7] = presetKnobValues[VocoderCh][7]; //pulse shape
 8017c04:	61e0      	str	r0, [r4, #28]
            oneMinusStereo = 1.0f - displayValues[13];
 8017c06:	f240 2254 	movw	r2, #596	; 0x254
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 8017c0a:	f8d3 0084 	ldr.w	r0, [r3, #132]	; 0x84
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017c0e:	ee77 7aa1 	vadd.f32	s15, s15, s3
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 8017c12:	ee73 3a82 	vadd.f32	s7, s7, s4
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8017c16:	f8d3 c078 	ldr.w	ip, [r3, #120]	; 0x78
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017c1a:	ee24 6a06 	vmul.f32	s12, s8, s12
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017c1e:	2500      	movs	r5, #0
            chVocOutputGain = 9.0f * displayValues[0];
 8017c20:	ee22 5a85 	vmul.f32	s10, s5, s10
            displayValues[4] = presetKnobValues[VocoderCh][4]; //noise thresh
 8017c24:	6126      	str	r6, [r4, #16]
            oneMinusStereo = 1.0f - displayValues[13];
 8017c26:	ee75 5ac3 	vsub.f32	s11, s11, s6
            displayValues[8] = presetKnobValues[VocoderCh][8]; //breathiness
 8017c2a:	6220      	str	r0, [r4, #32]
            chVocOutputGain = 9.0f * displayValues[0];
 8017c2c:	f2c2 0100 	movt	r1, #8192	; 0x2000
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 8017c30:	f8d3 0088 	ldr.w	r0, [r3, #136]	; 0x88
            oneMinusStereo = 1.0f - displayValues[13];
 8017c34:	f2c2 0200 	movt	r2, #8192	; 0x2000
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
 8017c38:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8017c3c:	f243 473c 	movw	r7, #13372	; 0x343c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017c40:	f247 5620 	movw	r6, #29984	; 0x7520
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017c44:	f64a 28ab 	movw	r8, #43691	; 0xaaab
            displayValues[2] = (uint8_t)(presetKnobValues[VocoderCh][2] * 16.9f) + 8.0f; //quality
 8017c48:	edc4 7a02 	vstr	s15, [r4, #8]
            displayValues[1] = (presetKnobValues[VocoderCh][1] * 0.8f) - 0.4f; //warp factor
 8017c4c:	edc4 6a01 	vstr	s13, [r4, #4]
 8017c50:	f2c2 0700 	movt	r7, #8192	; 0x2000
            displayValues[3] = (presetKnobValues[VocoderCh][3]* 2.0f) + 0.1f; //band width
 8017c54:	ed84 7a03 	vstr	s14, [r4, #12]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017c58:	f2c2 0601 	movt	r6, #8193	; 0x2001
            displayValues[5] = presetKnobValues[VocoderCh][5]; //crossfade between sawtooth and glottal pulse
 8017c5c:	f8c4 c014 	str.w	ip, [r4, #20]
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8017c60:	ee08 5a10 	vmov	s16, r5
            displayValues[10] = presetKnobValues[VocoderCh][10] + 0.5f; //bandsquish
 8017c64:	edc4 3a0a 	vstr	s7, [r4, #40]	; 0x28
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017c68:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
            displayValues[11] = presetKnobValues[VocoderCh][11] * 60.0f; //bandoffset
 8017c6c:	ed84 6a0b 	vstr	s12, [r4, #44]	; 0x2c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017c70:	46a9      	mov	r9, r5
            displayValues[9] = presetKnobValues[VocoderCh][9]; //speed
 8017c72:	6260      	str	r0, [r4, #36]	; 0x24
            displayValues[12] = (presetKnobValues[VocoderCh][12] * 4.0f) - 2.0f; //tilt
 8017c74:	edc4 4a0c 	vstr	s9, [r4, #48]	; 0x30
            displayValues[14] = presetKnobValues[VocoderCh][14]; //snap to bark scale
 8017c78:	63a3      	str	r3, [r4, #56]	; 0x38
            displayValues[0] = presetKnobValues[VocoderCh][0]; //vocoder volume
 8017c7a:	edc4 2a00 	vstr	s5, [r4]
            chVocOutputGain = 9.0f * displayValues[0];
 8017c7e:	ed81 5a00 	vstr	s10, [r1]
            displayValues[13] = presetKnobValues[VocoderCh][13]; //stereo
 8017c82:	ed84 3a0d 	vstr	s6, [r4, #52]	; 0x34
            oneMinusStereo = 1.0f - displayValues[13];
 8017c86:	edc2 5a00 	vstr	s11, [r2]
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017c8a:	e060      	b.n	8017d4e <SFXVocoderChFrame+0x25a>
 8017c8c:	eb05 0b03 	add.w	fp, r5, r3
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8017c90:	f010 fd48 	bl	8028724 <tSimplePoly_getVelocity>
 8017c94:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8017c98:	2800      	cmp	r0, #0
 8017c9a:	4658      	mov	r0, fp
 8017c9c:	fe30 0a08 	vselgt.f32	s0, s0, s16
 8017ca0:	f00e f976 	bl	8025f90 <tExpSmooth_setDest>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8017ca4:	4651      	mov	r1, sl
 8017ca6:	4630      	mov	r0, r6
 8017ca8:	f010 fd30 	bl	802870c <tSimplePoly_getPitch>
 8017cac:	f240 52d8 	movw	r2, #1496	; 0x5d8
 8017cb0:	ee07 0a90 	vmov	s15, r0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017cb4:	f240 6354 	movw	r3, #1620	; 0x654
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8017cb8:	f2c2 0200 	movt	r2, #8192	; 0x2000
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8017cbc:	f240 6120 	movw	r1, #1568	; 0x620
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8017cc0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017cc4:	f2c2 0300 	movt	r3, #8192	; 0x2000
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8017cc8:	ed92 0a00 	vldr	s0, [r2]
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8017ccc:	f2c2 0100 	movt	r1, #8192	; 0x2000
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017cd0:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8017cd2:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8017cd6:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8017cda:	ee17 3a90 	vmov	r3, s15
 8017cde:	1a9b      	subs	r3, r3, r2
 8017ce0:	fb88 2003 	smull	r2, r0, r8, r3
 8017ce4:	17da      	asrs	r2, r3, #31
 8017ce6:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 8017cea:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8017cee:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8017cf2:	ee07 3a90 	vmov	s15, r3
 8017cf6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8017cfa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8017cfe:	ee17 3a90 	vmov	r3, s15
 8017d02:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8017d06:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8017d0a:	ee37 0a00 	vadd.f32	s0, s14, s0
 8017d0e:	f00f ff3d 	bl	8027b8c <LEAF_midiToFrequency>
                tSawtooth_setFreq(&osc[i], freq[i]);
 8017d12:	f247 20dc 	movw	r0, #29404	; 0x72dc
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8017d16:	ed87 0a00 	vstr	s0, [r7]
                tSawtooth_setFreq(&osc[i], freq[i]);
 8017d1a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8017d1e:	4428      	add	r0, r5
 8017d20:	f010 fdba 	bl	8028898 <tSawtooth_setFreq>
 8017d24:	f642 0048 	movw	r0, #10312	; 0x2848
                tRosenbergGlottalPulse_setFreq(&glottal[i], freq[i]);
 8017d28:	ecb7 0a01 	vldmia	r7!, {s0}
 8017d2c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017d30:	eb05 0a00 	add.w	sl, r5, r0
 8017d34:	3504      	adds	r5, #4
 8017d36:	4650      	mov	r0, sl
 8017d38:	f00c fc48 	bl	80245cc <tRosenbergGlottalPulse_setFreq>
                tRosenbergGlottalPulse_setOpenLengthAndPulseLength(&glottal[i], displayValues[6] * displayValues[7], displayValues[6]);
 8017d3c:	edd4 0a06 	vldr	s1, [r4, #24]
 8017d40:	ed94 0a07 	vldr	s0, [r4, #28]
 8017d44:	4650      	mov	r0, sl
 8017d46:	ee20 0a80 	vmul.f32	s0, s1, s0
 8017d4a:	f00c fc69 	bl	8024620 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017d4e:	4630      	mov	r0, r6
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8017d50:	fa5f fa89 	uxtb.w	sl, r9
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017d54:	f010 fcbe 	bl	80286d4 <tSimplePoly_getNumVoices>
 8017d58:	f647 131c 	movw	r3, #31004	; 0x791c
 8017d5c:	4548      	cmp	r0, r9
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8017d5e:	4651      	mov	r1, sl
 8017d60:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8017d64:	4630      	mov	r0, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8017d66:	f109 0901 	add.w	r9, r9, #1
 8017d6a:	dc8f      	bgt.n	8017c8c <SFXVocoderChFrame+0x198>
            numberOfVocoderBands = displayValues[2];
 8017d6c:	ed94 7a02 	vldr	s14, [r4, #8]
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8017d70:	f240 2668 	movw	r6, #616	; 0x268
            numberOfVocoderBands = displayValues[2];
 8017d74:	f240 2551 	movw	r5, #593	; 0x251
            float warpFactor = 1.0f + displayValues[1];
 8017d78:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
            numberOfVocoderBands = displayValues[2];
 8017d7c:	eebc 7ac7 	vcvt.u32.f32	s14, s14
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8017d80:	f2c2 0600 	movt	r6, #8192	; 0x2000
            numberOfVocoderBands = displayValues[2];
 8017d84:	f2c2 0500 	movt	r5, #8192	; 0x2000
            float warpFactor = 1.0f + displayValues[1];
 8017d88:	edd4 8a01 	vldr	s17, [r4, #4]
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8017d8c:	7833      	ldrb	r3, [r6, #0]
 8017d8e:	f240 2864 	movw	r8, #612	; 0x264
            numberOfVocoderBands = displayValues[2];
 8017d92:	ed8d 7a00 	vstr	s14, [sp]
            float warpFactor = 1.0f + displayValues[1];
 8017d96:	ee78 8aa7 	vadd.f32	s17, s17, s15
            numberOfVocoderBands = displayValues[2];
 8017d9a:	f89d 1000 	ldrb.w	r1, [sp]
            float myQ = displayValues[3];
 8017d9e:	ed94 8a03 	vldr	s16, [r4, #12]
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8017da2:	428b      	cmp	r3, r1
            numberOfVocoderBands = displayValues[2];
 8017da4:	7029      	strb	r1, [r5, #0]
            float bandSquish = displayValues[10];
 8017da6:	ed94 9a0a 	vldr	s18, [r4, #40]	; 0x28
            float bandOffset = displayValues[11];
 8017daa:	ed94 aa0b 	vldr	s20, [r4, #44]	; 0x2c
            float myTilt = displayValues[12];
 8017dae:	edd4 aa0c 	vldr	s21, [r4, #48]	; 0x30
            float barkPull = displayValues[14];
 8017db2:	edd4 9a0e 	vldr	s19, [r4, #56]	; 0x38
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 8017db6:	f000 8161 	beq.w	801807c <SFXVocoderChFrame+0x588>
 8017dba:	f240 2970 	movw	r9, #624	; 0x270
 8017dbe:	f240 2a60 	movw	sl, #608	; 0x260
 8017dc2:	f240 235c 	movw	r3, #604	; 0x25c
 8017dc6:	f240 52e4 	movw	r2, #1508	; 0x5e4
 8017dca:	f240 50e0 	movw	r0, #1504	; 0x5e0
 8017dce:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8017dd2:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8017dd6:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8017dda:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017dde:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8017de2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017de6:	9300      	str	r3, [sp, #0]
 8017de8:	9201      	str	r2, [sp, #4]
 8017dea:	9002      	str	r0, [sp, #8]
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017dec:	f247 00a4 	movw	r0, #28836	; 0x70a4
 8017df0:	ee07 1a90 	vmov	s15, r1
 8017df4:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017df8:	2200      	movs	r2, #0
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017dfa:	f6c3 707d 	movt	r0, #16253	; 0x3f7d
 8017dfe:	eeb8 6a67 	vcvt.f32.u32	s12, s15
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e02:	f2c4 22bc 	movt	r2, #17084	; 0x42bc
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e06:	f64a 21ab 	movw	r1, #43691	; 0xaaab
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017e0a:	ee06 0a90 	vmov	s13, r0
                invMyQ = 1.0f / myQ;
 8017e0e:	ee85 5a88 	vdiv.f32	s10, s11, s16
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e12:	ee07 2a90 	vmov	s15, r2
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e16:	f6c3 51aa 	movt	r1, #15786	; 0x3daa
                invMyQ = 1.0f / myQ;
 8017e1a:	f240 2340 	movw	r3, #576	; 0x240
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e1e:	f247 5014 	movw	r0, #29972	; 0x7514
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e22:	ee07 1a10 	vmov	s14, r1
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017e26:	f240 2244 	movw	r2, #580	; 0x244
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e2a:	f243 4168 	movw	r1, #13416	; 0x3468
                thisBandwidth = bandWidthInOctaves * myQ;
 8017e2e:	f642 0740 	movw	r7, #10304	; 0x2840
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017e32:	ee76 6a66 	vsub.f32	s13, s12, s13
                alteringBands = 1;
 8017e36:	f240 5b14 	movw	fp, #1300	; 0x514
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e3a:	ee69 7a27 	vmul.f32	s15, s18, s15
                invMyQ = 1.0f / myQ;
 8017e3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e42:	f2c2 0001 	movt	r0, #8193	; 0x2001
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017e46:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8017e4a:	ee85 6aa6 	vdiv.f32	s12, s11, s13
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e4e:	f2c2 0100 	movt	r1, #8192	; 0x2000
                thisBandwidth = bandWidthInOctaves * myQ;
 8017e52:	f2c2 0700 	movt	r7, #8192	; 0x2000
                alteringBands = 1;
 8017e56:	f04f 0c01 	mov.w	ip, #1
 8017e5a:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8017e5e:	f8cb c000 	str.w	ip, [fp]
                invMyQ = 1.0f / myQ;
 8017e62:	ed83 5a00 	vstr	s10, [r3]
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e66:	ee67 7a86 	vmul.f32	s15, s15, s12
                invNumberOfVocoderBands = 1.0f / ((float)numberOfVocoderBands-0.99f);
 8017e6a:	ed82 6a00 	vstr	s12, [r2]
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e6e:	ee27 7a87 	vmul.f32	s14, s15, s14
                bandWidthInSemitones = 94.0f * bandSquish * invNumberOfVocoderBands; //was 90
 8017e72:	edc0 7a00 	vstr	s15, [r0]
                thisBandwidth = bandWidthInOctaves * myQ;
 8017e76:	ee67 6a08 	vmul.f32	s13, s14, s16
                bandWidthInOctaves = bandWidthInSemitones * 0.083333333333333f;  // divide by 12
 8017e7a:	ed81 7a00 	vstr	s14, [r1]
                thisBandwidth = bandWidthInOctaves * myQ;
 8017e7e:	edc7 6a00 	vstr	s13, [r7]
                if (analysisOrSynthesis == 0)
 8017e82:	f240 5018 	movw	r0, #1304	; 0x518
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 8017e86:	eeb0 0a4a 	vmov.f32	s0, s20
            float oneMinusBarkPull = 1.0f - barkPull;
 8017e8a:	eeb7 ba00 	vmov.f32	s22, #112	; 0x3f800000  1.0
                if (analysisOrSynthesis == 0)
 8017e8e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8017e92:	e9cd 3206 	strd	r3, r2, [sp, #24]
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 8017e96:	f240 536c 	movw	r3, #1388	; 0x56c
            float oneMinusBarkPull = 1.0f - barkPull;
 8017e9a:	ee7b ba69 	vsub.f32	s23, s22, s19
                float bandFreq = faster_mtof((currentBandToAlter * bandWidthInSemitones) + bandOffset); //midinote 28 (41Hz) to midinote 134 (18814Hz) is 106 midinotes, divide that by how many bands to find out how far apart to put the bands
 8017e9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017ea2:	6819      	ldr	r1, [r3, #0]
 8017ea4:	ee07 1a10 	vmov	s14, r1
 8017ea8:	9105      	str	r1, [sp, #20]
 8017eaa:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8017eae:	e9cd 3003 	strd	r3, r0, [sp, #12]
 8017eb2:	eea7 0a27 	vfma.f32	s0, s14, s15
 8017eb6:	f00f fefb 	bl	8027cb0 <faster_mtof>
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017eba:	9903      	ldr	r1, [sp, #12]
 8017ebc:	f240 102c 	movw	r0, #300	; 0x12c
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017ec0:	9a07      	ldr	r2, [sp, #28]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017ec2:	f8d1 c000 	ldr.w	ip, [r1]
                float tiltOffset = (1.0f - ((myTilt * 0.5f) + 0.5f)) + 0.5f;
 8017ec6:	ee7a 4a8b 	vadd.f32	s9, s21, s22
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017eca:	f2c2 0000 	movt	r0, #8192	; 0x2000
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017ece:	edd2 6a00 	vldr	s13, [r2]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017ed2:	ea4f 018c 	mov.w	r1, ip, lsl #2
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017ed6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
                float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
 8017eda:	ee07 ca10 	vmov	s14, ip
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017ede:	9b06      	ldr	r3, [sp, #24]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017ee0:	4408      	add	r0, r1
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017ee2:	ee66 6aa7 	vmul.f32	s13, s13, s15
                float myHeight = currentBandToAlter * invNumberOfVocoderBands; //x value
 8017ee6:	eef8 5ac7 	vcvt.f32.s32	s11, s14
                if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
 8017eea:	f44f 4280 	mov.w	r2, #16384	; 0x4000
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017eee:	edd0 7a00 	vldr	s15, [r0]
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017ef2:	eeb7 7a08 	vmov.f32	s14, #120	; 0x3fc00000  1.5
 8017ef6:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017efa:	ed93 6a00 	vldr	s12, [r3]
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017efe:	ee69 7aa7 	vmul.f32	s15, s19, s15
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f02:	f240 138c 	movw	r3, #396	; 0x18c
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017f06:	eea5 7aa6 	vfma.f32	s14, s11, s13
                if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
 8017f0a:	f2c4 529c 	movt	r2, #17820	; 0x459c
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f0e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8017f12:	2000      	movs	r0, #0
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017f14:	eeeb 7a80 	vfma.f32	s15, s23, s0
                if (bandFreq > 5000.0f) // a way to keep the upper bands fixed so consonants are not stretched even though vowels are
 8017f18:	ee06 2a90 	vmov	s13, r2
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f1c:	440b      	add	r3, r1
 8017f1e:	ee68 0a29 	vmul.f32	s1, s16, s19
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017f22:	f247 2278 	movw	r2, #29304	; 0x7278
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f26:	edd7 5a00 	vldr	s11, [r7]
 8017f2a:	f2c4 607a 	movt	r0, #18042	; 0x467a
                if (analysisOrSynthesis == 0)
 8017f2e:	9f04      	ldr	r7, [sp, #16]
                float tiltY = displayValues[12] * myHeight + tiltOffset;
 8017f30:	eea4 7ac5 	vfms.f32	s14, s9, s10
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017f34:	f2c2 0201 	movt	r2, #8193	; 0x2001
                bandFreq = (bandFreq * oneMinusBarkPull) + (barkBandFreqs[currentBandToAlter] * barkPull);
 8017f38:	eeb0 0a67 	vmov.f32	s0, s15
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f3c:	edd3 7a00 	vldr	s15, [r3]
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017f40:	440a      	add	r2, r1
                if (analysisOrSynthesis == 0)
 8017f42:	683b      	ldr	r3, [r7, #0]
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f44:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8017f48:	ee07 0a90 	vmov	s15, r0
                float tempWarpFactor = warpFactor;
 8017f4c:	eeb4 0ae6 	vcmpe.f32	s0, s13
 8017f50:	ea4f 00cc 	mov.w	r0, ip, lsl #3
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017f54:	ee27 7a06 	vmul.f32	s14, s14, s12
 8017f58:	fe80 0a67 	vminnm.f32	s0, s0, s15
                float bandBandwidth = (thisBandwidth * oneMinusBarkPull) + (barkBandWidths[currentBandToAlter] *  barkPull * myQ);
 8017f5c:	eee5 0aab 	vfma.f32	s1, s11, s23
                float tempWarpFactor = warpFactor;
 8017f60:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                bandGains[currentBandToAlter] = invMyQ * tiltY;
 8017f64:	ed82 7a00 	vstr	s14, [r2]
                float tempWarpFactor = warpFactor;
 8017f68:	bf98      	it	ls
 8017f6a:	eeb0 ba68 	vmovls.f32	s22, s17
                if (analysisOrSynthesis == 0)
 8017f6e:	2b00      	cmp	r3, #0
 8017f70:	f040 80cc 	bne.w	801810c <SFXVocoderChFrame+0x618>
                    tVZFilter_setFreqAndBandwidth(&analysisBands[currentBandToAlter][0], bandFreq, bandBandwidth);
 8017f74:	f248 2738 	movw	r7, #33336	; 0x8238
 8017f78:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8017f7c:	4438      	add	r0, r7
 8017f7e:	f00e ffe1 	bl	8026f44 <tVZFilter_setFreqAndBandwidth>
                    analysisBands[currentBandToAlter][1]->B = analysisBands[currentBandToAlter][0]->B;
 8017f82:	9903      	ldr	r1, [sp, #12]
 8017f84:	680b      	ldr	r3, [r1, #0]
 8017f86:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017f8a:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
 8017f8e:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8017f90:	6851      	ldr	r1, [r2, #4]
 8017f92:	6348      	str	r0, [r1, #52]	; 0x34
                    analysisBands[currentBandToAlter][1]->fc = analysisBands[currentBandToAlter][0]->fc;
 8017f94:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017f98:	6851      	ldr	r1, [r2, #4]
 8017f9a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8017f9c:	6288      	str	r0, [r1, #40]	; 0x28
                    analysisBands[currentBandToAlter][1]->R2 = analysisBands[currentBandToAlter][0]->R2;
 8017f9e:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017fa2:	6851      	ldr	r1, [r2, #4]
 8017fa4:	6940      	ldr	r0, [r0, #20]
 8017fa6:	6148      	str	r0, [r1, #20]
                    analysisBands[currentBandToAlter][1]->cL = analysisBands[currentBandToAlter][0]->cL;
 8017fa8:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017fac:	6851      	ldr	r1, [r2, #4]
 8017fae:	69c0      	ldr	r0, [r0, #28]
 8017fb0:	61c8      	str	r0, [r1, #28]
                    analysisBands[currentBandToAlter][1]->cB = analysisBands[currentBandToAlter][0]->cB;
 8017fb2:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017fb6:	6851      	ldr	r1, [r2, #4]
 8017fb8:	6a00      	ldr	r0, [r0, #32]
 8017fba:	6208      	str	r0, [r1, #32]
                    analysisBands[currentBandToAlter][1]->cH = analysisBands[currentBandToAlter][0]->cH;
 8017fbc:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017fc0:	6851      	ldr	r1, [r2, #4]
 8017fc2:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8017fc4:	6248      	str	r0, [r1, #36]	; 0x24
                    analysisBands[currentBandToAlter][1]->h = analysisBands[currentBandToAlter][0]->h;
 8017fc6:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8017fca:	6851      	ldr	r1, [r2, #4]
 8017fcc:	6980      	ldr	r0, [r0, #24]
 8017fce:	6188      	str	r0, [r1, #24]
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
 8017fd0:	f857 1033 	ldr.w	r1, [r7, r3, lsl #3]
 8017fd4:	6852      	ldr	r2, [r2, #4]
 8017fd6:	6909      	ldr	r1, [r1, #16]
                    analysisOrSynthesis++;
 8017fd8:	9804      	ldr	r0, [sp, #16]
                    analysisBands[currentBandToAlter][1]->g = analysisBands[currentBandToAlter][0]->g;
 8017fda:	6111      	str	r1, [r2, #16]
                    analysisOrSynthesis++;
 8017fdc:	6802      	ldr	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8017fde:	7829      	ldrb	r1, [r5, #0]
                    analysisOrSynthesis++;
 8017fe0:	3201      	adds	r2, #1
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8017fe2:	428b      	cmp	r3, r1
                    analysisOrSynthesis++;
 8017fe4:	6002      	str	r2, [r0, #0]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8017fe6:	db02      	blt.n	8017fee <SFXVocoderChFrame+0x4fa>
 8017fe8:	2a00      	cmp	r2, #0
 8017fea:	f000 80d2 	beq.w	8018192 <SFXVocoderChFrame+0x69e>
            prevBandOffset = bandOffset;
 8017fee:	9b00      	ldr	r3, [sp, #0]
            prevNumberOfVocoderBands = numberOfVocoderBands;
 8017ff0:	7031      	strb	r1, [r6, #0]
            prevBandOffset = bandOffset;
 8017ff2:	ed83 aa00 	vstr	s20, [r3]
            prevMyTilt = myTilt;
 8017ff6:	9b01      	ldr	r3, [sp, #4]
            prevMyQ = myQ;
 8017ff8:	ed88 8a00 	vstr	s16, [r8]
            prevMyTilt = myTilt;
 8017ffc:	edc3 aa00 	vstr	s21, [r3]
            prevBarkPull = barkPull;
 8018000:	9b02      	ldr	r3, [sp, #8]
            prevWarpFactor = warpFactor;
 8018002:	edc9 8a00 	vstr	s17, [r9]
            prevBandSquish = bandSquish;
 8018006:	ed8a 9a00 	vstr	s18, [sl]
            prevBarkPull = barkPull;
 801800a:	edc3 9a00 	vstr	s19, [r3]
            for (int i = 0; i < numberOfVocoderBands; i++)
 801800e:	b1f1      	cbz	r1, 801804e <SFXVocoderChFrame+0x55a>
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
 8018010:	f649 32a6 	movw	r2, #39846	; 0x9ba6
 8018014:	f24b 7317 	movw	r3, #46871	; 0xb717
 8018018:	f247 662c 	movw	r6, #30252	; 0x762c
            for (int i = 0; i < numberOfVocoderBands; i++)
 801801c:	2700      	movs	r7, #0
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
 801801e:	f6c3 22c4 	movt	r2, #15044	; 0x3ac4
 8018022:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8018026:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801802a:	ee08 2a90 	vmov	s17, r2
 801802e:	ee08 3a10 	vmov	s16, r3
 8018032:	eeb0 0a48 	vmov.f32	s0, s16
 8018036:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 801803a:	4630      	mov	r0, r6
            for (int i = 0; i < numberOfVocoderBands; i++)
 801803c:	3701      	adds	r7, #1
 801803e:	3604      	adds	r6, #4
                tExpSmooth_setFactor(&envFollowers[i], (displayValues[9] * 0.0015f) + 0.0001f);
 8018040:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8018044:	f00d ff92 	bl	8025f6c <tExpSmooth_setFactor>
            for (int i = 0; i < numberOfVocoderBands; i++)
 8018048:	782b      	ldrb	r3, [r5, #0]
 801804a:	42bb      	cmp	r3, r7
 801804c:	dcf1      	bgt.n	8018032 <SFXVocoderChFrame+0x53e>
            if (tSimplePoly_getNumActiveVoices(&poly) != 0)
 801804e:	f247 5020 	movw	r0, #29984	; 0x7520
 8018052:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018056:	f010 fb41 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 801805a:	2800      	cmp	r0, #0
 801805c:	f040 809f 	bne.w	801819e <SFXVocoderChFrame+0x6aa>
                tExpSmooth_setDest(&comp, 0.0f);
 8018060:	2300      	movs	r3, #0
 8018062:	f247 205c 	movw	r0, #29276	; 0x725c
 8018066:	ee00 3a10 	vmov	s0, r3
 801806a:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 801806e:	b009      	add	sp, #36	; 0x24
 8018070:	ecbd 8b08 	vpop	{d8-d11}
 8018074:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
 8018078:	f00d bf8a 	b.w	8025f90 <tExpSmooth_setDest>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 801807c:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8018080:	f240 2970 	movw	r9, #624	; 0x270
 8018084:	edd8 7a00 	vldr	s15, [r8]
 8018088:	eef4 7a48 	vcmp.f32	s15, s16
 801808c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018090:	d133      	bne.n	80180fa <SFXVocoderChFrame+0x606>
 8018092:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8018096:	f240 2a60 	movw	sl, #608	; 0x260
 801809a:	edd9 7a00 	vldr	s15, [r9]
 801809e:	eef4 7a68 	vcmp.f32	s15, s17
 80180a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80180a6:	f000 8095 	beq.w	80181d4 <SFXVocoderChFrame+0x6e0>
 80180aa:	f240 235c 	movw	r3, #604	; 0x25c
 80180ae:	f240 52e4 	movw	r2, #1508	; 0x5e4
 80180b2:	f240 50e0 	movw	r0, #1504	; 0x5e0
 80180b6:	e68e      	b.n	8017dd6 <SFXVocoderChFrame+0x2e2>
                internalExternal = !internalExternal;
 80180b8:	f240 529c 	movw	r2, #1436	; 0x59c
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80180bc:	2300      	movs	r3, #0
                internalExternal = !internalExternal;
 80180be:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 80180c2:	7623      	strb	r3, [r4, #24]
                internalExternal = !internalExternal;
 80180c4:	7813      	ldrb	r3, [r2, #0]
 80180c6:	fab3 f383 	clz	r3, r3
 80180ca:	095b      	lsrs	r3, r3, #5
                setLED_B(internalExternal);
 80180cc:	4618      	mov	r0, r3
                internalExternal = !internalExternal;
 80180ce:	7013      	strb	r3, [r2, #0]
                setLED_B(internalExternal);
 80180d0:	f7fd fc1c 	bl	801590c <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 80180d4:	7f23      	ldrb	r3, [r4, #28]
 80180d6:	2b01      	cmp	r3, #1
 80180d8:	f47f ad3a 	bne.w	8017b50 <SFXVocoderChFrame+0x5c>
                vocChFreeze = !vocChFreeze;
 80180dc:	f240 6210 	movw	r2, #1552	; 0x610
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80180e0:	2300      	movs	r3, #0
                vocChFreeze = !vocChFreeze;
 80180e2:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 80180e6:	7723      	strb	r3, [r4, #28]
                vocChFreeze = !vocChFreeze;
 80180e8:	6813      	ldr	r3, [r2, #0]
 80180ea:	fab3 f383 	clz	r3, r3
 80180ee:	095b      	lsrs	r3, r3, #5
                setLED_C(vocChFreeze);
 80180f0:	4618      	mov	r0, r3
                vocChFreeze = !vocChFreeze;
 80180f2:	6013      	str	r3, [r2, #0]
                setLED_C(vocChFreeze);
 80180f4:	f7fd fc1a 	bl	801592c <setLED_C>
 80180f8:	e52a      	b.n	8017b50 <SFXVocoderChFrame+0x5c>
 80180fa:	f240 2a60 	movw	sl, #608	; 0x260
 80180fe:	f240 235c 	movw	r3, #604	; 0x25c
 8018102:	f240 52e4 	movw	r2, #1508	; 0x5e4
 8018106:	f240 50e0 	movw	r0, #1504	; 0x5e0
 801810a:	e662      	b.n	8017dd2 <SFXVocoderChFrame+0x2de>
                    tVZFilter_setFreqAndBandwidth(&synthesisBands[currentBandToAlter][0], bandFreq * tempWarpFactor, bandBandwidth);
 801810c:	f247 4728 	movw	r7, #29736	; 0x7428
 8018110:	ee2b 0a00 	vmul.f32	s0, s22, s0
 8018114:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8018118:	4438      	add	r0, r7
 801811a:	f00e ff13 	bl	8026f44 <tVZFilter_setFreqAndBandwidth>
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 801811e:	9b03      	ldr	r3, [sp, #12]
                    analysisOrSynthesis = 0;
 8018120:	f04f 0e00 	mov.w	lr, #0
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 8018124:	681b      	ldr	r3, [r3, #0]
 8018126:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 801812a:	eb07 02c3 	add.w	r2, r7, r3, lsl #3
                    currentBandToAlter++;
 801812e:	f103 0c01 	add.w	ip, r3, #1
                    synthesisBands[currentBandToAlter][1]->B = synthesisBands[currentBandToAlter][0]->B;
 8018132:	6851      	ldr	r1, [r2, #4]
 8018134:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8018136:	6348      	str	r0, [r1, #52]	; 0x34
                    synthesisBands[currentBandToAlter][1]->fc = synthesisBands[currentBandToAlter][0]->fc;
 8018138:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 801813c:	6851      	ldr	r1, [r2, #4]
 801813e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8018140:	6288      	str	r0, [r1, #40]	; 0x28
                    synthesisBands[currentBandToAlter][1]->R2 = synthesisBands[currentBandToAlter][0]->R2;
 8018142:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8018146:	6851      	ldr	r1, [r2, #4]
 8018148:	6940      	ldr	r0, [r0, #20]
 801814a:	6148      	str	r0, [r1, #20]
                    synthesisBands[currentBandToAlter][1]->cL = synthesisBands[currentBandToAlter][0]->cL;
 801814c:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8018150:	6851      	ldr	r1, [r2, #4]
 8018152:	69c0      	ldr	r0, [r0, #28]
 8018154:	61c8      	str	r0, [r1, #28]
                    synthesisBands[currentBandToAlter][1]->cB = synthesisBands[currentBandToAlter][0]->cB;
 8018156:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 801815a:	6851      	ldr	r1, [r2, #4]
 801815c:	6a00      	ldr	r0, [r0, #32]
 801815e:	6208      	str	r0, [r1, #32]
                    synthesisBands[currentBandToAlter][1]->cH = synthesisBands[currentBandToAlter][0]->cH;
 8018160:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 8018164:	6851      	ldr	r1, [r2, #4]
 8018166:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8018168:	6248      	str	r0, [r1, #36]	; 0x24
                    synthesisBands[currentBandToAlter][1]->h = synthesisBands[currentBandToAlter][0]->h;
 801816a:	f857 0033 	ldr.w	r0, [r7, r3, lsl #3]
 801816e:	6851      	ldr	r1, [r2, #4]
 8018170:	6980      	ldr	r0, [r0, #24]
 8018172:	6188      	str	r0, [r1, #24]
                    synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
 8018174:	f857 3033 	ldr.w	r3, [r7, r3, lsl #3]
 8018178:	6852      	ldr	r2, [r2, #4]
 801817a:	691b      	ldr	r3, [r3, #16]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 801817c:	7829      	ldrb	r1, [r5, #0]
                    synthesisBands[currentBandToAlter][1]->g = synthesisBands[currentBandToAlter][0]->g;
 801817e:	6113      	str	r3, [r2, #16]
                    currentBandToAlter++;
 8018180:	9b03      	ldr	r3, [sp, #12]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 8018182:	458c      	cmp	ip, r1
                    currentBandToAlter++;
 8018184:	f8c3 c000 	str.w	ip, [r3]
                    analysisOrSynthesis = 0;
 8018188:	9b04      	ldr	r3, [sp, #16]
 801818a:	f8c3 e000 	str.w	lr, [r3]
                if ((currentBandToAlter >= numberOfVocoderBands) && (analysisOrSynthesis == 0))
 801818e:	f6ff af2e 	blt.w	8017fee <SFXVocoderChFrame+0x4fa>
                    alteringBands = 0;
 8018192:	2300      	movs	r3, #0
                    currentBandToAlter = 0;
 8018194:	9a03      	ldr	r2, [sp, #12]
                    alteringBands = 0;
 8018196:	f8cb 3000 	str.w	r3, [fp]
                    currentBandToAlter = 0;
 801819a:	6013      	str	r3, [r2, #0]
 801819c:	e727      	b.n	8017fee <SFXVocoderChFrame+0x4fa>
                tExpSmooth_setDest(&comp, sqrtf(1.0f / tSimplePoly_getNumActiveVoices(&poly)));
 801819e:	f247 5020 	movw	r0, #29984	; 0x7520
 80181a2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80181a6:	f010 fa99 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 80181aa:	ee07 0a90 	vmov	s15, r0
 80181ae:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80181b2:	f247 205c 	movw	r0, #29276	; 0x725c
 80181b6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80181ba:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80181be:	ee87 0a27 	vdiv.f32	s0, s14, s15
 80181c2:	eeb1 0ac0 	vsqrt.f32	s0, s0
        }
 80181c6:	b009      	add	sp, #36	; 0x24
 80181c8:	ecbd 8b08 	vpop	{d8-d11}
 80181cc:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                tExpSmooth_setDest(&comp, 0.0f);
 80181d0:	f00d bede 	b.w	8025f90 <tExpSmooth_setDest>
            if ((numberOfVocoderBands != prevNumberOfVocoderBands) || (myQ != prevMyQ) || (warpFactor != prevWarpFactor) || (bandSquish != prevBandSquish) || (bandOffset != prevBandOffset) || (myTilt != prevMyTilt) || (barkPull != prevBarkPull))
 80181d4:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 80181d8:	f240 235c 	movw	r3, #604	; 0x25c
 80181dc:	edda 7a00 	vldr	s15, [sl]
 80181e0:	eef4 7a49 	vcmp.f32	s15, s18
 80181e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80181e8:	d114      	bne.n	8018214 <SFXVocoderChFrame+0x720>
 80181ea:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80181ee:	edd3 7a00 	vldr	s15, [r3]
 80181f2:	9300      	str	r3, [sp, #0]
 80181f4:	f240 53e4 	movw	r3, #1508	; 0x5e4
 80181f8:	eef4 7a4a 	vcmp.f32	s15, s20
 80181fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018200:	d00d      	beq.n	801821e <SFXVocoderChFrame+0x72a>
 8018202:	f240 52e0 	movw	r2, #1504	; 0x5e0
 8018206:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801820a:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801820e:	9301      	str	r3, [sp, #4]
 8018210:	9202      	str	r2, [sp, #8]
 8018212:	e5eb      	b.n	8017dec <SFXVocoderChFrame+0x2f8>
 8018214:	f240 52e4 	movw	r2, #1508	; 0x5e4
 8018218:	f240 50e0 	movw	r0, #1504	; 0x5e0
 801821c:	e5dd      	b.n	8017dda <SFXVocoderChFrame+0x2e6>
 801821e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018222:	edd3 7a00 	vldr	s15, [r3]
 8018226:	9301      	str	r3, [sp, #4]
 8018228:	f240 53e0 	movw	r3, #1504	; 0x5e0
 801822c:	eef4 7a6a 	vcmp.f32	s15, s21
 8018230:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018234:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018238:	9302      	str	r3, [sp, #8]
 801823a:	f47f add7 	bne.w	8017dec <SFXVocoderChFrame+0x2f8>
 801823e:	edd3 7a00 	vldr	s15, [r3]
 8018242:	eef4 7a69 	vcmp.f32	s15, s19
 8018246:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801824a:	f47f adcf 	bne.w	8017dec <SFXVocoderChFrame+0x2f8>
            if (alteringBands)
 801824e:	f240 5b14 	movw	fp, #1300	; 0x514
 8018252:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8018256:	f8db 3000 	ldr.w	r3, [fp]
 801825a:	2b00      	cmp	r3, #0
 801825c:	f43f aec7 	beq.w	8017fee <SFXVocoderChFrame+0x4fa>
 8018260:	f247 5114 	movw	r1, #29972	; 0x7514
 8018264:	f240 2244 	movw	r2, #580	; 0x244
 8018268:	f642 0740 	movw	r7, #10304	; 0x2840
 801826c:	f240 2340 	movw	r3, #576	; 0x240
 8018270:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8018274:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8018278:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801827c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018280:	edd1 7a00 	vldr	s15, [r1]
 8018284:	e5fd      	b.n	8017e82 <SFXVocoderChFrame+0x38e>
 8018286:	bf00      	nop

08018288 <SFXVocoderChTick>:
        {
 8018288:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801828c:	4606      	mov	r6, r0
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 801828e:	f247 50f0 	movw	r0, #30192	; 0x75f0
        {
 8018292:	ed2d 8b06 	vpush	{d8-d10}
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 8018296:	f2c2 0001 	movt	r0, #8193	; 0x2001
        {
 801829a:	b087      	sub	sp, #28
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 801829c:	ed96 0a01 	vldr	s0, [r6, #4]
 80182a0:	f00e fbec 	bl	8026a7c <tVZFilter_tick>
            if (internalExternal == 1)
 80182a4:	f240 539c 	movw	r3, #1436	; 0x59c
            input[1] = tVZFilter_tick(&vocodec_highshelf, input[1]);
 80182a8:	ed86 0a01 	vstr	s0, [r6, #4]
            if (internalExternal == 1)
 80182ac:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80182b0:	781b      	ldrb	r3, [r3, #0]
 80182b2:	2b01      	cmp	r3, #1
 80182b4:	f040 80d8 	bne.w	8018468 <SFXVocoderChTick+0x1e0>
 80182b8:	f248 7794 	movw	r7, #34708	; 0x8794
                sample = input[0];
 80182bc:	ed96 0a00 	vldr	s0, [r6]
 80182c0:	f2c2 0701 	movt	r7, #8193	; 0x2001
            sample = LEAF_tanh(sample);
 80182c4:	f00f fbca 	bl	8027a5c <LEAF_tanh>
            input[1] = input[1] * (displayValues[0] * 30.0f);
 80182c8:	eeb3 7a0e 	vmov.f32	s14, #62	; 0x41f00000  30.0
            sample = LEAF_tanh(sample);
 80182cc:	eeb0 9a40 	vmov.f32	s18, s0
            input[1] = input[1] * (displayValues[0] * 30.0f);
 80182d0:	ed97 0a00 	vldr	s0, [r7]
            for (int i = 0; i < numberOfVocoderBands; i++)
 80182d4:	f240 2851 	movw	r8, #593	; 0x251
            input[1] = input[1] * (displayValues[0] * 30.0f);
 80182d8:	edd6 7a01 	vldr	s15, [r6, #4]
 80182dc:	ee20 0a07 	vmul.f32	s0, s0, s14
            float output[2] = {0.0f, 0.0f};
 80182e0:	2300      	movs	r3, #0
            for (int i = 0; i < numberOfVocoderBands; i++)
 80182e2:	f2c2 0800 	movt	r8, #8192	; 0x2000
            float output[2] = {0.0f, 0.0f};
 80182e6:	9304      	str	r3, [sp, #16]
            input[1] = input[1] * (displayValues[0] * 30.0f);
 80182e8:	ee20 0a27 	vmul.f32	s0, s0, s15
            for (int i = 0; i < numberOfVocoderBands; i++)
 80182ec:	f898 2000 	ldrb.w	r2, [r8]
            float output[2] = {0.0f, 0.0f};
 80182f0:	9305      	str	r3, [sp, #20]
            input[1] = input[1] * (displayValues[0] * 30.0f);
 80182f2:	ed86 0a01 	vstr	s0, [r6, #4]
            for (int i = 0; i < numberOfVocoderBands; i++)
 80182f6:	2a00      	cmp	r2, #0
 80182f8:	f000 8168 	beq.w	80185cc <SFXVocoderChTick+0x344>
 80182fc:	ee08 3a10 	vmov	s16, r3
 8018300:	f248 2238 	movw	r2, #33336	; 0x8238
 8018304:	469a      	mov	sl, r3
 8018306:	f247 632c 	movw	r3, #30252	; 0x762c
 801830a:	f247 4928 	movw	r9, #29736	; 0x7428
 801830e:	f247 2578 	movw	r5, #29304	; 0x7278
 8018312:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8018316:	f240 6710 	movw	r7, #1552	; 0x610
 801831a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801831e:	f2c2 0901 	movt	r9, #8193	; 0x2001
 8018322:	9203      	str	r2, [sp, #12]
 8018324:	f2c2 0501 	movt	r5, #8193	; 0x2001
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8018328:	eef0 9a48 	vmov.f32	s19, s16
 801832c:	ee18 ba10 	vmov	fp, s16
 8018330:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8018334:	e9cd 3601 	strd	r3, r6, [sp, #4]
 8018338:	e033      	b.n	80183a2 <SFXVocoderChTick+0x11a>
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
 801833a:	4630      	mov	r0, r6
            for (int i = 0; i < numberOfVocoderBands; i++)
 801833c:	f10b 0b01 	add.w	fp, fp, #1
                tempSamp = tExpSmooth_tick(&envFollowers[i]);
 8018340:	f00d fe30 	bl	8025fa4 <tExpSmooth_tick>
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8018344:	eeb0 1a00 	vmov.f32	s2, #0	; 0x40000000  2.0
 8018348:	eef0 0a40 	vmov.f32	s1, s0
 801834c:	eeb0 0a69 	vmov.f32	s0, s19
 8018350:	f00f fb32 	bl	80279b8 <LEAF_clip>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
 8018354:	eb09 0004 	add.w	r0, r9, r4
                tempSamp = LEAF_clip(0.0f, tempSamp, 2.0f);
 8018358:	eef0 8a40 	vmov.f32	s17, s0
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][0], tempSynth);
 801835c:	eeb0 0a49 	vmov.f32	s0, s18
 8018360:	f00e fbca 	bl	8026af8 <tVZFilter_tickEfficient>
                tempSynth = tVZFilter_tickEfficient(&synthesisBands[i][1], tempSynth);
 8018364:	f247 432c 	movw	r3, #29740	; 0x742c
 8018368:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801836c:	1918      	adds	r0, r3, r4
 801836e:	f00e fbc3 	bl	8026af8 <tVZFilter_tickEfficient>
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
 8018372:	ee28 0a80 	vmul.f32	s0, s17, s0
 8018376:	ecf5 7a01 	vldmia	r5!, {s15}
 801837a:	ab06      	add	r3, sp, #24
            for (int i = 0; i < numberOfVocoderBands; i++)
 801837c:	f898 1000 	ldrb.w	r1, [r8]
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
 8018380:	eea0 8a27 	vfma.f32	s16, s0, s15
 8018384:	eb03 008a 	add.w	r0, r3, sl, lsl #2
            for (int i = 0; i < numberOfVocoderBands; i++)
 8018388:	4559      	cmp	r1, fp
 801838a:	f00b 0a01 	and.w	sl, fp, #1
 801838e:	eb03 048a 	add.w	r4, r3, sl, lsl #2
                output[oddEven] += tempSynth * tempSamp * bandGains[i];
 8018392:	ed00 8a02 	vstr	s16, [r0, #-8]
            for (int i = 0; i < numberOfVocoderBands; i++)
 8018396:	dd1d      	ble.n	80183d4 <SFXVocoderChTick+0x14c>
 8018398:	9b02      	ldr	r3, [sp, #8]
 801839a:	ed14 8a02 	vldr	s16, [r4, #-8]
 801839e:	ed93 0a01 	vldr	s0, [r3, #4]
 80183a2:	9b01      	ldr	r3, [sp, #4]
 80183a4:	ea4f 04cb 	mov.w	r4, fp, lsl #3
                if (!vocChFreeze)
 80183a8:	6838      	ldr	r0, [r7, #0]
 80183aa:	eb03 068b 	add.w	r6, r3, fp, lsl #2
 80183ae:	2800      	cmp	r0, #0
 80183b0:	d1c3      	bne.n	801833a <SFXVocoderChTick+0xb2>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][0], tempSamp);
 80183b2:	9b03      	ldr	r3, [sp, #12]
 80183b4:	1918      	adds	r0, r3, r4
 80183b6:	f00e fb9f 	bl	8026af8 <tVZFilter_tickEfficient>
                    tempSamp = tVZFilter_tickEfficient(&analysisBands[i][1], tempSamp);
 80183ba:	f248 233c 	movw	r3, #33340	; 0x823c
 80183be:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80183c2:	1918      	adds	r0, r3, r4
 80183c4:	f00e fb98 	bl	8026af8 <tVZFilter_tickEfficient>
                    tExpSmooth_setDest(&envFollowers[i], fabsf(tempSamp));
 80183c8:	4630      	mov	r0, r6
 80183ca:	eeb0 0ac0 	vabs.f32	s0, s0
 80183ce:	f00d fddf 	bl	8025f90 <tExpSmooth_setDest>
 80183d2:	e7b2      	b.n	801833a <SFXVocoderChTick+0xb2>
 80183d4:	9e02      	ldr	r6, [sp, #8]
 80183d6:	eddd 8a04 	vldr	s17, [sp, #16]
 80183da:	ed9d 8a05 	vldr	s16, [sp, #20]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
 80183de:	f240 2554 	movw	r5, #596	; 0x254
 80183e2:	eeb0 0a68 	vmov.f32	s0, s17
 80183e6:	f240 14ec 	movw	r4, #492	; 0x1ec
 80183ea:	f642 003c 	movw	r0, #10300	; 0x283c
 80183ee:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80183f2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80183f6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80183fa:	ed95 7a00 	vldr	s14, [r5]
 80183fe:	edd4 7a00 	vldr	s15, [r4]
 8018402:	eea7 0a08 	vfma.f32	s0, s14, s16
 8018406:	ee20 0a27 	vmul.f32	s0, s0, s15
 801840a:	f00e f913 	bl	8026634 <tHighpass_tick>
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
 801840e:	edd5 7a00 	vldr	s15, [r5]
            float finalSample1 = tHighpass_tick(&chVocFinalHP1, (output[0] + (output[1] * oneMinusStereo)) * chVocOutputGain);
 8018412:	eeb0 9a40 	vmov.f32	s18, s0
            float finalSample2 = tHighpass_tick(&chVocFinalHP2, (output[1] + (output[0] * oneMinusStereo)) * chVocOutputGain);
 8018416:	f248 202c 	movw	r0, #33324	; 0x822c
 801841a:	eea7 8aa8 	vfma.f32	s16, s15, s17
 801841e:	ed94 0a00 	vldr	s0, [r4]
 8018422:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018426:	ee28 0a00 	vmul.f32	s0, s16, s0
 801842a:	f00e f903 	bl	8026634 <tHighpass_tick>
 801842e:	eef0 8a40 	vmov.f32	s17, s0
            input[0] = 0.98f * tanhf(finalSample1);
 8018432:	eeb0 0a49 	vmov.f32	s0, s18
 8018436:	f013 f895 	bl	802b564 <tanhf>
 801843a:	f24e 1348 	movw	r3, #57672	; 0xe148
 801843e:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
 8018442:	ee08 3a10 	vmov	s16, r3
 8018446:	ee60 7a08 	vmul.f32	s15, s0, s16
            input[1] = 0.98f * tanhf(finalSample2);
 801844a:	eeb0 0a68 	vmov.f32	s0, s17
            input[0] = 0.98f * tanhf(finalSample1);
 801844e:	edc6 7a00 	vstr	s15, [r6]
            input[1] = 0.98f * tanhf(finalSample2);
 8018452:	f013 f887 	bl	802b564 <tanhf>
 8018456:	ee20 0a08 	vmul.f32	s0, s0, s16
 801845a:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 801845e:	b007      	add	sp, #28
 8018460:	ecbd 8b06 	vpop	{d8-d10}
 8018464:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (!vocChFreeze)
 8018468:	f240 6710 	movw	r7, #1552	; 0x610
                float zerocross = tZeroCrossing_tick(&zerox, input[1]);
 801846c:	f247 6090 	movw	r0, #30352	; 0x7690
                if (!vocChFreeze)
 8018470:	f2c2 0700 	movt	r7, #8192	; 0x2000
                float zerocross = tZeroCrossing_tick(&zerox, input[1]);
 8018474:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018478:	f009 ff1a 	bl	80222b0 <tZeroCrossing_tick>
                if (!vocChFreeze)
 801847c:	683b      	ldr	r3, [r7, #0]
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 801847e:	f248 7794 	movw	r7, #34708	; 0x8794
                if (!vocChFreeze)
 8018482:	2b00      	cmp	r3, #0
 8018484:	f000 8081 	beq.w	801858a <SFXVocoderChTick+0x302>
 8018488:	f2c2 0701 	movt	r7, #8193	; 0x2001
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 801848c:	f248 2028 	movw	r0, #33320	; 0x8228
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8018490:	f247 5920 	movw	r9, #29984	; 0x7520
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 8018494:	f647 181c 	movw	r8, #31004	; 0x791c
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 8018498:	2400      	movs	r4, #0
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 801849a:	f2c2 0001 	movt	r0, #8193	; 0x2001
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801849e:	f2c2 0901 	movt	r9, #8193	; 0x2001
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 80184a2:	f00d fd7f 	bl	8025fa4 <tExpSmooth_tick>
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 80184a6:	f243 4064 	movw	r0, #13412	; 0x3464
                float noiseRampVal = tExpSmooth_tick(&noiseRamp);
 80184aa:	eeb0 aa40 	vmov.f32	s20, s0
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 80184ae:	f2c2 0801 	movt	r8, #8193	; 0x2001
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 80184b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
            float sample = 0.0f;
 80184b6:	ee09 4a10 	vmov	s18, r4
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 80184ba:	f010 fa91 	bl	80289e0 <tNoise_tick>
                    if (tempRamp > 0.0001f)
 80184be:	f24b 7317 	movw	r3, #46871	; 0xb717
                float noiseSample = tNoise_tick(&vocoderNoise) * noiseRampVal;
 80184c2:	ee60 9a0a 	vmul.f32	s19, s0, s20
                    if (tempRamp > 0.0001f)
 80184c6:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 80184ca:	ee08 3a90 	vmov	s17, r3
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80184ce:	e005      	b.n	80184dc <SFXVocoderChTick+0x254>
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
 80184d0:	1958      	adds	r0, r3, r5
 80184d2:	f010 fa15 	bl	8028900 <tSawtooth_tick>
 80184d6:	eea0 9a08 	vfma.f32	s18, s0, s16
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80184da:	3401      	adds	r4, #1
 80184dc:	4648      	mov	r0, r9
 80184de:	00a5      	lsls	r5, r4, #2
 80184e0:	f010 f8f8 	bl	80286d4 <tSimplePoly_getNumVoices>
 80184e4:	42a0      	cmp	r0, r4
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 80184e6:	eb08 0005 	add.w	r0, r8, r5
                for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 80184ea:	dd1f      	ble.n	801852c <SFXVocoderChTick+0x2a4>
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 80184ec:	f00d fd5a 	bl	8025fa4 <tExpSmooth_tick>
                    if (tempRamp > 0.0001f)
 80184f0:	eeb4 0ae8 	vcmpe.f32	s0, s17
                    float tempRamp = tExpSmooth_tick(&polyRamp[i]);
 80184f4:	eeb0 8a40 	vmov.f32	s16, s0
                        if (displayValues[5] < 0.5f)
 80184f8:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                    if (tempRamp > 0.0001f)
 80184fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018500:	ddeb      	ble.n	80184da <SFXVocoderChTick+0x252>
                        if (displayValues[5] < 0.5f)
 8018502:	ed97 7a05 	vldr	s14, [r7, #20]
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8018506:	f642 0048 	movw	r0, #10312	; 0x2848
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
 801850a:	f247 23dc 	movw	r3, #29404	; 0x72dc
                        if (displayValues[5] < 0.5f)
 801850e:	eeb4 7ae7 	vcmpe.f32	s14, s15
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8018512:	f2c2 0000 	movt	r0, #8192	; 0x2000
                            sample += tSawtooth_tick(&osc[i]) * tempRamp;
 8018516:	f2c2 0301 	movt	r3, #8193	; 0x2001
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 801851a:	4428      	add	r0, r5
                        if (displayValues[5] < 0.5f)
 801851c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018520:	d4d6      	bmi.n	80184d0 <SFXVocoderChTick+0x248>
                            sample += tRosenbergGlottalPulse_tick(&glottal[i]) * tempRamp;
 8018522:	f00b ff6f 	bl	8024404 <tRosenbergGlottalPulse_tick>
 8018526:	eea0 9a08 	vfma.f32	s18, s0, s16
 801852a:	e7d6      	b.n	80184da <SFXVocoderChTick+0x252>
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
 801852c:	f649 139a 	movw	r3, #39322	; 0x999a
 8018530:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8018534:	edd7 6a08 	vldr	s13, [r7, #32]
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8018538:	f642 0018 	movw	r0, #10264	; 0x2818
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
 801853c:	f6c3 6399 	movt	r3, #16025	; 0x3e99
 8018540:	ee37 8aca 	vsub.f32	s16, s15, s20
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8018544:	f2c2 0000 	movt	r0, #8192	; 0x2000
                sample = (sample * (1.0f - (0.3f * displayValues[8])) * (1.0f-noiseRampVal)) + noiseSample;
 8018548:	ee07 3a10 	vmov	s14, r3
 801854c:	eee6 7ac7 	vfms.f32	s15, s13, s14
 8018550:	ee27 8a88 	vmul.f32	s16, s15, s16
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8018554:	f010 fa44 	bl	80289e0 <tNoise_tick>
 8018558:	f243 405c 	movw	r0, #13404	; 0x345c
 801855c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018560:	f00e f868 	bl	8026634 <tHighpass_tick>
 8018564:	edd7 7a08 	vldr	s15, [r7, #32]
                sample *= tExpSmooth_tick(&comp);
 8018568:	f247 205c 	movw	r0, #29276	; 0x725c
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 801856c:	ee77 7aa7 	vadd.f32	s15, s15, s15
                sample *= tExpSmooth_tick(&comp);
 8018570:	f2c2 0001 	movt	r0, #8193	; 0x2001
                sample += (tHighpass_tick(&noiseHP, tNoise_tick(&breathNoise)) * displayValues[8] * 2.0f);
 8018574:	ee67 7a80 	vmul.f32	s15, s15, s0
 8018578:	eee9 7a08 	vfma.f32	s15, s18, s16
 801857c:	ee79 9aa7 	vadd.f32	s19, s19, s15
                sample *= tExpSmooth_tick(&comp);
 8018580:	f00d fd10 	bl	8025fa4 <tExpSmooth_tick>
 8018584:	ee29 0a80 	vmul.f32	s0, s19, s0
 8018588:	e69c      	b.n	80182c4 <SFXVocoderChTick+0x3c>
                    tExpSmooth_setDest(&noiseRamp,zerocross > ((displayValues[4])-0.1f));
 801858a:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801858e:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8018592:	2200      	movs	r2, #0
 8018594:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8018598:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 801859c:	edd7 6a04 	vldr	s13, [r7, #16]
 80185a0:	ee07 2a10 	vmov	s14, r2
 80185a4:	f248 2028 	movw	r0, #33320	; 0x8228
 80185a8:	ee07 3a90 	vmov	s15, r3
 80185ac:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80185b0:	ee76 7ae7 	vsub.f32	s15, s13, s15
 80185b4:	eef4 7ac0 	vcmpe.f32	s15, s0
 80185b8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80185bc:	bf54      	ite	pl
 80185be:	eeb0 0a47 	vmovpl.f32	s0, s14
 80185c2:	eeb0 0a46 	vmovmi.f32	s0, s12
 80185c6:	f00d fce3 	bl	8025f90 <tExpSmooth_setDest>
 80185ca:	e75f      	b.n	801848c <SFXVocoderChTick+0x204>
            for (int i = 0; i < numberOfVocoderBands; i++)
 80185cc:	ee08 3a10 	vmov	s16, r3
 80185d0:	ee08 3a90 	vmov	s17, r3
 80185d4:	e703      	b.n	80183de <SFXVocoderChTick+0x156>
 80185d6:	bf00      	nop

080185d8 <SFXVocoderChFree>:
        {
 80185d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80185da:	f248 2438 	movw	r4, #33336	; 0x8238
 80185de:	f247 662c 	movw	r6, #30252	; 0x762c
 80185e2:	f247 452c 	movw	r5, #29740	; 0x742c
 80185e6:	f2c2 0401 	movt	r4, #8193	; 0x2001
 80185ea:	f2c2 0601 	movt	r6, #8193	; 0x2001
 80185ee:	f2c2 0501 	movt	r5, #8193	; 0x2001
 80185f2:	f104 07c0 	add.w	r7, r4, #192	; 0xc0
                tVZFilter_free(&analysisBands[i][0]);
 80185f6:	4620      	mov	r0, r4
 80185f8:	f00e fa32 	bl	8026a60 <tVZFilter_free>
                tVZFilter_free(&analysisBands[i][1]);
 80185fc:	1d20      	adds	r0, r4, #4
 80185fe:	f00e fa2f 	bl	8026a60 <tVZFilter_free>
                tVZFilter_free(&synthesisBands[i][0]);
 8018602:	1f28      	subs	r0, r5, #4
 8018604:	f00e fa2c 	bl	8026a60 <tVZFilter_free>
 8018608:	3408      	adds	r4, #8
                tVZFilter_free(&synthesisBands[i][1]);
 801860a:	4628      	mov	r0, r5
 801860c:	3508      	adds	r5, #8
 801860e:	f00e fa27 	bl	8026a60 <tVZFilter_free>
                tExpSmooth_free(&envFollowers[i]);
 8018612:	4630      	mov	r0, r6
 8018614:	f00d fca6 	bl	8025f64 <tExpSmooth_free>
            for (int i = 0; i < MAX_NUM_VOCODER_BANDS; i++)
 8018618:	42a7      	cmp	r7, r4
 801861a:	f106 0604 	add.w	r6, r6, #4
 801861e:	d1ea      	bne.n	80185f6 <SFXVocoderChFree+0x1e>
            tNoise_free(&breathNoise);
 8018620:	f642 0018 	movw	r0, #10264	; 0x2818
 8018624:	f247 26dc 	movw	r6, #29404	; 0x72dc
 8018628:	f642 0548 	movw	r5, #10312	; 0x2848
            tHighpass_free(&chVocFinalHP2);
 801862c:	2400      	movs	r4, #0
            tNoise_free(&breathNoise);
 801862e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018632:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8018636:	f010 f9cf 	bl	80289d8 <tNoise_free>
            tNoise_free(&vocoderNoise);
 801863a:	f243 4064 	movw	r0, #13412	; 0x3464
 801863e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8018642:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018646:	f010 f9c7 	bl	80289d8 <tNoise_free>
            tZeroCrossing_free(&zerox);
 801864a:	f247 6090 	movw	r0, #30352	; 0x7690
 801864e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018652:	f009 fe1d 	bl	8022290 <tZeroCrossing_free>
            tExpSmooth_free(&noiseRamp);
 8018656:	f248 2028 	movw	r0, #33320	; 0x8228
 801865a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801865e:	f00d fc81 	bl	8025f64 <tExpSmooth_free>
            tHighpass_free(&noiseHP);
 8018662:	f243 405c 	movw	r0, #13404	; 0x345c
 8018666:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801866a:	f00d ffcf 	bl	802660c <tHighpass_free>
            tVZFilter_free(&vocodec_highshelf);
 801866e:	f247 50f0 	movw	r0, #30192	; 0x75f0
 8018672:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018676:	f00e f9f3 	bl	8026a60 <tVZFilter_free>
            tHighpass_free(&chVocFinalHP1);
 801867a:	f642 003c 	movw	r0, #10300	; 0x283c
 801867e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018682:	f00d ffc3 	bl	802660c <tHighpass_free>
            tHighpass_free(&chVocFinalHP2);
 8018686:	f248 202c 	movw	r0, #33324	; 0x822c
 801868a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801868e:	f00d ffbd 	bl	802660c <tHighpass_free>
                tSawtooth_free(&osc[i]);
 8018692:	1930      	adds	r0, r6, r4
 8018694:	f010 f8fc 	bl	8028890 <tSawtooth_free>
                tRosenbergGlottalPulse_free(&glottal[i]);
 8018698:	1928      	adds	r0, r5, r4
 801869a:	3404      	adds	r4, #4
 801869c:	f00b feae 	bl	80243fc <tRosenbergGlottalPulse_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 80186a0:	2c20      	cmp	r4, #32
 80186a2:	d1f6      	bne.n	8018692 <SFXVocoderChFree+0xba>
        }
 80186a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80186a6:	bf00      	nop

080186a8 <SFXPitchShiftAlloc>:
            tFormantShifter_initToPool(&fs, 7, &smallPool);
 80186a8:	f248 22f8 	movw	r2, #33528	; 0x82f8
 80186ac:	f642 1064 	movw	r0, #10596	; 0x2964
 80186b0:	2107      	movs	r1, #7
 80186b2:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80186b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 80186ba:	b510      	push	{r4, lr}
 80186bc:	ed2d 8b02 	vpush	{d8}
            tFormantShifter_initToPool(&fs, 7, &smallPool);
 80186c0:	f00c fd90 	bl	80251e4 <tFormantShifter_initToPool>
            tRetune_init(&retune, NUM_RETUNE, 1024, 512);
 80186c4:	f242 6088 	movw	r0, #9864	; 0x2688
 80186c8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80186cc:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80186d0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80186d4:	2101      	movs	r1, #1
 80186d6:	f00c fa09 	bl	8024aec <tRetune_init>
            tRetune_init(&retune2, NUM_RETUNE, 1024, 512);
 80186da:	f647 004c 	movw	r0, #30796	; 0x784c
 80186de:	f44f 6280 	mov.w	r2, #1024	; 0x400
 80186e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80186e6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80186ea:	2101      	movs	r1, #1
 80186ec:	f00c f9fe 	bl	8024aec <tRetune_init>
            tRamp_init(&pitchshiftRamp, 100.0f, 1);
 80186f0:	f247 6494 	movw	r4, #30356	; 0x7694
 80186f4:	2300      	movs	r3, #0
 80186f6:	2101      	movs	r1, #1
 80186f8:	f2c2 0401 	movt	r4, #8193	; 0x2001
 80186fc:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
 8018700:	4620      	mov	r0, r4
 8018702:	ee00 3a10 	vmov	s0, r3
 8018706:	f00d fb25 	bl	8025d54 <tRamp_init>
            tRamp_setVal(&pitchshiftRamp, 1.0f);
 801870a:	4620      	mov	r0, r4
 801870c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018710:	f00d fb9e 	bl	8025e50 <tRamp_setVal>
            tSimplePoly_setNumVoices(&poly, 1);
 8018714:	f247 5020 	movw	r0, #29984	; 0x7520
 8018718:	2101      	movs	r1, #1
 801871a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801871e:	f00f ffd1 	bl	80286c4 <tSimplePoly_setNumVoices>
            tExpSmooth_init(&smoother1, 0.0f, 0.01f);
 8018722:	f24d 730a 	movw	r3, #55050	; 0xd70a
 8018726:	2200      	movs	r2, #0
 8018728:	f642 0044 	movw	r0, #10308	; 0x2844
 801872c:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 8018730:	ee00 2a10 	vmov	s0, r2
 8018734:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018738:	ee00 3a90 	vmov	s1, r3
 801873c:	ee08 2a90 	vmov	s17, r2
 8018740:	ee08 3a10 	vmov	s16, r3
 8018744:	f00d fbbe 	bl	8025ec4 <tExpSmooth_init>
            tExpSmooth_init(&smoother2, 0.0f, 0.01f);
 8018748:	f247 0040 	movw	r0, #28736	; 0x7040
 801874c:	eeb0 0a68 	vmov.f32	s0, s17
 8018750:	eef0 0a48 	vmov.f32	s1, s16
 8018754:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018758:	f00d fbb4 	bl	8025ec4 <tExpSmooth_init>
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
 801875c:	eef0 0a48 	vmov.f32	s1, s16
 8018760:	eeb0 0a68 	vmov.f32	s0, s17
 8018764:	f247 7080 	movw	r0, #30592	; 0x7780
        }
 8018768:	ecbd 8b02 	vpop	{d8}
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
 801876c:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 8018770:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            tExpSmooth_init(&smoother3, 0.0f, 0.01f);
 8018774:	f00d bba6 	b.w	8025ec4 <tExpSmooth_init>

08018778 <SFXPitchShiftFrame>:
        }
 8018778:	4770      	bx	lr
 801877a:	bf00      	nop

0801877c <SFXPitchShiftTick>:
        {
 801877c:	b570      	push	{r4, r5, r6, lr}
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 801877e:	f642 5510 	movw	r5, #11536	; 0x2d10
 8018782:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 8018786:	f64c 43cd 	movw	r3, #52429	; 0xcccd
            displayValues[0] = myPitchFactorCombined;
 801878a:	f248 7494 	movw	r4, #34708	; 0x8794
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 801878e:	f2c2 0500 	movt	r5, #8192	; 0x2000
        {
 8018792:	4606      	mov	r6, r0
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 8018794:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
 8018798:	f247 5020 	movw	r0, #29984	; 0x7520
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 801879c:	edd5 6a33 	vldr	s13, [r5, #204]	; 0xcc
            displayValues[0] = myPitchFactorCombined;
 80187a0:	f2c2 0401 	movt	r4, #8193	; 0x2001
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
 80187a4:	ed95 6a32 	vldr	s12, [r5, #200]	; 0xc8
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 80187a8:	ee07 3a90 	vmov	s15, r3
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
 80187ac:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80187b0:	2100      	movs	r1, #0
        {
 80187b2:	ed2d 8b04 	vpush	{d8-d9}
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80187b6:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
        {
 80187ba:	b082      	sub	sp, #8
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80187bc:	eef0 5a48 	vmov.f32	s11, s16
            float myPitchFactorCoarse = (presetKnobValues[Pitchshift][0]*2.0f) - 1.0f;
 80187c0:	eea6 8a07 	vfma.f32	s16, s12, s14
            float myPitchFactorFine = ((presetKnobValues[Pitchshift][1]*2.0f) - 1.0f) * 0.1f;
 80187c4:	eee6 5a87 	vfma.f32	s11, s13, s14
            float myPitchFactorCombined = myPitchFactorFine + myPitchFactorCoarse;
 80187c8:	eea5 8aa7 	vfma.f32	s16, s11, s15
            displayValues[0] = myPitchFactorCombined;
 80187cc:	ed84 8a00 	vstr	s16, [r4]
            displayValues[1] = myPitchFactorCombined;
 80187d0:	ed84 8a01 	vstr	s16, [r4, #4]
            float keyPitch = tSimplePoly_getPitchAndCheckActive(&poly, 0);
 80187d4:	f00f ffa0 	bl	8028718 <tSimplePoly_getPitchAndCheckActive>
 80187d8:	ee07 0a90 	vmov	s15, r0
 80187dc:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
            if (keyPitch >= 0)
 80187e0:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80187e4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80187e8:	f280 80d1 	bge.w	801898e <SFXPitchShiftTick+0x212>
                keyPitch = 1.0f;
 80187ec:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            float myPitchFactor = fastexp2f(myPitchFactorCombined);
 80187f0:	eeb0 0a48 	vmov.f32	s0, s16
 80187f4:	f00e fffc 	bl	80277f0 <fastexp2f>
            myPitchFactor *= keyPitch;
 80187f8:	ee68 8a80 	vmul.f32	s17, s17, s0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
 80187fc:	f242 6088 	movw	r0, #9864	; 0x2688
 8018800:	2100      	movs	r1, #0
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 8018802:	eebf 9a00 	vmov.f32	s18, #240	; 0xbf800000 -1.0
            tRetune_setPitchFactor(&retune, myPitchFactor, 0);
 8018806:	eeb0 0a68 	vmov.f32	s0, s17
 801880a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801880e:	f00c fa91 	bl	8024d34 <tRetune_setPitchFactor>
            tRetune_setPitchFactor(&retune2, myPitchFactor, 0);
 8018812:	f647 004c 	movw	r0, #30796	; 0x784c
 8018816:	2100      	movs	r1, #0
 8018818:	eeb0 0a68 	vmov.f32	s0, s17
 801881c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018820:	f00c fa88 	bl	8024d34 <tRetune_setPitchFactor>
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
 8018824:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8018828:	eeb0 1a08 	vmov.f32	s2, #8	; 0x40400000  3.0
 801882c:	2200      	movs	r2, #0
 801882e:	f6cb 634c 	movt	r3, #48716	; 0xbe4c
 8018832:	edd5 7a34 	vldr	s15, [r5, #208]	; 0xd0
 8018836:	ee00 2a10 	vmov	s0, r2
 801883a:	ee00 3a90 	vmov	s1, r3
 801883e:	eee7 0a81 	vfma.f32	s1, s15, s2
 8018842:	f00f f8b9 	bl	80279b8 <LEAF_clip>
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 8018846:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
            displayValues[2] = LEAF_clip( 0.0f,((presetKnobValues[Pitchshift][2]) * 3.0f) - 0.2f,3.0f);
 801884a:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 801884e:	eeb0 0a49 	vmov.f32	s0, s18
 8018852:	ed95 7a35 	vldr	s14, [r5, #212]	; 0xd4
 8018856:	eea7 0a27 	vfma.f32	s0, s14, s15
 801885a:	f00e ffc9 	bl	80277f0 <fastexp2f>
            tExpSmooth_setDest(&smoother3, displayValues[2]);
 801885e:	f247 7080 	movw	r0, #30592	; 0x7780
            displayValues[3] = fastexp2f((presetKnobValues[Pitchshift][3]*2.0f) - 1.0f);
 8018862:	ed84 0a03 	vstr	s0, [r4, #12]
            tExpSmooth_setDest(&smoother3, displayValues[2]);
 8018866:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801886a:	ed94 0a02 	vldr	s0, [r4, #8]
 801886e:	f00d fb8f 	bl	8025f90 <tExpSmooth_setDest>
            tFormantShifter_setIntensity(&fs, tExpSmooth_tick(&smoother3)+.1f);
 8018872:	f247 7080 	movw	r0, #30592	; 0x7780
 8018876:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801887a:	f00d fb93 	bl	8025fa4 <tExpSmooth_tick>
 801887e:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8018882:	f642 1064 	movw	r0, #10596	; 0x2964
 8018886:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 801888a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801888e:	ee07 3a90 	vmov	s15, r3
 8018892:	ee30 0a27 	vadd.f32	s0, s0, s15
 8018896:	f00c ff69 	bl	802576c <tFormantShifter_setIntensity>
            tFormantShifter_setShiftFactor(&fs, displayValues[3]);
 801889a:	f642 1064 	movw	r0, #10596	; 0x2964
 801889e:	ed94 0a03 	vldr	s0, [r4, #12]
 80188a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80188a6:	f00c ff5d 	bl	8025764 <tFormantShifter_setShiftFactor>
            if (displayValues[2] > 0.01f)
 80188aa:	f24d 730a 	movw	r3, #55050	; 0xd70a
 80188ae:	ed94 7a02 	vldr	s14, [r4, #8]
                tRamp_setDest(&pitchshiftRamp, -1.0f);
 80188b2:	f247 6094 	movw	r0, #30356	; 0x7694
            if (displayValues[2] > 0.01f)
 80188b6:	f6c3 4323 	movt	r3, #15395	; 0x3c23
                tRamp_setDest(&pitchshiftRamp, 1.0f);
 80188ba:	f2c2 0001 	movt	r0, #8193	; 0x2001
            if (displayValues[2] > 0.01f)
 80188be:	ee07 3a90 	vmov	s15, r3
 80188c2:	eeb4 7ae7 	vcmpe.f32	s14, s15
 80188c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                tRamp_setDest(&pitchshiftRamp, -1.0f);
 80188ca:	bfcc      	ite	gt
 80188cc:	eeb0 0a49 	vmovgt.f32	s0, s18
                tRamp_setDest(&pitchshiftRamp, 1.0f);
 80188d0:	eeb7 0a00 	vmovle.f32	s0, #112	; 0x3f800000  1.0
 80188d4:	f00d faae 	bl	8025e34 <tRamp_setDest>
            float crossfadeVal = tRamp_tick(&pitchshiftRamp);
 80188d8:	f247 6094 	movw	r0, #30356	; 0x7694
 80188dc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80188e0:	f00d fac4 	bl	8025e6c <tRamp_tick>
            LEAF_crossfade(crossfadeVal, myGains);
 80188e4:	4668      	mov	r0, sp
 80188e6:	f00e ffd7 	bl	8027898 <LEAF_crossfade>
            tExpSmooth_setDest(&smoother1, myGains[0]);
 80188ea:	f642 0044 	movw	r0, #10308	; 0x2844
 80188ee:	ed9d 0a00 	vldr	s0, [sp]
 80188f2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80188f6:	f00d fb4b 	bl	8025f90 <tExpSmooth_setDest>
            tExpSmooth_setDest(&smoother2, myGains[1]);
 80188fa:	f247 0040 	movw	r0, #28736	; 0x7040
 80188fe:	ed9d 0a01 	vldr	s0, [sp, #4]
 8018902:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018906:	f00d fb43 	bl	8025f90 <tExpSmooth_setDest>
            float formantsample = tanhf(tFormantShifter_remove(&fs, input[1]));
 801890a:	f642 1064 	movw	r0, #10596	; 0x2964
 801890e:	ed96 0a01 	vldr	s0, [r6, #4]
 8018912:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018916:	f00c fd6b 	bl	80253f0 <tFormantShifter_remove>
 801891a:	f012 fe23 	bl	802b564 <tanhf>
            float* samples = tRetune_tick(&retune2, formantsample);
 801891e:	f647 004c 	movw	r0, #30796	; 0x784c
 8018922:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018926:	f00c f92f 	bl	8024b88 <tRetune_tick>
            formantsample = samples[0];
 801892a:	edd0 8a00 	vldr	s17, [r0]
            samples = tRetune_tick(&retune, sample);
 801892e:	f242 6088 	movw	r0, #9864	; 0x2688
 8018932:	ed96 0a01 	vldr	s0, [r6, #4]
 8018936:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801893a:	f00c f925 	bl	8024b88 <tRetune_tick>
            sample = samples[0];
 801893e:	ed90 8a00 	vldr	s16, [r0]
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
 8018942:	f642 1064 	movw	r0, #10596	; 0x2964
 8018946:	eeb0 0a68 	vmov.f32	s0, s17
 801894a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801894e:	f00c fdd3 	bl	80254f8 <tFormantShifter_add>
 8018952:	f012 fe07 	bl	802b564 <tanhf>
 8018956:	f247 0040 	movw	r0, #28736	; 0x7040
 801895a:	eeb0 9a40 	vmov.f32	s18, s0
 801895e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018962:	f00d fb1f 	bl	8025fa4 <tExpSmooth_tick>
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
 8018966:	f642 0044 	movw	r0, #10308	; 0x2844
            formantsample = tanhf(tFormantShifter_add(&fs, formantsample)) * tExpSmooth_tick(&smoother2) ;
 801896a:	eef0 8a40 	vmov.f32	s17, s0
            sample = (sample * (tExpSmooth_tick(&smoother1))) +  formantsample;
 801896e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018972:	f00d fb17 	bl	8025fa4 <tExpSmooth_tick>
 8018976:	ee20 0a08 	vmul.f32	s0, s0, s16
 801897a:	eea9 0a28 	vfma.f32	s0, s18, s17
            input[0] = sample;
 801897e:	ed86 0a00 	vstr	s0, [r6]
            input[1] = sample;
 8018982:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 8018986:	b002      	add	sp, #8
 8018988:	ecbd 8b04 	vpop	{d8-d9}
 801898c:	bd70      	pop	{r4, r5, r6, pc}
                keyPitch = LEAF_midiToFrequency(keyPitch) * 0.003822629969419f ;
 801898e:	f00f f8fd 	bl	8027b8c <LEAF_midiToFrequency>
 8018992:	f248 5317 	movw	r3, #34071	; 0x8517
 8018996:	f6c3 337a 	movt	r3, #15226	; 0x3b7a
 801899a:	ee08 3a90 	vmov	s17, r3
 801899e:	ee60 8a28 	vmul.f32	s17, s0, s17
 80189a2:	e725      	b.n	80187f0 <SFXPitchShiftTick+0x74>

080189a4 <SFXPitchShiftFree>:
            tFormantShifter_free(&fs);
 80189a4:	f642 1064 	movw	r0, #10596	; 0x2964
        {
 80189a8:	b508      	push	{r3, lr}
            tFormantShifter_free(&fs);
 80189aa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80189ae:	f00c fce3 	bl	8025378 <tFormantShifter_free>
            tRetune_free(&retune);
 80189b2:	f242 6088 	movw	r0, #9864	; 0x2688
 80189b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80189ba:	f00c f8a3 	bl	8024b04 <tRetune_free>
            tRetune_free(&retune2);
 80189be:	f647 004c 	movw	r0, #30796	; 0x784c
 80189c2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80189c6:	f00c f89d 	bl	8024b04 <tRetune_free>
            tRamp_free(&pitchshiftRamp);
 80189ca:	f247 6094 	movw	r0, #30356	; 0x7694
 80189ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80189d2:	f00d fa2b 	bl	8025e2c <tRamp_free>
            tExpSmooth_free(&smoother1);
 80189d6:	f642 0044 	movw	r0, #10308	; 0x2844
 80189da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80189de:	f00d fac1 	bl	8025f64 <tExpSmooth_free>
            tExpSmooth_free(&smoother2);
 80189e2:	f247 0040 	movw	r0, #28736	; 0x7040
 80189e6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80189ea:	f00d fabb 	bl	8025f64 <tExpSmooth_free>
            tExpSmooth_free(&smoother3);
 80189ee:	f247 7080 	movw	r0, #30592	; 0x7780
        }
 80189f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&smoother3);
 80189f6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80189fa:	f00d bab3 	b.w	8025f64 <tExpSmooth_free>
 80189fe:	bf00      	nop

08018a00 <SFXNeartuneAlloc>:
        {
 8018a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            leaf.clearOnAllocation = 1;
 8018a02:	f249 44a0 	movw	r4, #38048	; 0x94a0
 8018a06:	2501      	movs	r5, #1
            tRetune_init(&autotuneMono, 1, 512, 256);
 8018a08:	f247 5018 	movw	r0, #29976	; 0x7518
 8018a0c:	f44f 7380 	mov.w	r3, #256	; 0x100
            leaf.clearOnAllocation = 1;
 8018a10:	f2c2 0401 	movt	r4, #8193	; 0x2001
            tRetune_init(&autotuneMono, 1, 512, 256);
 8018a14:	4629      	mov	r1, r5
 8018a16:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018a1a:	f44f 7200 	mov.w	r2, #512	; 0x200
            leaf.clearOnAllocation = 1;
 8018a1e:	6165      	str	r5, [r4, #20]
            tRetune_init(&autotuneMono, 1, 512, 256);
 8018a20:	f00c f864 	bl	8024aec <tRetune_init>
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018a24:	f240 6354 	movw	r3, #1620	; 0x654
 8018a28:	f642 2048 	movw	r0, #10824	; 0x2a48
 8018a2c:	f240 6520 	movw	r5, #1568	; 0x620
 8018a30:	f64a 26ab 	movw	r6, #43691	; 0xaaab
 8018a34:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018a38:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018a3c:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8018a40:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
 8018a44:	781f      	ldrb	r7, [r3, #0]
            for (int i = 0; i < 128; i++)
 8018a46:	2100      	movs	r1, #0
                float tempNote = i;
 8018a48:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
 8018a4c:	3101      	adds	r1, #1
                float tempNote = i;
 8018a4e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 8018a52:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018a54:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8018a58:	ee17 3a90 	vmov	r3, s15
 8018a5c:	eba3 0307 	sub.w	r3, r3, r7
 8018a60:	fb86 2403 	smull	r2, r4, r6, r3
 8018a64:	ea4f 72e3 	mov.w	r2, r3, asr #31
 8018a68:	ebc2 0264 	rsb	r2, r2, r4, asr #1
 8018a6c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8018a70:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8018a74:	ee07 3a90 	vmov	s15, r3
 8018a78:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018a7c:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8018a80:	ee17 3a90 	vmov	r3, s15
 8018a84:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8018a88:	edd3 7a00 	vldr	s15, [r3]
 8018a8c:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
 8018a90:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
 8018a94:	d1d8      	bne.n	8018a48 <SFXNeartuneAlloc+0x48>
            tExpSmooth_init(&neartune_smoother, 1.0f, .007f);
 8018a96:	f246 0342 	movw	r3, #24642	; 0x6042
 8018a9a:	f247 50e8 	movw	r0, #30184	; 0x75e8
 8018a9e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018aa2:	f6c3 33e5 	movt	r3, #15333	; 0x3be5
 8018aa6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018aaa:	ee00 3a90 	vmov	s1, r3
 8018aae:	f00d fa09 	bl	8025ec4 <tExpSmooth_init>
            tRamp_init(&nearWetRamp, 20.0f, 1);
 8018ab2:	f248 3064 	movw	r0, #33636	; 0x8364
 8018ab6:	2101      	movs	r1, #1
 8018ab8:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8018abc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018ac0:	f00d f948 	bl	8025d54 <tRamp_init>
            setLED_A(autotuneChromatic);
 8018ac4:	f240 531c 	movw	r3, #1308	; 0x51c
 8018ac8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018acc:	7818      	ldrb	r0, [r3, #0]
 8018ace:	f7fc ff0d 	bl	80158ec <setLED_A>
            setLED_C(autotuneLock);
 8018ad2:	f240 5320 	movw	r3, #1312	; 0x520
 8018ad6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018ada:	7818      	ldrb	r0, [r3, #0]
 8018adc:	f7fc ff26 	bl	801592c <setLED_C>
            lastSnap = 1.0f;
 8018ae0:	f240 234c 	movw	r3, #588	; 0x24c
 8018ae4:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
 8018ae8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018aec:	601a      	str	r2, [r3, #0]
        }
 8018aee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08018af0 <SFXNeartuneFrame>:
            if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
 8018af0:	f247 5020 	movw	r0, #29984	; 0x7520
        {
 8018af4:	b538      	push	{r3, r4, r5, lr}
            if ((tSimplePoly_getNumActiveVoices(&poly) != 0) || (autotuneChromatic == 1) || (autotuneLock == 1))
 8018af6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018afa:	f00f fdef 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 8018afe:	bb60      	cbnz	r0, 8018b5a <SFXNeartuneFrame+0x6a>
 8018b00:	f240 531c 	movw	r3, #1308	; 0x51c
 8018b04:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018b08:	781b      	ldrb	r3, [r3, #0]
 8018b0a:	2b01      	cmp	r3, #1
 8018b0c:	d025      	beq.n	8018b5a <SFXNeartuneFrame+0x6a>
 8018b0e:	f240 5320 	movw	r3, #1312	; 0x520
 8018b12:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018b16:	681b      	ldr	r3, [r3, #0]
 8018b18:	2b01      	cmp	r3, #1
 8018b1a:	d01e      	beq.n	8018b5a <SFXNeartuneFrame+0x6a>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b1c:	f248 64e4 	movw	r4, #34532	; 0x86e4
                tRamp_setDest(&nearWetRamp, -1.0f);
 8018b20:	f248 3064 	movw	r0, #33636	; 0x8364
 8018b24:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b28:	f2c2 0401 	movt	r4, #8193	; 0x2001
                tRamp_setDest(&nearWetRamp, -1.0f);
 8018b2c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018b30:	f00d f980 	bl	8025e34 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b34:	7d23      	ldrb	r3, [r4, #20]
 8018b36:	b1fb      	cbz	r3, 8018b78 <SFXNeartuneFrame+0x88>
                autotuneChromatic = !autotuneChromatic;
 8018b38:	f240 521c 	movw	r2, #1308	; 0x51c
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8018b3c:	2300      	movs	r3, #0
                autotuneChromatic = !autotuneChromatic;
 8018b3e:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8018b42:	7523      	strb	r3, [r4, #20]
                autotuneChromatic = !autotuneChromatic;
 8018b44:	7813      	ldrb	r3, [r2, #0]
 8018b46:	fab3 f383 	clz	r3, r3
 8018b4a:	095b      	lsrs	r3, r3, #5
                setLED_A(autotuneChromatic);
 8018b4c:	4618      	mov	r0, r3
                autotuneChromatic = !autotuneChromatic;
 8018b4e:	7013      	strb	r3, [r2, #0]
                setLED_A(autotuneChromatic);
 8018b50:	f7fc fecc 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018b54:	7f23      	ldrb	r3, [r4, #28]
 8018b56:	b993      	cbnz	r3, 8018b7e <SFXNeartuneFrame+0x8e>
        }
 8018b58:	bd38      	pop	{r3, r4, r5, pc}
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b5a:	f248 64e4 	movw	r4, #34532	; 0x86e4
                tRamp_setDest(&nearWetRamp, 1.0f);
 8018b5e:	f248 3064 	movw	r0, #33636	; 0x8364
 8018b62:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b66:	f2c2 0401 	movt	r4, #8193	; 0x2001
                tRamp_setDest(&nearWetRamp, 1.0f);
 8018b6a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018b6e:	f00d f961 	bl	8025e34 <tRamp_setDest>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018b72:	7d23      	ldrb	r3, [r4, #20]
 8018b74:	2b00      	cmp	r3, #0
 8018b76:	d1df      	bne.n	8018b38 <SFXNeartuneFrame+0x48>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018b78:	7f23      	ldrb	r3, [r4, #28]
 8018b7a:	2b00      	cmp	r3, #0
 8018b7c:	d0ec      	beq.n	8018b58 <SFXNeartuneFrame+0x68>
                autotuneLock = !autotuneLock;
 8018b7e:	f240 5520 	movw	r5, #1312	; 0x520
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018b82:	2300      	movs	r3, #0
                autotuneLock = !autotuneLock;
 8018b84:	f2c2 0500 	movt	r5, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8018b88:	7723      	strb	r3, [r4, #28]
                autotuneLock = !autotuneLock;
 8018b8a:	682b      	ldr	r3, [r5, #0]
 8018b8c:	fab3 f383 	clz	r3, r3
 8018b90:	095b      	lsrs	r3, r3, #5
                setLED_C(autotuneLock);
 8018b92:	4618      	mov	r0, r3
                autotuneLock = !autotuneLock;
 8018b94:	602b      	str	r3, [r5, #0]
                setLED_C(autotuneLock);
 8018b96:	f7fc fec9 	bl	801592c <setLED_C>
                if (autotuneLock)
 8018b9a:	6829      	ldr	r1, [r5, #0]
 8018b9c:	b181      	cbz	r1, 8018bc0 <SFXNeartuneFrame+0xd0>
 8018b9e:	f240 5530 	movw	r5, #1328	; 0x530
 8018ba2:	f240 54a8 	movw	r4, #1448	; 0x5a8
 8018ba6:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8018baa:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8018bae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018bb0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018bb2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8018bb4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8018bb6:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8018bba:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
        }
 8018bbe:	bd38      	pop	{r3, r4, r5, pc}
 8018bc0:	f240 50a8 	movw	r0, #1448	; 0x5a8
 8018bc4:	2230      	movs	r2, #48	; 0x30
 8018bc6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018bca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8018bce:	f012 b894 	b.w	802acfa <memset>
 8018bd2:	bf00      	nop

08018bd4 <SFXNeartuneFree>:
            tRetune_free(&autotuneMono);
 8018bd4:	f247 5018 	movw	r0, #29976	; 0x7518
        {
 8018bd8:	b508      	push	{r3, lr}
            tRetune_free(&autotuneMono);
 8018bda:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018bde:	f00b ff91 	bl	8024b04 <tRetune_free>
            tExpSmooth_free(&neartune_smoother);
 8018be2:	f247 50e8 	movw	r0, #30184	; 0x75e8
 8018be6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018bea:	f00d f9bb 	bl	8025f64 <tExpSmooth_free>
            tRamp_free(&nearWetRamp);
 8018bee:	f248 3064 	movw	r0, #33636	; 0x8364
        }
 8018bf2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tRamp_free(&nearWetRamp);
 8018bf6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018bfa:	f00d b917 	b.w	8025e2c <tRamp_free>
 8018bfe:	bf00      	nop

08018c00 <SFXAutotuneAlloc>:
            tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
 8018c00:	f243 4038 	movw	r0, #13368	; 0x3438
 8018c04:	2104      	movs	r1, #4
 8018c06:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8018c0a:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 8018c0e:	b508      	push	{r3, lr}
            tAutotune_init(&autotunePoly, NUM_AUTOTUNE, 1024, 512);
 8018c10:	f44f 7300 	mov.w	r3, #512	; 0x200
 8018c14:	f00c f98c 	bl	8024f30 <tAutotune_init>
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
 8018c18:	f247 5020 	movw	r0, #29984	; 0x7520
 8018c1c:	2104      	movs	r1, #4
 8018c1e:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 8018c22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tSimplePoly_setNumVoices(&poly, NUM_AUTOTUNE);
 8018c26:	f00f bd4d 	b.w	80286c4 <tSimplePoly_setNumVoices>
 8018c2a:	bf00      	nop

08018c2c <SFXAutotuneFrame>:
        {
 8018c2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8018c30:	2300      	movs	r3, #0
 8018c32:	f243 473c 	movw	r7, #13372	; 0x343c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018c36:	f247 5520 	movw	r5, #29984	; 0x7520
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c3a:	f64a 28ab 	movw	r8, #43691	; 0xaaab
 8018c3e:	f2c2 0700 	movt	r7, #8192	; 0x2000
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018c42:	461c      	mov	r4, r3
 8018c44:	f2c2 0501 	movt	r5, #8193	; 0x2001
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c48:	f6c2 28aa 	movt	r8, #10922	; 0x2aaa
        {
 8018c4c:	ed2d 8b02 	vpush	{d8}
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8018c50:	ee08 3a10 	vmov	s16, r3
        {
 8018c54:	b082      	sub	sp, #8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018c56:	e049      	b.n	8018cec <SFXAutotuneFrame+0xc0>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018c58:	f00f fd58 	bl	802870c <tSimplePoly_getPitch>
 8018c5c:	f240 52d8 	movw	r2, #1496	; 0x5d8
 8018c60:	ee07 0a90 	vmov	s15, r0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c64:	f240 6354 	movw	r3, #1620	; 0x654
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018c68:	f2c2 0200 	movt	r2, #8192	; 0x2000
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018c6c:	f240 6120 	movw	r1, #1568	; 0x620
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018c70:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c74:	f2c2 0300 	movt	r3, #8192	; 0x2000
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018c78:	ed92 0a00 	vldr	s0, [r2]
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018c7c:	f2c2 0100 	movt	r1, #8192	; 0x2000
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c80:	781a      	ldrb	r2, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018c82:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 8018c86:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 8018c8a:	ee17 3a90 	vmov	r3, s15
 8018c8e:	1a9b      	subs	r3, r3, r2
 8018c90:	fb88 2003 	smull	r2, r0, r8, r3
 8018c94:	17da      	asrs	r2, r3, #31
 8018c96:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 8018c9a:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 8018c9e:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 8018ca2:	ee07 3a90 	vmov	s15, r3
 8018ca6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 8018caa:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8018cae:	ee17 3a90 	vmov	r3, s15
 8018cb2:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 8018cb6:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8018cba:	ee37 0a00 	vadd.f32	s0, s14, s0
 8018cbe:	f00e ff65 	bl	8027b8c <LEAF_midiToFrequency>
 8018cc2:	f647 131c 	movw	r3, #31004	; 0x791c
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8018cc6:	4631      	mov	r1, r6
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 8018cc8:	eca7 0a01 	vstmia	r7!, {s0}
 8018ccc:	f2c2 0301 	movt	r3, #8193	; 0x2001
                tExpSmooth_setDest(&polyRamp[i], (tSimplePoly_getVelocity(&poly, i) > 0));
 8018cd0:	4628      	mov	r0, r5
 8018cd2:	eb03 0684 	add.w	r6, r3, r4, lsl #2
 8018cd6:	3401      	adds	r4, #1
 8018cd8:	f00f fd24 	bl	8028724 <tSimplePoly_getVelocity>
 8018cdc:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018ce0:	2800      	cmp	r0, #0
 8018ce2:	4630      	mov	r0, r6
 8018ce4:	fe30 0a08 	vselgt.f32	s0, s0, s16
 8018ce8:	f00d f952 	bl	8025f90 <tExpSmooth_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018cec:	4628      	mov	r0, r5
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018cee:	b2e6      	uxtb	r6, r4
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018cf0:	f00f fcf0 	bl	80286d4 <tSimplePoly_getNumVoices>
 8018cf4:	42a0      	cmp	r0, r4
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 8018cf6:	4631      	mov	r1, r6
 8018cf8:	4628      	mov	r0, r5
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018cfa:	dcad      	bgt.n	8018c58 <SFXAutotuneFrame+0x2c>
            int tempNumVoices = tSimplePoly_getNumActiveVoices(&poly);
 8018cfc:	f247 5020 	movw	r0, #29984	; 0x7520
 8018d00:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018d04:	f00f fcea 	bl	80286dc <tSimplePoly_getNumActiveVoices>
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 8018d08:	9001      	str	r0, [sp, #4]
 8018d0a:	b920      	cbnz	r0, 8018d16 <SFXAutotuneFrame+0xea>
        }
 8018d0c:	b002      	add	sp, #8
 8018d0e:	ecbd 8b02 	vpop	{d8}
 8018d12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 8018d16:	ee07 0a90 	vmov	s15, r0
 8018d1a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8018d1e:	f247 205c 	movw	r0, #29276	; 0x725c
 8018d22:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8018d26:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018d2a:	ee80 0a27 	vdiv.f32	s0, s0, s15
        }
 8018d2e:	b002      	add	sp, #8
 8018d30:	ecbd 8b02 	vpop	{d8}
 8018d34:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            if (tempNumVoices != 0) tExpSmooth_setDest(&comp, 1.0f / (float)tempNumVoices);
 8018d38:	f00d b92a 	b.w	8025f90 <tExpSmooth_setDest>

08018d3c <SFXAutotuneTick>:
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 8018d3c:	f642 5110 	movw	r1, #11536	; 0x2d10
 8018d40:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
 8018d44:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8018d48:	f248 7294 	movw	r2, #34708	; 0x8794
 8018d4c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8018d50:	f6c3 63f0 	movt	r3, #16112	; 0x3ef0
 8018d54:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8018d58:	ee07 3a10 	vmov	s14, r3
        {
 8018d5c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018d60:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 8018d64:	edd1 6a64 	vldr	s13, [r1, #400]	; 0x190
        {
 8018d68:	4680      	mov	r8, r0
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 8018d6a:	f243 4038 	movw	r0, #13368	; 0x3438
 8018d6e:	f243 453c 	movw	r5, #13372	; 0x343c
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 8018d72:	eee6 7a87 	vfma.f32	s15, s13, s14
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018d76:	f247 5720 	movw	r7, #29984	; 0x7520
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 8018d7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018d7e:	f2c2 0500 	movt	r5, #8192	; 0x2000
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018d82:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8018d86:	2400      	movs	r4, #0
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 8018d88:	4606      	mov	r6, r0
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 8018d8a:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[0] = 0.5f + (presetKnobValues[AutotunePoly][0] * 0.47f);
 8018d8e:	edc2 7a00 	vstr	s15, [r2]
            tAutotune_setFidelityThreshold(&autotunePoly, displayValues[0]);
 8018d92:	f00c fa23 	bl	80251dc <tAutotune_setFidelityThreshold>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018d96:	e003      	b.n	8018da0 <SFXAutotuneTick+0x64>
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 8018d98:	ecb5 0a01 	vldmia	r5!, {s0}
 8018d9c:	f00c fa16 	bl	80251cc <tAutotune_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018da0:	4638      	mov	r0, r7
 8018da2:	f00f fc97 	bl	80286d4 <tSimplePoly_getNumVoices>
 8018da6:	42a0      	cmp	r0, r4
                tAutotune_setFreq(&autotunePoly, freq[i], i);
 8018da8:	4621      	mov	r1, r4
 8018daa:	4630      	mov	r0, r6
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018dac:	f104 0401 	add.w	r4, r4, #1
 8018db0:	dcf2      	bgt.n	8018d98 <SFXAutotuneTick+0x5c>
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 8018db2:	f243 4038 	movw	r0, #13368	; 0x3438
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018db6:	f247 5720 	movw	r7, #29984	; 0x7520
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8018dba:	f647 161c 	movw	r6, #31004	; 0x791c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018dbe:	2400      	movs	r4, #0
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 8018dc0:	ed98 0a01 	vldr	s0, [r8, #4]
 8018dc4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018dc8:	f00c f900 	bl	8024fcc <tAutotune_tick>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018dcc:	f2c2 0701 	movt	r7, #8193	; 0x2001
            float* samples = tAutotune_tick(&autotunePoly, input[1]);
 8018dd0:	4605      	mov	r5, r0
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8018dd2:	f2c2 0601 	movt	r6, #8193	; 0x2001
            float sample = 0.0f;
 8018dd6:	ee08 4a10 	vmov	s16, r4
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018dda:	e005      	b.n	8018de8 <SFXAutotuneTick+0xac>
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8018ddc:	ecf5 8a01 	vldmia	r5!, {s17}
 8018de0:	f00d f8e0 	bl	8025fa4 <tExpSmooth_tick>
 8018de4:	eea8 8a80 	vfma.f32	s16, s17, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018de8:	4638      	mov	r0, r7
 8018dea:	f00f fc73 	bl	80286d4 <tSimplePoly_getNumVoices>
 8018dee:	42a0      	cmp	r0, r4
                sample += samples[i] * tExpSmooth_tick(&polyRamp[i]);
 8018df0:	eb06 0084 	add.w	r0, r6, r4, lsl #2
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); ++i)
 8018df4:	f104 0401 	add.w	r4, r4, #1
 8018df8:	dcf0      	bgt.n	8018ddc <SFXAutotuneTick+0xa0>
            sample *= tExpSmooth_tick(&comp);
 8018dfa:	f247 205c 	movw	r0, #29276	; 0x725c
 8018dfe:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018e02:	f00d f8cf 	bl	8025fa4 <tExpSmooth_tick>
 8018e06:	ee28 0a00 	vmul.f32	s0, s16, s0
            input[0] = sample;
 8018e0a:	ed88 0a00 	vstr	s0, [r8]
            input[1] = sample;
 8018e0e:	ed88 0a01 	vstr	s0, [r8, #4]
        }
 8018e12:	ecbd 8b02 	vpop	{d8}
 8018e16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8018e1a:	bf00      	nop

08018e1c <SFXAutotuneFree>:
            tAutotune_free(&autotunePoly);
 8018e1c:	f243 4038 	movw	r0, #13368	; 0x3438
 8018e20:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8018e24:	f00c b890 	b.w	8024f48 <tAutotune_free>

08018e28 <SFXSamplerBPAlloc>:
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8018e28:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8018e2c:	2300      	movs	r3, #0
 8018e2e:	f247 5210 	movw	r2, #29968	; 0x7510
 8018e32:	f2c4 332c 	movt	r3, #17196	; 0x432c
 8018e36:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8018e3a:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8018e3e:	ee07 3a90 	vmov	s15, r3
        {
 8018e42:	b570      	push	{r4, r5, r6, lr}
 8018e44:	ed2d 8b02 	vpush	{d8}
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8018e48:	ed91 7a00 	vldr	s14, [r1]
 8018e4c:	f243 54f0 	movw	r4, #13808	; 0x35f0
            tSampler_init(&sampler, &buff);
 8018e50:	f247 2654 	movw	r6, #29268	; 0x7254
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
 8018e54:	f248 25f8 	movw	r5, #33528	; 0x82f8
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8018e58:	ee67 7a27 	vmul.f32	s15, s14, s15
 8018e5c:	f2c2 0400 	movt	r4, #8192	; 0x2000
            tSampler_init(&sampler, &buff);
 8018e60:	f2c2 0601 	movt	r6, #8193	; 0x2001
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
 8018e64:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tBuffer_initToPool(&buff, leaf.sampleRate * 172.0f, &largePool);
 8018e68:	4620      	mov	r0, r4
 8018e6a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8018e6e:	ee17 1a90 	vmov	r1, s15
 8018e72:	f011 f86d 	bl	8029f50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&buff, RecordOneShot);
 8018e76:	4620      	mov	r0, r4
 8018e78:	2100      	movs	r1, #0
 8018e7a:	f011 f8cd 	bl	802a018 <tBuffer_setRecordMode>
            tSampler_init(&sampler, &buff);
 8018e7e:	4621      	mov	r1, r4
 8018e80:	4630      	mov	r0, r6
 8018e82:	f011 f8d9 	bl	802a038 <tSampler_init>
            tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 8018e86:	f240 5324 	movw	r3, #1316	; 0x524
 8018e8a:	4630      	mov	r0, r6
 8018e8c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8018e90:	6819      	ldr	r1, [r3, #0]
 8018e92:	3101      	adds	r1, #1
 8018e94:	b2c9      	uxtb	r1, r1
 8018e96:	f011 f96b 	bl	802a170 <tSampler_setMode>
            tExpSmooth_initToPool(&startSmooth, 0.0f, 0.01f, &smallPool);
 8018e9a:	f24d 730a 	movw	r3, #55050	; 0xd70a
 8018e9e:	2200      	movs	r2, #0
 8018ea0:	f247 7084 	movw	r0, #30596	; 0x7784
 8018ea4:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 8018ea8:	4629      	mov	r1, r5
 8018eaa:	ee08 2a90 	vmov	s17, r2
 8018eae:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8018eb2:	ee08 3a10 	vmov	s16, r3
 8018eb6:	ee00 2a10 	vmov	s0, r2
 8018eba:	ee00 3a90 	vmov	s1, r3
 8018ebe:	f00d f82b 	bl	8025f18 <tExpSmooth_initToPool>
            tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
 8018ec2:	eef0 0a48 	vmov.f32	s1, s16
 8018ec6:	eeb0 0a68 	vmov.f32	s0, s17
 8018eca:	f247 0024 	movw	r0, #28708	; 0x7024
 8018ece:	4629      	mov	r1, r5
 8018ed0:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 8018ed4:	ecbd 8b02 	vpop	{d8}
 8018ed8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tExpSmooth_initToPool(&lengthSmooth, 0.0f, 0.01f, &smallPool);
 8018edc:	f00d b81c 	b.w	8025f18 <tExpSmooth_initToPool>

08018ee0 <SFXSamplerBPFrame>:
 8018ee0:	4770      	bx	lr
 8018ee2:	bf00      	nop

08018ee4 <SFXSamplerBPTick>:
        {
 8018ee4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018ee8:	f248 66e4 	movw	r6, #34532	; 0x86e4
        {
 8018eec:	4681      	mov	r9, r0
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8018eee:	f243 50f0 	movw	r0, #13808	; 0x35f0
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018ef2:	f2c2 0601 	movt	r6, #8193	; 0x2001
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8018ef6:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 8018efa:	ed2d 8b02 	vpush	{d8}
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8018efe:	f011 f883 	bl	802a008 <tBuffer_getRecordPosition>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018f02:	7f33      	ldrb	r3, [r6, #28]
            int recordPosition = tBuffer_getRecordPosition(&buff);
 8018f04:	ee08 0a10 	vmov	s16, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
 8018f08:	2b00      	cmp	r3, #0
 8018f0a:	f040 80de 	bne.w	80190ca <SFXSamplerBPTick+0x1e6>
 8018f0e:	f240 57fc 	movw	r7, #1532	; 0x5fc
 8018f12:	f642 5410 	movw	r4, #11536	; 0x2d10
 8018f16:	f248 7594 	movw	r5, #34708	; 0x8794
            if (buttonActionsSFX[ButtonB][ActionPress])
 8018f1a:	7e33      	ldrb	r3, [r6, #24]
 8018f1c:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8018f20:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8018f24:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8018f28:	2b00      	cmp	r3, #0
 8018f2a:	f040 80ef 	bne.w	801910c <SFXSamplerBPTick+0x228>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8018f2e:	7d33      	ldrb	r3, [r6, #20]
 8018f30:	2b00      	cmp	r3, #0
 8018f32:	f040 8107 	bne.w	8019144 <SFXSamplerBPTick+0x260>
            if (buttonActionsSFX[ButtonA][ActionRelease])
 8018f36:	7d73      	ldrb	r3, [r6, #21]
 8018f38:	2b00      	cmp	r3, #0
 8018f3a:	f040 8118 	bne.w	801916e <SFXSamplerBPTick+0x28a>
            sampleLength = recordPosition * leaf.invSampleRate;
 8018f3e:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8018f42:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f46:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            displayValues[0] = knobs[0] * sampleLength;
 8018f4a:	ed94 7a7d 	vldr	s14, [r4, #500]	; 0x1f4
            sampleLength = recordPosition * leaf.invSampleRate;
 8018f4e:	f2c2 0301 	movt	r3, #8193	; 0x2001
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f52:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
 8018f56:	2200      	movs	r2, #0
            sampleLength = recordPosition * leaf.invSampleRate;
 8018f58:	edd3 7a01 	vldr	s15, [r3, #4]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f5c:	ee38 1ac7 	vsub.f32	s2, s17, s14
 8018f60:	ee00 2a10 	vmov	s0, r2
            sampleLength = recordPosition * leaf.invSampleRate;
 8018f64:	ee68 7a27 	vmul.f32	s15, s16, s15
            displayValues[0] = knobs[0] * sampleLength;
 8018f68:	ee27 7a87 	vmul.f32	s14, s15, s14
            sampleLength = recordPosition * leaf.invSampleRate;
 8018f6c:	edc7 7a00 	vstr	s15, [r7]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f70:	ee21 1a27 	vmul.f32	s2, s2, s15
 8018f74:	ee67 0aa0 	vmul.f32	s1, s15, s1
            displayValues[0] = knobs[0] * sampleLength;
 8018f78:	ed85 7a00 	vstr	s14, [r5]
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f7c:	f00e fd1c 	bl	80279b8 <LEAF_clip>
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8018f80:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8018f84:	edd4 6a7f 	vldr	s13, [r4, #508]	; 0x1fc
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8018f88:	ed94 7a80 	vldr	s14, [r4, #512]	; 0x200
 8018f8c:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8018f90:	eef1 5a00 	vmov.f32	s11, #16	; 0x40800000  4.0
            displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8018f94:	ed85 0a01 	vstr	s0, [r5, #4]
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8018f98:	ee76 6ae7 	vsub.f32	s13, s13, s15
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8018f9c:	ee77 7a67 	vsub.f32	s15, s14, s15
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8018fa0:	ee66 6aa5 	vmul.f32	s13, s13, s11
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8018fa4:	ee67 7a86 	vmul.f32	s15, s15, s12
            displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8018fa8:	edc5 6a02 	vstr	s13, [r5, #8]
            float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8018fac:	fef8 7a67 	vrinta.f32	s15, s15
            if (rate < 0.0f)
 8018fb0:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8018fb4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8018fb8:	f100 8115 	bmi.w	80191e6 <SFXSamplerBPTick+0x302>
                rate += 1.0f;
 8018fbc:	ee77 7aa8 	vadd.f32	s15, s15, s17
            displayValues[4] = knobs[4] * 4000.0f;
 8018fc0:	2300      	movs	r3, #0
 8018fc2:	ed94 6a81 	vldr	s12, [r4, #516]	; 0x204
            samplerRate = displayValues[3] * displayValues[2];
 8018fc6:	f240 26a8 	movw	r6, #680	; 0x2a8
 8018fca:	ee66 6aa7 	vmul.f32	s13, s13, s15
            displayValues[4] = knobs[4] * 4000.0f;
 8018fce:	f2c4 537a 	movt	r3, #17786	; 0x457a
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 8018fd2:	ed94 0a7d 	vldr	s0, [r4, #500]	; 0x1f4
 8018fd6:	f247 7084 	movw	r0, #30596	; 0x7784
            samplerRate = displayValues[3] * displayValues[2];
 8018fda:	f2c2 0600 	movt	r6, #8192	; 0x2000
            displayValues[4] = knobs[4] * 4000.0f;
 8018fde:	ee07 3a10 	vmov	s14, r3
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 8018fe2:	ee28 0a00 	vmul.f32	s0, s16, s0
 8018fe6:	f2c2 0001 	movt	r0, #8193	; 0x2001
            samplerRate = displayValues[3] * displayValues[2];
 8018fea:	edc6 6a00 	vstr	s13, [r6]
            displayValues[4] = knobs[4] * 4000.0f;
 8018fee:	ee26 7a07 	vmul.f32	s14, s12, s14
            displayValues[3] = rate;
 8018ff2:	edc5 7a03 	vstr	s15, [r5, #12]
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 8018ff6:	f240 6804 	movw	r8, #1540	; 0x604
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8018ffa:	f240 6700 	movw	r7, #1536	; 0x600
            displayValues[4] = knobs[4] * 4000.0f;
 8018ffe:	ed85 7a04 	vstr	s14, [r5, #16]
            tExpSmooth_setDest(&startSmooth, knobs[0] * recordPosition);
 8019002:	f00c ffc5 	bl	8025f90 <tExpSmooth_setDest>
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
 8019006:	ed94 0a7e 	vldr	s0, [r4, #504]	; 0x1f8
 801900a:	f247 0024 	movw	r0, #28708	; 0x7024
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 801900e:	f2c2 0800 	movt	r8, #8192	; 0x2000
            crossfadeLength = displayValues[4];
 8019012:	f240 5464 	movw	r4, #1380	; 0x564
            tExpSmooth_setDest(&lengthSmooth, knobs[1] * recordPosition);
 8019016:	ee28 0a00 	vmul.f32	s0, s16, s0
 801901a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801901e:	f00c ffb7 	bl	8025f90 <tExpSmooth_setDest>
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 8019022:	f247 7084 	movw	r0, #30596	; 0x7784
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8019026:	f2c2 0700 	movt	r7, #8192	; 0x2000
            crossfadeLength = displayValues[4];
 801902a:	f2c2 0400 	movt	r4, #8192	; 0x2000
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 801902e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019032:	f00c ffb7 	bl	8025fa4 <tExpSmooth_tick>
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8019036:	f247 0024 	movw	r0, #28708	; 0x7024
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 801903a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 801903e:	f2c2 0001 	movt	r0, #8193	; 0x2001
            samplePlayStart = tExpSmooth_tick(&startSmooth);
 8019042:	ed88 0a00 	vstr	s0, [r8]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8019046:	f00c ffad 	bl	8025fa4 <tExpSmooth_tick>
            crossfadeLength = displayValues[4];
 801904a:	edd5 7a04 	vldr	s15, [r5, #16]
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 801904e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
            tSampler_setStart(&sampler, samplePlayStart);
 8019052:	f247 2054 	movw	r0, #29268	; 0x7254
 8019056:	f8d8 1000 	ldr.w	r1, [r8]
            crossfadeLength = displayValues[4];
 801905a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            tSampler_setStart(&sampler, samplePlayStart);
 801905e:	f2c2 0001 	movt	r0, #8193	; 0x2001
            samplePlayLength = tExpSmooth_tick(&lengthSmooth);
 8019062:	ed87 0a00 	vstr	s0, [r7]
            crossfadeLength = displayValues[4];
 8019066:	edc4 7a00 	vstr	s15, [r4]
            tSampler_setStart(&sampler, samplePlayStart);
 801906a:	f011 f8f1 	bl	802a250 <tSampler_setStart>
            tSampler_setLength(&sampler, samplePlayLength);
 801906e:	f247 2054 	movw	r0, #29268	; 0x7254
 8019072:	6839      	ldr	r1, [r7, #0]
 8019074:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019078:	f011 fd14 	bl	802aaa4 <tSampler_setLength>
            tSampler_setRate(&sampler, samplerRate);
 801907c:	f247 2054 	movw	r0, #29268	; 0x7254
 8019080:	ed96 0a00 	vldr	s0, [r6]
 8019084:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019088:	f011 fda6 	bl	802abd8 <tSampler_setRate>
            tSampler_setCrossfadeLength(&sampler, crossfadeLength);
 801908c:	f247 2054 	movw	r0, #29268	; 0x7254
 8019090:	6821      	ldr	r1, [r4, #0]
 8019092:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019096:	f011 f86f 	bl	802a178 <tSampler_setCrossfadeLength>
            tBuffer_tick(&buff, input[1]);
 801909a:	f243 50f0 	movw	r0, #13808	; 0x35f0
 801909e:	ed99 0a01 	vldr	s0, [r9, #4]
 80190a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80190a6:	f010 ff77 	bl	8029f98 <tBuffer_tick>
            sample = tanhf(tSampler_tick(&sampler));
 80190aa:	f247 2054 	movw	r0, #29268	; 0x7254
 80190ae:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80190b2:	f011 f9f9 	bl	802a4a8 <tSampler_tick>
 80190b6:	f012 fa55 	bl	802b564 <tanhf>
            input[0] = sample;
 80190ba:	ed89 0a00 	vstr	s0, [r9]
            input[1] = sample;
 80190be:	ed89 0a01 	vstr	s0, [r9, #4]
        }
 80190c2:	ecbd 8b02 	vpop	{d8}
 80190c6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (samplePlaying)
 80190ca:	f240 23a4 	movw	r3, #676	; 0x2a4
 80190ce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80190d2:	781a      	ldrb	r2, [r3, #0]
 80190d4:	2a00      	cmp	r2, #0
 80190d6:	d15c      	bne.n	8019192 <SFXSamplerBPTick+0x2ae>
                    tSampler_play(&sampler);
 80190d8:	f247 2054 	movw	r0, #29268	; 0x7254
 80190dc:	f240 57fc 	movw	r7, #1532	; 0x5fc
 80190e0:	f642 5410 	movw	r4, #11536	; 0x2d10
                    samplePlaying = 1;
 80190e4:	2201      	movs	r2, #1
 80190e6:	f248 7594 	movw	r5, #34708	; 0x8794
                    tSampler_play(&sampler);
 80190ea:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80190ee:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80190f2:	f2c2 0400 	movt	r4, #8192	; 0x2000
 80190f6:	f2c2 0501 	movt	r5, #8193	; 0x2001
                    samplePlaying = 1;
 80190fa:	701a      	strb	r2, [r3, #0]
                    tSampler_play(&sampler);
 80190fc:	f011 f850 	bl	802a1a0 <tSampler_play>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8019100:	2300      	movs	r3, #0
 8019102:	7733      	strb	r3, [r6, #28]
            if (buttonActionsSFX[ButtonB][ActionPress])
 8019104:	7e33      	ldrb	r3, [r6, #24]
 8019106:	2b00      	cmp	r3, #0
 8019108:	f43f af11 	beq.w	8018f2e <SFXSamplerBPTick+0x4a>
                bpMode = !bpMode;
 801910c:	f240 5824 	movw	r8, #1316	; 0x524
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 8019110:	f247 2054 	movw	r0, #29268	; 0x7254
                bpMode = !bpMode;
 8019114:	f2c2 0800 	movt	r8, #8192	; 0x2000
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 8019118:	f2c2 0001 	movt	r0, #8193	; 0x2001
                bpMode = !bpMode;
 801911c:	f8d8 3000 	ldr.w	r3, [r8]
 8019120:	fab3 f383 	clz	r3, r3
 8019124:	095b      	lsrs	r3, r3, #5
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 8019126:	1c59      	adds	r1, r3, #1
                bpMode = !bpMode;
 8019128:	f8c8 3000 	str.w	r3, [r8]
                tSampler_setMode(&sampler, (PlayMode)(bpMode + 1));
 801912c:	f011 f820 	bl	802a170 <tSampler_setMode>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8019130:	2300      	movs	r3, #0
                setLED_B(bpMode);
 8019132:	f898 0000 	ldrb.w	r0, [r8]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8019136:	7633      	strb	r3, [r6, #24]
                setLED_B(bpMode);
 8019138:	f7fc fbe8 	bl	801590c <setLED_B>
            if (buttonActionsSFX[ButtonA][ActionPress])
 801913c:	7d33      	ldrb	r3, [r6, #20]
 801913e:	2b00      	cmp	r3, #0
 8019140:	f43f aef9 	beq.w	8018f36 <SFXSamplerBPTick+0x52>
                tSampler_stop(&sampler);
 8019144:	f247 2054 	movw	r0, #29268	; 0x7254
 8019148:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801914c:	f011 f876 	bl	802a23c <tSampler_stop>
                tBuffer_record(&buff);
 8019150:	f243 50f0 	movw	r0, #13808	; 0x35f0
 8019154:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8019158:	f010 ff4c 	bl	8029ff4 <tBuffer_record>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801915c:	2300      	movs	r3, #0
                setLED_A(1);
 801915e:	2001      	movs	r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019160:	7533      	strb	r3, [r6, #20]
                setLED_A(1);
 8019162:	f7fc fbc3 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonA][ActionRelease])
 8019166:	7d73      	ldrb	r3, [r6, #21]
 8019168:	2b00      	cmp	r3, #0
 801916a:	f43f aee8 	beq.w	8018f3e <SFXSamplerBPTick+0x5a>
                tBuffer_stop(&buff);
 801916e:	f243 50f0 	movw	r0, #13808	; 0x35f0
 8019172:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8019176:	f010 ff43 	bl	802a000 <tBuffer_stop>
                if (samplePlaying) tSampler_play(&sampler);
 801917a:	f240 23a4 	movw	r3, #676	; 0x2a4
 801917e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019182:	781b      	ldrb	r3, [r3, #0]
 8019184:	bbb3      	cbnz	r3, 80191f4 <SFXSamplerBPTick+0x310>
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
 8019186:	2300      	movs	r3, #0
                setLED_A(0);
 8019188:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonA][ActionRelease] = 0;
 801918a:	7573      	strb	r3, [r6, #21]
                setLED_A(0);
 801918c:	f7fc fbae 	bl	80158ec <setLED_A>
 8019190:	e6d5      	b.n	8018f3e <SFXSamplerBPTick+0x5a>
                    tSampler_stop(&sampler);
 8019192:	f247 2054 	movw	r0, #29268	; 0x7254
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019196:	f642 5410 	movw	r4, #11536	; 0x2d10
                    samplePlaying = 0;
 801919a:	2200      	movs	r2, #0
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 801919c:	f240 57fc 	movw	r7, #1532	; 0x5fc
                    tSampler_stop(&sampler);
 80191a0:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80191a4:	f2c2 0400 	movt	r4, #8192	; 0x2000
                    samplePlaying = 0;
 80191a8:	701a      	strb	r2, [r3, #0]
                    tSampler_stop(&sampler);
 80191aa:	f011 f847 	bl	802a23c <tSampler_stop>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 80191ae:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80191b2:	ed94 1a7d 	vldr	s2, [r4, #500]	; 0x1f4
 80191b6:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80191ba:	f248 7594 	movw	r5, #34708	; 0x8794
 80191be:	edd4 0a7e 	vldr	s1, [r4, #504]	; 0x1f8
 80191c2:	2300      	movs	r3, #0
 80191c4:	ee77 7ac1 	vsub.f32	s15, s15, s2
 80191c8:	ed97 1a00 	vldr	s2, [r7]
 80191cc:	f2c2 0501 	movt	r5, #8193	; 0x2001
 80191d0:	ee00 3a10 	vmov	s0, r3
 80191d4:	ee61 0a20 	vmul.f32	s1, s2, s1
 80191d8:	ee27 1a81 	vmul.f32	s2, s15, s2
 80191dc:	f00e fbec 	bl	80279b8 <LEAF_clip>
 80191e0:	ed85 0a01 	vstr	s0, [r5, #4]
 80191e4:	e78c      	b.n	8019100 <SFXSamplerBPTick+0x21c>
                (rate = 1.0f / fabsf(rate-1.0f));
 80191e6:	ee77 7ae8 	vsub.f32	s15, s15, s17
 80191ea:	eeb0 7ae7 	vabs.f32	s14, s15
 80191ee:	eec8 7a87 	vdiv.f32	s15, s17, s14
 80191f2:	e6e5      	b.n	8018fc0 <SFXSamplerBPTick+0xdc>
                if (samplePlaying) tSampler_play(&sampler);
 80191f4:	f247 2054 	movw	r0, #29268	; 0x7254
 80191f8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80191fc:	f010 ffd0 	bl	802a1a0 <tSampler_play>
 8019200:	e7c1      	b.n	8019186 <SFXSamplerBPTick+0x2a2>
 8019202:	bf00      	nop

08019204 <SFXSamplerBPFree>:
            tBuffer_free(&buff);
 8019204:	f243 50f0 	movw	r0, #13808	; 0x35f0
        {
 8019208:	b508      	push	{r3, lr}
            tBuffer_free(&buff);
 801920a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801920e:	f010 feb7 	bl	8029f80 <tBuffer_free>
            tSampler_free(&sampler);
 8019212:	f247 2054 	movw	r0, #29268	; 0x7254
 8019216:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801921a:	f010 ff9d 	bl	802a158 <tSampler_free>
            tExpSmooth_free(&startSmooth);
 801921e:	f247 7084 	movw	r0, #30596	; 0x7784
 8019222:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019226:	f00c fe9d 	bl	8025f64 <tExpSmooth_free>
            tExpSmooth_free(&lengthSmooth);
 801922a:	f247 0024 	movw	r0, #28708	; 0x7024
        }
 801922e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&lengthSmooth);
 8019232:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019236:	f00c be95 	b.w	8025f64 <tExpSmooth_free>
 801923a:	bf00      	nop

0801923c <SFXSamplerKAlloc>:
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 801923c:	2000      	movs	r0, #0
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 801923e:	f24d 720a 	movw	r2, #55050	; 0xd70a
                tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
 8019242:	f247 5c10 	movw	ip, #29968	; 0x7510
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8019246:	f240 2120 	movw	r1, #544	; 0x220
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 801924a:	f6c3 5223 	movt	r2, #15651	; 0x3d23
 801924e:	f647 0350 	movw	r3, #30800	; 0x7850
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8019252:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8019256:	f2c2 0301 	movt	r3, #8193	; 0x2001
        {
 801925a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                crossfadeLengths[i] = 1000;
 801925e:	4605      	mov	r5, r0
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 8019260:	f249 4ba0 	movw	fp, #38048	; 0x94a0
                tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
 8019264:	f248 28f8 	movw	r8, #33528	; 0x82f8
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 8019268:	4604      	mov	r4, r0
                crossfadeLengths[i] = 1000;
 801926a:	f2c4 457a 	movt	r5, #17530	; 0x447a
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 801926e:	f2c2 0b01 	movt	fp, #8193	; 0x2001
                tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
 8019272:	f2c2 0801 	movt	r8, #8193	; 0x2001
 8019276:	f247 3644 	movw	r6, #29508	; 0x7344
 801927a:	f247 7a88 	movw	sl, #30600	; 0x7788
 801927e:	f642 1968 	movw	r9, #10600	; 0x2968
                samplePlayStarts[i] = 0;
 8019282:	4607      	mov	r7, r0
 8019284:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8019288:	f2c2 0a01 	movt	sl, #8193	; 0x2001
 801928c:	f2c2 0900 	movt	r9, #8192	; 0x2000
        {
 8019290:	ed2d 8b02 	vpush	{d8}
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 8019294:	ee08 2a10 	vmov	s16, r2
        {
 8019298:	b08d      	sub	sp, #52	; 0x34
 801929a:	f642 0280 	movw	r2, #10368	; 0x2880
            leaf.clearOnAllocation = 0; //needs this in case the box loads on this one first
 801929e:	f8cb 0014 	str.w	r0, [fp, #20]
                crossfadeLengths[i] = 1000;
 80192a2:	950b      	str	r5, [sp, #44]	; 0x2c
 80192a4:	f248 306c 	movw	r0, #33644	; 0x836c
 80192a8:	4615      	mov	r5, r2
 80192aa:	f248 1264 	movw	r2, #33124	; 0x8164
 80192ae:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80192b2:	9604      	str	r6, [sp, #16]
 80192b4:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80192b8:	9003      	str	r0, [sp, #12]
 80192ba:	9501      	str	r5, [sp, #4]
 80192bc:	4615      	mov	r5, r2
 80192be:	f243 522c 	movw	r2, #13612	; 0x352c
 80192c2:	f2c2 0501 	movt	r5, #8193	; 0x2001
 80192c6:	9507      	str	r5, [sp, #28]
 80192c8:	4615      	mov	r5, r2
 80192ca:	f242 628c 	movw	r2, #9868	; 0x268c
 80192ce:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80192d2:	9509      	str	r5, [sp, #36]	; 0x24
 80192d4:	4615      	mov	r5, r2
 80192d6:	f642 424c 	movw	r2, #11340	; 0x2c4c
 80192da:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80192de:	9506      	str	r5, [sp, #24]
 80192e0:	4615      	mov	r5, r2
                tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
 80192e2:	4662      	mov	r2, ip
 80192e4:	f2c2 0500 	movt	r5, #8192	; 0x2000
 80192e8:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80192ec:	9508      	str	r5, [sp, #32]
 80192ee:	920a      	str	r2, [sp, #40]	; 0x28
            currentSamplerKeyGlobal = 60 - LOWEST_SAMPLER_KEY;
 80192f0:	2218      	movs	r2, #24
 80192f2:	600a      	str	r2, [r1, #0]
 80192f4:	f247 7237 	movw	r2, #30519	; 0x7737
 80192f8:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80192fc:	9202      	str	r2, [sp, #8]
 80192fe:	4642      	mov	r2, r8
 8019300:	4698      	mov	r8, r3
 8019302:	465b      	mov	r3, fp
 8019304:	4693      	mov	fp, r2
                tBuffer_initToPool(&keyBuff[i], leaf.sampleRate * 3.5f, &largePool);
 8019306:	eef0 7a0c 	vmov.f32	s15, #12	; 0x40600000  3.5
 801930a:	ed93 7a00 	vldr	s14, [r3]
 801930e:	9305      	str	r3, [sp, #20]
 8019310:	9b07      	ldr	r3, [sp, #28]
 8019312:	ee67 7a27 	vmul.f32	s15, s14, s15
 8019316:	191d      	adds	r5, r3, r4
 8019318:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801931c:	4628      	mov	r0, r5
 801931e:	e9dd 3209 	ldrd	r3, r2, [sp, #36]	; 0x24
 8019322:	ee17 1a90 	vmov	r1, s15
 8019326:	191e      	adds	r6, r3, r4
 8019328:	f010 fe12 	bl	8029f50 <tBuffer_initToPool>
                tBuffer_setRecordMode(&keyBuff[i], RecordOneShot);
 801932c:	4628      	mov	r0, r5
 801932e:	2100      	movs	r1, #0
 8019330:	f010 fe72 	bl	802a018 <tBuffer_setRecordMode>
                tSampler_initToPool(&keySampler[i], &keyBuff[i], &smallPool);
 8019334:	465a      	mov	r2, fp
 8019336:	4629      	mov	r1, r5
 8019338:	4630      	mov	r0, r6
 801933a:	f010 fec7 	bl	802a0cc <tSampler_initToPool>
                tSampler_setMode(&keySampler[i], PlayLoop);
 801933e:	4630      	mov	r0, r6
 8019340:	2101      	movs	r1, #1
 8019342:	f010 ff15 	bl	802a170 <tSampler_setMode>
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 8019346:	9b06      	ldr	r3, [sp, #24]
 8019348:	2200      	movs	r2, #0
                crossfadeLengths[i] = 1000;
 801934a:	eddd 7a0b 	vldr	s15, [sp, #44]	; 0x2c
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 801934e:	1918      	adds	r0, r3, r4
                samplePlayStarts[i] = 0;
 8019350:	9b04      	ldr	r3, [sp, #16]
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 8019352:	ee00 2a10 	vmov	s0, r2
 8019356:	4659      	mov	r1, fp
                samplePlayStarts[i] = 0;
 8019358:	f843 7b04 	str.w	r7, [r3], #4
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 801935c:	eef0 0a48 	vmov.f32	s1, s16
                samplePlayStarts[i] = 0;
 8019360:	9304      	str	r3, [sp, #16]
                samplePlayLengths[i] = 0;
 8019362:	9b01      	ldr	r3, [sp, #4]
                crossfadeLengths[i] = 1000;
 8019364:	ecea 7a01 	vstmia	sl!, {s15}
                samplePlayLengths[i] = 0;
 8019368:	f843 7b04 	str.w	r7, [r3], #4
 801936c:	9301      	str	r3, [sp, #4]
                detectedAttackPos[i] = 0;
 801936e:	9b03      	ldr	r3, [sp, #12]
 8019370:	461a      	mov	r2, r3
 8019372:	2300      	movs	r3, #0
 8019374:	f842 3f04 	str.w	r3, [r2, #4]!
                samplerKeyHeld[i] = 0;
 8019378:	9b02      	ldr	r3, [sp, #8]
                detectedAttackPos[i] = 0;
 801937a:	9203      	str	r2, [sp, #12]
                samplerKeyHeld[i] = 0;
 801937c:	f04f 0200 	mov.w	r2, #0
 8019380:	f803 2f01 	strb.w	r2, [r3, #1]!
 8019384:	9302      	str	r3, [sp, #8]
                tExpSmooth_initToPool(&kSamplerGains[i], 0.0f, 0.04f, &smallPool);
 8019386:	f00c fdc7 	bl	8025f18 <tExpSmooth_initToPool>
                loopOns[i] = 1;
 801938a:	9b08      	ldr	r3, [sp, #32]
 801938c:	2101      	movs	r1, #1
                sampleRates[i] = 1.0f;
 801938e:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
                loopOns[i] = 1;
 8019392:	5119      	str	r1, [r3, r4]
 8019394:	3404      	adds	r4, #4
                sampleRates[i] = 1.0f;
 8019396:	f849 2b04 	str.w	r2, [r9], #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 801939a:	2cc4      	cmp	r4, #196	; 0xc4
                sampleRatesMult[i] = 1.0f;
 801939c:	f848 2b04 	str.w	r2, [r8], #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 80193a0:	9b05      	ldr	r3, [sp, #20]
 80193a2:	d1b0      	bne.n	8019306 <SFXSamplerKAlloc+0xca>
            tSimplePoly_setNumVoices(&poly, NUM_SAMPLER_VOICES);
 80193a4:	f247 5020 	movw	r0, #29984	; 0x7520
 80193a8:	2106      	movs	r1, #6
 80193aa:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80193ae:	f00f f989 	bl	80286c4 <tSimplePoly_setNumVoices>
            setLED_B(controlAllKeys);
 80193b2:	f240 5160 	movw	r1, #1376	; 0x560
                waitingForDeactivation[i] = -1;
 80193b6:	f247 6314 	movw	r3, #30228	; 0x7614
 80193ba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
            setLED_B(controlAllKeys);
 80193be:	f2c2 0100 	movt	r1, #8192	; 0x2000
                waitingForDeactivation[i] = -1;
 80193c2:	f2c2 0301 	movt	r3, #8193	; 0x2001
            setLED_B(controlAllKeys);
 80193c6:	7808      	ldrb	r0, [r1, #0]
                waitingForDeactivation[i] = -1;
 80193c8:	e9c3 2200 	strd	r2, r2, [r3]
 80193cc:	e9c3 2202 	strd	r2, r2, [r3, #8]
 80193d0:	e9c3 2204 	strd	r2, r2, [r3, #16]
            setLED_B(controlAllKeys);
 80193d4:	f7fc fa9a 	bl	801590c <setLED_B>
            samp_thresh = 0.0002f;
 80193d8:	f24b 7317 	movw	r3, #46871	; 0xb717
 80193dc:	f240 52f4 	movw	r2, #1524	; 0x5f4
 80193e0:	f6c3 1351 	movt	r3, #14673	; 0x3951
 80193e4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80193e8:	6013      	str	r3, [r2, #0]
        }
 80193ea:	b00d      	add	sp, #52	; 0x34
 80193ec:	ecbd 8b02 	vpop	{d8}
 80193f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080193f4 <SFXSamplerKFrame>:
            int currentSamplerKey = currentSamplerKeyGlobal;
 80193f4:	f240 2220 	movw	r2, #544	; 0x220
            if (samplerKeyHeld[currentSamplerKey])
 80193f8:	f247 7338 	movw	r3, #30520	; 0x7738
            int currentSamplerKey = currentSamplerKeyGlobal;
 80193fc:	f2c2 0200 	movt	r2, #8192	; 0x2000
            if (samplerKeyHeld[currentSamplerKey])
 8019400:	f2c2 0301 	movt	r3, #8193	; 0x2001
        {
 8019404:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8019408:	ed2d 8b04 	vpush	{d8-d9}
            int currentSamplerKey = currentSamplerKeyGlobal;
 801940c:	6815      	ldr	r5, [r2, #0]
        {
 801940e:	b083      	sub	sp, #12
            if (samplerKeyHeld[currentSamplerKey])
 8019410:	5d5b      	ldrb	r3, [r3, r5]
 8019412:	2b00      	cmp	r3, #0
 8019414:	f040 8133 	bne.w	801967e <SFXSamplerKFrame+0x28a>
            if (buttonActionsSFX[ButtonA][ActionPress])
 8019418:	f248 64e4 	movw	r4, #34532	; 0x86e4
 801941c:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8019420:	7d23      	ldrb	r3, [r4, #20]
 8019422:	b17b      	cbz	r3, 8019444 <SFXSamplerKFrame+0x50>
                tBuffer_setRecordPosition(&keyBuff[currentSamplerKey],0);
 8019424:	f248 1064 	movw	r0, #33124	; 0x8164
 8019428:	2100      	movs	r1, #0
 801942a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801942e:	eb00 0685 	add.w	r6, r0, r5, lsl #2
 8019432:	4630      	mov	r0, r6
 8019434:	f010 fdec 	bl	802a010 <tBuffer_setRecordPosition>
                tBuffer_setRecordedLength(&keyBuff[currentSamplerKey],0);
 8019438:	4630      	mov	r0, r6
 801943a:	2100      	movs	r1, #0
 801943c:	f010 fdf4 	bl	802a028 <tBuffer_setRecordedLength>
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 8019440:	2300      	movs	r3, #0
 8019442:	7523      	strb	r3, [r4, #20]
            if (buttonActionsSFX[ButtonB][ActionPress])
 8019444:	7e23      	ldrb	r3, [r4, #24]
 8019446:	b16b      	cbz	r3, 8019464 <SFXSamplerKFrame+0x70>
                controlAllKeys = !controlAllKeys;
 8019448:	f240 5260 	movw	r2, #1376	; 0x560
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801944c:	2300      	movs	r3, #0
                controlAllKeys = !controlAllKeys;
 801944e:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 8019452:	7623      	strb	r3, [r4, #24]
                controlAllKeys = !controlAllKeys;
 8019454:	6813      	ldr	r3, [r2, #0]
 8019456:	fab3 f383 	clz	r3, r3
 801945a:	095b      	lsrs	r3, r3, #5
                setLED_B(controlAllKeys);
 801945c:	4618      	mov	r0, r3
                controlAllKeys = !controlAllKeys;
 801945e:	6013      	str	r3, [r2, #0]
                setLED_B(controlAllKeys);
 8019460:	f7fc fa54 	bl	801590c <setLED_B>
            if (buttonActionsSFX[ButtonC][ActionPress])
 8019464:	7f23      	ldrb	r3, [r4, #28]
 8019466:	2b00      	cmp	r3, #0
 8019468:	f000 80eb 	beq.w	8019642 <SFXSamplerKFrame+0x24e>
                if (!controlAllKeys)
 801946c:	f240 5360 	movw	r3, #1376	; 0x560
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8019470:	2200      	movs	r2, #0
                if (!controlAllKeys)
 8019472:	f2c2 0300 	movt	r3, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 8019476:	7722      	strb	r2, [r4, #28]
                if (!controlAllKeys)
 8019478:	f8d3 9000 	ldr.w	r9, [r3]
 801947c:	f1b9 0f00 	cmp.w	r9, #0
 8019480:	d062      	beq.n	8019548 <SFXSamplerKFrame+0x154>
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8019482:	f241 236f 	movw	r3, #4719	; 0x126f
                                float previousPower = 0.0f;
 8019486:	2200      	movs	r2, #0
 8019488:	f248 4934 	movw	r9, #33844	; 0x8434
 801948c:	2106      	movs	r1, #6
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 801948e:	f6c3 2303 	movt	r3, #14851	; 0x3a03
                                float previousPower = 0.0f;
 8019492:	ee09 2a10 	vmov	s18, r2
 8019496:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801949a:	9101      	str	r1, [sp, #4]
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 801949c:	ee08 3a90 	vmov	s17, r3
 80194a0:	f248 1764 	movw	r7, #33124	; 0x8164
 80194a4:	f248 3670 	movw	r6, #33648	; 0x8370
 80194a8:	f247 3844 	movw	r8, #29508	; 0x7344
 80194ac:	f2c2 0701 	movt	r7, #8193	; 0x2001
 80194b0:	f2c2 0601 	movt	r6, #8193	; 0x2001
 80194b4:	f2c2 0801 	movt	r8, #8193	; 0x2001
 80194b8:	e01c      	b.n	80194f4 <SFXSamplerKFrame+0x100>
 80194ba:	eeb4 8ac0 	vcmpe.f32	s16, s0
 80194be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80194c2:	d53c      	bpl.n	801953e <SFXSamplerKFrame+0x14a>
                                        int thePos = (i + detectedAttackPos[key] - 480) % buffLength;
 80194c4:	6833      	ldr	r3, [r6, #0]
 80194c6:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
 80194ca:	449b      	add	fp, r3
 80194cc:	fb9b f3f4 	sdiv	r3, fp, r4
 80194d0:	fb04 b413 	mls	r4, r4, r3, fp
 80194d4:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
                                        samplePlayStarts[key] = thePos;
 80194d8:	ee07 4a90 	vmov	s15, r4
                                        detectedAttackPos[key] = thePos;
 80194dc:	6034      	str	r4, [r6, #0]
                                        samplePlayStarts[key] = thePos;
 80194de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80194e2:	edc8 7a00 	vstr	s15, [r8]
 80194e6:	3604      	adds	r6, #4
 80194e8:	3704      	adds	r7, #4
 80194ea:	f108 0804 	add.w	r8, r8, #4
                        for (int key = 0; key < NUM_SAMPLER_KEYS; key++)
 80194ee:	45b1      	cmp	r9, r6
 80194f0:	f000 80bb 	beq.w	801966a <SFXSamplerKFrame+0x276>
                            int buffLength = tBuffer_getRecordedLength(&keyBuff[key]);
 80194f4:	4638      	mov	r0, r7
 80194f6:	f010 fd93 	bl	802a020 <tBuffer_getRecordedLength>
                            if (buffLength > 0)
 80194fa:	1e04      	subs	r4, r0, #0
 80194fc:	ddf3      	ble.n	80194e6 <SFXSamplerKFrame+0xf2>
                                if (detectedAttackPos[key] > 0)
 80194fe:	6833      	ldr	r3, [r6, #0]
 8019500:	2b00      	cmp	r3, #0
 8019502:	f300 80a3 	bgt.w	801964c <SFXSamplerKFrame+0x258>
                                float previousPower = 0.0f;
 8019506:	eeb0 0a49 	vmov.f32	s0, s18
 801950a:	f240 5af4 	movw	sl, #1524	; 0x5f4
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 801950e:	ee30 8a28 	vadd.f32	s16, s0, s17
        {
 8019512:	2501      	movs	r5, #1
 8019514:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8019518:	f105 3bff 	add.w	fp, r5, #4294967295	; 0xffffffff
                                    float testSample = tBuffer_get(&keyBuff[key], (i + detectedAttackPos[key]) % buffLength);
 801951c:	4638      	mov	r0, r7
 801951e:	445b      	add	r3, fp
 8019520:	fb93 f1f4 	sdiv	r1, r3, r4
 8019524:	fb04 3111 	mls	r1, r4, r1, r3
 8019528:	f010 fd54 	bl	8029fd4 <tBuffer_get>
                                    currentPower = testSample*testSample;
 801952c:	ee20 0a00 	vmul.f32	s0, s0, s0
                                    if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8019530:	edda 7a00 	vldr	s15, [sl]
 8019534:	eef4 7ac0 	vcmpe.f32	s15, s0
 8019538:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801953c:	d4bd      	bmi.n	80194ba <SFXSamplerKFrame+0xc6>
                                    if (i >= buffLength)
 801953e:	42ac      	cmp	r4, r5
 8019540:	ddd1      	ble.n	80194e6 <SFXSamplerKFrame+0xf2>
 8019542:	3501      	adds	r5, #1
 8019544:	6833      	ldr	r3, [r6, #0]
 8019546:	e7e7      	b.n	8019518 <SFXSamplerKFrame+0x124>
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019548:	f248 1764 	movw	r7, #33124	; 0x8164
 801954c:	ea4f 0885 	mov.w	r8, r5, lsl #2
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8019550:	f248 3670 	movw	r6, #33648	; 0x8370
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019554:	f2c2 0701 	movt	r7, #8193	; 0x2001
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8019558:	f2c2 0601 	movt	r6, #8193	; 0x2001
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 801955c:	4447      	add	r7, r8
 801955e:	4638      	mov	r0, r7
 8019560:	f010 fd5e 	bl	802a020 <tBuffer_getRecordedLength>
                    if (detectedAttackPos[currentSamplerKey] > 0)
 8019564:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
                    int buffLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019568:	4604      	mov	r4, r0
                    if (detectedAttackPos[currentSamplerKey] > 0)
 801956a:	2b00      	cmp	r3, #0
 801956c:	f300 80c7 	bgt.w	80196fe <SFXSamplerKFrame+0x30a>
                    float previousPower = 0.0f;
 8019570:	2200      	movs	r2, #0
 8019572:	ee00 2a10 	vmov	s0, r2
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 8019576:	f241 216f 	movw	r1, #4719	; 0x126f
 801957a:	f240 5af4 	movw	sl, #1524	; 0x5f4
 801957e:	f6c3 2103 	movt	r1, #14851	; 0x3a03
 8019582:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 8019586:	ee08 1a10 	vmov	s16, r1
 801958a:	ee30 8a08 	vadd.f32	s16, s0, s16
                        float testSample = tBuffer_get(&keyBuff[currentSamplerKey], (i + detectedAttackPos[currentSamplerKey]) % buffLength);
 801958e:	444b      	add	r3, r9
 8019590:	4638      	mov	r0, r7
 8019592:	f109 0b01 	add.w	fp, r9, #1
 8019596:	fb93 f1f4 	sdiv	r1, r3, r4
 801959a:	fb04 3111 	mls	r1, r4, r1, r3
 801959e:	f010 fd19 	bl	8029fd4 <tBuffer_get>
                        currentPower = testSample*testSample;
 80195a2:	ee20 0a00 	vmul.f32	s0, s0, s0
                        if ((currentPower > samp_thresh) && (currentPower > (previousPower + 0.0005f)))
 80195a6:	edda 7a00 	vldr	s15, [sl]
 80195aa:	eef4 7ac0 	vcmpe.f32	s15, s0
 80195ae:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80195b2:	f140 809e 	bpl.w	80196f2 <SFXSamplerKFrame+0x2fe>
 80195b6:	eeb4 8ac0 	vcmpe.f32	s16, s0
 80195ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80195be:	f140 8098 	bpl.w	80196f2 <SFXSamplerKFrame+0x2fe>
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 80195c2:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
                            samplePlayStarts[currentSamplerKey] = thePos;
 80195c6:	f247 3244 	movw	r2, #29508	; 0x7344
                            OLEDclearLine(SecondLine);
 80195ca:	2001      	movs	r0, #1
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 80195cc:	f5a3 73f0 	sub.w	r3, r3, #480	; 0x1e0
                            samplePlayStarts[currentSamplerKey] = thePos;
 80195d0:	f2c2 0201 	movt	r2, #8193	; 0x2001
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 80195d4:	4499      	add	r9, r3
                            samplePlayStarts[currentSamplerKey] = thePos;
 80195d6:	4490      	add	r8, r2
                            int thePos = (i + detectedAttackPos[currentSamplerKey] - 480) % buffLength;
 80195d8:	fb99 f3f4 	sdiv	r3, r9, r4
 80195dc:	fb04 9313 	mls	r3, r4, r3, r9
 80195e0:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
                            samplePlayStarts[currentSamplerKey] = thePos;
 80195e4:	ee07 3a90 	vmov	s15, r3
                            detectedAttackPos[currentSamplerKey] = thePos;
 80195e8:	f846 3025 	str.w	r3, [r6, r5, lsl #2]
                            samplePlayStarts[currentSamplerKey] = thePos;
 80195ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80195f0:	edc8 7a00 	vstr	s15, [r8]
                            OLEDclearLine(SecondLine);
 80195f4:	f7fc fc1c 	bl	8015e30 <OLEDclearLine>
                            OLEDwriteString("ATKDETECT ", 10, 0, SecondLine);
 80195f8:	f64e 20b4 	movw	r0, #60084	; 0xeab4
 80195fc:	2200      	movs	r2, #0
 80195fe:	210a      	movs	r1, #10
 8019600:	2301      	movs	r3, #1
 8019602:	f6c0 0002 	movt	r0, #2050	; 0x802
 8019606:	f7fc fc29 	bl	8015e5c <OLEDwriteString>
                            OLEDwriteFloat((samplePlayStarts[currentSamplerKey] / (float)buffLength) * (buffLength * leaf.invSampleRate), OLEDgetCursor(), SecondLine);
 801960a:	ee07 4a90 	vmov	s15, r4
 801960e:	ed98 7a00 	vldr	s14, [r8]
 8019612:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8019616:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801961a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801961e:	ee87 8a27 	vdiv.f32	s16, s14, s15
 8019622:	ed93 7a01 	vldr	s14, [r3, #4]
 8019626:	ee67 7a87 	vmul.f32	s15, s15, s14
 801962a:	ee28 8a27 	vmul.f32	s16, s16, s15
 801962e:	f7fc ff03 	bl	8016438 <OLEDgetCursor>
 8019632:	2101      	movs	r1, #1
 8019634:	b2c0      	uxtb	r0, r0
 8019636:	eeb0 0a48 	vmov.f32	s0, s16
 801963a:	f7fc fcf3 	bl	8016024 <OLEDwriteFloat>
                        if (i >= buffLength)
 801963e:	455c      	cmp	r4, fp
 8019640:	dd43      	ble.n	80196ca <SFXSamplerKFrame+0x2d6>
        }
 8019642:	b003      	add	sp, #12
 8019644:	ecbd 8b04 	vpop	{d8-d9}
 8019648:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 801964c:	f241 22bf 	movw	r2, #4799	; 0x12bf
                                    detectedAttackPos[key] += 4800;
 8019650:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 8019654:	4638      	mov	r0, r7
 8019656:	441a      	add	r2, r3
                                    detectedAttackPos[key] += 4800;
 8019658:	6031      	str	r1, [r6, #0]
                                    previousPower = tBuffer_get(&keyBuff[key], (detectedAttackPos[key] -1) % buffLength);
 801965a:	fb92 f1f4 	sdiv	r1, r2, r4
 801965e:	fb04 2111 	mls	r1, r4, r1, r2
 8019662:	f010 fcb7 	bl	8029fd4 <tBuffer_get>
 8019666:	6833      	ldr	r3, [r6, #0]
 8019668:	e74f      	b.n	801950a <SFXSamplerKFrame+0x116>
                    for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 801966a:	9b01      	ldr	r3, [sp, #4]
 801966c:	3b01      	subs	r3, #1
 801966e:	9301      	str	r3, [sp, #4]
 8019670:	f47f af16 	bne.w	80194a0 <SFXSamplerKFrame+0xac>
        }
 8019674:	b003      	add	sp, #12
 8019676:	ecbd 8b04 	vpop	{d8-d9}
 801967a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
 801967e:	f248 1064 	movw	r0, #33124	; 0x8164
 8019682:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019686:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 801968a:	f010 fcd1 	bl	802a030 <tBuffer_isActive>
 801968e:	f240 236c 	movw	r3, #620	; 0x26c
 8019692:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019696:	b1a0      	cbz	r0, 80196c2 <SFXSamplerKFrame+0x2ce>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
 8019698:	f648 0054 	movw	r0, #34900	; 0x8854
                    writeButtonFlag = ExtraMessage;
 801969c:	f240 21ce 	movw	r1, #718	; 0x2ce
                    writeActionFlag = ActionHoldContinuous;
 80196a0:	f240 22cd 	movw	r2, #717	; 0x2cd
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
 80196a4:	2601      	movs	r6, #1
 80196a6:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    writeButtonFlag = ExtraMessage;
 80196aa:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    writeActionFlag = ActionHoldContinuous;
 80196ae:	f2c2 0200 	movt	r2, #8192	; 0x2000
                    writeButtonFlag = ExtraMessage;
 80196b2:	240a      	movs	r4, #10
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 1;
 80196b4:	f880 602b 	strb.w	r6, [r0, #43]	; 0x2b
                    writeActionFlag = ActionHoldContinuous;
 80196b8:	2003      	movs	r0, #3
                    writeButtonFlag = ExtraMessage;
 80196ba:	700c      	strb	r4, [r1, #0]
                    writeActionFlag = ActionHoldContinuous;
 80196bc:	7010      	strb	r0, [r2, #0]
                prevSamplerKey = currentSamplerKey;
 80196be:	601d      	str	r5, [r3, #0]
 80196c0:	e6aa      	b.n	8019418 <SFXSamplerKFrame+0x24>
                if ((tBuffer_isActive(&keyBuff[currentSamplerKey])) || (currentSamplerKey != prevSamplerKey)) //only write if recording
 80196c2:	681a      	ldr	r2, [r3, #0]
 80196c4:	42aa      	cmp	r2, r5
 80196c6:	d1e7      	bne.n	8019698 <SFXSamplerKFrame+0x2a4>
 80196c8:	e7f9      	b.n	80196be <SFXSamplerKFrame+0x2ca>
                            detectedAttackPos[currentSamplerKey] = 0;
 80196ca:	2400      	movs	r4, #0
                            OLEDclearLine(SecondLine);
 80196cc:	2001      	movs	r0, #1
                            detectedAttackPos[currentSamplerKey] = 0;
 80196ce:	f846 4025 	str.w	r4, [r6, r5, lsl #2]
                            OLEDclearLine(SecondLine);
 80196d2:	f7fc fbad 	bl	8015e30 <OLEDclearLine>
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
 80196d6:	f64e 20a4 	movw	r0, #60068	; 0xeaa4
 80196da:	4622      	mov	r2, r4
 80196dc:	2301      	movs	r3, #1
 80196de:	210a      	movs	r1, #10
 80196e0:	f6c0 0002 	movt	r0, #2050	; 0x802
        }
 80196e4:	b003      	add	sp, #12
 80196e6:	ecbd 8b04 	vpop	{d8-d9}
 80196ea:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                            OLEDwriteString("NO ATK FOUND ", 10, 0, SecondLine);
 80196ee:	f7fc bbb5 	b.w	8015e5c <OLEDwriteString>
                        if (i >= buffLength)
 80196f2:	455c      	cmp	r4, fp
 80196f4:	dde9      	ble.n	80196ca <SFXSamplerKFrame+0x2d6>
        {
 80196f6:	46d9      	mov	r9, fp
 80196f8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80196fc:	e747      	b.n	801958e <SFXSamplerKFrame+0x19a>
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 80196fe:	f241 22bf 	movw	r2, #4799	; 0x12bf
                        detectedAttackPos[currentSamplerKey] += 4800;
 8019702:	f503 5196 	add.w	r1, r3, #4800	; 0x12c0
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 8019706:	4638      	mov	r0, r7
 8019708:	441a      	add	r2, r3
                        detectedAttackPos[currentSamplerKey] += 4800;
 801970a:	f846 1025 	str.w	r1, [r6, r5, lsl #2]
                        previousPower = tBuffer_get(&keyBuff[currentSamplerKey], (detectedAttackPos[currentSamplerKey] -1) % buffLength);
 801970e:	fb92 f1f4 	sdiv	r1, r2, r4
 8019712:	fb04 2111 	mls	r1, r4, r1, r2
 8019716:	f010 fc5d 	bl	8029fd4 <tBuffer_get>
 801971a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801971e:	e72a      	b.n	8019576 <SFXSamplerKFrame+0x182>

08019720 <SFXSamplerKTick>:
            if (!controlAllKeys)
 8019720:	f240 5360 	movw	r3, #1376	; 0x560
 8019724:	f2c2 0300 	movt	r3, #8192	; 0x2000
        {
 8019728:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801972c:	ed2d 8b04 	vpush	{d8-d9}
 8019730:	b089      	sub	sp, #36	; 0x24
            if (!controlAllKeys)
 8019732:	681e      	ldr	r6, [r3, #0]
        {
 8019734:	9001      	str	r0, [sp, #4]
            if (!controlAllKeys)
 8019736:	2e00      	cmp	r6, #0
 8019738:	f000 81ef 	beq.w	8019b1a <SFXSamplerKTick+0x3fa>
                    displayValues[5] = knobs[5] * 4000.0f;
 801973c:	2300      	movs	r3, #0
 801973e:	f248 184c 	movw	r8, #33100	; 0x814c
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8019742:	2200      	movs	r2, #0
 8019744:	f642 5410 	movw	r4, #11536	; 0x2d10
 8019748:	f248 7594 	movw	r5, #34708	; 0x8794
                    displayValues[5] = knobs[5] * 4000.0f;
 801974c:	f2c4 537a 	movt	r3, #17786	; 0x457a
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019750:	f247 5920 	movw	r9, #29984	; 0x7520
 8019754:	f2c2 0801 	movt	r8, #8193	; 0x2001
 8019758:	f2c2 0400 	movt	r4, #8192	; 0x2000
                    displayValues[5] = knobs[5] * 4000.0f;
 801975c:	ee08 3a10 	vmov	s16, r3
 8019760:	f2c2 0501 	movt	r5, #8193	; 0x2001
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8019764:	ee08 2a90 	vmov	s17, r2
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019768:	f2c2 0901 	movt	r9, #8193	; 0x2001
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 801976c:	4617      	mov	r7, r2
 801976e:	e9cd ab02 	strd	sl, fp, [sp, #8]
 8019772:	46c3      	mov	fp, r8
 8019774:	e003      	b.n	801977e <SFXSamplerKTick+0x5e>
 8019776:	3701      	adds	r7, #1
 8019778:	2f06      	cmp	r7, #6
 801977a:	f000 810c 	beq.w	8019996 <SFXSamplerKTick+0x276>
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 801977e:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                    displayValues[0] = knobs[0];
 8019782:	ed94 1a96 	vldr	s2, [r4, #600]	; 0x258
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8019786:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
 801978a:	eeb0 0a68 	vmov.f32	s0, s17
                    displayValues[0] = knobs[0];
 801978e:	ed85 1a00 	vstr	s2, [r5]
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 8019792:	ee39 1a41 	vsub.f32	s2, s18, s2
 8019796:	f00e f90f 	bl	80279b8 <LEAF_clip>
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 801979a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 801979e:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80197a2:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
 80197a6:	edd4 6a99 	vldr	s13, [r4, #612]	; 0x264
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80197aa:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
 80197ae:	ee75 5ae7 	vsub.f32	s11, s11, s15
                    displayValues[1] = LEAF_clip(0.0f, knobs[1], (1.0f - knobs[0]));
 80197b2:	ed85 0a01 	vstr	s0, [r5, #4]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80197b6:	ee76 7ae7 	vsub.f32	s15, s13, s15
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80197ba:	ee25 6a86 	vmul.f32	s12, s11, s12
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80197be:	ee67 7a87 	vmul.f32	s15, s15, s14
                    displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 80197c2:	ed85 6a02 	vstr	s12, [r5, #8]
                    float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 80197c6:	fef8 7a67 	vrinta.f32	s15, s15
                    if (rate < 0.0f)
 80197ca:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80197ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80197d2:	f100 8150 	bmi.w	8019a76 <SFXSamplerKTick+0x356>
                        rate += 1.0f;
 80197d6:	ee77 7a89 	vadd.f32	s15, s15, s18
                    displayValues[5] = knobs[5] * 4000.0f;
 80197da:	edd4 6a9b 	vldr	s13, [r4, #620]	; 0x26c
                    if (tSimplePoly_isOn(&poly, i) > 0)
 80197de:	b2fe      	uxtb	r6, r7
                    displayValues[4] = roundf(knobs[4]);
 80197e0:	ed94 7a9a 	vldr	s14, [r4, #616]	; 0x268
                    if (tSimplePoly_isOn(&poly, i) > 0)
 80197e4:	4648      	mov	r0, r9
                    displayValues[5] = knobs[5] * 4000.0f;
 80197e6:	ee66 6a88 	vmul.f32	s13, s13, s16
                    displayValues[6] = knobs[6];
 80197ea:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                    if (tSimplePoly_isOn(&poly, i) > 0)
 80197ee:	4631      	mov	r1, r6
                    displayValues[3] = rate;
 80197f0:	edc5 7a03 	vstr	s15, [r5, #12]
                    displayValues[6] = knobs[6];
 80197f4:	61ab      	str	r3, [r5, #24]
                    displayValues[4] = roundf(knobs[4]);
 80197f6:	fef8 7a47 	vrinta.f32	s15, s14
                    displayValues[5] = knobs[5] * 4000.0f;
 80197fa:	edc5 6a05 	vstr	s13, [r5, #20]
                    displayValues[4] = roundf(knobs[4]);
 80197fe:	edc5 7a04 	vstr	s15, [r5, #16]
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019802:	f00e ff95 	bl	8028730 <tSimplePoly_isOn>
 8019806:	2800      	cmp	r0, #0
 8019808:	ddb5      	ble.n	8019776 <SFXSamplerKTick+0x56>
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 801980a:	4631      	mov	r1, r6
 801980c:	4648      	mov	r0, r9
 801980e:	f00e ff7d 	bl	802870c <tSimplePoly_getPitch>
 8019812:	f1a0 0824 	sub.w	r8, r0, #36	; 0x24
                        if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
 8019816:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 801981a:	d8ac      	bhi.n	8019776 <SFXSamplerKTick+0x56>
                            tBuffer_tick(&keyBuff[key], input[1]);
 801981c:	f248 1264 	movw	r2, #33124	; 0x8164
 8019820:	ea4f 0388 	mov.w	r3, r8, lsl #2
 8019824:	9901      	ldr	r1, [sp, #4]
 8019826:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801982a:	9300      	str	r3, [sp, #0]
 801982c:	ed91 0a01 	vldr	s0, [r1, #4]
 8019830:	18d6      	adds	r6, r2, r3
 8019832:	4630      	mov	r0, r6
 8019834:	f010 fbb0 	bl	8029f98 <tBuffer_tick>
                            int recordedLength = tBuffer_getRecordedLength(&keyBuff[key]);
 8019838:	4630      	mov	r0, r6
 801983a:	f010 fbf1 	bl	802a020 <tBuffer_getRecordedLength>
                            sampleLength = recordedLength * leaf.invSampleRate;
 801983e:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8019842:	ee07 0a90 	vmov	s15, r0
                            if (knobs[0] != prevKnobs[0])
 8019846:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
 801984a:	ed9b 6a00 	vldr	s12, [fp]
                            sampleLength = recordedLength * leaf.invSampleRate;
 801984e:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8019852:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8019856:	f240 52fc 	movw	r2, #1532	; 0x5fc
                            if (knobs[0] != prevKnobs[0])
 801985a:	eeb4 7a46 	vcmp.f32	s14, s12
                            sampleLength = recordedLength * leaf.invSampleRate;
 801985e:	edd1 6a01 	vldr	s13, [r1, #4]
 8019862:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019866:	ee66 6aa7 	vmul.f32	s13, s13, s15
                            if (knobs[0] != prevKnobs[0])
 801986a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                            sampleLength = recordedLength * leaf.invSampleRate;
 801986e:	edc2 6a00 	vstr	s13, [r2]
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
 8019872:	f247 3244 	movw	r2, #29508	; 0x7344
                            if (knobs[0] != prevKnobs[0])
 8019876:	f040 8147 	bne.w	8019b08 <SFXSamplerKTick+0x3e8>
 801987a:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801987e:	9b00      	ldr	r3, [sp, #0]
 8019880:	441a      	add	r2, r3
 8019882:	edd2 6a00 	vldr	s13, [r2]
                            if (knobs[1] != prevKnobs[1])
 8019886:	ed94 7a97 	vldr	s14, [r4, #604]	; 0x25c
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
 801988a:	f642 0280 	movw	r2, #10368	; 0x2880
                            if (knobs[1] != prevKnobs[1])
 801988e:	ed9b 6a01 	vldr	s12, [fp, #4]
 8019892:	eeb4 7a46 	vcmp.f32	s14, s12
 8019896:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801989a:	f040 82d2 	bne.w	8019e42 <SFXSamplerKTick+0x722>
 801989e:	f2c2 0200 	movt	r2, #8192	; 0x2000
                            if (knobs[2] != prevKnobs[2])
 80198a2:	ed94 7a98 	vldr	s14, [r4, #608]	; 0x260
                                sampleRates[key] = displayValues[2];
 80198a6:	f642 1368 	movw	r3, #10600	; 0x2968
                            if (knobs[2] != prevKnobs[2])
 80198aa:	eddb 7a02 	vldr	s15, [fp, #8]
 80198ae:	eeb4 7a67 	vcmp.f32	s14, s15
 80198b2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198b6:	f040 82bc 	bne.w	8019e32 <SFXSamplerKTick+0x712>
 80198ba:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80198be:	9306      	str	r3, [sp, #24]
                            if (knobs[3] != prevKnobs[3])
 80198c0:	ed94 7a99 	vldr	s14, [r4, #612]	; 0x264
                                sampleRatesMult[key] = displayValues[3];
 80198c4:	f647 0350 	movw	r3, #30800	; 0x7850
                            if (knobs[3] != prevKnobs[3])
 80198c8:	eddb 7a03 	vldr	s15, [fp, #12]
 80198cc:	eeb4 7a67 	vcmp.f32	s14, s15
 80198d0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198d4:	f040 82a6 	bne.w	8019e24 <SFXSamplerKTick+0x704>
 80198d8:	f2c2 0301 	movt	r3, #8193	; 0x2001
                            if (knobs[4] != prevKnobs[4])
 80198dc:	edd4 7a9a 	vldr	s15, [r4, #616]	; 0x268
                                loopOns[key] = roundf(knobs[4]);
 80198e0:	f642 414c 	movw	r1, #11340	; 0x2c4c
                            if (knobs[4] != prevKnobs[4])
 80198e4:	ed9b 7a04 	vldr	s14, [fp, #16]
 80198e8:	eef4 7a47 	vcmp.f32	s15, s14
 80198ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80198f0:	f040 828c 	bne.w	8019e0c <SFXSamplerKTick+0x6ec>
 80198f4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80198f8:	468a      	mov	sl, r1
                            if (knobs[5] != prevKnobs[5])
 80198fa:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
                                crossfadeLengths[key] = displayValues[5];
 80198fe:	f247 7188 	movw	r1, #30600	; 0x7788
                            if (knobs[5] != prevKnobs[5])
 8019902:	eddb 7a05 	vldr	s15, [fp, #20]
 8019906:	eeb4 7a67 	vcmp.f32	s14, s15
 801990a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801990e:	f040 8275 	bne.w	8019dfc <SFXSamplerKTick+0x6dc>
 8019912:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8019916:	9107      	str	r1, [sp, #28]
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
 8019918:	f243 562c 	movw	r6, #13612	; 0x352c
 801991c:	eefd 7ae6 	vcvt.s32.f32	s15, s13
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 8019920:	3701      	adds	r7, #1
                            tSampler_setStart(&keySampler[key], samplePlayStarts[key]);
 8019922:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8019926:	ee17 1a90 	vmov	r1, s15
 801992a:	e9cd 3204 	strd	r3, r2, [sp, #16]
 801992e:	9b00      	ldr	r3, [sp, #0]
 8019930:	441e      	add	r6, r3
 8019932:	4630      	mov	r0, r6
 8019934:	f010 fc8c 	bl	802a250 <tSampler_setStart>
                            tSampler_setLength(&keySampler[key], samplePlayLengths[key]);
 8019938:	9b00      	ldr	r3, [sp, #0]
 801993a:	9a05      	ldr	r2, [sp, #20]
 801993c:	4630      	mov	r0, r6
 801993e:	441a      	add	r2, r3
 8019940:	edd2 7a00 	vldr	s15, [r2]
 8019944:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019948:	ee17 1a90 	vmov	r1, s15
 801994c:	f011 f8aa 	bl	802aaa4 <tSampler_setLength>
                            tSampler_setCrossfadeLength(&keySampler[key], crossfadeLengths[key]);
 8019950:	9900      	ldr	r1, [sp, #0]
 8019952:	9a07      	ldr	r2, [sp, #28]
 8019954:	4630      	mov	r0, r6
 8019956:	440a      	add	r2, r1
 8019958:	edd2 7a00 	vldr	s15, [r2]
 801995c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8019960:	ee17 1a90 	vmov	r1, s15
 8019964:	f010 fc08 	bl	802a178 <tSampler_setCrossfadeLength>
                            tSampler_setRate(&keySampler[key], sampleRates[key] * sampleRatesMult[key]);
 8019968:	9b00      	ldr	r3, [sp, #0]
 801996a:	9a06      	ldr	r2, [sp, #24]
 801996c:	4630      	mov	r0, r6
 801996e:	4619      	mov	r1, r3
 8019970:	441a      	add	r2, r3
 8019972:	9b04      	ldr	r3, [sp, #16]
 8019974:	440b      	add	r3, r1
 8019976:	ed92 0a00 	vldr	s0, [r2]
 801997a:	edd3 7a00 	vldr	s15, [r3]
 801997e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8019982:	f011 f929 	bl	802abd8 <tSampler_setRate>
                            tSampler_setMode(&keySampler[key], (PlayMode)loopOns[key]);
 8019986:	4630      	mov	r0, r6
 8019988:	f81a 1028 	ldrb.w	r1, [sl, r8, lsl #2]
 801998c:	f010 fbf0 	bl	802a170 <tSampler_setMode>
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 8019990:	2f06      	cmp	r7, #6
 8019992:	f47f aef4 	bne.w	801977e <SFXSamplerKTick+0x5e>
 8019996:	f642 7e68 	movw	lr, #12136	; 0x2f68
 801999a:	f248 1c4c 	movw	ip, #33100	; 0x814c
                if ( tempGain > 0.001f)
 801999e:	f241 246f 	movw	r4, #4719	; 0x126f
 80199a2:	f242 668c 	movw	r6, #9868	; 0x268c
 80199a6:	f2c2 0e00 	movt	lr, #8192	; 0x2000
 80199aa:	f2c2 0c01 	movt	ip, #8193	; 0x2001
 80199ae:	f6c3 2483 	movt	r4, #14979	; 0x3a83
                        if (waitingForDeactivation[j] == (i + LOWEST_SAMPLER_KEY))
 80199b2:	f247 6514 	movw	r5, #30228	; 0x7614
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 80199b6:	f243 479c 	movw	r7, #13468	; 0x349c
 80199ba:	f2c2 0600 	movt	r6, #8192	; 0x2000
                if ( tempGain > 0.001f)
 80199be:	ee08 4a90 	vmov	s17, r4
            float sample = 0.0f;
 80199c2:	2400      	movs	r4, #0
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 80199c4:	f2c2 0700 	movt	r7, #8192	; 0x2000
                        if (waitingForDeactivation[j] == (i + LOWEST_SAMPLER_KEY))
 80199c8:	f2c2 0501 	movt	r5, #8193	; 0x2001
            float sample = 0.0f;
 80199cc:	ee09 4a10 	vmov	s18, r4
                for (int i = 0; i < NUM_SAMPLER_VOICES; i++)
 80199d0:	2424      	movs	r4, #36	; 0x24
 80199d2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
 80199d6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
 80199da:	e89e 0003 	ldmia.w	lr, {r0, r1}
 80199de:	e88c 0003 	stmia.w	ip, {r0, r1}
 80199e2:	e016      	b.n	8019a12 <SFXSamplerKTick+0x2f2>
                        if (waitingForDeactivation[j] == (i + LOWEST_SAMPLER_KEY))
 80199e4:	682b      	ldr	r3, [r5, #0]
 80199e6:	42a3      	cmp	r3, r4
 80199e8:	f000 8083 	beq.w	8019af2 <SFXSamplerKTick+0x3d2>
 80199ec:	686b      	ldr	r3, [r5, #4]
 80199ee:	429c      	cmp	r4, r3
 80199f0:	d074      	beq.n	8019adc <SFXSamplerKTick+0x3bc>
 80199f2:	68ab      	ldr	r3, [r5, #8]
 80199f4:	429c      	cmp	r4, r3
 80199f6:	d066      	beq.n	8019ac6 <SFXSamplerKTick+0x3a6>
 80199f8:	68eb      	ldr	r3, [r5, #12]
 80199fa:	429c      	cmp	r4, r3
 80199fc:	d058      	beq.n	8019ab0 <SFXSamplerKTick+0x390>
 80199fe:	692b      	ldr	r3, [r5, #16]
 8019a00:	429c      	cmp	r4, r3
 8019a02:	d04a      	beq.n	8019a9a <SFXSamplerKTick+0x37a>
 8019a04:	696b      	ldr	r3, [r5, #20]
 8019a06:	429c      	cmp	r4, r3
 8019a08:	d03c      	beq.n	8019a84 <SFXSamplerKTick+0x364>
 8019a0a:	3401      	adds	r4, #1
 8019a0c:	3604      	adds	r6, #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8019a0e:	2c55      	cmp	r4, #85	; 0x55
 8019a10:	d013      	beq.n	8019a3a <SFXSamplerKTick+0x31a>
                float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
 8019a12:	4630      	mov	r0, r6
 8019a14:	f00c fac6 	bl	8025fa4 <tExpSmooth_tick>
                if ( tempGain > 0.001f)
 8019a18:	eeb4 0ae8 	vcmpe.f32	s0, s17
                float tempGain = tExpSmooth_tick(&kSamplerGains[i]);
 8019a1c:	eeb0 8a40 	vmov.f32	s16, s0
                if ( tempGain > 0.001f)
 8019a20:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019a24:	ddde      	ble.n	80199e4 <SFXSamplerKTick+0x2c4>
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 8019a26:	eb07 0084 	add.w	r0, r7, r4, lsl #2
 8019a2a:	3401      	adds	r4, #1
 8019a2c:	f010 fd3c 	bl	802a4a8 <tSampler_tick>
 8019a30:	3604      	adds	r6, #4
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8019a32:	2c55      	cmp	r4, #85	; 0x55
                    sample += tSampler_tick(&keySampler[i]) * tempGain;
 8019a34:	eea0 9a08 	vfma.f32	s18, s0, s16
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8019a38:	d1eb      	bne.n	8019a12 <SFXSamplerKTick+0x2f2>
            sample = tanhf(sample) * 0.98;
 8019a3a:	f648 7a5c 	movw	sl, #36700	; 0x8f5c
 8019a3e:	f645 4b28 	movw	fp, #23592	; 0x5c28
 8019a42:	eeb0 0a49 	vmov.f32	s0, s18
 8019a46:	f011 fd8d 	bl	802b564 <tanhf>
 8019a4a:	f2cf 5ac2 	movt	sl, #62914	; 0xf5c2
 8019a4e:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
 8019a52:	f6c3 7bef 	movt	fp, #16367	; 0x3fef
            input[0] = sample;
 8019a56:	9b01      	ldr	r3, [sp, #4]
            sample = tanhf(sample) * 0.98;
 8019a58:	ec4b ab16 	vmov	d6, sl, fp
 8019a5c:	ee27 7b06 	vmul.f64	d7, d7, d6
 8019a60:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
            input[0] = sample;
 8019a64:	ed83 7a00 	vstr	s14, [r3]
            input[1] = sample;
 8019a68:	ed83 7a01 	vstr	s14, [r3, #4]
        }
 8019a6c:	b009      	add	sp, #36	; 0x24
 8019a6e:	ecbd 8b04 	vpop	{d8-d9}
 8019a72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        (rate = 1.0f / fabsf(rate-1.0f));
 8019a76:	ee77 7ac9 	vsub.f32	s15, s15, s18
 8019a7a:	eeb0 7ae7 	vabs.f32	s14, s15
 8019a7e:	eec9 7a07 	vdiv.f32	s15, s18, s14
 8019a82:	e6aa      	b.n	80197da <SFXSamplerKTick+0xba>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019a84:	f247 5020 	movw	r0, #29984	; 0x7520
 8019a88:	2105      	movs	r1, #5
 8019a8a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019a8e:	f00e fd63 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019a92:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019a96:	616b      	str	r3, [r5, #20]
 8019a98:	e7b7      	b.n	8019a0a <SFXSamplerKTick+0x2ea>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019a9a:	f247 5020 	movw	r0, #29984	; 0x7520
 8019a9e:	2104      	movs	r1, #4
 8019aa0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019aa4:	f00e fd58 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019aa8:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019aac:	612b      	str	r3, [r5, #16]
 8019aae:	e7a9      	b.n	8019a04 <SFXSamplerKTick+0x2e4>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019ab0:	f247 5020 	movw	r0, #29984	; 0x7520
 8019ab4:	2103      	movs	r1, #3
 8019ab6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019aba:	f00e fd4d 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019abe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019ac2:	60eb      	str	r3, [r5, #12]
 8019ac4:	e79b      	b.n	80199fe <SFXSamplerKTick+0x2de>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019ac6:	f247 5020 	movw	r0, #29984	; 0x7520
 8019aca:	2102      	movs	r1, #2
 8019acc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019ad0:	f00e fd42 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019ad4:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019ad8:	60ab      	str	r3, [r5, #8]
 8019ada:	e78d      	b.n	80199f8 <SFXSamplerKTick+0x2d8>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019adc:	f247 5020 	movw	r0, #29984	; 0x7520
 8019ae0:	2101      	movs	r1, #1
 8019ae2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019ae6:	f00e fd37 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019aea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019aee:	606b      	str	r3, [r5, #4]
 8019af0:	e77f      	b.n	80199f2 <SFXSamplerKTick+0x2d2>
                            tSimplePoly_deactivateVoice(&poly, j);
 8019af2:	f247 5020 	movw	r0, #29984	; 0x7520
 8019af6:	2100      	movs	r1, #0
 8019af8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019afc:	f00e fd2c 	bl	8028558 <tSimplePoly_deactivateVoice>
                            waitingForDeactivation[j] = -1;
 8019b00:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8019b04:	602b      	str	r3, [r5, #0]
 8019b06:	e771      	b.n	80199ec <SFXSamplerKTick+0x2cc>
                                samplePlayStarts[key]= (knobs[0] * recordedLength);
 8019b08:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8019b0c:	9b00      	ldr	r3, [sp, #0]
 8019b0e:	ee67 6a87 	vmul.f32	s13, s15, s14
 8019b12:	441a      	add	r2, r3
 8019b14:	edc2 6a00 	vstr	s13, [r2]
 8019b18:	e6b5      	b.n	8019886 <SFXSamplerKTick+0x166>
            int currentSamplerKey = currentSamplerKeyGlobal;
 8019b1a:	f240 2320 	movw	r3, #544	; 0x220
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019b1e:	f248 1264 	movw	r2, #33124	; 0x8164
                displayValues[0] = knobs[0] * sampleLength;
 8019b22:	f642 5410 	movw	r4, #11536	; 0x2d10
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b26:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
            int currentSamplerKey = currentSamplerKeyGlobal;
 8019b2a:	f2c2 0300 	movt	r3, #8192	; 0x2000
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019b2e:	f2c2 0201 	movt	r2, #8193	; 0x2001
                displayValues[0] = knobs[0] * sampleLength;
 8019b32:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8019b36:	f248 7594 	movw	r5, #34708	; 0x8794
            int currentSamplerKey = currentSamplerKeyGlobal;
 8019b3a:	681b      	ldr	r3, [r3, #0]
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019b3c:	9205      	str	r2, [sp, #20]
                displayValues[0] = knobs[0] * sampleLength;
 8019b3e:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8019b42:	009f      	lsls	r7, r3, #2
            int currentSamplerKey = currentSamplerKeyGlobal;
 8019b44:	9300      	str	r3, [sp, #0]
                int recordedLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKey]);
 8019b46:	19d0      	adds	r0, r2, r7
 8019b48:	f010 fa6a 	bl	802a020 <tBuffer_getRecordedLength>
                sampleLength = recordedLength * leaf.invSampleRate;
 8019b4c:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8019b50:	ee07 0a90 	vmov	s15, r0
                displayValues[0] = knobs[0] * sampleLength;
 8019b54:	ed94 7a96 	vldr	s14, [r4, #600]	; 0x258
                sampleLength = recordedLength * leaf.invSampleRate;
 8019b58:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8019b5c:	f240 53fc 	movw	r3, #1532	; 0x5fc
 8019b60:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b64:	edd4 0a97 	vldr	s1, [r4, #604]	; 0x25c
                sampleLength = recordedLength * leaf.invSampleRate;
 8019b68:	edd1 7a01 	vldr	s15, [r1, #4]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b6c:	ee38 1ac7 	vsub.f32	s2, s17, s14
 8019b70:	2100      	movs	r1, #0
                sampleLength = recordedLength * leaf.invSampleRate;
 8019b72:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019b76:	ee68 7a27 	vmul.f32	s15, s16, s15
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b7a:	ee00 1a10 	vmov	s0, r1
                displayValues[0] = knobs[0] * sampleLength;
 8019b7e:	ee27 7a87 	vmul.f32	s14, s15, s14
                sampleLength = recordedLength * leaf.invSampleRate;
 8019b82:	edc3 7a00 	vstr	s15, [r3]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b86:	ee21 1a27 	vmul.f32	s2, s2, s15
 8019b8a:	ee67 0aa0 	vmul.f32	s1, s15, s1
                displayValues[0] = knobs[0] * sampleLength;
 8019b8e:	ed85 7a00 	vstr	s14, [r5]
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019b92:	f00d ff11 	bl	80279b8 <LEAF_clip>
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8019b96:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8019b9a:	edd4 5a98 	vldr	s11, [r4, #608]	; 0x260
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8019b9e:	ed94 6a99 	vldr	s12, [r4, #612]	; 0x264
 8019ba2:	eeb2 7a0c 	vmov.f32	s14, #44	; 0x41600000  14.0
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8019ba6:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
                displayValues[1] = LEAF_clip(0.0f, knobs[1] * sampleLength, sampleLength * (1.0f - knobs[0]));
 8019baa:	ed85 0a01 	vstr	s0, [r5, #4]
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8019bae:	ee75 3ae7 	vsub.f32	s7, s11, s15
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8019bb2:	ee76 7a67 	vsub.f32	s15, s12, s15
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8019bb6:	ee63 3aa6 	vmul.f32	s7, s7, s13
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8019bba:	ee67 7a87 	vmul.f32	s15, s15, s14
                displayValues[2] = (knobs[2] - 0.5f) * 4.0f;
 8019bbe:	edc5 3a02 	vstr	s7, [r5, #8]
                float rate = roundf((knobs[3] - 0.5f) * 14.0f);
 8019bc2:	fef8 7a67 	vrinta.f32	s15, s15
                if (rate < 0.0f)
 8019bc6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8019bca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019bce:	f100 8150 	bmi.w	8019e72 <SFXSamplerKTick+0x752>
                    rate += 1.0f;
 8019bd2:	ee37 2aa8 	vadd.f32	s4, s15, s17
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019bd6:	f248 184c 	movw	r8, #33100	; 0x814c
 8019bda:	edd4 7a96 	vldr	s15, [r4, #600]	; 0x258
 8019bde:	f24b 7317 	movw	r3, #46871	; 0xb717
                displayValues[5] = knobs[5] * 4000.0f;
 8019be2:	2100      	movs	r1, #0
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019be4:	f2c2 0801 	movt	r8, #8193	; 0x2001
                displayValues[5] = knobs[5] * 4000.0f;
 8019be8:	ed94 7a9b 	vldr	s14, [r4, #620]	; 0x26c
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019bec:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
                displayValues[5] = knobs[5] * 4000.0f;
 8019bf0:	f2c4 517a 	movt	r1, #17786	; 0x457a
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019bf4:	edd8 4a00 	vldr	s9, [r8]
 8019bf8:	ee03 3a10 	vmov	s6, r3
                displayValues[5] = knobs[5] * 4000.0f;
 8019bfc:	ee02 1a90 	vmov	s5, r1
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019c00:	ee77 4ae4 	vsub.f32	s9, s15, s9
                displayValues[6] = knobs[6];
 8019c04:	f8d4 3270 	ldr.w	r3, [r4, #624]	; 0x270
                displayValues[5] = knobs[5] * 4000.0f;
 8019c08:	ee67 2a22 	vmul.f32	s5, s14, s5
                displayValues[4] = roundf(knobs[4]);
 8019c0c:	edd4 6a9a 	vldr	s13, [r4, #616]	; 0x268
                displayValues[6] = knobs[6];
 8019c10:	61ab      	str	r3, [r5, #24]
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
 8019c12:	f247 3344 	movw	r3, #29508	; 0x7344
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019c16:	eef0 4ae4 	vabs.f32	s9, s9
                displayValues[4] = roundf(knobs[4]);
 8019c1a:	feb8 4a66 	vrinta.f32	s8, s13
                displayValues[3] = rate;
 8019c1e:	ed85 2a03 	vstr	s4, [r5, #12]
                displayValues[4] = roundf(knobs[4]);
 8019c22:	ed85 4a04 	vstr	s8, [r5, #16]
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019c26:	eef4 4ac3 	vcmpe.f32	s9, s6
                displayValues[5] = knobs[5] * 4000.0f;
 8019c2a:	edc5 2a05 	vstr	s5, [r5, #20]
                if (fabsf(knobs[0]-prevKnobs[0]) > 0.0001f)
 8019c2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c32:	f300 810f 	bgt.w	8019e54 <SFXSamplerKTick+0x734>
 8019c36:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8019c3a:	443b      	add	r3, r7
 8019c3c:	edd3 7a00 	vldr	s15, [r3]
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
 8019c40:	ed94 5a97 	vldr	s10, [r4, #604]	; 0x25c
 8019c44:	f24b 7317 	movw	r3, #46871	; 0xb717
 8019c48:	edd8 4a01 	vldr	s9, [r8, #4]
 8019c4c:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8019c50:	ee75 4a64 	vsub.f32	s9, s10, s9
 8019c54:	ee03 3a10 	vmov	s6, r3
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
 8019c58:	f642 0380 	movw	r3, #10368	; 0x2880
                if (fabsf(knobs[1]-prevKnobs[1])  > 0.0001f)
 8019c5c:	eef0 4ae4 	vabs.f32	s9, s9
 8019c60:	eef4 4ac3 	vcmpe.f32	s9, s6
 8019c64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019c68:	f340 80ff 	ble.w	8019e6a <SFXSamplerKTick+0x74a>
                    samplePlayLengths[currentSamplerKey] = (knobs[1] * recordedLength);// - detectedAttackPos[currentSamplerKey];
 8019c6c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019c70:	ee28 5a05 	vmul.f32	s10, s16, s10
 8019c74:	9302      	str	r3, [sp, #8]
 8019c76:	443b      	add	r3, r7
 8019c78:	ed83 5a00 	vstr	s10, [r3]
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 8019c7c:	ed98 5a02 	vldr	s10, [r8, #8]
 8019c80:	f24b 7317 	movw	r3, #46871	; 0xb717
                    sampleRates[currentSamplerKey] = displayValues[2];
 8019c84:	f642 1968 	movw	r9, #10600	; 0x2968
                    loopOns[currentSamplerKey] = roundf(knobs[4]);
 8019c88:	f642 424c 	movw	r2, #11340	; 0x2c4c
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 8019c8c:	ee75 5ac5 	vsub.f32	s11, s11, s10
 8019c90:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
                    sampleRates[currentSamplerKey] = displayValues[2];
 8019c94:	f2c2 0900 	movt	r9, #8192	; 0x2000
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 8019c98:	ee05 3a10 	vmov	s10, r3
 8019c9c:	eef0 5ae5 	vabs.f32	s11, s11
 8019ca0:	eef4 5ac5 	vcmpe.f32	s11, s10
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 8019ca4:	edd8 5a03 	vldr	s11, [r8, #12]
 8019ca8:	ee36 6a65 	vsub.f32	s12, s12, s11
                if (fabsf(knobs[2]-prevKnobs[2])  > 0.0001f)
 8019cac:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 8019cb0:	eeb0 6ac6 	vabs.f32	s12, s12
                    sampleRates[currentSamplerKey] = displayValues[2];
 8019cb4:	bfc4      	itt	gt
 8019cb6:	eb09 0307 	addgt.w	r3, r9, r7
 8019cba:	edc3 3a00 	vstrgt	s7, [r3]
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 8019cbe:	f24b 7317 	movw	r3, #46871	; 0xb717
 8019cc2:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8019cc6:	ee05 3a90 	vmov	s11, r3
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8019cca:	f647 0350 	movw	r3, #30800	; 0x7850
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 8019cce:	eeb4 6ae5 	vcmpe.f32	s12, s11
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8019cd2:	f2c2 0301 	movt	r3, #8193	; 0x2001
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 8019cd6:	ed98 6a04 	vldr	s12, [r8, #16]
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8019cda:	9304      	str	r3, [sp, #16]
                if (fabsf(knobs[3]-prevKnobs[3])  > 0.0001f)
 8019cdc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 8019ce0:	ee76 6ac6 	vsub.f32	s13, s13, s12
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8019ce4:	bfc8      	it	gt
 8019ce6:	19db      	addgt	r3, r3, r7
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 8019ce8:	eef0 6ae6 	vabs.f32	s13, s13
                    sampleRatesMult[currentSamplerKey] = displayValues[3];
 8019cec:	bfc8      	it	gt
 8019cee:	ed83 2a00 	vstrgt	s4, [r3]
                if (fabsf(knobs[4]-prevKnobs[4]) > 0.0001f)
 8019cf2:	f24b 7317 	movw	r3, #46871	; 0xb717
 8019cf6:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8019cfa:	ee06 3a10 	vmov	s12, r3
 8019cfe:	eef4 6ac6 	vcmpe.f32	s13, s12
 8019d02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8019d06:	f340 80ad 	ble.w	8019e64 <SFXSamplerKTick+0x744>
                    loopOns[currentSamplerKey] = roundf(knobs[4]);
 8019d0a:	eebd 4ac4 	vcvt.s32.f32	s8, s8
 8019d0e:	9b00      	ldr	r3, [sp, #0]
 8019d10:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019d14:	4619      	mov	r1, r3
 8019d16:	ee14 3a10 	vmov	r3, s8
 8019d1a:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d1e:	edd8 6a05 	vldr	s13, [r8, #20]
 8019d22:	f24b 7317 	movw	r3, #46871	; 0xb717
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
 8019d26:	f247 7888 	movw	r8, #30600	; 0x7788
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d2a:	f243 552c 	movw	r5, #13612	; 0x352c
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d2e:	ee37 7a66 	vsub.f32	s14, s14, s13
 8019d32:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
 8019d36:	f2c2 0801 	movt	r8, #8193	; 0x2001
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d3a:	f2c2 0500 	movt	r5, #8192	; 0x2000
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d3e:	ee06 3a90 	vmov	s13, r3
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d42:	eefd 7ae7 	vcvt.s32.f32	s15, s15
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d46:	eeb0 7ac7 	vabs.f32	s14, s14
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d4a:	443d      	add	r5, r7
 8019d4c:	9206      	str	r2, [sp, #24]
                tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
 8019d4e:	44b9      	add	r9, r7
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d50:	4628      	mov	r0, r5
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019d52:	f247 5420 	movw	r4, #29984	; 0x7520
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d56:	eeb4 7ae6 	vcmpe.f32	s14, s13
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019d5a:	f2c2 0401 	movt	r4, #8193	; 0x2001
                if (fabsf(knobs[5]-prevKnobs[5])> 0.0001f)
 8019d5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    crossfadeLengths[currentSamplerKey] = displayValues[5];
 8019d62:	bfc4      	itt	gt
 8019d64:	eb08 0107 	addgt.w	r1, r8, r7
 8019d68:	edc1 2a00 	vstrgt	s5, [r1]
                tSampler_setStart(&keySampler[currentSamplerKey], samplePlayStarts[currentSamplerKey]);
 8019d6c:	ee17 1a90 	vmov	r1, s15
 8019d70:	f010 fa6e 	bl	802a250 <tSampler_setStart>
                tSampler_setLength(&keySampler[currentSamplerKey], samplePlayLengths[currentSamplerKey]);
 8019d74:	9b02      	ldr	r3, [sp, #8]
 8019d76:	4628      	mov	r0, r5
 8019d78:	443b      	add	r3, r7
 8019d7a:	edd3 7a00 	vldr	s15, [r3]
 8019d7e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019d82:	ee17 1a90 	vmov	r1, s15
 8019d86:	f010 fe8d 	bl	802aaa4 <tSampler_setLength>
                tSampler_setCrossfadeLength(&keySampler[currentSamplerKey], crossfadeLengths[currentSamplerKey]);
 8019d8a:	eb08 0307 	add.w	r3, r8, r7
 8019d8e:	4628      	mov	r0, r5
 8019d90:	edd3 7a00 	vldr	s15, [r3]
 8019d94:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8019d98:	ee17 1a90 	vmov	r1, s15
 8019d9c:	f010 f9ec 	bl	802a178 <tSampler_setCrossfadeLength>
                tSampler_setRate(&keySampler[currentSamplerKey], sampleRates[currentSamplerKey] * sampleRatesMult[currentSamplerKey]);
 8019da0:	9b04      	ldr	r3, [sp, #16]
 8019da2:	ed99 0a00 	vldr	s0, [r9]
 8019da6:	4628      	mov	r0, r5
 8019da8:	443b      	add	r3, r7
 8019daa:	edd3 7a00 	vldr	s15, [r3]
 8019dae:	ee20 0a27 	vmul.f32	s0, s0, s15
 8019db2:	f010 ff11 	bl	802abd8 <tSampler_setRate>
                tSampler_setMode(&keySampler[currentSamplerKey], (PlayMode)loopOns[currentSamplerKey]);
 8019db6:	9b00      	ldr	r3, [sp, #0]
 8019db8:	9a06      	ldr	r2, [sp, #24]
 8019dba:	4628      	mov	r0, r5
 8019dbc:	f812 1023 	ldrb.w	r1, [r2, r3, lsl #2]
 8019dc0:	f010 f9d6 	bl	802a170 <tSampler_setMode>
 8019dc4:	e002      	b.n	8019dcc <SFXSamplerKTick+0x6ac>
                for (int i = 0; i < NUM_SAMPLER_VOICES; ++i)
 8019dc6:	2e06      	cmp	r6, #6
 8019dc8:	f43f ade5 	beq.w	8019996 <SFXSamplerKTick+0x276>
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019dcc:	b2f5      	uxtb	r5, r6
 8019dce:	4620      	mov	r0, r4
 8019dd0:	3601      	adds	r6, #1
 8019dd2:	4629      	mov	r1, r5
 8019dd4:	f00e fcac 	bl	8028730 <tSimplePoly_isOn>
 8019dd8:	2800      	cmp	r0, #0
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 8019dda:	4629      	mov	r1, r5
 8019ddc:	4620      	mov	r0, r4
                    if (tSimplePoly_isOn(&poly, i) > 0)
 8019dde:	ddf2      	ble.n	8019dc6 <SFXSamplerKTick+0x6a6>
                        int key = tSimplePoly_getPitch(&poly, i) - LOWEST_SAMPLER_KEY;
 8019de0:	f00e fc94 	bl	802870c <tSimplePoly_getPitch>
 8019de4:	3824      	subs	r0, #36	; 0x24
                        if ((0 <= key) && (key < NUM_SAMPLER_KEYS))
 8019de6:	2830      	cmp	r0, #48	; 0x30
 8019de8:	d8ed      	bhi.n	8019dc6 <SFXSamplerKTick+0x6a6>
                            tBuffer_tick(&keyBuff[key], input[1]);
 8019dea:	9b05      	ldr	r3, [sp, #20]
 8019dec:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8019df0:	9b01      	ldr	r3, [sp, #4]
 8019df2:	ed93 0a01 	vldr	s0, [r3, #4]
 8019df6:	f010 f8cf 	bl	8029f98 <tBuffer_tick>
 8019dfa:	e7e4      	b.n	8019dc6 <SFXSamplerKTick+0x6a6>
                                crossfadeLengths[key] = displayValues[5];
 8019dfc:	f2c2 0101 	movt	r1, #8193	; 0x2001
 8019e00:	9e00      	ldr	r6, [sp, #0]
 8019e02:	6968      	ldr	r0, [r5, #20]
 8019e04:	9107      	str	r1, [sp, #28]
 8019e06:	4431      	add	r1, r6
 8019e08:	6008      	str	r0, [r1, #0]
 8019e0a:	e585      	b.n	8019918 <SFXSamplerKTick+0x1f8>
                                loopOns[key] = roundf(knobs[4]);
 8019e0c:	fef8 7a67 	vrinta.f32	s15, s15
 8019e10:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8019e14:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8019e18:	ee17 0a90 	vmov	r0, s15
 8019e1c:	468a      	mov	sl, r1
 8019e1e:	f841 0028 	str.w	r0, [r1, r8, lsl #2]
 8019e22:	e56a      	b.n	80198fa <SFXSamplerKTick+0x1da>
                                sampleRatesMult[key] = displayValues[3];
 8019e24:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8019e28:	9900      	ldr	r1, [sp, #0]
 8019e2a:	68e8      	ldr	r0, [r5, #12]
 8019e2c:	1859      	adds	r1, r3, r1
 8019e2e:	6008      	str	r0, [r1, #0]
 8019e30:	e554      	b.n	80198dc <SFXSamplerKTick+0x1bc>
                                sampleRates[key] = displayValues[2];
 8019e32:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e36:	9900      	ldr	r1, [sp, #0]
 8019e38:	68a8      	ldr	r0, [r5, #8]
 8019e3a:	1859      	adds	r1, r3, r1
 8019e3c:	9306      	str	r3, [sp, #24]
 8019e3e:	6008      	str	r0, [r1, #0]
 8019e40:	e53e      	b.n	80198c0 <SFXSamplerKTick+0x1a0>
                                samplePlayLengths[key] = (knobs[1] * recordedLength);
 8019e42:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019e46:	9b00      	ldr	r3, [sp, #0]
 8019e48:	ee67 7a87 	vmul.f32	s15, s15, s14
 8019e4c:	18d1      	adds	r1, r2, r3
 8019e4e:	edc1 7a00 	vstr	s15, [r1]
 8019e52:	e526      	b.n	80198a2 <SFXSamplerKTick+0x182>
                    samplePlayStarts[currentSamplerKey]= (knobs[0] * recordedLength);// + detectedAttackPos[currentSamplerKey];
 8019e54:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8019e58:	ee68 7a27 	vmul.f32	s15, s16, s15
 8019e5c:	443b      	add	r3, r7
 8019e5e:	edc3 7a00 	vstr	s15, [r3]
 8019e62:	e6ed      	b.n	8019c40 <SFXSamplerKTick+0x520>
 8019e64:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019e68:	e759      	b.n	8019d1e <SFXSamplerKTick+0x5fe>
 8019e6a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019e6e:	9302      	str	r3, [sp, #8]
 8019e70:	e704      	b.n	8019c7c <SFXSamplerKTick+0x55c>
                    (rate = 1.0f / fabsf(rate-1.0f));
 8019e72:	ee77 7ae8 	vsub.f32	s15, s15, s17
 8019e76:	eef0 7ae7 	vabs.f32	s15, s15
 8019e7a:	ee88 2aa7 	vdiv.f32	s4, s17, s15
 8019e7e:	e6aa      	b.n	8019bd6 <SFXSamplerKTick+0x4b6>

08019e80 <SFXSamplerKFree>:
        {
 8019e80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8019e82:	f248 1764 	movw	r7, #33124	; 0x8164
 8019e86:	f243 562c 	movw	r6, #13612	; 0x352c
 8019e8a:	f242 658c 	movw	r5, #9868	; 0x268c
 8019e8e:	2400      	movs	r4, #0
 8019e90:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8019e94:	f2c2 0600 	movt	r6, #8192	; 0x2000
 8019e98:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tBuffer_free(&keyBuff[i]);
 8019e9c:	1938      	adds	r0, r7, r4
 8019e9e:	f010 f86f 	bl	8029f80 <tBuffer_free>
                tSampler_free(&keySampler[i]);
 8019ea2:	1930      	adds	r0, r6, r4
 8019ea4:	f010 f958 	bl	802a158 <tSampler_free>
                tExpSmooth_free(&kSamplerGains[i]);
 8019ea8:	1928      	adds	r0, r5, r4
 8019eaa:	3404      	adds	r4, #4
 8019eac:	f00c f85a 	bl	8025f64 <tExpSmooth_free>
            for (int i = 0; i < NUM_SAMPLER_KEYS; i++)
 8019eb0:	2cc4      	cmp	r4, #196	; 0xc4
 8019eb2:	d1f3      	bne.n	8019e9c <SFXSamplerKFree+0x1c>
        }
 8019eb4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8019eb6:	bf00      	nop

08019eb8 <SFXSamplerAutoAlloc>:
        {
 8019eb8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 8019ebc:	f247 5710 	movw	r7, #29968	; 0x7510
 8019ec0:	f44f 496e 	mov.w	r9, #60928	; 0xee00
 8019ec4:	f247 5500 	movw	r5, #29952	; 0x7500
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019ec8:	f248 24f8 	movw	r4, #33528	; 0x82f8
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 8019ecc:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8019ed0:	f2c0 0902 	movt	r9, #2
 8019ed4:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019ed8:	f247 7674 	movw	r6, #30580	; 0x7774
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 8019edc:	463a      	mov	r2, r7
 8019ede:	4649      	mov	r1, r9
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
 8019ee0:	f105 0804 	add.w	r8, r5, #4
            tBuffer_initToPool(&asBuff[0], MAX_AUTOSAMP_LENGTH, &largePool);
 8019ee4:	4628      	mov	r0, r5
 8019ee6:	f010 f833 	bl	8029f50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
 8019eea:	4628      	mov	r0, r5
 8019eec:	2100      	movs	r1, #0
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019eee:	f2c2 0401 	movt	r4, #8193	; 0x2001
            tBuffer_setRecordMode(&asBuff[0], RecordOneShot);
 8019ef2:	f010 f891 	bl	802a018 <tBuffer_setRecordMode>
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019ef6:	f2c2 0601 	movt	r6, #8193	; 0x2001
            tBuffer_initToPool(&asBuff[1], MAX_AUTOSAMP_LENGTH, &largePool);
 8019efa:	463a      	mov	r2, r7
 8019efc:	4649      	mov	r1, r9
 8019efe:	4640      	mov	r0, r8
 8019f00:	f010 f826 	bl	8029f50 <tBuffer_initToPool>
            tBuffer_setRecordMode(&asBuff[1], RecordOneShot);
 8019f04:	4640      	mov	r0, r8
 8019f06:	2100      	movs	r1, #0
 8019f08:	f010 f886 	bl	802a018 <tBuffer_setRecordMode>
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019f0c:	4622      	mov	r2, r4
 8019f0e:	4629      	mov	r1, r5
 8019f10:	4630      	mov	r0, r6
            tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
 8019f12:	1d35      	adds	r5, r6, #4
            tSampler_initToPool(&asSampler[0], &asBuff[0], &smallPool);
 8019f14:	f010 f8da 	bl	802a0cc <tSampler_initToPool>
            tSampler_setMode(&asSampler[0], PlayLoop);
 8019f18:	4630      	mov	r0, r6
 8019f1a:	2101      	movs	r1, #1
 8019f1c:	f010 f928 	bl	802a170 <tSampler_setMode>
            tSampler_initToPool(&asSampler[1], &asBuff[1], &smallPool);
 8019f20:	4622      	mov	r2, r4
 8019f22:	4641      	mov	r1, r8
 8019f24:	4628      	mov	r0, r5
 8019f26:	f010 f8d1 	bl	802a0cc <tSampler_initToPool>
            tSampler_setMode(&asSampler[1], PlayLoop);
 8019f2a:	4628      	mov	r0, r5
 8019f2c:	2101      	movs	r1, #1
            randLengthVal = leaf.random() * 10000.0f;
 8019f2e:	f249 45a0 	movw	r5, #38048	; 0x94a0
            tSampler_setMode(&asSampler[1], PlayLoop);
 8019f32:	f010 f91d 	bl	802a170 <tSampler_setMode>
            tEnvelopeFollower_initToPool(&envfollow, 0.00001f, 0.9999f, &smallPool);
 8019f36:	f64f 1272 	movw	r2, #63858	; 0xf972
 8019f3a:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
 8019f3e:	f248 3068 	movw	r0, #33640	; 0x8368
 8019f42:	f6c3 727f 	movt	r2, #16255	; 0x3f7f
 8019f46:	4621      	mov	r1, r4
 8019f48:	f2c3 7327 	movt	r3, #14119	; 0x3727
 8019f4c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019f50:	ee00 2a90 	vmov	s1, r2
            randLengthVal = leaf.random() * 10000.0f;
 8019f54:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tEnvelopeFollower_initToPool(&envfollow, 0.00001f, 0.9999f, &smallPool);
 8019f58:	ee00 3a10 	vmov	s0, r3
 8019f5c:	f008 f92c 	bl	80221b8 <tEnvelopeFollower_initToPool>
            tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
 8019f60:	f24d 730a 	movw	r3, #55050	; 0xd70a
 8019f64:	2200      	movs	r2, #0
 8019f66:	f247 2058 	movw	r0, #29272	; 0x7258
 8019f6a:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 8019f6e:	4621      	mov	r1, r4
 8019f70:	ee00 2a10 	vmov	s0, r2
 8019f74:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8019f78:	ee00 3a90 	vmov	s1, r3
            currentSampler = 1;
 8019f7c:	2401      	movs	r4, #1
            tExpSmooth_initToPool(&cfxSmooth, 0.0f, 0.01f, &smallPool);
 8019f7e:	f00b ffcb 	bl	8025f18 <tExpSmooth_initToPool>
            setLED_A(samplerMode == PlayBackAndForth);
 8019f82:	f240 23a5 	movw	r3, #677	; 0x2a5
 8019f86:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019f8a:	7818      	ldrb	r0, [r3, #0]
 8019f8c:	f1a0 0002 	sub.w	r0, r0, #2
 8019f90:	fab0 f080 	clz	r0, r0
 8019f94:	0940      	lsrs	r0, r0, #5
 8019f96:	f7fb fca9 	bl	80158ec <setLED_A>
            setLED_B(triggerChannel);
 8019f9a:	f240 630d 	movw	r3, #1549	; 0x60d
 8019f9e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8019fa2:	7818      	ldrb	r0, [r3, #0]
 8019fa4:	f7fb fcb2 	bl	801590c <setLED_B>
            currentSampler = 1;
 8019fa8:	f240 5274 	movw	r2, #1396	; 0x574
            sample_countdown = 0;
 8019fac:	f240 6308 	movw	r3, #1544	; 0x608
 8019fb0:	2000      	movs	r0, #0
            currentSampler = 1;
 8019fb2:	f2c2 0200 	movt	r2, #8192	; 0x2000
            randLengthVal = leaf.random() * 10000.0f;
 8019fb6:	6929      	ldr	r1, [r5, #16]
            sample_countdown = 0;
 8019fb8:	f2c2 0300 	movt	r3, #8192	; 0x2000
            currentSampler = 1;
 8019fbc:	7014      	strb	r4, [r2, #0]
            sample_countdown = 0;
 8019fbe:	6018      	str	r0, [r3, #0]
            randLengthVal = leaf.random() * 10000.0f;
 8019fc0:	4788      	blx	r1
 8019fc2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8019fc6:	f240 52ec 	movw	r2, #1516	; 0x5ec
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8019fca:	6929      	ldr	r1, [r5, #16]
            randLengthVal = leaf.random() * 10000.0f;
 8019fcc:	f2c4 631c 	movt	r3, #17948	; 0x461c
 8019fd0:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8019fd4:	ee07 3a90 	vmov	s15, r3
 8019fd8:	ee20 0a27 	vmul.f32	s0, s0, s15
 8019fdc:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 8019fe0:	ed82 0a00 	vstr	s0, [r2]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8019fe4:	4788      	blx	r1
 8019fe6:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8019fea:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
            setLED_C(pitchQuantization);
 8019fee:	f240 52dc 	movw	r2, #1500	; 0x5dc
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8019ff2:	f240 53f0 	movw	r3, #1520	; 0x5f0
 8019ff6:	ee30 0a67 	vsub.f32	s0, s0, s15
            setLED_C(pitchQuantization);
 8019ffa:	f2c2 0200 	movt	r2, #8192	; 0x2000
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 8019ffe:	f2c2 0300 	movt	r3, #8192	; 0x2000
            setLED_C(pitchQuantization);
 801a002:	7810      	ldrb	r0, [r2, #0]
            randRateVal = (leaf.random() - 0.5f) * 4.0f;
 801a004:	ee20 0a07 	vmul.f32	s0, s0, s14
 801a008:	ed83 0a00 	vstr	s0, [r3]
        }
 801a00c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(pitchQuantization);
 801a010:	f7fb bc8c 	b.w	801592c <setLED_C>

0801a014 <SFXSamplerAutoFrame>:
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 801a014:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801a018:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801a01c:	7f1a      	ldrb	r2, [r3, #28]
 801a01e:	2a01      	cmp	r2, #1
 801a020:	d000      	beq.n	801a024 <SFXSamplerAutoFrame+0x10>
        }
 801a022:	4770      	bx	lr
                pitchQuantization = !pitchQuantization;
 801a024:	f240 52dc 	movw	r2, #1500	; 0x5dc
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801a028:	2100      	movs	r1, #0
                pitchQuantization = !pitchQuantization;
 801a02a:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801a02e:	7719      	strb	r1, [r3, #28]
                pitchQuantization = !pitchQuantization;
 801a030:	6813      	ldr	r3, [r2, #0]
 801a032:	fab3 f383 	clz	r3, r3
 801a036:	095b      	lsrs	r3, r3, #5
                setLED_C(pitchQuantization);
 801a038:	4618      	mov	r0, r3
                pitchQuantization = !pitchQuantization;
 801a03a:	6013      	str	r3, [r2, #0]
                setLED_C(pitchQuantization);
 801a03c:	f7fb bc76 	b.w	801592c <setLED_C>

0801a040 <SFXSamplerAutoTick>:
        {
 801a040:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (triggerChannel > 0)
 801a044:	f240 690d 	movw	r9, #1549	; 0x60d
        {
 801a048:	4605      	mov	r5, r0
                currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
 801a04a:	f240 5470 	movw	r4, #1392	; 0x570
 801a04e:	f248 3068 	movw	r0, #33640	; 0x8368
            if (triggerChannel > 0)
 801a052:	f2c2 0900 	movt	r9, #8192	; 0x2000
 801a056:	f899 3000 	ldrb.w	r3, [r9]
        {
 801a05a:	ed2d 8b06 	vpush	{d8-d10}
 801a05e:	b087      	sub	sp, #28
            if (triggerChannel > 0)
 801a060:	2b00      	cmp	r3, #0
 801a062:	f000 8095 	beq.w	801a190 <SFXSamplerAutoTick+0x150>
                currentPower = tEnvelopeFollower_tick(&envfollow, input[0]);
 801a066:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801a06a:	ed95 0a00 	vldr	s0, [r5]
 801a06e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a072:	f008 f8bd 	bl	80221f0 <tEnvelopeFollower_tick>
 801a076:	ed84 0a00 	vstr	s0, [r4]
            samp_thresh = 1.0f - knobs[0];
 801a07a:	f642 5110 	movw	r1, #11536	; 0x2d10
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a07e:	f240 2038 	movw	r0, #568	; 0x238
 801a082:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801a086:	f247 0344 	movw	r3, #28740	; 0x7044
            samp_thresh = 1.0f - knobs[0];
 801a08a:	f2c2 0100 	movt	r1, #8192	; 0x2000
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a08e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801a092:	f6c4 023b 	movt	r2, #18491	; 0x483b
 801a096:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801a09a:	edd0 7a00 	vldr	s15, [r0]
 801a09e:	2600      	movs	r6, #0
 801a0a0:	ed91 7ab0 	vldr	s14, [r1, #704]	; 0x2c0
 801a0a4:	ee00 2a90 	vmov	s1, r2
 801a0a8:	f2c4 467a 	movt	r6, #17530	; 0x447a
 801a0ac:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 801a0b0:	ee27 7a27 	vmul.f32	s14, s14, s15
 801a0b4:	edd1 6ab2 	vldr	s13, [r1, #712]	; 0x2c8
 801a0b8:	ee07 6a90 	vmov	s15, r6
 801a0bc:	f2c4 509c 	movt	r0, #17820	; 0x459c
            samp_thresh = 1.0f - knobs[0];
 801a0c0:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            if (pitchQuantization)
 801a0c4:	f240 56dc 	movw	r6, #1500	; 0x5dc
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a0c8:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            samp_thresh = 1.0f - knobs[0];
 801a0cc:	ed91 6aaf 	vldr	s12, [r1, #700]	; 0x2bc
 801a0d0:	ee66 7aa7 	vmul.f32	s15, s13, s15
 801a0d4:	ed91 9ab4 	vldr	s18, [r1, #720]	; 0x2d0
 801a0d8:	ee06 0a90 	vmov	s13, r0
            if (pitchQuantization)
 801a0dc:	f2c2 0600 	movt	r6, #8192	; 0x2000
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a0e0:	ee17 2a10 	vmov	r2, s14
            samp_thresh = 1.0f - knobs[0];
 801a0e4:	f240 57f4 	movw	r7, #1524	; 0x5f4
 801a0e8:	ee35 6ac6 	vsub.f32	s12, s11, s12
 801a0ec:	ed91 7ab1 	vldr	s14, [r1, #708]	; 0x2c4
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a0f0:	eb03 0282 	add.w	r2, r3, r2, lsl #2
            displayValues[0] = samp_thresh;
 801a0f4:	f248 7394 	movw	r3, #34708	; 0x8794
 801a0f8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            samp_thresh = 1.0f - knobs[0];
 801a0fc:	f2c2 0700 	movt	r7, #8192	; 0x2000
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a100:	edd2 8a00 	vldr	s17, [r2]
 801a104:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
 801a108:	ee29 9a26 	vmul.f32	s18, s18, s13
            displayValues[0] = samp_thresh;
 801a10c:	f2c2 0301 	movt	r3, #8193	; 0x2001
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a110:	ee68 0aa0 	vmul.f32	s1, s17, s1
            if (pitchQuantization)
 801a114:	6832      	ldr	r2, [r6, #0]
 801a116:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
            displayValues[0] = samp_thresh;
 801a11a:	ed83 6a00 	vstr	s12, [r3]
            samp_thresh = 1.0f - knobs[0];
 801a11e:	ed87 6a00 	vstr	s12, [r7]
 801a122:	ee37 7a64 	vsub.f32	s14, s14, s9
            int window_size = expBuffer[(int)(knobs[1] * expBufferSizeMinusOne)] * MAX_AUTOSAMP_LENGTH;
 801a126:	eefd 8ae0 	vcvt.s32.f32	s17, s1
            displayValues[1] = window_size;
 801a12a:	eef8 6ae8 	vcvt.f32.s32	s13, s17
 801a12e:	edc3 6a01 	vstr	s13, [r3, #4]
            if (pitchQuantization)
 801a132:	b3c2      	cbz	r2, 801a1a6 <SFXSamplerAutoTick+0x166>
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
 801a134:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a138:	2200      	movs	r2, #0
 801a13a:	ee06 2a90 	vmov	s13, r2
                rate = roundf((knobs[2] - 0.5f) * 14.0f);
 801a13e:	ee27 7a06 	vmul.f32	s14, s14, s12
 801a142:	feb8 7a47 	vrinta.f32	s14, s14
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a146:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 801a14a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a14e:	f100 8260 	bmi.w	801a612 <SFXSamplerAutoTick+0x5d2>
                else rate += 1.0f;
 801a152:	ee77 9a25 	vadd.f32	s19, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
 801a156:	f240 5864 	movw	r8, #1380	; 0x564
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a15a:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
 801a15e:	ed83 5a03 	vstr	s10, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 801a162:	f2c2 0800 	movt	r8, #8192	; 0x2000
            displayValues[2] = rate;
 801a166:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a16a:	eeb4 9ac7 	vcmpe.f32	s18, s14
            crossfadeLength = knobs[3] * 1000.0f;
 801a16e:	edc8 7a00 	vstr	s15, [r8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a172:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a176:	f100 8266 	bmi.w	801a646 <SFXSamplerAutoTick+0x606>
            displayValues[5] = randLengthAmount;
 801a17a:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = roundf(knobs[6] * 8.0f);
 801a17e:	eeb2 0a00 	vmov.f32	s0, #32	; 0x41000000  8.0
 801a182:	ed91 8ab5 	vldr	s16, [r1, #724]	; 0x2d4
 801a186:	ee28 8a00 	vmul.f32	s16, s16, s0
 801a18a:	feb8 8a48 	vrinta.f32	s16, s16
 801a18e:	e03c      	b.n	801a20a <SFXSamplerAutoTick+0x1ca>
                currentPower = tEnvelopeFollower_tick(&envfollow, input[1]);
 801a190:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801a194:	ed95 0a01 	vldr	s0, [r5, #4]
 801a198:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a19c:	f008 f828 	bl	80221f0 <tEnvelopeFollower_tick>
 801a1a0:	ed84 0a00 	vstr	s0, [r4]
 801a1a4:	e769      	b.n	801a07a <SFXSamplerAutoTick+0x3a>
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a1a6:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
            crossfadeLength = knobs[3] * 1000.0f;
 801a1aa:	f240 5864 	movw	r8, #1380	; 0x564
                rate = (knobs[2] - 0.5f) * 4.0f;
 801a1ae:	eef1 9a00 	vmov.f32	s19, #16	; 0x40800000  4.0
            displayValues[3] = crossfadeLength;
 801a1b2:	ed83 5a03 	vstr	s10, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 801a1b6:	f2c2 0800 	movt	r8, #8192	; 0x2000
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a1ba:	eeb4 9ae6 	vcmpe.f32	s18, s13
                rate = (knobs[2] - 0.5f) * 4.0f;
 801a1be:	ee67 9a29 	vmul.f32	s19, s14, s19
            crossfadeLength = knobs[3] * 1000.0f;
 801a1c2:	edc8 7a00 	vstr	s15, [r8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a1c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[2] = rate;
 801a1ca:	edc3 9a02 	vstr	s19, [r3, #8]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a1ce:	f100 8116 	bmi.w	801a3fe <SFXSamplerAutoTick+0x3be>
            displayValues[5] = randLengthAmount;
 801a1d2:	ed83 9a05 	vstr	s18, [r3, #20]
                randRateAmount = knobs[6] * 2.0f;
 801a1d6:	ed91 8ab5 	vldr	s16, [r1, #724]	; 0x2d4
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
 801a1da:	f241 4a7b 	movw	sl, #5243	; 0x147b
 801a1de:	f647 2be1 	movw	fp, #31457	; 0x7ae1
 801a1e2:	2200      	movs	r2, #0
                randRateAmount = knobs[6] * 2.0f;
 801a1e4:	ee38 8a08 	vadd.f32	s16, s16, s16
                if (randRateAmount < 0.01) randRateAmount = 0.0f;
 801a1e8:	f2c4 7aae 	movt	sl, #18350	; 0x47ae
 801a1ec:	f6c3 7b84 	movt	fp, #16260	; 0x3f84
 801a1f0:	ee07 2a10 	vmov	s14, r2
 801a1f4:	eeb7 5ac8 	vcvt.f64.f32	d5, s16
 801a1f8:	ec4b ab16 	vmov	d6, sl, fp
 801a1fc:	eeb4 5b46 	vcmp.f64	d5, d6
 801a200:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a204:	bf48      	it	mi
 801a206:	eeb0 8a47 	vmovmi.f32	s16, s14
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
 801a20a:	f247 7074 	movw	r0, #30580	; 0x7774
 801a20e:	ee17 1a90 	vmov	r1, s15
            displayValues[6] = randRateAmount;
 801a212:	ed83 8a06 	vstr	s16, [r3, #24]
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 801a216:	f240 5ae8 	movw	sl, #1512	; 0x5e8
            tSampler_setCrossfadeLength(&asSampler[0], crossfadeLength);
 801a21a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a21e:	f00f ffab 	bl	802a178 <tSampler_setCrossfadeLength>
            tSampler_setCrossfadeLength(&asSampler[1], crossfadeLength);
 801a222:	f247 7078 	movw	r0, #30584	; 0x7778
 801a226:	f8d8 1000 	ldr.w	r1, [r8]
 801a22a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a22e:	f00f ffa3 	bl	802a178 <tSampler_setCrossfadeLength>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 801a232:	ed94 7a00 	vldr	s14, [r4]
 801a236:	edd7 7a00 	vldr	s15, [r7]
 801a23a:	eeb4 7ae7 	vcmpe.f32	s14, s15
 801a23e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a242:	f300 80e1 	bgt.w	801a408 <SFXSamplerAutoTick+0x3c8>
 801a246:	f240 6108 	movw	r1, #1544	; 0x608
 801a24a:	f240 5bec 	movw	fp, #1516	; 0x5ec
 801a24e:	f240 58f0 	movw	r8, #1520	; 0x5f0
 801a252:	f240 273c 	movw	r7, #572	; 0x23c
 801a256:	f247 7274 	movw	r2, #30580	; 0x7774
 801a25a:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801a25e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801a262:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801a266:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801a26a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801a26e:	f2c2 0201 	movt	r2, #8193	; 0x2001
            tBuffer_tick(&asBuff[0], input[1]);
 801a272:	f247 5000 	movw	r0, #29952	; 0x7500
 801a276:	ed95 0a01 	vldr	s0, [r5, #4]
 801a27a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a27e:	e9cd 1200 	strd	r1, r2, [sp]
 801a282:	f00f fe89 	bl	8029f98 <tBuffer_tick>
            tBuffer_tick(&asBuff[1], input[1]);
 801a286:	f247 5004 	movw	r0, #29956	; 0x7504
 801a28a:	ed95 0a01 	vldr	s0, [r5, #4]
 801a28e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a292:	f00f fe81 	bl	8029f98 <tBuffer_tick>
            if (sample_countdown > 0)
 801a296:	9900      	ldr	r1, [sp, #0]
 801a298:	9a01      	ldr	r2, [sp, #4]
 801a29a:	680b      	ldr	r3, [r1, #0]
 801a29c:	2b00      	cmp	r3, #0
 801a29e:	f000 80e2 	beq.w	801a466 <SFXSamplerAutoTick+0x426>
                sample_countdown--;
 801a2a2:	3b01      	subs	r3, #1
 801a2a4:	600b      	str	r3, [r1, #0]
            if (pitchQuantization)
 801a2a6:	6833      	ldr	r3, [r6, #0]
                tSampler_setRate(&asSampler[0], rate * randRateVal);
 801a2a8:	f247 7074 	movw	r0, #30580	; 0x7774
 801a2ac:	ed98 0a00 	vldr	s0, [r8]
            if (pitchQuantization)
 801a2b0:	2b00      	cmp	r3, #0
 801a2b2:	f000 80c7 	beq.w	801a444 <SFXSamplerAutoTick+0x404>
                tSampler_setRate(&asSampler[0], rate * randRateVal);
 801a2b6:	ee29 0a80 	vmul.f32	s0, s19, s0
 801a2ba:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a2be:	f010 fc8b 	bl	802abd8 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate * randRateVal);
 801a2c2:	ed98 0a00 	vldr	s0, [r8]
 801a2c6:	f247 7078 	movw	r0, #30584	; 0x7778
 801a2ca:	ee29 0a80 	vmul.f32	s0, s19, s0
 801a2ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a2d2:	f010 fc81 	bl	802abd8 <tSampler_setRate>
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a2d6:	f8db 3000 	ldr.w	r3, [fp]
 801a2da:	ee18 1a90 	vmov	r1, s17
 801a2de:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 801a2e2:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a2e6:	4419      	add	r1, r3
            if (buttonActionsSFX[ButtonA][ActionPress])
 801a2e8:	f248 66e4 	movw	r6, #34532	; 0x86e4
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a2ec:	f6c4 023b 	movt	r2, #18491	; 0x483b
 801a2f0:	ee00 1a90 	vmov	s1, r1
            if (buttonActionsSFX[ButtonA][ActionPress])
 801a2f4:	f2c2 0601 	movt	r6, #8193	; 0x2001
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a2f8:	ee01 2a10 	vmov	s2, r2
 801a2fc:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 801a300:	f00d fb5a 	bl	80279b8 <LEAF_clip>
 801a304:	eefd 7ac0 	vcvt.s32.f32	s15, s0
            tSampler_setEnd(&asSampler[0], finalWindowSize);
 801a308:	f247 7074 	movw	r0, #30580	; 0x7774
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a30c:	ee17 1a90 	vmov	r1, s15
            tSampler_setEnd(&asSampler[0], finalWindowSize);
 801a310:	f2c2 0001 	movt	r0, #8193	; 0x2001
            finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a314:	edc7 7a00 	vstr	s15, [r7]
            tSampler_setEnd(&asSampler[0], finalWindowSize);
 801a318:	f010 f830 	bl	802a37c <tSampler_setEnd>
            tSampler_setEnd(&asSampler[1], finalWindowSize);
 801a31c:	f247 7078 	movw	r0, #30584	; 0x7778
 801a320:	6839      	ldr	r1, [r7, #0]
 801a322:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a326:	f010 f829 	bl	802a37c <tSampler_setEnd>
            if (buttonActionsSFX[ButtonA][ActionPress])
 801a32a:	7d33      	ldrb	r3, [r6, #20]
 801a32c:	b16b      	cbz	r3, 801a34a <SFXSamplerAutoTick+0x30a>
                if (samplerMode == PlayLoop)
 801a32e:	f240 27a5 	movw	r7, #677	; 0x2a5
 801a332:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801a336:	f897 8000 	ldrb.w	r8, [r7]
 801a33a:	f1b8 0f01 	cmp.w	r8, #1
 801a33e:	f000 8197 	beq.w	801a670 <SFXSamplerAutoTick+0x630>
                else if (samplerMode == PlayBackAndForth)
 801a342:	f1b8 0f02 	cmp.w	r8, #2
 801a346:	f000 81a9 	beq.w	801a69c <SFXSamplerAutoTick+0x65c>
            if (buttonActionsSFX[ButtonB][ActionPress])
 801a34a:	7e33      	ldrb	r3, [r6, #24]
 801a34c:	2b00      	cmp	r3, #0
 801a34e:	f040 80c1 	bne.w	801a4d4 <SFXSamplerAutoTick+0x494>
            float fade = tExpSmooth_tick(&cfxSmooth);
 801a352:	f247 2658 	movw	r6, #29272	; 0x7258
 801a356:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801a35a:	4630      	mov	r0, r6
 801a35c:	f00b fe22 	bl	8025fa4 <tExpSmooth_tick>
            if (fabsf(cfxSmooth->curr - cfxSmooth->dest) < 0.00001f)
 801a360:	6832      	ldr	r2, [r6, #0]
 801a362:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
 801a366:	edd2 7a03 	vldr	s15, [r2, #12]
 801a36a:	edd2 6a04 	vldr	s13, [r2, #16]
 801a36e:	f2c3 7327 	movt	r3, #14119	; 0x3727
 801a372:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801a376:	ee07 3a10 	vmov	s14, r3
 801a37a:	eef0 7ae7 	vabs.f32	s15, s15
 801a37e:	eef4 7ac7 	vcmpe.f32	s15, s14
 801a382:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a386:	d505      	bpl.n	801a394 <SFXSamplerAutoTick+0x354>
                fadeDone = 1;
 801a388:	f240 5384 	movw	r3, #1412	; 0x584
 801a38c:	2201      	movs	r2, #1
 801a38e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a392:	601a      	str	r2, [r3, #0]
            LEAF_crossfade((fade * 2.0f) - 1.0f, volumes);
 801a394:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 801a398:	a804      	add	r0, sp, #16
 801a39a:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801a39e:	eee0 7a07 	vfma.f32	s15, s0, s14
 801a3a2:	eeb0 0a67 	vmov.f32	s0, s15
 801a3a6:	f00d fa77 	bl	8027898 <LEAF_crossfade>
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 801a3aa:	f247 7074 	movw	r0, #30580	; 0x7774
 801a3ae:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a3b2:	f010 f879 	bl	802a4a8 <tSampler_tick>
 801a3b6:	f247 7078 	movw	r0, #30584	; 0x7778
 801a3ba:	eef0 8a40 	vmov.f32	s17, s0
 801a3be:	ed9d 8a05 	vldr	s16, [sp, #20]
 801a3c2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a3c6:	f010 f86f 	bl	802a4a8 <tSampler_tick>
 801a3ca:	eddd 7a04 	vldr	s15, [sp, #16]
            input[0] = sample * 0.99f;
 801a3ce:	f247 03a4 	movw	r3, #28836	; 0x70a4
            previousPower = currentPower;
 801a3d2:	6822      	ldr	r2, [r4, #0]
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 801a3d4:	ee20 0a27 	vmul.f32	s0, s0, s15
            input[0] = sample * 0.99f;
 801a3d8:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
            previousPower = currentPower;
 801a3dc:	f8ca 2000 	str.w	r2, [sl]
            sample = (tSampler_tick(&asSampler[0]) * volumes[1]) + (tSampler_tick(&asSampler[1]) * volumes[0]);
 801a3e0:	eea8 0a88 	vfma.f32	s0, s17, s16
            input[0] = sample * 0.99f;
 801a3e4:	ee07 3a90 	vmov	s15, r3
 801a3e8:	ee20 0a27 	vmul.f32	s0, s0, s15
 801a3ec:	ed85 0a00 	vstr	s0, [r5]
            input[1] = sample * 0.99f;
 801a3f0:	ed85 0a01 	vstr	s0, [r5, #4]
        }
 801a3f4:	b007      	add	sp, #28
 801a3f6:	ecbd 8b06 	vpop	{d8-d10}
 801a3fa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
            displayValues[5] = randLengthAmount;
 801a3fe:	2200      	movs	r2, #0
 801a400:	ee09 2a10 	vmov	s18, r2
 801a404:	615a      	str	r2, [r3, #20]
 801a406:	e6e6      	b.n	801a1d6 <SFXSamplerAutoTick+0x196>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 801a408:	f241 236f 	movw	r3, #4719	; 0x126f
 801a40c:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801a410:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 801a414:	ed9a 7a00 	vldr	s14, [sl]
 801a418:	edd4 6a00 	vldr	s13, [r4]
 801a41c:	ee07 3a90 	vmov	s15, r3
 801a420:	ee77 7a27 	vadd.f32	s15, s14, s15
 801a424:	eef4 7ae6 	vcmpe.f32	s15, s13
 801a428:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a42c:	d45f      	bmi.n	801a4ee <SFXSamplerAutoTick+0x4ae>
 801a42e:	f240 6108 	movw	r1, #1544	; 0x608
 801a432:	f240 5bec 	movw	fp, #1516	; 0x5ec
 801a436:	f240 58f0 	movw	r8, #1520	; 0x5f0
 801a43a:	f240 273c 	movw	r7, #572	; 0x23c
 801a43e:	f247 7274 	movw	r2, #30580	; 0x7774
 801a442:	e70c      	b.n	801a25e <SFXSamplerAutoTick+0x21e>
                tSampler_setRate(&asSampler[0], rate + randRateVal);
 801a444:	ee39 0a80 	vadd.f32	s0, s19, s0
 801a448:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a44c:	f010 fbc4 	bl	802abd8 <tSampler_setRate>
                tSampler_setRate(&asSampler[1], rate + randRateVal);
 801a450:	ed98 0a00 	vldr	s0, [r8]
 801a454:	f247 7078 	movw	r0, #30584	; 0x7778
 801a458:	ee39 0a80 	vadd.f32	s0, s19, s0
 801a45c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a460:	f010 fbba 	bl	802abd8 <tSampler_setRate>
 801a464:	e737      	b.n	801a2d6 <SFXSamplerAutoTick+0x296>
            else if (samp_triggered == 1)
 801a466:	f240 51f8 	movw	r1, #1528	; 0x5f8
 801a46a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801a46e:	6808      	ldr	r0, [r1, #0]
 801a470:	2801      	cmp	r0, #1
 801a472:	f47f af18 	bne.w	801a2a6 <SFXSamplerAutoTick+0x266>
                setLED_1(0);
 801a476:	4618      	mov	r0, r3
 801a478:	9301      	str	r3, [sp, #4]
 801a47a:	e9cd 1202 	strd	r1, r2, [sp, #8]
                currentSampler = !currentSampler;
 801a47e:	f240 5274 	movw	r2, #1396	; 0x574
 801a482:	9200      	str	r2, [sp, #0]
                setLED_1(0);
 801a484:	f7fb fa12 	bl	80158ac <setLED_1>
                currentSampler = !currentSampler;
 801a488:	9b00      	ldr	r3, [sp, #0]
                tSampler_play(&asSampler[currentSampler]);
 801a48a:	9a03      	ldr	r2, [sp, #12]
                currentSampler = !currentSampler;
 801a48c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a490:	f893 c000 	ldrb.w	ip, [r3]
 801a494:	9300      	str	r3, [sp, #0]
 801a496:	fabc fc8c 	clz	ip, ip
 801a49a:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
                tSampler_play(&asSampler[currentSampler]);
 801a49e:	eb02 008c 	add.w	r0, r2, ip, lsl #2
                currentSampler = !currentSampler;
 801a4a2:	f883 c000 	strb.w	ip, [r3]
                tSampler_play(&asSampler[currentSampler]);
 801a4a6:	f00f fe7b 	bl	802a1a0 <tSampler_play>
                tExpSmooth_setDest(&cfxSmooth,(float)currentSampler);
 801a4aa:	9b00      	ldr	r3, [sp, #0]
 801a4ac:	f247 2058 	movw	r0, #29272	; 0x7258
 801a4b0:	781b      	ldrb	r3, [r3, #0]
 801a4b2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a4b6:	ee00 3a10 	vmov	s0, r3
 801a4ba:	eeb8 0a40 	vcvt.f32.u32	s0, s0
 801a4be:	f00b fd67 	bl	8025f90 <tExpSmooth_setDest>
                fadeDone = 0;
 801a4c2:	f240 5284 	movw	r2, #1412	; 0x584
                samp_triggered = 0;
 801a4c6:	e9dd 3101 	ldrd	r3, r1, [sp, #4]
                fadeDone = 0;
 801a4ca:	f2c2 0200 	movt	r2, #8192	; 0x2000
                samp_triggered = 0;
 801a4ce:	600b      	str	r3, [r1, #0]
                fadeDone = 0;
 801a4d0:	6013      	str	r3, [r2, #0]
 801a4d2:	e6e8      	b.n	801a2a6 <SFXSamplerAutoTick+0x266>
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 801a4d4:	f899 3000 	ldrb.w	r3, [r9]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801a4d8:	2200      	movs	r2, #0
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 801a4da:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801a4de:	7632      	strb	r2, [r6, #24]
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 801a4e0:	095b      	lsrs	r3, r3, #5
                setLED_B(triggerChannel);
 801a4e2:	4618      	mov	r0, r3
                triggerChannel = (triggerChannel > 0) ? 0 : 1;
 801a4e4:	f889 3000 	strb.w	r3, [r9]
                setLED_B(triggerChannel);
 801a4e8:	f7fb fa10 	bl	801590c <setLED_B>
 801a4ec:	e731      	b.n	801a352 <SFXSamplerAutoTick+0x312>
            if ((currentPower > (samp_thresh)) && (currentPower > (previousPower + 0.001f)) && (samp_triggered == 0) && (sample_countdown == 0) && (fadeDone == 1))
 801a4ee:	f240 53f8 	movw	r3, #1528	; 0x5f8
 801a4f2:	f240 6108 	movw	r1, #1544	; 0x608
 801a4f6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a4fa:	681a      	ldr	r2, [r3, #0]
 801a4fc:	2a00      	cmp	r2, #0
 801a4fe:	d198      	bne.n	801a432 <SFXSamplerAutoTick+0x3f2>
 801a500:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801a504:	680a      	ldr	r2, [r1, #0]
 801a506:	2a00      	cmp	r2, #0
 801a508:	f040 80a1 	bne.w	801a64e <SFXSamplerAutoTick+0x60e>
 801a50c:	f240 5284 	movw	r2, #1412	; 0x584
 801a510:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801a514:	6812      	ldr	r2, [r2, #0]
 801a516:	2a01      	cmp	r2, #1
 801a518:	f040 8099 	bne.w	801a64e <SFXSamplerAutoTick+0x60e>
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
 801a51c:	f249 47a0 	movw	r7, #38048	; 0x94a0
 801a520:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
 801a524:	ee39 9a09 	vadd.f32	s18, s18, s18
 801a528:	f240 5bec 	movw	fp, #1516	; 0x5ec
 801a52c:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801a530:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801a534:	693a      	ldr	r2, [r7, #16]
 801a536:	e9cd 1300 	strd	r1, r3, [sp]
 801a53a:	4790      	blx	r2
 801a53c:	ee30 0a4a 	vsub.f32	s0, s0, s20
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
 801a540:	6832      	ldr	r2, [r6, #0]
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
 801a542:	ee20 0a09 	vmul.f32	s0, s0, s18
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
 801a546:	e9dd 1300 	ldrd	r1, r3, [sp]
                randLengthVal = (leaf.random() - 0.5f) * randLengthAmount * 2.0f;
 801a54a:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 801a54e:	ed8b 0a00 	vstr	s0, [fp]
                if (pitchQuantization) randRateVal = roundf(leaf.random() * randRateAmount) + 1.0f;
 801a552:	2a00      	cmp	r2, #0
 801a554:	f000 80b8 	beq.w	801a6c8 <SFXSamplerAutoTick+0x688>
 801a558:	693a      	ldr	r2, [r7, #16]
 801a55a:	f240 58f0 	movw	r8, #1520	; 0x5f0
 801a55e:	4790      	blx	r2
 801a560:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801a564:	ee60 7a08 	vmul.f32	s15, s0, s16
 801a568:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801a56c:	e9dd 1300 	ldrd	r1, r3, [sp]
 801a570:	fef8 7a67 	vrinta.f32	s15, s15
 801a574:	ee77 7a87 	vadd.f32	s15, s15, s14
 801a578:	edc8 7a00 	vstr	s15, [r8]
                tSampler_stop(&asSampler[!currentSampler]);
 801a57c:	f240 5274 	movw	r2, #1396	; 0x574
                samp_triggered = 1;
 801a580:	2001      	movs	r0, #1
 801a582:	9102      	str	r1, [sp, #8]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a584:	f240 273c 	movw	r7, #572	; 0x23c
                tSampler_stop(&asSampler[!currentSampler]);
 801a588:	9200      	str	r2, [sp, #0]
 801a58a:	f247 7274 	movw	r2, #30580	; 0x7774
                samp_triggered = 1;
 801a58e:	6018      	str	r0, [r3, #0]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a590:	f2c2 0700 	movt	r7, #8192	; 0x2000
                tSampler_stop(&asSampler[!currentSampler]);
 801a594:	9201      	str	r2, [sp, #4]
                setLED_1(1);
 801a596:	f7fb f989 	bl	80158ac <setLED_1>
                tSampler_stop(&asSampler[!currentSampler]);
 801a59a:	9a00      	ldr	r2, [sp, #0]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a59c:	ee18 1a90 	vmov	r1, s17
 801a5a0:	f8db 3000 	ldr.w	r3, [fp]
 801a5a4:	f44f 4000 	mov.w	r0, #32768	; 0x8000
                tSampler_stop(&asSampler[!currentSampler]);
 801a5a8:	f2c2 0200 	movt	r2, #8192	; 0x2000
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5ac:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801a5b0:	4419      	add	r1, r3
 801a5b2:	f6c4 003b 	movt	r0, #18491	; 0x483b
                tSampler_stop(&asSampler[!currentSampler]);
 801a5b6:	9200      	str	r2, [sp, #0]
 801a5b8:	9a01      	ldr	r2, [sp, #4]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5ba:	ee00 1a90 	vmov	s1, r1
 801a5be:	ee01 0a10 	vmov	s2, r0
                tSampler_stop(&asSampler[!currentSampler]);
 801a5c2:	f2c2 0201 	movt	r2, #8193	; 0x2001
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5c6:	eef8 0ae0 	vcvt.f32.s32	s1, s1
                tSampler_stop(&asSampler[!currentSampler]);
 801a5ca:	9201      	str	r2, [sp, #4]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5cc:	f00d f9f4 	bl	80279b8 <LEAF_clip>
                tSampler_stop(&asSampler[!currentSampler]);
 801a5d0:	9b00      	ldr	r3, [sp, #0]
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5d2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
                tSampler_stop(&asSampler[!currentSampler]);
 801a5d6:	9a01      	ldr	r2, [sp, #4]
 801a5d8:	7818      	ldrb	r0, [r3, #0]
                sample_countdown = finalWindowSize;
 801a5da:	9902      	ldr	r1, [sp, #8]
                tSampler_stop(&asSampler[!currentSampler]);
 801a5dc:	fab0 f080 	clz	r0, r0
                finalWindowSize = LEAF_clip(4, window_size + randLengthVal, MAX_AUTOSAMP_LENGTH);
 801a5e0:	edc7 7a00 	vstr	s15, [r7]
                sample_countdown = finalWindowSize;
 801a5e4:	edc1 7a00 	vstr	s15, [r1]
                tSampler_stop(&asSampler[!currentSampler]);
 801a5e8:	0940      	lsrs	r0, r0, #5
 801a5ea:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 801a5ee:	f00f fe25 	bl	802a23c <tSampler_stop>
                tBuffer_record(&asBuff[!currentSampler]);
 801a5f2:	9b00      	ldr	r3, [sp, #0]
 801a5f4:	f247 5000 	movw	r0, #29952	; 0x7500
 801a5f8:	781b      	ldrb	r3, [r3, #0]
 801a5fa:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a5fe:	fab3 f383 	clz	r3, r3
 801a602:	095b      	lsrs	r3, r3, #5
 801a604:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 801a608:	f00f fcf4 	bl	8029ff4 <tBuffer_record>
 801a60c:	e9dd 2101 	ldrd	r2, r1, [sp, #4]
 801a610:	e62f      	b.n	801a272 <SFXSamplerAutoTick+0x232>
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a612:	ee37 7a65 	vsub.f32	s14, s14, s11
            crossfadeLength = knobs[3] * 1000.0f;
 801a616:	f240 5864 	movw	r8, #1380	; 0x564
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a61a:	eeb3 6a04 	vmov.f32	s12, #52	; 0x41a00000  20.0
            displayValues[3] = crossfadeLength;
 801a61e:	ed83 5a03 	vstr	s10, [r3, #12]
            crossfadeLength = knobs[3] * 1000.0f;
 801a622:	f2c2 0800 	movt	r8, #8192	; 0x2000
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a626:	eeb0 7ac7 	vabs.f32	s14, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a62a:	eeb4 9a46 	vcmp.f32	s18, s12
            crossfadeLength = knobs[3] * 1000.0f;
 801a62e:	edc8 7a00 	vstr	s15, [r8]
                if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801a632:	eec5 9a87 	vdiv.f32	s19, s11, s14
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a636:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801a63a:	bf48      	it	mi
 801a63c:	eeb0 9a66 	vmovmi.f32	s18, s13
            displayValues[2] = rate;
 801a640:	edc3 9a02 	vstr	s19, [r3, #8]
 801a644:	e599      	b.n	801a17a <SFXSamplerAutoTick+0x13a>
            displayValues[5] = randLengthAmount;
 801a646:	615a      	str	r2, [r3, #20]
            if (randLengthAmount < 20.0f) randLengthAmount = 0.0f;
 801a648:	ee09 2a10 	vmov	s18, r2
 801a64c:	e597      	b.n	801a17e <SFXSamplerAutoTick+0x13e>
 801a64e:	f240 5bec 	movw	fp, #1516	; 0x5ec
 801a652:	f240 58f0 	movw	r8, #1520	; 0x5f0
 801a656:	f240 273c 	movw	r7, #572	; 0x23c
 801a65a:	f247 7274 	movw	r2, #30580	; 0x7774
 801a65e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801a662:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801a666:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801a66a:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801a66e:	e600      	b.n	801a272 <SFXSamplerAutoTick+0x232>
                    tSampler_setMode(&asSampler[0], PlayBackAndForth);
 801a670:	f247 7074 	movw	r0, #30580	; 0x7774
 801a674:	2102      	movs	r1, #2
 801a676:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a67a:	f00f fd79 	bl	802a170 <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayBackAndForth);
 801a67e:	f247 7078 	movw	r0, #30584	; 0x7778
 801a682:	2102      	movs	r1, #2
 801a684:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a688:	f00f fd72 	bl	802a170 <tSampler_setMode>
                    samplerMode = PlayBackAndForth;
 801a68c:	2302      	movs	r3, #2
                    setLED_A(1);
 801a68e:	4640      	mov	r0, r8
                    samplerMode = PlayBackAndForth;
 801a690:	703b      	strb	r3, [r7, #0]
                    setLED_A(1);
 801a692:	f7fb f92b 	bl	80158ec <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a696:	2300      	movs	r3, #0
 801a698:	7533      	strb	r3, [r6, #20]
 801a69a:	e656      	b.n	801a34a <SFXSamplerAutoTick+0x30a>
                    tSampler_setMode(&asSampler[0], PlayLoop);
 801a69c:	f247 7074 	movw	r0, #30580	; 0x7774
 801a6a0:	2101      	movs	r1, #1
 801a6a2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a6a6:	f00f fd63 	bl	802a170 <tSampler_setMode>
                    tSampler_setMode(&asSampler[1], PlayLoop);
 801a6aa:	f247 7078 	movw	r0, #30584	; 0x7778
 801a6ae:	2101      	movs	r1, #1
 801a6b0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a6b4:	f00f fd5c 	bl	802a170 <tSampler_setMode>
                    samplerMode = PlayLoop;
 801a6b8:	2301      	movs	r3, #1
                    setLED_A(0);
 801a6ba:	2000      	movs	r0, #0
                    samplerMode = PlayLoop;
 801a6bc:	703b      	strb	r3, [r7, #0]
                    setLED_A(0);
 801a6be:	f7fb f915 	bl	80158ec <setLED_A>
                    buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a6c2:	2300      	movs	r3, #0
 801a6c4:	7533      	strb	r3, [r6, #20]
 801a6c6:	e640      	b.n	801a34a <SFXSamplerAutoTick+0x30a>
                else randRateVal = (leaf.random() - 0.5f) * randRateAmount * 2.0f;
 801a6c8:	693a      	ldr	r2, [r7, #16]
 801a6ca:	ee38 8a08 	vadd.f32	s16, s16, s16
 801a6ce:	f240 58f0 	movw	r8, #1520	; 0x5f0
 801a6d2:	e9cd 1300 	strd	r1, r3, [sp]
 801a6d6:	4790      	blx	r2
 801a6d8:	ee30 0a4a 	vsub.f32	s0, s0, s20
 801a6dc:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801a6e0:	ee20 8a08 	vmul.f32	s16, s0, s16
 801a6e4:	e9dd 1300 	ldrd	r1, r3, [sp]
 801a6e8:	ed88 8a00 	vstr	s16, [r8]
 801a6ec:	e746      	b.n	801a57c <SFXSamplerAutoTick+0x53c>
 801a6ee:	bf00      	nop

0801a6f0 <SFXSamplerAutoFree>:
        {
 801a6f0:	b538      	push	{r3, r4, r5, lr}
            tBuffer_free(&asBuff[0]);
 801a6f2:	f247 5500 	movw	r5, #29952	; 0x7500
            tSampler_free(&asSampler[0]);
 801a6f6:	f247 7474 	movw	r4, #30580	; 0x7774
            tBuffer_free(&asBuff[0]);
 801a6fa:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tSampler_free(&asSampler[0]);
 801a6fe:	f2c2 0401 	movt	r4, #8193	; 0x2001
            tBuffer_free(&asBuff[0]);
 801a702:	4628      	mov	r0, r5
 801a704:	f00f fc3c 	bl	8029f80 <tBuffer_free>
            tBuffer_free(&asBuff[1]);
 801a708:	1d28      	adds	r0, r5, #4
 801a70a:	f00f fc39 	bl	8029f80 <tBuffer_free>
            tSampler_free(&asSampler[0]);
 801a70e:	4620      	mov	r0, r4
 801a710:	f00f fd22 	bl	802a158 <tSampler_free>
            tSampler_free(&asSampler[1]);
 801a714:	1d20      	adds	r0, r4, #4
 801a716:	f00f fd1f 	bl	802a158 <tSampler_free>
            tEnvelopeFollower_free(&envfollow);
 801a71a:	f248 3068 	movw	r0, #33640	; 0x8368
 801a71e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a722:	f007 fd61 	bl	80221e8 <tEnvelopeFollower_free>
            tExpSmooth_free(&cfxSmooth);
 801a726:	f247 2058 	movw	r0, #29272	; 0x7258
        }
 801a72a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            tExpSmooth_free(&cfxSmooth);
 801a72e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a732:	f00b bc17 	b.w	8025f64 <tExpSmooth_free>
 801a736:	bf00      	nop

0801a738 <SFXDistortionAlloc>:
        {
 801a738:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            tOversampler_initToPool(&oversampler, distOS_ratio, FALSE, &smallPool);
 801a73c:	f248 26f8 	movw	r6, #33528	; 0x82f8
 801a740:	f240 2534 	movw	r5, #564	; 0x234
            leaf.clearOnAllocation = 1;
 801a744:	f249 44a0 	movw	r4, #38048	; 0x94a0
            tOversampler_initToPool(&oversampler, distOS_ratio, FALSE, &smallPool);
 801a748:	f248 1048 	movw	r0, #33096	; 0x8148
 801a74c:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801a750:	f2c2 0500 	movt	r5, #8192	; 0x2000
            leaf.clearOnAllocation = 1;
 801a754:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801a758:	2701      	movs	r7, #1
            tOversampler_initToPool(&oversampler, distOS_ratio, FALSE, &smallPool);
 801a75a:	4633      	mov	r3, r6
 801a75c:	6829      	ldr	r1, [r5, #0]
 801a75e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a762:	2200      	movs	r2, #0
            leaf.clearOnAllocation = 1;
 801a764:	6167      	str	r7, [r4, #20]
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
 801a766:	f247 49fc 	movw	r9, #29948	; 0x74fc
            tOversampler_initToPool(&oversampler, distOS_ratio, FALSE, &smallPool);
 801a76a:	f008 fd57 	bl	802321c <tOversampler_initToPool>
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
 801a76e:	2300      	movs	r3, #0
 801a770:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801a774:	4632      	mov	r2, r6
 801a776:	f2c4 23a0 	movt	r3, #17056	; 0x42a0
 801a77a:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 801a77e:	4648      	mov	r0, r9
 801a780:	2106      	movs	r1, #6
 801a782:	ee00 3a10 	vmov	s0, r3
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
 801a786:	f247 4824 	movw	r8, #29732	; 0x7424
            tVZFilter_initToPool(&shelf1, Lowshelf, 80.0f, 6.0f, &smallPool);
 801a78a:	f00b ff63 	bl	8026654 <tVZFilter_initToPool>
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
 801a78e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 801a792:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801a796:	4632      	mov	r2, r6
 801a798:	f2c4 633b 	movt	r3, #17979	; 0x463b
 801a79c:	eef1 0a08 	vmov.f32	s1, #24	; 0x40c00000  6.0
 801a7a0:	4640      	mov	r0, r8
 801a7a2:	2107      	movs	r1, #7
 801a7a4:	ee00 3a10 	vmov	s0, r3
            tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
 801a7a8:	f247 373c 	movw	r7, #29500	; 0x733c
            tVZFilter_initToPool(&shelf2, Highshelf, 12000.0f, 6.0f, &smallPool);
 801a7ac:	f00b ff52 	bl	8026654 <tVZFilter_initToPool>
            tVZFilter_initToPool(&bell1, Bell, 1000.0f, 1.9f, &smallPool);
 801a7b0:	f243 3133 	movw	r1, #13107	; 0x3333
 801a7b4:	2300      	movs	r3, #0
 801a7b6:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801a7ba:	f6c3 71f3 	movt	r1, #16371	; 0x3ff3
 801a7be:	4632      	mov	r2, r6
 801a7c0:	f2c4 437a 	movt	r3, #17530	; 0x447a
 801a7c4:	4638      	mov	r0, r7
 801a7c6:	ee00 1a90 	vmov	s1, r1
 801a7ca:	2105      	movs	r1, #5
 801a7cc:	ee00 3a10 	vmov	s0, r3
 801a7d0:	f00b ff40 	bl	8026654 <tVZFilter_initToPool>
            tVZFilter_setSampleRate(&shelf1, leaf.sampleRate * distOS_ratio);
 801a7d4:	edd5 7a00 	vldr	s15, [r5]
 801a7d8:	ed94 0a00 	vldr	s0, [r4]
 801a7dc:	4648      	mov	r0, r9
 801a7de:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801a7e2:	ee27 0a80 	vmul.f32	s0, s15, s0
 801a7e6:	f00c f93f 	bl	8026a68 <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&shelf2, leaf.sampleRate * distOS_ratio);
 801a7ea:	edd5 7a00 	vldr	s15, [r5]
 801a7ee:	ed94 0a00 	vldr	s0, [r4]
 801a7f2:	4640      	mov	r0, r8
 801a7f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 801a7f8:	ee27 0a80 	vmul.f32	s0, s15, s0
 801a7fc:	f00c f934 	bl	8026a68 <tVZFilter_setSampleRate>
            tVZFilter_setSampleRate(&bell1, leaf.sampleRate * distOS_ratio);
 801a800:	ed95 0a00 	vldr	s0, [r5]
 801a804:	edd4 7a00 	vldr	s15, [r4]
 801a808:	4638      	mov	r0, r7
 801a80a:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 801a80e:	ee20 0a27 	vmul.f32	s0, s0, s15
 801a812:	f00c f929 	bl	8026a68 <tVZFilter_setSampleRate>
            setLED_A(distortionMode);
 801a816:	f240 537c 	movw	r3, #1404	; 0x57c
 801a81a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801a81e:	7818      	ldrb	r0, [r3, #0]
 801a820:	f7fb f864 	bl	80158ec <setLED_A>
            leaf.clearOnAllocation = 0;
 801a824:	2300      	movs	r3, #0
 801a826:	6163      	str	r3, [r4, #20]
        }
 801a828:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0801a82c <SFXDistortionFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 801a82c:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801a830:	f2c2 0301 	movt	r3, #8193	; 0x2001
        {
 801a834:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
 801a836:	7d1a      	ldrb	r2, [r3, #20]
 801a838:	b16a      	cbz	r2, 801a856 <SFXDistortionFrame+0x2a>
                distortionMode = !distortionMode;
 801a83a:	f240 527c 	movw	r2, #1404	; 0x57c
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a83e:	2100      	movs	r1, #0
                distortionMode = !distortionMode;
 801a840:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801a844:	7519      	strb	r1, [r3, #20]
                distortionMode = !distortionMode;
 801a846:	7813      	ldrb	r3, [r2, #0]
 801a848:	fab3 f383 	clz	r3, r3
 801a84c:	095b      	lsrs	r3, r3, #5
                setLED_A(distortionMode);
 801a84e:	4618      	mov	r0, r3
                distortionMode = !distortionMode;
 801a850:	7013      	strb	r3, [r2, #0]
                setLED_A(distortionMode);
 801a852:	f7fb f84b 	bl	80158ec <setLED_A>
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a856:	2000      	movs	r0, #0
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a858:	f642 5310 	movw	r3, #11536	; 0x2d10
 801a85c:	eef3 5a0e 	vmov.f32	s11, #62	; 0x41f00000  30.0
 801a860:	f248 7494 	movw	r4, #34708	; 0x8794
 801a864:	f2c2 0300 	movt	r3, #8192	; 0x2000
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a868:	4601      	mov	r1, r0
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a86a:	f2c4 2008 	movt	r0, #16904	; 0x4208
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a86e:	eefa 6a0e 	vmov.f32	s13, #174	; 0xc1700000 -15.0
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a872:	eebb 7a01 	vmov.f32	s14, #177	; 0xc1880000 -17.0
 801a876:	ed93 6aca 	vldr	s12, [r3, #808]	; 0x328
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a87a:	ed93 5ac9 	vldr	s10, [r3, #804]	; 0x324
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a87e:	ee07 0a90 	vmov	s15, r0
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a882:	460a      	mov	r2, r1
 801a884:	f2c4 219a 	movt	r1, #17050	; 0x429a
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a888:	eea6 7a27 	vfma.f32	s14, s12, s15
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a88c:	ed93 6acb 	vldr	s12, [r3, #812]	; 0x32c
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a890:	eee5 6a25 	vfma.f32	s13, s10, s11
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a894:	f2c4 2228 	movt	r2, #16936	; 0x4228
 801a898:	ee07 1a90 	vmov	s15, r1
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a89c:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a8a0:	ee00 2a10 	vmov	s0, r2
 801a8a4:	eea6 0a27 	vfma.f32	s0, s12, s15
            displayValues[2] = (presetKnobValues[Distortion][2] * 34.0f) - 17.0f;
 801a8a8:	ed84 7a02 	vstr	s14, [r4, #8]
            displayValues[1] = (presetKnobValues[Distortion][1] * 30.0f) - 15.0f;
 801a8ac:	edc4 6a01 	vstr	s13, [r4, #4]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a8b0:	f00d f9fe 	bl	8027cb0 <faster_mtof>
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
 801a8b4:	edd4 7a01 	vldr	s15, [r4, #4]
            displayValues[3] = faster_mtof(presetKnobValues[Distortion][3] * 77.0f + 42.0f);
 801a8b8:	ed84 0a03 	vstr	s0, [r4, #12]
            tVZFilter_setGain(&shelf1, fastdbtoa(-1.0f * displayValues[1]));
 801a8bc:	eeb1 0a67 	vneg.f32	s0, s15
 801a8c0:	f00d fa4e 	bl	8027d60 <fastdbtoa>
 801a8c4:	f247 40fc 	movw	r0, #29948	; 0x74fc
 801a8c8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a8cc:	f00c fd3c 	bl	8027348 <tVZFilter_setGain>
            tVZFilter_setGain(&shelf2, fastdbtoa(displayValues[1]));
 801a8d0:	ed94 0a01 	vldr	s0, [r4, #4]
 801a8d4:	f00d fa44 	bl	8027d60 <fastdbtoa>
 801a8d8:	f247 4024 	movw	r0, #29732	; 0x7424
 801a8dc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a8e0:	f00c fd32 	bl	8027348 <tVZFilter_setGain>
            tVZFilter_setFreq(&bell1, displayValues[3]);
 801a8e4:	f247 303c 	movw	r0, #29500	; 0x733c
 801a8e8:	ed94 0a03 	vldr	s0, [r4, #12]
 801a8ec:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a8f0:	f00c f934 	bl	8026b5c <tVZFilter_setFreq>
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
 801a8f4:	ed94 0a02 	vldr	s0, [r4, #8]
 801a8f8:	f00d fa32 	bl	8027d60 <fastdbtoa>
 801a8fc:	f247 303c 	movw	r0, #29500	; 0x733c
        }
 801a900:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            tVZFilter_setGain(&bell1, fastdbtoa(displayValues[2]));
 801a904:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a908:	f00c bd1e 	b.w	8027348 <tVZFilter_setGain>

0801a90c <SFXDistortionTick>:
        {
 801a90c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 801a910:	f642 5610 	movw	r6, #11536	; 0x2d10
 801a914:	eeb3 7a04 	vmov.f32	s14, #52	; 0x41a00000  20.0
 801a918:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801a91c:	f248 7394 	movw	r3, #34708	; 0x8794
 801a920:	f2c2 0600 	movt	r6, #8192	; 0x2000
            for (int i = 0; i < distOS_ratio; i++)
 801a924:	f240 2734 	movw	r7, #564	; 0x234
        {
 801a928:	4683      	mov	fp, r0
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801a92a:	f247 2168 	movw	r1, #29288	; 0x7268
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 801a92e:	edd6 6ac8 	vldr	s13, [r6, #800]	; 0x320
 801a932:	f2c2 0301 	movt	r3, #8193	; 0x2001
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
 801a936:	f8d6 2330 	ldr.w	r2, [r6, #816]	; 0x330
            for (int i = 0; i < distOS_ratio; i++)
 801a93a:	f2c2 0700 	movt	r7, #8192	; 0x2000
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 801a93e:	eee6 7a87 	vfma.f32	s15, s13, s14
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801a942:	f2c2 0101 	movt	r1, #8193	; 0x2001
        {
 801a946:	ed2d 8b02 	vpush	{d8}
            float sample = input[1];
 801a94a:	ed90 0a01 	vldr	s0, [r0, #4]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801a94e:	f248 1048 	movw	r0, #33096	; 0x8148
            displayValues[4] = presetKnobValues[Distortion][4]; // 15.0f
 801a952:	611a      	str	r2, [r3, #16]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801a954:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a958:	ee27 0a80 	vmul.f32	s0, s15, s0
            displayValues[0] = ((presetKnobValues[Distortion][0] * 20.0f) + 1.0f); // 15.0f
 801a95c:	edc3 7a00 	vstr	s15, [r3]
            tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801a960:	f008 fd54 	bl	802340c <tOversampler_upsample>
            for (int i = 0; i < distOS_ratio; i++)
 801a964:	683b      	ldr	r3, [r7, #0]
 801a966:	2b00      	cmp	r3, #0
 801a968:	dd3d      	ble.n	801a9e6 <SFXDistortionTick+0xda>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a96a:	f243 3333 	movw	r3, #13107	; 0x3333
 801a96e:	f247 2468 	movw	r4, #29288	; 0x7268
 801a972:	f240 5a7c 	movw	sl, #1404	; 0x57c
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 801a976:	f247 49fc 	movw	r9, #29948	; 0x74fc
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a97a:	f6c3 7373 	movt	r3, #16243	; 0x3f73
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 801a97e:	f247 4824 	movw	r8, #29732	; 0x7424
 801a982:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801a986:	f2c2 0a00 	movt	sl, #8192	; 0x2000
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a98a:	ee08 3a10 	vmov	s16, r3
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 801a98e:	f2c2 0901 	movt	r9, #8193	; 0x2001
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 801a992:	f2c2 0801 	movt	r8, #8193	; 0x2001
            for (int i = 0; i < distOS_ratio; i++)
 801a996:	2500      	movs	r5, #0
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
 801a998:	f89a 3000 	ldrb.w	r3, [sl]
 801a99c:	ecb4 0a01 	vldmia	r4!, {s0}
 801a9a0:	bb9b      	cbnz	r3, 801aa0a <SFXDistortionTick+0xfe>
                else oversamplerArray[i] = tanhf(oversamplerArray[i]);
 801a9a2:	f010 fddf 	bl	802b564 <tanhf>
 801a9a6:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 801a9aa:	4648      	mov	r0, r9
            for (int i = 0; i < distOS_ratio; i++)
 801a9ac:	3501      	adds	r5, #1
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 801a9ae:	f00c f865 	bl	8026a7c <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 801a9b2:	4640      	mov	r0, r8
                oversamplerArray[i] = tVZFilter_tick(&shelf1, oversamplerArray[i]); //put it through the low shelf
 801a9b4:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 801a9b8:	f00c f860 	bl	8026a7c <tVZFilter_tick>
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
 801a9bc:	f247 303c 	movw	r0, #29500	; 0x733c
                oversamplerArray[i] = tVZFilter_tick(&shelf2, oversamplerArray[i]); // now put that result through the high shelf
 801a9c0:	ed04 0a01 	vstr	s0, [r4, #-4]
                oversamplerArray[i] = tVZFilter_tick(&bell1, oversamplerArray[i]); // now add a bell (or peaking eq) filter
 801a9c4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a9c8:	f00c f858 	bl	8026a7c <tVZFilter_tick>
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a9cc:	edd6 7acc 	vldr	s15, [r6, #816]	; 0x330
 801a9d0:	ee20 0a27 	vmul.f32	s0, s0, s15
 801a9d4:	f010 fdc6 	bl	802b564 <tanhf>
            for (int i = 0; i < distOS_ratio; i++)
 801a9d8:	683b      	ldr	r3, [r7, #0]
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a9da:	ee20 0a08 	vmul.f32	s0, s0, s16
            for (int i = 0; i < distOS_ratio; i++)
 801a9de:	42ab      	cmp	r3, r5
                oversamplerArray[i] = tanhf(oversamplerArray[i] * presetKnobValues[Distortion][4]) * 0.95f;
 801a9e0:	ed04 0a01 	vstr	s0, [r4, #-4]
            for (int i = 0; i < distOS_ratio; i++)
 801a9e4:	dcd8      	bgt.n	801a998 <SFXDistortionTick+0x8c>
            sample = tOversampler_downsample(&oversampler, oversamplerArray);
 801a9e6:	f247 2168 	movw	r1, #29288	; 0x7268
 801a9ea:	f248 1048 	movw	r0, #33096	; 0x8148
 801a9ee:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801a9f2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801a9f6:	f008 fd53 	bl	80234a0 <tOversampler_downsample>
            input[0] = sample;
 801a9fa:	ed8b 0a00 	vstr	s0, [fp]
            input[1] = sample;
 801a9fe:	ed8b 0a01 	vstr	s0, [fp, #4]
        }
 801aa02:	ecbd 8b02 	vpop	{d8}
 801aa06:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (distortionMode > 0) oversamplerArray[i] = LEAF_shaper(oversamplerArray[i], 1.0f);
 801aa0a:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 801aa0e:	f00c ff71 	bl	80278f4 <LEAF_shaper>
 801aa12:	ed04 0a01 	vstr	s0, [r4, #-4]
 801aa16:	e7c8      	b.n	801a9aa <SFXDistortionTick+0x9e>

0801aa18 <SFXDistortionFree>:
            tOversampler_free(&oversampler);
 801aa18:	f248 1048 	movw	r0, #33096	; 0x8148
        {
 801aa1c:	b508      	push	{r3, lr}
            tOversampler_free(&oversampler);
 801aa1e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa22:	f008 fc4f 	bl	80232c4 <tOversampler_free>
            tVZFilter_free(&shelf1);
 801aa26:	f247 40fc 	movw	r0, #29948	; 0x74fc
 801aa2a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa2e:	f00c f817 	bl	8026a60 <tVZFilter_free>
            tVZFilter_free(&shelf2);
 801aa32:	f247 4024 	movw	r0, #29732	; 0x7424
 801aa36:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa3a:	f00c f811 	bl	8026a60 <tVZFilter_free>
            tVZFilter_free(&bell1);
 801aa3e:	f247 303c 	movw	r0, #29500	; 0x733c
        }
 801aa42:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tVZFilter_free(&bell1);
 801aa46:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa4a:	f00c b809 	b.w	8026a60 <tVZFilter_free>
 801aa4e:	bf00      	nop

0801aa50 <SFXWaveFolderAlloc>:
        {
 801aa50:	b538      	push	{r3, r4, r5, lr}
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
 801aa52:	f248 24f8 	movw	r4, #33528	; 0x82f8
            leaf.clearOnAllocation = 1;
 801aa56:	f249 45a0 	movw	r5, #38048	; 0x94a0
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
 801aa5a:	f242 7050 	movw	r0, #10064	; 0x2750
            leaf.clearOnAllocation = 1;
 801aa5e:	2301      	movs	r3, #1
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
 801aa60:	f2c2 0401 	movt	r4, #8193	; 0x2001
            leaf.clearOnAllocation = 1;
 801aa64:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
 801aa68:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801aa6c:	4621      	mov	r1, r4
            leaf.clearOnAllocation = 1;
 801aa6e:	616b      	str	r3, [r5, #20]
            tLockhartWavefolder_initToPool(&wavefolder1, &smallPool);
 801aa70:	f008 fd4c 	bl	802350c <tLockhartWavefolder_initToPool>
            tLockhartWavefolder_initToPool(&wavefolder2, &smallPool);
 801aa74:	f247 4020 	movw	r0, #29728	; 0x7420
 801aa78:	4621      	mov	r1, r4
 801aa7a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa7e:	f008 fd45 	bl	802350c <tLockhartWavefolder_initToPool>
            tHighpass_initToPool(&wfHP, 10.0f, &smallPool);
 801aa82:	f247 2064 	movw	r0, #29284	; 0x7264
 801aa86:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801aa8a:	4621      	mov	r1, r4
 801aa8c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aa90:	f00b fd9a 	bl	80265c8 <tHighpass_initToPool>
            tOversampler_initToPool(&oversampler, 2, FALSE, &smallPool);
 801aa94:	f248 1048 	movw	r0, #33096	; 0x8148
 801aa98:	4623      	mov	r3, r4
 801aa9a:	2200      	movs	r2, #0
 801aa9c:	2102      	movs	r1, #2
 801aa9e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aaa2:	f008 fbbb 	bl	802321c <tOversampler_initToPool>
            setLED_A(foldMode);
 801aaa6:	f240 538c 	movw	r3, #1420	; 0x58c
 801aaaa:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801aaae:	7818      	ldrb	r0, [r3, #0]
 801aab0:	f7fa ff1c 	bl	80158ec <setLED_A>
            leaf.clearOnAllocation = 0;
 801aab4:	2300      	movs	r3, #0
 801aab6:	616b      	str	r3, [r5, #20]
        }
 801aab8:	bd38      	pop	{r3, r4, r5, pc}
 801aaba:	bf00      	nop

0801aabc <SFXWaveFolderFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 801aabc:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801aac0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801aac4:	7d1a      	ldrb	r2, [r3, #20]
 801aac6:	b902      	cbnz	r2, 801aaca <SFXWaveFolderFrame+0xe>
        }
 801aac8:	4770      	bx	lr
                foldMode = !foldMode;
 801aaca:	f240 528c 	movw	r2, #1420	; 0x58c
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801aace:	2100      	movs	r1, #0
                foldMode = !foldMode;
 801aad0:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801aad4:	7519      	strb	r1, [r3, #20]
                foldMode = !foldMode;
 801aad6:	6813      	ldr	r3, [r2, #0]
 801aad8:	fab3 f383 	clz	r3, r3
 801aadc:	095b      	lsrs	r3, r3, #5
                setLED_A(foldMode);
 801aade:	4618      	mov	r0, r3
                foldMode = !foldMode;
 801aae0:	6013      	str	r3, [r2, #0]
                setLED_A(foldMode);
 801aae2:	f7fa bf03 	b.w	80158ec <setLED_A>
 801aae6:	bf00      	nop

0801aae8 <SFXWaveFolderTick>:
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801aae8:	f642 5310 	movw	r3, #11536	; 0x2d10
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 801aaec:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801aaf0:	eeb1 6a00 	vmov.f32	s12, #16	; 0x40800000  4.0
            if (foldMode == 0)
 801aaf4:	f240 528c 	movw	r2, #1420	; 0x58c
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801aaf8:	f2c2 0300 	movt	r3, #8192	; 0x2000
            if (foldMode == 0)
 801aafc:	f2c2 0200 	movt	r2, #8192	; 0x2000
        {
 801ab00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801ab04:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801ab08:	ed93 0ae1 	vldr	s0, [r3, #900]	; 0x384
 801ab0c:	f248 7494 	movw	r4, #34708	; 0x8794
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 801ab10:	ed93 7ae3 	vldr	s14, [r3, #908]	; 0x38c
        {
 801ab14:	4606      	mov	r6, r0
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 801ab16:	edd3 7ae2 	vldr	s15, [r3, #904]	; 0x388
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801ab1a:	ee20 0a06 	vmul.f32	s0, s0, s12
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 801ab1e:	ee37 7a66 	vsub.f32	s14, s14, s13
            float sample = input[1];
 801ab22:	ed90 8a01 	vldr	s16, [r0, #4]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 801ab26:	ee77 7ae6 	vsub.f32	s15, s15, s13
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801ab2a:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[3] = presetKnobValues[Wavefolder][3];
 801ab2e:	f8d3 1390 	ldr.w	r1, [r3, #912]	; 0x390
            sample = sample * gain;
 801ab32:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (foldMode == 0)
 801ab36:	6813      	ldr	r3, [r2, #0]
            displayValues[0] = (presetKnobValues[Wavefolder][0] * 4.0f);
 801ab38:	ed84 0a00 	vstr	s0, [r4]
            displayValues[2] = presetKnobValues[Wavefolder][2] - 0.5f;
 801ab3c:	ed84 7a02 	vstr	s14, [r4, #8]
            displayValues[3] = presetKnobValues[Wavefolder][3];
 801ab40:	60e1      	str	r1, [r4, #12]
            displayValues[1] = presetKnobValues[Wavefolder][1] - 0.5f;
 801ab42:	edc4 7a01 	vstr	s15, [r4, #4]
            if (foldMode == 0)
 801ab46:	2b00      	cmp	r3, #0
 801ab48:	d143      	bne.n	801abd2 <SFXWaveFolderTick+0xea>
 801ab4a:	f247 2568 	movw	r5, #29288	; 0x7268
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801ab4e:	f248 1048 	movw	r0, #33096	; 0x8148
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801ab52:	f242 7750 	movw	r7, #10064	; 0x2750
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801ab56:	eeb0 0a48 	vmov.f32	s0, s16
 801ab5a:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801ab5e:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801ab62:	f2c2 0700 	movt	r7, #8192	; 0x2000
                tOversampler_upsample(&oversampler, sample, oversamplerArray);
 801ab66:	4629      	mov	r1, r5
 801ab68:	f105 0808 	add.w	r8, r5, #8
 801ab6c:	f008 fc4e 	bl	802340c <tOversampler_upsample>
                    oversamplerArray[i] = sample + displayValues[1];
 801ab70:	edd4 7a01 	vldr	s15, [r4, #4]
                    oversamplerArray[i] *= displayValues[0];
 801ab74:	ed94 0a00 	vldr	s0, [r4]
                    oversamplerArray[i] = sample + displayValues[1];
 801ab78:	ee78 7a27 	vadd.f32	s15, s16, s15
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 801ab7c:	ee27 0a80 	vmul.f32	s0, s15, s0
 801ab80:	f010 fcf0 	bl	802b564 <tanhf>
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801ab84:	4638      	mov	r0, r7
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 801ab86:	ed85 0a00 	vstr	s0, [r5]
                    oversamplerArray[i] = tLockhartWavefolder_tick(&wavefolder1, oversamplerArray[i]);
 801ab8a:	f008 fd6d 	bl	8023668 <tLockhartWavefolder_tick>
                    oversamplerArray[i] = tanhf(oversamplerArray[i]);
 801ab8e:	f010 fce9 	bl	802b564 <tanhf>
 801ab92:	eca5 0a01 	vstmia	r5!, {s0}
                for (int i = 0; i < 2; i++)
 801ab96:	4545      	cmp	r5, r8
 801ab98:	d1ea      	bne.n	801ab70 <SFXWaveFolderTick+0x88>
                sample = tHighpass_tick(&wfHP, tOversampler_downsample(&oversampler, oversamplerArray)) * displayValues[3];
 801ab9a:	f247 2168 	movw	r1, #29288	; 0x7268
 801ab9e:	f248 1048 	movw	r0, #33096	; 0x8148
 801aba2:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801aba6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801abaa:	f008 fc79 	bl	80234a0 <tOversampler_downsample>
                sample = tHighpass_tick(&wfHP, sample) * displayValues[3];
 801abae:	f247 2064 	movw	r0, #29284	; 0x7264
 801abb2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801abb6:	f00b fd3d 	bl	8026634 <tHighpass_tick>
 801abba:	edd4 7a03 	vldr	s15, [r4, #12]
 801abbe:	ee20 0a27 	vmul.f32	s0, s0, s15
                input[0] = sample;
 801abc2:	ed86 0a00 	vstr	s0, [r6]
                input[1] = sample;
 801abc6:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 801abca:	ecbd 8b02 	vpop	{d8}
 801abce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                sample = sample + displayValues[1];
 801abd2:	ee77 7a88 	vadd.f32	s15, s15, s16
                sample = LEAF_tanh(sample);
 801abd6:	ee20 0a27 	vmul.f32	s0, s0, s15
 801abda:	f00c ff3f 	bl	8027a5c <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder1, sample);
 801abde:	f242 7050 	movw	r0, #10064	; 0x2750
 801abe2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801abe6:	f008 fd3f 	bl	8023668 <tLockhartWavefolder_tick>
                sample = sample + displayValues[2];
 801abea:	edd4 7a02 	vldr	s15, [r4, #8]
                sample *= displayValues[0];
 801abee:	ed94 7a00 	vldr	s14, [r4]
                sample = sample + displayValues[2];
 801abf2:	ee30 0a27 	vadd.f32	s0, s0, s15
                sample = LEAF_tanh(sample);
 801abf6:	ee20 0a07 	vmul.f32	s0, s0, s14
 801abfa:	f00c ff2f 	bl	8027a5c <LEAF_tanh>
                sample = tLockhartWavefolder_tick(&wavefolder2, sample);
 801abfe:	f247 4020 	movw	r0, #29728	; 0x7420
 801ac02:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ac06:	f008 fd2f 	bl	8023668 <tLockhartWavefolder_tick>
                sample = tOversampler_tick(&oversampler, sample, oversampleBuf, &LEAF_tanh);
 801ac0a:	f647 225d 	movw	r2, #31325	; 0x7a5d
 801ac0e:	f248 21fc 	movw	r1, #33532	; 0x82fc
 801ac12:	f248 1048 	movw	r0, #33096	; 0x8148
 801ac16:	f6c0 0202 	movt	r2, #2050	; 0x802
 801ac1a:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801ac1e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ac22:	f008 fb5f 	bl	80232e4 <tOversampler_tick>
 801ac26:	e7c2      	b.n	801abae <SFXWaveFolderTick+0xc6>

0801ac28 <SFXWaveFolderFree>:
            tLockhartWavefolder_free(&wavefolder1);
 801ac28:	f242 7050 	movw	r0, #10064	; 0x2750
        {
 801ac2c:	b508      	push	{r3, lr}
            tLockhartWavefolder_free(&wavefolder1);
 801ac2e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ac32:	f008 fd15 	bl	8023660 <tLockhartWavefolder_free>
            tLockhartWavefolder_free(&wavefolder2);
 801ac36:	f247 4020 	movw	r0, #29728	; 0x7420
 801ac3a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ac3e:	f008 fd0f 	bl	8023660 <tLockhartWavefolder_free>
            tHighpass_free(&wfHP);
 801ac42:	f247 2064 	movw	r0, #29284	; 0x7264
 801ac46:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ac4a:	f00b fcdf 	bl	802660c <tHighpass_free>
            tOversampler_free(&oversampler);
 801ac4e:	f248 1048 	movw	r0, #33096	; 0x8148
        }
 801ac52:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tOversampler_free(&oversampler);
 801ac56:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ac5a:	f008 bb33 	b.w	80232c4 <tOversampler_free>
 801ac5e:	bf00      	nop

0801ac60 <SFXBitcrusherAlloc>:
        {
 801ac60:	b510      	push	{r4, lr}
            tCrusher_initToPool(&crush, &smallPool);
 801ac62:	f248 24f8 	movw	r4, #33528	; 0x82f8
 801ac66:	f243 4060 	movw	r0, #13408	; 0x3460
 801ac6a:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801ac6e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ac72:	4621      	mov	r1, r4
 801ac74:	f008 fe10 	bl	8023898 <tCrusher_initToPool>
            tCrusher_initToPool(&crush2, &smallPool);
 801ac78:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801ac7c:	4621      	mov	r1, r4
 801ac7e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ac82:	f008 fe09 	bl	8023898 <tCrusher_initToPool>
            setLED_A(crusherStereo);
 801ac86:	f240 5368 	movw	r3, #1384	; 0x568
 801ac8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
        }
 801ac8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            setLED_A(crusherStereo);
 801ac92:	7818      	ldrb	r0, [r3, #0]
 801ac94:	f7fa be2a 	b.w	80158ec <setLED_A>

0801ac98 <SFXBitcrusherFrame>:
            if (buttonActionsSFX[ButtonA][ActionPress])
 801ac98:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801ac9c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801aca0:	7d1a      	ldrb	r2, [r3, #20]
 801aca2:	b902      	cbnz	r2, 801aca6 <SFXBitcrusherFrame+0xe>
        }
 801aca4:	4770      	bx	lr
                crusherStereo = !crusherStereo;
 801aca6:	f240 5268 	movw	r2, #1384	; 0x568
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801acaa:	2100      	movs	r1, #0
                crusherStereo = !crusherStereo;
 801acac:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801acb0:	7519      	strb	r1, [r3, #20]
                crusherStereo = !crusherStereo;
 801acb2:	6813      	ldr	r3, [r2, #0]
 801acb4:	fab3 f383 	clz	r3, r3
 801acb8:	095b      	lsrs	r3, r3, #5
                setLED_A(crusherStereo);
 801acba:	4618      	mov	r0, r3
                crusherStereo = !crusherStereo;
 801acbc:	6013      	str	r3, [r2, #0]
                setLED_A(crusherStereo);
 801acbe:	f7fa be15 	b.w	80158ec <setLED_A>
 801acc2:	bf00      	nop

0801acc4 <SFXBitcrusherTick>:
        {
 801acc4:	b570      	push	{r4, r5, r6, lr}
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801acc6:	f247 02a4 	movw	r2, #28836	; 0x70a4
 801acca:	f642 5510 	movw	r5, #11536	; 0x2d10
 801acce:	f24d 730a 	movw	r3, #55050	; 0xd70a
 801acd2:	f248 7494 	movw	r4, #34708	; 0x8794
 801acd6:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801acda:	f6c3 727d 	movt	r2, #16253	; 0x3f7d
 801acde:	f6c3 4323 	movt	r3, #15395	; 0x3c23
        {
 801ace2:	4606      	mov	r6, r0
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801ace4:	edd5 6afa 	vldr	s13, [r5, #1000]	; 0x3e8
 801ace8:	ee07 2a10 	vmov	s14, r2
 801acec:	ee07 3a90 	vmov	s15, r3
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 801acf0:	f243 4060 	movw	r0, #13408	; 0x3460
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801acf4:	f2c2 0401 	movt	r4, #8193	; 0x2001
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 801acf8:	eeb0 0a66 	vmov.f32	s0, s13
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801acfc:	eee6 7a87 	vfma.f32	s15, s13, s14
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 801ad00:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 801ad04:	ed2d 8b02 	vpush	{d8}
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 801ad08:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
            displayValues[0] = (presetKnobValues[BitCrusher][0] * 0.99f )+ 0.01f;
 801ad0c:	edc4 7a00 	vstr	s15, [r4]
            tCrusher_setQuality (&crush, presetKnobValues[BitCrusher][0]);
 801ad10:	f008 fe50 	bl	80239b4 <tCrusher_setQuality>
            tCrusher_setQuality (&crush2, presetKnobValues[BitCrusher][0]);
 801ad14:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801ad18:	ed95 0afa 	vldr	s0, [r5, #1000]	; 0x3e8
 801ad1c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ad20:	f008 fe48 	bl	80239b4 <tCrusher_setQuality>
            displayValues[1] = presetKnobValues[BitCrusher][1];
 801ad24:	edd5 7afb 	vldr	s15, [r5, #1004]	; 0x3ec
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 801ad28:	f243 4060 	movw	r0, #13408	; 0x3460
 801ad2c:	ee27 0a88 	vmul.f32	s0, s15, s16
            displayValues[1] = presetKnobValues[BitCrusher][1];
 801ad30:	edc4 7a01 	vstr	s15, [r4, #4]
            tCrusher_setSamplingRatio (&crush, presetKnobValues[BitCrusher][1] * 0.5f);
 801ad34:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ad38:	f008 fe6e 	bl	8023a18 <tCrusher_setSamplingRatio>
            tCrusher_setSamplingRatio (&crush2, presetKnobValues[BitCrusher][1] * 0.5f);
 801ad3c:	ed95 0afb 	vldr	s0, [r5, #1004]	; 0x3ec
 801ad40:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801ad44:	ee20 0a08 	vmul.f32	s0, s0, s16
 801ad48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ad4c:	f008 fe64 	bl	8023a18 <tCrusher_setSamplingRatio>
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 801ad50:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801ad54:	edd5 7afc 	vldr	s15, [r5, #1008]	; 0x3f0
            tCrusher_setRound (&crush, displayValues[2]);
 801ad58:	f243 4060 	movw	r0, #13408	; 0x3460
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 801ad5c:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
            tCrusher_setRound (&crush, displayValues[2]);
 801ad60:	f2c2 0000 	movt	r0, #8192	; 0x2000
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 801ad64:	ee08 3a10 	vmov	s16, r3
 801ad68:	ee67 7a88 	vmul.f32	s15, s15, s16
            tCrusher_setRound (&crush, displayValues[2]);
 801ad6c:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[2] = presetKnobValues[BitCrusher][2] * 0.1f;
 801ad70:	edc4 7a02 	vstr	s15, [r4, #8]
            tCrusher_setRound (&crush, displayValues[2]);
 801ad74:	f008 fe4a 	bl	8023a0c <tCrusher_setRound>
            tCrusher_setRound (&crush2, displayValues[2]);
 801ad78:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801ad7c:	ed94 0a02 	vldr	s0, [r4, #8]
 801ad80:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ad84:	f008 fe42 	bl	8023a0c <tCrusher_setRound>
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
 801ad88:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 801ad8c:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
 801ad90:	f243 4060 	movw	r0, #13408	; 0x3460
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
 801ad94:	ee60 7a27 	vmul.f32	s15, s0, s15
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
 801ad98:	f2c2 0000 	movt	r0, #8192	; 0x2000
            displayValues[3] = (uint32_t) (presetKnobValues[BitCrusher][3] * 8.0f);
 801ad9c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 801ada0:	eef8 7a67 	vcvt.f32.u32	s15, s15
 801ada4:	edc4 7a03 	vstr	s15, [r4, #12]
            tCrusher_setOperation (&crush, presetKnobValues[BitCrusher][3]);
 801ada8:	f008 fdfa 	bl	80239a0 <tCrusher_setOperation>
            tCrusher_setOperation (&crush2, presetKnobValues[BitCrusher][3]);
 801adac:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801adb0:	ed95 0afd 	vldr	s0, [r5, #1012]	; 0x3f4
 801adb4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801adb8:	f008 fdf2 	bl	80239a0 <tCrusher_setOperation>
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801adbc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801adc0:	eeb1 7a04 	vmov.f32	s14, #20	; 0x40a00000  5.0
 801adc4:	ed95 6aff 	vldr	s12, [r5, #1020]	; 0x3fc
            if (displayValues[0] < 0.1f)
 801adc8:	edd4 6a00 	vldr	s13, [r4]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801adcc:	eef0 5a67 	vmov.f32	s11, s15
            displayValues[4] = presetKnobValues[BitCrusher][4];
 801add0:	f8d5 33f8 	ldr.w	r3, [r5, #1016]	; 0x3f8
            if (displayValues[0] < 0.1f)
 801add4:	eef4 6ac8 	vcmpe.f32	s13, s16
            displayValues[4] = presetKnobValues[BitCrusher][4];
 801add8:	6123      	str	r3, [r4, #16]
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801adda:	eee6 5a07 	vfma.f32	s11, s12, s14
            if (displayValues[0] < 0.1f)
 801adde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[5] = (presetKnobValues[BitCrusher][5] * 5.0f) + 1.0f;
 801ade2:	eeb0 7a65 	vmov.f32	s14, s11
 801ade6:	edc4 5a05 	vstr	s11, [r4, #20]
            if (displayValues[0] < 0.1f)
 801adea:	d424      	bmi.n	801ae36 <SFXBitcrusherTick+0x172>
                volumeComp = (1.0f / (displayValues[3] + 1.0f));
 801adec:	edd4 6a03 	vldr	s13, [r4, #12]
 801adf0:	ee76 6aa7 	vadd.f32	s13, s13, s15
 801adf4:	eec7 8aa6 	vdiv.f32	s17, s15, s13
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 801adf8:	ed96 0a01 	vldr	s0, [r6, #4]
 801adfc:	f243 4060 	movw	r0, #13408	; 0x3460
 801ae00:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ae04:	ee27 0a00 	vmul.f32	s0, s14, s0
 801ae08:	f008 fd88 	bl	802391c <tCrusher_tick>
 801ae0c:	f010 fbaa 	bl	802b564 <tanhf>
            if (crusherStereo)
 801ae10:	f240 5368 	movw	r3, #1384	; 0x568
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 801ae14:	ee20 0a28 	vmul.f32	s0, s0, s17
 801ae18:	ed94 8a04 	vldr	s16, [r4, #16]
            if (crusherStereo)
 801ae1c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ae20:	681b      	ldr	r3, [r3, #0]
            sample = tanhf(tCrusher_tick(&crush, input[1] * displayValues[5])) * displayValues[4] * volumeComp;
 801ae22:	ee20 8a08 	vmul.f32	s16, s0, s16
            if (crusherStereo)
 801ae26:	b94b      	cbnz	r3, 801ae3c <SFXBitcrusherTick+0x178>
                input[1] = sample;
 801ae28:	ed86 8a01 	vstr	s16, [r6, #4]
            input[0] = sample;
 801ae2c:	ed86 8a00 	vstr	s16, [r6]
        }
 801ae30:	ecbd 8b02 	vpop	{d8}
 801ae34:	bd70      	pop	{r4, r5, r6, pc}
                volumeComp = 1.0f;
 801ae36:	eef0 8a67 	vmov.f32	s17, s15
 801ae3a:	e7dd      	b.n	801adf8 <SFXBitcrusherTick+0x134>
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
 801ae3c:	edd4 7a05 	vldr	s15, [r4, #20]
 801ae40:	f642 202c 	movw	r0, #10796	; 0x2a2c
 801ae44:	ed96 0a00 	vldr	s0, [r6]
 801ae48:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ae4c:	ee20 0a27 	vmul.f32	s0, s0, s15
 801ae50:	f008 fd64 	bl	802391c <tCrusher_tick>
 801ae54:	f010 fb86 	bl	802b564 <tanhf>
 801ae58:	edd4 7a04 	vldr	s15, [r4, #16]
            input[0] = sample;
 801ae5c:	ed86 8a00 	vstr	s16, [r6]
                input[1] = tanhf(tCrusher_tick(&crush2, input[0] * displayValues[5])) * displayValues[4] * volumeComp;
 801ae60:	ee68 8aa7 	vmul.f32	s17, s17, s15
 801ae64:	ee68 8a80 	vmul.f32	s17, s17, s0
 801ae68:	edc6 8a01 	vstr	s17, [r6, #4]
        }
 801ae6c:	ecbd 8b02 	vpop	{d8}
 801ae70:	bd70      	pop	{r4, r5, r6, pc}
 801ae72:	bf00      	nop

0801ae74 <SFXBitcrusherFree>:
            tCrusher_free(&crush);
 801ae74:	f243 4060 	movw	r0, #13408	; 0x3460
        {
 801ae78:	b508      	push	{r3, lr}
            tCrusher_free(&crush);
 801ae7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ae7e:	f008 fd41 	bl	8023904 <tCrusher_free>
            tCrusher_free(&crush2);
 801ae82:	f642 202c 	movw	r0, #10796	; 0x2a2c
        }
 801ae86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tCrusher_free(&crush2);
 801ae8a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ae8e:	f008 bd39 	b.w	8023904 <tCrusher_free>
 801ae92:	bf00      	nop

0801ae94 <SFXDelayAlloc>:
            tTapeDelay_init(&delay, 2000, 30000);
 801ae94:	2300      	movs	r3, #0
 801ae96:	f247 707c 	movw	r0, #30588	; 0x777c
 801ae9a:	f247 5130 	movw	r1, #30000	; 0x7530
 801ae9e:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
 801aea2:	f2c2 0001 	movt	r0, #8193	; 0x2001
        {
 801aea6:	b570      	push	{r4, r5, r6, lr}
            leaf.clearOnAllocation = 1;
 801aea8:	f249 44a0 	movw	r4, #38048	; 0x94a0
 801aeac:	2601      	movs	r6, #1
            tTapeDelay_init(&delay, 2000, 30000);
 801aeae:	ee00 3a10 	vmov	s0, r3
            delayShaper = 0;
 801aeb2:	2500      	movs	r5, #0
            leaf.clearOnAllocation = 1;
 801aeb4:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 801aeb8:	ed2d 8b02 	vpush	{d8}
            leaf.clearOnAllocation = 1;
 801aebc:	6166      	str	r6, [r4, #20]
            tTapeDelay_init(&delay, 2000, 30000);
 801aebe:	ee08 3a10 	vmov	s16, r3
 801aec2:	f008 f86b 	bl	8022f9c <tTapeDelay_init>
            tTapeDelay_init(&delay2, 2000, 30000);
 801aec6:	f243 6058 	movw	r0, #13912	; 0x3658
 801aeca:	eeb0 0a48 	vmov.f32	s0, s16
 801aece:	f247 5130 	movw	r1, #30000	; 0x7530
 801aed2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801aed6:	f008 f861 	bl	8022f9c <tTapeDelay_init>
            tSVF_init(&delayLP, SVFTypeLowpass, 16000.f, .7f);
 801aeda:	f243 3333 	movw	r3, #13107	; 0x3333
 801aede:	462a      	mov	r2, r5
 801aee0:	f247 6098 	movw	r0, #30360	; 0x7698
 801aee4:	f6c3 7333 	movt	r3, #16179	; 0x3f33
 801aee8:	4631      	mov	r1, r6
 801aeea:	f2c4 627a 	movt	r2, #18042	; 0x467a
 801aeee:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801aef2:	ee00 3a90 	vmov	s1, r3
 801aef6:	ee08 3a10 	vmov	s16, r3
 801aefa:	ee00 2a10 	vmov	s0, r2
 801aefe:	ee08 2a90 	vmov	s17, r2
 801af02:	f00b f985 	bl	8026210 <tSVF_init>
            tSVF_init(&delayHP, SVFTypeHighpass, 20.f, .7f);
 801af06:	f247 20d8 	movw	r0, #29400	; 0x72d8
 801af0a:	eef0 0a48 	vmov.f32	s1, s16
 801af0e:	4629      	mov	r1, r5
 801af10:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801af14:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801af18:	f00b f97a 	bl	8026210 <tSVF_init>
            tSVF_init(&delayLP2, SVFTypeLowpass, 16000.f, .7f);
 801af1c:	f247 6010 	movw	r0, #30224	; 0x7610
 801af20:	eef0 0a48 	vmov.f32	s1, s16
 801af24:	4631      	mov	r1, r6
 801af26:	eeb0 0a68 	vmov.f32	s0, s17
 801af2a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801af2e:	f00b f96f 	bl	8026210 <tSVF_init>
            tSVF_init(&delayHP2, SVFTypeHighpass, 20.f, .7f);
 801af32:	f247 5024 	movw	r0, #29988	; 0x7524
 801af36:	eef0 0a48 	vmov.f32	s1, s16
 801af3a:	4629      	mov	r1, r5
 801af3c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801af40:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801af44:	f00b f964 	bl	8026210 <tSVF_init>
            tHighpass_init(&delayShaperHp, 20.0f);
 801af48:	f247 5008 	movw	r0, #29960	; 0x7508
 801af4c:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 801af50:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801af54:	f00b fb16 	bl	8026584 <tHighpass_init>
            tFeedbackLeveler_init(&feedbackControl, .99f, 0.01, 0.125f, 0);
 801af58:	f24d 720a 	movw	r2, #55050	; 0xd70a
 801af5c:	f247 03a4 	movw	r3, #28836	; 0x70a4
 801af60:	f247 3040 	movw	r0, #29504	; 0x7340
 801af64:	f6c3 4223 	movt	r2, #15395	; 0x3c23
 801af68:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
 801af6c:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
 801af70:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801af74:	ee00 2a90 	vmov	s1, r2
 801af78:	4629      	mov	r1, r5
 801af7a:	ee00 3a10 	vmov	s0, r3
 801af7e:	f008 fd61 	bl	8023a44 <tFeedbackLeveler_init>
            capFeedback = 1;
 801af82:	f240 5128 	movw	r1, #1320	; 0x528
            delayShaper = 0;
 801af86:	f240 5278 	movw	r2, #1400	; 0x578
            freeze = 0;
 801af8a:	f240 5390 	movw	r3, #1424	; 0x590
            capFeedback = 1;
 801af8e:	f2c2 0100 	movt	r1, #8192	; 0x2000
            setLED_A(delayShaper);
 801af92:	4628      	mov	r0, r5
            delayShaper = 0;
 801af94:	f2c2 0200 	movt	r2, #8192	; 0x2000
            freeze = 0;
 801af98:	f2c2 0300 	movt	r3, #8192	; 0x2000
            capFeedback = 1;
 801af9c:	700e      	strb	r6, [r1, #0]
            delayShaper = 0;
 801af9e:	6015      	str	r5, [r2, #0]
            freeze = 0;
 801afa0:	601d      	str	r5, [r3, #0]
            setLED_A(delayShaper);
 801afa2:	f7fa fca3 	bl	80158ec <setLED_A>
            leaf.clearOnAllocation = 0;
 801afa6:	6165      	str	r5, [r4, #20]
        }
 801afa8:	ecbd 8b02 	vpop	{d8}
 801afac:	bd70      	pop	{r4, r5, r6, pc}
 801afae:	bf00      	nop

0801afb0 <SFXDelayFrame>:
        {
 801afb0:	b510      	push	{r4, lr}
            if (buttonActionsSFX[ButtonA][ActionPress])
 801afb2:	f248 64e4 	movw	r4, #34532	; 0x86e4
 801afb6:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801afba:	7d23      	ldrb	r3, [r4, #20]
 801afbc:	b9fb      	cbnz	r3, 801affe <SFXDelayFrame+0x4e>
            if (buttonActionsSFX[ButtonB][ActionPress])
 801afbe:	7e23      	ldrb	r3, [r4, #24]
 801afc0:	b153      	cbz	r3, 801afd8 <SFXDelayFrame+0x28>
                capFeedback = !capFeedback;
 801afc2:	f240 5228 	movw	r2, #1320	; 0x528
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801afc6:	2300      	movs	r3, #0
                capFeedback = !capFeedback;
 801afc8:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801afcc:	7623      	strb	r3, [r4, #24]
                capFeedback = !capFeedback;
 801afce:	7813      	ldrb	r3, [r2, #0]
 801afd0:	fab3 f383 	clz	r3, r3
 801afd4:	095b      	lsrs	r3, r3, #5
 801afd6:	7013      	strb	r3, [r2, #0]
            if (buttonActionsSFX[ButtonC][ActionPress])
 801afd8:	7f23      	ldrb	r3, [r4, #28]
 801afda:	b903      	cbnz	r3, 801afde <SFXDelayFrame+0x2e>
        }
 801afdc:	bd10      	pop	{r4, pc}
                freeze = !freeze;
 801afde:	f240 5290 	movw	r2, #1424	; 0x590
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801afe2:	2300      	movs	r3, #0
                freeze = !freeze;
 801afe4:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801afe8:	7723      	strb	r3, [r4, #28]
                freeze = !freeze;
 801afea:	6813      	ldr	r3, [r2, #0]
 801afec:	fab3 f383 	clz	r3, r3
 801aff0:	095b      	lsrs	r3, r3, #5
 801aff2:	6013      	str	r3, [r2, #0]
                setLED_C(freeze);
 801aff4:	4618      	mov	r0, r3
        }
 801aff6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                setLED_C(freeze);
 801affa:	f7fa bc97 	b.w	801592c <setLED_C>
                delayShaper = !delayShaper;
 801affe:	f240 5278 	movw	r2, #1400	; 0x578
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801b002:	2300      	movs	r3, #0
                delayShaper = !delayShaper;
 801b004:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801b008:	7523      	strb	r3, [r4, #20]
                delayShaper = !delayShaper;
 801b00a:	6813      	ldr	r3, [r2, #0]
 801b00c:	fab3 f383 	clz	r3, r3
 801b010:	095b      	lsrs	r3, r3, #5
                setLED_A(delayShaper);
 801b012:	4618      	mov	r0, r3
                delayShaper = !delayShaper;
 801b014:	6013      	str	r3, [r2, #0]
                setLED_A(delayShaper);
 801b016:	f7fa fc69 	bl	80158ec <setLED_A>
 801b01a:	e7d0      	b.n	801afbe <SFXDelayFrame+0xe>

0801b01c <SFXDelayTick>:
        {
 801b01c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b01e:	f243 155c 	movw	r5, #12636	; 0x315c
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801b022:	f04f 4286 	mov.w	r2, #1124073472	; 0x43000000
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b026:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
 801b02a:	f248 7494 	movw	r4, #34708	; 0x8794
 801b02e:	f2c2 0500 	movt	r5, #8192	; 0x2000
        {
 801b032:	4607      	mov	r7, r0
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b034:	f2c4 63ea 	movt	r3, #18154	; 0x46ea
 801b038:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801b03c:	4629      	mov	r1, r5
 801b03e:	ee07 3a90 	vmov	s15, r3
        {
 801b042:	ed2d 8b02 	vpush	{d8}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801b046:	eef2 8a04 	vmov.f32	s17, #36	; 0x41200000  10.0
 801b04a:	ee08 2a10 	vmov	s16, r2
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b04e:	ecf1 6a01 	vldmia	r1!, {s13}
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801b052:	ed95 7a02 	vldr	s14, [r5, #8]
 801b056:	eeb0 0a68 	vmov.f32	s0, s17
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b05a:	ee66 6aa7 	vmul.f32	s13, s13, s15
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801b05e:	eea7 0a08 	vfma.f32	s0, s14, s16
            displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
 801b062:	ed91 7a00 	vldr	s14, [r1]
            displayValues[0] = presetKnobValues[Delay][0] * 30000.0f;
 801b066:	edc4 6a00 	vstr	s13, [r4]
            displayValues[1] = presetKnobValues[Delay][1] * 30000.0f;
 801b06a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801b06e:	edc4 7a01 	vstr	s15, [r4, #4]
            displayValues[2] = faster_mtof((presetKnobValues[Delay][2] * 128) + 10.0f);
 801b072:	f00c fe1d 	bl	8027cb0 <faster_mtof>
 801b076:	ed84 0a02 	vstr	s0, [r4, #8]
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
 801b07a:	eeb0 0a68 	vmov.f32	s0, s17
 801b07e:	edd5 7a03 	vldr	s15, [r5, #12]
 801b082:	eea7 0a88 	vfma.f32	s0, s15, s16
 801b086:	f00c fe13 	bl	8027cb0 <faster_mtof>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 801b08a:	f240 5328 	movw	r3, #1320	; 0x528
            displayValues[3] = faster_mtof((presetKnobValues[Delay][3] * 128) + 10.0f);
 801b08e:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 801b092:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b096:	781b      	ldrb	r3, [r3, #0]
 801b098:	2b00      	cmp	r3, #0
 801b09a:	f040 8125 	bne.w	801b2e8 <SFXDelayTick+0x2cc>
 801b09e:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801b0a2:	ed95 7a04 	vldr	s14, [r5, #16]
 801b0a6:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
 801b0aa:	ee07 3a90 	vmov	s15, r3
 801b0ae:	ee67 7a27 	vmul.f32	s15, s14, s15
            displayValues[5] = presetKnobValues[Delay][5];
 801b0b2:	f243 1370 	movw	r3, #12656	; 0x3170
            tSVF_setFreq(&delayHP, displayValues[2]);
 801b0b6:	f247 20d8 	movw	r0, #29400	; 0x72d8
 801b0ba:	ed94 0a02 	vldr	s0, [r4, #8]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801b0be:	f247 561c 	movw	r6, #29980	; 0x751c
            displayValues[5] = presetKnobValues[Delay][5];
 801b0c2:	f2c2 0300 	movt	r3, #8192	; 0x2000
            tSVF_setFreq(&delayHP, displayValues[2]);
 801b0c6:	f2c2 0001 	movt	r0, #8193	; 0x2001
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 801b0ca:	edc4 7a04 	vstr	s15, [r4, #16]
            displayValues[5] = presetKnobValues[Delay][5];
 801b0ce:	681b      	ldr	r3, [r3, #0]
 801b0d0:	6163      	str	r3, [r4, #20]
            tSVF_setFreq(&delayHP, displayValues[2]);
 801b0d2:	f00b f957 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&delayHP2, displayValues[2]);
 801b0d6:	f247 5024 	movw	r0, #29988	; 0x7524
 801b0da:	ed94 0a02 	vldr	s0, [r4, #8]
 801b0de:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b0e2:	f00b f94f 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&delayLP, displayValues[3]);
 801b0e6:	f247 6098 	movw	r0, #30360	; 0x7698
 801b0ea:	ed94 0a03 	vldr	s0, [r4, #12]
 801b0ee:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b0f2:	f00b f947 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&delayLP2, displayValues[3]);
 801b0f6:	f247 6010 	movw	r0, #30224	; 0x7610
 801b0fa:	ed94 0a03 	vldr	s0, [r4, #12]
 801b0fe:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b102:	f00b f93f 	bl	8026384 <tSVF_setFreq>
            if (delayShaper == 0)
 801b106:	f240 5378 	movw	r3, #1400	; 0x578
 801b10a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b10e:	681b      	ldr	r3, [r3, #0]
 801b110:	2b00      	cmp	r3, #0
 801b112:	f040 8095 	bne.w	801b240 <SFXDelayTick+0x224>
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801b116:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801b11a:	ed94 7a04 	vldr	s14, [r4, #16]
 801b11e:	ed97 0a01 	vldr	s0, [r7, #4]
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 801b122:	f248 2530 	movw	r5, #33328	; 0x8230
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801b126:	edd6 7a00 	vldr	s15, [r6]
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 801b12a:	f2c2 0501 	movt	r5, #8193	; 0x2001
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801b12e:	eea7 0a27 	vfma.f32	s0, s14, s15
 801b132:	f010 fa17 	bl	802b564 <tanhf>
 801b136:	f247 3040 	movw	r0, #29504	; 0x7340
 801b13a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b13e:	f008 fce5 	bl	8023b0c <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 801b142:	edd5 7a00 	vldr	s15, [r5]
 801b146:	ed94 7a04 	vldr	s14, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB1 * displayValues[4])));
 801b14a:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tanhf(input[1] + (delayFB2 * displayValues[4])));
 801b14e:	ed97 0a01 	vldr	s0, [r7, #4]
 801b152:	eea7 0a27 	vfma.f32	s0, s14, s15
 801b156:	f010 fa05 	bl	802b564 <tanhf>
 801b15a:	f247 3040 	movw	r0, #29504	; 0x7340
 801b15e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b162:	f008 fcd3 	bl	8023b0c <tFeedbackLeveler_tick>
 801b166:	eeb0 8a40 	vmov.f32	s16, s0
            tTapeDelay_setDelay(&delay, displayValues[0]);
 801b16a:	f247 707c 	movw	r0, #30588	; 0x777c
 801b16e:	ed94 0a00 	vldr	s0, [r4]
 801b172:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b176:	f007 fff7 	bl	8023168 <tTapeDelay_setDelay>
            tTapeDelay_setDelay(&delay2, displayValues[1]);
 801b17a:	f243 6058 	movw	r0, #13912	; 0x3658
 801b17e:	ed94 0a01 	vldr	s0, [r4, #4]
 801b182:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b186:	f007 ffef 	bl	8023168 <tTapeDelay_setDelay>
            if (!freeze)
 801b18a:	f240 5390 	movw	r3, #1424	; 0x590
                delayFB1 = tTapeDelay_tick(&delay, input1);
 801b18e:	f247 707c 	movw	r0, #30588	; 0x777c
            if (!freeze)
 801b192:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b196:	681b      	ldr	r3, [r3, #0]
 801b198:	2b00      	cmp	r3, #0
 801b19a:	f000 8092 	beq.w	801b2c2 <SFXDelayTick+0x2a6>
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
 801b19e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b1a2:	ed96 0a00 	vldr	s0, [r6]
 801b1a6:	f007 ff69 	bl	802307c <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
 801b1aa:	f243 6058 	movw	r0, #13912	; 0x3658
                delayFB1 = tTapeDelay_tick(&delay, delayFB1);
 801b1ae:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, delayFB2);
 801b1b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b1b6:	ed95 0a00 	vldr	s0, [r5]
 801b1ba:	f007 ff5f 	bl	802307c <tTapeDelay_tick>
 801b1be:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
 801b1c2:	f247 6098 	movw	r0, #30360	; 0x7698
 801b1c6:	ed96 0a00 	vldr	s0, [r6]
 801b1ca:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b1ce:	f00b f8a3 	bl	8026318 <tSVF_tick>
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 801b1d2:	f247 6010 	movw	r0, #30224	; 0x7610
            delayFB1 = tSVF_tick(&delayLP, delayFB1);
 801b1d6:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 801b1da:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b1de:	ed95 0a00 	vldr	s0, [r5]
 801b1e2:	f00b f899 	bl	8026318 <tSVF_tick>
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 801b1e6:	f247 20d8 	movw	r0, #29400	; 0x72d8
            delayFB2 = tSVF_tick(&delayLP2, delayFB2);
 801b1ea:	ed85 0a00 	vstr	s0, [r5]
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 801b1ee:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b1f2:	ed96 0a00 	vldr	s0, [r6]
 801b1f6:	f00b f88f 	bl	8026318 <tSVF_tick>
 801b1fa:	f010 f9b3 	bl	802b564 <tanhf>
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 801b1fe:	f247 5024 	movw	r0, #29988	; 0x7524
            delayFB1 = tanhf(tSVF_tick(&delayHP, delayFB1));
 801b202:	ed86 0a00 	vstr	s0, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 801b206:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b20a:	ed95 0a00 	vldr	s0, [r5]
 801b20e:	f00b f883 	bl	8026318 <tSVF_tick>
 801b212:	f010 f9a7 	bl	802b564 <tanhf>
            input[0] = delayFB1 * displayValues[5];
 801b216:	edd4 7a05 	vldr	s15, [r4, #20]
 801b21a:	ed96 7a00 	vldr	s14, [r6]
            delayFB2 = tanhf(tSVF_tick(&delayHP2, delayFB2));
 801b21e:	ed85 0a00 	vstr	s0, [r5]
            input[0] = delayFB1 * displayValues[5];
 801b222:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b226:	edc7 7a00 	vstr	s15, [r7]
            input[1] = delayFB2 * displayValues[5];
 801b22a:	edd4 7a05 	vldr	s15, [r4, #20]
 801b22e:	ed95 7a00 	vldr	s14, [r5]
 801b232:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b236:	edc7 7a01 	vstr	s15, [r7, #4]
        }
 801b23a:	ecbd 8b02 	vpop	{d8}
 801b23e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 801b240:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801b244:	edd4 7a04 	vldr	s15, [r4, #16]
 801b248:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 801b24c:	ed97 0a01 	vldr	s0, [r7, #4]
 801b250:	ed96 7a00 	vldr	s14, [r6]
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 801b254:	f248 2530 	movw	r5, #33328	; 0x8230
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 801b258:	ee67 7a87 	vmul.f32	s15, s15, s14
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 801b25c:	f2c2 0501 	movt	r5, #8193	; 0x2001
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 801b260:	eef0 0a48 	vmov.f32	s1, s16
 801b264:	eea7 0a88 	vfma.f32	s0, s15, s16
 801b268:	f00c fb44 	bl	80278f4 <LEAF_shaper>
 801b26c:	f247 5008 	movw	r0, #29960	; 0x7508
 801b270:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b274:	f00b f9de 	bl	8026634 <tHighpass_tick>
 801b278:	f247 3040 	movw	r0, #29504	; 0x7340
 801b27c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b280:	f008 fc44 	bl	8023b0c <tFeedbackLeveler_tick>
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 801b284:	ed95 7a00 	vldr	s14, [r5]
 801b288:	edd4 7a04 	vldr	s15, [r4, #16]
                input1 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB1 * displayValues[4] * 0.5f), 0.5f)));
 801b28c:	eef0 8a40 	vmov.f32	s17, s0
                input2 = tFeedbackLeveler_tick(&feedbackControl, tHighpass_tick(&delayShaperHp, LEAF_shaper(input[1] + (delayFB2 * displayValues[4] * 0.5f), 0.5f)));
 801b290:	ed97 0a01 	vldr	s0, [r7, #4]
 801b294:	eef0 0a48 	vmov.f32	s1, s16
 801b298:	ee67 7a87 	vmul.f32	s15, s15, s14
 801b29c:	eea7 0a88 	vfma.f32	s0, s15, s16
 801b2a0:	f00c fb28 	bl	80278f4 <LEAF_shaper>
 801b2a4:	f247 5008 	movw	r0, #29960	; 0x7508
 801b2a8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b2ac:	f00b f9c2 	bl	8026634 <tHighpass_tick>
 801b2b0:	f247 3040 	movw	r0, #29504	; 0x7340
 801b2b4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b2b8:	f008 fc28 	bl	8023b0c <tFeedbackLeveler_tick>
 801b2bc:	eeb0 8a40 	vmov.f32	s16, s0
 801b2c0:	e753      	b.n	801b16a <SFXDelayTick+0x14e>
                delayFB1 = tTapeDelay_tick(&delay, input1);
 801b2c2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b2c6:	eeb0 0a68 	vmov.f32	s0, s17
 801b2ca:	f007 fed7 	bl	802307c <tTapeDelay_tick>
                delayFB2 = tTapeDelay_tick(&delay2, input2);
 801b2ce:	f243 6058 	movw	r0, #13912	; 0x3658
                delayFB1 = tTapeDelay_tick(&delay, input1);
 801b2d2:	ed86 0a00 	vstr	s0, [r6]
                delayFB2 = tTapeDelay_tick(&delay2, input2);
 801b2d6:	eeb0 0a48 	vmov.f32	s0, s16
 801b2da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b2de:	f007 fecd 	bl	802307c <tTapeDelay_tick>
 801b2e2:	ed85 0a00 	vstr	s0, [r5]
 801b2e6:	e76c      	b.n	801b1c2 <SFXDelayTick+0x1a6>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Delay][4] * 1.1f, 0.9f) : presetKnobValues[Delay][4] * 1.1f;
 801b2e8:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801b2ec:	f246 6266 	movw	r2, #26214	; 0x6666
 801b2f0:	edd5 0a04 	vldr	s1, [r5, #16]
 801b2f4:	2100      	movs	r1, #0
 801b2f6:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
 801b2fa:	f6c3 7266 	movt	r2, #16230	; 0x3f66
 801b2fe:	ee00 1a10 	vmov	s0, r1
 801b302:	ee07 3a90 	vmov	s15, r3
 801b306:	ee01 2a10 	vmov	s2, r2
 801b30a:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801b30e:	f00c fb53 	bl	80279b8 <LEAF_clip>
 801b312:	eef0 7a40 	vmov.f32	s15, s0
 801b316:	e6cc      	b.n	801b0b2 <SFXDelayTick+0x96>

0801b318 <SFXDelayFree>:
            tTapeDelay_free(&delay);
 801b318:	f247 707c 	movw	r0, #30588	; 0x777c
        {
 801b31c:	b508      	push	{r3, lr}
            tTapeDelay_free(&delay);
 801b31e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b322:	f007 fe9f 	bl	8023064 <tTapeDelay_free>
            tTapeDelay_free(&delay2);
 801b326:	f243 6058 	movw	r0, #13912	; 0x3658
 801b32a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b32e:	f007 fe99 	bl	8023064 <tTapeDelay_free>
            tSVF_free(&delayLP);
 801b332:	f247 6098 	movw	r0, #30360	; 0x7698
 801b336:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b33a:	f00a ffe9 	bl	8026310 <tSVF_free>
            tSVF_free(&delayHP);
 801b33e:	f247 20d8 	movw	r0, #29400	; 0x72d8
 801b342:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b346:	f00a ffe3 	bl	8026310 <tSVF_free>
            tSVF_free(&delayLP2);
 801b34a:	f247 6010 	movw	r0, #30224	; 0x7610
 801b34e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b352:	f00a ffdd 	bl	8026310 <tSVF_free>
            tSVF_free(&delayHP2);
 801b356:	f247 5024 	movw	r0, #29988	; 0x7524
 801b35a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b35e:	f00a ffd7 	bl	8026310 <tSVF_free>
            tHighpass_free(&delayShaperHp);
 801b362:	f247 5008 	movw	r0, #29960	; 0x7508
 801b366:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b36a:	f00b f94f 	bl	802660c <tHighpass_free>
            tFeedbackLeveler_free(&feedbackControl);
 801b36e:	f247 3040 	movw	r0, #29504	; 0x7340
        }
 801b372:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tFeedbackLeveler_free(&feedbackControl);
 801b376:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b37a:	f008 bbb7 	b.w	8023aec <tFeedbackLeveler_free>
 801b37e:	bf00      	nop

0801b380 <SFXReverbAlloc>:
        {
 801b380:	b570      	push	{r4, r5, r6, lr}
            tDattorroReverb_init(&reverb);
 801b382:	f642 4548 	movw	r5, #11336	; 0x2c48
            leaf.clearOnAllocation = 1;
 801b386:	f249 44a0 	movw	r4, #38048	; 0x94a0
 801b38a:	2601      	movs	r6, #1
            tDattorroReverb_init(&reverb);
 801b38c:	f2c2 0500 	movt	r5, #8192	; 0x2000
            leaf.clearOnAllocation = 1;
 801b390:	f2c2 0401 	movt	r4, #8193	; 0x2001
            tDattorroReverb_init(&reverb);
 801b394:	4628      	mov	r0, r5
            leaf.clearOnAllocation = 1;
 801b396:	6166      	str	r6, [r4, #20]
            tDattorroReverb_init(&reverb);
 801b398:	f00e fa8e 	bl	80298b8 <tDattorroReverb_init>
            tExpSmooth_init(&sizeSmoother, 0.5f, 0.001f);
 801b39c:	f241 236f 	movw	r3, #4719	; 0x126f
 801b3a0:	f248 103c 	movw	r0, #33084	; 0x813c
 801b3a4:	eeb6 0a00 	vmov.f32	s0, #96	; 0x3f000000  0.5
 801b3a8:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 801b3ac:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b3b0:	ee00 3a90 	vmov	s1, r3
 801b3b4:	f00a fd86 	bl	8025ec4 <tExpSmooth_init>
            tDattorroReverb_setMix(&reverb, 1.0f);
 801b3b8:	4628      	mov	r0, r5
 801b3ba:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801b3be:	f00e fca1 	bl	8029d04 <tDattorroReverb_setMix>
            freeze = 0;
 801b3c2:	f240 5290 	movw	r2, #1424	; 0x590
            capFeedback = 1;
 801b3c6:	f240 5328 	movw	r3, #1320	; 0x528
            freeze = 0;
 801b3ca:	2100      	movs	r1, #0
 801b3cc:	f2c2 0200 	movt	r2, #8192	; 0x2000
            capFeedback = 1;
 801b3d0:	f2c2 0300 	movt	r3, #8192	; 0x2000
            leaf.clearOnAllocation = 0;
 801b3d4:	6161      	str	r1, [r4, #20]
            freeze = 0;
 801b3d6:	6011      	str	r1, [r2, #0]
            capFeedback = 1;
 801b3d8:	701e      	strb	r6, [r3, #0]
        }
 801b3da:	bd70      	pop	{r4, r5, r6, pc}

0801b3dc <SFXReverbFrame>:
            if (buttonActionsSFX[ButtonB][ActionPress])
 801b3dc:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801b3e0:	f2c2 0301 	movt	r3, #8193	; 0x2001
        {
 801b3e4:	b570      	push	{r4, r5, r6, lr}
 801b3e6:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonB][ActionPress])
 801b3ea:	7e1a      	ldrb	r2, [r3, #24]
 801b3ec:	b152      	cbz	r2, 801b404 <SFXReverbFrame+0x28>
                capFeedback = !capFeedback;
 801b3ee:	f240 5228 	movw	r2, #1320	; 0x528
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801b3f2:	2100      	movs	r1, #0
                capFeedback = !capFeedback;
 801b3f4:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801b3f8:	7619      	strb	r1, [r3, #24]
                capFeedback = !capFeedback;
 801b3fa:	7813      	ldrb	r3, [r2, #0]
 801b3fc:	fab3 f383 	clz	r3, r3
 801b400:	095b      	lsrs	r3, r3, #5
 801b402:	7013      	strb	r3, [r2, #0]
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
 801b404:	f243 16c4 	movw	r6, #12740	; 0x31c4
 801b408:	2300      	movs	r3, #0
 801b40a:	f248 7494 	movw	r4, #34708	; 0x8794
 801b40e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801b412:	f2c4 3301 	movt	r3, #17153	; 0x4301
 801b416:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801b41a:	4635      	mov	r5, r6
 801b41c:	ee08 3a10 	vmov	s16, r3
 801b420:	ecb5 0a01 	vldmia	r5!, {s0}
 801b424:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b428:	f00c fc42 	bl	8027cb0 <faster_mtof>
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
 801b42c:	f642 4048 	movw	r0, #11336	; 0x2c48
            displayValues[1] = faster_mtof(presetKnobValues[Reverb][1]*129.0f);
 801b430:	ed84 0a01 	vstr	s0, [r4, #4]
            tDattorroReverb_setFeedbackFilter(&reverb, displayValues[1]);
 801b434:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b438:	f00e fd68 	bl	8029f0c <tDattorroReverb_setFeedbackFilter>
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
 801b43c:	2300      	movs	r3, #0
 801b43e:	ed95 0a00 	vldr	s0, [r5]
 801b442:	f2c4 23f6 	movt	r3, #17142	; 0x42f6
 801b446:	ee07 3a90 	vmov	s15, r3
 801b44a:	ee20 0a27 	vmul.f32	s0, s0, s15
 801b44e:	f00c fc2f 	bl	8027cb0 <faster_mtof>
            tDattorroReverb_setHP(&reverb, displayValues[2]);
 801b452:	f642 4048 	movw	r0, #11336	; 0x2c48
            displayValues[2] =  faster_mtof(presetKnobValues[Reverb][2]*123.0f);
 801b456:	ed84 0a02 	vstr	s0, [r4, #8]
            tDattorroReverb_setHP(&reverb, displayValues[2]);
 801b45a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b45e:	f00e fca7 	bl	8029db0 <tDattorroReverb_setHP>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
 801b462:	ed96 0a02 	vldr	s0, [r6, #8]
 801b466:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b46a:	f00c fc21 	bl	8027cb0 <faster_mtof>
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
 801b46e:	f642 4048 	movw	r0, #11336	; 0x2c48
            displayValues[3] = faster_mtof(presetKnobValues[Reverb][3]*129.0f);
 801b472:	ed84 0a03 	vstr	s0, [r4, #12]
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
 801b476:	f2c2 0000 	movt	r0, #8192	; 0x2000
        }
 801b47a:	ecbd 8b02 	vpop	{d8}
 801b47e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            tDattorroReverb_setInputFilter(&reverb, displayValues[3]);
 801b482:	f00e bd2b 	b.w	8029edc <tDattorroReverb_setInputFilter>
 801b486:	bf00      	nop

0801b488 <SFXReverbTick>:
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b488:	f248 63e4 	movw	r3, #34532	; 0x86e4
 801b48c:	f2c2 0301 	movt	r3, #8193	; 0x2001
        {
 801b490:	b570      	push	{r4, r5, r6, lr}
 801b492:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b496:	7f1a      	ldrb	r2, [r3, #28]
        {
 801b498:	b082      	sub	sp, #8
 801b49a:	4604      	mov	r4, r0
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b49c:	2a00      	cmp	r2, #0
 801b49e:	d169      	bne.n	801b574 <SFXReverbTick+0xec>
            input[1] *= 4.0f;
 801b4a0:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 801b4a4:	ed94 7a01 	vldr	s14, [r4, #4]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801b4a8:	f246 6266 	movw	r2, #26214	; 0x6666
 801b4ac:	f64c 43cd 	movw	r3, #52429	; 0xcccd
            displayValues[0] = presetKnobValues[Reverb][0];
 801b4b0:	f243 16c0 	movw	r6, #12736	; 0x31c0
 801b4b4:	f248 7594 	movw	r5, #34708	; 0x8794
            input[1] *= 4.0f;
 801b4b8:	ee27 7a27 	vmul.f32	s14, s14, s15
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801b4bc:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 801b4c0:	f6c3 7266 	movt	r2, #16230	; 0x3f66
            displayValues[0] = presetKnobValues[Reverb][0];
 801b4c4:	f2c2 0600 	movt	r6, #8192	; 0x2000
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801b4c8:	ee00 3a10 	vmov	s0, r3
 801b4cc:	f248 103c 	movw	r0, #33084	; 0x813c
 801b4d0:	ee07 2a90 	vmov	s15, r2
            input[1] *= 4.0f;
 801b4d4:	ed84 7a01 	vstr	s14, [r4, #4]
            displayValues[0] = presetKnobValues[Reverb][0];
 801b4d8:	ed96 7a00 	vldr	s14, [r6]
 801b4dc:	f2c2 0501 	movt	r5, #8193	; 0x2001
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801b4e0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b4e4:	eea7 0a27 	vfma.f32	s0, s14, s15
            displayValues[0] = presetKnobValues[Reverb][0];
 801b4e8:	ed85 7a00 	vstr	s14, [r5]
            tExpSmooth_setDest(&sizeSmoother, (displayValues[0] * 0.9f) + 0.1f);
 801b4ec:	f00a fd50 	bl	8025f90 <tExpSmooth_setDest>
            float tempSize = tExpSmooth_tick(&sizeSmoother);
 801b4f0:	f248 103c 	movw	r0, #33084	; 0x813c
 801b4f4:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b4f8:	f00a fd54 	bl	8025fa4 <tExpSmooth_tick>
            tDattorroReverb_setSize(&reverb, tempSize);
 801b4fc:	f642 4048 	movw	r0, #11336	; 0x2c48
 801b500:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b504:	f00e fc74 	bl	8029df0 <tDattorroReverb_setSize>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 801b508:	f240 5328 	movw	r3, #1320	; 0x528
 801b50c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801b510:	781b      	ldrb	r3, [r3, #0]
 801b512:	2b00      	cmp	r3, #0
 801b514:	d144      	bne.n	801b5a0 <SFXReverbTick+0x118>
 801b516:	edd6 7a04 	vldr	s15, [r6, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
 801b51a:	f642 4048 	movw	r0, #11336	; 0x2c48
 801b51e:	eeb0 0a67 	vmov.f32	s0, s15
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 801b522:	edc5 7a04 	vstr	s15, [r5, #16]
            tDattorroReverb_setFeedbackGain(&reverb, displayValues[4]);
 801b526:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b52a:	f00e fd0d 	bl	8029f48 <tDattorroReverb_setFeedbackGain>
            tDattorroReverb_tickStereo(&reverb, input[1], stereo);
 801b52e:	f642 4048 	movw	r0, #11336	; 0x2c48
 801b532:	4669      	mov	r1, sp
 801b534:	ed94 0a01 	vldr	s0, [r4, #4]
 801b538:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b53c:	f00e fa1a 	bl	8029974 <tDattorroReverb_tickStereo>
            sample = tanhf(stereo[0]) * 0.99f;
 801b540:	ed9d 0a00 	vldr	s0, [sp]
 801b544:	f010 f80e 	bl	802b564 <tanhf>
 801b548:	f247 03a4 	movw	r3, #28836	; 0x70a4
 801b54c:	f6c3 737d 	movt	r3, #16253	; 0x3f7d
 801b550:	ee08 3a10 	vmov	s16, r3
 801b554:	ee60 7a08 	vmul.f32	s15, s0, s16
            input[1] = tanhf(stereo[1]) * 0.99f;
 801b558:	ed9d 0a01 	vldr	s0, [sp, #4]
            input[0] = sample;
 801b55c:	edc4 7a00 	vstr	s15, [r4]
            input[1] = tanhf(stereo[1]) * 0.99f;
 801b560:	f010 f800 	bl	802b564 <tanhf>
 801b564:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b568:	ed84 0a01 	vstr	s0, [r4, #4]
        }
 801b56c:	b002      	add	sp, #8
 801b56e:	ecbd 8b02 	vpop	{d8}
 801b572:	bd70      	pop	{r4, r5, r6, pc}
                freeze = !freeze;
 801b574:	f240 5590 	movw	r5, #1424	; 0x590
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801b578:	2200      	movs	r2, #0
                tDattorroReverb_setFreeze(&reverb, freeze);
 801b57a:	f642 4048 	movw	r0, #11336	; 0x2c48
                freeze = !freeze;
 801b57e:	f2c2 0500 	movt	r5, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801b582:	771a      	strb	r2, [r3, #28]
                tDattorroReverb_setFreeze(&reverb, freeze);
 801b584:	f2c2 0000 	movt	r0, #8192	; 0x2000
                freeze = !freeze;
 801b588:	682b      	ldr	r3, [r5, #0]
 801b58a:	fab3 f383 	clz	r3, r3
 801b58e:	095b      	lsrs	r3, r3, #5
                tDattorroReverb_setFreeze(&reverb, freeze);
 801b590:	4619      	mov	r1, r3
                freeze = !freeze;
 801b592:	602b      	str	r3, [r5, #0]
                tDattorroReverb_setFreeze(&reverb, freeze);
 801b594:	f00e fbc4 	bl	8029d20 <tDattorroReverb_setFreeze>
                setLED_C(freeze);
 801b598:	7828      	ldrb	r0, [r5, #0]
 801b59a:	f7fa f9c7 	bl	801592c <setLED_C>
 801b59e:	e77f      	b.n	801b4a0 <SFXReverbTick+0x18>
            displayValues[4] = capFeedback ? LEAF_clip(0.0f, presetKnobValues[Reverb][4], 0.5f) : presetKnobValues[Reverb][4];
 801b5a0:	2300      	movs	r3, #0
 801b5a2:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 801b5a6:	edd6 0a04 	vldr	s1, [r6, #16]
 801b5aa:	ee00 3a10 	vmov	s0, r3
 801b5ae:	f00c fa03 	bl	80279b8 <LEAF_clip>
 801b5b2:	eef0 7a40 	vmov.f32	s15, s0
 801b5b6:	e7b0      	b.n	801b51a <SFXReverbTick+0x92>

0801b5b8 <SFXReverbFree>:
            tDattorroReverb_free(&reverb);
 801b5b8:	f642 4048 	movw	r0, #11336	; 0x2c48
        {
 801b5bc:	b508      	push	{r3, lr}
            tDattorroReverb_free(&reverb);
 801b5be:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b5c2:	f00e f97f 	bl	80298c4 <tDattorroReverb_free>
            tExpSmooth_free(&sizeSmoother);
 801b5c6:	f248 103c 	movw	r0, #33084	; 0x813c
        }
 801b5ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tExpSmooth_free(&sizeSmoother);
 801b5ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b5d2:	f00a bcc7 	b.w	8025f64 <tExpSmooth_free>
 801b5d6:	bf00      	nop

0801b5d8 <SFXReverb2Alloc>:
        {
 801b5d8:	b570      	push	{r4, r5, r6, lr}
            tNReverb_init(&reverb2, 1.0f);
 801b5da:	f248 2534 	movw	r5, #33332	; 0x8234
            leaf.clearOnAllocation = 1;
 801b5de:	f249 44a0 	movw	r4, #38048	; 0x94a0
 801b5e2:	2601      	movs	r6, #1
            tNReverb_init(&reverb2, 1.0f);
 801b5e4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801b5e8:	f2c2 0501 	movt	r5, #8193	; 0x2001
            leaf.clearOnAllocation = 1;
 801b5ec:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 801b5f0:	ed2d 8b04 	vpush	{d8-d9}
            tNReverb_init(&reverb2, 1.0f);
 801b5f4:	4628      	mov	r0, r5
            leaf.clearOnAllocation = 1;
 801b5f6:	6166      	str	r6, [r4, #20]
            tNReverb_init(&reverb2, 1.0f);
 801b5f8:	f00d fe5a 	bl	80292b0 <tNReverb_init>
            tNReverb_setMix(&reverb2, 1.0f);
 801b5fc:	4628      	mov	r0, r5
 801b5fe:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801b602:	f00d febf 	bl	8029384 <tNReverb_setMix>
            tSVF_init(&lowpass, SVFTypeLowpass, 18000.0f, 0.75f);
 801b606:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 801b60a:	f642 1048 	movw	r0, #10568	; 0x2948
 801b60e:	4631      	mov	r1, r6
 801b610:	f2c4 638c 	movt	r3, #18060	; 0x468c
 801b614:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 801b618:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b61c:	ee00 3a10 	vmov	s0, r3
 801b620:	ee09 3a10 	vmov	s18, r3
 801b624:	f00a fdf4 	bl	8026210 <tSVF_init>
            tSVF_init(&highpass, SVFTypeHighpass, 40.0f, 0.75f);
 801b628:	2300      	movs	r3, #0
 801b62a:	f248 1044 	movw	r0, #33092	; 0x8144
 801b62e:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 801b632:	f2c4 2320 	movt	r3, #16928	; 0x4220
 801b636:	2100      	movs	r1, #0
 801b638:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b63c:	ee00 3a10 	vmov	s0, r3
 801b640:	ee08 3a90 	vmov	s17, r3
 801b644:	f00a fde4 	bl	8026210 <tSVF_init>
            tSVF_init(&bandpass, SVFTypeBandpass, 2000.0f, 1.0f);
 801b648:	2300      	movs	r3, #0
 801b64a:	f247 600c 	movw	r0, #30220	; 0x760c
 801b64e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 801b652:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
 801b656:	2102      	movs	r1, #2
 801b658:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b65c:	ee00 3a10 	vmov	s0, r3
 801b660:	ee08 3a10 	vmov	s16, r3
 801b664:	f00a fdd4 	bl	8026210 <tSVF_init>
            tSVF_init(&lowpass2, SVFTypeLowpass, 18000.0f, 0.75f);
 801b668:	f247 2060 	movw	r0, #29280	; 0x7260
 801b66c:	eeb0 0a49 	vmov.f32	s0, s18
 801b670:	4631      	mov	r1, r6
 801b672:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b676:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 801b67a:	f00a fdc9 	bl	8026210 <tSVF_init>
            tSVF_init(&highpass2, SVFTypeHighpass, 40.0f, 0.75f);
 801b67e:	f247 500c 	movw	r0, #29964	; 0x750c
 801b682:	eeb0 0a68 	vmov.f32	s0, s17
 801b686:	2100      	movs	r1, #0
 801b688:	eef6 0a08 	vmov.f32	s1, #104	; 0x3f400000  0.750
 801b68c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b690:	f00a fdbe 	bl	8026210 <tSVF_init>
            tSVF_init(&bandpass2, SVFTypeBandpass, 2000.0f, 1.0f);
 801b694:	f247 50ec 	movw	r0, #30188	; 0x75ec
 801b698:	eeb0 0a48 	vmov.f32	s0, s16
 801b69c:	2102      	movs	r1, #2
 801b69e:	eef7 0a00 	vmov.f32	s1, #112	; 0x3f800000  1.0
 801b6a2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b6a6:	f00a fdb3 	bl	8026210 <tSVF_init>
            freeze = 0;
 801b6aa:	f240 5390 	movw	r3, #1424	; 0x590
 801b6ae:	2200      	movs	r2, #0
 801b6b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
            leaf.clearOnAllocation = 0;
 801b6b4:	6162      	str	r2, [r4, #20]
            freeze = 0;
 801b6b6:	601a      	str	r2, [r3, #0]
        }
 801b6b8:	ecbd 8b04 	vpop	{d8-d9}
 801b6bc:	bd70      	pop	{r4, r5, r6, pc}
 801b6be:	bf00      	nop

0801b6c0 <SFXReverb2Frame>:
 801b6c0:	4770      	bx	lr
 801b6c2:	bf00      	nop

0801b6c4 <SFXReverb2Tick>:
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 801b6c4:	f243 2324 	movw	r3, #12836	; 0x3224
 801b6c8:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 801b6cc:	f2c2 0300 	movt	r3, #8192	; 0x2000
        {
 801b6d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
            if (!freeze)
 801b6d4:	f240 5690 	movw	r6, #1424	; 0x590
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 801b6d8:	f248 7494 	movw	r4, #34708	; 0x8794
        {
 801b6dc:	4607      	mov	r7, r0
            if (!freeze)
 801b6de:	f2c2 0600 	movt	r6, #8192	; 0x2000
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 801b6e2:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 801b6e6:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 801b6ea:	ed93 0a00 	vldr	s0, [r3]
        {
 801b6ee:	b083      	sub	sp, #12
            if (!freeze)
 801b6f0:	6833      	ldr	r3, [r6, #0]
            displayValues[0] = presetKnobValues[Reverb2][0] * 4.0f;
 801b6f2:	ee20 0a27 	vmul.f32	s0, s0, s15
 801b6f6:	ed84 0a00 	vstr	s0, [r4]
            if (!freeze)
 801b6fa:	2b00      	cmp	r3, #0
 801b6fc:	f040 80c1 	bne.w	801b882 <SFXReverb2Tick+0x1be>
                tNReverb_setT60(&reverb2, displayValues[0]);
 801b700:	f248 2034 	movw	r0, #33332	; 0x8234
 801b704:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b708:	f00d fdf4 	bl	80292f4 <tNReverb_setT60>
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 801b70c:	f243 2828 	movw	r8, #12840	; 0x3228
 801b710:	2300      	movs	r3, #0
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b712:	f248 65e4 	movw	r5, #34532	; 0x86e4
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 801b716:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801b71a:	f2c4 3307 	movt	r3, #17159	; 0x4307
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b71e:	f2c2 0501 	movt	r5, #8193	; 0x2001
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 801b722:	46c1      	mov	r9, r8
 801b724:	ee07 3a90 	vmov	s15, r3
 801b728:	ecb9 0a01 	vldmia	r9!, {s0}
 801b72c:	ee20 0a27 	vmul.f32	s0, s0, s15
 801b730:	f00c fabe 	bl	8027cb0 <faster_mtof>
            tSVF_setFreq(&lowpass, displayValues[1]);
 801b734:	f642 1048 	movw	r0, #10568	; 0x2948
            displayValues[1] = faster_mtof(presetKnobValues[Reverb2][1]*135.0f);
 801b738:	ed84 0a01 	vstr	s0, [r4, #4]
            tSVF_setFreq(&lowpass, displayValues[1]);
 801b73c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b740:	f00a fe20 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&lowpass2, displayValues[1]);
 801b744:	f247 2060 	movw	r0, #29280	; 0x7260
 801b748:	ed94 0a01 	vldr	s0, [r4, #4]
 801b74c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b750:	f00a fe18 	bl	8026384 <tSVF_setFreq>
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
 801b754:	f04f 4386 	mov.w	r3, #1124073472	; 0x43000000
 801b758:	ed99 0a00 	vldr	s0, [r9]
 801b75c:	ee08 3a10 	vmov	s16, r3
 801b760:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b764:	f00c faa4 	bl	8027cb0 <faster_mtof>
            tSVF_setFreq(&highpass, displayValues[2]);
 801b768:	f248 1044 	movw	r0, #33092	; 0x8144
            displayValues[2] = faster_mtof(presetKnobValues[Reverb2][2]*128.0f);
 801b76c:	ed84 0a02 	vstr	s0, [r4, #8]
            tSVF_setFreq(&highpass, displayValues[2]);
 801b770:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b774:	f00a fe06 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&highpass2, displayValues[2]);
 801b778:	f247 500c 	movw	r0, #29964	; 0x750c
 801b77c:	ed94 0a02 	vldr	s0, [r4, #8]
 801b780:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b784:	f00a fdfe 	bl	8026384 <tSVF_setFreq>
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
 801b788:	ed98 0a02 	vldr	s0, [r8, #8]
 801b78c:	ee20 0a08 	vmul.f32	s0, s0, s16
 801b790:	f00c fa8e 	bl	8027cb0 <faster_mtof>
            tSVF_setFreq(&bandpass, displayValues[3]);
 801b794:	f247 600c 	movw	r0, #30220	; 0x760c
            displayValues[3] = faster_mtof(presetKnobValues[Reverb2][3]*128.0f);
 801b798:	ed84 0a03 	vstr	s0, [r4, #12]
            tSVF_setFreq(&bandpass, displayValues[3]);
 801b79c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b7a0:	f00a fdf0 	bl	8026384 <tSVF_setFreq>
            tSVF_setFreq(&bandpass2, displayValues[3]);
 801b7a4:	f247 50ec 	movw	r0, #30188	; 0x75ec
 801b7a8:	ed94 0a03 	vldr	s0, [r4, #12]
 801b7ac:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b7b0:	f00a fde8 	bl	8026384 <tSVF_setFreq>
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
 801b7b4:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 801b7b8:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 801b7bc:	edd8 6a03 	vldr	s13, [r8, #12]
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b7c0:	7f2b      	ldrb	r3, [r5, #28]
            displayValues[4] = (presetKnobValues[Reverb2][4] * 4.0f) - 2.0f;
 801b7c2:	eee6 7a87 	vfma.f32	s15, s13, s14
 801b7c6:	edc4 7a04 	vstr	s15, [r4, #16]
            if (buttonActionsSFX[ButtonC][ActionPress])
 801b7ca:	2b00      	cmp	r3, #0
 801b7cc:	d167      	bne.n	801b89e <SFXReverb2Tick+0x1da>
            if (buttonActionsSFX[ButtonA][ActionPress])
 801b7ce:	7d2b      	ldrb	r3, [r5, #20]
 801b7d0:	b14b      	cbz	r3, 801b7e6 <SFXReverb2Tick+0x122>
                freeze = !freeze;
 801b7d2:	6833      	ldr	r3, [r6, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801b7d4:	2200      	movs	r2, #0
                freeze = !freeze;
 801b7d6:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801b7da:	752a      	strb	r2, [r5, #20]
                freeze = !freeze;
 801b7dc:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
 801b7de:	4618      	mov	r0, r3
                freeze = !freeze;
 801b7e0:	6033      	str	r3, [r6, #0]
                setLED_C(freeze);
 801b7e2:	f7fa f8a3 	bl	801592c <setLED_C>
            tNReverb_tickStereo(&reverb2, input[1], stereoOuts);
 801b7e6:	f248 2034 	movw	r0, #33332	; 0x8234
 801b7ea:	4669      	mov	r1, sp
 801b7ec:	ed97 0a01 	vldr	s0, [r7, #4]
 801b7f0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b7f4:	f00d fdca 	bl	802938c <tNReverb_tickStereo>
            float leftOut = tSVF_tick(&lowpass, stereoOuts[0]);
 801b7f8:	f642 1048 	movw	r0, #10568	; 0x2948
 801b7fc:	ed9d 0a00 	vldr	s0, [sp]
 801b800:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b804:	f00a fd88 	bl	8026318 <tSVF_tick>
            leftOut = tSVF_tick(&highpass, leftOut);
 801b808:	f248 1044 	movw	r0, #33092	; 0x8144
 801b80c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b810:	f00a fd82 	bl	8026318 <tSVF_tick>
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 801b814:	f247 600c 	movw	r0, #30220	; 0x760c
            leftOut = tSVF_tick(&highpass, leftOut);
 801b818:	eef0 8a40 	vmov.f32	s17, s0
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 801b81c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b820:	f00a fd7a 	bl	8026318 <tSVF_tick>
 801b824:	edd4 7a04 	vldr	s15, [r4, #16]
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
 801b828:	f247 2060 	movw	r0, #29280	; 0x7260
            leftOut += tSVF_tick(&bandpass, leftOut) * displayValues[4];
 801b82c:	eee0 8a27 	vfma.f32	s17, s0, s15
            float rightOutTemp = tSVF_tick(&lowpass2, stereoOuts[1]);
 801b830:	ed9d 0a01 	vldr	s0, [sp, #4]
 801b834:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b838:	f00a fd6e 	bl	8026318 <tSVF_tick>
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
 801b83c:	f247 500c 	movw	r0, #29964	; 0x750c
 801b840:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b844:	f00a fd68 	bl	8026318 <tSVF_tick>
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
 801b848:	f247 600c 	movw	r0, #30220	; 0x760c
            rightOutTemp = tSVF_tick(&highpass2, rightOutTemp);
 801b84c:	eeb0 8a40 	vmov.f32	s16, s0
            rightOutTemp += tSVF_tick(&bandpass, rightOutTemp) * displayValues[4];
 801b850:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b854:	f00a fd60 	bl	8026318 <tSVF_tick>
 801b858:	edd4 7a04 	vldr	s15, [r4, #16]
 801b85c:	eea0 8a27 	vfma.f32	s16, s0, s15
            sample = tanhf(leftOut);
 801b860:	eeb0 0a68 	vmov.f32	s0, s17
 801b864:	f00f fe7e 	bl	802b564 <tanhf>
            input[0] = sample;
 801b868:	ed87 0a00 	vstr	s0, [r7]
            input[1] = tanhf(rightOutTemp);
 801b86c:	eeb0 0a48 	vmov.f32	s0, s16
 801b870:	f00f fe78 	bl	802b564 <tanhf>
 801b874:	ed87 0a01 	vstr	s0, [r7, #4]
        }
 801b878:	b003      	add	sp, #12
 801b87a:	ecbd 8b02 	vpop	{d8}
 801b87e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                tNReverb_setT60(&reverb2, 1000.0f);
 801b882:	2300      	movs	r3, #0
 801b884:	f248 2034 	movw	r0, #33332	; 0x8234
 801b888:	f2c4 437a 	movt	r3, #17530	; 0x447a
 801b88c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b890:	ee00 3a10 	vmov	s0, r3
 801b894:	f00d fd2e 	bl	80292f4 <tNReverb_setT60>
                input[1] = 0.0f;
 801b898:	2300      	movs	r3, #0
 801b89a:	607b      	str	r3, [r7, #4]
 801b89c:	e736      	b.n	801b70c <SFXReverb2Tick+0x48>
                freeze = !freeze;
 801b89e:	6833      	ldr	r3, [r6, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801b8a0:	2200      	movs	r2, #0
                freeze = !freeze;
 801b8a2:	fab3 f383 	clz	r3, r3
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801b8a6:	772a      	strb	r2, [r5, #28]
                freeze = !freeze;
 801b8a8:	095b      	lsrs	r3, r3, #5
                setLED_C(freeze);
 801b8aa:	4618      	mov	r0, r3
                freeze = !freeze;
 801b8ac:	6033      	str	r3, [r6, #0]
                setLED_C(freeze);
 801b8ae:	f7fa f83d 	bl	801592c <setLED_C>
 801b8b2:	e78c      	b.n	801b7ce <SFXReverb2Tick+0x10a>

0801b8b4 <SFXReverb2Free>:
            tNReverb_free(&reverb2);
 801b8b4:	f248 2034 	movw	r0, #33332	; 0x8234
        {
 801b8b8:	b508      	push	{r3, lr}
            tNReverb_free(&reverb2);
 801b8ba:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b8be:	f00d fcfd 	bl	80292bc <tNReverb_free>
            tSVF_free(&lowpass);
 801b8c2:	f642 1048 	movw	r0, #10568	; 0x2948
 801b8c6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801b8ca:	f00a fd21 	bl	8026310 <tSVF_free>
            tSVF_free(&highpass);
 801b8ce:	f248 1044 	movw	r0, #33092	; 0x8144
 801b8d2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b8d6:	f00a fd1b 	bl	8026310 <tSVF_free>
            tSVF_free(&bandpass);
 801b8da:	f247 600c 	movw	r0, #30220	; 0x760c
 801b8de:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b8e2:	f00a fd15 	bl	8026310 <tSVF_free>
            tSVF_free(&lowpass2);
 801b8e6:	f247 2060 	movw	r0, #29280	; 0x7260
 801b8ea:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b8ee:	f00a fd0f 	bl	8026310 <tSVF_free>
            tSVF_free(&highpass2);
 801b8f2:	f247 500c 	movw	r0, #29964	; 0x750c
 801b8f6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b8fa:	f00a fd09 	bl	8026310 <tSVF_free>
            tSVF_free(&bandpass2);
 801b8fe:	f247 50ec 	movw	r0, #30188	; 0x75ec
        }
 801b902:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            tSVF_free(&bandpass2);
 801b906:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b90a:	f00a bd01 	b.w	8026310 <tSVF_free>
 801b90e:	bf00      	nop

0801b910 <SFXLivingStringAlloc>:
        {
 801b910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            levMode = 0;
 801b914:	f240 56a0 	movw	r6, #1440	; 0x5a0
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801b918:	f247 5020 	movw	r0, #29984	; 0x7520
            levMode = 0;
 801b91c:	2400      	movs	r4, #0
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b91e:	f649 179a 	movw	r7, #39322	; 0x999a
            levMode = 0;
 801b922:	f2c2 0600 	movt	r6, #8192	; 0x2000
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801b926:	2106      	movs	r1, #6
 801b928:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801b92c:	f642 0568 	movw	r5, #10344	; 0x2868
            levMode = 0;
 801b930:	6034      	str	r4, [r6, #0]
 801b932:	f249 49a0 	movw	r9, #38048	; 0x94a0
 801b936:	f242 6870 	movw	r8, #9840	; 0x2670
 801b93a:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801b93e:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801b942:	f2c2 0800 	movt	r8, #8192	; 0x2000
        {
 801b946:	ed2d 8b06 	vpush	{d8-d10}
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801b94a:	f00c febb 	bl	80286c4 <tSimplePoly_setNumVoices>
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b94e:	4638      	mov	r0, r7
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b950:	f24d 710a 	movw	r1, #55050	; 0xd70a
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b954:	f6c3 6799 	movt	r7, #16025	; 0x3e99
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b958:	f44f 4320 	mov.w	r3, #40960	; 0xa000
 801b95c:	f64c 42cd 	movw	r2, #52429	; 0xcccd
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b960:	f6cb 6019 	movt	r0, #48665	; 0xbe19
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b964:	f6c3 4123 	movt	r1, #15395	; 0x3c23
 801b968:	f2c4 630c 	movt	r3, #17932	; 0x460c
 801b96c:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b970:	ee0a 7a90 	vmov	s21, r7
 801b974:	f247 0728 	movw	r7, #28712	; 0x7028
 801b978:	ee0a 0a10 	vmov	s20, r0
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b97c:	ee09 1a90 	vmov	s19, r1
 801b980:	ee09 3a10 	vmov	s18, r3
 801b984:	ee08 2a90 	vmov	s17, r2
 801b988:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801b98c:	ee08 4a10 	vmov	s16, r4
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b990:	f8d9 3010 	ldr.w	r3, [r9, #16]
 801b994:	4798      	blx	r3
 801b996:	eef0 7a4a 	vmov.f32	s15, s20
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b99a:	f649 129a 	movw	r2, #39322	; 0x999a
 801b99e:	2300      	movs	r3, #0
 801b9a0:	eb08 0004 	add.w	r0, r8, r4
 801b9a4:	6831      	ldr	r1, [r6, #0]
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b9a6:	eee0 7a2a 	vfma.f32	s15, s0, s21
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b9aa:	f6c3 6299 	movt	r2, #16025	; 0x3e99
 801b9ae:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
 801b9b2:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
 801b9b6:	ee03 2a10 	vmov	s6, r2
 801b9ba:	eef0 3a69 	vmov.f32	s7, s19
 801b9be:	ee00 3a10 	vmov	s0, r3
 801b9c2:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
 801b9c6:	ee01 2a10 	vmov	s2, r2
 801b9ca:	eeb0 2a49 	vmov.f32	s4, s18
 801b9ce:	eef0 1a48 	vmov.f32	s3, s16
 801b9d2:	eef0 0a68 	vmov.f32	s1, s17
                myDetune[i] = (leaf.random() * 0.3f) - 0.15f;
 801b9d6:	ece5 7a01 	vstmia	r5!, {s15}
                tComplexLivingString_init(&theString[i], 440.f, 0.8f, 0.3f, 0.f, 9000.f, 1.0f, 0.3f, 0.01f, 0.125f, levMode);
 801b9da:	f00d f98b 	bl	8028cf4 <tComplexLivingString_init>
                tExpSmooth_initToPool(&stringGains[i], 0.0f, 0.002f, &smallPool);
 801b9de:	f241 236f 	movw	r3, #4719	; 0x126f
 801b9e2:	f248 21f8 	movw	r1, #33528	; 0x82f8
 801b9e6:	1938      	adds	r0, r7, r4
 801b9e8:	f6c3 3303 	movt	r3, #15107	; 0x3b03
 801b9ec:	3404      	adds	r4, #4
 801b9ee:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801b9f2:	eeb0 0a48 	vmov.f32	s0, s16
 801b9f6:	ee00 3a90 	vmov	s1, r3
 801b9fa:	f00a fa8d 	bl	8025f18 <tExpSmooth_initToPool>
            for (int i = 0; i < NUM_STRINGS; i++)
 801b9fe:	2c18      	cmp	r4, #24
 801ba00:	d1c6      	bne.n	801b990 <SFXLivingStringAlloc+0x80>
            ignoreFreqKnobs = 0;
 801ba02:	f240 5394 	movw	r3, #1428	; 0x594
 801ba06:	2200      	movs	r2, #0
 801ba08:	f2c2 0300 	movt	r3, #8192	; 0x2000
            setLED_A(ignoreFreqKnobs);
 801ba0c:	4610      	mov	r0, r2
            ignoreFreqKnobs = 0;
 801ba0e:	601a      	str	r2, [r3, #0]
            setLED_A(ignoreFreqKnobs);
 801ba10:	f7f9 ff6c 	bl	80158ec <setLED_A>
            setLED_B(independentStrings);
 801ba14:	f240 5398 	movw	r3, #1432	; 0x598
 801ba18:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ba1c:	7818      	ldrb	r0, [r3, #0]
 801ba1e:	f7f9 ff75 	bl	801590c <setLED_B>
            setLED_C(levMode);
 801ba22:	7830      	ldrb	r0, [r6, #0]
        }
 801ba24:	ecbd 8b06 	vpop	{d8-d10}
 801ba28:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            setLED_C(levMode);
 801ba2c:	f7f9 bf7e 	b.w	801592c <setLED_C>

0801ba30 <SFXLivingStringFrame>:
        {
 801ba30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801ba34:	f248 65e4 	movw	r5, #34532	; 0x86e4
 801ba38:	f2c2 0501 	movt	r5, #8193	; 0x2001
        {
 801ba3c:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801ba40:	7d2a      	ldrb	r2, [r5, #20]
        {
 801ba42:	b087      	sub	sp, #28
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801ba44:	2a01      	cmp	r2, #1
 801ba46:	f000 8243 	beq.w	801bed0 <SFXLivingStringFrame+0x4a0>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 801ba4a:	7f2a      	ldrb	r2, [r5, #28]
 801ba4c:	2a01      	cmp	r2, #1
 801ba4e:	f000 818a 	beq.w	801bd66 <SFXLivingStringFrame+0x336>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801ba52:	7e2a      	ldrb	r2, [r5, #24]
 801ba54:	f242 6770 	movw	r7, #9840	; 0x2670
                independentStrings = !independentStrings;
 801ba58:	f240 5698 	movw	r6, #1432	; 0x598
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801ba5c:	2a01      	cmp	r2, #1
 801ba5e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801ba62:	f000 81a5 	beq.w	801bdb0 <SFXLivingStringFrame+0x380>
 801ba66:	f2c2 0600 	movt	r6, #8192	; 0x2000
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801ba6a:	f243 2588 	movw	r5, #12936	; 0x3288
 801ba6e:	2300      	movs	r3, #0
 801ba70:	f248 7494 	movw	r4, #34708	; 0x8794
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801ba74:	f641 6ab8 	movw	sl, #7864	; 0x1eb8
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801ba78:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801ba7c:	f2c4 23b4 	movt	r3, #17076	; 0x42b4
 801ba80:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801ba84:	f647 29e1 	movw	r9, #31457	; 0x7ae1
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801ba88:	462a      	mov	r2, r5
 801ba8a:	ee08 3a90 	vmov	s17, r3
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801ba8e:	f64b 0b51 	movw	fp, #47185	; 0xb851
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801ba92:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801ba96:	ecb2 0a01 	vldmia	r2!, {s0}
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801ba9a:	f6ce 3a85 	movt	sl, #60293	; 0xeb85
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801ba9e:	f6c3 7994 	movt	r9, #16276	; 0x3f94
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801baa2:	f6c3 7bde 	movt	fp, #16350	; 0x3fde
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801baa6:	ee20 0a28 	vmul.f32	s0, s0, s17
 801baaa:	9200      	str	r2, [sp, #0]
 801baac:	f00c f86e 	bl	8027b8c <LEAF_midiToFrequency>
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 801bab0:	2300      	movs	r3, #0
 801bab2:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
 801bab6:	edd5 6a03 	vldr	s13, [r5, #12]
 801baba:	f2c4 3302 	movt	r3, #17154	; 0x4302
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
 801babe:	9a00      	ldr	r2, [sp, #0]
            displayValues[0] = LEAF_midiToFrequency((presetKnobValues[LivingString][0] * 90.0f)); //freq
 801bac0:	ed84 0a00 	vstr	s0, [r4]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801bac4:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 801bac8:	ee07 3a90 	vmov	s15, r3
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
 801bacc:	6812      	ldr	r2, [r2, #0]
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
 801bace:	68ab      	ldr	r3, [r5, #8]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 801bad0:	eea6 7aa7 	vfma.f32	s14, s13, s15
            displayValues[1] = presetKnobValues[LivingString][1]; //detune
 801bad4:	6062      	str	r2, [r4, #4]
            displayValues[2] = presetKnobValues[LivingString][2]; //decay
 801bad6:	60a3      	str	r3, [r4, #8]
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 801bad8:	eeb0 0a47 	vmov.f32	s0, s14
 801badc:	f00c f8bc 	bl	8027c58 <mtof>
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801bae0:	ed95 3a04 	vldr	s6, [r5, #16]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801bae4:	ed95 4a05 	vldr	s8, [r5, #20]
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801bae8:	eeb6 5b00 	vmov.f64	d5, #96	; 0x3f000000  0.5
 801baec:	eeb7 3ac3 	vcvt.f64.f32	d3, s6
            displayValues[3] = mtof((presetKnobValues[LivingString][3] * 130.0f)+12.0f); //lowpass
 801baf0:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801baf4:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801baf8:	ed95 2a06 	vldr	s4, [r5, #24]
 801bafc:	eef2 2a00 	vmov.f32	s5, #32	; 0x41000000  8.0
 801bb00:	eeb9 0a00 	vmov.f32	s0, #144	; 0xc0800000 -4.0
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801bb04:	ec4b ab16 	vmov	d6, sl, fp
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801bb08:	ec49 8b17 	vmov	d7, r8, r9
 801bb0c:	eea4 7b06 	vfma.f64	d7, d4, d6
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801bb10:	eea3 5b06 	vfma.f64	d5, d3, d6
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801bb14:	eea2 0a22 	vfma.f32	s0, s4, s5
            displayValues[5] = (presetKnobValues[LivingString][5] * 0.48) + 0.02f;//prepPos
 801bb18:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
 801bb1c:	ed84 7a05 	vstr	s14, [r4, #20]
            displayValues[4] = (presetKnobValues[LivingString][4] * 0.48) + 0.5f;//pickPos
 801bb20:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
 801bb24:	ed84 5a04 	vstr	s10, [r4, #16]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801bb28:	f00f fd1c 	bl	802b564 <tanhf>
 801bb2c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
 801bb30:	69eb      	ldr	r3, [r5, #28]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801bb32:	ee30 0a08 	vadd.f32	s0, s0, s16
            if (!independentStrings)
 801bb36:	6836      	ldr	r6, [r6, #0]
            displayValues[7] = presetKnobValues[LivingString][7];// let ring
 801bb38:	61e3      	str	r3, [r4, #28]
            displayValues[6] = ((tanhf((presetKnobValues[LivingString][6] * 8.0f) - 4.0f)) * 0.5f) + 0.5f;//prep Index
 801bb3a:	ee20 0a27 	vmul.f32	s0, s0, s15
 801bb3e:	ed84 0a06 	vstr	s0, [r4, #24]
            if (!independentStrings)
 801bb42:	2e00      	cmp	r6, #0
 801bb44:	f040 8141 	bne.w	801bdca <SFXLivingStringFrame+0x39a>
                if (!ignoreFreqKnobs)
 801bb48:	f240 5394 	movw	r3, #1428	; 0x594
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bb4c:	f24c 228f 	movw	r2, #49807	; 0xc28f
                if (!ignoreFreqKnobs)
 801bb50:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bb54:	f8d3 9000 	ldr.w	r9, [r3]
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bb58:	f64b 0352 	movw	r3, #47186	; 0xb852
                if (!ignoreFreqKnobs)
 801bb5c:	f1b9 0f00 	cmp.w	r9, #0
 801bb60:	f000 80ac 	beq.w	801bcbc <SFXLivingStringFrame+0x28c>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bb64:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
 801bb68:	f642 0168 	movw	r1, #10344	; 0x2868
 801bb6c:	f247 0828 	movw	r8, #28712	; 0x7028
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bb70:	f64a 2cab 	movw	ip, #43691	; 0xaaab
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bb74:	ee08 3a90 	vmov	s17, r3
 801bb78:	460b      	mov	r3, r1
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801bb7a:	f247 5120 	movw	r1, #29984	; 0x7520
 801bb7e:	f243 4a3c 	movw	sl, #13372	; 0x343c
 801bb82:	f2c2 0300 	movt	r3, #8192	; 0x2000
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bb86:	f6c3 4275 	movt	r2, #15477	; 0x3c75
 801bb8a:	f240 5bd8 	movw	fp, #1496	; 0x5d8
 801bb8e:	f240 6020 	movw	r0, #1568	; 0x620
 801bb92:	9300      	str	r3, [sp, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801bb94:	460b      	mov	r3, r1
 801bb96:	f240 6554 	movw	r5, #1620	; 0x654
 801bb9a:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801bb9e:	f2c2 0301 	movt	r3, #8193	; 0x2001
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bba2:	4661      	mov	r1, ip
 801bba4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801bba8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801bbac:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bbb0:	ee09 2a10 	vmov	s18, r2
 801bbb4:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801bbb8:	f2c2 0b00 	movt	fp, #8192	; 0x2000
                if (!ignoreFreqKnobs)
 801bbbc:	46b1      	mov	r9, r6
 801bbbe:	9002      	str	r0, [sp, #8]
 801bbc0:	9503      	str	r5, [sp, #12]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bbc2:	9101      	str	r1, [sp, #4]
                if (!ignoreFreqKnobs)
 801bbc4:	e9cd 8704 	strd	r8, r7, [sp, #16]
 801bbc8:	461f      	mov	r7, r3
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801bbca:	fa5f f889 	uxtb.w	r8, r9
 801bbce:	9b05      	ldr	r3, [sp, #20]
 801bbd0:	4638      	mov	r0, r7
 801bbd2:	4641      	mov	r1, r8
 801bbd4:	199d      	adds	r5, r3, r6
 801bbd6:	f00c fd99 	bl	802870c <tSimplePoly_getPitch>
 801bbda:	ee07 0a90 	vmov	s15, r0
 801bbde:	ed9b 0a00 	vldr	s0, [fp]
 801bbe2:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bbe6:	9b03      	ldr	r3, [sp, #12]
 801bbe8:	7818      	ldrb	r0, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801bbea:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bbee:	9b01      	ldr	r3, [sp, #4]
 801bbf0:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801bbf4:	ee17 1a90 	vmov	r1, s15
 801bbf8:	1a09      	subs	r1, r1, r0
 801bbfa:	fb83 3c01 	smull	r3, ip, r3, r1
 801bbfe:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801bc00:	9b02      	ldr	r3, [sp, #8]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801bc02:	ebc0 006c 	rsb	r0, r0, ip, asr #1
 801bc06:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801bc0a:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
 801bc0e:	ee07 0a90 	vmov	s15, r0
 801bc12:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801bc16:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801bc1a:	ee17 1a90 	vmov	r1, s15
 801bc1e:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 801bc22:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801bc26:	ee37 0a00 	vadd.f32	s0, s14, s0
 801bc2a:	f00b ffaf 	bl	8027b8c <LEAF_midiToFrequency>
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bc2e:	9b00      	ldr	r3, [sp, #0]
 801bc30:	eef0 6a48 	vmov.f32	s13, s16
 801bc34:	edd4 7a01 	vldr	s15, [r4, #4]
 801bc38:	ecb3 7a01 	vldmia	r3!, {s14}
 801bc3c:	4628      	mov	r0, r5
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801bc3e:	ecaa 0a01 	vstmia	sl!, {s0}
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bc42:	eee7 6a27 	vfma.f32	s13, s14, s15
 801bc46:	9300      	str	r3, [sp, #0]
 801bc48:	ee26 0a80 	vmul.f32	s0, s13, s0
 801bc4c:	f00d f8a4 	bl	8028d98 <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bc50:	eeb0 0a68 	vmov.f32	s0, s17
 801bc54:	edd4 7a02 	vldr	s15, [r4, #8]
 801bc58:	4628      	mov	r0, r5
 801bc5a:	eea7 0a89 	vfma.f32	s0, s15, s18
 801bc5e:	f00d f905 	bl	8028e6c <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 801bc62:	4628      	mov	r0, r5
 801bc64:	ed94 0a03 	vldr	s0, [r4, #12]
 801bc68:	f00d f8e0 	bl	8028e2c <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 801bc6c:	4628      	mov	r0, r5
 801bc6e:	ed94 0a04 	vldr	s0, [r4, #16]
 801bc72:	f00d f8ad 	bl	8028dd0 <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 801bc76:	4628      	mov	r0, r5
 801bc78:	ed94 0a05 	vldr	s0, [r4, #20]
 801bc7c:	f00d f8b8 	bl	8028df0 <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 801bc80:	ed94 0a06 	vldr	s0, [r4, #24]
 801bc84:	4628      	mov	r0, r5
 801bc86:	f00d f8c3 	bl	8028e10 <tComplexLivingString_setPrepIndex>
                        if (tSimplePoly_isOn(&poly, i))
 801bc8a:	4641      	mov	r1, r8
 801bc8c:	4638      	mov	r0, r7
 801bc8e:	f00c fd4f 	bl	8028730 <tSimplePoly_isOn>
 801bc92:	9b04      	ldr	r3, [sp, #16]
                            tExpSmooth_setDest(&stringGains[i], 1.0f);
 801bc94:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801bc98:	1999      	adds	r1, r3, r6
                        if (tSimplePoly_isOn(&poly, i))
 801bc9a:	b908      	cbnz	r0, 801bca0 <SFXLivingStringFrame+0x270>
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
 801bc9c:	ed94 0a07 	vldr	s0, [r4, #28]
                    for (int i = 0; i < NUM_STRINGS; i++)
 801bca0:	f109 0901 	add.w	r9, r9, #1
                            tExpSmooth_setDest(&stringGains[i], displayValues[7]);
 801bca4:	4608      	mov	r0, r1
 801bca6:	f00a f973 	bl	8025f90 <tExpSmooth_setDest>
 801bcaa:	3604      	adds	r6, #4
                    for (int i = 0; i < NUM_STRINGS; i++)
 801bcac:	f1b9 0f06 	cmp.w	r9, #6
 801bcb0:	d18b      	bne.n	801bbca <SFXLivingStringFrame+0x19a>
        }
 801bcb2:	b007      	add	sp, #28
 801bcb4:	ecbd 8b04 	vpop	{d8-d9}
 801bcb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801bcbc:	f642 0a68 	movw	sl, #10344	; 0x2868
 801bcc0:	f247 0828 	movw	r8, #28712	; 0x7028
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bcc4:	f6c3 4275 	movt	r2, #15477	; 0x3c75
 801bcc8:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
 801bccc:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801bcd0:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801bcd4:	ee09 2a10 	vmov	s18, r2
 801bcd8:	ee08 3a90 	vmov	s17, r3
                if (!ignoreFreqKnobs)
 801bcdc:	464e      	mov	r6, r9
                        float freqVal = displayValues[0] * (i+1);
 801bcde:	f109 0901 	add.w	r9, r9, #1
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bce2:	eeb0 0a48 	vmov.f32	s0, s16
 801bce6:	ecba 6a01 	vldmia	sl!, {s12}
 801bcea:	19bd      	adds	r5, r7, r6
 801bcec:	edd4 6a01 	vldr	s13, [r4, #4]
                        float freqVal = displayValues[0] * (i+1);
 801bcf0:	ee07 9a90 	vmov	s15, r9
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bcf4:	4628      	mov	r0, r5
                        float freqVal = displayValues[0] * (i+1);
 801bcf6:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801bcfa:	edd4 7a00 	vldr	s15, [r4]
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bcfe:	eea6 0a26 	vfma.f32	s0, s12, s13
                        float freqVal = displayValues[0] * (i+1);
 801bd02:	ee67 7a27 	vmul.f32	s15, s14, s15
                        tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801bd06:	ee27 0a80 	vmul.f32	s0, s15, s0
 801bd0a:	f00d f845 	bl	8028d98 <tComplexLivingString_setFreq>
                        tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801bd0e:	eeb0 0a68 	vmov.f32	s0, s17
 801bd12:	edd4 7a02 	vldr	s15, [r4, #8]
 801bd16:	4628      	mov	r0, r5
 801bd18:	eea7 0a89 	vfma.f32	s0, s15, s18
 801bd1c:	f00d f8a6 	bl	8028e6c <tComplexLivingString_setDecay>
                        tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 801bd20:	4628      	mov	r0, r5
 801bd22:	ed94 0a03 	vldr	s0, [r4, #12]
 801bd26:	f00d f881 	bl	8028e2c <tComplexLivingString_setDampFreq>
                        tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 801bd2a:	4628      	mov	r0, r5
 801bd2c:	ed94 0a04 	vldr	s0, [r4, #16]
 801bd30:	f00d f84e 	bl	8028dd0 <tComplexLivingString_setPickPos>
                        tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 801bd34:	4628      	mov	r0, r5
 801bd36:	ed94 0a05 	vldr	s0, [r4, #20]
 801bd3a:	f00d f859 	bl	8028df0 <tComplexLivingString_setPrepPos>
                        tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 801bd3e:	4628      	mov	r0, r5
 801bd40:	ed94 0a06 	vldr	s0, [r4, #24]
 801bd44:	f00d f864 	bl	8028e10 <tComplexLivingString_setPrepIndex>
                        tExpSmooth_setDest(&stringGains[i], 1.0f);
 801bd48:	eb08 0006 	add.w	r0, r8, r6
 801bd4c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801bd50:	3604      	adds	r6, #4
 801bd52:	f00a f91d 	bl	8025f90 <tExpSmooth_setDest>
                    for (int i = 0; i < NUM_STRINGS; i++)
 801bd56:	f1b9 0f06 	cmp.w	r9, #6
 801bd5a:	d1c0      	bne.n	801bcde <SFXLivingStringFrame+0x2ae>
        }
 801bd5c:	b007      	add	sp, #28
 801bd5e:	ecbd 8b04 	vpop	{d8-d9}
 801bd62:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levMode = !levMode;
 801bd66:	f240 56a0 	movw	r6, #1440	; 0x5a0
 801bd6a:	f242 6770 	movw	r7, #9840	; 0x2670
 801bd6e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801bd72:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801bd76:	6831      	ldr	r1, [r6, #0]
 801bd78:	463c      	mov	r4, r7
 801bd7a:	fab1 f181 	clz	r1, r1
 801bd7e:	0949      	lsrs	r1, r1, #5
 801bd80:	6031      	str	r1, [r6, #0]
 801bd82:	e000      	b.n	801bd86 <SFXLivingStringFrame+0x356>
 801bd84:	6831      	ldr	r1, [r6, #0]
                    tComplexLivingString_setLevMode(&theString[i], levMode);
 801bd86:	4620      	mov	r0, r4
 801bd88:	3404      	adds	r4, #4
 801bd8a:	f00d f887 	bl	8028e9c <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
 801bd8e:	f242 6388 	movw	r3, #9864	; 0x2688
 801bd92:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801bd96:	429c      	cmp	r4, r3
 801bd98:	d1f4      	bne.n	801bd84 <SFXLivingStringFrame+0x354>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801bd9a:	2200      	movs	r2, #0
                setLED_C(levMode);
 801bd9c:	7830      	ldrb	r0, [r6, #0]
                independentStrings = !independentStrings;
 801bd9e:	f240 5698 	movw	r6, #1432	; 0x598
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801bda2:	772a      	strb	r2, [r5, #28]
                setLED_C(levMode);
 801bda4:	f7f9 fdc2 	bl	801592c <setLED_C>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801bda8:	7e2a      	ldrb	r2, [r5, #24]
 801bdaa:	2a01      	cmp	r2, #1
 801bdac:	f47f ae5b 	bne.w	801ba66 <SFXLivingStringFrame+0x36>
                independentStrings = !independentStrings;
 801bdb0:	f2c2 0600 	movt	r6, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801bdb4:	2200      	movs	r2, #0
                independentStrings = !independentStrings;
 801bdb6:	6833      	ldr	r3, [r6, #0]
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801bdb8:	762a      	strb	r2, [r5, #24]
                independentStrings = !independentStrings;
 801bdba:	fab3 f383 	clz	r3, r3
 801bdbe:	095b      	lsrs	r3, r3, #5
                setLED_B(independentStrings);
 801bdc0:	4618      	mov	r0, r3
                independentStrings = !independentStrings;
 801bdc2:	6033      	str	r3, [r6, #0]
                setLED_B(independentStrings);
 801bdc4:	f7f9 fda2 	bl	801590c <setLED_B>
 801bdc8:	e64f      	b.n	801ba6a <SFXLivingStringFrame+0x3a>
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 801bdca:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
 801bdce:	f642 0b68 	movw	fp, #10344	; 0x2868
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 801bdd2:	f04f 0a00 	mov.w	sl, #0
 801bdd6:	f247 0828 	movw	r8, #28712	; 0x7028
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 801bdda:	ee20 0a28 	vmul.f32	s0, s0, s17
 801bdde:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801bde2:	f00b fed3 	bl	8027b8c <LEAF_midiToFrequency>
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 801bde6:	edd5 7a0b 	vldr	s15, [r5, #44]	; 0x2c
                displayValues[10] = LEAF_midiToFrequency((presetKnobValues[LivingString][10] * 90.0f)); //freq
 801bdea:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
                for (int i = 0; i < NUM_STRINGS; i++)
 801bdee:	4656      	mov	r6, sl
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 801bdf0:	ee27 0aa8 	vmul.f32	s0, s15, s17
 801bdf4:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801bdf8:	f00b fec8 	bl	8027b8c <LEAF_midiToFrequency>
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 801bdfc:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
                displayValues[11] = LEAF_midiToFrequency((presetKnobValues[LivingString][11] * 90.0f)); //freq
 801be00:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
 801be04:	f104 0924 	add.w	r9, r4, #36	; 0x24
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 801be08:	ee27 0aa8 	vmul.f32	s0, s15, s17
 801be0c:	f00b febe 	bl	8027b8c <LEAF_midiToFrequency>
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 801be10:	edd5 7a0d 	vldr	s15, [r5, #52]	; 0x34
                displayValues[12] = LEAF_midiToFrequency((presetKnobValues[LivingString][12] * 90.0f)); //freq
 801be14:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 801be18:	ee27 0aa8 	vmul.f32	s0, s15, s17
 801be1c:	f00b feb6 	bl	8027b8c <LEAF_midiToFrequency>
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 801be20:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
                displayValues[13] = LEAF_midiToFrequency((presetKnobValues[LivingString][13] * 90.0f)); //freq
 801be24:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 801be28:	ee27 0aa8 	vmul.f32	s0, s15, s17
 801be2c:	f00b feae 	bl	8027b8c <LEAF_midiToFrequency>
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801be30:	f24c 228f 	movw	r2, #49807	; 0xc28f
 801be34:	f64b 0352 	movw	r3, #47186	; 0xb852
                displayValues[14] = LEAF_midiToFrequency((presetKnobValues[LivingString][14] * 90.0f)); //freq
 801be38:	ed84 0a0e 	vstr	s0, [r4, #56]	; 0x38
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801be3c:	f6c3 4275 	movt	r2, #15477	; 0x3c75
 801be40:	f6c3 737e 	movt	r3, #16254	; 0x3f7e
 801be44:	ee09 2a10 	vmov	s18, r2
 801be48:	ee08 3a90 	vmov	s17, r3
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
 801be4c:	2e00      	cmp	r6, #0
 801be4e:	d04e      	beq.n	801beee <SFXLivingStringFrame+0x4be>
 801be50:	edd9 7a00 	vldr	s15, [r9]
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801be54:	eeb0 0a48 	vmov.f32	s0, s16
 801be58:	ecfb 6a01 	vldmia	fp!, {s13}
 801be5c:	ed94 7a01 	vldr	s14, [r4, #4]
 801be60:	eb07 050a 	add.w	r5, r7, sl
                for (int i = 0; i < NUM_STRINGS; i++)
 801be64:	3601      	adds	r6, #1
 801be66:	f109 0904 	add.w	r9, r9, #4
                    tComplexLivingString_setFreq(&theString[i], (1.0f + (myDetune[i] * displayValues[1])) * freqVal);
 801be6a:	eea6 0a87 	vfma.f32	s0, s13, s14
 801be6e:	4628      	mov	r0, r5
 801be70:	ee20 0a27 	vmul.f32	s0, s0, s15
 801be74:	f00c ff90 	bl	8028d98 <tComplexLivingString_setFreq>
                    tComplexLivingString_setDecay(&theString[i], (displayValues[2] * 0.015f) + 0.995f);
 801be78:	eeb0 0a68 	vmov.f32	s0, s17
 801be7c:	edd4 7a02 	vldr	s15, [r4, #8]
 801be80:	4628      	mov	r0, r5
 801be82:	eea7 0a89 	vfma.f32	s0, s15, s18
 801be86:	f00c fff1 	bl	8028e6c <tComplexLivingString_setDecay>
                    tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 801be8a:	4628      	mov	r0, r5
 801be8c:	ed94 0a03 	vldr	s0, [r4, #12]
 801be90:	f00c ffcc 	bl	8028e2c <tComplexLivingString_setDampFreq>
                    tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 801be94:	4628      	mov	r0, r5
 801be96:	ed94 0a04 	vldr	s0, [r4, #16]
 801be9a:	f00c ff99 	bl	8028dd0 <tComplexLivingString_setPickPos>
                    tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 801be9e:	4628      	mov	r0, r5
 801bea0:	ed94 0a05 	vldr	s0, [r4, #20]
 801bea4:	f00c ffa4 	bl	8028df0 <tComplexLivingString_setPrepPos>
                    tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 801bea8:	4628      	mov	r0, r5
 801beaa:	ed94 0a06 	vldr	s0, [r4, #24]
 801beae:	f00c ffaf 	bl	8028e10 <tComplexLivingString_setPrepIndex>
                    tExpSmooth_setDest(&stringGains[i], 1.0f);
 801beb2:	eb08 000a 	add.w	r0, r8, sl
 801beb6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801beba:	f10a 0a04 	add.w	sl, sl, #4
 801bebe:	f00a f867 	bl	8025f90 <tExpSmooth_setDest>
                for (int i = 0; i < NUM_STRINGS; i++)
 801bec2:	2e06      	cmp	r6, #6
 801bec4:	d1c2      	bne.n	801be4c <SFXLivingStringFrame+0x41c>
        }
 801bec6:	b007      	add	sp, #28
 801bec8:	ecbd 8b04 	vpop	{d8-d9}
 801becc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                ignoreFreqKnobs = !ignoreFreqKnobs;
 801bed0:	f240 5194 	movw	r1, #1428	; 0x594
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801bed4:	2200      	movs	r2, #0
                ignoreFreqKnobs = !ignoreFreqKnobs;
 801bed6:	f2c2 0100 	movt	r1, #8192	; 0x2000
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801beda:	752a      	strb	r2, [r5, #20]
                ignoreFreqKnobs = !ignoreFreqKnobs;
 801bedc:	680a      	ldr	r2, [r1, #0]
 801bede:	fab2 f282 	clz	r2, r2
 801bee2:	0952      	lsrs	r2, r2, #5
                setLED_A(ignoreFreqKnobs);
 801bee4:	4610      	mov	r0, r2
                ignoreFreqKnobs = !ignoreFreqKnobs;
 801bee6:	600a      	str	r2, [r1, #0]
                setLED_A(ignoreFreqKnobs);
 801bee8:	f7f9 fd00 	bl	80158ec <setLED_A>
 801beec:	e5ad      	b.n	801ba4a <SFXLivingStringFrame+0x1a>
                    float freqVal = i == 0 ? displayValues[0] : displayValues[9+i];
 801beee:	edd4 7a00 	vldr	s15, [r4]
 801bef2:	e7af      	b.n	801be54 <SFXLivingStringFrame+0x424>

0801bef4 <SFXLivingStringTick>:
        {
 801bef4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
            float sample = 0.0f;
 801bef6:	2300      	movs	r3, #0
 801bef8:	f242 6770 	movw	r7, #9840	; 0x2670
 801befc:	f247 0628 	movw	r6, #28712	; 0x7028
        {
 801bf00:	4605      	mov	r5, r0
 801bf02:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801bf06:	461c      	mov	r4, r3
 801bf08:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801bf0c:	ed2d 8b02 	vpush	{d8}
            float sample = 0.0f;
 801bf10:	ee08 3a10 	vmov	s16, r3
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
 801bf14:	1938      	adds	r0, r7, r4
 801bf16:	ed95 0a01 	vldr	s0, [r5, #4]
 801bf1a:	f00c ffd5 	bl	8028ec8 <tComplexLivingString_tick>
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 801bf1e:	1930      	adds	r0, r6, r4
 801bf20:	3404      	adds	r4, #4
                float tick = tComplexLivingString_tick(&theString[i], input[1]);
 801bf22:	eef0 8a40 	vmov.f32	s17, s0
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 801bf26:	f00a f83d 	bl	8025fa4 <tExpSmooth_tick>
            for (int i = 0; i < NUM_STRINGS; i++)
 801bf2a:	2c18      	cmp	r4, #24
                sample += tick * tExpSmooth_tick(&stringGains[i]);
 801bf2c:	eea0 8a28 	vfma.f32	s16, s0, s17
            for (int i = 0; i < NUM_STRINGS; i++)
 801bf30:	d1f0      	bne.n	801bf14 <SFXLivingStringTick+0x20>
            sample *= 0.1625f;
 801bf32:	f246 6366 	movw	r3, #26214	; 0x6666
 801bf36:	f6c3 6326 	movt	r3, #15910	; 0x3e26
 801bf3a:	ee07 3a90 	vmov	s15, r3
 801bf3e:	ee28 8a27 	vmul.f32	s16, s16, s15
            input[0] = sample;
 801bf42:	ed85 8a00 	vstr	s16, [r5]
            input[1] = sample;
 801bf46:	ed85 8a01 	vstr	s16, [r5, #4]
        }
 801bf4a:	ecbd 8b02 	vpop	{d8}
 801bf4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0801bf50 <SFXLivingStringFree>:
        {
 801bf50:	b570      	push	{r4, r5, r6, lr}
 801bf52:	f242 6670 	movw	r6, #9840	; 0x2670
 801bf56:	f247 0528 	movw	r5, #28712	; 0x7028
 801bf5a:	2400      	movs	r4, #0
 801bf5c:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801bf60:	f2c2 0501 	movt	r5, #8193	; 0x2001
                tComplexLivingString_free(&theString[i]);
 801bf64:	1930      	adds	r0, r6, r4
 801bf66:	f00c fecb 	bl	8028d00 <tComplexLivingString_free>
                tExpSmooth_free(&stringGains[i]);
 801bf6a:	1928      	adds	r0, r5, r4
 801bf6c:	3404      	adds	r4, #4
 801bf6e:	f009 fff9 	bl	8025f64 <tExpSmooth_free>
            for (int i = 0; i < NUM_STRINGS; i++)
 801bf72:	2c18      	cmp	r4, #24
 801bf74:	d1f6      	bne.n	801bf64 <SFXLivingStringFree+0x14>
        }
 801bf76:	bd70      	pop	{r4, r5, r6, pc}

0801bf78 <SFXLivingStringSynthAlloc>:
        {
 801bf78:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            levMode = 1;
 801bf7c:	f240 53a0 	movw	r3, #1440	; 0x5a0
            leaf.clearOnAllocation = 0;
 801bf80:	f249 4ba0 	movw	fp, #38048	; 0x94a0
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801bf84:	f247 5020 	movw	r0, #29984	; 0x7520
            levMode = 1;
 801bf88:	2201      	movs	r2, #1
 801bf8a:	f2c2 0300 	movt	r3, #8192	; 0x2000
            leaf.clearOnAllocation = 0;
 801bf8e:	2400      	movs	r4, #0
 801bf90:	f2c2 0b01 	movt	fp, #8193	; 0x2001
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801bf94:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801bf98:	2106      	movs	r1, #6
 801bf9a:	f240 56a4 	movw	r6, #1444	; 0x5a4
            leaf.clearOnAllocation = 0;
 801bf9e:	f8cb 4014 	str.w	r4, [fp, #20]
 801bfa2:	f242 6a70 	movw	sl, #9840	; 0x2670
 801bfa6:	f247 59f4 	movw	r9, #30196	; 0x75f4
 801bfaa:	f247 68bc 	movw	r8, #30396	; 0x76bc
 801bfae:	f247 4708 	movw	r7, #29704	; 0x7408
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
 801bfb2:	f248 25f8 	movw	r5, #33528	; 0x82f8
 801bfb6:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801bfba:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801bfbe:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801bfc2:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801bfc6:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801bfca:	f2c2 0501 	movt	r5, #8193	; 0x2001
        {
 801bfce:	ed2d 8b06 	vpush	{d8-d10}
            levMode = 1;
 801bfd2:	601a      	str	r2, [r3, #0]
            tSimplePoly_setNumVoices(&poly, NUM_STRINGS);
 801bfd4:	f00c fb76 	bl	80286c4 <tSimplePoly_setNumVoices>
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
 801bfd8:	f24d 700a 	movw	r0, #55050	; 0xd70a
 801bfdc:	f44f 4120 	mov.w	r1, #40960	; 0xa000
 801bfe0:	f649 129a 	movw	r2, #39322	; 0x999a
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
 801bfe4:	4623      	mov	r3, r4
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
 801bfe6:	f6c3 4023 	movt	r0, #15395	; 0x3c23
 801bfea:	f2c4 610c 	movt	r1, #17932	; 0x460c
 801bfee:	f6c3 6299 	movt	r2, #16025	; 0x3e99
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
 801bff2:	f2c4 437a 	movt	r3, #17530	; 0x447a
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
 801bff6:	ee0a 0a10 	vmov	s20, r0
 801bffa:	ee09 1a90 	vmov	s19, r1
 801bffe:	ee09 2a10 	vmov	s18, r2
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
 801c002:	ee08 3a10 	vmov	s16, r3
                tComplexLivingString_init(&theString[i], 440.f, 0.2f, 0.3f, 0.f, 9000.f, 1.0f, 0.0f, 0.01f, 0.125f, levModeStr);
 801c006:	ee08 4a90 	vmov	s17, r4
 801c00a:	2300      	movs	r3, #0
 801c00c:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 801c010:	eeb4 4a00 	vmov.f32	s8, #64	; 0x3e000000  0.125
 801c014:	6831      	ldr	r1, [r6, #0]
 801c016:	f6c3 624c 	movt	r2, #15948	; 0x3e4c
 801c01a:	4618      	mov	r0, r3
 801c01c:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
 801c020:	eef0 3a4a 	vmov.f32	s7, s20
 801c024:	ee01 0a90 	vmov	s3, r0
 801c028:	ee00 2a90 	vmov	s1, r2
 801c02c:	ee00 3a10 	vmov	s0, r3
 801c030:	eeb0 3a68 	vmov.f32	s6, s17
 801c034:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
 801c038:	eb0a 0004 	add.w	r0, sl, r4
 801c03c:	eeb0 2a69 	vmov.f32	s4, s19
 801c040:	eeb0 1a49 	vmov.f32	s2, s18
 801c044:	f00c fe56 	bl	8028cf4 <tComplexLivingString_init>
                tSlide_initToPool(&stringOutEnvs[i], 10.0f, 1000.0f, &smallPool);
 801c048:	eb09 0004 	add.w	r0, r9, r4
 801c04c:	4629      	mov	r1, r5
 801c04e:	eef0 0a48 	vmov.f32	s1, s16
 801c052:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801c056:	f009 ffb5 	bl	8025fc4 <tSlide_initToPool>
                tSlide_initToPool(&stringInEnvs[i], 12.0f, 1000.0f, &smallPool);
 801c05a:	eb08 0004 	add.w	r0, r8, r4
 801c05e:	4629      	mov	r1, r5
 801c060:	eef0 0a48 	vmov.f32	s1, s16
 801c064:	eeb2 0a08 	vmov.f32	s0, #40	; 0x41400000  12.0
 801c068:	f009 ffac 	bl	8025fc4 <tSlide_initToPool>
                tADSR4_initToPool(&pluckEnvs[i], 4.0f, 70.0f, 0.0f, 5.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c06c:	2200      	movs	r2, #0
 801c06e:	f647 113c 	movw	r1, #31036	; 0x793c
 801c072:	1938      	adds	r0, r7, r4
 801c074:	f2c4 228c 	movt	r2, #17036	; 0x428c
 801c078:	3404      	adds	r4, #4
 801c07a:	462b      	mov	r3, r5
 801c07c:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801c080:	ee00 2a90 	vmov	s1, r2
 801c084:	eef1 1a04 	vmov.f32	s3, #20	; 0x40a00000  5.0
 801c088:	eeb0 1a68 	vmov.f32	s2, s17
 801c08c:	f44f 7200 	mov.w	r2, #512	; 0x200
 801c090:	eeb1 0a00 	vmov.f32	s0, #16	; 0x40800000  4.0
 801c094:	f009 fb8a 	bl	80257ac <tADSR4_initToPool>
            for (int i = 0; i < NUM_STRINGS; i++)
 801c098:	2c18      	cmp	r4, #24
 801c09a:	d1b6      	bne.n	801c00a <SFXLivingStringSynthAlloc+0x92>
            tVZFilter_initToPool(&pluckFilt, BandpassPeak, 2000.0f, 4.0f, &smallPool);
 801c09c:	2300      	movs	r3, #0
 801c09e:	f248 22f8 	movw	r2, #33528	; 0x82f8
 801c0a2:	f248 306c 	movw	r0, #33644	; 0x836c
 801c0a6:	eef1 0a00 	vmov.f32	s1, #16	; 0x40800000  4.0
 801c0aa:	f2c4 43fa 	movt	r3, #17658	; 0x44fa
 801c0ae:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801c0b2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c0b6:	2103      	movs	r1, #3
 801c0b8:	ee00 3a10 	vmov	s0, r3
 801c0bc:	f00a faca 	bl	8026654 <tVZFilter_initToPool>
            tNoise_initToPool(&stringPluckNoise, WhiteNoise, &smallPool);
 801c0c0:	f248 22f8 	movw	r2, #33528	; 0x82f8
 801c0c4:	f642 1044 	movw	r0, #10564	; 0x2944
 801c0c8:	2100      	movs	r1, #0
 801c0ca:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801c0ce:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c0d2:	f00c fc6f 	bl	80289b4 <tNoise_initToPool>
            setLED_A(numVoices == 1);
 801c0d6:	f240 2350 	movw	r3, #592	; 0x250
 801c0da:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c0de:	7818      	ldrb	r0, [r3, #0]
 801c0e0:	f1a0 0001 	sub.w	r0, r0, #1
 801c0e4:	fab0 f080 	clz	r0, r0
 801c0e8:	0940      	lsrs	r0, r0, #5
 801c0ea:	f7f9 fbff 	bl	80158ec <setLED_A>
            setLED_B(voicePluck);
 801c0ee:	f240 6318 	movw	r3, #1560	; 0x618
 801c0f2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c0f6:	7818      	ldrb	r0, [r3, #0]
 801c0f8:	f7f9 fc08 	bl	801590c <setLED_B>
            setLED_C(levModeStr);
 801c0fc:	7830      	ldrb	r0, [r6, #0]
 801c0fe:	f7f9 fc15 	bl	801592c <setLED_C>
            samplesPerMs = leaf.sampleRate / 1000.0f;
 801c102:	f241 236f 	movw	r3, #4719	; 0x126f
 801c106:	ed9b 7a00 	vldr	s14, [fp]
 801c10a:	f240 22ac 	movw	r2, #684	; 0x2ac
 801c10e:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 801c112:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801c116:	ee07 3a90 	vmov	s15, r3
 801c11a:	ee67 7a27 	vmul.f32	s15, s14, s15
 801c11e:	edc2 7a00 	vstr	s15, [r2]
        }
 801c122:	ecbd 8b06 	vpop	{d8-d10}
 801c126:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801c12a:	bf00      	nop

0801c12c <SFXLivingStringSynthFrame>:
        {
 801c12c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c130:	f248 6ae4 	movw	sl, #34532	; 0x86e4
 801c134:	f2c2 0a01 	movt	sl, #8193	; 0x2001
        {
 801c138:	ed2d 8b02 	vpush	{d8}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c13c:	f89a 4014 	ldrb.w	r4, [sl, #20]
        {
 801c140:	b085      	sub	sp, #20
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c142:	2c01      	cmp	r4, #1
 801c144:	d11a      	bne.n	801c17c <SFXLivingStringSynthFrame+0x50>
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 801c146:	f240 2550 	movw	r5, #592	; 0x250
                tSimplePoly_setNumVoices(&poly, numVoices);
 801c14a:	f247 5020 	movw	r0, #29984	; 0x7520
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 801c14e:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tSimplePoly_setNumVoices(&poly, numVoices);
 801c152:	f2c2 0001 	movt	r0, #8193	; 0x2001
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 801c156:	7829      	ldrb	r1, [r5, #0]
 801c158:	2901      	cmp	r1, #1
 801c15a:	bf98      	it	ls
 801c15c:	2406      	movls	r4, #6
                tSimplePoly_setNumVoices(&poly, numVoices);
 801c15e:	4621      	mov	r1, r4
                numVoices = (numVoices > 1) ? 1 : NUM_STRINGS;
 801c160:	702c      	strb	r4, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 801c162:	f00c faaf 	bl	80286c4 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 801c166:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801c168:	2100      	movs	r1, #0
                setLED_A(numVoices == 1);
 801c16a:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801c16e:	f88a 1014 	strb.w	r1, [sl, #20]
                setLED_A(numVoices == 1);
 801c172:	fab0 f080 	clz	r0, r0
 801c176:	0940      	lsrs	r0, r0, #5
 801c178:	f7f9 fbb8 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801c17c:	f89a 1018 	ldrb.w	r1, [sl, #24]
 801c180:	2901      	cmp	r1, #1
 801c182:	f000 81a9 	beq.w	801c4d8 <SFXLivingStringSynthFrame+0x3ac>
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 801c186:	f89a 101c 	ldrb.w	r1, [sl, #28]
 801c18a:	2901      	cmp	r1, #1
 801c18c:	f000 8184 	beq.w	801c498 <SFXLivingStringSynthFrame+0x36c>
 801c190:	f242 6370 	movw	r3, #9840	; 0x2670
 801c194:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c198:	9301      	str	r3, [sp, #4]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c19a:	f243 2bec 	movw	fp, #13036	; 0x32ec
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c19e:	2100      	movs	r1, #0
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1a0:	eeb2 6a04 	vmov.f32	s12, #36	; 0x41200000  10.0
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1a4:	2300      	movs	r3, #0
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1a6:	f2c2 0b00 	movt	fp, #8192	; 0x2000
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1aa:	f2c4 21ee 	movt	r1, #17134	; 0x42ee
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1ae:	9302      	str	r3, [sp, #8]
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1b0:	f248 7494 	movw	r4, #34708	; 0x8794
 801c1b4:	4658      	mov	r0, fp
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1b6:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1ba:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1be:	ee07 1a90 	vmov	s15, r1
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1c2:	ecb0 7a01 	vldmia	r0!, {s14}
 801c1c6:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1ca:	eddb 6a03 	vldr	s13, [fp, #12]
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1ce:	f6c3 73e0 	movt	r3, #16352	; 0x3fe0
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1d2:	ee27 7a06 	vmul.f32	s14, s14, s12
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
 801c1d6:	6800      	ldr	r0, [r0, #0]
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
 801c1d8:	f8db 1008 	ldr.w	r1, [fp, #8]
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1dc:	eea6 0aa7 	vfma.f32	s0, s13, s15
            displayValues[1] = presetKnobValues[LivingStringSynth][1]; //lowpass
 801c1e0:	6060      	str	r0, [r4, #4]
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1e2:	f645 4629 	movw	r6, #23593	; 0x5c29
 801c1e6:	9303      	str	r3, [sp, #12]
 801c1e8:	f642 07f5 	movw	r7, #10485	; 0x28f5
            displayValues[2] = presetKnobValues[LivingStringSynth][2]; //decay
 801c1ec:	60a1      	str	r1, [r4, #8]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c1ee:	f647 29e1 	movw	r9, #31457	; 0x7ae1
            displayValues[0] = presetKnobValues[LivingStringSynth][0] * 10.0f; //pluck volume
 801c1f2:	ed84 7a00 	vstr	s14, [r4]
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c1f6:	f00b fd5b 	bl	8027cb0 <faster_mtof>
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c1fa:	ed9b 3a04 	vldr	s6, [fp, #16]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c1fe:	eef2 7a01 	vmov.f32	s15, #33	; 0x41080000  8.5
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c202:	ed9b 4a05 	vldr	s8, [fp, #20]
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c206:	f2cc 268f 	movt	r6, #49807	; 0xc28f
            displayValues[3] = faster_mtof((presetKnobValues[LivingStringSynth][3] * 119.0f)+20.0f); //lowpass
 801c20a:	ed84 0a03 	vstr	s0, [r4, #12]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c20e:	eeb9 0a01 	vmov.f32	s0, #145	; 0xc0880000 -4.250
 801c212:	ed9b 7a06 	vldr	s14, [fp, #24]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c216:	f04f 4880 	mov.w	r8, #1073741824	; 0x40000000
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c21a:	f6c3 77dc 	movt	r7, #16348	; 0x3fdc
 801c21e:	eeb7 3ac3 	vcvt.f64.f32	d3, s6
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c222:	eeb7 4ac4 	vcvt.f64.f32	d4, s8
 801c226:	f6c3 79a4 	movt	r9, #16292	; 0x3fa4
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c22a:	eea7 0a27 	vfma.f32	s0, s14, s15
 801c22e:	f247 5af4 	movw	sl, #30196	; 0x75f4
 801c232:	f240 25ac 	movw	r5, #684	; 0x2ac
 801c236:	f2c2 0a01 	movt	sl, #8193	; 0x2001
 801c23a:	f2c2 0500 	movt	r5, #8192	; 0x2000
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c23e:	ed9d 6b02 	vldr	d6, [sp, #8]
 801c242:	ec47 6b15 	vmov	d5, r6, r7
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c246:	ec49 8b17 	vmov	d7, r8, r9
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c24a:	eea3 6b05 	vfma.f64	d6, d3, d5
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c24e:	2700      	movs	r7, #0
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c250:	eea4 7b05 	vfma.f64	d7, d4, d5
            displayValues[4] = (presetKnobValues[LivingStringSynth][4] * 0.44) + 0.52f;//pick Pos
 801c254:	eeb7 6bc6 	vcvt.f32.f64	s12, d6
 801c258:	ed84 6a04 	vstr	s12, [r4, #16]
            displayValues[5] = (presetKnobValues[LivingStringSynth][5] * 0.44) + 0.04f;//prep Pos
 801c25c:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
 801c260:	ed84 7a05 	vstr	s14, [r4, #20]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c264:	f00b fbfa 	bl	8027a5c <LEAF_tanh>
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c268:	f240 2238 	movw	r2, #568	; 0x238
 801c26c:	eddb 7a09 	vldr	s15, [fp, #36]	; 0x24
 801c270:	f04f 438c 	mov.w	r3, #1174405120	; 0x46000000
 801c274:	f247 0144 	movw	r1, #28740	; 0x7044
 801c278:	f2c2 0200 	movt	r2, #8192	; 0x2000
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c27c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c280:	ee06 3a90 	vmov	s13, r3
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c284:	f24e 1348 	movw	r3, #57672	; 0xe148
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c288:	edd2 5a00 	vldr	s11, [r2]
 801c28c:	f2c2 0101 	movt	r1, #8193	; 0x2001
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c290:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c294:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c298:	ee67 7aa5 	vmul.f32	s15, s15, s11
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c29c:	f24d 720a 	movw	r2, #55050	; 0xd70a
 801c2a0:	ee08 3a10 	vmov	s16, r3
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c2a4:	ee30 0a07 	vadd.f32	s0, s0, s14
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c2a8:	f6c3 42a3 	movt	r2, #15523	; 0x3ca3
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
 801c2ac:	f8db 601c 	ldr.w	r6, [fp, #28]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c2b0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
 801c2b4:	f8db 0020 	ldr.w	r0, [fp, #32]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c2b8:	ee20 0a06 	vmul.f32	s0, s0, s12
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c2bc:	ee08 2a90 	vmov	s17, r2
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c2c0:	f8dd 8004 	ldr.w	r8, [sp, #4]
 801c2c4:	ee17 3a90 	vmov	r3, s15
            displayValues[7] = presetKnobValues[LivingStringSynth][7];//let Ring
 801c2c8:	61e6      	str	r6, [r4, #28]
            displayValues[6] = ((LEAF_tanh((presetKnobValues[LivingStringSynth][6] * 8.5f) - 4.25f)) * 0.5f) + 0.5f;//prep Index
 801c2ca:	ed84 0a06 	vstr	s0, [r4, #24]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c2ce:	eb01 0183 	add.w	r1, r1, r3, lsl #2
            displayValues[8] = presetKnobValues[LivingStringSynth][8];//feedback level
 801c2d2:	6220      	str	r0, [r4, #32]
            displayValues[9] = expBuffer[(int)(presetKnobValues[LivingStringSynth][9] * expBufferSizeMinusOne)] * 8192.0f;//release time
 801c2d4:	edd1 7a00 	vldr	s15, [r1]
 801c2d8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 801c2dc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
                tComplexLivingString_setDecay(&theString[i], ((displayValues[2]  * 0.02f) + 0.98f));
 801c2e0:	eeb0 0a48 	vmov.f32	s0, s16
 801c2e4:	edd4 7a02 	vldr	s15, [r4, #8]
 801c2e8:	eb08 0607 	add.w	r6, r8, r7
 801c2ec:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801c2f0:	4630      	mov	r0, r6
 801c2f2:	f00c fdbb 	bl	8028e6c <tComplexLivingString_setDecay>
                tComplexLivingString_setDampFreq(&theString[i], displayValues[3]);
 801c2f6:	4630      	mov	r0, r6
 801c2f8:	ed94 0a03 	vldr	s0, [r4, #12]
 801c2fc:	f00c fd96 	bl	8028e2c <tComplexLivingString_setDampFreq>
                tComplexLivingString_setPickPos(&theString[i], displayValues[4]);
 801c300:	4630      	mov	r0, r6
 801c302:	ed94 0a04 	vldr	s0, [r4, #16]
 801c306:	f00c fd63 	bl	8028dd0 <tComplexLivingString_setPickPos>
                tComplexLivingString_setPrepPos(&theString[i], displayValues[5]);
 801c30a:	4630      	mov	r0, r6
 801c30c:	ed94 0a05 	vldr	s0, [r4, #20]
 801c310:	f00c fd6e 	bl	8028df0 <tComplexLivingString_setPrepPos>
                tComplexLivingString_setPrepIndex(&theString[i], displayValues[6]);
 801c314:	4630      	mov	r0, r6
 801c316:	ed94 0a06 	vldr	s0, [r4, #24]
 801c31a:	f00c fd79 	bl	8028e10 <tComplexLivingString_setPrepIndex>
                tSlide_setDownSlide(&stringOutEnvs[i], displayValues[9] * samplesPerMs);
 801c31e:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 801c322:	edd5 7a00 	vldr	s15, [r5]
 801c326:	eb0a 0007 	add.w	r0, sl, r7
 801c32a:	3704      	adds	r7, #4
 801c32c:	ee20 0a27 	vmul.f32	s0, s0, s15
 801c330:	f009 fe72 	bl	8026018 <tSlide_setDownSlide>
            for (int i = 0; i < NUM_STRINGS; i++)
 801c334:	2f18      	cmp	r7, #24
 801c336:	d1d3      	bne.n	801c2e0 <SFXLivingStringSynthFrame+0x1b4>
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c338:	2300      	movs	r3, #0
 801c33a:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c33e:	f64a 22ab 	movw	r2, #43691	; 0xaaab
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c342:	ed94 7a01 	vldr	s14, [r4, #4]
 801c346:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c34a:	2500      	movs	r5, #0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c34c:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
 801c350:	f243 4b3c 	movw	fp, #13372	; 0x343c
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c354:	ee07 3a90 	vmov	s15, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c358:	f247 5720 	movw	r7, #29984	; 0x7520
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c35c:	9202      	str	r2, [sp, #8]
 801c35e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c362:	eea7 0a27 	vfma.f32	s0, s14, s15
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c366:	462e      	mov	r6, r5
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c368:	f00b fca2 	bl	8027cb0 <faster_mtof>
 801c36c:	f248 306c 	movw	r0, #33644	; 0x836c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c370:	f2c2 0701 	movt	r7, #8193	; 0x2001
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801c374:	ee08 5a90 	vmov	s17, r5
            tVZFilter_setFreq(&pluckFilt, faster_mtof((displayValues[1] * 100.0f)+20.0f));
 801c378:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c37c:	f00a fbee 	bl	8026b5c <tVZFilter_setFreq>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c380:	e01e      	b.n	801c3c0 <SFXLivingStringSynthFrame+0x294>
                    tComplexLivingString_setTargetLev(&theString[i],voiceOn * displayValues[8]);
 801c382:	ed94 0a08 	vldr	s0, [r4, #32]
 801c386:	ee28 0a00 	vmul.f32	s0, s16, s0
 801c38a:	f00c fd73 	bl	8028e74 <tComplexLivingString_setTargetLev>
                if (voiceOn)
 801c38e:	eeb5 8a40 	vcmp.f32	s16, #0.0
 801c392:	f247 63bc 	movw	r3, #30396	; 0x76bc
 801c396:	eb0a 0205 	add.w	r2, sl, r5
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 801c39a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801c39e:	f2c2 0301 	movt	r3, #8193	; 0x2001
                if (voiceOn)
 801c3a2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 801c3a6:	4610      	mov	r0, r2
 801c3a8:	eb05 0803 	add.w	r8, r5, r3
                if (voiceOn)
 801c3ac:	d065      	beq.n	801c47a <SFXLivingStringSynthFrame+0x34e>
                    tSlide_setDest(&stringOutEnvs[i], 1.0f);
 801c3ae:	f009 fe3b 	bl	8026028 <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 1.0f);
 801c3b2:	4640      	mov	r0, r8
 801c3b4:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801c3b8:	f009 fe36 	bl	8026028 <tSlide_setDest>
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c3bc:	3601      	adds	r6, #1
 801c3be:	3504      	adds	r5, #4
 801c3c0:	9b01      	ldr	r3, [sp, #4]
 801c3c2:	4638      	mov	r0, r7
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3c4:	fa5f f986 	uxtb.w	r9, r6
 801c3c8:	eb03 0805 	add.w	r8, r3, r5
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c3cc:	f00c f982 	bl	80286d4 <tSimplePoly_getNumVoices>
 801c3d0:	42b0      	cmp	r0, r6
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3d2:	4649      	mov	r1, r9
 801c3d4:	4638      	mov	r0, r7
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801c3d6:	dd5a      	ble.n	801c48e <SFXLivingStringSynthFrame+0x362>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3d8:	f00c f998 	bl	802870c <tSimplePoly_getPitch>
 801c3dc:	f240 52d8 	movw	r2, #1496	; 0x5d8
 801c3e0:	ee07 0a90 	vmov	s15, r0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c3e4:	f240 6354 	movw	r3, #1620	; 0x654
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3e8:	f2c2 0200 	movt	r2, #8192	; 0x2000
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801c3ec:	f240 6120 	movw	r1, #1568	; 0x620
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3f0:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c3f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c3f8:	ed92 0a00 	vldr	s0, [r2]
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801c3fc:	f2c2 0100 	movt	r1, #8192	; 0x2000
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c400:	781a      	ldrb	r2, [r3, #0]
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801c402:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801c406:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801c40a:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801c40e:	ee17 3a90 	vmov	r3, s15
 801c412:	1a9b      	subs	r3, r3, r2
 801c414:	9a02      	ldr	r2, [sp, #8]
 801c416:	fb82 2003 	smull	r2, r0, r2, r3
 801c41a:	17da      	asrs	r2, r3, #31
 801c41c:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 801c420:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801c424:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 801c428:	ee07 3a90 	vmov	s15, r3
 801c42c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801c430:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c434:	ee17 3a90 	vmov	r3, s15
 801c438:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 801c43c:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801c440:	ee37 0a00 	vadd.f32	s0, s14, s0
 801c444:	f00b fba2 	bl	8027b8c <LEAF_midiToFrequency>
                tComplexLivingString_setFreq(&theString[i], freq[i]);
 801c448:	4640      	mov	r0, r8
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801c44a:	ecab 0a01 	vstmia	fp!, {s0}
                tComplexLivingString_setFreq(&theString[i], freq[i]);
 801c44e:	f00c fca3 	bl	8028d98 <tComplexLivingString_setFreq>
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801c452:	4649      	mov	r1, r9
 801c454:	4638      	mov	r0, r7
 801c456:	f00c f965 	bl	8028724 <tSimplePoly_getVelocity>
                if (levModeStr)
 801c45a:	f240 53a4 	movw	r3, #1444	; 0x5a4
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801c45e:	2800      	cmp	r0, #0
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 801c460:	eeb0 0a48 	vmov.f32	s0, s16
                if (levModeStr)
 801c464:	f2c2 0300 	movt	r3, #8192	; 0x2000
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 801c468:	4640      	mov	r0, r8
                float voiceOn = (tSimplePoly_getVelocity(&poly, i) > 0);
 801c46a:	fe38 8a28 	vselgt.f32	s16, s16, s17
                if (levModeStr)
 801c46e:	681b      	ldr	r3, [r3, #0]
 801c470:	2b00      	cmp	r3, #0
 801c472:	d186      	bne.n	801c382 <SFXLivingStringSynthFrame+0x256>
                    tComplexLivingString_setTargetLev(&theString[i],1.0f);
 801c474:	f00c fcfe 	bl	8028e74 <tComplexLivingString_setTargetLev>
 801c478:	e789      	b.n	801c38e <SFXLivingStringSynthFrame+0x262>
                    tSlide_setDest(&stringOutEnvs[i], displayValues[7]);
 801c47a:	ed94 0a07 	vldr	s0, [r4, #28]
 801c47e:	f009 fdd3 	bl	8026028 <tSlide_setDest>
                    tSlide_setDest(&stringInEnvs[i], 0.0f);
 801c482:	eeb0 0a68 	vmov.f32	s0, s17
 801c486:	4640      	mov	r0, r8
 801c488:	f009 fdce 	bl	8026028 <tSlide_setDest>
 801c48c:	e796      	b.n	801c3bc <SFXLivingStringSynthFrame+0x290>
        }
 801c48e:	b005      	add	sp, #20
 801c490:	ecbd 8b02 	vpop	{d8}
 801c494:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                levModeStr = !levModeStr;
 801c498:	f240 54a4 	movw	r4, #1444	; 0x5a4
 801c49c:	f242 6370 	movw	r3, #9840	; 0x2670
 801c4a0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801c4a4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c4a8:	6821      	ldr	r1, [r4, #0]
 801c4aa:	461d      	mov	r5, r3
 801c4ac:	9301      	str	r3, [sp, #4]
 801c4ae:	f103 0b18 	add.w	fp, r3, #24
 801c4b2:	fab1 f181 	clz	r1, r1
 801c4b6:	0949      	lsrs	r1, r1, #5
 801c4b8:	6021      	str	r1, [r4, #0]
 801c4ba:	e000      	b.n	801c4be <SFXLivingStringSynthFrame+0x392>
 801c4bc:	6821      	ldr	r1, [r4, #0]
                    tComplexLivingString_setLevMode(&theString[i], levModeStr);
 801c4be:	4628      	mov	r0, r5
 801c4c0:	3504      	adds	r5, #4
 801c4c2:	f00c fceb 	bl	8028e9c <tComplexLivingString_setLevMode>
                for (int i = 0; i < NUM_STRINGS; i++)
 801c4c6:	45ab      	cmp	fp, r5
 801c4c8:	d1f8      	bne.n	801c4bc <SFXLivingStringSynthFrame+0x390>
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801c4ca:	2100      	movs	r1, #0
                setLED_C(levModeStr);
 801c4cc:	7820      	ldrb	r0, [r4, #0]
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801c4ce:	f88a 101c 	strb.w	r1, [sl, #28]
                setLED_C(levModeStr);
 801c4d2:	f7f9 fa2b 	bl	801592c <setLED_C>
 801c4d6:	e660      	b.n	801c19a <SFXLivingStringSynthFrame+0x6e>
                voicePluck = !voicePluck;
 801c4d8:	f240 6418 	movw	r4, #1560	; 0x618
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801c4dc:	2100      	movs	r1, #0
                voicePluck = !voicePluck;
 801c4de:	f2c2 0400 	movt	r4, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801c4e2:	f88a 1018 	strb.w	r1, [sl, #24]
                voicePluck = !voicePluck;
 801c4e6:	6821      	ldr	r1, [r4, #0]
 801c4e8:	fab1 f181 	clz	r1, r1
 801c4ec:	0949      	lsrs	r1, r1, #5
                setLED_B(voicePluck);
 801c4ee:	4608      	mov	r0, r1
                voicePluck = !voicePluck;
 801c4f0:	6021      	str	r1, [r4, #0]
                setLED_B(voicePluck);
 801c4f2:	f7f9 fa0b 	bl	801590c <setLED_B>
 801c4f6:	e646      	b.n	801c186 <SFXLivingStringSynthFrame+0x5a>

0801c4f8 <SFXLivingStringSynthTick>:
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 801c4f8:	f248 7394 	movw	r3, #34708	; 0x8794
        {
 801c4fc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 801c500:	4606      	mov	r6, r0
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 801c502:	f642 1044 	movw	r0, #10564	; 0x2944
 801c506:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801c50a:	f240 6a18 	movw	sl, #1560	; 0x618
 801c50e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c512:	f247 4908 	movw	r9, #29704	; 0x7408
 801c516:	f247 58f4 	movw	r8, #30196	; 0x75f4
 801c51a:	f242 6770 	movw	r7, #9840	; 0x2670
 801c51e:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801c522:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801c526:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801c52a:	f2c2 0700 	movt	r7, #8192	; 0x2000
        {
 801c52e:	ed2d 8b06 	vpush	{d8-d10}
            float pluck = displayValues[0] * tNoise_tick(&stringPluckNoise);
 801c532:	ed93 8a00 	vldr	s16, [r3]
 801c536:	f00c fa53 	bl	80289e0 <tNoise_tick>
            pluck = tVZFilter_tick(&pluckFilt, pluck);
 801c53a:	f248 306c 	movw	r0, #33644	; 0x836c
 801c53e:	ee28 0a00 	vmul.f32	s0, s16, s0
 801c542:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c546:	f00a fa99 	bl	8026a7c <tVZFilter_tick>
            float sample = 0.0f;
 801c54a:	2300      	movs	r3, #0
            pluck = tVZFilter_tick(&pluckFilt, pluck);
 801c54c:	eeb0 aa40 	vmov.f32	s20, s0
 801c550:	461c      	mov	r4, r3
            float sample = 0.0f;
 801c552:	ee09 3a10 	vmov	s18, r3
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
 801c556:	edda 7a00 	vldr	s15, [sl]
 801c55a:	eb09 0004 	add.w	r0, r9, r4
 801c55e:	edd6 9a01 	vldr	s19, [r6, #4]
 801c562:	eb08 0504 	add.w	r5, r8, r4
 801c566:	eef8 8ae7 	vcvt.f32.s32	s17, s15
 801c56a:	f009 f9db 	bl	8025924 <tADSR4_tick>
 801c56e:	ee20 8a0a 	vmul.f32	s16, s0, s20
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 801c572:	4628      	mov	r0, r5
 801c574:	f009 fd5c 	bl	8026030 <tSlide_tickNoInput>
 801c578:	1938      	adds	r0, r7, r4
 801c57a:	3404      	adds	r4, #4
                inputSample = (input[1] * voicePluck) + (pluck * tADSR4_tick(&pluckEnvs[i]));
 801c57c:	eea9 8aa8 	vfma.f32	s16, s19, s17
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 801c580:	ee20 0a08 	vmul.f32	s0, s0, s16
 801c584:	f00c fca0 	bl	8028ec8 <tComplexLivingString_tick>
 801c588:	4628      	mov	r0, r5
 801c58a:	eeb0 8a40 	vmov.f32	s16, s0
 801c58e:	f009 fd4f 	bl	8026030 <tSlide_tickNoInput>
            for (int i = 0; i < NUM_STRINGS; i++)
 801c592:	2c18      	cmp	r4, #24
                sample += tComplexLivingString_tick(&theString[i], (inputSample * tSlide_tickNoInput(&stringOutEnvs[i]))) * tSlide_tickNoInput(&stringOutEnvs[i]);
 801c594:	eea8 9a00 	vfma.f32	s18, s16, s0
            for (int i = 0; i < NUM_STRINGS; i++)
 801c598:	d1dd      	bne.n	801c556 <SFXLivingStringSynthTick+0x5e>
            sample *= 0.1625f;
 801c59a:	f246 6366 	movw	r3, #26214	; 0x6666
 801c59e:	f6c3 6326 	movt	r3, #15910	; 0x3e26
 801c5a2:	ee00 3a10 	vmov	s0, r3
            sample = LEAF_tanh(sample) * 0.98f;
 801c5a6:	ee29 0a00 	vmul.f32	s0, s18, s0
 801c5aa:	f00b fa57 	bl	8027a5c <LEAF_tanh>
 801c5ae:	f24e 1348 	movw	r3, #57672	; 0xe148
 801c5b2:	f6c3 737a 	movt	r3, #16250	; 0x3f7a
 801c5b6:	ee07 3a90 	vmov	s15, r3
 801c5ba:	ee20 0a27 	vmul.f32	s0, s0, s15
            input[0] = sample;
 801c5be:	ed86 0a00 	vstr	s0, [r6]
            input[1] = sample;
 801c5c2:	ed86 0a01 	vstr	s0, [r6, #4]
        }
 801c5c6:	ecbd 8b06 	vpop	{d8-d10}
 801c5ca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 801c5ce:	bf00      	nop

0801c5d0 <SFXLivingStringSynthFree>:
        {
 801c5d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801c5d4:	f242 6870 	movw	r8, #9840	; 0x2670
 801c5d8:	f247 67bc 	movw	r7, #30396	; 0x76bc
 801c5dc:	f247 56f4 	movw	r6, #30196	; 0x75f4
 801c5e0:	f247 4508 	movw	r5, #29704	; 0x7408
 801c5e4:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801c5e8:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801c5ec:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801c5f0:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801c5f4:	2400      	movs	r4, #0
                tComplexLivingString_free(&theString[i]);
 801c5f6:	eb08 0004 	add.w	r0, r8, r4
 801c5fa:	f00c fb81 	bl	8028d00 <tComplexLivingString_free>
                tSlide_free(&stringInEnvs[i]);
 801c5fe:	1938      	adds	r0, r7, r4
 801c600:	f009 fd06 	bl	8026010 <tSlide_free>
                tSlide_free(&stringOutEnvs[i]);
 801c604:	1930      	adds	r0, r6, r4
 801c606:	f009 fd03 	bl	8026010 <tSlide_free>
                tADSR4_free(&pluckEnvs[i]);
 801c60a:	1928      	adds	r0, r5, r4
 801c60c:	3404      	adds	r4, #4
 801c60e:	f009 f927 	bl	8025860 <tADSR4_free>
            for (int i = 0; i < NUM_STRINGS; i++)
 801c612:	2c18      	cmp	r4, #24
 801c614:	d1ef      	bne.n	801c5f6 <SFXLivingStringSynthFree+0x26>
            tVZFilter_free(&pluckFilt);
 801c616:	f248 306c 	movw	r0, #33644	; 0x836c
 801c61a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c61e:	f00a fa1f 	bl	8026a60 <tVZFilter_free>
            tNoise_free(&stringPluckNoise);
 801c622:	f642 1044 	movw	r0, #10564	; 0x2944
        }
 801c626:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
            tNoise_free(&stringPluckNoise);
 801c62a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801c62e:	f00c b9d3 	b.w	80289d8 <tNoise_free>
 801c632:	bf00      	nop

0801c634 <SFXClassicSynthAlloc>:
            tSimplePoly_setNumVoices(&poly, numVoices);
 801c634:	f240 2250 	movw	r2, #592	; 0x250
 801c638:	f247 5020 	movw	r0, #29984	; 0x7520
            leaf.clearOnAllocation = 1;
 801c63c:	2301      	movs	r3, #1
            tSimplePoly_setNumVoices(&poly, numVoices);
 801c63e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801c642:	f2c2 0001 	movt	r0, #8193	; 0x2001
        {
 801c646:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            leaf.clearOnAllocation = 1;
 801c64a:	f249 4aa0 	movw	sl, #38048	; 0x94a0
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801c64e:	f04f 478b 	mov.w	r7, #1166016512	; 0x45800000
            displayValues[0] = knobs[0]; //synth volume
 801c652:	f248 7594 	movw	r5, #34708	; 0x8794
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 801c656:	f04f 0800 	mov.w	r8, #0
            leaf.clearOnAllocation = 1;
 801c65a:	f2c2 0a01 	movt	sl, #8193	; 0x2001
            displayValues[0] = knobs[0]; //synth volume
 801c65e:	f2c2 0501 	movt	r5, #8193	; 0x2001
            leaf.clearOnAllocation = 1;
 801c662:	f8ca 3014 	str.w	r3, [sl, #20]
        {
 801c666:	ed2d 8b08 	vpush	{d8-d11}
 801c66a:	b089      	sub	sp, #36	; 0x24
            tSimplePoly_setNumVoices(&poly, numVoices);
 801c66c:	7811      	ldrb	r1, [r2, #0]
 801c66e:	9207      	str	r2, [sp, #28]
 801c670:	f00c f828 	bl	80286c4 <tSimplePoly_setNumVoices>
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c674:	f240 2138 	movw	r1, #568	; 0x238
            displayValues[0] = knobs[0]; //synth volume
 801c678:	f243 3350 	movw	r3, #13136	; 0x3350
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c67c:	f64c 40cd 	movw	r0, #52429	; 0xcccd
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c680:	f247 0244 	movw	r2, #28740	; 0x7044
            displayValues[0] = knobs[0]; //synth volume
 801c684:	f2c2 0300 	movt	r3, #8192	; 0x2000
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c688:	f2c2 0100 	movt	r1, #8192	; 0x2000
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c68c:	f6c3 60cc 	movt	r0, #16076	; 0x3ecc
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c690:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801c694:	edd1 7a00 	vldr	s15, [r1]
            displayValues[0] = knobs[0]; //synth volume
 801c698:	469c      	mov	ip, r3
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c69a:	ed93 6a0a 	vldr	s12, [r3, #40]	; 0x28
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c69e:	ee09 0a90 	vmov	s19, r0
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6a2:	ed93 5a05 	vldr	s10, [r3, #20]
 801c6a6:	f04f 418c 	mov.w	r1, #1174405120	; 0x46000000
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6aa:	edd3 5a06 	vldr	s11, [r3, #24]
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6ae:	ee27 6a86 	vmul.f32	s12, s15, s12
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c6b2:	ed93 7a08 	vldr	s14, [r3, #32]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6b6:	ee27 5a85 	vmul.f32	s10, s15, s10
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6ba:	edd3 6a0b 	vldr	s13, [r3, #44]	; 0x2c
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6be:	ee67 5aa5 	vmul.f32	s11, s15, s11
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c6c2:	ee27 7a87 	vmul.f32	s14, s15, s14
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c6c6:	edd3 4a04 	vldr	s9, [r3, #16]
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6ca:	ee67 6aa6 	vmul.f32	s13, s15, s13
            displayValues[0] = knobs[0]; //synth volume
 801c6ce:	f85c 9b04 	ldr.w	r9, [ip], #4
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6d2:	eebd 6ac6 	vcvt.s32.f32	s12, s12
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
 801c6d6:	f8d3 b008 	ldr.w	fp, [r3, #8]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6da:	eebd 5ac5 	vcvt.s32.f32	s10, s10
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801c6de:	ed9c 4a00 	vldr	s8, [ip]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6e2:	eefd 5ae5 	vcvt.s32.f32	s11, s11
            displayValues[7] = knobs[7]; //sus
 801c6e6:	f8d3 c01c 	ldr.w	ip, [r3, #28]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c6ea:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6ee:	ee16 0a10 	vmov	r0, s12
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6f2:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c6f6:	ee15 ea10 	vmov	lr, s10
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c6fa:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c6fe:	ee15 6a90 	vmov	r6, s11
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c702:	eef0 3a69 	vmov.f32	s7, s19
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c706:	ee17 4a10 	vmov	r4, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c70a:	ee07 1a10 	vmov	s14, r1
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c70e:	ee16 1a90 	vmov	r1, s13
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c712:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
            displayValues[12] = knobs[12]; //sus
 801c716:	ed93 3a0c 	vldr	s6, [r3, #48]	; 0x30
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c71a:	eb02 0686 	add.w	r6, r2, r6, lsl #2
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c71e:	eee4 3a86 	vfma.f32	s7, s9, s12
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c722:	eb02 0484 	add.w	r4, r2, r4, lsl #2
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801c726:	ee06 7a10 	vmov	s12, r7
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c72a:	eb02 0080 	add.w	r0, r2, r0, lsl #2
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c72e:	edde 6a00 	vldr	s13, [lr]
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c732:	eb02 0181 	add.w	r1, r2, r1, lsl #2
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c736:	edd6 4a00 	vldr	s9, [r6]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c73a:	ed94 5a00 	vldr	s10, [r4]
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801c73e:	ee24 4a06 	vmul.f32	s8, s8, s12
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c742:	edd0 5a00 	vldr	s11, [r0]
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c746:	ee66 6a87 	vmul.f32	s13, s13, s14
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c74a:	ed91 6a00 	vldr	s12, [r1]
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c74e:	ee64 4a87 	vmul.f32	s9, s9, s14
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c752:	ee65 5a87 	vmul.f32	s11, s11, s14
            displayValues[9] = knobs[9]; //leak
 801c756:	6a5f      	ldr	r7, [r3, #36]	; 0x24
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c758:	ee26 6a07 	vmul.f32	s12, s12, s14
            displayValues[3] = knobs[3]; //detune
 801c75c:	f8d3 e00c 	ldr.w	lr, [r3, #12]
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c760:	ee25 5a07 	vmul.f32	s10, s10, s14
            displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c764:	edc5 6a05 	vstr	s13, [r5, #20]
            displayValues[7] = knobs[7]; //sus
 801c768:	f8c5 c01c 	str.w	ip, [r5, #28]
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c76c:	f244 40d0 	movw	r0, #17616	; 0x44d0
            displayValues[9] = knobs[9]; //leak
 801c770:	626f      	str	r7, [r5, #36]	; 0x24
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c772:	f44f 4170 	mov.w	r1, #61440	; 0xf000
            displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c776:	ed85 6a0b 	vstr	s12, [r5, #44]	; 0x2c
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c77a:	f6cb 4058 	movt	r0, #48216	; 0xbc58
            displayValues[0] = knobs[0]; //synth volume
 801c77e:	f8c5 9000 	str.w	r9, [r5]
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c782:	f2c4 517f 	movt	r1, #17791	; 0x457f
            displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801c786:	ed85 4a01 	vstr	s8, [r5, #4]
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c78a:	ee0a 0a90 	vmov	s21, r0
            displayValues[2] = knobs[2]; //keyfollow filter cutoff
 801c78e:	f8c5 b008 	str.w	fp, [r5, #8]
 801c792:	f641 7048 	movw	r0, #8008	; 0x1f48
            displayValues[3] = knobs[3]; //detune
 801c796:	f8c5 e00c 	str.w	lr, [r5, #12]
 801c79a:	f247 26dc 	movw	r6, #29404	; 0x72dc
            displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801c79e:	edc5 3a04 	vstr	s7, [r5, #16]
 801c7a2:	f2c2 0000 	movt	r0, #8192	; 0x2000
            displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801c7a6:	edc5 4a06 	vstr	s9, [r5, #24]
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c7aa:	ee06 1a90 	vmov	s13, r1
            displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c7ae:	ed85 5a08 	vstr	s10, [r5, #32]
 801c7b2:	f2c2 0601 	movt	r6, #8193	; 0x2001
            displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801c7b6:	edc5 5a0a 	vstr	s11, [r5, #40]	; 0x28
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c7ba:	f244 44d0 	movw	r4, #17616	; 0x44d0
            displayValues[12] = knobs[12]; //sus
 801c7be:	ed85 3a0c 	vstr	s6, [r5, #48]	; 0x30
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 801c7c2:	f649 119a 	movw	r1, #39322	; 0x999a
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c7c6:	edd3 5a0d 	vldr	s11, [r3, #52]	; 0x34
 801c7ca:	f642 0c48 	movw	ip, #10312	; 0x2848
 801c7ce:	9004      	str	r0, [sp, #16]
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c7d0:	f6c3 44d8 	movt	r4, #15576	; 0x3cd8
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c7d4:	ee67 7aa5 	vmul.f32	s15, s15, s11
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 801c7d8:	f6c3 6199 	movt	r1, #16025	; 0x3e99
 801c7dc:	9600      	str	r6, [sp, #0]
 801c7de:	4666      	mov	r6, ip
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c7e0:	ee0b 4a10 	vmov	s22, r4
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 801c7e4:	ee0a 1a10 	vmov	s20, r1
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c7e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801c7ec:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801c7f0:	f243 4418 	movw	r4, #13336	; 0x3418
 801c7f4:	f248 3104 	movw	r1, #33540	; 0x8304
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c7f8:	ed93 6a0f 	vldr	s12, [r3, #60]	; 0x3c
 801c7fc:	f247 679c 	movw	r7, #30364	; 0x769c
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c800:	ee17 0a90 	vmov	r0, s15
 801c804:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801c808:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801c80c:	9601      	str	r6, [sp, #4]
 801c80e:	eb02 0280 	add.w	r2, r2, r0, lsl #2
                    tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c812:	f248 26f8 	movw	r6, #33528	; 0x82f8
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c816:	ee66 6a26 	vmul.f32	s13, s12, s13
 801c81a:	9405      	str	r4, [sp, #20]
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c81c:	edd2 7a00 	vldr	s15, [r2]
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c820:	f647 123c 	movw	r2, #31036	; 0x793c
 801c824:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801c828:	9103      	str	r1, [sp, #12]
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c82a:	ee27 7a87 	vmul.f32	s14, s15, s14
            displayValues[14] = knobs[14]; //leak
 801c82e:	6b99      	ldr	r1, [r3, #56]	; 0x38
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c830:	f2c2 0201 	movt	r2, #8193	; 0x2001
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 801c834:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801c836:	4644      	mov	r4, r8
                    tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c838:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801c83c:	9702      	str	r7, [sp, #8]
            displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801c83e:	edc5 6a0f 	vstr	s13, [r5, #60]	; 0x3c
            displayValues[14] = knobs[14]; //leak
 801c842:	63a9      	str	r1, [r5, #56]	; 0x38
            displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 801c844:	642b      	str	r3, [r5, #64]	; 0x40
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c846:	9206      	str	r2, [sp, #24]
            displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801c848:	ed85 7a0d 	vstr	s14, [r5, #52]	; 0x34
 801c84c:	9b03      	ldr	r3, [sp, #12]
 801c84e:	f104 090c 	add.w	r9, r4, #12
 801c852:	191f      	adds	r7, r3, r4
                    tSawtooth_initToPool(&osc[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c854:	9b00      	ldr	r3, [sp, #0]
 801c856:	4631      	mov	r1, r6
 801c858:	1918      	adds	r0, r3, r4
 801c85a:	f00b fff3 	bl	8028844 <tSawtooth_initToPool>
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c85e:	f8da 2010 	ldr.w	r2, [sl, #16]
 801c862:	4790      	blx	r2
 801c864:	eef0 7a6a 	vmov.f32	s15, s21
 801c868:	9b01      	ldr	r3, [sp, #4]
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c86a:	4631      	mov	r1, r6
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c86c:	eee0 7a0b 	vfma.f32	s15, s0, s22
 801c870:	eb03 0b04 	add.w	fp, r3, r4
 801c874:	3404      	adds	r4, #4
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c876:	4658      	mov	r0, fp
                    synthDetune[i][j] = ((leaf.random() * 0.0264f) - 0.0132f);
 801c878:	ece7 7a01 	vstmia	r7!, {s15}
                    tRosenbergGlottalPulse_initToPool(&glottal[(i * NUM_OSC_PER_VOICE) + j], &smallPool);
 801c87c:	f007 fdae 	bl	80243dc <tRosenbergGlottalPulse_initToPool>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.3f);
 801c880:	eeb0 0a4a 	vmov.f32	s0, s20
 801c884:	4658      	mov	r0, fp
 801c886:	f007 feaf 	bl	80245e8 <tRosenbergGlottalPulse_setOpenLength>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], 0.4f);
 801c88a:	eeb0 0a69 	vmov.f32	s0, s19
 801c88e:	4658      	mov	r0, fp
 801c890:	f007 feb8 	bl	8024604 <tRosenbergGlottalPulse_setPulseLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801c894:	454c      	cmp	r4, r9
 801c896:	d1dd      	bne.n	801c854 <SFXClassicSynthAlloc+0x220>
 801c898:	9b02      	ldr	r3, [sp, #8]
                tEfficientSVF_initToPool(&synthLP[i], SVFTypeLowpass, 6000.0f, displayValues[4], &smallPool);
 801c89a:	f241 7270 	movw	r2, #6000	; 0x1770
 801c89e:	9805      	ldr	r0, [sp, #20]
 801c8a0:	2101      	movs	r1, #1
 801c8a2:	eb03 0908 	add.w	r9, r3, r8
 801c8a6:	ed95 0a04 	vldr	s0, [r5, #16]
 801c8aa:	4440      	add	r0, r8
 801c8ac:	4633      	mov	r3, r6
 801c8ae:	f009 fd9b 	bl	80263e8 <tEfficientSVF_initToPool>
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c8b2:	f8dd b018 	ldr.w	fp, [sp, #24]
 801c8b6:	edd5 1a08 	vldr	s3, [r5, #32]
 801c8ba:	4648      	mov	r0, r9
 801c8bc:	4659      	mov	r1, fp
 801c8be:	ed95 1a07 	vldr	s2, [r5, #28]
 801c8c2:	edd5 0a06 	vldr	s1, [r5, #24]
 801c8c6:	4633      	mov	r3, r6
 801c8c8:	f44f 7200 	mov.w	r2, #512	; 0x200
 801c8cc:	ed95 0a05 	vldr	s0, [r5, #20]
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 801c8d0:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801c8d4:	9f04      	ldr	r7, [sp, #16]
                tADSR4_initToPool(&polyEnvs[i], displayValues[5], displayValues[6], displayValues[7], displayValues[8], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c8d6:	f008 ff69 	bl	80257ac <tADSR4_initToPool>
                tADSR4_setLeakFactor(&polyEnvs[i],((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 801c8da:	f24b 7217 	movw	r2, #46871	; 0xb717
 801c8de:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
 801c8e2:	edd5 7a09 	vldr	s15, [r5, #36]	; 0x24
 801c8e6:	f6c3 0251 	movt	r2, #14417	; 0x3851
 801c8ea:	4447      	add	r7, r8
 801c8ec:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 801c8f0:	ee78 7a67 	vsub.f32	s15, s16, s15
 801c8f4:	ee09 2a10 	vmov	s18, r2
 801c8f8:	4648      	mov	r0, r9
 801c8fa:	ee00 3a10 	vmov	s0, r3
 801c8fe:	ee08 3a90 	vmov	s17, r3
 801c902:	f108 0804 	add.w	r8, r8, #4
 801c906:	eea7 0a89 	vfma.f32	s0, s15, s18
 801c90a:	f008 ffed 	bl	80258e8 <tADSR4_setLeakFactor>
                tADSR4_initToPool(&polyFiltEnvs[i], displayValues[10], displayValues[11], displayValues[12], displayValues[13], decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801c90e:	4638      	mov	r0, r7
 801c910:	4633      	mov	r3, r6
 801c912:	f44f 7200 	mov.w	r2, #512	; 0x200
 801c916:	4659      	mov	r1, fp
 801c918:	edd5 1a0d 	vldr	s3, [r5, #52]	; 0x34
 801c91c:	ed95 1a0c 	vldr	s2, [r5, #48]	; 0x30
 801c920:	edd5 0a0b 	vldr	s1, [r5, #44]	; 0x2c
 801c924:	ed95 0a0a 	vldr	s0, [r5, #40]	; 0x28
 801c928:	f008 ff40 	bl	80257ac <tADSR4_initToPool>
                tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 801c92c:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
 801c930:	eeb0 0a68 	vmov.f32	s0, s17
 801c934:	4638      	mov	r0, r7
 801c936:	ee38 8a67 	vsub.f32	s16, s16, s15
 801c93a:	eea8 0a09 	vfma.f32	s0, s16, s18
 801c93e:	f008 ffd3 	bl	80258e8 <tADSR4_setLeakFactor>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801c942:	f1b8 0f20 	cmp.w	r8, #32
 801c946:	d181      	bne.n	801c84c <SFXClassicSynthAlloc+0x218>
            tCycle_initToPool(&pwmLFO1, &smallPool);
 801c948:	f248 21f8 	movw	r1, #33528	; 0x82f8
 801c94c:	f247 608c 	movw	r0, #30348	; 0x768c
 801c950:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801c954:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c958:	f00b fef4 	bl	8028744 <tCycle_initToPool>
            tCycle_initToPool(&pwmLFO2, &smallPool);
 801c95c:	f248 21f8 	movw	r1, #33528	; 0x82f8
 801c960:	f247 7070 	movw	r0, #30576	; 0x7770
 801c964:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801c968:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c96c:	f00b feea 	bl	8028744 <tCycle_initToPool>
            tCycle_setFreq(&pwmLFO1, 63.0f);
 801c970:	2300      	movs	r3, #0
 801c972:	f247 608c 	movw	r0, #30348	; 0x768c
 801c976:	f2c4 237c 	movt	r3, #17020	; 0x427c
 801c97a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c97e:	ee00 3a10 	vmov	s0, r3
 801c982:	f00b fef1 	bl	8028768 <tCycle_setFreq>
            tCycle_setFreq(&pwmLFO2, 72.11f);
 801c986:	f643 0352 	movw	r3, #14418	; 0x3852
 801c98a:	f247 7070 	movw	r0, #30576	; 0x7770
 801c98e:	f2c4 2390 	movt	r3, #17040	; 0x4290
 801c992:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801c996:	ee00 3a10 	vmov	s0, r3
 801c99a:	f00b fee5 	bl	8028768 <tCycle_setFreq>
            setLED_A(numVoices == 1);
 801c99e:	9b07      	ldr	r3, [sp, #28]
 801c9a0:	7818      	ldrb	r0, [r3, #0]
 801c9a2:	f1a0 0001 	sub.w	r0, r0, #1
 801c9a6:	fab0 f080 	clz	r0, r0
 801c9aa:	0940      	lsrs	r0, r0, #5
 801c9ac:	f7f8 ff9e 	bl	80158ec <setLED_A>
            leaf.clearOnAllocation = 0;
 801c9b0:	2300      	movs	r3, #0
 801c9b2:	f8ca 3014 	str.w	r3, [sl, #20]
        }
 801c9b6:	b009      	add	sp, #36	; 0x24
 801c9b8:	ecbd 8b08 	vpop	{d8-d11}
 801c9bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801c9c0 <SFXClassicSynthFrame>:
        {
 801c9c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c9c4:	f248 64e4 	movw	r4, #34532	; 0x86e4
 801c9c8:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 801c9cc:	ed2d 8b08 	vpush	{d8-d11}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c9d0:	7d23      	ldrb	r3, [r4, #20]
        {
 801c9d2:	b08d      	sub	sp, #52	; 0x34
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801c9d4:	2b01      	cmp	r3, #1
 801c9d6:	f000 8151 	beq.w	801cc7c <SFXClassicSynthFrame+0x2bc>
 801c9da:	f240 2350 	movw	r3, #592	; 0x250
 801c9de:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c9e2:	9304      	str	r3, [sp, #16]
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801c9e4:	7e23      	ldrb	r3, [r4, #24]
 801c9e6:	2b01      	cmp	r3, #1
 801c9e8:	f000 8167 	beq.w	801ccba <SFXClassicSynthFrame+0x2fa>
            if (writeKnobFlag != -1)
 801c9ec:	f240 23cf 	movw	r3, #719	; 0x2cf
 801c9f0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801c9f4:	f993 2000 	ldrsb.w	r2, [r3]
 801c9f8:	1c53      	adds	r3, r2, #1
 801c9fa:	d027      	beq.n	801ca4c <SFXClassicSynthFrame+0x8c>
                switch(writeKnobFlag + (knobPage * KNOB_PAGE_SIZE))
 801c9fc:	f240 6156 	movw	r1, #1622	; 0x656
 801ca00:	2305      	movs	r3, #5
 801ca02:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801ca06:	7809      	ldrb	r1, [r1, #0]
 801ca08:	fb13 2301 	smlabb	r3, r3, r1, r2
 801ca0c:	2b10      	cmp	r3, #16
 801ca0e:	d81d      	bhi.n	801ca4c <SFXClassicSynthFrame+0x8c>
 801ca10:	e8df f013 	tbh	[pc, r3, lsl #1]
 801ca14:	03d60011 	.word	0x03d60011
 801ca18:	03be03ca 	.word	0x03be03ca
 801ca1c:	03560392 	.word	0x03560392
 801ca20:	02f8031a 	.word	0x02f8031a
 801ca24:	028602bc 	.word	0x028602bc
 801ca28:	020e024a 	.word	0x020e024a
 801ca2c:	01b001ec 	.word	0x01b001ec
 801ca30:	0165017a 	.word	0x0165017a
 801ca34:	0159      	.short	0x0159
                        displayValues[0] = knobs[0]; //synth volume
 801ca36:	f243 3350 	movw	r3, #13136	; 0x3350
 801ca3a:	f248 7994 	movw	r9, #34708	; 0x8794
 801ca3e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ca42:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801ca46:	681b      	ldr	r3, [r3, #0]
 801ca48:	f8c9 3000 	str.w	r3, [r9]
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
 801ca4c:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 801ca50:	f247 608c 	movw	r0, #30348	; 0x768c
 801ca54:	eeb5 8a00 	vmov.f32	s16, #80	; 0x3e800000  0.250
 801ca58:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ca5c:	f00b fe92 	bl	8028784 <tCycle_tick>
 801ca60:	eef0 9a68 	vmov.f32	s19, s17
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 801ca64:	f247 7070 	movw	r0, #30576	; 0x7770
 801ca68:	f2c2 0001 	movt	r0, #8193	; 0x2001
            float tempLFO1 = (tCycle_tick(&pwmLFO1) * 0.25f) + 0.5f; // pulse length
 801ca6c:	eee0 9a08 	vfma.f32	s19, s0, s16
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 801ca70:	f00b fe88 	bl	8028784 <tCycle_tick>
 801ca74:	eee0 8a08 	vfma.f32	s17, s0, s16
            for (int i = 0; i < numVoices; i++)
 801ca78:	9b04      	ldr	r3, [sp, #16]
 801ca7a:	781b      	ldrb	r3, [r3, #0]
            float tempLFO2 = ((tCycle_tick(&pwmLFO2) * 0.25f) + 0.5f) * tempLFO1; // open length
 801ca7c:	ee68 8aa9 	vmul.f32	s17, s17, s19
            for (int i = 0; i < numVoices; i++)
 801ca80:	2b00      	cmp	r3, #0
 801ca82:	f000 80e9 	beq.w	801cc58 <SFXClassicSynthFrame+0x298>
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801ca86:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 801ca8a:	f240 53d8 	movw	r3, #1496	; 0x5d8
 801ca8e:	f240 6220 	movw	r2, #1568	; 0x620
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 801ca92:	f247 5a20 	movw	sl, #29984	; 0x7520
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801ca96:	f2c4 517f 	movt	r1, #17791	; 0x457f
            for (int i = 0; i < numVoices; i++)
 801ca9a:	f04f 0b00 	mov.w	fp, #0
 801ca9e:	f2c2 0200 	movt	r2, #8192	; 0x2000
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 801caa2:	f2c2 0a01 	movt	sl, #8193	; 0x2001
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801caa6:	ee0a 1a90 	vmov	s21, r1
 801caaa:	4619      	mov	r1, r3
 801caac:	f248 3304 	movw	r3, #33540	; 0x8304
 801cab0:	9209      	str	r2, [sp, #36]	; 0x24
 801cab2:	f243 473c 	movw	r7, #13372	; 0x343c
 801cab6:	f248 7994 	movw	r9, #34708	; 0x8794
 801caba:	461a      	mov	r2, r3
 801cabc:	f247 23dc 	movw	r3, #29404	; 0x72dc
 801cac0:	f240 6554 	movw	r5, #1620	; 0x654
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 801cac4:	f04f 4485 	mov.w	r4, #1115684864	; 0x42800000
 801cac8:	f2c2 0201 	movt	r2, #8193	; 0x2001
            for (int i = 0; i < numVoices; i++)
 801cacc:	465e      	mov	r6, fp
 801cace:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cad2:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801cad6:	9206      	str	r2, [sp, #24]
 801cad8:	461a      	mov	r2, r3
 801cada:	f642 0348 	movw	r3, #10312	; 0x2848
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801cade:	ee0b ba10 	vmov	s22, fp
 801cae2:	f2c2 0201 	movt	r2, #8193	; 0x2001
 801cae6:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801caea:	f2c2 0901 	movt	r9, #8193	; 0x2001
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 801caee:	ee0b 4a90 	vmov	s23, r4
 801caf2:	9201      	str	r2, [sp, #4]
 801caf4:	461a      	mov	r2, r3
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801caf6:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 801cafa:	9107      	str	r1, [sp, #28]
 801cafc:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801cb00:	9508      	str	r5, [sp, #32]
 801cb02:	9202      	str	r2, [sp, #8]
 801cb04:	461a      	mov	r2, r3
                        if (polyEnvs[i]->whichStage == env_idle)
 801cb06:	f247 639c 	movw	r3, #30364	; 0x769c
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801cb0a:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
                        if (polyEnvs[i]->whichStage == env_idle)
 801cb0e:	f2c2 0301 	movt	r3, #8193	; 0x2001
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801cb12:	9205      	str	r2, [sp, #20]
                        if (polyEnvs[i]->whichStage == env_idle)
 801cb14:	930b      	str	r3, [sp, #44]	; 0x2c
 801cb16:	f247 2342 	movw	r3, #29250	; 0x7242
 801cb1a:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801cb1e:	9303      	str	r3, [sp, #12]
 801cb20:	4653      	mov	r3, sl
 801cb22:	46da      	mov	sl, fp
 801cb24:	469b      	mov	fp, r3
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 801cb26:	b2f3      	uxtb	r3, r6
 801cb28:	9a06      	ldr	r2, [sp, #24]
 801cb2a:	4658      	mov	r0, fp
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 801cb2c:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 801cb30:	461c      	mov	r4, r3
 801cb32:	4619      	mov	r1, r3
 801cb34:	930a      	str	r3, [sp, #40]	; 0x28
 801cb36:	eb02 050a 	add.w	r5, r2, sl
 801cb3a:	f00b fde7 	bl	802870c <tSimplePoly_getPitch>
 801cb3e:	ee07 0a90 	vmov	s15, r0
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801cb42:	4621      	mov	r1, r4
 801cb44:	4658      	mov	r0, fp
                float myMidiNote = tSimplePoly_getPitch(&poly, i);
 801cb46:	eeb8 aae7 	vcvt.f32.s32	s20, s15
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801cb4a:	f00b fddf 	bl	802870c <tSimplePoly_getPitch>
 801cb4e:	ee07 0a90 	vmov	s15, r0
 801cb52:	9b07      	ldr	r3, [sp, #28]
 801cb54:	f10a 080c 	add.w	r8, sl, #12
 801cb58:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 801cb5c:	ed93 0a00 	vldr	s0, [r3]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801cb60:	9b08      	ldr	r3, [sp, #32]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801cb62:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801cb66:	7818      	ldrb	r0, [r3, #0]
 801cb68:	9b05      	ldr	r3, [sp, #20]
 801cb6a:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801cb6e:	ee17 1a90 	vmov	r1, s15
 801cb72:	1a09      	subs	r1, r1, r0
 801cb74:	fb83 3401 	smull	r3, r4, r3, r1
 801cb78:	17c8      	asrs	r0, r1, #31
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801cb7a:	9b09      	ldr	r3, [sp, #36]	; 0x24
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801cb7c:	ebc0 0064 	rsb	r0, r0, r4, asr #1
 801cb80:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801cb84:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
 801cb88:	ee07 0a90 	vmov	s15, r0
 801cb8c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801cb90:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cb94:	ee17 1a90 	vmov	r1, s15
 801cb98:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 801cb9c:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801cba0:	ee37 0a00 	vadd.f32	s0, s14, s0
 801cba4:	f00a fff2 	bl	8027b8c <LEAF_midiToFrequency>
 801cba8:	464b      	mov	r3, r9
 801cbaa:	46b1      	mov	r9, r6
 801cbac:	eca7 0a01 	vstmia	r7!, {s0}
 801cbb0:	461e      	mov	r6, r3
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 801cbb2:	eeb0 8a49 	vmov.f32	s16, s18
 801cbb6:	ecb5 7a01 	vldmia	r5!, {s14}
 801cbba:	edd6 7a03 	vldr	s15, [r6, #12]
 801cbbe:	9b02      	ldr	r3, [sp, #8]
 801cbc0:	eea7 8a27 	vfma.f32	s16, s14, s15
 801cbc4:	eb03 040a 	add.w	r4, r3, sl
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 801cbc8:	9b01      	ldr	r3, [sp, #4]
 801cbca:	eb03 000a 	add.w	r0, r3, sl
 801cbce:	f10a 0a04 	add.w	sl, sl, #4
                    float tempFreq = freq[i] * (1.0f + (synthDetune[i][j] * displayValues[3]));
 801cbd2:	ee28 8a00 	vmul.f32	s16, s16, s0
                    tSawtooth_setFreq(&osc[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 801cbd6:	eeb0 0a48 	vmov.f32	s0, s16
 801cbda:	f00b fe5d 	bl	8028898 <tSawtooth_setFreq>
                    tRosenbergGlottalPulse_setFreq(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempFreq);
 801cbde:	eeb0 0a48 	vmov.f32	s0, s16
 801cbe2:	4620      	mov	r0, r4
 801cbe4:	f007 fcf2 	bl	80245cc <tRosenbergGlottalPulse_setFreq>
                    tRosenbergGlottalPulse_setPulseLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO1);
 801cbe8:	eeb0 0a69 	vmov.f32	s0, s19
 801cbec:	4620      	mov	r0, r4
 801cbee:	f007 fd09 	bl	8024604 <tRosenbergGlottalPulse_setPulseLength>
                    tRosenbergGlottalPulse_setOpenLength(&glottal[(i * NUM_OSC_PER_VOICE) + j], tempLFO2);
 801cbf2:	eeb0 0a68 	vmov.f32	s0, s17
 801cbf6:	4620      	mov	r0, r4
 801cbf8:	f007 fcf6 	bl	80245e8 <tRosenbergGlottalPulse_setOpenLength>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801cbfc:	45c2      	cmp	sl, r8
 801cbfe:	d002      	beq.n	801cc06 <SFXClassicSynthFrame+0x246>
 801cc00:	ed17 0a01 	vldr	s0, [r7, #-4]
 801cc04:	e7d5      	b.n	801cbb2 <SFXClassicSynthFrame+0x1f2>
 801cc06:	4633      	mov	r3, r6
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801cc08:	eeb0 1a6a 	vmov.f32	s2, s21
 801cc0c:	eeb0 0a4b 	vmov.f32	s0, s22
 801cc10:	464e      	mov	r6, r9
                float tempFreq2 = displayValues[1] +  keyFollowFilt;
 801cc12:	edd3 7a02 	vldr	s15, [r3, #8]
 801cc16:	4699      	mov	r9, r3
 801cc18:	edd3 0a01 	vldr	s1, [r3, #4]
 801cc1c:	ee67 7aab 	vmul.f32	s15, s15, s23
                tempFreq2 = LEAF_clip(0.0f, tempFreq2, 4095.0f);
 801cc20:	eeea 0a27 	vfma.f32	s1, s20, s15
 801cc24:	f00a fec8 	bl	80279b8 <LEAF_clip>
                if (numVoices > 1)
 801cc28:	9b04      	ldr	r3, [sp, #16]
                filtFreqs[i] = (uint16_t) tempFreq2;
 801cc2a:	eebc 0ac0 	vcvt.u32.f32	s0, s0
                if (numVoices > 1)
 801cc2e:	7819      	ldrb	r1, [r3, #0]
                filtFreqs[i] = (uint16_t) tempFreq2;
 801cc30:	9b03      	ldr	r3, [sp, #12]
 801cc32:	ee10 2a10 	vmov	r2, s0
                if (numVoices > 1)
 801cc36:	2901      	cmp	r1, #1
                filtFreqs[i] = (uint16_t) tempFreq2;
 801cc38:	f823 2f02 	strh.w	r2, [r3, #2]!
 801cc3c:	9303      	str	r3, [sp, #12]
                if (numVoices > 1)
 801cc3e:	d907      	bls.n	801cc50 <SFXClassicSynthFrame+0x290>
                    if (poly->voices[i][0] == -2)
 801cc40:	f8db 0000 	ldr.w	r0, [fp]
 801cc44:	6900      	ldr	r0, [r0, #16]
 801cc46:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
 801cc4a:	6800      	ldr	r0, [r0, #0]
 801cc4c:	3002      	adds	r0, #2
 801cc4e:	d008      	beq.n	801cc62 <SFXClassicSynthFrame+0x2a2>
            for (int i = 0; i < numVoices; i++)
 801cc50:	3601      	adds	r6, #1
 801cc52:	42b1      	cmp	r1, r6
 801cc54:	f73f af67 	bgt.w	801cb26 <SFXClassicSynthFrame+0x166>
        }
 801cc58:	b00d      	add	sp, #52	; 0x34
 801cc5a:	ecbd 8b08 	vpop	{d8-d11}
 801cc5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (polyEnvs[i]->whichStage == env_idle)
 801cc62:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801cc64:	f853 0026 	ldr.w	r0, [r3, r6, lsl #2]
 801cc68:	6a80      	ldr	r0, [r0, #40]	; 0x28
 801cc6a:	2800      	cmp	r0, #0
 801cc6c:	d1f0      	bne.n	801cc50 <SFXClassicSynthFrame+0x290>
                            tSimplePoly_deactivateVoice(&poly, i);
 801cc6e:	990a      	ldr	r1, [sp, #40]	; 0x28
 801cc70:	4658      	mov	r0, fp
 801cc72:	f00b fc71 	bl	8028558 <tSimplePoly_deactivateVoice>
 801cc76:	9b04      	ldr	r3, [sp, #16]
 801cc78:	7819      	ldrb	r1, [r3, #0]
 801cc7a:	e7e9      	b.n	801cc50 <SFXClassicSynthFrame+0x290>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801cc7c:	f240 2550 	movw	r5, #592	; 0x250
                tSimplePoly_setNumVoices(&poly, numVoices);
 801cc80:	f247 5020 	movw	r0, #29984	; 0x7520
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801cc84:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tSimplePoly_setNumVoices(&poly, numVoices);
 801cc88:	f2c2 0001 	movt	r0, #8193	; 0x2001
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801cc8c:	782a      	ldrb	r2, [r5, #0]
 801cc8e:	9504      	str	r5, [sp, #16]
 801cc90:	2a01      	cmp	r2, #1
 801cc92:	bf98      	it	ls
 801cc94:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
 801cc96:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801cc98:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 801cc9a:	f00b fd13 	bl	80286c4 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 801cc9e:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801cca0:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 801cca2:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801cca6:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 801cca8:	fab0 f080 	clz	r0, r0
 801ccac:	0940      	lsrs	r0, r0, #5
 801ccae:	f7f8 fe1d 	bl	80158ec <setLED_A>
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801ccb2:	7e23      	ldrb	r3, [r4, #24]
 801ccb4:	2b01      	cmp	r3, #1
 801ccb6:	f47f ae99 	bne.w	801c9ec <SFXClassicSynthFrame+0x2c>
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801ccba:	2300      	movs	r3, #0
                setLED_Edit(0);
 801ccbc:	4618      	mov	r0, r3
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801ccbe:	7623      	strb	r3, [r4, #24]
                setLED_Edit(0);
 801ccc0:	f7f8 fdd4 	bl	801586c <setLED_Edit>
 801ccc4:	e692      	b.n	801c9ec <SFXClassicSynthFrame+0x2c>
                        displayValues[16] = knobs[16];  // fade between sawtooth and glottal pulse
 801ccc6:	f243 3390 	movw	r3, #13200	; 0x3390
 801ccca:	f248 7994 	movw	r9, #34708	; 0x8794
 801ccce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ccd2:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801ccd6:	681b      	ldr	r3, [r3, #0]
 801ccd8:	f8c9 3040 	str.w	r3, [r9, #64]	; 0x40
                        break;
 801ccdc:	e6b6      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[15] = knobs[15] * 4095.0f;  // filter envelope amount
 801ccde:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 801cce2:	f243 318c 	movw	r1, #13196	; 0x338c
 801cce6:	f248 7994 	movw	r9, #34708	; 0x8794
 801ccea:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801ccee:	f2c4 537f 	movt	r3, #17791	; 0x457f
 801ccf2:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801ccf6:	ed91 7a00 	vldr	s14, [r1]
 801ccfa:	ee07 3a90 	vmov	s15, r3
 801ccfe:	ee67 7a27 	vmul.f32	s15, s14, s15
 801cd02:	edc9 7a0f 	vstr	s15, [r9, #60]	; 0x3c
                        break;
 801cd06:	e6a1      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[14] = knobs[14]; //leak
 801cd08:	f243 3188 	movw	r1, #13192	; 0x3388
 801cd0c:	f248 7994 	movw	r9, #34708	; 0x8794
                        for (int i = 0; i < numVoices; i++)
 801cd10:	9e04      	ldr	r6, [sp, #16]
                        displayValues[14] = knobs[14]; //leak
 801cd12:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cd16:	f2c2 0901 	movt	r9, #8193	; 0x2001
                        for (int i = 0; i < numVoices; i++)
 801cd1a:	7833      	ldrb	r3, [r6, #0]
                        displayValues[14] = knobs[14]; //leak
 801cd1c:	edd1 7a00 	vldr	s15, [r1]
 801cd20:	edc9 7a0e 	vstr	s15, [r9, #56]	; 0x38
                        for (int i = 0; i < numVoices; i++)
 801cd24:	2b00      	cmp	r3, #0
 801cd26:	f43f ae91 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 801cd2a:	f24b 7117 	movw	r1, #46871	; 0xb717
 801cd2e:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
 801cd32:	f641 7448 	movw	r4, #8008	; 0x1f48
 801cd36:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 801cd3a:	f6c3 0151 	movt	r1, #14417	; 0x3851
 801cd3e:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 801cd42:	f2c2 0400 	movt	r4, #8192	; 0x2000
                        for (int i = 0; i < numVoices; i++)
 801cd46:	2500      	movs	r5, #0
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 801cd48:	ee08 1a90 	vmov	s17, r1
 801cd4c:	ee08 3a10 	vmov	s16, r3
 801cd50:	e001      	b.n	801cd56 <SFXClassicSynthFrame+0x396>
 801cd52:	edd9 7a0e 	vldr	s15, [r9, #56]	; 0x38
 801cd56:	ee79 7a67 	vsub.f32	s15, s18, s15
 801cd5a:	4620      	mov	r0, r4
 801cd5c:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
 801cd60:	3501      	adds	r5, #1
 801cd62:	3404      	adds	r4, #4
                            tADSR4_setLeakFactor(&polyFiltEnvs[i], ((1.0f - displayValues[14]) * 0.00005f) + 0.99995f);
 801cd64:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801cd68:	f008 fdbe 	bl	80258e8 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
 801cd6c:	7833      	ldrb	r3, [r6, #0]
 801cd6e:	42ab      	cmp	r3, r5
 801cd70:	dcef      	bgt.n	801cd52 <SFXClassicSynthFrame+0x392>
 801cd72:	e66b      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cd74:	f240 2138 	movw	r1, #568	; 0x238
 801cd78:	f243 3084 	movw	r0, #13188	; 0x3384
 801cd7c:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801cd80:	f247 0344 	movw	r3, #28740	; 0x7044
 801cd84:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cd88:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801cd8c:	ee07 2a10 	vmov	s14, r2
 801cd90:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801cd94:	edd1 6a00 	vldr	s13, [r1]
 801cd98:	f248 7994 	movw	r9, #34708	; 0x8794
 801cd9c:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801cda0:	9e04      	ldr	r6, [sp, #16]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cda2:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801cda6:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801cdaa:	7831      	ldrb	r1, [r6, #0]
                        displayValues[13] = expBuffer[(int)(knobs[13] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cdac:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cdb0:	ee17 2a90 	vmov	r2, s15
 801cdb4:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801cdb8:	ed93 0a00 	vldr	s0, [r3]
 801cdbc:	ee20 0a07 	vmul.f32	s0, s0, s14
 801cdc0:	ed89 0a0d 	vstr	s0, [r9, #52]	; 0x34
                        for (int i = 0; i < numVoices; i++)
 801cdc4:	2900      	cmp	r1, #0
 801cdc6:	f43f ae41 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801cdca:	f641 7448 	movw	r4, #8008	; 0x1f48
 801cdce:	2500      	movs	r5, #0
 801cdd0:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801cdd4:	e001      	b.n	801cdda <SFXClassicSynthFrame+0x41a>
 801cdd6:	ed99 0a0d 	vldr	s0, [r9, #52]	; 0x34
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
 801cdda:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801cddc:	3501      	adds	r5, #1
                            tADSR4_setRelease(&polyFiltEnvs[i], displayValues[13]);
 801cdde:	f008 fd75 	bl	80258cc <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
 801cde2:	7833      	ldrb	r3, [r6, #0]
 801cde4:	3404      	adds	r4, #4
 801cde6:	42ab      	cmp	r3, r5
 801cde8:	dcf5      	bgt.n	801cdd6 <SFXClassicSynthFrame+0x416>
 801cdea:	e62f      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[12] = knobs[12]; //sus
 801cdec:	f243 3180 	movw	r1, #13184	; 0x3380
 801cdf0:	f248 7994 	movw	r9, #34708	; 0x8794
                        for (int i = 0; i < numVoices; i++)
 801cdf4:	9e04      	ldr	r6, [sp, #16]
                        displayValues[12] = knobs[12]; //sus
 801cdf6:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cdfa:	f2c2 0901 	movt	r9, #8193	; 0x2001
                        for (int i = 0; i < numVoices; i++)
 801cdfe:	7833      	ldrb	r3, [r6, #0]
                        displayValues[12] = knobs[12]; //sus
 801ce00:	ed91 0a00 	vldr	s0, [r1]
 801ce04:	ed89 0a0c 	vstr	s0, [r9, #48]	; 0x30
                        for (int i = 0; i < numVoices; i++)
 801ce08:	2b00      	cmp	r3, #0
 801ce0a:	f43f ae1f 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801ce0e:	f641 7448 	movw	r4, #8008	; 0x1f48
 801ce12:	2500      	movs	r5, #0
 801ce14:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801ce18:	e001      	b.n	801ce1e <SFXClassicSynthFrame+0x45e>
 801ce1a:	ed99 0a0c 	vldr	s0, [r9, #48]	; 0x30
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
 801ce1e:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801ce20:	3501      	adds	r5, #1
                            tADSR4_setSustain(&polyFiltEnvs[i], displayValues[12]);
 801ce22:	f008 fd3d 	bl	80258a0 <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
 801ce26:	7833      	ldrb	r3, [r6, #0]
 801ce28:	3404      	adds	r4, #4
 801ce2a:	42ab      	cmp	r3, r5
 801ce2c:	dcf5      	bgt.n	801ce1a <SFXClassicSynthFrame+0x45a>
 801ce2e:	e60d      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801ce30:	f240 2138 	movw	r1, #568	; 0x238
 801ce34:	f243 307c 	movw	r0, #13180	; 0x337c
 801ce38:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801ce3c:	f247 0344 	movw	r3, #28740	; 0x7044
 801ce40:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801ce44:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ce48:	ee07 2a10 	vmov	s14, r2
 801ce4c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ce50:	edd1 6a00 	vldr	s13, [r1]
 801ce54:	f248 7994 	movw	r9, #34708	; 0x8794
 801ce58:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801ce5c:	9e04      	ldr	r6, [sp, #16]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801ce5e:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801ce62:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801ce66:	7831      	ldrb	r1, [r6, #0]
                        displayValues[11] = expBuffer[(int)(knobs[11] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801ce68:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ce6c:	ee17 2a90 	vmov	r2, s15
 801ce70:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801ce74:	ed93 0a00 	vldr	s0, [r3]
 801ce78:	ee20 0a07 	vmul.f32	s0, s0, s14
 801ce7c:	ed89 0a0b 	vstr	s0, [r9, #44]	; 0x2c
                        for (int i = 0; i < numVoices; i++)
 801ce80:	2900      	cmp	r1, #0
 801ce82:	f43f ade3 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801ce86:	f641 7448 	movw	r4, #8008	; 0x1f48
 801ce8a:	2500      	movs	r5, #0
 801ce8c:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801ce90:	e001      	b.n	801ce96 <SFXClassicSynthFrame+0x4d6>
 801ce92:	ed99 0a0b 	vldr	s0, [r9, #44]	; 0x2c
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
 801ce96:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801ce98:	3501      	adds	r5, #1
                            tADSR4_setDecay(&polyFiltEnvs[i], displayValues[11]);
 801ce9a:	f008 fcf3 	bl	8025884 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
 801ce9e:	7833      	ldrb	r3, [r6, #0]
 801cea0:	3404      	adds	r4, #4
 801cea2:	42ab      	cmp	r3, r5
 801cea4:	dcf5      	bgt.n	801ce92 <SFXClassicSynthFrame+0x4d2>
 801cea6:	e5d1      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801cea8:	f240 2138 	movw	r1, #568	; 0x238
 801ceac:	f243 3078 	movw	r0, #13176	; 0x3378
 801ceb0:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801ceb4:	f247 0344 	movw	r3, #28740	; 0x7044
 801ceb8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cebc:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801cec0:	ee07 2a10 	vmov	s14, r2
 801cec4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801cec8:	edd1 6a00 	vldr	s13, [r1]
 801cecc:	f248 7994 	movw	r9, #34708	; 0x8794
 801ced0:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801ced4:	9e04      	ldr	r6, [sp, #16]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801ced6:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801ceda:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801cede:	7831      	ldrb	r1, [r6, #0]
                        displayValues[10] = expBuffer[(int)(knobs[10] * expBufferSizeMinusOne)] * 8192.0f; //att
 801cee0:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cee4:	ee17 2a90 	vmov	r2, s15
 801cee8:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801ceec:	ed93 0a00 	vldr	s0, [r3]
 801cef0:	ee20 0a07 	vmul.f32	s0, s0, s14
 801cef4:	ed89 0a0a 	vstr	s0, [r9, #40]	; 0x28
                        for (int i = 0; i < numVoices; i++)
 801cef8:	2900      	cmp	r1, #0
 801cefa:	f43f ada7 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801cefe:	f641 7448 	movw	r4, #8008	; 0x1f48
 801cf02:	2500      	movs	r5, #0
 801cf04:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801cf08:	e001      	b.n	801cf0e <SFXClassicSynthFrame+0x54e>
 801cf0a:	ed99 0a0a 	vldr	s0, [r9, #40]	; 0x28
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
 801cf0e:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801cf10:	3501      	adds	r5, #1
                            tADSR4_setAttack(&polyFiltEnvs[i], displayValues[10]);
 801cf12:	f008 fca9 	bl	8025868 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
 801cf16:	7833      	ldrb	r3, [r6, #0]
 801cf18:	3404      	adds	r4, #4
 801cf1a:	42ab      	cmp	r3, r5
 801cf1c:	dcf5      	bgt.n	801cf0a <SFXClassicSynthFrame+0x54a>
 801cf1e:	e595      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[9] = knobs[9]; //leak
 801cf20:	f243 3174 	movw	r1, #13172	; 0x3374
 801cf24:	f248 7994 	movw	r9, #34708	; 0x8794
                        for (int i = 0; i < numVoices; i++)
 801cf28:	9e04      	ldr	r6, [sp, #16]
                        displayValues[9] = knobs[9]; //leak
 801cf2a:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cf2e:	f2c2 0901 	movt	r9, #8193	; 0x2001
                        for (int i = 0; i < numVoices; i++)
 801cf32:	7833      	ldrb	r3, [r6, #0]
                        displayValues[9] = knobs[9]; //leak
 801cf34:	edd1 7a00 	vldr	s15, [r1]
 801cf38:	edc9 7a09 	vstr	s15, [r9, #36]	; 0x24
                        for (int i = 0; i < numVoices; i++)
 801cf3c:	2b00      	cmp	r3, #0
 801cf3e:	f43f ad85 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 801cf42:	f24b 7117 	movw	r1, #46871	; 0xb717
 801cf46:	f64f 43b9 	movw	r3, #64697	; 0xfcb9
 801cf4a:	f247 649c 	movw	r4, #30364	; 0x769c
 801cf4e:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 801cf52:	f6c3 0151 	movt	r1, #14417	; 0x3851
 801cf56:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 801cf5a:	f2c2 0401 	movt	r4, #8193	; 0x2001
                        for (int i = 0; i < numVoices; i++)
 801cf5e:	2500      	movs	r5, #0
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 801cf60:	ee08 1a90 	vmov	s17, r1
 801cf64:	ee08 3a10 	vmov	s16, r3
 801cf68:	e001      	b.n	801cf6e <SFXClassicSynthFrame+0x5ae>
 801cf6a:	edd9 7a09 	vldr	s15, [r9, #36]	; 0x24
 801cf6e:	ee79 7a67 	vsub.f32	s15, s18, s15
 801cf72:	4620      	mov	r0, r4
 801cf74:	eeb0 0a48 	vmov.f32	s0, s16
                        for (int i = 0; i < numVoices; i++)
 801cf78:	3501      	adds	r5, #1
 801cf7a:	3404      	adds	r4, #4
                            tADSR4_setLeakFactor(&polyEnvs[i], ((1.0f - displayValues[9]) * 0.00005f) + 0.99995f);
 801cf7c:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801cf80:	f008 fcb2 	bl	80258e8 <tADSR4_setLeakFactor>
                        for (int i = 0; i < numVoices; i++)
 801cf84:	7833      	ldrb	r3, [r6, #0]
 801cf86:	42ab      	cmp	r3, r5
 801cf88:	dcef      	bgt.n	801cf6a <SFXClassicSynthFrame+0x5aa>
 801cf8a:	e55f      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cf8c:	f240 2138 	movw	r1, #568	; 0x238
 801cf90:	f243 3070 	movw	r0, #13168	; 0x3370
 801cf94:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801cf98:	f247 0344 	movw	r3, #28740	; 0x7044
 801cf9c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801cfa0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801cfa4:	ee07 2a10 	vmov	s14, r2
 801cfa8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801cfac:	edd1 6a00 	vldr	s13, [r1]
 801cfb0:	f248 7994 	movw	r9, #34708	; 0x8794
 801cfb4:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801cfb8:	9e04      	ldr	r6, [sp, #16]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cfba:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801cfbe:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801cfc2:	7831      	ldrb	r1, [r6, #0]
                        displayValues[8] = expBuffer[(int)(knobs[8] * expBufferSizeMinusOne)] * 8192.0f; //rel
 801cfc4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801cfc8:	ee17 2a90 	vmov	r2, s15
 801cfcc:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801cfd0:	ed93 0a00 	vldr	s0, [r3]
 801cfd4:	ee20 0a07 	vmul.f32	s0, s0, s14
 801cfd8:	ed89 0a08 	vstr	s0, [r9, #32]
                        for (int i = 0; i < numVoices; i++)
 801cfdc:	2900      	cmp	r1, #0
 801cfde:	f43f ad35 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801cfe2:	f247 649c 	movw	r4, #30364	; 0x769c
 801cfe6:	2500      	movs	r5, #0
 801cfe8:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801cfec:	e001      	b.n	801cff2 <SFXClassicSynthFrame+0x632>
 801cfee:	ed99 0a08 	vldr	s0, [r9, #32]
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
 801cff2:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801cff4:	3501      	adds	r5, #1
                            tADSR4_setRelease(&polyEnvs[i], displayValues[8]);
 801cff6:	f008 fc69 	bl	80258cc <tADSR4_setRelease>
                        for (int i = 0; i < numVoices; i++)
 801cffa:	7833      	ldrb	r3, [r6, #0]
 801cffc:	3404      	adds	r4, #4
 801cffe:	42ab      	cmp	r3, r5
 801d000:	dcf5      	bgt.n	801cfee <SFXClassicSynthFrame+0x62e>
 801d002:	e523      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[7] = knobs[7]; //sus
 801d004:	f243 316c 	movw	r1, #13164	; 0x336c
 801d008:	f248 7994 	movw	r9, #34708	; 0x8794
                        for (int i = 0; i < numVoices; i++)
 801d00c:	9e04      	ldr	r6, [sp, #16]
                        displayValues[7] = knobs[7]; //sus
 801d00e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801d012:	f2c2 0901 	movt	r9, #8193	; 0x2001
                        for (int i = 0; i < numVoices; i++)
 801d016:	7833      	ldrb	r3, [r6, #0]
                        displayValues[7] = knobs[7]; //sus
 801d018:	ed91 0a00 	vldr	s0, [r1]
 801d01c:	ed89 0a07 	vstr	s0, [r9, #28]
                        for (int i = 0; i < numVoices; i++)
 801d020:	2b00      	cmp	r3, #0
 801d022:	f43f ad13 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801d026:	f247 649c 	movw	r4, #30364	; 0x769c
 801d02a:	2500      	movs	r5, #0
 801d02c:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801d030:	e001      	b.n	801d036 <SFXClassicSynthFrame+0x676>
 801d032:	ed99 0a07 	vldr	s0, [r9, #28]
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
 801d036:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801d038:	3501      	adds	r5, #1
                            tADSR4_setSustain(&polyEnvs[i], displayValues[7]);
 801d03a:	f008 fc31 	bl	80258a0 <tADSR4_setSustain>
                        for (int i = 0; i < numVoices; i++)
 801d03e:	7833      	ldrb	r3, [r6, #0]
 801d040:	3404      	adds	r4, #4
 801d042:	42ab      	cmp	r3, r5
 801d044:	dcf5      	bgt.n	801d032 <SFXClassicSynthFrame+0x672>
 801d046:	e501      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801d048:	f240 2138 	movw	r1, #568	; 0x238
 801d04c:	f243 3068 	movw	r0, #13160	; 0x3368
 801d050:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801d054:	f247 0344 	movw	r3, #28740	; 0x7044
 801d058:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801d05c:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801d060:	ee07 2a10 	vmov	s14, r2
 801d064:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801d068:	edd1 6a00 	vldr	s13, [r1]
 801d06c:	f248 7994 	movw	r9, #34708	; 0x8794
 801d070:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801d074:	9e04      	ldr	r6, [sp, #16]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801d076:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d07a:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801d07e:	7831      	ldrb	r1, [r6, #0]
                        displayValues[6] = expBuffer[(int)(knobs[6] * expBufferSizeMinusOne)] * 8192.0f; //dec
 801d080:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801d084:	ee17 2a90 	vmov	r2, s15
 801d088:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801d08c:	ed93 0a00 	vldr	s0, [r3]
 801d090:	ee20 0a07 	vmul.f32	s0, s0, s14
 801d094:	ed89 0a06 	vstr	s0, [r9, #24]
                        for (int i = 0; i < numVoices; i++)
 801d098:	2900      	cmp	r1, #0
 801d09a:	f43f acd7 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801d09e:	f247 649c 	movw	r4, #30364	; 0x769c
 801d0a2:	2500      	movs	r5, #0
 801d0a4:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801d0a8:	e001      	b.n	801d0ae <SFXClassicSynthFrame+0x6ee>
 801d0aa:	ed99 0a06 	vldr	s0, [r9, #24]
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
 801d0ae:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801d0b0:	3501      	adds	r5, #1
                            tADSR4_setDecay(&polyEnvs[i], displayValues[6]);
 801d0b2:	f008 fbe7 	bl	8025884 <tADSR4_setDecay>
                        for (int i = 0; i < numVoices; i++)
 801d0b6:	7833      	ldrb	r3, [r6, #0]
 801d0b8:	3404      	adds	r4, #4
 801d0ba:	42ab      	cmp	r3, r5
 801d0bc:	dcf5      	bgt.n	801d0aa <SFXClassicSynthFrame+0x6ea>
 801d0be:	e4c5      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801d0c0:	f240 2138 	movw	r1, #568	; 0x238
 801d0c4:	f243 3064 	movw	r0, #13156	; 0x3364
 801d0c8:	f04f 428c 	mov.w	r2, #1174405120	; 0x46000000
 801d0cc:	f247 0344 	movw	r3, #28740	; 0x7044
 801d0d0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801d0d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801d0d8:	ee07 2a10 	vmov	s14, r2
 801d0dc:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801d0e0:	edd1 6a00 	vldr	s13, [r1]
 801d0e4:	f248 7994 	movw	r9, #34708	; 0x8794
 801d0e8:	edd0 7a00 	vldr	s15, [r0]
                        for (int i = 0; i < numVoices; i++)
 801d0ec:	9e04      	ldr	r6, [sp, #16]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801d0ee:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d0f2:	ee67 7aa6 	vmul.f32	s15, s15, s13
                        for (int i = 0; i < numVoices; i++)
 801d0f6:	7831      	ldrb	r1, [r6, #0]
                        displayValues[5] = expBuffer[(int)(knobs[5] * expBufferSizeMinusOne)] * 8192.0f; //att
 801d0f8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801d0fc:	ee17 2a90 	vmov	r2, s15
 801d100:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801d104:	ed93 0a00 	vldr	s0, [r3]
 801d108:	ee20 0a07 	vmul.f32	s0, s0, s14
 801d10c:	ed89 0a05 	vstr	s0, [r9, #20]
                        for (int i = 0; i < numVoices; i++)
 801d110:	2900      	cmp	r1, #0
 801d112:	f43f ac9b 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801d116:	f247 649c 	movw	r4, #30364	; 0x769c
 801d11a:	2500      	movs	r5, #0
 801d11c:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801d120:	e001      	b.n	801d126 <SFXClassicSynthFrame+0x766>
 801d122:	ed99 0a05 	vldr	s0, [r9, #20]
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
 801d126:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801d128:	3501      	adds	r5, #1
                            tADSR4_setAttack(&polyEnvs[i], displayValues[5]);
 801d12a:	f008 fb9d 	bl	8025868 <tADSR4_setAttack>
                        for (int i = 0; i < numVoices; i++)
 801d12e:	7833      	ldrb	r3, [r6, #0]
 801d130:	3404      	adds	r4, #4
 801d132:	42ab      	cmp	r3, r5
 801d134:	dcf5      	bgt.n	801d122 <SFXClassicSynthFrame+0x762>
 801d136:	e489      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801d138:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801d13c:	f243 3160 	movw	r1, #13152	; 0x3360
 801d140:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 801d144:	f248 7994 	movw	r9, #34708	; 0x8794
 801d148:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801d14c:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
                        for (int i = 0; i < numVoices; i++)
 801d150:	9e04      	ldr	r6, [sp, #16]
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801d152:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d156:	ed91 7a00 	vldr	s14, [r1]
 801d15a:	ee00 3a10 	vmov	s0, r3
                        for (int i = 0; i < numVoices; i++)
 801d15e:	7831      	ldrb	r1, [r6, #0]
                        displayValues[4] = (knobs[4] * 2.0f) + 0.4f; //filter Q
 801d160:	eea7 0a27 	vfma.f32	s0, s14, s15
 801d164:	ed89 0a04 	vstr	s0, [r9, #16]
                        for (int i = 0; i < numVoices; i++)
 801d168:	2900      	cmp	r1, #0
 801d16a:	f43f ac6f 	beq.w	801ca4c <SFXClassicSynthFrame+0x8c>
 801d16e:	f243 4418 	movw	r4, #13336	; 0x3418
 801d172:	2500      	movs	r5, #0
 801d174:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801d178:	e001      	b.n	801d17e <SFXClassicSynthFrame+0x7be>
 801d17a:	ed99 0a04 	vldr	s0, [r9, #16]
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
 801d17e:	4620      	mov	r0, r4
                        for (int i = 0; i < numVoices; i++)
 801d180:	3501      	adds	r5, #1
                            tEfficientSVF_setQ(&synthLP[i],displayValues[4]);
 801d182:	f009 f9e3 	bl	802654c <tEfficientSVF_setQ>
                        for (int i = 0; i < numVoices; i++)
 801d186:	7833      	ldrb	r3, [r6, #0]
 801d188:	3404      	adds	r4, #4
 801d18a:	42ab      	cmp	r3, r5
 801d18c:	dcf5      	bgt.n	801d17a <SFXClassicSynthFrame+0x7ba>
 801d18e:	e45d      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[3] = knobs[3]; //detune
 801d190:	f243 335c 	movw	r3, #13148	; 0x335c
 801d194:	f248 7994 	movw	r9, #34708	; 0x8794
 801d198:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d19c:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d1a0:	681b      	ldr	r3, [r3, #0]
 801d1a2:	f8c9 300c 	str.w	r3, [r9, #12]
                        break;
 801d1a6:	e451      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[2] = knobs[2]; //keyfollow filter cutoff
 801d1a8:	f243 3358 	movw	r3, #13144	; 0x3358
 801d1ac:	f248 7994 	movw	r9, #34708	; 0x8794
 801d1b0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d1b4:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d1b8:	681b      	ldr	r3, [r3, #0]
 801d1ba:	f8c9 3008 	str.w	r3, [r9, #8]
                        break;
 801d1be:	e445      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
                        displayValues[1] = knobs[1] * 4096.0f; //lowpass cutoff
 801d1c0:	f243 3154 	movw	r1, #13140	; 0x3354
 801d1c4:	f04f 438b 	mov.w	r3, #1166016512	; 0x45800000
 801d1c8:	f248 7994 	movw	r9, #34708	; 0x8794
 801d1cc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801d1d0:	ee07 3a10 	vmov	s14, r3
 801d1d4:	f2c2 0901 	movt	r9, #8193	; 0x2001
 801d1d8:	edd1 7a00 	vldr	s15, [r1]
 801d1dc:	ee67 7a87 	vmul.f32	s15, s15, s14
 801d1e0:	edc9 7a01 	vstr	s15, [r9, #4]
                        break;
 801d1e4:	e432      	b.n	801ca4c <SFXClassicSynthFrame+0x8c>
 801d1e6:	bf00      	nop

0801d1e8 <SFXClassicSynthTick>:
            float sample = 0.0f;
 801d1e8:	2200      	movs	r2, #0
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d1ea:	f44f 4370 	mov.w	r3, #61440	; 0xf000
        {
 801d1ee:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d1f2:	4615      	mov	r5, r2
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d1f4:	f2c4 537f 	movt	r3, #17791	; 0x457f
 801d1f8:	f248 7494 	movw	r4, #34708	; 0x8794
 801d1fc:	f247 2a42 	movw	sl, #29250	; 0x7242
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d200:	46a9      	mov	r9, r5
 801d202:	f04f 080c 	mov.w	r8, #12
 801d206:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801d20a:	f2c2 0a01 	movt	sl, #8193	; 0x2001
        {
 801d20e:	ed2d 8b08 	vpush	{d8-d11}
            float sample = 0.0f;
 801d212:	ee0a 2a90 	vmov	s21, r2
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d216:	f247 5220 	movw	r2, #29984	; 0x7520
        {
 801d21a:	b083      	sub	sp, #12
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d21c:	ee0b 3a10 	vmov	s22, r3
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d220:	f2c2 0201 	movt	r2, #8193	; 0x2001
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d224:	ee0b 5a90 	vmov	s23, r5
        {
 801d228:	9001      	str	r0, [sp, #4]
 801d22a:	4610      	mov	r0, r2
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d22c:	9200      	str	r2, [sp, #0]
 801d22e:	f00b fa51 	bl	80286d4 <tSimplePoly_getNumVoices>
 801d232:	4548      	cmp	r0, r9
 801d234:	dd68      	ble.n	801d308 <SFXClassicSynthTick+0x120>
                float env = tADSR4_tick(&polyEnvs[i]);
 801d236:	f247 609c 	movw	r0, #30364	; 0x769c
 801d23a:	f247 27dc 	movw	r7, #29404	; 0x72dc
 801d23e:	f642 0648 	movw	r6, #10312	; 0x2848
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801d242:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
                float env = tADSR4_tick(&polyEnvs[i]);
 801d246:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d24a:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801d24e:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801d252:	eb05 0b45 	add.w	fp, r5, r5, lsl #1
 801d256:	4428      	add	r0, r5
 801d258:	f008 fb64 	bl	8025924 <tADSR4_tick>
                float tempSample = 0.0f;
 801d25c:	2200      	movs	r2, #0
                float env = tADSR4_tick(&polyEnvs[i]);
 801d25e:	eef0 9a40 	vmov.f32	s19, s0
                float tempSample = 0.0f;
 801d262:	ee08 2a90 	vmov	s17, r2
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801d266:	eb07 000b 	add.w	r0, r7, fp
 801d26a:	f00b fb49 	bl	8028900 <tSawtooth_tick>
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801d26e:	eb06 000b 	add.w	r0, r6, fp
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801d272:	eeb0 9a40 	vmov.f32	s18, s0
 801d276:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801d27a:	f007 f8c3 	bl	8024404 <tRosenbergGlottalPulse_tick>
 801d27e:	edd4 7a10 	vldr	s15, [r4, #64]	; 0x40
                    tempSample += tSawtooth_tick(&osc[(i * NUM_OSC_PER_VOICE) + j]) * env * (1.0f-displayValues[16]);
 801d282:	ee3a 8a48 	vsub.f32	s16, s20, s16
 801d286:	f10b 0b04 	add.w	fp, fp, #4
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801d28a:	ee20 0a27 	vmul.f32	s0, s0, s15
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801d28e:	45c3      	cmp	fp, r8
                    tempSample += tRosenbergGlottalPulse_tick(&glottal[(i * NUM_OSC_PER_VOICE) + j]) * env * (displayValues[16]);
 801d290:	eea9 0a08 	vfma.f32	s0, s18, s16
 801d294:	eee9 8a80 	vfma.f32	s17, s19, s0
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801d298:	d1e5      	bne.n	801d266 <SFXClassicSynthTick+0x7e>
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d29a:	f83a 3f02 	ldrh.w	r3, [sl, #2]!
 801d29e:	f641 7048 	movw	r0, #8008	; 0x1f48
 801d2a2:	ed94 9a0f 	vldr	s18, [r4, #60]	; 0x3c
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d2a6:	f109 0901 	add.w	r9, r9, #1
                tEfficientSVF_setFreq(&synthLP[i], LEAF_clip(0.0f, (filtFreqs[i] + (displayValues[15] * tADSR4_tick(&polyFiltEnvs[i]))), 4095.0f));
 801d2aa:	ee08 3a10 	vmov	s16, r3
 801d2ae:	f243 4318 	movw	r3, #13336	; 0x3418
 801d2b2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801d2b6:	f108 080c 	add.w	r8, r8, #12
 801d2ba:	eeb8 8ac8 	vcvt.f32.s32	s16, s16
 801d2be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d2c2:	4428      	add	r0, r5
 801d2c4:	18ee      	adds	r6, r5, r3
 801d2c6:	f008 fb2d 	bl	8025924 <tADSR4_tick>
 801d2ca:	eef0 0a48 	vmov.f32	s1, s16
 801d2ce:	3504      	adds	r5, #4
 801d2d0:	eeb0 1a4b 	vmov.f32	s2, s22
 801d2d4:	eee9 0a00 	vfma.f32	s1, s18, s0
 801d2d8:	eeb0 0a6b 	vmov.f32	s0, s23
 801d2dc:	f00a fb6c 	bl	80279b8 <LEAF_clip>
 801d2e0:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 801d2e4:	4630      	mov	r0, r6
 801d2e6:	ee10 3a10 	vmov	r3, s0
 801d2ea:	b299      	uxth	r1, r3
 801d2ec:	f009 f90a 	bl	8026504 <tEfficientSVF_setFreq>
                sample += tEfficientSVF_tick(&synthLP[i], tempSample);
 801d2f0:	4630      	mov	r0, r6
 801d2f2:	eeb0 0a68 	vmov.f32	s0, s17
 801d2f6:	f009 f8b5 	bl	8026464 <tEfficientSVF_tick>
 801d2fa:	9800      	ldr	r0, [sp, #0]
 801d2fc:	ee7a aa80 	vadd.f32	s21, s21, s0
            for (int i = 0; i < tSimplePoly_getNumVoices(&poly); i++)
 801d300:	f00b f9e8 	bl	80286d4 <tSimplePoly_getNumVoices>
 801d304:	4548      	cmp	r0, r9
 801d306:	dc96      	bgt.n	801d236 <SFXClassicSynthTick+0x4e>
            sample *= INV_NUM_OSC_PER_VOICE * displayValues[0];
 801d308:	f24f 53c3 	movw	r3, #62915	; 0xf5c3
 801d30c:	edd4 7a00 	vldr	s15, [r4]
 801d310:	f6c3 63a8 	movt	r3, #16040	; 0x3ea8
 801d314:	ee00 3a10 	vmov	s0, r3
 801d318:	ee27 0a80 	vmul.f32	s0, s15, s0
            sample = tanhf(sample);
 801d31c:	ee20 0a2a 	vmul.f32	s0, s0, s21
 801d320:	f00e f920 	bl	802b564 <tanhf>
            input[0] = sample;
 801d324:	9b01      	ldr	r3, [sp, #4]
 801d326:	ed83 0a00 	vstr	s0, [r3]
            input[1] = sample;
 801d32a:	ed83 0a01 	vstr	s0, [r3, #4]
        }
 801d32e:	b003      	add	sp, #12
 801d330:	ecbd 8b08 	vpop	{d8-d11}
 801d334:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0801d338 <SFXClassicSynthFree>:
        {
 801d338:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801d33c:	f247 28dc 	movw	r8, #29404	; 0x72dc
 801d340:	f642 0748 	movw	r7, #10312	; 0x2848
 801d344:	f243 4b18 	movw	fp, #13336	; 0x3418
 801d348:	f247 6a9c 	movw	sl, #30364	; 0x769c
 801d34c:	f641 7948 	movw	r9, #8008	; 0x1f48
 801d350:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801d354:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801d358:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801d35c:	f2c2 0a01 	movt	sl, #8193	; 0x2001
 801d360:	f2c2 0900 	movt	r9, #8192	; 0x2000
 801d364:	2500      	movs	r5, #0
 801d366:	260c      	movs	r6, #12
 801d368:	eb05 0445 	add.w	r4, r5, r5, lsl #1
                    tSawtooth_free(&osc[(i * NUM_OSC_PER_VOICE) + j]);
 801d36c:	eb08 0004 	add.w	r0, r8, r4
 801d370:	f00b fa8e 	bl	8028890 <tSawtooth_free>
                    tRosenbergGlottalPulse_free(&glottal[(i * NUM_OSC_PER_VOICE) + j]);
 801d374:	1938      	adds	r0, r7, r4
 801d376:	3404      	adds	r4, #4
 801d378:	f007 f840 	bl	80243fc <tRosenbergGlottalPulse_free>
                for (int j = 0; j < NUM_OSC_PER_VOICE; j++)
 801d37c:	42b4      	cmp	r4, r6
 801d37e:	d1f5      	bne.n	801d36c <SFXClassicSynthFree+0x34>
                tEfficientSVF_free(&synthLP[i]);
 801d380:	eb0b 0005 	add.w	r0, fp, r5
 801d384:	f104 060c 	add.w	r6, r4, #12
 801d388:	f009 f868 	bl	802645c <tEfficientSVF_free>
                tADSR4_free(&polyEnvs[i]);
 801d38c:	eb0a 0005 	add.w	r0, sl, r5
 801d390:	f008 fa66 	bl	8025860 <tADSR4_free>
                tADSR4_free(&polyFiltEnvs[i]);
 801d394:	eb09 0005 	add.w	r0, r9, r5
 801d398:	3504      	adds	r5, #4
 801d39a:	f008 fa61 	bl	8025860 <tADSR4_free>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801d39e:	2d20      	cmp	r5, #32
 801d3a0:	d1e2      	bne.n	801d368 <SFXClassicSynthFree+0x30>
            tCycle_free(&pwmLFO1);
 801d3a2:	f247 608c 	movw	r0, #30348	; 0x768c
 801d3a6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d3aa:	f00b f9d9 	bl	8028760 <tCycle_free>
            tCycle_free(&pwmLFO2);
 801d3ae:	f247 7070 	movw	r0, #30576	; 0x7770
        }
 801d3b2:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_free(&pwmLFO2);
 801d3b6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d3ba:	f00b b9d1 	b.w	8028760 <tCycle_free>
 801d3be:	bf00      	nop

0801d3c0 <SFXRhodesAlloc>:
            leaf.clearOnAllocation = 1;
 801d3c0:	f249 41a0 	movw	r1, #38048	; 0x94a0
            soundNames[0] = "DARK  ";
 801d3c4:	f64e 227c 	movw	r2, #60028	; 0xea7c
            soundNames[1] = "LIGHT ";
 801d3c8:	f64e 2384 	movw	r3, #60036	; 0xea84
            soundNames[4] = "CUSTOM";
 801d3cc:	f64e 209c 	movw	r0, #60060	; 0xea9c
            leaf.clearOnAllocation = 1;
 801d3d0:	f2c2 0101 	movt	r1, #8193	; 0x2001
            soundNames[0] = "DARK  ";
 801d3d4:	f6c0 0202 	movt	r2, #2050	; 0x802
            soundNames[1] = "LIGHT ";
 801d3d8:	f6c0 0302 	movt	r3, #2050	; 0x802
            soundNames[4] = "CUSTOM";
 801d3dc:	f6c0 0002 	movt	r0, #2050	; 0x802
        {
 801d3e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            soundNames[0] = "DARK  ";
 801d3e4:	f247 4be8 	movw	fp, #29928	; 0x74e8
            leaf.clearOnAllocation = 1;
 801d3e8:	460e      	mov	r6, r1
            soundNames[3] = "PAD   ";
 801d3ea:	f64e 2494 	movw	r4, #60052	; 0xea94
            soundNames[2] = "BASS  ";
 801d3ee:	f64e 258c 	movw	r5, #60044	; 0xea8c
            soundNames[0] = "DARK  ";
 801d3f2:	f2c2 0b01 	movt	fp, #8193	; 0x2001
 801d3f6:	f243 4a6c 	movw	sl, #13420	; 0x346c
            soundNames[3] = "PAD   ";
 801d3fa:	f6c0 0402 	movt	r4, #2050	; 0x802
 801d3fe:	f247 5928 	movw	r9, #29992	; 0x7528
            soundNames[0] = "DARK  ";
 801d402:	f8cb 2000 	str.w	r2, [fp]
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d406:	2200      	movs	r2, #0
            soundNames[1] = "LIGHT ";
 801d408:	f8cb 3004 	str.w	r3, [fp, #4]
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801d40c:	f64f 63b0 	movw	r3, #65200	; 0xfeb0
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d410:	f2c4 427a 	movt	r2, #17530	; 0x447a
            soundNames[2] = "BASS  ";
 801d414:	f6c0 0502 	movt	r5, #2050	; 0x802
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801d418:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 801d41c:	f2c2 0a00 	movt	sl, #8192	; 0x2000
 801d420:	f2c2 0901 	movt	r9, #8193	; 0x2001
            soundNames[2] = "BASS  ";
 801d424:	f8cb 5008 	str.w	r5, [fp, #8]
        {
 801d428:	ed2d 8b04 	vpush	{d8-d9}
 801d42c:	b083      	sub	sp, #12
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d42e:	ee08 2a90 	vmov	s17, r2
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801d432:	ee08 3a10 	vmov	s16, r3
            leaf.clearOnAllocation = 1;
 801d436:	9101      	str	r1, [sp, #4]
 801d438:	2101      	movs	r1, #1
 801d43a:	6171      	str	r1, [r6, #20]
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d43c:	2100      	movs	r1, #0
 801d43e:	f2c4 21c8 	movt	r1, #17096	; 0x42c8
            soundNames[4] = "CUSTOM";
 801d442:	e9cb 4003 	strd	r4, r0, [fp, #12]
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d446:	ee09 1a10 	vmov	s18, r1
            soundNames[4] = "CUSTOM";
 801d44a:	2400      	movs	r4, #0
                    tCycle_initToPool(&FM_sines[i][j], &smallPool);
 801d44c:	f248 26f8 	movw	r6, #33528	; 0x82f8
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d450:	f647 173c 	movw	r7, #31036	; 0x793c
 801d454:	f104 0818 	add.w	r8, r4, #24
                    tCycle_initToPool(&FM_sines[i][j], &smallPool);
 801d458:	f2c2 0601 	movt	r6, #8193	; 0x2001
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d45c:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801d460:	eb09 0504 	add.w	r5, r9, r4
                    tCycle_initToPool(&FM_sines[i][j], &smallPool);
 801d464:	eb0a 0004 	add.w	r0, sl, r4
 801d468:	4631      	mov	r1, r6
 801d46a:	3404      	adds	r4, #4
 801d46c:	f00b f96a 	bl	8028744 <tCycle_initToPool>
                    tADSR4_initToPool(&FM_envs[i][j], 10, 1000, 0.5f, 100.0f, decayExpBuffer, DECAY_EXP_BUFFER_SIZE, &smallPool);
 801d470:	4628      	mov	r0, r5
 801d472:	4633      	mov	r3, r6
 801d474:	f44f 7200 	mov.w	r2, #512	; 0x200
 801d478:	4639      	mov	r1, r7
 801d47a:	eef0 1a49 	vmov.f32	s3, s18
 801d47e:	eeb6 1a00 	vmov.f32	s2, #96	; 0x3f000000  0.5
 801d482:	eef0 0a68 	vmov.f32	s1, s17
 801d486:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801d48a:	f008 f98f 	bl	80257ac <tADSR4_initToPool>
                    tADSR4_setLeakFactor(&FM_envs[i][j], 0.99998f);
 801d48e:	eeb0 0a48 	vmov.f32	s0, s16
 801d492:	4628      	mov	r0, r5
 801d494:	f008 fa28 	bl	80258e8 <tADSR4_setLeakFactor>
                for (int j = 0; j < 6; j++)
 801d498:	4544      	cmp	r4, r8
 801d49a:	d1e1      	bne.n	801d460 <SFXRhodesAlloc+0xa0>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801d49c:	2cc0      	cmp	r4, #192	; 0xc0
 801d49e:	d1d5      	bne.n	801d44c <SFXRhodesAlloc+0x8c>
 801d4a0:	f642 2430 	movw	r4, #10800	; 0x2a30
                tExpSmooth_initToPool(&susSmoothers[i], 1.0f, 0.01f, &smallPool);
 801d4a4:	f24d 730a 	movw	r3, #55050	; 0xd70a
 801d4a8:	f248 25f8 	movw	r5, #33528	; 0x82f8
 801d4ac:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801d4b0:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 801d4b4:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801d4b8:	f104 0618 	add.w	r6, r4, #24
 801d4bc:	ee08 3a10 	vmov	s16, r3
 801d4c0:	4620      	mov	r0, r4
 801d4c2:	3404      	adds	r4, #4
 801d4c4:	4629      	mov	r1, r5
 801d4c6:	eef0 0a48 	vmov.f32	s1, s16
 801d4ca:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801d4ce:	f008 fd23 	bl	8025f18 <tExpSmooth_initToPool>
            for (int i = 0; i < 6; i++)
 801d4d2:	42a6      	cmp	r6, r4
 801d4d4:	d1f4      	bne.n	801d4c0 <SFXRhodesAlloc+0x100>
            tCycle_initToPool(&tremolo, &smallPool);
 801d4d6:	f248 21f8 	movw	r1, #33528	; 0x82f8
 801d4da:	f247 706c 	movw	r0, #30572	; 0x776c
 801d4de:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801d4e2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d4e6:	f00b f92d 	bl	8028744 <tCycle_initToPool>
            tCycle_setFreq(&tremolo, 3.0f);
 801d4ea:	f247 706c 	movw	r0, #30572	; 0x776c
 801d4ee:	eeb0 0a08 	vmov.f32	s0, #8	; 0x40400000  3.0
 801d4f2:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d4f6:	f00b f937 	bl	8028768 <tCycle_setFreq>
            tSimplePoly_setNumVoices(&poly, NUM_VOC_VOICES);
 801d4fa:	f247 5020 	movw	r0, #29984	; 0x7520
 801d4fe:	2108      	movs	r1, #8
 801d500:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801d504:	f00b f8de 	bl	80286c4 <tSimplePoly_setNumVoices>
            setLED_A(numVoices == 1);
 801d508:	f240 2350 	movw	r3, #592	; 0x250
 801d50c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d510:	7818      	ldrb	r0, [r3, #0]
 801d512:	f1a0 0001 	sub.w	r0, r0, #1
 801d516:	fab0 f080 	clz	r0, r0
 801d51a:	0940      	lsrs	r0, r0, #5
 801d51c:	f7f8 f9e6 	bl	80158ec <setLED_A>
            setLED_C(tremoloStereo == 1);
 801d520:	f240 630c 	movw	r3, #1548	; 0x60c
 801d524:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d528:	7818      	ldrb	r0, [r3, #0]
 801d52a:	f1a0 0001 	sub.w	r0, r0, #1
 801d52e:	fab0 f080 	clz	r0, r0
 801d532:	0940      	lsrs	r0, r0, #5
 801d534:	f7f8 f9fa 	bl	801592c <setLED_C>
            OLEDclearLine(SecondLine);
 801d538:	2001      	movs	r0, #1
 801d53a:	f7f8 fc79 	bl	8015e30 <OLEDclearLine>
            OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 801d53e:	f240 5010 	movw	r0, #1296	; 0x510
 801d542:	2301      	movs	r3, #1
 801d544:	2200      	movs	r2, #0
 801d546:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801d54a:	2106      	movs	r1, #6
 801d54c:	6800      	ldr	r0, [r0, #0]
 801d54e:	f85b 0020 	ldr.w	r0, [fp, r0, lsl #2]
 801d552:	f7f8 fc83 	bl	8015e5c <OLEDwriteString>
            leaf.clearOnAllocation = 0;
 801d556:	2300      	movs	r3, #0
 801d558:	9a01      	ldr	r2, [sp, #4]
 801d55a:	6153      	str	r3, [r2, #20]
        }
 801d55c:	b003      	add	sp, #12
 801d55e:	ecbd 8b04 	vpop	{d8-d9}
 801d562:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801d566:	bf00      	nop

0801d568 <SFXRhodesFrame>:
        {
 801d568:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801d56c:	f248 64e4 	movw	r4, #34532	; 0x86e4
 801d570:	f2c2 0401 	movt	r4, #8193	; 0x2001
        {
 801d574:	ed2d 8b04 	vpush	{d8-d9}
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801d578:	7d23      	ldrb	r3, [r4, #20]
        {
 801d57a:	b085      	sub	sp, #20
            if (buttonActionsSFX[ButtonA][ActionPress] == 1)
 801d57c:	2b01      	cmp	r3, #1
 801d57e:	f000 84bd 	beq.w	801defc <SFXRhodesFrame+0x994>
 801d582:	f240 2350 	movw	r3, #592	; 0x250
 801d586:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d58a:	9302      	str	r3, [sp, #8]
            if (buttonActionsSFX[ButtonB][ActionPress] == 1)
 801d58c:	7e23      	ldrb	r3, [r4, #24]
 801d58e:	2b01      	cmp	r3, #1
 801d590:	d114      	bne.n	801d5bc <SFXRhodesFrame+0x54>
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801d592:	f240 5110 	movw	r1, #1296	; 0x510
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801d596:	2300      	movs	r3, #0
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801d598:	f246 6267 	movw	r2, #26215	; 0x6667
 801d59c:	f2c2 0100 	movt	r1, #8192	; 0x2000
                buttonActionsSFX[ButtonB][ActionPress] = 0;
 801d5a0:	7623      	strb	r3, [r4, #24]
                Rsound = (Rsound + 1 ) % 5; // switch to another rhodes preset sound
 801d5a2:	f2c6 6266 	movt	r2, #26214	; 0x6666
 801d5a6:	680b      	ldr	r3, [r1, #0]
 801d5a8:	3301      	adds	r3, #1
 801d5aa:	fb82 2003 	smull	r2, r0, r2, r3
 801d5ae:	17da      	asrs	r2, r3, #31
 801d5b0:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 801d5b4:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 801d5b8:	1a9b      	subs	r3, r3, r2
 801d5ba:	600b      	str	r3, [r1, #0]
            if (buttonActionsSFX[ButtonC][ActionPress] == 1)
 801d5bc:	7f23      	ldrb	r3, [r4, #28]
 801d5be:	2b01      	cmp	r3, #1
 801d5c0:	f000 84b9 	beq.w	801df36 <SFXRhodesFrame+0x9ce>
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d5c4:	f240 2338 	movw	r3, #568	; 0x238
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d5c8:	f243 35b4 	movw	r5, #13236	; 0x33b4
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d5cc:	f247 0244 	movw	r2, #28740	; 0x7044
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d5d0:	f246 6466 	movw	r4, #26214	; 0x6666
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d5d4:	f2c2 0500 	movt	r5, #8192	; 0x2000
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d5d8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801d5dc:	f2c2 0201 	movt	r2, #8193	; 0x2001
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d5e0:	f6c3 74a6 	movt	r4, #16294	; 0x3fa6
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d5e4:	edd3 6a00 	vldr	s13, [r3]
 801d5e8:	f04f 438c 	mov.w	r3, #1174405120	; 0x46000000
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d5ec:	edd5 5a08 	vldr	s11, [r5, #32]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d5f0:	462f      	mov	r7, r5
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d5f2:	ed95 7a05 	vldr	s14, [r5, #20]
 801d5f6:	ee06 3a10 	vmov	s12, r3
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d5fa:	edd5 7a06 	vldr	s15, [r5, #24]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d5fe:	2300      	movs	r3, #0
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d600:	ee26 7a87 	vmul.f32	s14, s13, s14
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d604:	ecb7 3a01 	vldmia	r7!, {s6}
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d608:	ee66 7aa7 	vmul.f32	s15, s13, s15
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d60c:	f2c4 437a 	movt	r3, #17530	; 0x447a
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d610:	ee66 6aa5 	vmul.f32	s13, s13, s11
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d614:	ee05 4a90 	vmov	s11, r4
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d618:	eebd 7ac7 	vcvt.s32.f32	s14, s14
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d61c:	f248 7494 	movw	r4, #34708	; 0x8794
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d620:	eefd 7ae7 	vcvt.s32.f32	s15, s15
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d624:	ee01 3a10 	vmov	s2, r3
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d628:	eefd 6ae6 	vcvt.s32.f32	s13, s13
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d62c:	ed95 4a03 	vldr	s8, [r5, #12]
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d630:	ee17 0a10 	vmov	r0, s14
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d634:	eef1 1a00 	vmov.f32	s3, #16	; 0x40800000  4.0
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d638:	ee17 1a90 	vmov	r1, s15
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801d63c:	eeb2 2a04 	vmov.f32	s4, #36	; 0x41200000  10.0
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d640:	ee16 6a90 	vmov	r6, s13
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d644:	eb02 0080 	add.w	r0, r2, r0, lsl #2
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d648:	eb02 0181 	add.w	r1, r2, r1, lsl #2
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801d64c:	edd5 3a02 	vldr	s7, [r5, #8]
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d650:	eb02 0286 	add.w	r2, r2, r6, lsl #2
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d654:	edd0 2a00 	vldr	s5, [r0]
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d658:	edd1 4a00 	vldr	s9, [r1]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d65c:	f2c2 0401 	movt	r4, #8193	; 0x2001
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d660:	ed92 5a00 	vldr	s10, [r2]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d664:	f240 06b4 	movw	r6, #180	; 0xb4
 801d668:	edd5 6a0a 	vldr	s13, [r5, #40]	; 0x28
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d66c:	ee64 5a25 	vmul.f32	s11, s8, s11
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801d670:	ed95 7a0b 	vldr	s14, [r5, #44]	; 0x2c
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d674:	ee62 2a86 	vmul.f32	s5, s5, s12
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801d678:	edd5 7a0c 	vldr	s15, [r5, #48]	; 0x30
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d67c:	ee66 6a81 	vmul.f32	s13, s13, s2
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
 801d680:	683b      	ldr	r3, [r7, #0]
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801d682:	ee27 7a01 	vmul.f32	s14, s14, s2
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801d686:	ee67 7a81 	vmul.f32	s15, s15, s2
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d68a:	f2c2 0600 	movt	r6, #8192	; 0x2000
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d68e:	ee64 4a86 	vmul.f32	s9, s9, s12
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
 801d692:	6929      	ldr	r1, [r5, #16]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d694:	ee23 3a21 	vmul.f32	s6, s6, s3
            displayValues[7] = presetKnobValues[Rhodes][7];
 801d698:	69ea      	ldr	r2, [r5, #28]
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801d69a:	ee63 3a82 	vmul.f32	s7, s7, s4
            displayValues[1] = presetKnobValues[Rhodes][1]; // tremelo amount
 801d69e:	6063      	str	r3, [r4, #4]
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d6a0:	ee25 6a06 	vmul.f32	s12, s10, s12
            displayValues[9] = presetKnobValues[Rhodes][9];
 801d6a4:	6a6b      	ldr	r3, [r5, #36]	; 0x24
            displayValues[3] = presetKnobValues[Rhodes][3] * 1.3f; //drive
 801d6a6:	edc4 5a03 	vstr	s11, [r4, #12]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d6aa:	eefa 0a04 	vmov.f32	s1, #164	; 0xc1200000 -10.0
            displayValues[9] = presetKnobValues[Rhodes][9];
 801d6ae:	6263      	str	r3, [r4, #36]	; 0x24
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d6b0:	f247 68d4 	movw	r8, #30420	; 0x76d4
            displayValues[5] = expBuffer[(int)(presetKnobValues[Rhodes][5] * expBufferSizeMinusOne)] * 8192.0f;
 801d6b4:	edc4 2a05 	vstr	s5, [r4, #20]
            displayValues[0] = presetKnobValues[Rhodes][0] * 4.0f; // brightness
 801d6b8:	ed84 3a00 	vstr	s6, [r4]
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d6bc:	f2c2 0801 	movt	r8, #8193	; 0x2001
            displayValues[2] = presetKnobValues[Rhodes][2] * 10.0f; //tremelo rate
 801d6c0:	edc4 3a02 	vstr	s7, [r4, #8]
            displayValues[4] = presetKnobValues[Rhodes][4]; //pan spread
 801d6c4:	6121      	str	r1, [r4, #16]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d6c6:	2100      	movs	r1, #0
            displayValues[6] = expBuffer[(int)(presetKnobValues[Rhodes][6] * expBufferSizeMinusOne)] * 8192.0f;
 801d6c8:	edc4 4a06 	vstr	s9, [r4, #24]
            displayValues[8] = expBuffer[(int)(presetKnobValues[Rhodes][8] * expBufferSizeMinusOne)] * 8192.0f;
 801d6cc:	ed84 6a08 	vstr	s12, [r4, #32]
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d6d0:	ee00 1a10 	vmov	s0, r1
            displayValues[7] = presetKnobValues[Rhodes][7];
 801d6d4:	61e2      	str	r2, [r4, #28]
            FM_indices[4][0] = displayValues[10] = presetKnobValues[Rhodes][10] * 1000.0f;
 801d6d6:	edc4 6a0a 	vstr	s13, [r4, #40]	; 0x28
 801d6da:	edc6 6a18 	vstr	s13, [r6, #96]	; 0x60
            FM_indices[4][1] = displayValues[11] = presetKnobValues[Rhodes][11] * 1000.0f;
 801d6de:	ed84 7a0b 	vstr	s14, [r4, #44]	; 0x2c
 801d6e2:	ed86 7a19 	vstr	s14, [r6, #100]	; 0x64
            FM_indices[4][2] = displayValues[12] = presetKnobValues[Rhodes][12] * 1000.0f;
 801d6e6:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
 801d6ea:	edc6 7a1a 	vstr	s15, [r6, #104]	; 0x68
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801d6ee:	ed95 7a0d 	vldr	s14, [r5, #52]	; 0x34
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801d6f2:	edd5 7a0e 	vldr	s15, [r5, #56]	; 0x38
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801d6f6:	ee27 7a01 	vmul.f32	s14, s14, s2
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d6fa:	edd5 6a15 	vldr	s13, [r5, #84]	; 0x54
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801d6fe:	ee67 7a81 	vmul.f32	s15, s15, s2
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d702:	eee6 0a81 	vfma.f32	s1, s13, s2
            FM_indices[4][3] = displayValues[13] = presetKnobValues[Rhodes][13] * 1000.0f;
 801d706:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
 801d70a:	ed86 7a1b 	vstr	s14, [r6, #108]	; 0x6c
            FM_indices[4][4] = displayValues[14] = presetKnobValues[Rhodes][14] * 1000.0f;
 801d70e:	edc4 7a0e 	vstr	s15, [r4, #56]	; 0x38
 801d712:	edc6 7a1c 	vstr	s15, [r6, #112]	; 0x70
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d716:	f00a f94f 	bl	80279b8 <LEAF_clip>
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d71a:	edd8 6a0f 	vldr	s13, [r8, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d71e:	f240 2358 	movw	r3, #600	; 0x258
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d722:	ed95 4a0f 	vldr	s8, [r5, #60]	; 0x3c
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d726:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801d72a:	f2c2 0300 	movt	r3, #8192	; 0x2000
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d72e:	ed84 0a15 	vstr	s0, [r4, #84]	; 0x54
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d732:	eef4 6a44 	vcmp.f32	s13, s8
            FM_indices[4][5] = displayValues[21] = LEAF_clip(0.0f, ((presetKnobValues[Rhodes][21] * 1000.0f) - 10.0f), 1000.0f); // feedback
 801d736:	ed86 0a1d 	vstr	s0, [r6, #116]	; 0x74
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d73a:	ed93 7a00 	vldr	s14, [r3]
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d73e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d742:	ee75 7ac7 	vsub.f32	s15, s11, s14
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d746:	d01d      	beq.n	801d784 <SFXRhodesFrame+0x21c>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d748:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801d74c:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801d750:	ee74 6a66 	vsub.f32	s13, s8, s13
 801d754:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d758:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801d75c:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d760:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d764:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
 801d768:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d76c:	f100 8413 	bmi.w	801df96 <SFXRhodesFrame+0xa2e>
                    else rate += 1.0f;
 801d770:	ee36 6a25 	vadd.f32	s12, s12, s11
                    FM_freqRatios[4][k-15] = rate;
 801d774:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d778:	ed84 6a0f 	vstr	s12, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
 801d77c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d780:	ed82 6a18 	vstr	s12, [r2, #96]	; 0x60
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d784:	f243 32f4 	movw	r2, #13300	; 0x33f4
 801d788:	edd8 6a10 	vldr	s13, [r8, #64]	; 0x40
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d78c:	ed88 4a0f 	vstr	s8, [r8, #60]	; 0x3c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d790:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d794:	edd2 4a00 	vldr	s9, [r2]
 801d798:	eef4 6a64 	vcmp.f32	s13, s9
 801d79c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d7a0:	d021      	beq.n	801d7e6 <SFXRhodesFrame+0x27e>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d7a2:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801d7a6:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801d7aa:	ee74 6ae6 	vsub.f32	s13, s9, s13
 801d7ae:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d7b2:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801d7b6:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d7ba:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d7be:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d7c2:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d7c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d7ca:	f100 83ec 	bmi.w	801dfa6 <SFXRhodesFrame+0xa3e>
                    else rate += 1.0f;
 801d7ce:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801d7d2:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801d7d6:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d7da:	ed84 6a10 	vstr	s12, [r4, #64]	; 0x40
                    FM_freqRatios[4][k-15] = rate;
 801d7de:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d7e2:	ed82 6a19 	vstr	s12, [r2, #100]	; 0x64
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d7e6:	f243 32f8 	movw	r2, #13304	; 0x33f8
 801d7ea:	edd8 6a11 	vldr	s13, [r8, #68]	; 0x44
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d7ee:	edc8 4a10 	vstr	s9, [r8, #64]	; 0x40
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d7f2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d7f6:	ed92 5a00 	vldr	s10, [r2]
 801d7fa:	eef4 6a45 	vcmp.f32	s13, s10
 801d7fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d802:	d021      	beq.n	801d848 <SFXRhodesFrame+0x2e0>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d804:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801d808:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801d80c:	ee75 6a66 	vsub.f32	s13, s10, s13
 801d810:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d814:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801d818:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d81c:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d820:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d824:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d828:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d82c:	f100 83c4 	bmi.w	801dfb8 <SFXRhodesFrame+0xa50>
                    else rate += 1.0f;
 801d830:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801d834:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801d838:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d83c:	ed84 6a11 	vstr	s12, [r4, #68]	; 0x44
                    FM_freqRatios[4][k-15] = rate;
 801d840:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d844:	ed82 6a1a 	vstr	s12, [r2, #104]	; 0x68
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d848:	f243 32fc 	movw	r2, #13308	; 0x33fc
 801d84c:	edd8 6a12 	vldr	s13, [r8, #72]	; 0x48
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d850:	ed88 5a11 	vstr	s10, [r8, #68]	; 0x44
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d854:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d858:	edd2 5a00 	vldr	s11, [r2]
 801d85c:	eef4 6a65 	vcmp.f32	s13, s11
 801d860:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d864:	d021      	beq.n	801d8aa <SFXRhodesFrame+0x342>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d866:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801d86a:	eeb2 6a0c 	vmov.f32	s12, #44	; 0x41600000  14.0
 801d86e:	ee75 6ae6 	vsub.f32	s13, s11, s13
 801d872:	ee66 6a86 	vmul.f32	s13, s13, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d876:	ee27 6aa6 	vmul.f32	s12, s15, s13
                    float snapRate = roundf(rawRate);
 801d87a:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d87e:	eea7 6a26 	vfma.f32	s12, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d882:	eeb5 6ac0 	vcmpe.f32	s12, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d886:	eef0 6a46 	vmov.f32	s13, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d88a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d88e:	f100 8362 	bmi.w	801df56 <SFXRhodesFrame+0x9ee>
                    else rate += 1.0f;
 801d892:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 801d896:	ee36 6a86 	vadd.f32	s12, s13, s12
                    FM_freqRatios[4][k-15] = rate;
 801d89a:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d89e:	ed84 6a12 	vstr	s12, [r4, #72]	; 0x48
                    FM_freqRatios[4][k-15] = rate;
 801d8a2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d8a6:	ed82 6a1b 	vstr	s12, [r2, #108]	; 0x6c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d8aa:	f243 4200 	movw	r2, #13312	; 0x3400
 801d8ae:	edd8 6a13 	vldr	s13, [r8, #76]	; 0x4c
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d8b2:	edc8 5a12 	vstr	s11, [r8, #72]	; 0x48
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d8b6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d8ba:	ed92 6a00 	vldr	s12, [r2]
 801d8be:	eef4 6a46 	vcmp.f32	s13, s12
 801d8c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d8c6:	d021      	beq.n	801d90c <SFXRhodesFrame+0x3a4>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d8c8:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 801d8cc:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
 801d8d0:	ee76 6a66 	vsub.f32	s13, s12, s13
 801d8d4:	ee66 6aa3 	vmul.f32	s13, s13, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d8d8:	ee67 3aa6 	vmul.f32	s7, s15, s13
                    float snapRate = roundf(rawRate);
 801d8dc:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d8e0:	eee7 3a26 	vfma.f32	s7, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d8e4:	eef5 3ac0 	vcmpe.f32	s7, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d8e8:	eef0 6a63 	vmov.f32	s13, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d8ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d8f0:	f100 833a 	bmi.w	801df68 <SFXRhodesFrame+0xa00>
                    else rate += 1.0f;
 801d8f4:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
 801d8f8:	ee76 3aa3 	vadd.f32	s7, s13, s7
                    FM_freqRatios[4][k-15] = rate;
 801d8fc:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d900:	edc4 3a13 	vstr	s7, [r4, #76]	; 0x4c
                    FM_freqRatios[4][k-15] = rate;
 801d904:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d908:	edc2 3a1c 	vstr	s7, [r2, #112]	; 0x70
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d90c:	f243 4204 	movw	r2, #13316	; 0x3404
 801d910:	edd8 3a14 	vldr	s7, [r8, #80]	; 0x50
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d914:	ed88 6a13 	vstr	s12, [r8, #76]	; 0x4c
                if (presetKnobValues[Rhodes][k] != prevKnobValues[k])
 801d918:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d91c:	edd2 6a00 	vldr	s13, [r2]
 801d920:	eef4 6a63 	vcmp.f32	s13, s7
 801d924:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d928:	d01f      	beq.n	801d96a <SFXRhodesFrame+0x402>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d92a:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
 801d92e:	eeb2 3a0c 	vmov.f32	s6, #44	; 0x41600000  14.0
 801d932:	ee76 3ae3 	vsub.f32	s7, s13, s7
 801d936:	ee63 3a83 	vmul.f32	s7, s7, s6
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d93a:	ee67 7aa3 	vmul.f32	s15, s15, s7
                    float snapRate = roundf(rawRate);
 801d93e:	fef8 3a63 	vrinta.f32	s7, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d942:	eee7 7a23 	vfma.f32	s15, s14, s7
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d946:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 801d94a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801d94e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d952:	f100 8312 	bmi.w	801df7a <SFXRhodesFrame+0xa12>
                    else rate += 1.0f;
 801d956:	ee77 7a87 	vadd.f32	s15, s15, s14
                    FM_freqRatios[4][k-15] = rate;
 801d95a:	f240 023c 	movw	r2, #60	; 0x3c
                    displayValues[k] = rate;
 801d95e:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
 801d962:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d966:	edc2 7a1d 	vstr	s15, [r2, #116]	; 0x74
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
 801d96a:	f243 420c 	movw	r2, #13324	; 0x340c
 801d96e:	edd8 7a16 	vldr	s15, [r8, #88]	; 0x58
                prevKnobValues[k] = presetKnobValues[Rhodes][k];
 801d972:	edc8 6a14 	vstr	s13, [r8, #80]	; 0x50
            if (presetKnobValues[Rhodes][22] != prevKnobValues[22])
 801d976:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801d97a:	ed92 7a00 	vldr	s14, [r2]
 801d97e:	eeb4 7a67 	vcmp.f32	s14, s15
 801d982:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d986:	f000 80ba 	beq.w	801dafe <SFXRhodesFrame+0x596>
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d98a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
 801d98e:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d992:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                overtoneSnap = displayValues[22] = presetKnobValues[Rhodes][22];
 801d996:	ed83 7a00 	vstr	s14, [r3]
 801d99a:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d99e:	ee34 4a67 	vsub.f32	s8, s8, s15
 801d9a2:	ee73 7a47 	vsub.f32	s15, s6, s14
 801d9a6:	ee24 4a23 	vmul.f32	s8, s8, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d9aa:	ee64 3a27 	vmul.f32	s7, s8, s15
                    float snapRate = roundf(rawRate);
 801d9ae:	feb8 4a44 	vrinta.f32	s8, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d9b2:	eee7 3a04 	vfma.f32	s7, s14, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d9b6:	eef5 3ac0 	vcmpe.f32	s7, #0.0
 801d9ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801d9be:	f100 82e3 	bmi.w	801df88 <SFXRhodesFrame+0xa20>
                    else rate += 1.0f;
 801d9c2:	ee33 4a83 	vadd.f32	s8, s7, s6
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d9c6:	eeb6 3a00 	vmov.f32	s6, #96	; 0x3f000000  0.5
                    FM_freqRatios[4][k-15] = rate;
 801d9ca:	f240 033c 	movw	r3, #60	; 0x3c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d9ce:	eef2 3a0c 	vmov.f32	s7, #44	; 0x41600000  14.0
                    displayValues[k] = rate;
 801d9d2:	ed84 4a0f 	vstr	s8, [r4, #60]	; 0x3c
                    FM_freqRatios[4][k-15] = rate;
 801d9d6:	f2c2 0300 	movt	r3, #8192	; 0x2000
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d9da:	ee74 4ac3 	vsub.f32	s9, s9, s6
                    FM_freqRatios[4][k-15] = rate;
 801d9de:	ed83 4a18 	vstr	s8, [r3, #96]	; 0x60
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801d9e2:	ee64 4aa3 	vmul.f32	s9, s9, s7
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d9e6:	ee24 4aa7 	vmul.f32	s8, s9, s15
                    float snapRate = roundf(rawRate);
 801d9ea:	fef8 4a64 	vrinta.f32	s9, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d9ee:	eea7 4a24 	vfma.f32	s8, s14, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d9f2:	eeb5 4ac0 	vcmpe.f32	s8, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801d9f6:	eef0 4a44 	vmov.f32	s9, s8
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801d9fa:	eeb7 4a00 	vmov.f32	s8, #112	; 0x3f800000  1.0
 801d9fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da02:	f100 82fe 	bmi.w	801e002 <SFXRhodesFrame+0xa9a>
                    else rate += 1.0f;
 801da06:	ee74 4a84 	vadd.f32	s9, s9, s8
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da0a:	eef6 3a00 	vmov.f32	s7, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801da0e:	edc4 4a10 	vstr	s9, [r4, #64]	; 0x40
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da12:	eeb2 4a0c 	vmov.f32	s8, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801da16:	edc3 4a19 	vstr	s9, [r3, #100]	; 0x64
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da1a:	ee35 5a63 	vsub.f32	s10, s10, s7
 801da1e:	ee25 5a04 	vmul.f32	s10, s10, s8
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da22:	ee65 4a27 	vmul.f32	s9, s10, s15
                    float snapRate = roundf(rawRate);
 801da26:	feb8 5a45 	vrinta.f32	s10, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da2a:	eee7 4a05 	vfma.f32	s9, s14, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801da2e:	eef5 4ac0 	vcmpe.f32	s9, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da32:	eeb0 5a64 	vmov.f32	s10, s9
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801da36:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
 801da3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da3e:	f100 82d9 	bmi.w	801dff4 <SFXRhodesFrame+0xa8c>
                    else rate += 1.0f;
 801da42:	ee35 5a24 	vadd.f32	s10, s10, s9
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da46:	eeb6 4a00 	vmov.f32	s8, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801da4a:	ed84 5a11 	vstr	s10, [r4, #68]	; 0x44
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da4e:	eef2 4a0c 	vmov.f32	s9, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801da52:	ed83 5a1a 	vstr	s10, [r3, #104]	; 0x68
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da56:	ee75 5ac4 	vsub.f32	s11, s11, s8
 801da5a:	ee65 5aa4 	vmul.f32	s11, s11, s9
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da5e:	ee25 5aa7 	vmul.f32	s10, s11, s15
                    float snapRate = roundf(rawRate);
 801da62:	fef8 5a65 	vrinta.f32	s11, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da66:	eea7 5a25 	vfma.f32	s10, s14, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801da6a:	eeb5 5ac0 	vcmpe.f32	s10, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da6e:	eef0 5a45 	vmov.f32	s11, s10
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801da72:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 801da76:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801da7a:	f100 82b4 	bmi.w	801dfe6 <SFXRhodesFrame+0xa7e>
                    else rate += 1.0f;
 801da7e:	ee75 5a85 	vadd.f32	s11, s11, s10
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da82:	eef6 4a00 	vmov.f32	s9, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801da86:	edc4 5a12 	vstr	s11, [r4, #72]	; 0x48
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da8a:	eeb2 5a0c 	vmov.f32	s10, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801da8e:	edc3 5a1b 	vstr	s11, [r3, #108]	; 0x6c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801da92:	ee36 6a64 	vsub.f32	s12, s12, s9
 801da96:	ee26 6a05 	vmul.f32	s12, s12, s10
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801da9a:	ee66 5a27 	vmul.f32	s11, s12, s15
                    float snapRate = roundf(rawRate);
 801da9e:	feb8 6a46 	vrinta.f32	s12, s12
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801daa2:	eee7 5a06 	vfma.f32	s11, s14, s12
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801daa6:	eef5 5ac0 	vcmpe.f32	s11, #0.0
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801daaa:	eeb0 6a65 	vmov.f32	s12, s11
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801daae:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801dab2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dab6:	f100 828f 	bmi.w	801dfd8 <SFXRhodesFrame+0xa70>
                    else rate += 1.0f;
 801daba:	ee36 6a25 	vadd.f32	s12, s12, s11
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801dabe:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
                    displayValues[k] = rate;
 801dac2:	ed84 6a13 	vstr	s12, [r4, #76]	; 0x4c
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801dac6:	eef2 5a0c 	vmov.f32	s11, #44	; 0x41600000  14.0
                    FM_freqRatios[4][k-15] = rate;
 801daca:	ed83 6a1c 	vstr	s12, [r3, #112]	; 0x70
                    float rawRate = (presetKnobValues[Rhodes][k] - 0.5f) * 14.0f;
 801dace:	ee76 6ac5 	vsub.f32	s13, s13, s10
 801dad2:	ee66 6aa5 	vmul.f32	s13, s13, s11
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801dad6:	ee66 7aa7 	vmul.f32	s15, s13, s15
                    float snapRate = roundf(rawRate);
 801dada:	fef8 6a66 	vrinta.f32	s13, s13
                    float rate = (snapRate * overtoneSnap) + (rawRate * (1.0f - overtoneSnap));
 801dade:	eee7 7a26 	vfma.f32	s15, s14, s13
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801dae2:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 801dae6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 801daea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801daee:	f100 826c 	bmi.w	801dfca <SFXRhodesFrame+0xa62>
                    else rate += 1.0f;
 801daf2:	ee77 7aa6 	vadd.f32	s15, s15, s13
                    displayValues[k] = rate;
 801daf6:	edc4 7a14 	vstr	s15, [r4, #80]	; 0x50
                    FM_freqRatios[4][k-15] = rate;
 801dafa:	edc3 7a1d 	vstr	s15, [r3, #116]	; 0x74
            if (prevDisplayValues[23] != displayValues[23])
 801dafe:	f243 53f4 	movw	r3, #13812	; 0x35f4
            displayValues[23] = presetKnobValues[Rhodes][23];
 801db02:	f243 4210 	movw	r2, #13328	; 0x3410
            prevKnobValues[22] = presetKnobValues[Rhodes][22];
 801db06:	ed88 7a16 	vstr	s14, [r8, #88]	; 0x58
            if (prevDisplayValues[23] != displayValues[23])
 801db0a:	f2c2 0300 	movt	r3, #8192	; 0x2000
            displayValues[23] = presetKnobValues[Rhodes][23];
 801db0e:	f2c2 0200 	movt	r2, #8192	; 0x2000
            if (prevDisplayValues[23] != displayValues[23])
 801db12:	ed93 7a17 	vldr	s14, [r3, #92]	; 0x5c
            displayValues[23] = presetKnobValues[Rhodes][23];
 801db16:	edd2 7a00 	vldr	s15, [r2]
            if (prevDisplayValues[23] != displayValues[23])
 801db1a:	9301      	str	r3, [sp, #4]
 801db1c:	eef4 7a47 	vcmp.f32	s15, s14
            displayValues[23] = presetKnobValues[Rhodes][23];
 801db20:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
            if (prevDisplayValues[23] != displayValues[23])
 801db24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801db28:	d04e      	beq.n	801dbc8 <SFXRhodesFrame+0x660>
 801db2a:	f240 2974 	movw	r9, #628	; 0x274
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801db2e:	f248 531f 	movw	r3, #34079	; 0x851f
 801db32:	f249 47a0 	movw	r7, #38048	; 0x94a0
 801db36:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
 801db3a:	f2c2 0900 	movt	r9, #8192	; 0x2000
 801db3e:	f6cb 736b 	movt	r3, #49003	; 0xbf6b
 801db42:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 801db46:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801db4a:	f109 0518 	add.w	r5, r9, #24
            if (prevDisplayValues[23] != displayValues[23])
 801db4e:	464e      	mov	r6, r9
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801db50:	ee08 3a10 	vmov	s16, r3
                    float randomNumberDraw = (leaf.random() * 2.0f) + 0.08f;
 801db54:	693b      	ldr	r3, [r7, #16]
 801db56:	4798      	blx	r3
                    randomDecays[i] = (1.0f - displayValues[23]) + (randomNumberDraw * displayValues[23]);
 801db58:	eeb0 7a48 	vmov.f32	s14, s16
 801db5c:	eef0 6a68 	vmov.f32	s13, s17
 801db60:	edd4 7a17 	vldr	s15, [r4, #92]	; 0x5c
 801db64:	eea0 7a09 	vfma.f32	s14, s0, s18
 801db68:	eee7 6a27 	vfma.f32	s13, s14, s15
 801db6c:	ece6 6a01 	vstmia	r6!, {s13}
                for (int i = 0; i < 6; i++)
 801db70:	42ae      	cmp	r6, r5
 801db72:	d1ef      	bne.n	801db54 <SFXRhodesFrame+0x5ec>
 801db74:	f247 5728 	movw	r7, #29992	; 0x7528
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
 801db78:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801db7c:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801db80:	f2c4 639c 	movt	r3, #18076	; 0x469c
 801db84:	f107 0ac0 	add.w	sl, r7, #192	; 0xc0
 801db88:	ee08 3a10 	vmov	s16, r3
            if (prevDisplayValues[23] != displayValues[23])
 801db8c:	46bb      	mov	fp, r7
 801db8e:	464d      	mov	r5, r9
                        tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(10.0f, displayValues[6] * randomDecays[j], 20000.0f))); //FM_decays[Rsound][j] * displayValues[6]);
 801db90:	ecf5 0a01 	vldmia	r5!, {s1}
 801db94:	eeb0 1a48 	vmov.f32	s2, s16
 801db98:	edd4 7a06 	vldr	s15, [r4, #24]
 801db9c:	eeb2 0a04 	vmov.f32	s0, #36	; 0x41200000  10.0
 801dba0:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801dba4:	f009 ff08 	bl	80279b8 <LEAF_clip>
 801dba8:	4658      	mov	r0, fp
 801dbaa:	f007 fe6b 	bl	8025884 <tADSR4_setDecay>
                    for (int j = 0; j < 6; j++)
 801dbae:	42b5      	cmp	r5, r6
 801dbb0:	f10b 0b04 	add.w	fp, fp, #4
 801dbb4:	d1ec      	bne.n	801db90 <SFXRhodesFrame+0x628>
 801dbb6:	3718      	adds	r7, #24
                for (int i = 0; i < NUM_VOC_VOICES; i++)
 801dbb8:	4557      	cmp	r7, sl
 801dbba:	d1e7      	bne.n	801db8c <SFXRhodesFrame+0x624>
 801dbbc:	f243 4310 	movw	r3, #13328	; 0x3410
 801dbc0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801dbc4:	ed93 7a00 	vldr	s14, [r3]
            displayValues[24] = presetKnobValues[Rhodes][24];
 801dbc8:	f243 4314 	movw	r3, #13332	; 0x3414
            if (prevDisplayValues[24] != displayValues[24])
 801dbcc:	9a01      	ldr	r2, [sp, #4]
            prevKnobValues[23] = presetKnobValues[Rhodes][23];
 801dbce:	ed88 7a17 	vstr	s14, [r8, #92]	; 0x5c
            displayValues[24] = presetKnobValues[Rhodes][24];
 801dbd2:	f2c2 0300 	movt	r3, #8192	; 0x2000
            if (prevDisplayValues[24] != displayValues[24])
 801dbd6:	edd2 7a18 	vldr	s15, [r2, #96]	; 0x60
            displayValues[24] = presetKnobValues[Rhodes][24];
 801dbda:	edd3 6a00 	vldr	s13, [r3]
            if (prevDisplayValues[24] != displayValues[24])
 801dbde:	eef4 6a67 	vcmp.f32	s13, s15
            displayValues[24] = presetKnobValues[Rhodes][24];
 801dbe2:	edc4 6a18 	vstr	s13, [r4, #96]	; 0x60
            if (prevDisplayValues[24] != displayValues[24])
 801dbe6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dbea:	d02e      	beq.n	801dc4a <SFXRhodesFrame+0x6e2>
 801dbec:	f240 258c 	movw	r5, #652	; 0x28c
 801dbf0:	f642 2630 	movw	r6, #10800	; 0x2a30
 801dbf4:	f249 47a0 	movw	r7, #38048	; 0x94a0
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801dbf8:	eeb0 9a00 	vmov.f32	s18, #0	; 0x40000000  2.0
 801dbfc:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801dc00:	eeff 8a00 	vmov.f32	s17, #240	; 0xbf800000 -1.0
 801dc04:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801dc08:	f2c2 0600 	movt	r6, #8192	; 0x2000
 801dc0c:	f105 0818 	add.w	r8, r5, #24
 801dc10:	f2c2 0701 	movt	r7, #8193	; 0x2001
                    float randomNumberDraw = leaf.random() * 2.0f;
 801dc14:	693b      	ldr	r3, [r7, #16]
 801dc16:	4798      	blx	r3
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801dc18:	eeb0 7a68 	vmov.f32	s14, s17
 801dc1c:	eef0 6a48 	vmov.f32	s13, s16
 801dc20:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801dc24:	4630      	mov	r0, r6
 801dc26:	3604      	adds	r6, #4
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801dc28:	eea0 7a09 	vfma.f32	s14, s0, s18
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801dc2c:	ed94 0a07 	vldr	s0, [r4, #28]
                    randomSustains[i] = (1.0f - displayValues[24]) + (randomNumberDraw * displayValues[24]);
 801dc30:	eee7 6a27 	vfma.f32	s13, s14, s15
 801dc34:	ece5 6a01 	vstmia	r5!, {s13}
                    tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801dc38:	ee26 0a80 	vmul.f32	s0, s13, s0
 801dc3c:	f008 f9a8 	bl	8025f90 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
 801dc40:	4545      	cmp	r5, r8
 801dc42:	d1e7      	bne.n	801dc14 <SFXRhodesFrame+0x6ac>
 801dc44:	edd4 7a18 	vldr	s15, [r4, #96]	; 0x60
 801dc48:	9a01      	ldr	r2, [sp, #4]
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
 801dc4a:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801dc4e:	f243 6708 	movw	r7, #13832	; 0x3608
 801dc52:	f248 7aa8 	movw	sl, #34728	; 0x87a8
 801dc56:	f240 268c 	movw	r6, #652	; 0x28c
 801dc5a:	f2c4 639c 	movt	r3, #18076	; 0x469c
 801dc5e:	f2c2 0700 	movt	r7, #8192	; 0x2000
            prevDisplayValues[24] = displayValues[24];
 801dc62:	f04f 0906 	mov.w	r9, #6
 801dc66:	f2c2 0a01 	movt	sl, #8193	; 0x2001
 801dc6a:	f2c2 0600 	movt	r6, #8192	; 0x2000
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
 801dc6e:	ee08 3a10 	vmov	s16, r3
            prevDisplayValues[24] = displayValues[24];
 801dc72:	edc2 7a18 	vstr	s15, [r2, #96]	; 0x60
                if (prevDisplayValues[k] != displayValues[k])
 801dc76:	ecb7 7a01 	vldmia	r7!, {s14}
 801dc7a:	ecfa 7a01 	vldmia	sl!, {s15}
 801dc7e:	eeb4 7a67 	vcmp.f32	s14, s15
 801dc82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801dc86:	d01d      	beq.n	801dcc4 <SFXRhodesFrame+0x75c>
                    switch(k)
 801dc88:	f1a9 0307 	sub.w	r3, r9, #7
 801dc8c:	2b03      	cmp	r3, #3
 801dc8e:	d805      	bhi.n	801dc9c <SFXRhodesFrame+0x734>
 801dc90:	e8df f013 	tbh	[pc, r3, lsl #1]
 801dc94:	00ef010b 	.word	0x00ef010b
 801dc98:	002000d8 	.word	0x002000d8
 801dc9c:	f247 5528 	movw	r5, #29992	; 0x7528
 801dca0:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801dca4:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
 801dca8:	f105 0818 	add.w	r8, r5, #24
                                    tADSR4_setAttack(&FM_envs[i][j], displayValues[5] );
 801dcac:	4628      	mov	r0, r5
 801dcae:	3504      	adds	r5, #4
 801dcb0:	ed94 0a05 	vldr	s0, [r4, #20]
 801dcb4:	f007 fdd8 	bl	8025868 <tADSR4_setAttack>
                                for (int j = 0; j < 6; j++)
 801dcb8:	45a8      	cmp	r8, r5
 801dcba:	d1f7      	bne.n	801dcac <SFXRhodesFrame+0x744>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801dcbc:	45d8      	cmp	r8, fp
 801dcbe:	d1f3      	bne.n	801dca8 <SFXRhodesFrame+0x740>
 801dcc0:	ed5a 7a01 	vldr	s15, [sl, #-4]
            for (int k = 5; k < 10; k++)
 801dcc4:	f1b9 0f0a 	cmp.w	r9, #10
                prevDisplayValues[k] = displayValues[k];
 801dcc8:	ed47 7a01 	vstr	s15, [r7, #-4]
            for (int k = 5; k < 10; k++)
 801dccc:	d02b      	beq.n	801dd26 <SFXRhodesFrame+0x7be>
 801dcce:	f109 0901 	add.w	r9, r9, #1
 801dcd2:	e7d0      	b.n	801dc76 <SFXRhodesFrame+0x70e>
 801dcd4:	f247 5528 	movw	r5, #29992	; 0x7528
                                    tADSR4_setLeakFactor(&FM_envs[i][j], ((1.0f - displayValues[9])  * 0.00004f) + 0.99996f);
 801dcd8:	f24c 52ac 	movw	r2, #50604	; 0xc5ac
 801dcdc:	f64f 5361 	movw	r3, #64865	; 0xfd61
 801dce0:	eeb7 9a00 	vmov.f32	s18, #112	; 0x3f800000  1.0
 801dce4:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801dce8:	f6c3 0227 	movt	r2, #14375	; 0x3827
 801dcec:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 801dcf0:	f105 07c0 	add.w	r7, r5, #192	; 0xc0
 801dcf4:	ee08 2a90 	vmov	s17, r2
 801dcf8:	ee08 3a10 	vmov	s16, r3
 801dcfc:	f105 0618 	add.w	r6, r5, #24
 801dd00:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 801dd04:	eeb0 0a48 	vmov.f32	s0, s16
 801dd08:	4628      	mov	r0, r5
 801dd0a:	3504      	adds	r5, #4
 801dd0c:	ee79 7a67 	vsub.f32	s15, s18, s15
 801dd10:	eea7 0aa8 	vfma.f32	s0, s15, s17
 801dd14:	f007 fde8 	bl	80258e8 <tADSR4_setLeakFactor>
                                for (int j = 0; j < 6; j++)
 801dd18:	42b5      	cmp	r5, r6
 801dd1a:	d1f1      	bne.n	801dd00 <SFXRhodesFrame+0x798>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801dd1c:	42bd      	cmp	r5, r7
 801dd1e:	d1ed      	bne.n	801dcfc <SFXRhodesFrame+0x794>
                prevDisplayValues[k] = displayValues[k];
 801dd20:	6a63      	ldr	r3, [r4, #36]	; 0x24
 801dd22:	9a01      	ldr	r2, [sp, #4]
 801dd24:	6253      	str	r3, [r2, #36]	; 0x24
            for (int i = 0; i < numVoices; i++)
 801dd26:	9e02      	ldr	r6, [sp, #8]
 801dd28:	7833      	ldrb	r3, [r6, #0]
 801dd2a:	2b00      	cmp	r3, #0
 801dd2c:	d07d      	beq.n	801de2a <SFXRhodesFrame+0x8c2>
 801dd2e:	f247 5a20 	movw	sl, #29984	; 0x7520
 801dd32:	f243 4b3c 	movw	fp, #13372	; 0x343c
 801dd36:	f240 6354 	movw	r3, #1620	; 0x654
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801dd3a:	f247 5228 	movw	r2, #29992	; 0x7528
 801dd3e:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801dd42:	f240 58d8 	movw	r8, #1496	; 0x5d8
 801dd46:	f240 6720 	movw	r7, #1568	; 0x620
 801dd4a:	f2c2 0a01 	movt	sl, #8193	; 0x2001
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801dd4e:	f64a 29ab 	movw	r9, #43691	; 0xaaab
 801dd52:	f2c2 0300 	movt	r3, #8192	; 0x2000
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801dd56:	f2c2 0201 	movt	r2, #8193	; 0x2001
            for (int i = 0; i < numVoices; i++)
 801dd5a:	9403      	str	r4, [sp, #12]
 801dd5c:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801dd60:	465c      	mov	r4, fp
 801dd62:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801dd66:	9301      	str	r3, [sp, #4]
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801dd68:	f6c2 29aa 	movt	r9, #10922	; 0x2aaa
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801dd6c:	9202      	str	r2, [sp, #8]
            for (int i = 0; i < numVoices; i++)
 801dd6e:	2500      	movs	r5, #0
 801dd70:	46d3      	mov	fp, sl
 801dd72:	e002      	b.n	801dd7a <SFXRhodesFrame+0x812>
 801dd74:	3501      	adds	r5, #1
 801dd76:	42a9      	cmp	r1, r5
 801dd78:	dd56      	ble.n	801de28 <SFXRhodesFrame+0x8c0>
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801dd7a:	fa5f fa85 	uxtb.w	sl, r5
 801dd7e:	f247 5020 	movw	r0, #29984	; 0x7520
 801dd82:	4651      	mov	r1, sl
 801dd84:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801dd88:	f00a fcc0 	bl	802870c <tSimplePoly_getPitch>
 801dd8c:	ee07 0a90 	vmov	s15, r0
 801dd90:	ed98 0a00 	vldr	s0, [r8]
 801dd94:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801dd98:	9b01      	ldr	r3, [sp, #4]
 801dd9a:	7818      	ldrb	r0, [r3, #0]
            float tempNote = (float)tSimplePoly_getPitch(&poly, voice) + pitchBendValue;
 801dd9c:	ee37 7a00 	vadd.f32	s14, s14, s0
            float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801dda0:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801dda4:	ee17 1a90 	vmov	r1, s15
 801dda8:	1a09      	subs	r1, r1, r0
 801ddaa:	fb89 3c01 	smull	r3, ip, r9, r1
 801ddae:	17c8      	asrs	r0, r1, #31
 801ddb0:	ebc0 006c 	rsb	r0, r0, ip, asr #1
 801ddb4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801ddb8:	eba1 0080 	sub.w	r0, r1, r0, lsl #2
 801ddbc:	ee07 0a90 	vmov	s15, r0
 801ddc0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801ddc4:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801ddc8:	ee17 1a90 	vmov	r1, s15
 801ddcc:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 801ddd0:	ed91 0a00 	vldr	s0, [r1]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801ddd4:	ee37 0a00 	vadd.f32	s0, s14, s0
 801ddd8:	f009 fed8 	bl	8027b8c <LEAF_midiToFrequency>
                if (numVoices > 1)
 801dddc:	7831      	ldrb	r1, [r6, #0]
            freq[voice] = LEAF_midiToFrequency(tunedNote);
 801ddde:	eca4 0a01 	vstmia	r4!, {s0}
                if (numVoices > 1)
 801dde2:	2901      	cmp	r1, #1
 801dde4:	d9c6      	bls.n	801dd74 <SFXRhodesFrame+0x80c>
                    if (poly->voices[i][0] == -2)
 801dde6:	f8db 0000 	ldr.w	r0, [fp]
 801ddea:	6900      	ldr	r0, [r0, #16]
 801ddec:	f850 0025 	ldr.w	r0, [r0, r5, lsl #2]
 801ddf0:	6800      	ldr	r0, [r0, #0]
 801ddf2:	3002      	adds	r0, #2
 801ddf4:	d1be      	bne.n	801dd74 <SFXRhodesFrame+0x80c>
 801ddf6:	eb05 0045 	add.w	r0, r5, r5, lsl #1
                        if ((FM_envs[i][0]->whichStage == env_idle) && (FM_envs[i][2]->whichStage == env_idle))
 801ddfa:	9a02      	ldr	r2, [sp, #8]
 801ddfc:	f852 3030 	ldr.w	r3, [r2, r0, lsl #3]
 801de00:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 801de04:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 801de06:	2b00      	cmp	r3, #0
 801de08:	d1b4      	bne.n	801dd74 <SFXRhodesFrame+0x80c>
 801de0a:	6880      	ldr	r0, [r0, #8]
 801de0c:	6a80      	ldr	r0, [r0, #40]	; 0x28
 801de0e:	2800      	cmp	r0, #0
 801de10:	d1b0      	bne.n	801dd74 <SFXRhodesFrame+0x80c>
                            tSimplePoly_deactivateVoice(&poly, i);
 801de12:	f247 5020 	movw	r0, #29984	; 0x7520
 801de16:	4651      	mov	r1, sl
            for (int i = 0; i < numVoices; i++)
 801de18:	3501      	adds	r5, #1
                            tSimplePoly_deactivateVoice(&poly, i);
 801de1a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801de1e:	f00a fb9b 	bl	8028558 <tSimplePoly_deactivateVoice>
 801de22:	7831      	ldrb	r1, [r6, #0]
            for (int i = 0; i < numVoices; i++)
 801de24:	42a9      	cmp	r1, r5
 801de26:	dca8      	bgt.n	801dd7a <SFXRhodesFrame+0x812>
 801de28:	9c03      	ldr	r4, [sp, #12]
            tCycle_setFreq(&tremolo, displayValues[2]);
 801de2a:	f247 706c 	movw	r0, #30572	; 0x776c
 801de2e:	ed94 0a02 	vldr	s0, [r4, #8]
 801de32:	f2c2 0001 	movt	r0, #8193	; 0x2001
        }
 801de36:	b005      	add	sp, #20
 801de38:	ecbd 8b04 	vpop	{d8-d9}
 801de3c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            tCycle_setFreq(&tremolo, displayValues[2]);
 801de40:	f00a bc92 	b.w	8028768 <tCycle_setFreq>
 801de44:	f247 5528 	movw	r5, #29992	; 0x7528
 801de48:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801de4c:	f105 0bc0 	add.w	fp, r5, #192	; 0xc0
 801de50:	f105 0818 	add.w	r8, r5, #24
                                    tADSR4_setRelease(&FM_envs[i][j], displayValues[8]);
 801de54:	4628      	mov	r0, r5
 801de56:	3504      	adds	r5, #4
 801de58:	ed94 0a08 	vldr	s0, [r4, #32]
 801de5c:	f007 fd36 	bl	80258cc <tADSR4_setRelease>
                                for (int j = 0; j < 6; j++)
 801de60:	45a8      	cmp	r8, r5
 801de62:	d1f7      	bne.n	801de54 <SFXRhodesFrame+0x8ec>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801de64:	45ab      	cmp	fp, r5
 801de66:	d1f3      	bne.n	801de50 <SFXRhodesFrame+0x8e8>
                prevDisplayValues[k] = displayValues[k];
 801de68:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801de6c:	f847 3c04 	str.w	r3, [r7, #-4]
 801de70:	e72d      	b.n	801dcce <SFXRhodesFrame+0x766>
 801de72:	f240 258c 	movw	r5, #652	; 0x28c
 801de76:	f642 2830 	movw	r8, #10800	; 0x2a30
 801de7a:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801de7e:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801de82:	f105 0b18 	add.w	fp, r5, #24
                                tExpSmooth_setDest(&susSmoothers[i], displayValues[7] * randomSustains[i]);
 801de86:	ecb5 0a01 	vldmia	r5!, {s0}
 801de8a:	4640      	mov	r0, r8
 801de8c:	edd4 7a07 	vldr	s15, [r4, #28]
 801de90:	f108 0804 	add.w	r8, r8, #4
 801de94:	ee20 0a27 	vmul.f32	s0, s0, s15
 801de98:	f008 f87a 	bl	8025f90 <tExpSmooth_setDest>
                            for (int i = 0; i < 6; i++)
 801de9c:	45ab      	cmp	fp, r5
 801de9e:	d1f2      	bne.n	801de86 <SFXRhodesFrame+0x91e>
                prevDisplayValues[k] = displayValues[k];
 801dea0:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801dea4:	f847 3c04 	str.w	r3, [r7, #-4]
 801dea8:	e711      	b.n	801dcce <SFXRhodesFrame+0x766>
 801deaa:	f247 5828 	movw	r8, #29992	; 0x7528
 801deae:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801deb2:	f240 2b74 	movw	fp, #628	; 0x274
            prevDisplayValues[24] = displayValues[24];
 801deb6:	4645      	mov	r5, r8
 801deb8:	f2c2 0b00 	movt	fp, #8192	; 0x2000
                                    tADSR4_setDecay(&FM_envs[i][j],(LEAF_clip(7.0f, displayValues[6] * randomDecays[j], 20000.0f)));
 801debc:	ecfb 0a01 	vldmia	fp!, {s1}
 801dec0:	eeb0 1a48 	vmov.f32	s2, s16
 801dec4:	edd4 7a06 	vldr	s15, [r4, #24]
 801dec8:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
 801decc:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801ded0:	f009 fd72 	bl	80279b8 <LEAF_clip>
 801ded4:	4628      	mov	r0, r5
 801ded6:	f007 fcd5 	bl	8025884 <tADSR4_setDecay>
                                for (int j = 0; j < 6; j++)
 801deda:	455e      	cmp	r6, fp
 801dedc:	f105 0504 	add.w	r5, r5, #4
 801dee0:	d1ec      	bne.n	801debc <SFXRhodesFrame+0x954>
                            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801dee2:	f247 53e8 	movw	r3, #30184	; 0x75e8
 801dee6:	f108 0818 	add.w	r8, r8, #24
 801deea:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801deee:	4543      	cmp	r3, r8
 801def0:	d1df      	bne.n	801deb2 <SFXRhodesFrame+0x94a>
                prevDisplayValues[k] = displayValues[k];
 801def2:	f85a 3c04 	ldr.w	r3, [sl, #-4]
 801def6:	f847 3c04 	str.w	r3, [r7, #-4]
 801defa:	e6e8      	b.n	801dcce <SFXRhodesFrame+0x766>
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801defc:	f240 2550 	movw	r5, #592	; 0x250
                tSimplePoly_setNumVoices(&poly, numVoices);
 801df00:	f247 5020 	movw	r0, #29984	; 0x7520
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801df04:	f2c2 0500 	movt	r5, #8192	; 0x2000
                tSimplePoly_setNumVoices(&poly, numVoices);
 801df08:	f2c2 0001 	movt	r0, #8193	; 0x2001
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801df0c:	782a      	ldrb	r2, [r5, #0]
 801df0e:	9502      	str	r5, [sp, #8]
 801df10:	2a01      	cmp	r2, #1
 801df12:	bf98      	it	ls
 801df14:	2308      	movls	r3, #8
                tSimplePoly_setNumVoices(&poly, numVoices);
 801df16:	4619      	mov	r1, r3
                numVoices = (numVoices > 1) ? 1 : NUM_VOC_VOICES;
 801df18:	702b      	strb	r3, [r5, #0]
                tSimplePoly_setNumVoices(&poly, numVoices);
 801df1a:	f00a fbd3 	bl	80286c4 <tSimplePoly_setNumVoices>
                setLED_A(numVoices == 1);
 801df1e:	7828      	ldrb	r0, [r5, #0]
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801df20:	2300      	movs	r3, #0
                setLED_A(numVoices == 1);
 801df22:	f1a0 0001 	sub.w	r0, r0, #1
                buttonActionsSFX[ButtonA][ActionPress] = 0;
 801df26:	7523      	strb	r3, [r4, #20]
                setLED_A(numVoices == 1);
 801df28:	fab0 f080 	clz	r0, r0
 801df2c:	0940      	lsrs	r0, r0, #5
 801df2e:	f7f7 fcdd 	bl	80158ec <setLED_A>
 801df32:	f7ff bb2b 	b.w	801d58c <SFXRhodesFrame+0x24>
                tremoloStereo = !tremoloStereo;
 801df36:	f240 620c 	movw	r2, #1548	; 0x60c
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801df3a:	2300      	movs	r3, #0
                tremoloStereo = !tremoloStereo;
 801df3c:	f2c2 0200 	movt	r2, #8192	; 0x2000
                buttonActionsSFX[ButtonC][ActionPress] = 0;
 801df40:	7723      	strb	r3, [r4, #28]
                tremoloStereo = !tremoloStereo;
 801df42:	7813      	ldrb	r3, [r2, #0]
 801df44:	fab3 f383 	clz	r3, r3
 801df48:	095b      	lsrs	r3, r3, #5
                setLED_C(tremoloStereo == 1);
 801df4a:	4618      	mov	r0, r3
                tremoloStereo = !tremoloStereo;
 801df4c:	7013      	strb	r3, [r2, #0]
                setLED_C(tremoloStereo == 1);
 801df4e:	f7f7 fced 	bl	801592c <setLED_C>
 801df52:	f7ff bb37 	b.w	801d5c4 <SFXRhodesFrame+0x5c>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801df56:	eef7 3a00 	vmov.f32	s7, #112	; 0x3f800000  1.0
 801df5a:	ee76 6a63 	vsub.f32	s13, s12, s7
 801df5e:	eef0 6ae6 	vabs.f32	s13, s13
 801df62:	ee83 6aa6 	vdiv.f32	s12, s7, s13
 801df66:	e498      	b.n	801d89a <SFXRhodesFrame+0x332>
 801df68:	eeb7 3a00 	vmov.f32	s6, #112	; 0x3f800000  1.0
 801df6c:	ee73 6ac3 	vsub.f32	s13, s7, s6
 801df70:	eef0 6ae6 	vabs.f32	s13, s13
 801df74:	eec3 3a26 	vdiv.f32	s7, s6, s13
 801df78:	e4c0      	b.n	801d8fc <SFXRhodesFrame+0x394>
 801df7a:	ee77 7ac7 	vsub.f32	s15, s15, s14
 801df7e:	eef0 3ae7 	vabs.f32	s7, s15
 801df82:	eec7 7a23 	vdiv.f32	s15, s14, s7
 801df86:	e4e8      	b.n	801d95a <SFXRhodesFrame+0x3f2>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801df88:	ee33 4ac3 	vsub.f32	s8, s7, s6
 801df8c:	eef0 3ac4 	vabs.f32	s7, s8
 801df90:	ee83 4a23 	vdiv.f32	s8, s6, s7
 801df94:	e517      	b.n	801d9c6 <SFXRhodesFrame+0x45e>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801df96:	ee76 6a65 	vsub.f32	s13, s12, s11
 801df9a:	eef0 6ae6 	vabs.f32	s13, s13
 801df9e:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801dfa2:	f7ff bbe7 	b.w	801d774 <SFXRhodesFrame+0x20c>
 801dfa6:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801dfaa:	ee76 6a65 	vsub.f32	s13, s12, s11
 801dfae:	eef0 6ae6 	vabs.f32	s13, s13
 801dfb2:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801dfb6:	e40e      	b.n	801d7d6 <SFXRhodesFrame+0x26e>
 801dfb8:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
 801dfbc:	ee76 6a65 	vsub.f32	s13, s12, s11
 801dfc0:	eef0 6ae6 	vabs.f32	s13, s13
 801dfc4:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 801dfc8:	e436      	b.n	801d838 <SFXRhodesFrame+0x2d0>
                    if (rate < 0.0f) rate = 1.0f / fabsf(rate-1.0f);
 801dfca:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801dfce:	eeb0 6ae7 	vabs.f32	s12, s15
 801dfd2:	eec6 7a86 	vdiv.f32	s15, s13, s12
 801dfd6:	e58e      	b.n	801daf6 <SFXRhodesFrame+0x58e>
 801dfd8:	ee36 6a65 	vsub.f32	s12, s12, s11
 801dfdc:	eeb0 5ac6 	vabs.f32	s10, s12
 801dfe0:	ee85 6a85 	vdiv.f32	s12, s11, s10
 801dfe4:	e56b      	b.n	801dabe <SFXRhodesFrame+0x556>
 801dfe6:	ee75 5ac5 	vsub.f32	s11, s11, s10
 801dfea:	eef0 4ae5 	vabs.f32	s9, s11
 801dfee:	eec5 5a24 	vdiv.f32	s11, s10, s9
 801dff2:	e546      	b.n	801da82 <SFXRhodesFrame+0x51a>
 801dff4:	ee35 5a64 	vsub.f32	s10, s10, s9
 801dff8:	eeb0 4ac5 	vabs.f32	s8, s10
 801dffc:	ee84 5a84 	vdiv.f32	s10, s9, s8
 801e000:	e521      	b.n	801da46 <SFXRhodesFrame+0x4de>
 801e002:	ee74 4ac4 	vsub.f32	s9, s9, s8
 801e006:	eef0 3ae4 	vabs.f32	s7, s9
 801e00a:	eec4 4a23 	vdiv.f32	s9, s8, s7
 801e00e:	e4fc      	b.n	801da0a <SFXRhodesFrame+0x4a2>

0801e010 <SFXRhodesTick>:
        {
 801e010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801e014:	f642 184c 	movw	r8, #10572	; 0x294c
 801e018:	f642 2430 	movw	r4, #10800	; 0x2a30
 801e01c:	f2c2 0800 	movt	r8, #8192	; 0x2000
 801e020:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801e024:	ed2d 8b08 	vpush	{d8-d11}
 801e028:	f108 0518 	add.w	r5, r8, #24
 801e02c:	b091      	sub	sp, #68	; 0x44
 801e02e:	4646      	mov	r6, r8
 801e030:	900f      	str	r0, [sp, #60]	; 0x3c
                sustainsFinal[i] = tExpSmooth_tick(&susSmoothers[i]);
 801e032:	4620      	mov	r0, r4
 801e034:	3404      	adds	r4, #4
 801e036:	f007 ffb5 	bl	8025fa4 <tExpSmooth_tick>
 801e03a:	eca6 0a01 	vstmia	r6!, {s0}
            for (int i = 0; i < 6; i++)
 801e03e:	42ae      	cmp	r6, r5
 801e040:	d1f7      	bne.n	801e032 <SFXRhodesTick+0x22>
 801e042:	f247 5728 	movw	r7, #29992	; 0x7528
 801e046:	f2c2 0701 	movt	r7, #8193	; 0x2001
 801e04a:	f107 09c0 	add.w	r9, r7, #192	; 0xc0
 801e04e:	9707      	str	r7, [sp, #28]
        {
 801e050:	463d      	mov	r5, r7
 801e052:	4644      	mov	r4, r8
                    tADSR4_setSustain(&FM_envs[i][j], sustainsFinal[j]); //FM_sustains[Rsound][j] * displayValues[7]);
 801e054:	ecb4 0a01 	vldmia	r4!, {s0}
 801e058:	4628      	mov	r0, r5
 801e05a:	f007 fc21 	bl	80258a0 <tADSR4_setSustain>
 801e05e:	3504      	adds	r5, #4
                for (int j = 0; j < 6; j++)
 801e060:	42a6      	cmp	r6, r4
 801e062:	d1f7      	bne.n	801e054 <SFXRhodesTick+0x44>
 801e064:	3718      	adds	r7, #24
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801e066:	454f      	cmp	r7, r9
 801e068:	d1f2      	bne.n	801e050 <SFXRhodesTick+0x40>
            for (int i = 0; i < numVoices; i++)
 801e06a:	f240 2350 	movw	r3, #592	; 0x250
 801e06e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e072:	9308      	str	r3, [sp, #32]
 801e074:	781b      	ldrb	r3, [r3, #0]
 801e076:	2b00      	cmp	r3, #0
 801e078:	f000 8191 	beq.w	801e39e <SFXRhodesTick+0x38e>
 801e07c:	f243 406c 	movw	r0, #13420	; 0x346c
 801e080:	f243 433c 	movw	r3, #13372	; 0x343c
 801e084:	f642 011c 	movw	r1, #10268	; 0x281c
 801e088:	f240 5b88 	movw	fp, #1416	; 0x588
 801e08c:	f2c2 0000 	movt	r0, #8192	; 0x2000
            float rightSample = 0.0f;
 801e090:	2200      	movs	r2, #0
 801e092:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e096:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 801e09a:	900e      	str	r0, [sp, #56]	; 0x38
 801e09c:	f240 5910 	movw	r9, #1296	; 0x510
 801e0a0:	9807      	ldr	r0, [sp, #28]
 801e0a2:	f248 7894 	movw	r8, #34708	; 0x8794
 801e0a6:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801e0aa:	ee09 2a10 	vmov	s18, r2
 801e0ae:	4606      	mov	r6, r0
 801e0b0:	f2c2 0900 	movt	r9, #8192	; 0x2000
 801e0b4:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801e0b8:	f240 043c 	movw	r4, #60	; 0x3c
 801e0bc:	3614      	adds	r6, #20
 801e0be:	f240 05b4 	movw	r5, #180	; 0xb4
            float leftSample = 0.0f;
 801e0c2:	ee09 2a90 	vmov	s19, r2
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e0c6:	eef7 aa00 	vmov.f32	s21, #112	; 0x3f800000  1.0
 801e0ca:	960d      	str	r6, [sp, #52]	; 0x34
 801e0cc:	4606      	mov	r6, r0
 801e0ce:	eeb6 aa00 	vmov.f32	s20, #96	; 0x3f000000  0.5
 801e0d2:	46c2      	mov	sl, r8
 801e0d4:	3610      	adds	r6, #16
 801e0d6:	f2c2 0400 	movt	r4, #8192	; 0x2000
 801e0da:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801e0de:	960c      	str	r6, [sp, #48]	; 0x30
 801e0e0:	4606      	mov	r6, r0
 801e0e2:	e9cd 1304 	strd	r1, r3, [sp, #16]
 801e0e6:	360c      	adds	r6, #12
 801e0e8:	4613      	mov	r3, r2
 801e0ea:	465a      	mov	r2, fp
 801e0ec:	46cb      	mov	fp, r9
 801e0ee:	960b      	str	r6, [sp, #44]	; 0x2c
 801e0f0:	ee19 9a10 	vmov	r9, s18
 801e0f4:	1d06      	adds	r6, r0, #4
 801e0f6:	4690      	mov	r8, r2
 801e0f8:	3008      	adds	r0, #8
 801e0fa:	9609      	str	r6, [sp, #36]	; 0x24
 801e0fc:	900a      	str	r0, [sp, #40]	; 0x28
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801e0fe:	f8db 7000 	ldr.w	r7, [fp]
            for (int i = 0; i < numVoices; i++)
 801e102:	3301      	adds	r3, #1
                float myFrequency = freq[i];
 801e104:	9905      	ldr	r1, [sp, #20]
 801e106:	f243 4280 	movw	r2, #13440	; 0x3480
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801e10a:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 801e10e:	ed9a 0a00 	vldr	s0, [sl]
                float myFrequency = freq[i];
 801e112:	ecf1 8a01 	vldmia	r1!, {s17}
 801e116:	f2c2 0200 	movt	r2, #8192	; 0x2000
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801e11a:	00ff      	lsls	r7, r7, #3
 801e11c:	edd8 7a00 	vldr	s15, [r8]
                float myFrequency = freq[i];
 801e120:	9105      	str	r1, [sp, #20]
 801e122:	f243 4174 	movw	r1, #13428	; 0x3474
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801e126:	eb05 0c07 	add.w	ip, r5, r7
 801e12a:	ee67 7a80 	vmul.f32	s15, s15, s0
            for (int i = 0; i < numVoices; i++)
 801e12e:	9306      	str	r3, [sp, #24]
                tCycle_setFreq(&FM_sines[i][5], (myFrequency  * FM_freqRatios[Rsound][5]) + (FM_indices[Rsound][5] * feedback_output * displayValues[0]));
 801e130:	4427      	add	r7, r4
 801e132:	ed9c 0a05 	vldr	s0, [ip, #20]
 801e136:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801e13a:	f243 4378 	movw	r3, #13432	; 0x3478
 801e13e:	ed97 7a05 	vldr	s14, [r7, #20]
 801e142:	eb02 0609 	add.w	r6, r2, r9
 801e146:	eb01 0709 	add.w	r7, r1, r9
 801e14a:	ee27 0a80 	vmul.f32	s0, s15, s0
 801e14e:	3a04      	subs	r2, #4
 801e150:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e154:	3904      	subs	r1, #4
 801e156:	444a      	add	r2, r9
 801e158:	4630      	mov	r0, r6
 801e15a:	4449      	add	r1, r9
 801e15c:	444b      	add	r3, r9
 801e15e:	eea7 0a28 	vfma.f32	s0, s14, s17
 801e162:	9203      	str	r2, [sp, #12]
 801e164:	9101      	str	r1, [sp, #4]
 801e166:	9302      	str	r3, [sp, #8]
 801e168:	f00a fafe 	bl	8028768 <tCycle_setFreq>
                feedback_output = tCycle_tick(&FM_sines[i][5]);
 801e16c:	4630      	mov	r0, r6
 801e16e:	f00a fb09 	bl	8028784 <tCycle_tick>
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
 801e172:	f8db 0000 	ldr.w	r0, [fp]
 801e176:	edda 7a00 	vldr	s15, [sl]
 801e17a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
                feedback_output = tCycle_tick(&FM_sines[i][5]);
 801e17e:	ed88 0a00 	vstr	s0, [r8]
                tCycle_setFreq(&FM_sines[i][4], (myFrequency  * FM_freqRatios[Rsound][4]) + (FM_indices[Rsound][4] * feedback_output * displayValues[0] * tADSR4_tick(&FM_envs[i][5])));
 801e182:	00c0      	lsls	r0, r0, #3
 801e184:	eb05 0c00 	add.w	ip, r5, r0
 801e188:	1826      	adds	r6, r4, r0
 801e18a:	980d      	ldr	r0, [sp, #52]	; 0x34
 801e18c:	ed9c 8a04 	vldr	s16, [ip, #16]
 801e190:	4448      	add	r0, r9
 801e192:	ed96 ba04 	vldr	s22, [r6, #16]
 801e196:	ee28 8a27 	vmul.f32	s16, s16, s15
 801e19a:	9e0e      	ldr	r6, [sp, #56]	; 0x38
 801e19c:	444e      	add	r6, r9
 801e19e:	ee28 8a00 	vmul.f32	s16, s16, s0
 801e1a2:	f007 fbbf 	bl	8025924 <tADSR4_tick>
 801e1a6:	9803      	ldr	r0, [sp, #12]
 801e1a8:	ee28 0a00 	vmul.f32	s0, s16, s0
 801e1ac:	eeab 0a28 	vfma.f32	s0, s22, s17
 801e1b0:	f00a fada 	bl	8028768 <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][3], (myFrequency  * FM_freqRatios[Rsound][3]) + (FM_indices[Rsound][3] * displayValues[0] * tCycle_tick(&FM_sines[i][4]) * tADSR4_tickNoInterp(&FM_envs[i][4])));
 801e1b4:	f8db 2000 	ldr.w	r2, [fp]
 801e1b8:	edda 7a00 	vldr	s15, [sl]
 801e1bc:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 801e1c0:	9803      	ldr	r0, [sp, #12]
 801e1c2:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801e1c6:	eb05 0e0c 	add.w	lr, r5, ip
 801e1ca:	44a4      	add	ip, r4
 801e1cc:	ed9e 8a03 	vldr	s16, [lr, #12]
 801e1d0:	ed9c ba03 	vldr	s22, [ip, #12]
 801e1d4:	ee28 8a27 	vmul.f32	s16, s16, s15
 801e1d8:	f00a fad4 	bl	8028784 <tCycle_tick>
 801e1dc:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 801e1de:	ee28 8a00 	vmul.f32	s16, s16, s0
 801e1e2:	eb02 0009 	add.w	r0, r2, r9
 801e1e6:	f007 fcf7 	bl	8025bd8 <tADSR4_tickNoInterp>
 801e1ea:	9802      	ldr	r0, [sp, #8]
 801e1ec:	ee28 0a00 	vmul.f32	s0, s16, s0
 801e1f0:	eeab 0a28 	vfma.f32	s0, s22, s17
 801e1f4:	f00a fab8 	bl	8028768 <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][2], (myFrequency  * FM_freqRatios[Rsound][2]) + (FM_indices[Rsound][2] * displayValues[0] * tCycle_tick(&FM_sines[i][3]) * tADSR4_tickNoInterp(&FM_envs[i][3])));
 801e1f8:	f8db 2000 	ldr.w	r2, [fp]
 801e1fc:	edda 7a00 	vldr	s15, [sl]
 801e200:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 801e204:	9802      	ldr	r0, [sp, #8]
 801e206:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801e20a:	eb05 0e0c 	add.w	lr, r5, ip
 801e20e:	44a4      	add	ip, r4
 801e210:	ed9e 8a02 	vldr	s16, [lr, #8]
 801e214:	ed9c ba02 	vldr	s22, [ip, #8]
 801e218:	ee28 8a27 	vmul.f32	s16, s16, s15
 801e21c:	f00a fab2 	bl	8028784 <tCycle_tick>
 801e220:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 801e222:	ee28 8a00 	vmul.f32	s16, s16, s0
 801e226:	eb03 0009 	add.w	r0, r3, r9
 801e22a:	f007 fcd5 	bl	8025bd8 <tADSR4_tickNoInterp>
 801e22e:	4638      	mov	r0, r7
 801e230:	ee28 0a00 	vmul.f32	s0, s16, s0
 801e234:	eeab 0a28 	vfma.f32	s0, s22, s17
 801e238:	f00a fa96 	bl	8028768 <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][1], myFrequency  * FM_freqRatios[Rsound][1]);
 801e23c:	f8db 2000 	ldr.w	r2, [fp]
 801e240:	9801      	ldr	r0, [sp, #4]
 801e242:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 801e246:	eb04 0ccc 	add.w	ip, r4, ip, lsl #3
 801e24a:	ed9c 0a01 	vldr	s0, [ip, #4]
 801e24e:	ee28 0a80 	vmul.f32	s0, s17, s0
 801e252:	f00a fa89 	bl	8028768 <tCycle_setFreq>
                tCycle_setFreq(&FM_sines[i][0],( myFrequency  * FM_freqRatios[Rsound][0]) + (FM_indices[Rsound][0] * displayValues[0] * tCycle_tick(&FM_sines[i][1]) * tADSR4_tickNoInterp(&FM_envs[i][1])));
 801e256:	f8db 2000 	ldr.w	r2, [fp]
 801e25a:	edda 7a00 	vldr	s15, [sl]
 801e25e:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
 801e262:	9801      	ldr	r0, [sp, #4]
 801e264:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 801e268:	eb05 0e0c 	add.w	lr, r5, ip
 801e26c:	44a4      	add	ip, r4
 801e26e:	ed9e 8a00 	vldr	s16, [lr]
 801e272:	ed9c ba00 	vldr	s22, [ip]
 801e276:	ee28 8a27 	vmul.f32	s16, s16, s15
 801e27a:	f00a fa83 	bl	8028784 <tCycle_tick>
 801e27e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801e280:	ee28 8a00 	vmul.f32	s16, s16, s0
 801e284:	eb03 0009 	add.w	r0, r3, r9
 801e288:	f007 fca6 	bl	8025bd8 <tADSR4_tickNoInterp>
 801e28c:	4630      	mov	r0, r6
 801e28e:	ee28 0a00 	vmul.f32	s0, s16, s0
 801e292:	eeab 0a28 	vfma.f32	s0, s22, s17
 801e296:	f00a fa67 	bl	8028768 <tCycle_setFreq>
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
 801e29a:	4638      	mov	r0, r7
 801e29c:	f00a fa72 	bl	8028784 <tCycle_tick>
 801e2a0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801e2a2:	eeb0 ba40 	vmov.f32	s22, s0
 801e2a6:	eb03 0009 	add.w	r0, r3, r9
 801e2aa:	f007 fc95 	bl	8025bd8 <tADSR4_tickNoInterp>
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801e2ae:	4630      	mov	r0, r6
                sample += (tCycle_tick(&FM_sines[i][2]) * tADSR4_tickNoInterp(&FM_envs[i][2]));
 801e2b0:	eef0 8a40 	vmov.f32	s17, s0
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801e2b4:	f00a fa66 	bl	8028784 <tCycle_tick>
 801e2b8:	9b07      	ldr	r3, [sp, #28]
 801e2ba:	eeb0 8a40 	vmov.f32	s16, s0
 801e2be:	eb03 0009 	add.w	r0, r3, r9
 801e2c2:	f109 0918 	add.w	r9, r9, #24
 801e2c6:	f007 fc87 	bl	8025bd8 <tADSR4_tickNoInterp>
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e2ca:	9b04      	ldr	r3, [sp, #16]
 801e2cc:	edda 7a04 	vldr	s15, [sl, #16]
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801e2d0:	ee28 0a00 	vmul.f32	s0, s16, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e2d4:	ecf3 6a01 	vldmia	r3!, {s13}
 801e2d8:	ee3a 6ae7 	vsub.f32	s12, s21, s15
 801e2dc:	ee3a 7ae6 	vsub.f32	s14, s21, s13
 801e2e0:	9304      	str	r3, [sp, #16]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801e2e2:	ee67 6aa6 	vmul.f32	s13, s15, s13
            for (int i = 0; i < numVoices; i++)
 801e2e6:	9b08      	ldr	r3, [sp, #32]
                sample += tCycle_tick(&FM_sines[i][0]) * tADSR4_tickNoInterp(&FM_envs[i][0]);
 801e2e8:	eeab 0a28 	vfma.f32	s0, s22, s17
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e2ec:	ee67 7a27 	vmul.f32	s15, s14, s15
            for (int i = 0; i < numVoices; i++)
 801e2f0:	7818      	ldrb	r0, [r3, #0]
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801e2f2:	eee6 6a0a 	vfma.f32	s13, s12, s20
            for (int i = 0; i < numVoices; i++)
 801e2f6:	9b06      	ldr	r3, [sp, #24]
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e2f8:	eee6 7a0a 	vfma.f32	s15, s12, s20
            for (int i = 0; i < numVoices; i++)
 801e2fc:	4298      	cmp	r0, r3
                rightSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (panValues[i])));
 801e2fe:	eea6 9a80 	vfma.f32	s18, s13, s0
                leftSample += sample*((0.5f * (1.0f - displayValues[4])) + (displayValues[4] * (1.0f - panValues[i])));
 801e302:	eee7 9a80 	vfma.f32	s19, s15, s0
            for (int i = 0; i < numVoices; i++)
 801e306:	f73f aefa 	bgt.w	801e0fe <SFXRhodesTick+0xee>
 801e30a:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801e30e:	46d0      	mov	r8, sl
 801e310:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
 801e314:	ee07 3a90 	vmov	s15, r3
 801e318:	ee69 9aa7 	vmul.f32	s19, s19, s15
 801e31c:	ee29 9a27 	vmul.f32	s18, s18, s15
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801e320:	f247 706c 	movw	r0, #30572	; 0x776c
 801e324:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e328:	f00a fa2c 	bl	8028784 <tCycle_tick>
 801e32c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 801e330:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 801e334:	edd8 6a01 	vldr	s13, [r8, #4]
            if (tremoloStereo)
 801e338:	f240 630c 	movw	r3, #1548	; 0x60c
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801e33c:	ee30 0a27 	vadd.f32	s0, s0, s15
 801e340:	ee26 7a87 	vmul.f32	s14, s13, s14
            if (tremoloStereo)
 801e344:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e348:	ee77 7ae6 	vsub.f32	s15, s15, s13
 801e34c:	781b      	ldrb	r3, [r3, #0]
            float tremoloSignal = ((tCycle_tick(&tremolo) * 0.5f) + 0.5f) * displayValues[1];
 801e34e:	ee20 7a07 	vmul.f32	s14, s0, s14
 801e352:	ee37 0a87 	vadd.f32	s0, s15, s14
            if (tremoloStereo)
 801e356:	b9cb      	cbnz	r3, 801e38c <SFXRhodesTick+0x37c>
                rightSample *= ((tremoloSignal) + (1.0f - displayValues[1]));
 801e358:	ee29 9a00 	vmul.f32	s18, s18, s0
            leftSample *= displayValues[3]; //drive
 801e35c:	ed98 8a03 	vldr	s16, [r8, #12]
 801e360:	ee68 9a29 	vmul.f32	s19, s16, s19
            leftSample = tanhf(leftSample);
 801e364:	ee29 0a80 	vmul.f32	s0, s19, s0
 801e368:	f00d f8fc 	bl	802b564 <tanhf>
 801e36c:	eef0 8a40 	vmov.f32	s17, s0
            rightSample = tanhf(rightSample);
 801e370:	ee28 0a09 	vmul.f32	s0, s16, s18
 801e374:	f00d f8f6 	bl	802b564 <tanhf>
            input[0] = leftSample;
 801e378:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801e37a:	edc3 8a00 	vstr	s17, [r3]
            input[1] = rightSample;
 801e37e:	ed83 0a01 	vstr	s0, [r3, #4]
        }
 801e382:	b011      	add	sp, #68	; 0x44
 801e384:	ecbd 8b08 	vpop	{d8-d11}
 801e388:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                rightSample *= ((1.0f-tremoloSignal) + (1.0f - displayValues[1]));
 801e38c:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 801e390:	ee77 6ae6 	vsub.f32	s13, s15, s13
 801e394:	ee36 7ac7 	vsub.f32	s14, s13, s14
 801e398:	ee27 9a09 	vmul.f32	s18, s14, s18
 801e39c:	e7de      	b.n	801e35c <SFXRhodesTick+0x34c>
 801e39e:	f248 7894 	movw	r8, #34708	; 0x8794
            for (int i = 0; i < numVoices; i++)
 801e3a2:	ee09 3a10 	vmov	s18, r3
 801e3a6:	ee09 3a90 	vmov	s19, r3
 801e3aa:	f2c2 0801 	movt	r8, #8193	; 0x2001
 801e3ae:	e7b7      	b.n	801e320 <SFXRhodesTick+0x310>

0801e3b0 <SFXRhodesFree>:
        {
 801e3b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801e3b2:	f243 476c 	movw	r7, #13420	; 0x346c
 801e3b6:	f247 5628 	movw	r6, #29992	; 0x7528
 801e3ba:	2400      	movs	r4, #0
 801e3bc:	f2c2 0700 	movt	r7, #8192	; 0x2000
 801e3c0:	f2c2 0601 	movt	r6, #8193	; 0x2001
 801e3c4:	f104 0518 	add.w	r5, r4, #24
                    tCycle_free(&FM_sines[i][j]);
 801e3c8:	1938      	adds	r0, r7, r4
 801e3ca:	f00a f9c9 	bl	8028760 <tCycle_free>
                    tADSR4_free(&FM_envs[i][j]);
 801e3ce:	1930      	adds	r0, r6, r4
 801e3d0:	3404      	adds	r4, #4
 801e3d2:	f007 fa45 	bl	8025860 <tADSR4_free>
                for (int j = 0; j < 6; j++)
 801e3d6:	42ac      	cmp	r4, r5
 801e3d8:	d1f6      	bne.n	801e3c8 <SFXRhodesFree+0x18>
            for (int i = 0; i < NUM_VOC_VOICES; i++)
 801e3da:	2cc0      	cmp	r4, #192	; 0xc0
 801e3dc:	d1f2      	bne.n	801e3c4 <SFXRhodesFree+0x14>
                tExpSmooth_free(&susSmoothers[i]);
 801e3de:	f642 2030 	movw	r0, #10800	; 0x2a30
 801e3e2:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e3e6:	f007 fdbd 	bl	8025f64 <tExpSmooth_free>
 801e3ea:	f642 2034 	movw	r0, #10804	; 0x2a34
 801e3ee:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e3f2:	f007 fdb7 	bl	8025f64 <tExpSmooth_free>
 801e3f6:	f642 2038 	movw	r0, #10808	; 0x2a38
 801e3fa:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e3fe:	f007 fdb1 	bl	8025f64 <tExpSmooth_free>
 801e402:	f642 203c 	movw	r0, #10812	; 0x2a3c
 801e406:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e40a:	f007 fdab 	bl	8025f64 <tExpSmooth_free>
 801e40e:	f642 2040 	movw	r0, #10816	; 0x2a40
 801e412:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e416:	f007 fda5 	bl	8025f64 <tExpSmooth_free>
 801e41a:	f642 2044 	movw	r0, #10820	; 0x2a44
 801e41e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e422:	f007 fd9f 	bl	8025f64 <tExpSmooth_free>
            tCycle_free(&tremolo);
 801e426:	f247 706c 	movw	r0, #30572	; 0x776c
        }
 801e42a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
            tCycle_free(&tremolo);
 801e42e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e432:	f00a b995 	b.w	8028760 <tCycle_free>
 801e436:	bf00      	nop

0801e438 <calculateNoteArray>:
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801e438:	f240 6354 	movw	r3, #1620	; 0x654
 801e43c:	f642 2048 	movw	r0, #10824	; 0x2a48
            for (int i = 0; i < 128; i++)
 801e440:	2100      	movs	r1, #0
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801e442:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e446:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 801e44a:	b4f0      	push	{r4, r5, r6, r7}
 801e44c:	f240 6520 	movw	r5, #1568	; 0x620
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801e450:	f64a 26ab 	movw	r6, #43691	; 0xaaab
 801e454:	781f      	ldrb	r7, [r3, #0]
 801e456:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801e45a:	f6c2 26aa 	movt	r6, #10922	; 0x2aaa
                float tempNote = i;
 801e45e:	ee07 1a90 	vmov	s15, r1
            for (int i = 0; i < 128; i++)
 801e462:	3101      	adds	r1, #1
                float tempNote = i;
 801e464:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
            for (int i = 0; i < 128; i++)
 801e468:	2980      	cmp	r1, #128	; 0x80
                float tempPitchClass = ((((int)tempNote) - keyCenter) % 12 );
 801e46a:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 801e46e:	ee17 3a90 	vmov	r3, s15
 801e472:	eba3 0307 	sub.w	r3, r3, r7
 801e476:	fb86 2403 	smull	r2, r4, r6, r3
 801e47a:	ea4f 72e3 	mov.w	r2, r3, asr #31
 801e47e:	ebc2 0264 	rsb	r2, r2, r4, asr #1
 801e482:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801e486:	eba3 0382 	sub.w	r3, r3, r2, lsl #2
 801e48a:	ee07 3a90 	vmov	s15, r3
 801e48e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                float tunedNote = tempNote + centsDeviation[(int)tempPitchClass];
 801e492:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801e496:	ee17 3a90 	vmov	r3, s15
 801e49a:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 801e49e:	edd3 7a00 	vldr	s15, [r3]
 801e4a2:	ee77 7a87 	vadd.f32	s15, s15, s14
                notes[i] = tunedNote;
 801e4a6:	ece0 7a01 	vstmia	r0!, {s15}
            for (int i = 0; i < 128; i++)
 801e4aa:	d1d8      	bne.n	801e45e <calculateNoteArray+0x26>
            }
        }
 801e4ac:	bcf0      	pop	{r4, r5, r6, r7}
 801e4ae:	4770      	bx	lr

0801e4b0 <nearestNoteWithHysteresis>:

        int lastNearNote = -1;


        float nearestNoteWithHysteresis(float note, float hysteresis)
        {
 801e4b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
            float leastDifference = fastabsf(note - notes[0]);
 801e4b4:	f642 2748 	movw	r7, #10824	; 0x2a48
            int* chord;
            float output = 0.0f;

            if (autotuneChromatic > 0)
            {
                chord = chromaticArray;
 801e4b8:	f240 5830 	movw	r8, #1328	; 0x530
            float leastDifference = fastabsf(note - notes[0]);
 801e4bc:	f2c2 0700 	movt	r7, #8192	; 0x2000
                chord = chromaticArray;
 801e4c0:	f2c2 0800 	movt	r8, #8192	; 0x2000
        {
 801e4c4:	ed2d 8b04 	vpush	{d8-d9}
 801e4c8:	eef0 8a40 	vmov.f32	s17, s0
            float leastDifference = fastabsf(note - notes[0]);
 801e4cc:	ed97 0a00 	vldr	s0, [r7]
        {
 801e4d0:	eeb0 9a60 	vmov.f32	s18, s1
            float leastDifference = fastabsf(note - notes[0]);
 801e4d4:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801e4d8:	f009 f982 	bl	80277e0 <fastabsf>
            if (autotuneChromatic > 0)
 801e4dc:	f240 531c 	movw	r3, #1308	; 0x51c
                chord = chromaticArray;
 801e4e0:	f240 12f0 	movw	r2, #496	; 0x1f0
            }
            else
            {
                chord = chordArray;
            }
            if (autotuneLock > 0)
 801e4e4:	f240 5120 	movw	r1, #1312	; 0x520
            if (autotuneChromatic > 0)
 801e4e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
            float leastDifference = fastabsf(note - notes[0]);
 801e4ec:	eeb0 8a40 	vmov.f32	s16, s0
                chord = chromaticArray;
 801e4f0:	f2c2 0200 	movt	r2, #8192	; 0x2000
            if (autotuneLock > 0)
 801e4f4:	f2c2 0100 	movt	r1, #8192	; 0x2000
            if (autotuneChromatic > 0)
 801e4f8:	7818      	ldrb	r0, [r3, #0]
            {
                chord = lockArray;
 801e4fa:	f240 53a8 	movw	r3, #1448	; 0x5a8
            if (autotuneLock > 0)
 801e4fe:	6809      	ldr	r1, [r1, #0]
                chord = chromaticArray;
 801e500:	2800      	cmp	r0, #0
 801e502:	bf18      	it	ne
 801e504:	4690      	movne	r8, r2
                chord = lockArray;
 801e506:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e50a:	2900      	cmp	r1, #0
 801e50c:	bf18      	it	ne
 801e50e:	4698      	movne	r8, r3
            }
            int hasNotes = 0;
            for (int i = 0; i < 12; i++)
            {
                if (chord[i] > 0)
 801e510:	e9d8 3200 	ldrd	r3, r2, [r8]
 801e514:	f8d8 0008 	ldr.w	r0, [r8, #8]
 801e518:	2b00      	cmp	r3, #0
 801e51a:	bfcc      	ite	gt
 801e51c:	2301      	movgt	r3, #1
 801e51e:	2300      	movle	r3, #0
                {
                    hasNotes = 1;
 801e520:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801e522:	e9d8 1203 	ldrd	r1, r2, [r8, #12]
                    hasNotes = 1;
 801e526:	bfc8      	it	gt
 801e528:	2301      	movgt	r3, #1
 801e52a:	2800      	cmp	r0, #0
                if (chord[i] > 0)
 801e52c:	f8d8 0014 	ldr.w	r0, [r8, #20]
                    hasNotes = 1;
 801e530:	bfc8      	it	gt
 801e532:	2301      	movgt	r3, #1
 801e534:	2900      	cmp	r1, #0
                if (chord[i] > 0)
 801e536:	f8d8 1018 	ldr.w	r1, [r8, #24]
                    hasNotes = 1;
 801e53a:	bfc8      	it	gt
 801e53c:	2301      	movgt	r3, #1
 801e53e:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801e540:	f8d8 201c 	ldr.w	r2, [r8, #28]
                    hasNotes = 1;
 801e544:	bfc8      	it	gt
 801e546:	2301      	movgt	r3, #1
 801e548:	2800      	cmp	r0, #0
                if (chord[i] > 0)
 801e54a:	f8d8 0020 	ldr.w	r0, [r8, #32]
                    hasNotes = 1;
 801e54e:	bfc8      	it	gt
 801e550:	2301      	movgt	r3, #1
 801e552:	2900      	cmp	r1, #0
                if (chord[i] > 0)
 801e554:	f8d8 1024 	ldr.w	r1, [r8, #36]	; 0x24
                    hasNotes = 1;
 801e558:	bfc8      	it	gt
 801e55a:	2301      	movgt	r3, #1
 801e55c:	2a00      	cmp	r2, #0
                if (chord[i] > 0)
 801e55e:	f8d8 2028 	ldr.w	r2, [r8, #40]	; 0x28
                    hasNotes = 1;
 801e562:	bfc8      	it	gt
 801e564:	2301      	movgt	r3, #1
 801e566:	2800      	cmp	r0, #0
 801e568:	bfc8      	it	gt
 801e56a:	2301      	movgt	r3, #1
 801e56c:	2900      	cmp	r1, #0
 801e56e:	bfc8      	it	gt
 801e570:	2301      	movgt	r3, #1
                if (chord[i] > 0)
 801e572:	2a00      	cmp	r2, #0
 801e574:	f340 809a 	ble.w	801e6ac <nearestNoteWithHysteresis+0x1fc>
            if (hasNotes)
            {

                for(int i = 1; i < 128; i++)
                {
                    if (chord[i%12] > 0)
 801e578:	f64a 29ab 	movw	r9, #43691	; 0xaaab
 801e57c:	f642 254c 	movw	r5, #10828	; 0x2a4c
                for(int i = 1; i < 128; i++)
 801e580:	2401      	movs	r4, #1
            int nearIndex = 0;
 801e582:	2600      	movs	r6, #0
 801e584:	f2c2 0500 	movt	r5, #8192	; 0x2000
                    if (chord[i%12] > 0)
 801e588:	f6ca 29aa 	movt	r9, #43690	; 0xaaaa
 801e58c:	e003      	b.n	801e596 <nearestNoteWithHysteresis+0xe6>
                for(int i = 1; i < 128; i++)
 801e58e:	3401      	adds	r4, #1
 801e590:	3504      	adds	r5, #4
 801e592:	2c80      	cmp	r4, #128	; 0x80
 801e594:	d01c      	beq.n	801e5d0 <nearestNoteWithHysteresis+0x120>
                    if (chord[i%12] > 0)
 801e596:	fba9 2304 	umull	r2, r3, r9, r4
 801e59a:	08db      	lsrs	r3, r3, #3
 801e59c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e5a0:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
 801e5a4:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 801e5a8:	2b00      	cmp	r3, #0
 801e5aa:	ddf0      	ble.n	801e58e <nearestNoteWithHysteresis+0xde>
                    {
                        difference = fastabsf(note - notes[i]);
 801e5ac:	ed95 0a00 	vldr	s0, [r5]
 801e5b0:	ee38 0ac0 	vsub.f32	s0, s17, s0
 801e5b4:	f009 f914 	bl	80277e0 <fastabsf>
                        if(difference < leastDifference)
 801e5b8:	eeb4 0ac8 	vcmpe.f32	s0, s16
 801e5bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e5c0:	d5e5      	bpl.n	801e58e <nearestNoteWithHysteresis+0xde>
 801e5c2:	4626      	mov	r6, r4
                for(int i = 1; i < 128; i++)
 801e5c4:	3401      	adds	r4, #1
                        {
                            leastDifference = difference;
 801e5c6:	eeb0 8a40 	vmov.f32	s16, s0
 801e5ca:	3504      	adds	r5, #4
                for(int i = 1; i < 128; i++)
 801e5cc:	2c80      	cmp	r4, #128	; 0x80
 801e5ce:	d1e2      	bne.n	801e596 <nearestNoteWithHysteresis+0xe6>
                            nearIndex = i;
                        }
                    }
                }

                if (lastNearNote == -1)
 801e5d0:	f240 2048 	movw	r0, #584	; 0x248
 801e5d4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e5d8:	6801      	ldr	r1, [r0, #0]
 801e5da:	1c4b      	adds	r3, r1, #1
 801e5dc:	d05d      	beq.n	801e69a <nearestNoteWithHysteresis+0x1ea>
 801e5de:	eb07 0381 	add.w	r3, r7, r1, lsl #2
                {
                    output = notes[nearIndex];
                    lastNearNote = nearIndex;
                    return output;
                }
                if (nearIndex != lastNearNote)
 801e5e2:	42b1      	cmp	r1, r6
 801e5e4:	ed93 0a00 	vldr	s0, [r3]
 801e5e8:	d05c      	beq.n	801e6a4 <nearestNoteWithHysteresis+0x1f4>
                    int downNote = 128;
                    int i = lastNearNote;
                    while ((i < 128) && (upNote == 0))
                    {
                        i++;
                        if (chord[i%12] > 0)
 801e5ea:	f64a 2cab 	movw	ip, #43691	; 0xaaab
 801e5ee:	460b      	mov	r3, r1
                    int upNote = 0;
 801e5f0:	2400      	movs	r4, #0
                        if (chord[i%12] > 0)
 801e5f2:	f6c2 2caa 	movt	ip, #10922	; 0x2aaa
 801e5f6:	e00f      	b.n	801e618 <nearestNoteWithHysteresis+0x168>
 801e5f8:	ebc2 0265 	rsb	r2, r2, r5, asr #1
                    while ((i < 128) && (upNote == 0))
 801e5fc:	b9a4      	cbnz	r4, 801e628 <nearestNoteWithHysteresis+0x178>
                        if (chord[i%12] > 0)
 801e5fe:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 801e602:	eba3 0282 	sub.w	r2, r3, r2, lsl #2
 801e606:	f858 2022 	ldr.w	r2, [r8, r2, lsl #2]
 801e60a:	2a00      	cmp	r2, #0
 801e60c:	bfcc      	ite	gt
 801e60e:	461c      	movgt	r4, r3
 801e610:	2400      	movle	r4, #0
                        {
                            upNote = i;
                        }
                        if (i == 128)
                        {
                            upNote = 128;
 801e612:	2b80      	cmp	r3, #128	; 0x80
 801e614:	bf08      	it	eq
 801e616:	461c      	moveq	r4, r3
                    while ((i < 128) && (upNote == 0))
 801e618:	2b7f      	cmp	r3, #127	; 0x7f
                        i++;
 801e61a:	f103 0301 	add.w	r3, r3, #1
                        if (chord[i%12] > 0)
 801e61e:	fb8c 2503 	smull	r2, r5, ip, r3
 801e622:	ea4f 72e3 	mov.w	r2, r3, asr #31
                    while ((i < 128) && (upNote == 0))
 801e626:	dde7      	ble.n	801e5f8 <nearestNoteWithHysteresis+0x148>
                    }
                    i = lastNearNote;
                    while ((i > 0) && (downNote == 128))
                    {
                        i--;
                        if (chord[i%12] > 0)
 801e628:	f64a 25ab 	movw	r5, #43691	; 0xaaab
                    int downNote = 128;
 801e62c:	2280      	movs	r2, #128	; 0x80
                        if (chord[i%12] > 0)
 801e62e:	f6ca 25aa 	movt	r5, #43690	; 0xaaaa
 801e632:	e010      	b.n	801e656 <nearestNoteWithHysteresis+0x1a6>
                    while ((i > 0) && (downNote == 128))
 801e634:	2a80      	cmp	r2, #128	; 0x80
                        if (chord[i%12] > 0)
 801e636:	ea4f 03d3 	mov.w	r3, r3, lsr #3
                    while ((i > 0) && (downNote == 128))
 801e63a:	d112      	bne.n	801e662 <nearestNoteWithHysteresis+0x1b2>
                        if (chord[i%12] > 0)
 801e63c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e640:	eba1 0383 	sub.w	r3, r1, r3, lsl #2
 801e644:	f858 3023 	ldr.w	r3, [r8, r3, lsl #2]
 801e648:	2b00      	cmp	r3, #0
 801e64a:	bfcc      	ite	gt
 801e64c:	460a      	movgt	r2, r1
 801e64e:	2280      	movle	r2, #128	; 0x80
                        {
                            downNote = i;
                        }
                        if (i == 0)
                        {
                            downNote = 0;
 801e650:	2900      	cmp	r1, #0
 801e652:	bf08      	it	eq
 801e654:	460a      	moveq	r2, r1
                    while ((i > 0) && (downNote == 128))
 801e656:	2900      	cmp	r1, #0
                        i--;
 801e658:	f101 31ff 	add.w	r1, r1, #4294967295	; 0xffffffff
                        if (chord[i%12] > 0)
 801e65c:	fba5 c301 	umull	ip, r3, r5, r1
                    while ((i > 0) && (downNote == 128))
 801e660:	dce8      	bgt.n	801e634 <nearestNoteWithHysteresis+0x184>
                        }
                    }
                    //now should have adjacent notes in array available
                    //calculate the differences that should be necessary to move away
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
 801e662:	eb07 0282 	add.w	r2, r7, r2, lsl #2

                    float theDifference = note - notes[lastNearNote];
 801e666:	ee78 8ac0 	vsub.f32	s17, s17, s0
                    float lowerNearHyst = (notes[lastNearNote] - notes[downNote]) * -hysteresis;
 801e66a:	edd2 7a00 	vldr	s15, [r2]
 801e66e:	ee70 7a67 	vsub.f32	s15, s0, s15
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
 801e672:	ee69 7a67 	vnmul.f32	s15, s18, s15
 801e676:	eef4 7ae8 	vcmpe.f32	s15, s17
 801e67a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e67e:	dc0c      	bgt.n	801e69a <nearestNoteWithHysteresis+0x1ea>
                    float upperNearHyst = (notes[upNote] - notes[lastNearNote]) * hysteresis;
 801e680:	eb07 0484 	add.w	r4, r7, r4, lsl #2
 801e684:	edd4 7a00 	vldr	s15, [r4]
 801e688:	ee77 7ac0 	vsub.f32	s15, s15, s0
 801e68c:	ee27 9a89 	vmul.f32	s18, s15, s18
                    if ((theDifference > upperNearHyst) || (theDifference < lowerNearHyst))
 801e690:	eeb4 9a68 	vcmp.f32	s18, s17
 801e694:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e698:	d504      	bpl.n	801e6a4 <nearestNoteWithHysteresis+0x1f4>
                    {
                        output = notes[nearIndex];
 801e69a:	eb07 0786 	add.w	r7, r7, r6, lsl #2
                        lastNearNote = nearIndex;
 801e69e:	6006      	str	r6, [r0, #0]
                        output = notes[nearIndex];
 801e6a0:	ed97 0a00 	vldr	s0, [r7]
            else
            {
                output = -1.0f; //signal that there are no notes to snap to
            }
            return output;
        }
 801e6a4:	ecbd 8b04 	vpop	{d8-d9}
 801e6a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
                if (chord[i] > 0)
 801e6ac:	f8d8 202c 	ldr.w	r2, [r8, #44]	; 0x2c
 801e6b0:	2a00      	cmp	r2, #0
 801e6b2:	f73f af61 	bgt.w	801e578 <nearestNoteWithHysteresis+0xc8>
            if (hasNotes)
 801e6b6:	2b00      	cmp	r3, #0
 801e6b8:	f47f af5e 	bne.w	801e578 <nearestNoteWithHysteresis+0xc8>
                output = -1.0f; //signal that there are no notes to snap to
 801e6bc:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
        }
 801e6c0:	ecbd 8b04 	vpop	{d8-d9}
 801e6c4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0801e6c8 <SFXNeartuneTick>:
        {
 801e6c8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e6cc:	f24e 1348 	movw	r3, #57672	; 0xe148
 801e6d0:	f642 5510 	movw	r5, #11536	; 0x2d10
 801e6d4:	f248 7494 	movw	r4, #34708	; 0x8794
        {
 801e6d8:	4680      	mov	r8, r0
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e6da:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801e6de:	f6c3 63fa 	movt	r3, #16122	; 0x3efa
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801e6e2:	f247 5018 	movw	r0, #29976	; 0x7518
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e6e6:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801e6ea:	ee07 3a90 	vmov	s15, r3
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801e6ee:	f2c2 0001 	movt	r0, #8193	; 0x2001
        {
 801e6f2:	ed2d 8b02 	vpush	{d8}
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e6f6:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
 801e6fa:	ed95 7a4b 	vldr	s14, [r5, #300]	; 0x12c
        {
 801e6fe:	b083      	sub	sp, #12
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e700:	eef0 6a48 	vmov.f32	s13, s16
 801e704:	eee7 6a27 	vfma.f32	s13, s14, s15
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801e708:	eeb0 0a66 	vmov.f32	s0, s13
            displayValues[0] = 0.5f + (presetKnobValues[AutotuneMono][0] * 0.49f); //fidelity
 801e70c:	edc4 6a00 	vstr	s13, [r4]
            tRetune_setFidelityThreshold(&autotuneMono, displayValues[0]);
 801e710:	f006 fb22 	bl	8024d58 <tRetune_setFidelityThreshold>
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
 801e714:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 801e718:	edd5 0a4c 	vldr	s1, [r5, #304]	; 0x130
 801e71c:	2200      	movs	r2, #0
 801e71e:	f6c3 738c 	movt	r3, #16268	; 0x3f8c
 801e722:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 801e726:	ee00 2a10 	vmov	s0, r2
 801e72a:	ee07 3a90 	vmov	s15, r3
 801e72e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 801e732:	f009 f941 	bl	80279b8 <LEAF_clip>
            if (displayValues[2] > .90f)
 801e736:	f246 6366 	movw	r3, #26214	; 0x6666
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801e73a:	eef2 6a08 	vmov.f32	s13, #40	; 0x41400000  12.0
 801e73e:	edd5 7a4e 	vldr	s15, [r5, #312]	; 0x138
            if (displayValues[2] > .90f)
 801e742:	f6c3 7366 	movt	r3, #16230	; 0x3f66
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801e746:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
 801e74a:	ed95 6a4d 	vldr	s12, [r5, #308]	; 0x134
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801e74e:	ee67 7aa6 	vmul.f32	s15, s15, s13
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801e752:	ed95 7a4f 	vldr	s14, [r5, #316]	; 0x13c
            if (displayValues[2] > .90f)
 801e756:	ee06 3a90 	vmov	s13, r3
            displayValues[1] = LEAF_clip(0.0f, presetKnobValues[AutotuneMono][1] * 1.1f, 1.0f); // amount of forcing to new pitch
 801e75a:	ed84 0a01 	vstr	s0, [r4, #4]
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801e75e:	ee37 7a25 	vadd.f32	s14, s14, s11
            displayValues[2] = presetKnobValues[AutotuneMono][2]; //speed to get to desired pitch shift
 801e762:	ed84 6a02 	vstr	s12, [r4, #8]
            if (displayValues[2] > .90f)
 801e766:	eeb4 6ae6 	vcmpe.f32	s12, s13
            displayValues[3] = presetKnobValues[AutotuneMono][3] * 12.0f;
 801e76a:	edc4 7a03 	vstr	s15, [r4, #12]
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801e76e:	ee27 7a08 	vmul.f32	s14, s14, s16
            if (displayValues[2] > .90f)
 801e772:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            displayValues[4] = (presetKnobValues[AutotuneMono][4] * 0.5f) + 0.5f;
 801e776:	ed84 7a04 	vstr	s14, [r4, #16]
            if (displayValues[2] > .90f)
 801e77a:	f300 80b8 	bgt.w	801e8ee <SFXNeartuneTick+0x226>
 801e77e:	ee66 7a06 	vmul.f32	s15, s12, s12
 801e782:	ee67 7a86 	vmul.f32	s15, s15, s12
            tExpSmooth_setFactor(&neartune_smoother, expBuffer[(int)(displayValues[2] * displayValues[2] * displayValues[2] * expBufferSizeMinusOne)]);
 801e786:	f240 2238 	movw	r2, #568	; 0x238
 801e78a:	f247 0344 	movw	r3, #28740	; 0x7044
 801e78e:	f247 50e8 	movw	r0, #30184	; 0x75e8
 801e792:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801e796:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801e79a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e79e:	ed92 7a00 	vldr	s14, [r2]
 801e7a2:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e7a6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 801e7aa:	ee17 2a90 	vmov	r2, s15
 801e7ae:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 801e7b2:	ed93 0a00 	vldr	s0, [r3]
 801e7b6:	f007 fbd9 	bl	8025f6c <tExpSmooth_setFactor>
            float destFactor = tExpSmooth_tick(&neartune_smoother);
 801e7ba:	f247 50e8 	movw	r0, #30184	; 0x75e8
 801e7be:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e7c2:	f007 fbef 	bl	8025fa4 <tExpSmooth_tick>
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
 801e7c6:	f247 5018 	movw	r0, #29976	; 0x7518
            float destFactor = tExpSmooth_tick(&neartune_smoother);
 801e7ca:	eef0 8a40 	vmov.f32	s17, s0
            float detectedPeriod = tRetune_getInputPeriod(&autotuneMono);
 801e7ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e7d2:	f006 fac5 	bl	8024d60 <tRetune_getInputPeriod>
            if (detectedPeriod > 0.0f)
 801e7d6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 801e7da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e7de:	dd56      	ble.n	801e88e <SFXNeartuneTick+0x1c6>
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
 801e7e0:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 801e7e4:	f240 2530 	movw	r5, #560	; 0x230
 801e7e8:	f2c2 0500 	movt	r5, #8192	; 0x2000
 801e7ec:	ee88 0a00 	vdiv.f32	s0, s16, s0
 801e7f0:	f009 f868 	bl	80278c4 <LEAF_frequencyToMidi>
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801e7f4:	edd4 0a04 	vldr	s1, [r4, #16]
                detectedNote = LEAF_frequencyToMidi(1.0f / detectedPeriod);
 801e7f8:	ed85 0a00 	vstr	s0, [r5]
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801e7fc:	f7ff fe58 	bl	801e4b0 <nearestNoteWithHysteresis>
 801e800:	f240 2324 	movw	r3, #548	; 0x224
                if (desiredSnap > 0.0f)
 801e804:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
                desiredSnap = nearestNoteWithHysteresis(detectedNote, displayValues[4]);
 801e808:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e80c:	ed83 0a00 	vstr	s0, [r3]
                if (desiredSnap > 0.0f)
 801e810:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e814:	f340 808e 	ble.w	801e934 <SFXNeartuneTick+0x26c>
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e818:	edd4 6a01 	vldr	s13, [r4, #4]
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e81c:	f240 244c 	movw	r4, #588	; 0x24c
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e820:	edd5 7a00 	vldr	s15, [r5]
                    if ((changeAmount < 11.9))
 801e824:	f64c 46cd 	movw	r6, #52429	; 0xcccd
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e828:	ee38 8a66 	vsub.f32	s16, s16, s13
                    if ((changeAmount < 11.9))
 801e82c:	f64c 47cc 	movw	r7, #52428	; 0xcccc
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e830:	f2c2 0400 	movt	r4, #8192	; 0x2000
                    if ((changeAmount < 11.9))
 801e834:	f6cc 46cc 	movt	r6, #52428	; 0xcccc
 801e838:	f2c4 0727 	movt	r7, #16423	; 0x4027
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801e83c:	f240 522c 	movw	r2, #1324	; 0x52c
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e840:	ee28 8a27 	vmul.f32	s16, s16, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e844:	ed94 7a00 	vldr	s14, [r4]
 801e848:	f240 5380 	movw	r3, #1408	; 0x580
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e84c:	f240 292c 	movw	r9, #556	; 0x22c
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801e850:	f2c2 0200 	movt	r2, #8192	; 0x2000
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e854:	eea0 8a26 	vfma.f32	s16, s0, s13
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e858:	f2c2 0300 	movt	r3, #8192	; 0x2000
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e85c:	f2c2 0900 	movt	r9, #8192	; 0x2000
                    if ((changeAmount < 11.9))
 801e860:	ec47 6b16 	vmov	d6, r6, r7
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801e864:	ee78 7a67 	vsub.f32	s15, s16, s15
                    destinationNote = (desiredSnap * displayValues[1]) + (detectedNote * (1.0f - displayValues[1]));
 801e868:	ed89 8a00 	vstr	s16, [r9]
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e86c:	ee38 7a47 	vsub.f32	s14, s16, s14
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801e870:	eef0 7ae7 	vabs.f32	s15, s15
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e874:	eeb0 7ac7 	vabs.f32	s14, s14
                    if ((changeAmount < 11.9))
 801e878:	eeb7 5ae7 	vcvt.f64.f32	d5, s15
                    changeAmount = (fabsf(destinationNote-detectedNote));
 801e87c:	edc2 7a00 	vstr	s15, [r2]
                    factorDiff = (fabsf(destinationNote-lastSnap));
 801e880:	ed83 7a00 	vstr	s14, [r3]
                    if ((changeAmount < 11.9))
 801e884:	eeb4 5bc6 	vcmpe.f64	d5, d6
 801e888:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 801e88c:	d434      	bmi.n	801e8f8 <SFXNeartuneTick+0x230>
            tRetune_setPitchFactor(&autotuneMono, destFactor, 0);
 801e88e:	f247 5018 	movw	r0, #29976	; 0x7518
 801e892:	2100      	movs	r1, #0
 801e894:	eeb0 0a68 	vmov.f32	s0, s17
 801e898:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e89c:	f006 fa4a 	bl	8024d34 <tRetune_setPitchFactor>
            float* samples = tRetune_tick(&autotuneMono, input[1]);
 801e8a0:	f247 5018 	movw	r0, #29976	; 0x7518
 801e8a4:	ed98 0a01 	vldr	s0, [r8, #4]
 801e8a8:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e8ac:	f006 f96c 	bl	8024b88 <tRetune_tick>
 801e8b0:	4604      	mov	r4, r0
            LEAF_crossfade(tRamp_tick(&nearWetRamp), fades);
 801e8b2:	f248 3064 	movw	r0, #33636	; 0x8364
 801e8b6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e8ba:	f007 fad7 	bl	8025e6c <tRamp_tick>
 801e8be:	4668      	mov	r0, sp
 801e8c0:	f008 ffea 	bl	8027898 <LEAF_crossfade>
            sample += input[1] * fades[1]; // crossfade to dry signal if no notes held down.
 801e8c4:	edd8 7a01 	vldr	s15, [r8, #4]
 801e8c8:	ed9d 7a01 	vldr	s14, [sp, #4]
 801e8cc:	edd4 6a00 	vldr	s13, [r4]
 801e8d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 801e8d4:	ed9d 7a00 	vldr	s14, [sp]
 801e8d8:	eee6 7a87 	vfma.f32	s15, s13, s14
            input[0] = sample;
 801e8dc:	edc8 7a00 	vstr	s15, [r8]
            input[1] = sample;
 801e8e0:	edc8 7a01 	vstr	s15, [r8, #4]
        }
 801e8e4:	b003      	add	sp, #12
 801e8e6:	ecbd 8b02 	vpop	{d8}
 801e8ea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
                displayValues[2] = 1.0f;
 801e8ee:	eef0 7a65 	vmov.f32	s15, s11
 801e8f2:	edc4 5a02 	vstr	s11, [r4, #8]
 801e8f6:	e746      	b.n	801e786 <SFXNeartuneTick+0xbe>
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
 801e8f8:	eeb0 0a48 	vmov.f32	s0, s16
 801e8fc:	f009 f946 	bl	8027b8c <LEAF_midiToFrequency>
 801e900:	eeb0 8a40 	vmov.f32	s16, s0
 801e904:	ed95 0a00 	vldr	s0, [r5]
 801e908:	f009 f940 	bl	8027b8c <LEAF_midiToFrequency>
 801e90c:	f240 2328 	movw	r3, #552	; 0x228
 801e910:	eec8 7a00 	vdiv.f32	s15, s16, s0
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
 801e914:	f247 50e8 	movw	r0, #30184	; 0x75e8
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
 801e918:	f2c2 0300 	movt	r3, #8192	; 0x2000
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
 801e91c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e920:	eeb0 0a67 	vmov.f32	s0, s15
                        destinationFactor = (LEAF_midiToFrequency(destinationNote) / LEAF_midiToFrequency(detectedNote));
 801e924:	edc3 7a00 	vstr	s15, [r3]
                        tExpSmooth_setDest(&neartune_smoother, destinationFactor);
 801e928:	f007 fb32 	bl	8025f90 <tExpSmooth_setDest>
                        lastSnap = destinationNote;
 801e92c:	f8d9 3000 	ldr.w	r3, [r9]
 801e930:	6023      	str	r3, [r4, #0]
 801e932:	e7ac      	b.n	801e88e <SFXNeartuneTick+0x1c6>
                    tExpSmooth_setDest(&neartune_smoother, 1.0f);
 801e934:	f247 50e8 	movw	r0, #30184	; 0x75e8
 801e938:	eeb0 0a48 	vmov.f32	s0, s16
 801e93c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e940:	f007 fb26 	bl	8025f90 <tExpSmooth_setDest>
 801e944:	e7a3      	b.n	801e88e <SFXNeartuneTick+0x1c6>
 801e946:	bf00      	nop

0801e948 <noteOff>:
            }
        }

        void noteOff(int key, int velocity)
        {
            if (chordArray[key%12] > 0) chordArray[key%12]--;
 801e948:	f64a 22ab 	movw	r2, #43691	; 0xaaab
 801e94c:	17c3      	asrs	r3, r0, #31
 801e94e:	f240 5130 	movw	r1, #1328	; 0x530
 801e952:	f6c2 22aa 	movt	r2, #10922	; 0x2aaa
 801e956:	f2c2 0100 	movt	r1, #8192	; 0x2000
        {
 801e95a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 801e95e:	4604      	mov	r4, r0
            if (chordArray[key%12] > 0) chordArray[key%12]--;
 801e960:	fb82 0204 	smull	r0, r2, r2, r4
 801e964:	ebc3 0362 	rsb	r3, r3, r2, asr #1
 801e968:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801e96c:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
 801e970:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
 801e974:	2a00      	cmp	r2, #0
 801e976:	dd02      	ble.n	801e97e <noteOff+0x36>
 801e978:	3a01      	subs	r2, #1
 801e97a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]



            if (currentPreset == Rhodes)
 801e97e:	f240 6355 	movw	r3, #1621	; 0x655
 801e982:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801e986:	781b      	ldrb	r3, [r3, #0]
 801e988:	2b11      	cmp	r3, #17
 801e98a:	d057      	beq.n	801ea3c <noteOff+0xf4>
                        tADSR4_off(&FM_envs[voice][j]);
                    }
                }

            }
            else if (currentPreset == ClassicSynth)
 801e98c:	2b10      	cmp	r3, #16
 801e98e:	d07b      	beq.n	801ea88 <noteOff+0x140>
                    tADSR4_off(&polyEnvs[voice]);
                    tADSR4_off(&polyFiltEnvs[voice]);
                }
            }

            else if (currentPreset == SamplerKeyboard)
 801e990:	2b06      	cmp	r3, #6
 801e992:	d013      	beq.n	801e9bc <noteOff+0x74>
            }
            else if (currentPreset == LivingStringSynth)
            {
                int voice;

                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801e994:	f247 5020 	movw	r0, #29984	; 0x7520
            else if (currentPreset == LivingStringSynth)
 801e998:	2b0f      	cmp	r3, #15
 801e99a:	b2e1      	uxtb	r1, r4
                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801e99c:	f2c2 0001 	movt	r0, #8193	; 0x2001
            else if (currentPreset == LivingStringSynth)
 801e9a0:	f000 8094 	beq.w	801eacc <noteOff+0x184>
                    tADSR4_off(&pluckEnvs[voice]);
                }
            }
            else
            {
                tSimplePoly_noteOff(&poly, key);
 801e9a4:	f009 fd36 	bl	8028414 <tSimplePoly_noteOff>
            }

            if (tSimplePoly_getNumActiveVoices(&poly) < 1)
 801e9a8:	f247 5020 	movw	r0, #29984	; 0x7520
 801e9ac:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e9b0:	f009 fe94 	bl	80286dc <tSimplePoly_getNumActiveVoices>
 801e9b4:	2800      	cmp	r0, #0
 801e9b6:	dd3c      	ble.n	801ea32 <noteOff+0xea>
            {
                setLED_2(0);
            }

        }
 801e9b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                if (key >= LOWEST_SAMPLER_KEY && key < LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS)
 801e9bc:	f1a4 0524 	sub.w	r5, r4, #36	; 0x24
 801e9c0:	2d30      	cmp	r5, #48	; 0x30
 801e9c2:	d8f1      	bhi.n	801e9a8 <noteOff+0x60>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801e9c4:	f247 5020 	movw	r0, #29984	; 0x7520
 801e9c8:	b2e1      	uxtb	r1, r4
 801e9ca:	ea4f 0885 	mov.w	r8, r5, lsl #2
 801e9ce:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e9d2:	f009 fe0b 	bl	80285ec <tSimplePoly_markPendingNoteOff>
 801e9d6:	4607      	mov	r7, r0
                    if (tBuffer_isActive(&keyBuff[key-LOWEST_SAMPLER_KEY]) == 1)
 801e9d8:	f248 1064 	movw	r0, #33124	; 0x8164
 801e9dc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801e9e0:	eb08 0600 	add.w	r6, r8, r0
 801e9e4:	4630      	mov	r0, r6
 801e9e6:	f00b fb23 	bl	802a030 <tBuffer_isActive>
 801e9ea:	2801      	cmp	r0, #1
 801e9ec:	d07f      	beq.n	801eaee <noteOff+0x1a6>
                        tExpSmooth_setDest(&kSamplerGains[key-LOWEST_SAMPLER_KEY], 0.0f);
 801e9ee:	f242 608c 	movw	r0, #9868	; 0x268c
 801e9f2:	2300      	movs	r3, #0
 801e9f4:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801e9f8:	ee00 3a10 	vmov	s0, r3
 801e9fc:	4440      	add	r0, r8
 801e9fe:	f007 fac7 	bl	8025f90 <tExpSmooth_setDest>
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
 801ea02:	f247 7338 	movw	r3, #30520	; 0x7738
 801ea06:	2200      	movs	r2, #0
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
 801ea08:	2103      	movs	r1, #3
 801ea0a:	2007      	movs	r0, #7
                    samplerKeyHeld[key-LOWEST_SAMPLER_KEY] = 0;
 801ea0c:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ea10:	555a      	strb	r2, [r3, r5]
                    UISamplerKButtons(ButtonC, ActionHoldContinuous);
 801ea12:	f002 fab1 	bl	8020f78 <UISamplerKButtons>
                    tSampler_stop(&keySampler[key-LOWEST_SAMPLER_KEY]);
 801ea16:	f243 502c 	movw	r0, #13612	; 0x352c
 801ea1a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ea1e:	4440      	add	r0, r8
 801ea20:	f00b fc0c 	bl	802a23c <tSampler_stop>
                    waitingForDeactivation[voice] = key;
 801ea24:	f247 6314 	movw	r3, #30228	; 0x7614
 801ea28:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ea2c:	f843 4027 	str.w	r4, [r3, r7, lsl #2]
 801ea30:	e7ba      	b.n	801e9a8 <noteOff+0x60>
                setLED_2(0);
 801ea32:	2000      	movs	r0, #0
        }
 801ea34:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
                setLED_2(0);
 801ea38:	f7f6 bf48 	b.w	80158cc <setLED_2>
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801ea3c:	f247 5020 	movw	r0, #29984	; 0x7520
 801ea40:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ea44:	f009 fe46 	bl	80286d4 <tSimplePoly_getNumVoices>
 801ea48:	2801      	cmp	r0, #1
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801ea4a:	f247 5020 	movw	r0, #29984	; 0x7520
 801ea4e:	b2e1      	uxtb	r1, r4
 801ea50:	f2c2 0001 	movt	r0, #8193	; 0x2001
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801ea54:	dd15      	ble.n	801ea82 <noteOff+0x13a>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801ea56:	f009 fdc9 	bl	80285ec <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
 801ea5a:	2800      	cmp	r0, #0
 801ea5c:	dba4      	blt.n	801e9a8 <noteOff+0x60>
 801ea5e:	f247 5428 	movw	r4, #29992	; 0x7528
 801ea62:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 801ea66:	f2c2 0401 	movt	r4, #8193	; 0x2001
 801ea6a:	00c0      	lsls	r0, r0, #3
 801ea6c:	f104 0518 	add.w	r5, r4, #24
 801ea70:	4404      	add	r4, r0
 801ea72:	4405      	add	r5, r0
                        tADSR4_off(&FM_envs[voice][j]);
 801ea74:	4620      	mov	r0, r4
 801ea76:	3404      	adds	r4, #4
 801ea78:	f006 ff4c 	bl	8025914 <tADSR4_off>
                    for (int j = 0; j < 6; j++)
 801ea7c:	42a5      	cmp	r5, r4
 801ea7e:	d1f9      	bne.n	801ea74 <noteOff+0x12c>
 801ea80:	e792      	b.n	801e9a8 <noteOff+0x60>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801ea82:	f009 fcc7 	bl	8028414 <tSimplePoly_noteOff>
 801ea86:	e7e8      	b.n	801ea5a <noteOff+0x112>
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801ea88:	f247 5020 	movw	r0, #29984	; 0x7520
 801ea8c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ea90:	f009 fe20 	bl	80286d4 <tSimplePoly_getNumVoices>
 801ea94:	2801      	cmp	r0, #1
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801ea96:	f247 5020 	movw	r0, #29984	; 0x7520
 801ea9a:	b2e1      	uxtb	r1, r4
 801ea9c:	f2c2 0001 	movt	r0, #8193	; 0x2001
                if (tSimplePoly_getNumVoices(&poly) > 1)
 801eaa0:	dd22      	ble.n	801eae8 <noteOff+0x1a0>
                    voice = tSimplePoly_markPendingNoteOff(&poly, key); //if we're polyphonic, we need to let release envelopes happen and not mark voices free when they are not
 801eaa2:	f009 fda3 	bl	80285ec <tSimplePoly_markPendingNoteOff>
                if (voice >= 0)
 801eaa6:	2800      	cmp	r0, #0
 801eaa8:	f6ff af7e 	blt.w	801e9a8 <noteOff+0x60>
                    tADSR4_off(&polyEnvs[voice]);
 801eaac:	f247 639c 	movw	r3, #30364	; 0x769c
 801eab0:	0084      	lsls	r4, r0, #2
 801eab2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801eab6:	1918      	adds	r0, r3, r4
 801eab8:	f006 ff2c 	bl	8025914 <tADSR4_off>
                    tADSR4_off(&polyFiltEnvs[voice]);
 801eabc:	f641 7048 	movw	r0, #8008	; 0x1f48
 801eac0:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801eac4:	4420      	add	r0, r4
 801eac6:	f006 ff25 	bl	8025914 <tADSR4_off>
 801eaca:	e76d      	b.n	801e9a8 <noteOff+0x60>
                voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801eacc:	f009 fca2 	bl	8028414 <tSimplePoly_noteOff>
                if (voice >= 0)
 801ead0:	2800      	cmp	r0, #0
 801ead2:	f6ff af69 	blt.w	801e9a8 <noteOff+0x60>
                    tADSR4_off(&pluckEnvs[voice]);
 801ead6:	f247 4308 	movw	r3, #29704	; 0x7408
 801eada:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801eade:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801eae2:	f006 ff17 	bl	8025914 <tADSR4_off>
 801eae6:	e75f      	b.n	801e9a8 <noteOff+0x60>
                    voice = tSimplePoly_noteOff(&poly, key); //if we're monophonic, we need to allow fast voice stealing and returning to previous stolen notes without regard for the release envelopes
 801eae8:	f009 fc94 	bl	8028414 <tSimplePoly_noteOff>
 801eaec:	e7db      	b.n	801eaa6 <noteOff+0x15e>
                        tBuffer_stop(&keyBuff[key-LOWEST_SAMPLER_KEY]);
 801eaee:	4630      	mov	r0, r6
 801eaf0:	f00b fa86 	bl	802a000 <tBuffer_stop>
                        UISamplerKButtons(ButtonUp, ActionPress);
 801eaf4:	2100      	movs	r1, #0
 801eaf6:	2004      	movs	r0, #4
 801eaf8:	f002 fa3e 	bl	8020f78 <UISamplerKButtons>
 801eafc:	e781      	b.n	801ea02 <noteOff+0xba>
 801eafe:	bf00      	nop

0801eb00 <noteOn>:
            if (!velocity)
 801eb00:	2900      	cmp	r1, #0
 801eb02:	d048      	beq.n	801eb96 <noteOn+0x96>
                chordArray[key%12]++;
 801eb04:	f240 5230 	movw	r2, #1328	; 0x530
        {
 801eb08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801eb0a:	460d      	mov	r5, r1
                chordArray[key%12]++;
 801eb0c:	f64a 21ab 	movw	r1, #43691	; 0xaaab
 801eb10:	4604      	mov	r4, r0
 801eb12:	17c3      	asrs	r3, r0, #31
 801eb14:	f6c2 21aa 	movt	r1, #10922	; 0x2aaa
                if (currentPreset == AutotuneMono)
 801eb18:	f240 6055 	movw	r0, #1621	; 0x655
                chordArray[key%12]++;
 801eb1c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801eb20:	fb81 6104 	smull	r6, r1, r1, r4
                if (currentPreset == AutotuneMono)
 801eb24:	f2c2 0000 	movt	r0, #8192	; 0x2000
                chordArray[key%12]++;
 801eb28:	ebc3 0361 	rsb	r3, r3, r1, asr #1
 801eb2c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 801eb30:	eba4 0383 	sub.w	r3, r4, r3, lsl #2
        {
 801eb34:	ed2d 8b02 	vpush	{d8}
                chordArray[key%12]++;
 801eb38:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
                if (currentPreset == AutotuneMono)
 801eb3c:	7800      	ldrb	r0, [r0, #0]
                chordArray[key%12]++;
 801eb3e:	3101      	adds	r1, #1
                if (currentPreset == AutotuneMono)
 801eb40:	2803      	cmp	r0, #3
                chordArray[key%12]++;
 801eb42:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                if (currentPreset == AutotuneMono)
 801eb46:	d011      	beq.n	801eb6c <noteOn+0x6c>
                if (currentPreset == Rhodes)
 801eb48:	2811      	cmp	r0, #17
 801eb4a:	d04a      	beq.n	801ebe2 <noteOn+0xe2>
                else if (currentPreset == ClassicSynth)
 801eb4c:	2810      	cmp	r0, #16
 801eb4e:	d078      	beq.n	801ec42 <noteOn+0x142>
                else if (currentPreset == SamplerKeyboard)
 801eb50:	2806      	cmp	r0, #6
 801eb52:	d12d      	bne.n	801ebb0 <noteOn+0xb0>
                    if ((key >= LOWEST_SAMPLER_KEY) && key < (LOWEST_SAMPLER_KEY + NUM_SAMPLER_KEYS))
 801eb54:	f1a4 0624 	sub.w	r6, r4, #36	; 0x24
 801eb58:	2e30      	cmp	r6, #48	; 0x30
 801eb5a:	f240 8094 	bls.w	801ec86 <noteOn+0x186>
                setLED_2(1);
 801eb5e:	2001      	movs	r0, #1
        }
 801eb60:	ecbd 8b02 	vpop	{d8}
 801eb64:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
 801eb68:	f7f6 beb0 	b.w	80158cc <setLED_2>
                    if (autotuneLock)
 801eb6c:	f240 5220 	movw	r2, #1312	; 0x520
 801eb70:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801eb74:	6812      	ldr	r2, [r2, #0]
 801eb76:	b982      	cbnz	r2, 801eb9a <noteOn+0x9a>
 801eb78:	b2ea      	uxtb	r2, r5
                    tSimplePoly_noteOn(&poly, key, velocity);
 801eb7a:	f247 5020 	movw	r0, #29984	; 0x7520
 801eb7e:	4621      	mov	r1, r4
 801eb80:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801eb84:	f009 fb1a 	bl	80281bc <tSimplePoly_noteOn>
                setLED_2(1);
 801eb88:	2001      	movs	r0, #1
        }
 801eb8a:	ecbd 8b02 	vpop	{d8}
 801eb8e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
                setLED_2(1);
 801eb92:	f7f6 be9b 	b.w	80158cc <setLED_2>
                noteOff(key, velocity);
 801eb96:	f7ff bed7 	b.w	801e948 <noteOff>
                        lockArray[key%12]++;
 801eb9a:	f240 51a8 	movw	r1, #1448	; 0x5a8
 801eb9e:	b2ea      	uxtb	r2, r5
 801eba0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 801eba4:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
 801eba8:	3001      	adds	r0, #1
 801ebaa:	f841 0023 	str.w	r0, [r1, r3, lsl #2]
 801ebae:	e7e4      	b.n	801eb7a <noteOn+0x7a>
                else if (currentPreset == LivingStringSynth)
 801ebb0:	280f      	cmp	r0, #15
 801ebb2:	b2ea      	uxtb	r2, r5
 801ebb4:	d1e1      	bne.n	801eb7a <noteOn+0x7a>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801ebb6:	f247 5020 	movw	r0, #29984	; 0x7520
 801ebba:	4621      	mov	r1, r4
 801ebbc:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ebc0:	f009 fafc 	bl	80281bc <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801ebc4:	2800      	cmp	r0, #0
 801ebc6:	dbca      	blt.n	801eb5e <noteOn+0x5e>
                        tADSR4_on(&pluckEnvs[whichVoice], velocity * 0.0078125f);
 801ebc8:	f247 4308 	movw	r3, #29704	; 0x7408
 801ebcc:	ee00 5a10 	vmov	s0, r5
 801ebd0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ebd4:	eeba 0aec 	vcvt.f32.s32	s0, s0, #7
 801ebd8:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801ebdc:	f006 fe88 	bl	80258f0 <tADSR4_on>
 801ebe0:	e7bd      	b.n	801eb5e <noteOn+0x5e>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801ebe2:	f247 5020 	movw	r0, #29984	; 0x7520
 801ebe6:	b2ea      	uxtb	r2, r5
 801ebe8:	4621      	mov	r1, r4
 801ebea:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ebee:	f009 fae5 	bl	80281bc <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801ebf2:	1e07      	subs	r7, r0, #0
 801ebf4:	dbb3      	blt.n	801eb5e <noteOn+0x5e>
 801ebf6:	f247 5328 	movw	r3, #29992	; 0x7528
 801ebfa:	eb07 0647 	add.w	r6, r7, r7, lsl #1
                            tADSR4_on(&FM_envs[whichVoice][j], velocity * 0.0078125f);
 801ebfe:	ee08 5a10 	vmov	s16, r5
 801ec02:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ec06:	00f2      	lsls	r2, r6, #3
 801ec08:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
 801ec0c:	f103 0618 	add.w	r6, r3, #24
 801ec10:	18d5      	adds	r5, r2, r3
 801ec12:	4416      	add	r6, r2
 801ec14:	4628      	mov	r0, r5
 801ec16:	3504      	adds	r5, #4
 801ec18:	eeb0 0a48 	vmov.f32	s0, s16
 801ec1c:	f006 fe68 	bl	80258f0 <tADSR4_on>
                        for (int j = 0; j < 6; j++)
 801ec20:	42ae      	cmp	r6, r5
 801ec22:	d1f7      	bne.n	801ec14 <noteOn+0x114>
                        panValues[whichVoice] = key * 0.0078125; // divide by 128.0f
 801ec24:	f642 031c 	movw	r3, #10268	; 0x281c
 801ec28:	ee07 4a10 	vmov	s14, r4
 801ec2c:	eeba 7bec 	vcvt.f64.s32	d7, d7, #7
 801ec30:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ec34:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
 801ec38:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 801ec3c:	ed87 7a00 	vstr	s14, [r7]
 801ec40:	e78d      	b.n	801eb5e <noteOn+0x5e>
                    int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801ec42:	f247 5020 	movw	r0, #29984	; 0x7520
 801ec46:	4621      	mov	r1, r4
 801ec48:	b2ea      	uxtb	r2, r5
 801ec4a:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ec4e:	f009 fab5 	bl	80281bc <tSimplePoly_noteOn>
                    if (whichVoice >= 0)
 801ec52:	2800      	cmp	r0, #0
 801ec54:	db83      	blt.n	801eb5e <noteOn+0x5e>
                        tADSR4_on(&polyEnvs[whichVoice], velocity * 0.0078125f);
 801ec56:	ee08 5a10 	vmov	s16, r5
 801ec5a:	f247 639c 	movw	r3, #30364	; 0x769c
 801ec5e:	0084      	lsls	r4, r0, #2
 801ec60:	eeba 8aec 	vcvt.f32.s32	s16, s16, #7
 801ec64:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ec68:	1918      	adds	r0, r3, r4
 801ec6a:	eeb0 0a48 	vmov.f32	s0, s16
 801ec6e:	f006 fe3f 	bl	80258f0 <tADSR4_on>
                        tADSR4_on(&polyFiltEnvs[whichVoice], velocity * 0.0078125f);
 801ec72:	f641 7048 	movw	r0, #8008	; 0x1f48
 801ec76:	eeb0 0a48 	vmov.f32	s0, s16
 801ec7a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801ec7e:	4420      	add	r0, r4
 801ec80:	f006 fe36 	bl	80258f0 <tADSR4_on>
 801ec84:	e76b      	b.n	801eb5e <noteOn+0x5e>
                        int whichVoice = tSimplePoly_noteOn(&poly, key, velocity);
 801ec86:	f247 5020 	movw	r0, #29984	; 0x7520
 801ec8a:	4621      	mov	r1, r4
 801ec8c:	b2ea      	uxtb	r2, r5
 801ec8e:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801ec92:	f009 fa93 	bl	80281bc <tSimplePoly_noteOn>
                        if (whichVoice >= 0)
 801ec96:	2800      	cmp	r0, #0
 801ec98:	f6ff af61 	blt.w	801eb5e <noteOn+0x5e>
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801ec9c:	f248 1764 	movw	r7, #33124	; 0x8164
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
 801eca0:	f240 2420 	movw	r4, #544	; 0x220
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801eca4:	f2c2 0701 	movt	r7, #8193	; 0x2001
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
 801eca8:	f2c2 0400 	movt	r4, #8192	; 0x2000
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801ecac:	eb07 0086 	add.w	r0, r7, r6, lsl #2
                            currentSamplerKeyGlobal = key - LOWEST_SAMPLER_KEY;
 801ecb0:	6026      	str	r6, [r4, #0]
                            if (tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]) == 0)
 801ecb2:	f00b f9b5 	bl	802a020 <tBuffer_getRecordedLength>
 801ecb6:	b998      	cbnz	r0, 801ece0 <noteOn+0x1e0>
                                tBuffer_record(&keyBuff[currentSamplerKeyGlobal]);
 801ecb8:	6820      	ldr	r0, [r4, #0]
 801ecba:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 801ecbe:	f00b f999 	bl	8029ff4 <tBuffer_record>
                                newBuffer[currentSamplerKeyGlobal] = 1;
 801ecc2:	f242 7354 	movw	r3, #10068	; 0x2754
 801ecc6:	6822      	ldr	r2, [r4, #0]
 801ecc8:	2101      	movs	r1, #1
 801ecca:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ecce:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                            samplerKeyHeld[currentSamplerKeyGlobal] = 1;
 801ecd2:	f247 7338 	movw	r3, #30520	; 0x7738
 801ecd6:	2101      	movs	r1, #1
 801ecd8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801ecdc:	5499      	strb	r1, [r3, r2]
 801ecde:	e73e      	b.n	801eb5e <noteOn+0x5e>
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
 801ece0:	f243 532c 	movw	r3, #13612	; 0x352c
 801ece4:	6820      	ldr	r0, [r4, #0]
                                if (newBuffer[currentSamplerKeyGlobal])
 801ece6:	f242 7654 	movw	r6, #10068	; 0x2754
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
 801ecea:	f2c2 0300 	movt	r3, #8192	; 0x2000
                                if (newBuffer[currentSamplerKeyGlobal])
 801ecee:	f2c2 0600 	movt	r6, #8192	; 0x2000
                                tSampler_play(&keySampler[currentSamplerKeyGlobal]);
 801ecf2:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 801ecf6:	f00b fa53 	bl	802a1a0 <tSampler_play>
                                if (newBuffer[currentSamplerKeyGlobal])
 801ecfa:	6823      	ldr	r3, [r4, #0]
 801ecfc:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 801ed00:	b9fa      	cbnz	r2, 801ed42 <noteOn+0x242>
 801ed02:	0098      	lsls	r0, r3, #2
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
 801ed04:	f248 7194 	movw	r1, #34708	; 0x8794
 801ed08:	f04f 5370 	mov.w	r3, #1006632960	; 0x3c000000
 801ed0c:	ee07 5a90 	vmov	s15, r5
 801ed10:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 801ed14:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801ed18:	ee07 3a10 	vmov	s14, r3
 801ed1c:	eef8 6ae7 	vcvt.f32.s32	s13, s15
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
 801ed20:	f242 628c 	movw	r2, #9868	; 0x268c
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
 801ed24:	edd1 7a06 	vldr	s15, [r1, #24]
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
 801ed28:	f2c2 0200 	movt	r2, #8192	; 0x2000
                                float tempGain = (velocity * 0.0078125f * displayValues[6]) + (1.0f - displayValues[6]);
 801ed2c:	ee30 0a67 	vsub.f32	s0, s0, s15
 801ed30:	ee67 7a87 	vmul.f32	s15, s15, s14
                                tExpSmooth_setDest(&kSamplerGains[currentSamplerKeyGlobal], tempGain);
 801ed34:	4410      	add	r0, r2
 801ed36:	eea6 0aa7 	vfma.f32	s0, s13, s15
 801ed3a:	f007 f929 	bl	8025f90 <tExpSmooth_setDest>
 801ed3e:	6822      	ldr	r2, [r4, #0]
 801ed40:	e7c7      	b.n	801ecd2 <noteOn+0x1d2>
                                    int recordLength = tBuffer_getRecordedLength(&keyBuff[currentSamplerKeyGlobal]);
 801ed42:	eb07 0083 	add.w	r0, r7, r3, lsl #2
 801ed46:	f00b f96b 	bl	802a020 <tBuffer_getRecordedLength>
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801ed4a:	6823      	ldr	r3, [r4, #0]
 801ed4c:	f642 0280 	movw	r2, #10368	; 0x2880
 801ed50:	ee07 0a90 	vmov	s15, r0
 801ed54:	0098      	lsls	r0, r3, #2
                                    newBuffer[currentSamplerKeyGlobal] = 0;
 801ed56:	2100      	movs	r1, #0
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801ed58:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801ed5c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
                                    newBuffer[currentSamplerKeyGlobal] = 0;
 801ed60:	f846 1023 	str.w	r1, [r6, r3, lsl #2]
                                    samplePlayLengths[currentSamplerKeyGlobal] = recordLength;
 801ed64:	4402      	add	r2, r0
 801ed66:	edc2 7a00 	vstr	s15, [r2]
 801ed6a:	e7cb      	b.n	801ed04 <noteOn+0x204>

0801ed6c <pitchBend>:


        void pitchBend(int data)
        {
            pitchBendValue = (data - 8192) * 0.000244140625f;
 801ed6c:	f5a0 5300 	sub.w	r3, r0, #8192	; 0x2000
 801ed70:	ee07 3a90 	vmov	s15, r3
 801ed74:	f240 53d8 	movw	r3, #1496	; 0x5d8
 801ed78:	eefa 7aca 	vcvt.f32.s32	s15, s15, #12
 801ed7c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801ed80:	edc3 7a00 	vstr	s15, [r3]
        }
 801ed84:	4770      	bx	lr
 801ed86:	bf00      	nop

0801ed88 <sustainOff>:
 801ed88:	4770      	bx	lr
 801ed8a:	bf00      	nop

0801ed8c <sustainOn>:
        }

        void sustainOn()
        {

        }
 801ed8c:	4770      	bx	lr
 801ed8e:	bf00      	nop

0801ed90 <ssd1306_begin>:
uint8_t OLED_i2c_address;
uint8_t OLED_externalVCC;
I2C_HandleTypeDef* OLED_i2c_handle;

void ssd1306_begin(I2C_HandleTypeDef* hi2c, uint8_t vccstate, uint8_t i2caddr)
{
 801ed90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	OLED_i2c_address = i2caddr;
	OLED_externalVCC = vccstate;
	OLED_i2c_handle = hi2c;
 801ed94:	f248 6438 	movw	r4, #34360	; 0x8638
	OLED_i2c_address = i2caddr;
 801ed98:	f248 653c 	movw	r5, #34364	; 0x863c
	OLED_externalVCC = vccstate;
 801ed9c:	f248 6334 	movw	r3, #34356	; 0x8634
{
 801eda0:	4688      	mov	r8, r1
	OLED_i2c_handle = hi2c;
 801eda2:	f2c2 0401 	movt	r4, #8193	; 0x2001
	OLED_i2c_address = i2caddr;
 801eda6:	f2c2 0501 	movt	r5, #8193	; 0x2001
	OLED_externalVCC = vccstate;
 801edaa:	f2c2 0301 	movt	r3, #8193	; 0x2001
{
 801edae:	b084      	sub	sp, #16
	OLED_i2c_handle = hi2c;
 801edb0:	6020      	str	r0, [r4, #0]

	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801edb2:	2000      	movs	r0, #0
 801edb4:	f44f 7100 	mov.w	r1, #512	; 0x200
	OLED_i2c_address = i2caddr;
 801edb8:	702a      	strb	r2, [r5, #0]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801edba:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801edbe:	2201      	movs	r2, #1
	OLED_externalVCC = vccstate;
 801edc0:	f883 8000 	strb.w	r8, [r3]
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801edc4:	f7e7 fc38 	bl	8006638 <HAL_GPIO_WritePin>
	// VDD (3.3V) goes high at start, lets just chill for a ms
	HAL_Delay(1);
 801edc8:	2001      	movs	r0, #1

void ssd1306_command(uint8_t c) {
	// I2C
	//	uint8_t control = 0x00;   // Co = 0, D/C = 0

	uint8_t i2c_message[2] = {0,0};
 801edca:	ae04      	add	r6, sp, #16
	HAL_Delay(1);
 801edcc:	f7e1 fe3c 	bl	8000a48 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
 801edd0:	2000      	movs	r0, #0
 801edd2:	f44f 7100 	mov.w	r1, #512	; 0x200
	i2c_message[1] = c;
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801edd6:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_RESET); //PULL RESET LINE HIGH
 801edda:	4602      	mov	r2, r0
 801eddc:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801ede0:	f7e7 fc2a 	bl	8006638 <HAL_GPIO_WritePin>
	HAL_Delay(10);
 801ede4:	200a      	movs	r0, #10
 801ede6:	f7e1 fe2f 	bl	8000a48 <HAL_Delay>
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_9, GPIO_PIN_SET); //PULL RESET LINE HIGH
 801edea:	2000      	movs	r0, #0
 801edec:	2201      	movs	r2, #1
 801edee:	f44f 7100 	mov.w	r1, #512	; 0x200
 801edf2:	f6c5 0002 	movt	r0, #22530	; 0x5802
 801edf6:	f7e7 fc1f 	bl	8006638 <HAL_GPIO_WritePin>
	uint8_t i2c_message[2] = {0,0};
 801edfa:	f44f 432e 	mov.w	r3, #44544	; 0xae00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801edfe:	7829      	ldrb	r1, [r5, #0]
 801ee00:	6820      	ldr	r0, [r4, #0]
 801ee02:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801ee04:	f826 3d04 	strh.w	r3, [r6, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee08:	2302      	movs	r3, #2
 801ee0a:	4632      	mov	r2, r6
 801ee0c:	f7e8 fafa 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee10:	f44f 4c55 	mov.w	ip, #54528	; 0xd500
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee14:	7829      	ldrb	r1, [r5, #0]
 801ee16:	4632      	mov	r2, r6
 801ee18:	6820      	ldr	r0, [r4, #0]
 801ee1a:	2302      	movs	r3, #2
 801ee1c:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801ee1e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee22:	f7e8 faef 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee26:	f44f 4c00 	mov.w	ip, #32768	; 0x8000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee2a:	7829      	ldrb	r1, [r5, #0]
 801ee2c:	6820      	ldr	r0, [r4, #0]
 801ee2e:	4632      	mov	r2, r6
 801ee30:	9700      	str	r7, [sp, #0]
 801ee32:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ee34:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee38:	f7e8 fae4 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee3c:	f44f 4c28 	mov.w	ip, #43008	; 0xa800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee40:	7829      	ldrb	r1, [r5, #0]
 801ee42:	6820      	ldr	r0, [r4, #0]
 801ee44:	4632      	mov	r2, r6
 801ee46:	9700      	str	r7, [sp, #0]
 801ee48:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ee4a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee4e:	f7e8 fad9 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee52:	f44f 5cf8 	mov.w	ip, #7936	; 0x1f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee56:	7829      	ldrb	r1, [r5, #0]
 801ee58:	6820      	ldr	r0, [r4, #0]
 801ee5a:	4632      	mov	r2, r6
 801ee5c:	9700      	str	r7, [sp, #0]
 801ee5e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ee60:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee64:	f7e8 face 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee68:	f44f 4c53 	mov.w	ip, #54016	; 0xd300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee6c:	7829      	ldrb	r1, [r5, #0]
 801ee6e:	6820      	ldr	r0, [r4, #0]
 801ee70:	4632      	mov	r2, r6
 801ee72:	9700      	str	r7, [sp, #0]
 801ee74:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ee76:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee7a:	f7e8 fac3 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee7e:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee82:	7829      	ldrb	r1, [r5, #0]
 801ee84:	6820      	ldr	r0, [r4, #0]
 801ee86:	4632      	mov	r2, r6
 801ee88:	9700      	str	r7, [sp, #0]
 801ee8a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ee8c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee90:	f7e8 fab8 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ee94:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ee98:	7829      	ldrb	r1, [r5, #0]
 801ee9a:	6820      	ldr	r0, [r4, #0]
 801ee9c:	4632      	mov	r2, r6
 801ee9e:	9700      	str	r7, [sp, #0]
 801eea0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801eea2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eea6:	f7e8 faad 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801eeaa:	f44f 4c0d 	mov.w	ip, #36096	; 0x8d00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eeae:	7829      	ldrb	r1, [r5, #0]
 801eeb0:	6820      	ldr	r0, [r4, #0]
 801eeb2:	4632      	mov	r2, r6
 801eeb4:	9700      	str	r7, [sp, #0]
 801eeb6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801eeb8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eebc:	f7e8 faa2 	bl	8007404 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
 801eec0:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eec4:	6820      	ldr	r0, [r4, #0]
 801eec6:	7829      	ldrb	r1, [r5, #0]
 801eec8:	4632      	mov	r2, r6
	uint8_t i2c_message[2] = {0,0};
 801eeca:	bf0c      	ite	eq
 801eecc:	f44f 5c80 	moveq.w	ip, #4096	; 0x1000
 801eed0:	f44f 5ca0 	movne.w	ip, #5120	; 0x1400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eed4:	9700      	str	r7, [sp, #0]
 801eed6:	2302      	movs	r3, #2
 801eed8:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801eedc:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eee0:	f7e8 fa90 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801eee4:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eee8:	7829      	ldrb	r1, [r5, #0]
 801eeea:	4632      	mov	r2, r6
 801eeec:	6820      	ldr	r0, [r4, #0]
 801eeee:	2302      	movs	r3, #2
 801eef0:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801eef2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eef6:	f7e8 fa85 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801eefa:	f04f 0c00 	mov.w	ip, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eefe:	7829      	ldrb	r1, [r5, #0]
 801ef00:	6820      	ldr	r0, [r4, #0]
 801ef02:	4632      	mov	r2, r6
 801ef04:	9700      	str	r7, [sp, #0]
 801ef06:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef08:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef0c:	f7e8 fa7a 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef10:	f44f 4c21 	mov.w	ip, #41216	; 0xa100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef14:	7829      	ldrb	r1, [r5, #0]
 801ef16:	6820      	ldr	r0, [r4, #0]
 801ef18:	4632      	mov	r2, r6
 801ef1a:	9700      	str	r7, [sp, #0]
 801ef1c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef1e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef22:	f7e8 fa6f 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef26:	f44f 4c48 	mov.w	ip, #51200	; 0xc800
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef2a:	7829      	ldrb	r1, [r5, #0]
 801ef2c:	6820      	ldr	r0, [r4, #0]
 801ef2e:	4632      	mov	r2, r6
 801ef30:	9700      	str	r7, [sp, #0]
 801ef32:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef34:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef38:	f7e8 fa64 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef3c:	f44f 4c5a 	mov.w	ip, #55808	; 0xda00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef40:	7829      	ldrb	r1, [r5, #0]
 801ef42:	6820      	ldr	r0, [r4, #0]
 801ef44:	4632      	mov	r2, r6
 801ef46:	9700      	str	r7, [sp, #0]
 801ef48:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef4a:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef4e:	f7e8 fa59 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef52:	f44f 7c00 	mov.w	ip, #512	; 0x200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef56:	7829      	ldrb	r1, [r5, #0]
 801ef58:	6820      	ldr	r0, [r4, #0]
 801ef5a:	4632      	mov	r2, r6
 801ef5c:	9700      	str	r7, [sp, #0]
 801ef5e:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef60:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef64:	f7e8 fa4e 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef68:	f44f 4c01 	mov.w	ip, #33024	; 0x8100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef6c:	7829      	ldrb	r1, [r5, #0]
 801ef6e:	6820      	ldr	r0, [r4, #0]
 801ef70:	4632      	mov	r2, r6
 801ef72:	9700      	str	r7, [sp, #0]
 801ef74:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef76:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef7a:	f7e8 fa43 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef7e:	f44f 4c0f 	mov.w	ip, #36608	; 0x8f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef82:	7829      	ldrb	r1, [r5, #0]
 801ef84:	6820      	ldr	r0, [r4, #0]
 801ef86:	4632      	mov	r2, r6
 801ef88:	9700      	str	r7, [sp, #0]
 801ef8a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801ef8c:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef90:	f7e8 fa38 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801ef94:	f44f 4c59 	mov.w	ip, #55552	; 0xd900
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801ef98:	7829      	ldrb	r1, [r5, #0]
 801ef9a:	6820      	ldr	r0, [r4, #0]
 801ef9c:	4632      	mov	r2, r6
 801ef9e:	9700      	str	r7, [sp, #0]
 801efa0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801efa2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efa6:	f7e8 fa2d 	bl	8007404 <HAL_I2C_Master_Transmit>
	if (vccstate == SSD1306_EXTERNALVCC)
 801efaa:	f1b8 0f01 	cmp.w	r8, #1
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efae:	6820      	ldr	r0, [r4, #0]
 801efb0:	7829      	ldrb	r1, [r5, #0]
 801efb2:	4632      	mov	r2, r6
	uint8_t i2c_message[2] = {0,0};
 801efb4:	bf0c      	ite	eq
 801efb6:	f44f 5c08 	moveq.w	ip, #8704	; 0x2200
 801efba:	f44f 4c71 	movne.w	ip, #61696	; 0xf100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efbe:	9700      	str	r7, [sp, #0]
 801efc0:	2302      	movs	r3, #2
 801efc2:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801efc6:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efca:	f7e8 fa1b 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801efce:	f44f 4c5b 	mov.w	ip, #56064	; 0xdb00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efd2:	7829      	ldrb	r1, [r5, #0]
 801efd4:	4632      	mov	r2, r6
 801efd6:	6820      	ldr	r0, [r4, #0]
 801efd8:	2302      	movs	r3, #2
 801efda:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801efdc:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efe0:	f7e8 fa10 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801efe4:	f44f 4c80 	mov.w	ip, #16384	; 0x4000
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801efe8:	7829      	ldrb	r1, [r5, #0]
 801efea:	6820      	ldr	r0, [r4, #0]
 801efec:	4632      	mov	r2, r6
 801efee:	9700      	str	r7, [sp, #0]
 801eff0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801eff2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801eff6:	f7e8 fa05 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801effa:	f44f 4c24 	mov.w	ip, #41984	; 0xa400
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801effe:	7829      	ldrb	r1, [r5, #0]
 801f000:	6820      	ldr	r0, [r4, #0]
 801f002:	4632      	mov	r2, r6
 801f004:	9700      	str	r7, [sp, #0]
 801f006:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f008:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f00c:	f7e8 f9fa 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801f010:	f44f 4c26 	mov.w	ip, #42496	; 0xa600
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f014:	7829      	ldrb	r1, [r5, #0]
 801f016:	6820      	ldr	r0, [r4, #0]
 801f018:	4632      	mov	r2, r6
 801f01a:	9700      	str	r7, [sp, #0]
 801f01c:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f01e:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f022:	f7e8 f9ef 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801f026:	f44f 5c38 	mov.w	ip, #11776	; 0x2e00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f02a:	7829      	ldrb	r1, [r5, #0]
 801f02c:	6820      	ldr	r0, [r4, #0]
 801f02e:	4632      	mov	r2, r6
 801f030:	9700      	str	r7, [sp, #0]
 801f032:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f034:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f038:	f7e8 f9e4 	bl	8007404 <HAL_I2C_Master_Transmit>
 801f03c:	6820      	ldr	r0, [r4, #0]
 801f03e:	4632      	mov	r2, r6
 801f040:	7829      	ldrb	r1, [r5, #0]
	uint8_t i2c_message[2] = {0,0};
 801f042:	f44f 442f 	mov.w	r4, #44800	; 0xaf00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f046:	2302      	movs	r3, #2
 801f048:	9700      	str	r7, [sp, #0]
	uint8_t i2c_message[2] = {0,0};
 801f04a:	f8ad 400c 	strh.w	r4, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f04e:	f7e8 f9d9 	bl	8007404 <HAL_I2C_Master_Transmit>
}
 801f052:	b004      	add	sp, #16
 801f054:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0801f058 <ssd1306_display_full_buffer>:
  ssd1306_command(contrast);
}



void ssd1306_display_full_buffer(void) {
 801f058:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f05c:	f248 653c 	movw	r5, #34364	; 0x863c
void ssd1306_display_full_buffer(void) {
 801f060:	b085      	sub	sp, #20
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f062:	f248 6438 	movw	r4, #34360	; 0x8638
 801f066:	f44f 67fa 	mov.w	r7, #2000	; 0x7d0
	uint8_t i2c_message[2] = {0,0};
 801f06a:	ae04      	add	r6, sp, #16
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f06c:	f2c2 0501 	movt	r5, #8193	; 0x2001
 801f070:	f2c2 0401 	movt	r4, #8193	; 0x2001
	uint8_t i2c_message[2] = {0,0};
 801f074:	f44f 5304 	mov.w	r3, #8448	; 0x2100
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f078:	7829      	ldrb	r1, [r5, #0]
	uint8_t i2c_message[2] = {0,0};
 801f07a:	f04f 0900 	mov.w	r9, #0
 801f07e:	f826 3d04 	strh.w	r3, [r6, #-4]!
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f082:	2302      	movs	r3, #2
 801f084:	4632      	mov	r2, r6
 801f086:	6820      	ldr	r0, [r4, #0]
 801f088:	9700      	str	r7, [sp, #0]
//		HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17);
////		HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 17, 2000);
////		HAL_Delay(1);
//		i--;
//	}
	displayBufferChunk[0] = 0x40;
 801f08a:	f240 0800 	movw	r8, #0
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f08e:	f7e8 f9b9 	bl	8007404 <HAL_I2C_Master_Transmit>
 801f092:	7829      	ldrb	r1, [r5, #0]
 801f094:	4632      	mov	r2, r6
 801f096:	6820      	ldr	r0, [r4, #0]
 801f098:	9700      	str	r7, [sp, #0]
 801f09a:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f09c:	f8ad 900c 	strh.w	r9, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0a0:	f7e8 f9b0 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801f0a4:	f44f 4cfe 	mov.w	ip, #32512	; 0x7f00
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0a8:	7829      	ldrb	r1, [r5, #0]
 801f0aa:	4632      	mov	r2, r6
 801f0ac:	6820      	ldr	r0, [r4, #0]
 801f0ae:	9700      	str	r7, [sp, #0]
 801f0b0:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f0b2:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0b6:	f7e8 f9a5 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801f0ba:	f44f 5c08 	mov.w	ip, #8704	; 0x2200
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0be:	7829      	ldrb	r1, [r5, #0]
 801f0c0:	4632      	mov	r2, r6
 801f0c2:	6820      	ldr	r0, [r4, #0]
 801f0c4:	9700      	str	r7, [sp, #0]
 801f0c6:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f0c8:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0cc:	f7e8 f99a 	bl	8007404 <HAL_I2C_Master_Transmit>
 801f0d0:	7829      	ldrb	r1, [r5, #0]
 801f0d2:	4632      	mov	r2, r6
 801f0d4:	6820      	ldr	r0, [r4, #0]
 801f0d6:	2302      	movs	r3, #2
 801f0d8:	9700      	str	r7, [sp, #0]
	displayBufferChunk[0] = 0x40;
 801f0da:	f6c3 0800 	movt	r8, #14336	; 0x3800
	uint8_t i2c_message[2] = {0,0};
 801f0de:	f8ad 900c 	strh.w	r9, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0e2:	f7e8 f98f 	bl	8007404 <HAL_I2C_Master_Transmit>
	uint8_t i2c_message[2] = {0,0};
 801f0e6:	f44f 7c40 	mov.w	ip, #768	; 0x300
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0ea:	7829      	ldrb	r1, [r5, #0]
 801f0ec:	4632      	mov	r2, r6
 801f0ee:	6820      	ldr	r0, [r4, #0]
 801f0f0:	9700      	str	r7, [sp, #0]
 801f0f2:	2302      	movs	r3, #2
	uint8_t i2c_message[2] = {0,0};
 801f0f4:	f8ad c00c 	strh.w	ip, [sp, #12]
	HAL_I2C_Master_Transmit(OLED_i2c_handle, OLED_i2c_address, i2c_message, 2, 2000);
 801f0f8:	f7e8 f984 	bl	8007404 <HAL_I2C_Master_Transmit>
	displayBufferChunk[0] = 0x40;
 801f0fc:	4640      	mov	r0, r8
 801f0fe:	2340      	movs	r3, #64	; 0x40
 801f100:	f248 4134 	movw	r1, #33844	; 0x8434
 801f104:	f44f 7200 	mov.w	r2, #512	; 0x200
 801f108:	f800 3b01 	strb.w	r3, [r0], #1
 801f10c:	f2c2 0101 	movt	r1, #8193	; 0x2001
 801f110:	f00b fde8 	bl	802ace4 <memcpy>
	for (int i = 0; i < 512; i++)
	{
		displayBufferChunk[i+1] = buffer[i];
	}
	HAL_I2C_Master_Transmit_DMA(OLED_i2c_handle, OLED_i2c_address, displayBufferChunk, 513);
 801f114:	4642      	mov	r2, r8
 801f116:	7829      	ldrb	r1, [r5, #0]
 801f118:	f240 2301 	movw	r3, #513	; 0x201
 801f11c:	6820      	ldr	r0, [r4, #0]
 801f11e:	f7e8 fac3 	bl	80076a8 <HAL_I2C_Master_Transmit_DMA>
}
 801f122:	b005      	add	sp, #20
 801f124:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

0801f128 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801f128:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
 801f12c:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 801f12e:	f6c5 0302 	movt	r3, #22530	; 0x5802
 801f132:	f8d3 20f4 	ldr.w	r2, [r3, #244]	; 0xf4
 801f136:	f042 0202 	orr.w	r2, r2, #2
 801f13a:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
 801f13e:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 801f142:	f003 0302 	and.w	r3, r3, #2
 801f146:	9301      	str	r3, [sp, #4]
 801f148:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 801f14a:	b002      	add	sp, #8
 801f14c:	4770      	bx	lr
 801f14e:	bf00      	nop

0801f150 <NMI_Handler>:
void NMI_Handler(void)
{
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f150:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f154:	2001      	movs	r0, #1
 801f156:	2100      	movs	r1, #0
 801f158:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f15c:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f160:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f164:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f168:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
	}
  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 801f16c:	4770      	bx	lr
 801f16e:	bf00      	nop

0801f170 <MemManage_Handler>:
void MemManage_Handler(void)
{
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f170:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f174:	2001      	movs	r0, #1
 801f176:	2100      	movs	r1, #0
 801f178:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f17c:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f180:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f184:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f188:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801f18c:	e7fe      	b.n	801f18c <MemManage_Handler+0x1c>
 801f18e:	bf00      	nop

0801f190 <BusFault_Handler>:
 801f190:	b508      	push	{r3, lr}
 801f192:	f7ff ffed 	bl	801f170 <MemManage_Handler>
 801f196:	bf00      	nop

0801f198 <UsageFault_Handler>:
 801f198:	b508      	push	{r3, lr}
 801f19a:	f7ff ffe9 	bl	801f170 <MemManage_Handler>
 801f19e:	bf00      	nop

0801f1a0 <SVC_Handler>:
 801f1a0:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f1a4:	2001      	movs	r0, #1
 801f1a6:	2100      	movs	r1, #0
 801f1a8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f1ac:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f1b0:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f1b4:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f1b8:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801f1bc:	4770      	bx	lr
 801f1be:	bf00      	nop

0801f1c0 <DebugMon_Handler>:
 801f1c0:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f1c4:	2001      	movs	r0, #1
 801f1c6:	2100      	movs	r1, #0
 801f1c8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f1cc:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f1d0:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f1d4:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f1d8:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801f1dc:	4770      	bx	lr
 801f1de:	bf00      	nop

0801f1e0 <PendSV_Handler>:
 801f1e0:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f1e4:	2001      	movs	r0, #1
 801f1e6:	2100      	movs	r1, #0
 801f1e8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f1ec:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f1f0:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f1f4:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f1f8:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
 801f1fc:	4770      	bx	lr
 801f1fe:	bf00      	nop

0801f200 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f200:	f641 3390 	movw	r3, #7056	; 0x1b90
 801f204:	2001      	movs	r0, #1
 801f206:	2100      	movs	r1, #0
 801f208:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f20c:	e9c3 0104 	strd	r0, r1, [r3, #16]
 801f210:	e9c3 010a 	strd	r0, r1, [r3, #40]	; 0x28
 801f214:	e9c3 0110 	strd	r0, r1, [r3, #64]	; 0x40
 801f218:	e9c3 0116 	strd	r0, r1, [r3, #88]	; 0x58
	}
  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 801f21c:	f7e1 bc00 	b.w	8000a20 <HAL_IncTick>

0801f220 <DMA1_Stream1_IRQHandler>:
void DMA1_Stream1_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f220:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END DMA1_Stream1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 801f224:	f641 5040 	movw	r0, #7488	; 0x1d40
{
 801f228:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f22a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f22e:	2401      	movs	r4, #1
 801f230:	2500      	movs	r5, #0
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 801f232:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f236:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f23a:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f23e:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f242:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA1_Stream1_IRQn 1 */

  /* USER CODE END DMA1_Stream1_IRQn 1 */
}
 801f246:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_sai1_a);
 801f248:	f7e5 bbe4 	b.w	8004a14 <HAL_DMA_IRQHandler>

0801f24c <DMA1_Stream2_IRQHandler>:
void DMA1_Stream2_IRQHandler(void)
{
  /* USER CODE BEGIN DMA1_Stream2_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f24c:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END DMA1_Stream2_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 801f250:	f641 50b8 	movw	r0, #7608	; 0x1db8
{
 801f254:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f256:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f25a:	2401      	movs	r4, #1
 801f25c:	2500      	movs	r5, #0
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 801f25e:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f262:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f266:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f26a:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f26e:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA1_Stream2_IRQn 1 */

  /* USER CODE END DMA1_Stream2_IRQn 1 */
}
 801f272:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_sai1_b);
 801f274:	f7e5 bbce 	b.w	8004a14 <HAL_DMA_IRQHandler>

0801f278 <ADC_IRQHandler>:
void ADC_IRQHandler(void)
{
  /* USER CODE BEGIN ADC_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f278:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END ADC_IRQn 0 */
  HAL_ADC_IRQHandler(&hadc1);
 801f27c:	f240 7010 	movw	r0, #1808	; 0x710
{
 801f280:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f282:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f286:	2401      	movs	r4, #1
 801f288:	2500      	movs	r5, #0
  HAL_ADC_IRQHandler(&hadc1);
 801f28a:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f28e:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f292:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f296:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f29a:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN ADC_IRQn 1 */

  /* USER CODE END ADC_IRQn 1 */
}
 801f29e:	bc30      	pop	{r4, r5}
  HAL_ADC_IRQHandler(&hadc1);
 801f2a0:	f7e1 bd2c 	b.w	8000cfc <HAL_ADC_IRQHandler>

0801f2a4 <DMA2_Stream0_IRQHandler>:
void DMA2_Stream0_IRQHandler(void)
{
  /* USER CODE BEGIN DMA2_Stream0_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2a4:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END DMA2_Stream0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_adc1);
 801f2a8:	f240 7074 	movw	r0, #1908	; 0x774
{
 801f2ac:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2ae:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f2b2:	2401      	movs	r4, #1
 801f2b4:	2500      	movs	r5, #0
  HAL_DMA_IRQHandler(&hdma_adc1);
 801f2b6:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2ba:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f2be:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f2c2:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f2c6:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMA2_Stream0_IRQn 1 */

  /* USER CODE END DMA2_Stream0_IRQn 1 */
}
 801f2ca:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_adc1);
 801f2cc:	f7e5 bba2 	b.w	8004a14 <HAL_DMA_IRQHandler>

0801f2d0 <SAI1_IRQHandler>:
/**
  * @brief This function handles SAI1 global interrupt.
  */
uint8_t isItCalled = 0;
void SAI1_IRQHandler(void)
{
 801f2d0:	b538      	push	{r3, r4, r5, lr}
  /* USER CODE BEGIN SAI1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
	}
	isItCalled = 1;
 801f2d2:	f240 621c 	movw	r2, #1564	; 0x61c
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2d6:	f641 3390 	movw	r3, #7056	; 0x1b90
  /* USER CODE END SAI1_IRQn 0 */
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 801f2da:	f641 6030 	movw	r0, #7728	; 0x1e30
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2de:	2401      	movs	r4, #1
 801f2e0:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f2e4:	2500      	movs	r5, #0
	isItCalled = 1;
 801f2e6:	f2c2 0200 	movt	r2, #8192	; 0x2000
 801f2ea:	2101      	movs	r1, #1
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 801f2ec:	f2c2 0000 	movt	r0, #8192	; 0x2000
	isItCalled = 1;
 801f2f0:	7011      	strb	r1, [r2, #0]
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f2f2:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f2f6:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f2fa:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f2fe:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  HAL_SAI_IRQHandler(&hsai_BlockA1);
 801f302:	f7ed fa1f 	bl	800c744 <HAL_SAI_IRQHandler>
  HAL_SAI_IRQHandler(&hsai_BlockB1);
 801f306:	f641 40a8 	movw	r0, #7336	; 0x1ca8
  /* USER CODE BEGIN SAI1_IRQn 1 */

  /* USER CODE END SAI1_IRQn 1 */
}
 801f30a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_SAI_IRQHandler(&hsai_BlockB1);
 801f30e:	f2c2 0000 	movt	r0, #8192	; 0x2000
 801f312:	f7ed ba17 	b.w	800c744 <HAL_SAI_IRQHandler>
 801f316:	bf00      	nop

0801f318 <I2C4_EV_IRQHandler>:
void I2C4_EV_IRQHandler(void)
{
  /* USER CODE BEGIN I2C4_EV_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f318:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END I2C4_EV_IRQn 0 */
  HAL_I2C_EV_IRQHandler(&hi2c4);
 801f31c:	f241 6048 	movw	r0, #5704	; 0x1648
{
 801f320:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f322:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f326:	2401      	movs	r4, #1
 801f328:	2500      	movs	r5, #0
  HAL_I2C_EV_IRQHandler(&hi2c4);
 801f32a:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f32e:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f332:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f336:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f33a:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN I2C4_EV_IRQn 1 */

  /* USER CODE END I2C4_EV_IRQn 1 */
}
 801f33e:	bc30      	pop	{r4, r5}
  HAL_I2C_EV_IRQHandler(&hi2c4);
 801f340:	f7e8 bad6 	b.w	80078f0 <HAL_I2C_EV_IRQHandler>

0801f344 <I2C4_ER_IRQHandler>:
void I2C4_ER_IRQHandler(void)
{
  /* USER CODE BEGIN I2C4_ER_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f344:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END I2C4_ER_IRQn 0 */
  HAL_I2C_ER_IRQHandler(&hi2c4);
 801f348:	f241 6048 	movw	r0, #5704	; 0x1648
{
 801f34c:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f34e:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f352:	2401      	movs	r4, #1
 801f354:	2500      	movs	r5, #0
  HAL_I2C_ER_IRQHandler(&hi2c4);
 801f356:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f35a:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f35e:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f362:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f366:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN I2C4_ER_IRQn 1 */

  /* USER CODE END I2C4_ER_IRQn 1 */
}
 801f36a:	bc30      	pop	{r4, r5}
  HAL_I2C_ER_IRQHandler(&hi2c4);
 801f36c:	f7e9 bb46 	b.w	80089fc <HAL_I2C_ER_IRQHandler>

0801f370 <OTG_FS_IRQHandler>:
void OTG_FS_IRQHandler(void)
{
  /* USER CODE BEGIN OTG_FS_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f370:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END OTG_FS_IRQn 0 */
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 801f374:	f249 10dc 	movw	r0, #37340	; 0x91dc
{
 801f378:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f37a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f37e:	2401      	movs	r4, #1
 801f380:	2500      	movs	r5, #0
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 801f382:	f2c2 0001 	movt	r0, #8193	; 0x2001
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f386:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f38a:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f38e:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f392:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN OTG_FS_IRQn 1 */

  /* USER CODE END OTG_FS_IRQn 1 */
}
 801f396:	bc30      	pop	{r4, r5}
  HAL_HCD_IRQHandler(&hhcd_USB_OTG_FS);
 801f398:	f7e7 ba8c 	b.w	80068b4 <HAL_HCD_IRQHandler>

0801f39c <DMAMUX1_OVR_IRQHandler>:
void DMAMUX1_OVR_IRQHandler(void)
{
  /* USER CODE BEGIN DMAMUX1_OVR_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f39c:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END DMAMUX1_OVR_IRQn 0 */
  // Handle DMA2_Stream0
  HAL_DMAEx_MUX_IRQHandler(&hdma_adc1);
 801f3a0:	f240 7074 	movw	r0, #1908	; 0x774
{
 801f3a4:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3a6:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f3aa:	2401      	movs	r4, #1
 801f3ac:	2500      	movs	r5, #0
  HAL_DMAEx_MUX_IRQHandler(&hdma_adc1);
 801f3ae:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3b2:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f3b6:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f3ba:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f3be:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN DMAMUX1_OVR_IRQn 1 */

  /* USER CODE END DMAMUX1_OVR_IRQn 1 */
}
 801f3c2:	bc30      	pop	{r4, r5}
  HAL_DMAEx_MUX_IRQHandler(&hdma_adc1);
 801f3c4:	f7e6 ba10 	b.w	80057e8 <HAL_DMAEx_MUX_IRQHandler>

0801f3c8 <BDMA_Channel0_IRQHandler>:
void BDMA_Channel0_IRQHandler(void)
{
  /* USER CODE BEGIN BDMA_Channel0_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3c8:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END BDMA_Channel0_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c4_rx);
 801f3cc:	f241 60e0 	movw	r0, #5856	; 0x16e0
{
 801f3d0:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3d2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f3d6:	2401      	movs	r4, #1
 801f3d8:	2500      	movs	r5, #0
  HAL_DMA_IRQHandler(&hdma_i2c4_rx);
 801f3da:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3de:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f3e2:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f3e6:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f3ea:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN BDMA_Channel0_IRQn 1 */

  /* USER CODE END BDMA_Channel0_IRQn 1 */
}
 801f3ee:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_i2c4_rx);
 801f3f0:	f7e5 bb10 	b.w	8004a14 <HAL_DMA_IRQHandler>

0801f3f4 <BDMA_Channel1_IRQHandler>:
void BDMA_Channel1_IRQHandler(void)
{
  /* USER CODE BEGIN BDMA_Channel1_IRQn 0 */
	for (int i = 0; i < 4; i++)
	{
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3f4:	f641 3390 	movw	r3, #7056	; 0x1b90
	}
  /* USER CODE END BDMA_Channel1_IRQn 0 */
  HAL_DMA_IRQHandler(&hdma_i2c4_tx);
 801f3f8:	f241 50d0 	movw	r0, #5584	; 0x15d0
{
 801f3fc:	b430      	push	{r4, r5}
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f3fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 801f402:	2401      	movs	r4, #1
 801f404:	2500      	movs	r5, #0
  HAL_DMA_IRQHandler(&hdma_i2c4_tx);
 801f406:	f2c2 0000 	movt	r0, #8192	; 0x2000
		cycleCountVals[i][2] = 1; //set these bits to make sure cycle counting that is happening is invalidated during a USB interrupt (so it's not counted toward the averaged and min max totals)
 801f40a:	e9c3 4504 	strd	r4, r5, [r3, #16]
 801f40e:	e9c3 450a 	strd	r4, r5, [r3, #40]	; 0x28
 801f412:	e9c3 4510 	strd	r4, r5, [r3, #64]	; 0x40
 801f416:	e9c3 4516 	strd	r4, r5, [r3, #88]	; 0x58
  /* USER CODE BEGIN BDMA_Channel1_IRQn 1 */

  /* USER CODE END BDMA_Channel1_IRQn 1 */
}
 801f41a:	bc30      	pop	{r4, r5}
  HAL_DMA_IRQHandler(&hdma_i2c4_tx);
 801f41c:	f7e5 bafa 	b.w	8004a14 <HAL_DMA_IRQHandler>

0801f420 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 801f420:	b470      	push	{r4, r5, r6}
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */

  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801f422:	f44f 446d 	mov.w	r4, #60672	; 0xed00
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= RCC_CR_HSION;
 801f426:	f44f 4388 	mov.w	r3, #17408	; 0x4400

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 801f42a:	2200      	movs	r2, #0

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 801f42c:	f64e 507f 	movw	r0, #60799	; 0xed7f
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801f430:	f2ce 0400 	movt	r4, #57344	; 0xe000
  RCC->CR |= RCC_CR_HSION;
 801f434:	f6c5 0302 	movt	r3, #22530	; 0x5802
  RCC->CR &= 0xEAF6ED7FU;
 801f438:	f6ce 20f6 	movt	r0, #60150	; 0xeaf6
  SCB->VTOR = FLASH_BANK2_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
#endif /* VECT_TAB_SRAM */

#else
  /* dual core CM7 or single core line */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801f43c:	f44f 5680 	mov.w	r6, #4096	; 0x1000
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801f440:	f8d4 5088 	ldr.w	r5, [r4, #136]	; 0x88
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801f444:	4611      	mov	r1, r2
 801f446:	f6c5 4600 	movt	r6, #23552	; 0x5c00
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801f44a:	f445 0570 	orr.w	r5, r5, #15728640	; 0xf00000
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801f44e:	f6cf 71ff 	movt	r1, #65535	; 0xffff
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 801f452:	f8c4 5088 	str.w	r5, [r4, #136]	; 0x88
  RCC->CR |= RCC_CR_HSION;
 801f456:	681c      	ldr	r4, [r3, #0]
 801f458:	f044 0401 	orr.w	r4, r4, #1
 801f45c:	601c      	str	r4, [r3, #0]
  RCC->CFGR = 0x00000000;
 801f45e:	611a      	str	r2, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
 801f460:	681c      	ldr	r4, [r3, #0]
 801f462:	4020      	ands	r0, r4
 801f464:	6018      	str	r0, [r3, #0]
  RCC->D1CFGR = 0x00000000;
 801f466:	619a      	str	r2, [r3, #24]
  RCC->D2CFGR = 0x00000000;
 801f468:	61da      	str	r2, [r3, #28]
  RCC->D3CFGR = 0x00000000;
 801f46a:	621a      	str	r2, [r3, #32]
  RCC->PLLCKSELR = 0x00000000;
 801f46c:	629a      	str	r2, [r3, #40]	; 0x28
  RCC->PLLCFGR = 0x00000000;
 801f46e:	62da      	str	r2, [r3, #44]	; 0x2c
  RCC->PLL1DIVR = 0x00000000;
 801f470:	631a      	str	r2, [r3, #48]	; 0x30
  RCC->PLL1FRACR = 0x00000000;
 801f472:	635a      	str	r2, [r3, #52]	; 0x34
  RCC->PLL2DIVR = 0x00000000;
 801f474:	639a      	str	r2, [r3, #56]	; 0x38
  RCC->PLL2FRACR = 0x00000000;
 801f476:	63da      	str	r2, [r3, #60]	; 0x3c
  RCC->PLL3DIVR = 0x00000000;
 801f478:	641a      	str	r2, [r3, #64]	; 0x40
  RCC->PLL3FRACR = 0x00000000;
 801f47a:	645a      	str	r2, [r3, #68]	; 0x44
  RCC->CR &= 0xFFFBFFFFU;
 801f47c:	6818      	ldr	r0, [r3, #0]
 801f47e:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
 801f482:	6018      	str	r0, [r3, #0]
  RCC->CIER = 0x00000000;
 801f484:	661a      	str	r2, [r3, #96]	; 0x60
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 801f486:	6833      	ldr	r3, [r6, #0]
 801f488:	4019      	ands	r1, r3
 801f48a:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
 801f48e:	d205      	bcs.n	801f49c <SystemInit+0x7c>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x000000001U;
 801f490:	f248 1308 	movw	r3, #33032	; 0x8108
 801f494:	2201      	movs	r2, #1
 801f496:	f2c5 1300 	movt	r3, #20736	; 0x5100
 801f49a:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address for cortex-M7 ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal D1 AXI-RAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 801f49c:	f44f 436d 	mov.w	r3, #60672	; 0xed00
 801f4a0:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 801f4a4:	f2ce 0300 	movt	r3, #57344	; 0xe000
 801f4a8:	609a      	str	r2, [r3, #8]
#endif

#endif /*DUAL_CORE && CORE_CM4*/

}
 801f4aa:	bc70      	pop	{r4, r5, r6}
 801f4ac:	4770      	bx	lr
 801f4ae:	bf00      	nop

0801f4b0 <MX_TIM3_Init>:
TIM_HandleTypeDef htim3;
TIM_HandleTypeDef htim4;

/* TIM3 init function */
void MX_TIM3_Init(void)
{
 801f4b0:	b530      	push	{r4, r5, lr}
  TIM_MasterConfigTypeDef sMasterConfig = {0};
  TIM_OC_InitTypeDef sConfigOC = {0};

  htim3.Instance = TIM3;
 801f4b2:	f248 6480 	movw	r4, #34432	; 0x8680
 801f4b6:	f44f 6280 	mov.w	r2, #1024	; 0x400
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801f4ba:	2300      	movs	r3, #0
{
 801f4bc:	b093      	sub	sp, #76	; 0x4c
  htim3.Instance = TIM3;
 801f4be:	f2c2 0401 	movt	r4, #8193	; 0x2001
  htim3.Init.Prescaler = 0;
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim3.Init.Period = 1024;
 801f4c2:	4611      	mov	r1, r2
  htim3.Instance = TIM3;
 801f4c4:	f2c4 0200 	movt	r2, #16384	; 0x4000
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801f4c8:	9303      	str	r3, [sp, #12]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 801f4ca:	4620      	mov	r0, r4
  htim3.Init.Period = 1024;
 801f4cc:	60e1      	str	r1, [r4, #12]
  htim3.Instance = TIM3;
 801f4ce:	6022      	str	r2, [r4, #0]
  htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801f4d0:	6123      	str	r3, [r4, #16]
  htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801f4d2:	61a3      	str	r3, [r4, #24]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801f4d4:	930b      	str	r3, [sp, #44]	; 0x2c
  htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
 801f4d6:	e9c4 3301 	strd	r3, r3, [r4, #4]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801f4da:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801f4de:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
 801f4e2:	e9cd 330e 	strd	r3, r3, [sp, #56]	; 0x38
 801f4e6:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
 801f4ea:	f7ee fc73 	bl	800ddd4 <HAL_TIM_PWM_Init>
 801f4ee:	bb98      	cbnz	r0, 801f558 <MX_TIM3_Init+0xa8>
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 801f4f0:	f248 6080 	movw	r0, #34432	; 0x8680
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801f4f4:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 801f4f6:	a903      	add	r1, sp, #12
 801f4f8:	f2c2 0001 	movt	r0, #8193	; 0x2001
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801f4fc:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801f4fe:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
 801f500:	f7ef fe12 	bl	800f128 <HAL_TIMEx_MasterConfigSynchronization>
 801f504:	bb28      	cbnz	r0, 801f552 <MX_TIM3_Init+0xa2>
  }
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
  sConfigOC.Pulse = 0;
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801f506:	f248 6080 	movw	r0, #34432	; 0x8680
  sConfigOC.Pulse = 0;
 801f50a:	2300      	movs	r3, #0
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801f50c:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801f50e:	a90b      	add	r1, sp, #44	; 0x2c
 801f510:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801f514:	2204      	movs	r2, #4
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801f516:	930d      	str	r3, [sp, #52]	; 0x34
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801f518:	930f      	str	r3, [sp, #60]	; 0x3c
  sConfigOC.Pulse = 0;
 801f51a:	e9cd 530b 	strd	r5, r3, [sp, #44]	; 0x2c
  if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801f51e:	f7ef fafb 	bl	800eb18 <HAL_TIM_PWM_ConfigChannel>
 801f522:	b108      	cbz	r0, 801f528 <MX_TIM3_Init+0x78>
  {
    Error_Handler();
 801f524:	f7f6 f99e 	bl	8015864 <Error_Handler>
}
void HAL_TIM_MspPostInit(TIM_HandleTypeDef* timHandle)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(timHandle->Instance==TIM3)
 801f528:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801f52c:	6821      	ldr	r1, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f52e:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
 801f530:	f2c4 0200 	movt	r2, #16384	; 0x4000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f534:	930a      	str	r3, [sp, #40]	; 0x28
  if(timHandle->Instance==TIM3)
 801f536:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f538:	e9cd 3306 	strd	r3, r3, [sp, #24]
 801f53c:	e9cd 3308 	strd	r3, r3, [sp, #32]
  if(timHandle->Instance==TIM3)
 801f540:	d02a      	beq.n	801f598 <MX_TIM3_Init+0xe8>

  /* USER CODE BEGIN TIM3_MspPostInit 1 */

  /* USER CODE END TIM3_MspPostInit 1 */
  }
  else if(timHandle->Instance==TIM4)
 801f542:	f44f 6300 	mov.w	r3, #2048	; 0x800
 801f546:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801f54a:	4299      	cmp	r1, r3
 801f54c:	d007      	beq.n	801f55e <MX_TIM3_Init+0xae>
}
 801f54e:	b013      	add	sp, #76	; 0x4c
 801f550:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 801f552:	f7f6 f987 	bl	8015864 <Error_Handler>
 801f556:	e7d6      	b.n	801f506 <MX_TIM3_Init+0x56>
    Error_Handler();
 801f558:	f7f6 f984 	bl	8015864 <Error_Handler>
 801f55c:	e7c8      	b.n	801f4f0 <MX_TIM3_Init+0x40>
  {
  /* USER CODE BEGIN TIM4_MspPostInit 0 */

  /* USER CODE END TIM4_MspPostInit 0 */
  
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f55e:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    PB6     ------> TIM4_CH1
    PB7     ------> TIM4_CH2
    PB8     ------> TIM4_CH3 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f562:	2402      	movs	r4, #2
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f564:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801f568:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f56c:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f570:	a906      	add	r1, sp, #24
 801f572:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f576:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801f57a:	4322      	orrs	r2, r4
 801f57c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801f580:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801f584:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f586:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f588:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 801f58a:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f58c:	9302      	str	r3, [sp, #8]
 801f58e:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f590:	f7e6 fca8 	bl	8005ee4 <HAL_GPIO_Init>
}
 801f594:	b013      	add	sp, #76	; 0x4c
 801f596:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f598:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f59c:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f59e:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801f5a2:	2520      	movs	r5, #32
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f5a4:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f5a8:	a906      	add	r1, sp, #24
 801f5aa:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f5ae:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801f5b2:	4322      	orrs	r2, r4
 801f5b4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801f5b8:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801f5bc:	9506      	str	r5, [sp, #24]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f5be:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f5c0:	9407      	str	r4, [sp, #28]
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 801f5c2:	940a      	str	r4, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f5c4:	9301      	str	r3, [sp, #4]
 801f5c6:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f5c8:	f7e6 fc8c 	bl	8005ee4 <HAL_GPIO_Init>
}
 801f5cc:	b013      	add	sp, #76	; 0x4c
 801f5ce:	bd30      	pop	{r4, r5, pc}

0801f5d0 <MX_TIM4_Init>:
{
 801f5d0:	b530      	push	{r4, r5, lr}
  htim4.Instance = TIM4;
 801f5d2:	f248 6440 	movw	r4, #34368	; 0x8640
 801f5d6:	f44f 6200 	mov.w	r2, #2048	; 0x800
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801f5da:	2300      	movs	r3, #0
{
 801f5dc:	b097      	sub	sp, #92	; 0x5c
  htim4.Instance = TIM4;
 801f5de:	f2c2 0401 	movt	r4, #8193	; 0x2001
  htim4.Init.Period = 1024;
 801f5e2:	f44f 6180 	mov.w	r1, #1024	; 0x400
  htim4.Instance = TIM4;
 801f5e6:	f2c4 0200 	movt	r2, #16384	; 0x4000
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801f5ea:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 801f5ec:	4620      	mov	r0, r4
  htim4.Init.Period = 1024;
 801f5ee:	60e1      	str	r1, [r4, #12]
  htim4.Instance = TIM4;
 801f5f0:	6022      	str	r2, [r4, #0]
  htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 801f5f2:	6123      	str	r3, [r4, #16]
  htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 801f5f4:	61a3      	str	r3, [r4, #24]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801f5f6:	9303      	str	r3, [sp, #12]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801f5f8:	930f      	str	r3, [sp, #60]	; 0x3c
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801f5fa:	9309      	str	r3, [sp, #36]	; 0x24
  htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
 801f5fc:	e9c4 3301 	strd	r3, r3, [r4, #4]
  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 801f600:	e9cd 3307 	strd	r3, r3, [sp, #28]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 801f604:	e9cd 3304 	strd	r3, r3, [sp, #16]
  TIM_OC_InitTypeDef sConfigOC = {0};
 801f608:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
 801f60c:	e9cd 3312 	strd	r3, r3, [sp, #72]	; 0x48
 801f610:	e9cd 3314 	strd	r3, r3, [sp, #80]	; 0x50
  if (HAL_TIM_Base_Init(&htim4) != HAL_OK)
 801f614:	f7ee fa90 	bl	800db38 <HAL_TIM_Base_Init>
 801f618:	2800      	cmp	r0, #0
 801f61a:	d166      	bne.n	801f6ea <MX_TIM4_Init+0x11a>
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801f61c:	f248 6040 	movw	r0, #34368	; 0x8640
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801f620:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801f624:	a906      	add	r1, sp, #24
 801f626:	f2c2 0001 	movt	r0, #8193	; 0x2001
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 801f62a:	9306      	str	r3, [sp, #24]
  if (HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig) != HAL_OK)
 801f62c:	f7ee fe4c 	bl	800e2c8 <HAL_TIM_ConfigClockSource>
 801f630:	2800      	cmp	r0, #0
 801f632:	d157      	bne.n	801f6e4 <MX_TIM4_Init+0x114>
  if (HAL_TIM_PWM_Init(&htim4) != HAL_OK)
 801f634:	f248 6040 	movw	r0, #34368	; 0x8640
 801f638:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801f63c:	f7ee fbca 	bl	800ddd4 <HAL_TIM_PWM_Init>
 801f640:	2800      	cmp	r0, #0
 801f642:	d14c      	bne.n	801f6de <MX_TIM4_Init+0x10e>
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801f644:	f248 6040 	movw	r0, #34368	; 0x8640
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801f648:	2300      	movs	r3, #0
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801f64a:	a903      	add	r1, sp, #12
 801f64c:	f2c2 0001 	movt	r0, #8193	; 0x2001
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 801f650:	9303      	str	r3, [sp, #12]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 801f652:	9305      	str	r3, [sp, #20]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig) != HAL_OK)
 801f654:	f7ef fd68 	bl	800f128 <HAL_TIMEx_MasterConfigSynchronization>
 801f658:	2800      	cmp	r0, #0
 801f65a:	d13d      	bne.n	801f6d8 <MX_TIM4_Init+0x108>
  sConfigOC.Pulse = 0;
 801f65c:	2300      	movs	r3, #0
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801f65e:	f248 6040 	movw	r0, #34368	; 0x8640
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801f662:	2560      	movs	r5, #96	; 0x60
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801f664:	a90f      	add	r1, sp, #60	; 0x3c
 801f666:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801f66a:	461a      	mov	r2, r3
  sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 801f66c:	9313      	str	r3, [sp, #76]	; 0x4c
  sConfigOC.OCMode = TIM_OCMODE_PWM1;
 801f66e:	950f      	str	r5, [sp, #60]	; 0x3c
  sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 801f670:	e9cd 3310 	strd	r3, r3, [sp, #64]	; 0x40
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 801f674:	f7ef fa50 	bl	800eb18 <HAL_TIM_PWM_ConfigChannel>
 801f678:	bb58      	cbnz	r0, 801f6d2 <MX_TIM4_Init+0x102>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
 801f67a:	f248 6040 	movw	r0, #34368	; 0x8640
 801f67e:	2204      	movs	r2, #4
 801f680:	a90f      	add	r1, sp, #60	; 0x3c
 801f682:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801f686:	f7ef fa47 	bl	800eb18 <HAL_TIM_PWM_ConfigChannel>
 801f68a:	b9f8      	cbnz	r0, 801f6cc <MX_TIM4_Init+0xfc>
  if (HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
 801f68c:	f248 6040 	movw	r0, #34368	; 0x8640
 801f690:	a90f      	add	r1, sp, #60	; 0x3c
 801f692:	2208      	movs	r2, #8
 801f694:	f2c2 0001 	movt	r0, #8193	; 0x2001
 801f698:	f7ef fa3e 	bl	800eb18 <HAL_TIM_PWM_ConfigChannel>
 801f69c:	b108      	cbz	r0, 801f6a2 <MX_TIM4_Init+0xd2>
    Error_Handler();
 801f69e:	f7f6 f8e1 	bl	8015864 <Error_Handler>
  if(timHandle->Instance==TIM3)
 801f6a2:	f44f 6280 	mov.w	r2, #1024	; 0x400
 801f6a6:	6821      	ldr	r1, [r4, #0]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f6a8:	2300      	movs	r3, #0
  if(timHandle->Instance==TIM3)
 801f6aa:	f2c4 0200 	movt	r2, #16384	; 0x4000
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f6ae:	930e      	str	r3, [sp, #56]	; 0x38
  if(timHandle->Instance==TIM3)
 801f6b0:	4291      	cmp	r1, r2
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 801f6b2:	e9cd 330a 	strd	r3, r3, [sp, #40]	; 0x28
 801f6b6:	e9cd 330c 	strd	r3, r3, [sp, #48]	; 0x30
  if(timHandle->Instance==TIM3)
 801f6ba:	d036      	beq.n	801f72a <MX_TIM4_Init+0x15a>
  else if(timHandle->Instance==TIM4)
 801f6bc:	f44f 6300 	mov.w	r3, #2048	; 0x800
 801f6c0:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801f6c4:	4299      	cmp	r1, r3
 801f6c6:	d013      	beq.n	801f6f0 <MX_TIM4_Init+0x120>
}
 801f6c8:	b017      	add	sp, #92	; 0x5c
 801f6ca:	bd30      	pop	{r4, r5, pc}
    Error_Handler();
 801f6cc:	f7f6 f8ca 	bl	8015864 <Error_Handler>
 801f6d0:	e7dc      	b.n	801f68c <MX_TIM4_Init+0xbc>
    Error_Handler();
 801f6d2:	f7f6 f8c7 	bl	8015864 <Error_Handler>
 801f6d6:	e7d0      	b.n	801f67a <MX_TIM4_Init+0xaa>
    Error_Handler();
 801f6d8:	f7f6 f8c4 	bl	8015864 <Error_Handler>
 801f6dc:	e7be      	b.n	801f65c <MX_TIM4_Init+0x8c>
    Error_Handler();
 801f6de:	f7f6 f8c1 	bl	8015864 <Error_Handler>
 801f6e2:	e7af      	b.n	801f644 <MX_TIM4_Init+0x74>
    Error_Handler();
 801f6e4:	f7f6 f8be 	bl	8015864 <Error_Handler>
 801f6e8:	e7a4      	b.n	801f634 <MX_TIM4_Init+0x64>
    Error_Handler();
 801f6ea:	f7f6 f8bb 	bl	8015864 <Error_Handler>
 801f6ee:	e795      	b.n	801f61c <MX_TIM4_Init+0x4c>
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f6f0:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f6f4:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f6f6:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801f6fa:	f44f 75e0 	mov.w	r5, #448	; 0x1c0
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f6fe:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f702:	a90a      	add	r1, sp, #40	; 0x28
 801f704:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f708:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801f70c:	4322      	orrs	r2, r4
 801f70e:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801f712:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7|GPIO_PIN_8;
 801f716:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f718:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f71a:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM4;
 801f71c:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f71e:	9302      	str	r3, [sp, #8]
 801f720:	9b02      	ldr	r3, [sp, #8]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f722:	f7e6 fbdf 	bl	8005ee4 <HAL_GPIO_Init>
}
 801f726:	b017      	add	sp, #92	; 0x5c
 801f728:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f72a:	f44f 4388 	mov.w	r3, #17408	; 0x4400
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f72e:	2402      	movs	r4, #2
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f730:	f44f 6080 	mov.w	r0, #1024	; 0x400
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801f734:	2520      	movs	r5, #32
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f736:	f6c5 0302 	movt	r3, #22530	; 0x5802
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f73a:	a90a      	add	r1, sp, #40	; 0x28
 801f73c:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f740:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 801f744:	4322      	orrs	r2, r4
 801f746:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 801f74a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_5;
 801f74e:	950a      	str	r5, [sp, #40]	; 0x28
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f750:	4023      	ands	r3, r4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801f752:	940b      	str	r4, [sp, #44]	; 0x2c
    GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 801f754:	940e      	str	r4, [sp, #56]	; 0x38
    __HAL_RCC_GPIOB_CLK_ENABLE();
 801f756:	9301      	str	r3, [sp, #4]
 801f758:	9b01      	ldr	r3, [sp, #4]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 801f75a:	f7e6 fbc3 	bl	8005ee4 <HAL_GPIO_Init>
}
 801f75e:	b017      	add	sp, #92	; 0x5c
 801f760:	bd30      	pop	{r4, r5, pc}
 801f762:	bf00      	nop

0801f764 <HAL_TIM_PWM_MspInit>:
  if(tim_pwmHandle->Instance==TIM3)
 801f764:	f44f 6380 	mov.w	r3, #1024	; 0x400
 801f768:	6802      	ldr	r2, [r0, #0]
 801f76a:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801f76e:	429a      	cmp	r2, r3
 801f770:	d000      	beq.n	801f774 <HAL_TIM_PWM_MspInit+0x10>
 801f772:	4770      	bx	lr
    __HAL_RCC_TIM3_CLK_ENABLE();
 801f774:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
 801f778:	b082      	sub	sp, #8
    __HAL_RCC_TIM3_CLK_ENABLE();
 801f77a:	f6c5 0302 	movt	r3, #22530	; 0x5802
 801f77e:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 801f782:	f042 0202 	orr.w	r2, r2, #2
 801f786:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 801f78a:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801f78e:	f003 0302 	and.w	r3, r3, #2
 801f792:	9301      	str	r3, [sp, #4]
 801f794:	9b01      	ldr	r3, [sp, #4]
}
 801f796:	b002      	add	sp, #8
 801f798:	4770      	bx	lr
 801f79a:	bf00      	nop

0801f79c <HAL_TIM_Base_MspInit>:
  if(tim_baseHandle->Instance==TIM4)
 801f79c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 801f7a0:	6802      	ldr	r2, [r0, #0]
 801f7a2:	f2c4 0300 	movt	r3, #16384	; 0x4000
 801f7a6:	429a      	cmp	r2, r3
 801f7a8:	d000      	beq.n	801f7ac <HAL_TIM_Base_MspInit+0x10>
 801f7aa:	4770      	bx	lr
    __HAL_RCC_TIM4_CLK_ENABLE();
 801f7ac:	f44f 4388 	mov.w	r3, #17408	; 0x4400
{
 801f7b0:	b082      	sub	sp, #8
    __HAL_RCC_TIM4_CLK_ENABLE();
 801f7b2:	f6c5 0302 	movt	r3, #22530	; 0x5802
 801f7b6:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 801f7ba:	f042 0204 	orr.w	r2, r2, #4
 801f7be:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
 801f7c2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	; 0xe8
 801f7c6:	f003 0304 	and.w	r3, r3, #4
 801f7ca:	9301      	str	r3, [sp, #4]
 801f7cc:	9b01      	ldr	r3, [sp, #4]
}
 801f7ce:	b002      	add	sp, #8
 801f7d0:	4770      	bx	lr
 801f7d2:	bf00      	nop

0801f7d4 <initModeNames>:
        VocodecPresetType currentPreset = (VocodecPresetType)0;
        VocodecPresetType previousPreset = PresetNil;
        uint8_t loadingPreset = 0;

        void initModeNames(void)
        {
 801f7d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            for (int i = 0; i < PresetNil; i++)
            {
                cvAddParam[i] = -1;
            }

            modeNames[Vocoder] = "VOCODER1";
 801f7d8:	f248 7710 	movw	r7, #34576	; 0x8710
        {
 801f7dc:	b08b      	sub	sp, #44	; 0x2c
            shortModeNames[Vocoder] = "VL";
            modeNamesDetails[Vocoder] = "LPC";
 801f7de:	f648 00f0 	movw	r0, #35056	; 0x88f0
                floatADCUI[i] = -1.0f;
 801f7e2:	f648 023c 	movw	r2, #34876	; 0x883c
            modeNames[Vocoder] = "VOCODER1";
 801f7e6:	f2c2 0701 	movt	r7, #8193	; 0x2001
                floatADCUI[i] = -1.0f;
 801f7ea:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 801f7ee:	f2c2 0201 	movt	r2, #8193	; 0x2001
                orderedParams[i] = i;
 801f7f2:	f248 7458 	movw	r4, #34648	; 0x8758
            modeNames[Vocoder] = "VOCODER1";
 801f7f6:	9702      	str	r7, [sp, #8]
            shortModeNames[Vocoder] = "VL";
 801f7f8:	f648 0780 	movw	r7, #34944	; 0x8880
                orderedParams[i] = i;
 801f7fc:	f44f 7b80 	mov.w	fp, #256	; 0x100
            modeNames[Vocoder] = "VOCODER1";
 801f800:	f64f 3ecc 	movw	lr, #64460	; 0xfbcc
            shortModeNames[Vocoder] = "VL";
 801f804:	f2c2 0701 	movt	r7, #8193	; 0x2001
                orderedParams[i] = i;
 801f808:	f2c2 0401 	movt	r4, #8193	; 0x2001
                floatADCUI[i] = -1.0f;
 801f80c:	edc2 7a00 	vstr	s15, [r2]
                orderedParams[i] = i;
 801f810:	f2c0 3b02 	movt	fp, #770	; 0x302
            shortModeNames[Vocoder] = "VL";
 801f814:	9700      	str	r7, [sp, #0]
            modeNamesDetails[Vocoder] = "LPC";
 801f816:	4607      	mov	r7, r0
            numPages[Vocoder] = 2;
            knobParamNames[Vocoder][0] = "VOLUME";
 801f818:	f64f 30e0 	movw	r0, #64480	; 0xfbe0
                floatADCUI[i] = -1.0f;
 801f81c:	edc2 7a01 	vstr	s15, [r2, #4]
            modeNamesDetails[Vocoder] = "LPC";
 801f820:	f2c2 0701 	movt	r7, #8193	; 0x2001
                floatADCUI[i] = -1.0f;
 801f824:	edc2 7a02 	vstr	s15, [r2, #8]
 801f828:	edc2 7a03 	vstr	s15, [r2, #12]
            modeNames[Vocoder] = "VOCODER1";
 801f82c:	f6c0 0e02 	movt	lr, #2050	; 0x802
            modeNamesDetails[Vocoder] = "LPC";
 801f830:	9701      	str	r7, [sp, #4]
            knobParamNames[Vocoder][1] = "WARP";
            knobParamNames[Vocoder][2] = "QUALITY";
 801f832:	f64f 37f0 	movw	r7, #64496	; 0xfbf0
                floatADCUI[i] = -1.0f;
 801f836:	edc2 7a04 	vstr	s15, [r2, #16]
            knobParamNames[Vocoder][0] = "VOLUME";
 801f83a:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[Vocoder][2] = "QUALITY";
 801f83e:	f6c0 0702 	movt	r7, #2050	; 0x802
                floatADCUI[i] = -1.0f;
 801f842:	edc2 7a05 	vstr	s15, [r2, #20]
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
            knobParamNames[Vocoder][8] = "PULSESHAPE";
            knobParamNames[Vocoder][9] = "";


            modeNames[VocoderCh] = "VOCODER2";
 801f846:	f64f 4c38 	movw	ip, #64568	; 0xfc38
            orderedParams[7] = ButtonB;
 801f84a:	2206      	movs	r2, #6
            knobParamNames[Vocoder][2] = "QUALITY";
 801f84c:	9705      	str	r7, [sp, #20]
            knobParamNames[Vocoder][5] = "BREATH";
 801f84e:	f64f 4710 	movw	r7, #64528	; 0xfc10
            knobParamNames[Vocoder][0] = "VOLUME";
 801f852:	9004      	str	r0, [sp, #16]
            modeNames[VocoderCh] = "VOCODER2";
 801f854:	f6c0 0c02 	movt	ip, #2050	; 0x802
            knobParamNames[Vocoder][5] = "BREATH";
 801f858:	f6c0 0702 	movt	r7, #2050	; 0x802
                orderedParams[i] = i;
 801f85c:	f8c4 b000 	str.w	fp, [r4]
            orderedParams[7] = ButtonB;
 801f860:	71e2      	strb	r2, [r4, #7]
                orderedParams[i] = i;
 801f862:	f04f 0b05 	mov.w	fp, #5
            knobParamNames[Vocoder][5] = "BREATH";
 801f866:	9708      	str	r7, [sp, #32]
            knobParamNames[Vocoder][6] = "TILT";
 801f868:	f64f 4718 	movw	r7, #64536	; 0xfc18
 801f86c:	f648 1138 	movw	r1, #35128	; 0x8938
            shortModeNames[Vocoder] = "VL";
 801f870:	f64f 36d8 	movw	r6, #64472	; 0xfbd8
            knobParamNames[Vocoder][6] = "TILT";
 801f874:	f6c0 0702 	movt	r7, #2050	; 0x802
            shortModeNames[VocoderCh] = "VC";
 801f878:	f64f 4a44 	movw	sl, #64580	; 0xfc44
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801f87c:	f64f 30f8 	movw	r0, #64504	; 0xfbf8
            knobParamNames[Vocoder][9] = "";
 801f880:	f64f 3248 	movw	r2, #64328	; 0xfb48
            knobParamNames[Vocoder][6] = "TILT";
 801f884:	9707      	str	r7, [sp, #28]
 801f886:	f2c2 0101 	movt	r1, #8193	; 0x2001
            modeNames[Vocoder] = "VOCODER1";
 801f88a:	9f02      	ldr	r7, [sp, #8]
            shortModeNames[Vocoder] = "VL";
 801f88c:	f6c0 0602 	movt	r6, #2050	; 0x802
                orderedParams[i] = i;
 801f890:	f884 b005 	strb.w	fp, [r4, #5]
            shortModeNames[VocoderCh] = "VC";
 801f894:	f6c0 0a02 	movt	sl, #2050	; 0x802
            modeNames[Vocoder] = "VOCODER1";
 801f898:	f8c7 e000 	str.w	lr, [r7]
                orderedParams[i] = i;
 801f89c:	f04f 0e04 	mov.w	lr, #4
            modeNames[VocoderCh] = "VOCODER2";
 801f8a0:	f8c7 c004 	str.w	ip, [r7, #4]
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801f8a4:	f6c0 0002 	movt	r0, #2050	; 0x802
            shortModeNames[Vocoder] = "VL";
 801f8a8:	9f00      	ldr	r7, [sp, #0]
            knobParamNames[Vocoder][9] = "";
 801f8aa:	f6c0 0202 	movt	r2, #2050	; 0x802
                orderedParams[i] = i;
 801f8ae:	f884 e004 	strb.w	lr, [r4, #4]
            modeNamesDetails[VocoderCh] = "CHANNEL";
 801f8b2:	f64f 4548 	movw	r5, #64584	; 0xfc48
            orderedParams[6] = ButtonA;
 801f8b6:	f884 b006 	strb.w	fp, [r4, #6]
 801f8ba:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801f8be:	9006      	str	r0, [sp, #24]
            modeNamesDetails[VocoderCh] = "CHANNEL";
 801f8c0:	f6c0 0502 	movt	r5, #2050	; 0x802
 801f8c4:	600c      	str	r4, [r1, #0]
            knobParamNames[Vocoder][0] = "VOLUME";
 801f8c6:	f648 1364 	movw	r3, #35172	; 0x8964
 801f8ca:	604c      	str	r4, [r1, #4]
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
 801f8cc:	f64f 4e20 	movw	lr, #64544	; 0xfc20
            knobParamNames[Vocoder][9] = "";
 801f8d0:	9203      	str	r2, [sp, #12]
            knobParamNames[Vocoder][0] = "VOLUME";
 801f8d2:	f2c2 0301 	movt	r3, #8193	; 0x2001
 801f8d6:	608c      	str	r4, [r1, #8]
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
 801f8d8:	f6c0 0e02 	movt	lr, #2050	; 0x802
 801f8dc:	60cc      	str	r4, [r1, #12]
            knobParamNames[Vocoder][1] = "WARP";
 801f8de:	f64f 38e8 	movw	r8, #64488	; 0xfbe8
 801f8e2:	820c      	strh	r4, [r1, #16]
            knobParamNames[Vocoder][4] = "NOISTHRESH";
 801f8e4:	f64f 4004 	movw	r0, #64516	; 0xfc04
            shortModeNames[Vocoder] = "VL";
 801f8e8:	603e      	str	r6, [r7, #0]
            knobParamNames[Vocoder][1] = "WARP";
 801f8ea:	f6c0 0802 	movt	r8, #2050	; 0x802
            shortModeNames[VocoderCh] = "VC";
 801f8ee:	f8c7 a004 	str.w	sl, [r7, #4]
            modeNamesDetails[Vocoder] = "LPC";
 801f8f2:	f64f 39dc 	movw	r9, #64476	; 0xfbdc
 801f8f6:	9f01      	ldr	r7, [sp, #4]
            knobParamNames[Vocoder][8] = "PULSESHAPE";
 801f8f8:	f64f 4c2c 	movw	ip, #64556	; 0xfc2c
            knobParamNames[Vocoder][0] = "VOLUME";
 801f8fc:	9a04      	ldr	r2, [sp, #16]
            knobParamNames[VocoderCh][6] = "PULSEWIDTH";
            knobParamNames[VocoderCh][7] = "PULSESHAPE";
            knobParamNames[VocoderCh][8] = "BREATH";
            knobParamNames[VocoderCh][9] = "SPEED";
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801f8fe:	f64f 4470 	movw	r4, #64624	; 0xfc70
            modeNamesDetails[VocoderCh] = "CHANNEL";
 801f902:	607d      	str	r5, [r7, #4]
            knobParamNames[Vocoder][4] = "NOISTHRESH";
 801f904:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801f908:	9d06      	ldr	r5, [sp, #24]
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
 801f90a:	f64f 4a64 	movw	sl, #64612	; 0xfc64
            knobParamNames[Vocoder][2] = "QUALITY";
 801f90e:	9905      	ldr	r1, [sp, #20]
            knobParamNames[Vocoder][8] = "PULSESHAPE";
 801f910:	f6c0 0c02 	movt	ip, #2050	; 0x802
            knobParamNames[Vocoder][3] = "SAWtoPULSE";
 801f914:	60dd      	str	r5, [r3, #12]
            modeNamesDetails[Vocoder] = "LPC";
 801f916:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[Vocoder][5] = "BREATH";
 801f91a:	9d08      	ldr	r5, [sp, #32]
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801f91c:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[Vocoder][0] = "VOLUME";
 801f920:	601a      	str	r2, [r3, #0]
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
 801f922:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[Vocoder][5] = "BREATH";
 801f926:	615d      	str	r5, [r3, #20]
            knobParamNames[VocoderCh][12] = "TILT";
            knobParamNames[VocoderCh][13] = "STEREO";
            knobParamNames[VocoderCh][14] = "BARKPULL";

            modeNames[Pitchshift] = "PITCHSHIFT";
 801f928:	f64f 468c 	movw	r6, #64652	; 0xfc8c
            knobParamNames[Vocoder][6] = "TILT";
 801f92c:	9d07      	ldr	r5, [sp, #28]
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
 801f92e:	f64f 4b50 	movw	fp, #64592	; 0xfc50
            knobParamNames[Vocoder][4] = "NOISTHRESH";
 801f932:	6118      	str	r0, [r3, #16]
            modeNames[Pitchshift] = "PITCHSHIFT";
 801f934:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[VocoderCh][4] = "NOISTHRESH";
 801f938:	6758      	str	r0, [r3, #116]	; 0x74
            shortModeNames[Pitchshift] = "PS";
            modeNamesDetails[Pitchshift] = "";
            numPages[Pitchshift] = 2;
            knobParamNames[Pitchshift][0] = "SHIFT";
            knobParamNames[Pitchshift][1] = "FINE";
 801f93a:	f64f 40a4 	movw	r0, #64676	; 0xfca4
            modeNamesDetails[Vocoder] = "LPC";
 801f93e:	f8c7 9000 	str.w	r9, [r7]
            knobParamNames[Pitchshift][0] = "SHIFT";
 801f942:	f64f 499c 	movw	r9, #64668	; 0xfc9c
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801f946:	9409      	str	r4, [sp, #36]	; 0x24
            knobParamNames[Pitchshift][1] = "FINE";
 801f948:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[Vocoder][1] = "WARP";
 801f94c:	f8c3 8004 	str.w	r8, [r3, #4]
            knobParamNames[VocoderCh][14] = "BARKPULL";
 801f950:	f64f 4480 	movw	r4, #64640	; 0xfc80
            knobParamNames[Vocoder][2] = "QUALITY";
 801f954:	6099      	str	r1, [r3, #8]
            shortModeNames[Pitchshift] = "PS";
 801f956:	f64f 4198 	movw	r1, #64664	; 0xfc98
            knobParamNames[Vocoder][8] = "PULSESHAPE";
 801f95a:	f8c3 c020 	str.w	ip, [r3, #32]
            knobParamNames[VocoderCh][14] = "BARKPULL";
 801f95e:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[VocoderCh][6] = "PULSEWIDTH";
 801f962:	f8c3 e07c 	str.w	lr, [r3, #124]	; 0x7c
            shortModeNames[Pitchshift] = "PS";
 801f966:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[VocoderCh][7] = "PULSESHAPE";
 801f96a:	f8c3 c080 	str.w	ip, [r3, #128]	; 0x80
            knobParamNames[Pitchshift][2] = "F AMT";
            knobParamNames[Pitchshift][3] = "FORMANT";
            knobParamNames[Pitchshift][4] = "RANGE";
 801f96e:	f64f 4cbc 	movw	ip, #64700	; 0xfcbc
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
 801f972:	f6c0 0b02 	movt	fp, #2050	; 0x802
            knobParamNames[Pitchshift][0] = "SHIFT";
 801f976:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[Pitchshift][4] = "RANGE";
 801f97a:	f6c0 0c02 	movt	ip, #2050	; 0x802
            knobParamNames[Vocoder][7] = "PULSEWIDTH";
 801f97e:	e9c3 5e06 	strd	r5, lr, [r3, #24]
            knobParamNames[Vocoder][9] = "";
 801f982:	9d03      	ldr	r5, [sp, #12]
            knobParamNames[Pitchshift][3] = "FORMANT";
 801f984:	f64f 4eb4 	movw	lr, #64692	; 0xfcb4
            knobParamNames[Vocoder][9] = "";
 801f988:	625d      	str	r5, [r3, #36]	; 0x24
            knobParamNames[Pitchshift][3] = "FORMANT";
 801f98a:	f6c0 0e02 	movt	lr, #2050	; 0x802
            knobParamNames[VocoderCh][5] = "SAWtoPULSE";
 801f98e:	9d06      	ldr	r5, [sp, #24]
 801f990:	679d      	str	r5, [r3, #120]	; 0x78
            knobParamNames[VocoderCh][8] = "BREATH";
 801f992:	9d08      	ldr	r5, [sp, #32]
            knobParamNames[VocoderCh][1] = "WARP";
 801f994:	e9c3 2819 	strd	r2, r8, [r3, #100]	; 0x64
            knobParamNames[VocoderCh][8] = "BREATH";
 801f998:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
            knobParamNames[Pitchshift][2] = "F AMT";
 801f99c:	f64f 48ac 	movw	r8, #64684	; 0xfcac
            knobParamNames[VocoderCh][2] = "QUALITY";
 801f9a0:	9a05      	ldr	r2, [sp, #20]
            knobParamNames[VocoderCh][12] = "TILT";
 801f9a2:	9d07      	ldr	r5, [sp, #28]
            knobParamNames[Pitchshift][2] = "F AMT";
 801f9a4:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[VocoderCh][2] = "QUALITY";
 801f9a8:	66da      	str	r2, [r3, #108]	; 0x6c
            knobParamNames[VocoderCh][12] = "TILT";
 801f9aa:	f8c3 5094 	str.w	r5, [r3, #148]	; 0x94
            knobParamNames[Pitchshift][5] = "OFFSET";
 801f9ae:	f64f 45c4 	movw	r5, #64708	; 0xfcc4
            modeNamesDetails[Pitchshift] = "";
 801f9b2:	9a03      	ldr	r2, [sp, #12]
            knobParamNames[VocoderCh][10] = "BANDSQUISH";
 801f9b4:	f8c3 a08c 	str.w	sl, [r3, #140]	; 0x8c
            knobParamNames[VocoderCh][13] = "STEREO";
 801f9b8:	f64f 4a78 	movw	sl, #64632	; 0xfc78
            knobParamNames[Pitchshift][5] = "OFFSET";
 801f9bc:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[Pitchshift][8] = "";
            knobParamNames[Pitchshift][9] = "";

            modeNames[AutotuneMono] = "AUTOTUNE";
            shortModeNames[AutotuneMono] = "NT";
            modeNamesDetails[AutotuneMono] = "";
 801f9c0:	60fa      	str	r2, [r7, #12]
            modeNamesDetails[Pitchshift] = "";
 801f9c2:	60ba      	str	r2, [r7, #8]
            knobParamNames[Pitchshift][6] = "";
 801f9c4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
            knobParamNames[Pitchshift][9] = "";
 801f9c8:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
            knobParamNames[Pitchshift][1] = "FINE";
 801f9cc:	f8c3 00cc 	str.w	r0, [r3, #204]	; 0xcc
            knobParamNames[VocoderCh][13] = "STEREO";
 801f9d0:	4650      	mov	r0, sl
            knobParamNames[Pitchshift][5] = "OFFSET";
 801f9d2:	9506      	str	r5, [sp, #24]
            knobParamNames[AutotuneMono][2] = "SPEED";
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";


            modeNames[AutotunePoly] = "HARMONIZE";
 801f9d4:	f64f 5a04 	movw	sl, #64772	; 0xfd04
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801f9d8:	9d09      	ldr	r5, [sp, #36]	; 0x24
            knobParamNames[VocoderCh][13] = "STEREO";
 801f9da:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[Pitchshift][5] = "OFFSET";
 801f9de:	9f06      	ldr	r7, [sp, #24]
            modeNames[AutotunePoly] = "HARMONIZE";
 801f9e0:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[VocoderCh][13] = "STEREO";
 801f9e4:	9008      	str	r0, [sp, #32]
            knobParamNames[AutotuneMono][0] = "PICKINESS";
 801f9e6:	f64f 40d8 	movw	r0, #64728	; 0xfcd8
            knobParamNames[VocoderCh][11] = "BANDOFF";
 801f9ea:	f8c3 5090 	str.w	r5, [r3, #144]	; 0x90
            shortModeNames[AutotuneMono] = "NT";
 801f9ee:	f64f 45e8 	movw	r5, #64744	; 0xfce8
            knobParamNames[VocoderCh][14] = "BARKPULL";
 801f9f2:	f8c3 409c 	str.w	r4, [r3, #156]	; 0x9c
            knobParamNames[AutotuneMono][1] = "AMOUNT";
 801f9f6:	f64f 44e4 	movw	r4, #64740	; 0xfce4
            knobParamNames[Pitchshift][5] = "OFFSET";
 801f9fa:	f8c3 70dc 	str.w	r7, [r3, #220]	; 0xdc
            knobParamNames[AutotuneMono][0] = "PICKINESS";
 801f9fe:	f6c0 0002 	movt	r0, #2050	; 0x802
            modeNames[AutotuneMono] = "AUTOTUNE";
 801fa02:	9f02      	ldr	r7, [sp, #8]
            shortModeNames[AutotuneMono] = "NT";
 801fa04:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[AutotuneMono][1] = "AMOUNT";
 801fa08:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[VocoderCh][3] = "BANDWIDTH";
 801fa0c:	f8c3 b070 	str.w	fp, [r3, #112]	; 0x70
            knobParamNames[Pitchshift][0] = "SHIFT";
 801fa10:	f8c3 90c8 	str.w	r9, [r3, #200]	; 0xc8
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
 801fa14:	f64f 4bf8 	movw	fp, #64760	; 0xfcf8
            knobParamNames[Pitchshift][2] = "F AMT";
 801fa18:	f8c3 80d0 	str.w	r8, [r3, #208]	; 0xd0
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
 801fa1c:	f64f 48ec 	movw	r8, #64748	; 0xfcec
            knobParamNames[Pitchshift][3] = "FORMANT";
 801fa20:	f8c3 e0d4 	str.w	lr, [r3, #212]	; 0xd4
            shortModeNames[AutotunePoly] = "AT";
 801fa24:	f64f 5e10 	movw	lr, #64784	; 0xfd10
            knobParamNames[Pitchshift][4] = "RANGE";
 801fa28:	f8c3 c0d8 	str.w	ip, [r3, #216]	; 0xd8
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
 801fa2c:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[AutotuneMono][1] = "AMOUNT";
 801fa30:	f8c3 4130 	str.w	r4, [r3, #304]	; 0x130
            shortModeNames[AutotunePoly] = "AT";
 801fa34:	f6c0 0e02 	movt	lr, #2050	; 0x802
            knobParamNames[AutotunePoly][2] = "";
            knobParamNames[AutotunePoly][3] = "";
            knobParamNames[AutotunePoly][4] = "";


            modeNames[SamplerButtonPress] = "SAMPLER BP";
 801fa38:	f64f 5c14 	movw	ip, #64788	; 0xfd14
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";



            modeNames[SamplerKeyboard] = "KEYSAMPLER";
 801fa3c:	f64f 545c 	movw	r4, #64860	; 0xfd5c
            shortModeNames[SamplerKeyboard] = "KS";
 801fa40:	f64f 5968 	movw	r9, #64872	; 0xfd68
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
 801fa44:	f6c0 0b02 	movt	fp, #2050	; 0x802
            modeNames[SamplerButtonPress] = "SAMPLER BP";
 801fa48:	f6c0 0c02 	movt	ip, #2050	; 0x802
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
 801fa4c:	f6c0 0402 	movt	r4, #2050	; 0x802
            shortModeNames[SamplerKeyboard] = "KS";
 801fa50:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[Pitchshift][8] = "";
 801fa54:	e9c3 2239 	strd	r2, r2, [r3, #228]	; 0xe4
            modeNames[Pitchshift] = "PITCHSHIFT";
 801fa58:	9a02      	ldr	r2, [sp, #8]
 801fa5a:	6096      	str	r6, [r2, #8]
            modeNames[AutotuneMono] = "AUTOTUNE";
 801fa5c:	f64f 46cc 	movw	r6, #64716	; 0xfccc
            shortModeNames[Pitchshift] = "PS";
 801fa60:	9a00      	ldr	r2, [sp, #0]
            modeNames[AutotuneMono] = "AUTOTUNE";
 801fa62:	f6c0 0602 	movt	r6, #2050	; 0x802
            shortModeNames[Pitchshift] = "PS";
 801fa66:	6091      	str	r1, [r2, #8]
            knobParamNames[VocoderCh][9] = "SPEED";
 801fa68:	f64f 415c 	movw	r1, #64604	; 0xfc5c
            modeNames[AutotuneMono] = "AUTOTUNE";
 801fa6c:	60fe      	str	r6, [r7, #12]
            shortModeNames[SamplerButtonPress] = "SB";
 801fa6e:	f64f 5720 	movw	r7, #64800	; 0xfd20
            knobParamNames[VocoderCh][9] = "SPEED";
 801fa72:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[VocoderCh][13] = "STEREO";
 801fa76:	9e08      	ldr	r6, [sp, #32]
            shortModeNames[AutotuneMono] = "NT";
 801fa78:	60d5      	str	r5, [r2, #12]
            shortModeNames[SamplerButtonPress] = "SB";
 801fa7a:	f6c0 0702 	movt	r7, #2050	; 0x802
            knobParamNames[VocoderCh][9] = "SPEED";
 801fa7e:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801fa82:	f64f 5524 	movw	r5, #64804	; 0xfd24
            knobParamNames[VocoderCh][13] = "STEREO";
 801fa86:	f8c3 6098 	str.w	r6, [r3, #152]	; 0x98
            knobParamNames[AutotuneMono][0] = "PICKINESS";
 801fa8a:	f8c3 012c 	str.w	r0, [r3, #300]	; 0x12c
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801fa8e:	f6c0 0502 	movt	r5, #2050	; 0x802
            modeNamesDetails[AutotunePoly] = "";
 801fa92:	9a03      	ldr	r2, [sp, #12]
 801fa94:	9e01      	ldr	r6, [sp, #4]
            knobParamNames[AutotunePoly][1] = "";
 801fa96:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
            modeNamesDetails[AutotunePoly] = "";
 801fa9a:	6132      	str	r2, [r6, #16]
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801fa9c:	f64f 566c 	movw	r6, #64876	; 0xfd6c
            knobParamNames[AutotunePoly][2] = "";
 801faa0:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
            knobParamNames[AutotunePoly][3] = "";
 801faa4:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801faa8:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[AutotunePoly][4] = "";
 801faac:	f8c3 21a0 	str.w	r2, [r3, #416]	; 0x1a0
            knobParamNames[SamplerKeyboard][2] = "SPEED";
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
            knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
            knobParamNames[SamplerKeyboard][7] = "";
 801fab0:	f8c3 2274 	str.w	r2, [r3, #628]	; 0x274
            knobParamNames[SamplerKeyboard][8] = "";
 801fab4:	f8c3 2278 	str.w	r2, [r3, #632]	; 0x278
            knobParamNames[SamplerKeyboard][9] = "";
 801fab8:	f8c3 227c 	str.w	r2, [r3, #636]	; 0x27c
            shortModeNames[AutotunePoly] = "AT";
 801fabc:	9a00      	ldr	r2, [sp, #0]
            knobParamNames[AutotunePoly][0] = "PICKINESS";
 801fabe:	f8c3 0190 	str.w	r0, [r3, #400]	; 0x190
            shortModeNames[AutotunePoly] = "AT";
 801fac2:	f8c2 e010 	str.w	lr, [r2, #16]
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
 801fac6:	f64f 5e80 	movw	lr, #64896	; 0xfd80
            shortModeNames[SamplerButtonPress] = "SB";
 801faca:	9a00      	ldr	r2, [sp, #0]
            modeNames[AutotunePoly] = "HARMONIZE";
 801facc:	9802      	ldr	r0, [sp, #8]
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
 801face:	f6c0 0e02 	movt	lr, #2050	; 0x802
            shortModeNames[SamplerButtonPress] = "SB";
 801fad2:	6157      	str	r7, [r2, #20]
            knobParamNames[SamplerButtonPress][0] = "START";
 801fad4:	f64f 5734 	movw	r7, #64820	; 0xfd34
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801fad8:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[AutotuneMono][3] = "LEAPALLOW";
 801fada:	f8c3 8138 	str.w	r8, [r3, #312]	; 0x138
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
 801fade:	f64f 5878 	movw	r8, #64888	; 0xfd78
            modeNames[SamplerKeyboard] = "KEYSAMPLER";
 801fae2:	6184      	str	r4, [r0, #24]
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
 801fae4:	f64f 5444 	movw	r4, #64836	; 0xfd44
            modeNames[AutotunePoly] = "HARMONIZE";
 801fae8:	f8c0 a010 	str.w	sl, [r0, #16]
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
 801faec:	f6c0 0802 	movt	r8, #2050	; 0x802
            modeNames[SamplerButtonPress] = "SAMPLER BP";
 801faf0:	f8c0 c014 	str.w	ip, [r0, #20]


            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801faf4:	f64f 5c8c 	movw	ip, #64908	; 0xfd8c
            shortModeNames[SamplerKeyboard] = "KS";
 801faf8:	9800      	ldr	r0, [sp, #0]
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
 801fafa:	f6c0 0402 	movt	r4, #2050	; 0x802
            modeNamesDetails[SamplerButtonPress] = "PRESS BUTTON A";
 801fafe:	6155      	str	r5, [r2, #20]
            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801fb00:	f6c0 0c02 	movt	ip, #2050	; 0x802
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801fb04:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[SamplerButtonPress][0] = "START";
 801fb06:	f6c0 0702 	movt	r7, #2050	; 0x802
            knobParamNames[AutotuneMono][2] = "SPEED";
 801fb0a:	f8c3 1134 	str.w	r1, [r3, #308]	; 0x134
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
 801fb0e:	f64f 553c 	movw	r5, #64828	; 0xfd3c
            knobParamNames[SamplerButtonPress][2] = "SPEED";
 801fb12:	f8c3 11fc 	str.w	r1, [r3, #508]	; 0x1fc
            shortModeNames[SamplerAutoGrab] = "AS";
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
            numPages[SamplerAutoGrab] = 2;
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
 801fb16:	f64f 5aac 	movw	sl, #64940	; 0xfdac
            knobParamNames[SamplerKeyboard][2] = "SPEED";
 801fb1a:	f8c3 1260 	str.w	r1, [r3, #608]	; 0x260
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
 801fb1e:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[AutotuneMono][4] = "HYSTERESIS";
 801fb22:	f8c3 b13c 	str.w	fp, [r3, #316]	; 0x13c
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801fb26:	f64f 5b9c 	movw	fp, #64924	; 0xfd9c
            shortModeNames[SamplerKeyboard] = "KS";
 801fb2a:	f8c0 9018 	str.w	r9, [r0, #24]
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
 801fb2e:	f64f 5050 	movw	r0, #64848	; 0xfd50
            knobParamNames[SamplerKeyboard][4] = "LOOP ON";
 801fb32:	f8c3 8268 	str.w	r8, [r3, #616]	; 0x268
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801fb36:	f6c0 0b02 	movt	fp, #2050	; 0x802
            knobParamNames[SamplerKeyboard][6] = "VELO SENS";
 801fb3a:	f8c3 e270 	str.w	lr, [r3, #624]	; 0x270
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
 801fb3e:	f64f 59b8 	movw	r9, #64952	; 0xfdb8
            modeNamesDetails[SamplerKeyboard] = "KEY TO REC";
 801fb42:	6196      	str	r6, [r2, #24]
            shortModeNames[SamplerAutoGrab] = "AS";
 801fb44:	f64f 5698 	movw	r6, #64920	; 0xfd98
            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801fb48:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
            knobParamNames[SamplerAutoGrab][4] = "";
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
 801fb4a:	f64f 58c0 	movw	r8, #64960	; 0xfdc0
            knobParamNames[SamplerButtonPress][3] = "SPEEDMULT";
 801fb4e:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
            shortModeNames[SamplerAutoGrab] = "AS";
 801fb52:	f6c0 0602 	movt	r6, #2050	; 0x802
            modeNames[SamplerAutoGrab] = "AUTOSAMP";
 801fb56:	f8c2 c01c 	str.w	ip, [r2, #28]
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
 801fb5a:	f64f 5ecc 	movw	lr, #64972	; 0xfdcc
            knobParamNames[SamplerAutoGrab][4] = "";
 801fb5e:	9a03      	ldr	r2, [sp, #12]
            knobParamNames[SamplerAutoGrab][7] = "";
            knobParamNames[SamplerAutoGrab][8] = "";
            knobParamNames[SamplerAutoGrab][9] = "";

            modeNames[Distortion] = "DISTORT";
 801fb60:	f64f 5cd8 	movw	ip, #64984	; 0xfdd8
            knobParamNames[SamplerKeyboard][3] = "SPEEDMULT";
 801fb64:	f8c3 4264 	str.w	r4, [r3, #612]	; 0x264
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
 801fb68:	f6c0 0002 	movt	r0, #2050	; 0x802
            shortModeNames[SamplerAutoGrab] = "AS";
 801fb6c:	9c00      	ldr	r4, [sp, #0]
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
 801fb6e:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][4] = "";
 801fb72:	f8c3 22cc 	str.w	r2, [r3, #716]	; 0x2cc
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
 801fb76:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][7] = "";
 801fb7a:	f8c3 22d8 	str.w	r2, [r3, #728]	; 0x2d8
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
 801fb7e:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][8] = "";
 801fb82:	f8c3 22dc 	str.w	r2, [r3, #732]	; 0x2dc
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
 801fb86:	f6c0 0e02 	movt	lr, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][9] = "";
 801fb8a:	f8c3 22e0 	str.w	r2, [r3, #736]	; 0x2e0
            modeNames[Distortion] = "DISTORT";
 801fb8e:	f6c0 0c02 	movt	ip, #2050	; 0x802
            numPages[Wavefolder] = 1;
            knobParamNames[Wavefolder][0] = "GAIN";
            knobParamNames[Wavefolder][1] = "OFFSET1";
            knobParamNames[Wavefolder][2] = "OFFSET2";
            knobParamNames[Wavefolder][3] = "POST GAIN";
            knobParamNames[Wavefolder][4] = "";
 801fb92:	f8c3 2394 	str.w	r2, [r3, #916]	; 0x394
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801fb96:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[SamplerButtonPress][0] = "START";
 801fb98:	f8c3 71f4 	str.w	r7, [r3, #500]	; 0x1f4
            knobParamNames[SamplerKeyboard][0] = "START";
 801fb9c:	f8c3 7258 	str.w	r7, [r3, #600]	; 0x258
            shortModeNames[Distortion] = "DT";
 801fba0:	f64f 57e0 	movw	r7, #64992	; 0xfde0
            shortModeNames[SamplerAutoGrab] = "AS";
 801fba4:	61e6      	str	r6, [r4, #28]
            modeNamesDetails[Distortion] = "WITH EQ";
 801fba6:	f64f 56e4 	movw	r6, #64996	; 0xfde4

            modeNames[BitCrusher] = "BITCRUSH";
            shortModeNames[BitCrusher] = "BC";
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
            numPages[BitCrusher] = 2;
            knobParamNames[BitCrusher][0] = "QUALITY";
 801fbaa:	9c05      	ldr	r4, [sp, #20]
            shortModeNames[Distortion] = "DT";
 801fbac:	f6c0 0702 	movt	r7, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][2] = "SPEED";
 801fbb0:	f8c3 12c4 	str.w	r1, [r3, #708]	; 0x2c4
            modeNamesDetails[Distortion] = "WITH EQ";
 801fbb4:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[Distortion][1] = "TILT";
 801fbb8:	9907      	ldr	r1, [sp, #28]
            modeNamesDetails[SamplerAutoGrab] = "AUDIO TRIG'D";
 801fbba:	f8c2 b01c 	str.w	fp, [r2, #28]
            modeNames[Distortion] = "DISTORT";
 801fbbe:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[SamplerButtonPress][1] = "LENGTH";
 801fbc0:	f8c3 51f8 	str.w	r5, [r3, #504]	; 0x1f8
            knobParamNames[SamplerKeyboard][1] = "LENGTH";
 801fbc4:	f8c3 525c 	str.w	r5, [r3, #604]	; 0x25c
            knobParamNames[Distortion][2] = "MID GAIN";
 801fbc8:	f64f 55f8 	movw	r5, #65016	; 0xfdf8
            knobParamNames[SamplerButtonPress][4] = "CROSSFADE";
 801fbcc:	f8c3 0204 	str.w	r0, [r3, #516]	; 0x204
            knobParamNames[SamplerKeyboard][5] = "CROSSFADE";
 801fbd0:	f8c3 026c 	str.w	r0, [r3, #620]	; 0x26c
            knobParamNames[Distortion][2] = "MID GAIN";
 801fbd4:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][3] = "CROSSFADE";
 801fbd8:	f8c3 02c8 	str.w	r0, [r3, #712]	; 0x2c8
            knobParamNames[Distortion][3] = "MID FREQ";
 801fbdc:	f64f 6004 	movw	r0, #65028	; 0xfe04
            knobParamNames[Distortion][1] = "TILT";
 801fbe0:	f8c3 1324 	str.w	r1, [r3, #804]	; 0x324
            modeNames[Wavefolder] = "WAVEFOLD";
 801fbe4:	f64f 611c 	movw	r1, #65052	; 0xfe1c
            knobParamNames[BitCrusher][0] = "QUALITY";
 801fbe8:	f8c3 43e8 	str.w	r4, [r3, #1000]	; 0x3e8
            knobParamNames[Distortion][3] = "MID FREQ";
 801fbec:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][0] = "THRESHOLD";
 801fbf0:	f8c3 a2bc 	str.w	sl, [r3, #700]	; 0x2bc
            modeNames[Wavefolder] = "WAVEFOLD";
 801fbf4:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[SamplerAutoGrab][1] = "WINDOW";
 801fbf8:	f8c3 92c0 	str.w	r9, [r3, #704]	; 0x2c0
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801fbfc:	f64f 6a2c 	movw	sl, #65068	; 0xfe2c
            knobParamNames[SamplerAutoGrab][5] = "LEN RAND";
 801fc00:	f8c3 82d0 	str.w	r8, [r3, #720]	; 0x2d0
            shortModeNames[Wavefolder] = "WF";
 801fc04:	f64f 6428 	movw	r4, #65064	; 0xfe28
            knobParamNames[SamplerAutoGrab][6] = "SPD RAND";
 801fc08:	f8c3 e2d4 	str.w	lr, [r3, #724]	; 0x2d4
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801fc0c:	f6c0 0a02 	movt	sl, #2050	; 0x802
            modeNames[Distortion] = "DISTORT";
 801fc10:	f8c2 c020 	str.w	ip, [r2, #32]
            modeNames[BitCrusher] = "BITCRUSH";
 801fc14:	f64f 6c48 	movw	ip, #65096	; 0xfe48
            shortModeNames[Distortion] = "DT";
 801fc18:	9a00      	ldr	r2, [sp, #0]
            shortModeNames[Wavefolder] = "WF";
 801fc1a:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[Distortion][3] = "MID FREQ";
 801fc1e:	f8c3 032c 	str.w	r0, [r3, #812]	; 0x32c
            modeNames[BitCrusher] = "BITCRUSH";
 801fc22:	f6c0 0c02 	movt	ip, #2050	; 0x802
            shortModeNames[Distortion] = "DT";
 801fc26:	6217      	str	r7, [r2, #32]
 801fc28:	4693      	mov	fp, r2
            shortModeNames[BitCrusher] = "BC";
 801fc2a:	f64f 6754 	movw	r7, #65108	; 0xfe54
            modeNamesDetails[Distortion] = "WITH EQ";
 801fc2e:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[Distortion][0] = "PRE GAIN";
 801fc30:	f64f 50ec 	movw	r0, #65004	; 0xfdec
            knobParamNames[Distortion][2] = "MID GAIN";
 801fc34:	f8c3 5328 	str.w	r5, [r3, #808]	; 0x328
            modeNamesDetails[Distortion] = "WITH EQ";
 801fc38:	6216      	str	r6, [r2, #32]
            shortModeNames[BitCrusher] = "BC";
 801fc3a:	f6c0 0702 	movt	r7, #2050	; 0x802
            modeNames[Wavefolder] = "WAVEFOLD";
 801fc3e:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[Distortion][0] = "PRE GAIN";
 801fc40:	f6c0 0002 	movt	r0, #2050	; 0x802
            shortModeNames[BitCrusher] = "BC";
 801fc44:	9705      	str	r7, [sp, #20]
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
            knobParamNames[BitCrusher][2] = "ROUNDING";
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fc46:	f64f 677c 	movw	r7, #65148	; 0xfe7c
            modeNames[Wavefolder] = "WAVEFOLD";
 801fc4a:	6251      	str	r1, [r2, #36]	; 0x24
            knobParamNames[Wavefolder][0] = "GAIN";
 801fc4c:	f64f 59fc 	movw	r9, #65020	; 0xfdfc
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801fc50:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[Wavefolder][1] = "OFFSET1";
 801fc52:	f64f 6838 	movw	r8, #65080	; 0xfe38
            shortModeNames[Wavefolder] = "WF";
 801fc56:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
            knobParamNames[Wavefolder][2] = "OFFSET2";
 801fc5a:	f64f 6e40 	movw	lr, #65088	; 0xfe40
            modeNamesDetails[Wavefolder] = "SERGE STYLE";
 801fc5e:	f8c2 a024 	str.w	sl, [r2, #36]	; 0x24
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fc62:	46ba      	mov	sl, r7
            knobParamNames[BitCrusher][6] = "";
            knobParamNames[BitCrusher][7] = "";
            knobParamNames[BitCrusher][8] = "";
            knobParamNames[BitCrusher][9] = "";

            modeNames[Delay] = "DELAY";
 801fc64:	f64f 6788 	movw	r7, #65160	; 0xfe88
            modeNames[BitCrusher] = "BITCRUSH";
 801fc68:	9a02      	ldr	r2, [sp, #8]
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801fc6a:	f64f 6658 	movw	r6, #65112	; 0xfe58
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
 801fc6e:	f64f 6564 	movw	r5, #65124	; 0xfe64
            modeNames[Delay] = "DELAY";
 801fc72:	f6c0 0702 	movt	r7, #2050	; 0x802
            modeNames[BitCrusher] = "BITCRUSH";
 801fc76:	f8c2 c028 	str.w	ip, [r2, #40]	; 0x28
            knobParamNames[Distortion][4] = "POST GAIN";
 801fc7a:	f64f 6110 	movw	r1, #65040	; 0xfe10
            shortModeNames[BitCrusher] = "BC";
 801fc7e:	9a00      	ldr	r2, [sp, #0]
            modeNames[Delay] = "DELAY";
 801fc80:	9706      	str	r7, [sp, #24]
            knobParamNames[BitCrusher][2] = "ROUNDING";
 801fc82:	f64f 6470 	movw	r4, #65136	; 0xfe70
            shortModeNames[BitCrusher] = "BC";
 801fc86:	9f05      	ldr	r7, [sp, #20]
            knobParamNames[Distortion][4] = "POST GAIN";
 801fc88:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[Distortion][0] = "PRE GAIN";
 801fc8c:	f8c3 0320 	str.w	r0, [r3, #800]	; 0x320
            knobParamNames[Wavefolder][0] = "GAIN";
 801fc90:	f6c0 0902 	movt	r9, #2050	; 0x802
            shortModeNames[BitCrusher] = "BC";
 801fc94:	6297      	str	r7, [r2, #40]	; 0x28
            knobParamNames[Wavefolder][1] = "OFFSET1";
 801fc96:	f6c0 0802 	movt	r8, #2050	; 0x802
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801fc9a:	9a01      	ldr	r2, [sp, #4]
            knobParamNames[Wavefolder][2] = "OFFSET2";
 801fc9c:	f6c0 0e02 	movt	lr, #2050	; 0x802
            knobParamNames[BitCrusher][5] = "PRE GAIN";
 801fca0:	f8c3 03fc 	str.w	r0, [r3, #1020]	; 0x3fc
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801fca4:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[BitCrusher][6] = "";
 801fca8:	9803      	ldr	r0, [sp, #12]
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
 801fcaa:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[BitCrusher][2] = "ROUNDING";
 801fcae:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fcb2:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[Wavefolder][0] = "GAIN";
 801fcb6:	f8c3 9384 	str.w	r9, [r3, #900]	; 0x384
            shortModeNames[Delay] = "DL";
 801fcba:	f64f 6b90 	movw	fp, #65168	; 0xfe90
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fcbe:	f8cd a01c 	str.w	sl, [sp, #28]
            modeNamesDetails[Delay] = "STEREO";
            numPages[Delay] = 2;
            knobParamNames[Delay][0] = "DELAY_L";
 801fcc2:	f64f 6a94 	movw	sl, #65172	; 0xfe94
            knobParamNames[Wavefolder][1] = "OFFSET1";
 801fcc6:	f8c3 8388 	str.w	r8, [r3, #904]	; 0x388
            shortModeNames[Delay] = "DL";
 801fcca:	f6c0 0b02 	movt	fp, #2050	; 0x802
            knobParamNames[Wavefolder][2] = "OFFSET2";
 801fcce:	f8c3 e38c 	str.w	lr, [r3, #908]	; 0x38c
            knobParamNames[Delay][0] = "DELAY_L";
 801fcd2:	f6c0 0a02 	movt	sl, #2050	; 0x802
            modeNamesDetails[BitCrusher] = "AHH HALP ME";
 801fcd6:	6296      	str	r6, [r2, #40]	; 0x28
            knobParamNames[Delay][6] = "POST GAIN";
            knobParamNames[Delay][7] = "POST GAIN";
            knobParamNames[Delay][8] = "POST GAIN";
            knobParamNames[Delay][9] = "";

            modeNames[Reverb] = "REVERB1";
 801fcd8:	f64f 68c4 	movw	r8, #65220	; 0xfec4
            knobParamNames[BitCrusher][1] = "SAMP RATIO";
 801fcdc:	f8c3 53ec 	str.w	r5, [r3, #1004]	; 0x3ec
            knobParamNames[Delay][1] = "DELAY_R";
 801fce0:	f64f 699c 	movw	r9, #65180	; 0xfe9c
            knobParamNames[Distortion][4] = "POST GAIN";
 801fce4:	f8c3 1330 	str.w	r1, [r3, #816]	; 0x330
            modeNames[Reverb] = "REVERB1";
 801fce8:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[Wavefolder][3] = "POST GAIN";
 801fcec:	f8c3 1390 	str.w	r1, [r3, #912]	; 0x390
            shortModeNames[Reverb] = "RV";
            modeNamesDetails[Reverb] = "DATTORRO ALG";
            numPages[Reverb] = 1;
            knobParamNames[Reverb][0] = "SIZE";
            knobParamNames[Reverb][1] = "FB LOPASS";
 801fcf0:	f64f 6ee8 	movw	lr, #65256	; 0xfee8
            knobParamNames[BitCrusher][2] = "ROUNDING";
 801fcf4:	f8c3 43f0 	str.w	r4, [r3, #1008]	; 0x3f0
            knobParamNames[Reverb][2] = "IN HIPASS";
 801fcf8:	f64f 6cf4 	movw	ip, #65268	; 0xfef4
            knobParamNames[BitCrusher][4] = "POST GAIN";
 801fcfc:	f8c3 13f8 	str.w	r1, [r3, #1016]	; 0x3f8
            knobParamNames[Reverb][3] = "IN LOPASS";
 801fd00:	f64f 7700 	movw	r7, #65280	; 0xff00
            knobParamNames[BitCrusher][6] = "";
 801fd04:	f8c3 0400 	str.w	r0, [r3, #1024]	; 0x400
            knobParamNames[Reverb][4] = "FB GAIN";
 801fd08:	f64f 760c 	movw	r6, #65292	; 0xff0c
            knobParamNames[BitCrusher][7] = "";
 801fd0c:	f8c3 0404 	str.w	r0, [r3, #1028]	; 0x404
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801fd10:	f64f 65d0 	movw	r5, #65232	; 0xfed0
            knobParamNames[BitCrusher][8] = "";
 801fd14:	f8c3 0408 	str.w	r0, [r3, #1032]	; 0x408


            modeNames[Reverb2] = "REVERB2";
 801fd18:	f64f 7414 	movw	r4, #65300	; 0xff14
            knobParamNames[BitCrusher][9] = "";
 801fd1c:	f8c3 040c 	str.w	r0, [r3, #1036]	; 0x40c
            knobParamNames[Delay][1] = "DELAY_R";
 801fd20:	f6c0 0902 	movt	r9, #2050	; 0x802
            modeNamesDetails[Delay] = "STEREO";
 801fd24:	9808      	ldr	r0, [sp, #32]
            knobParamNames[Reverb][1] = "FB LOPASS";
 801fd26:	f6c0 0e02 	movt	lr, #2050	; 0x802
            knobParamNames[Delay][5] = "POST GAIN";
 801fd2a:	f8c3 1460 	str.w	r1, [r3, #1120]	; 0x460
            knobParamNames[Reverb][2] = "IN HIPASS";
 801fd2e:	f6c0 0c02 	movt	ip, #2050	; 0x802
            modeNamesDetails[Delay] = "STEREO";
 801fd32:	62d0      	str	r0, [r2, #44]	; 0x2c
            knobParamNames[Reverb][3] = "IN LOPASS";
 801fd34:	f6c0 0702 	movt	r7, #2050	; 0x802
            knobParamNames[Delay][9] = "";
 801fd38:	9a03      	ldr	r2, [sp, #12]
            knobParamNames[Reverb][4] = "FB GAIN";
 801fd3a:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[Delay][6] = "POST GAIN";
 801fd3e:	f8c3 1464 	str.w	r1, [r3, #1124]	; 0x464
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801fd42:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[Delay][7] = "POST GAIN";
 801fd46:	f8c3 1468 	str.w	r1, [r3, #1128]	; 0x468
            modeNames[Reverb2] = "REVERB2";
 801fd4a:	f6c0 0402 	movt	r4, #2050	; 0x802
            knobParamNames[Delay][8] = "POST GAIN";
 801fd4e:	f8c3 146c 	str.w	r1, [r3, #1132]	; 0x46c
            knobParamNames[Delay][2] = "HIGHPASS";
 801fd52:	f64f 61a4 	movw	r1, #65188	; 0xfea4
            knobParamNames[Delay][9] = "";
 801fd56:	f8c3 2470 	str.w	r2, [r3, #1136]	; 0x470
            shortModeNames[Reverb2] = "RV";
            modeNamesDetails[Reverb2] = "NREVERB ALG";
 801fd5a:	f64f 701c 	movw	r0, #65308	; 0xff1c
            knobParamNames[Delay][2] = "HIGHPASS";
 801fd5e:	460a      	mov	r2, r1
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fd60:	9907      	ldr	r1, [sp, #28]
            knobParamNames[Delay][0] = "DELAY_L";
 801fd62:	f8c3 a44c 	str.w	sl, [r3, #1100]	; 0x44c
            knobParamNames[Delay][4] = "FEEDBACK";
 801fd66:	f64f 6ab8 	movw	sl, #65208	; 0xfeb8
            knobParamNames[BitCrusher][3] = "OPERATION";
 801fd6a:	f8c3 13f4 	str.w	r1, [r3, #1012]	; 0x3f4
            knobParamNames[Delay][2] = "HIGHPASS";
 801fd6e:	4611      	mov	r1, r2
            modeNames[Delay] = "DELAY";
 801fd70:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[Delay][4] = "FEEDBACK";
 801fd72:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[Delay][2] = "HIGHPASS";
 801fd76:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[Delay][1] = "DELAY_R";
 801fd7a:	f8c3 9450 	str.w	r9, [r3, #1104]	; 0x450
            knobParamNames[Delay][4] = "FEEDBACK";
 801fd7e:	f8cd a020 	str.w	sl, [sp, #32]
            modeNamesDetails[Reverb2] = "NREVERB ALG";
 801fd82:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[Delay][2] = "HIGHPASS";
 801fd86:	9107      	str	r1, [sp, #28]
            shortModeNames[Reverb] = "RV";
 801fd88:	f64f 69cc 	movw	r9, #65228	; 0xfecc
            modeNames[Delay] = "DELAY";
 801fd8c:	9906      	ldr	r1, [sp, #24]
            knobParamNames[LivingString][6] = "PREP FORCE";
            knobParamNames[LivingString][7] = "LET RING";
            knobParamNames[LivingString][8] = "";
            knobParamNames[LivingString][9] = "";
            knobParamNames[LivingString][10] = "FREQ2";
            knobParamNames[LivingString][11] = "FREQ3";
 801fd8e:	f64f 7ab0 	movw	sl, #65456	; 0xffb0
            knobParamNames[Reverb][1] = "FB LOPASS";
 801fd92:	f8c3 e4b4 	str.w	lr, [r3, #1204]	; 0x4b4
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
 801fd96:	f64f 7e28 	movw	lr, #65320	; 0xff28
            modeNames[Delay] = "DELAY";
 801fd9a:	62d1      	str	r1, [r2, #44]	; 0x2c
            knobParamNames[Delay][3] = "LOWPASS";
 801fd9c:	f64f 61b0 	movw	r1, #65200	; 0xfeb0
            shortModeNames[Delay] = "DL";
 801fda0:	9a00      	ldr	r2, [sp, #0]
            shortModeNames[Reverb] = "RV";
 801fda2:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[Delay][3] = "LOWPASS";
 801fda6:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[Reverb][2] = "IN HIPASS";
 801fdaa:	f8c3 c4b8 	str.w	ip, [r3, #1208]	; 0x4b8
            shortModeNames[Delay] = "DL";
 801fdae:	f8c2 b02c 	str.w	fp, [r2, #44]	; 0x2c
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
 801fdb2:	f64f 7c34 	movw	ip, #65332	; 0xff34
            modeNames[Reverb] = "REVERB1";
 801fdb6:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[LivingString][12] = "FREQ4";
 801fdb8:	f64f 7bb8 	movw	fp, #65464	; 0xffb8
            knobParamNames[Delay][3] = "LOWPASS";
 801fdbc:	9105      	str	r1, [sp, #20]
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
 801fdbe:	f6c0 0e02 	movt	lr, #2050	; 0x802
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801fdc2:	9901      	ldr	r1, [sp, #4]
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
 801fdc4:	f6c0 0c02 	movt	ip, #2050	; 0x802
            modeNames[Reverb] = "REVERB1";
 801fdc8:	f8c2 8030 	str.w	r8, [r2, #48]	; 0x30
            knobParamNames[Reverb][0] = "SIZE";
 801fdcc:	f64f 68e0 	movw	r8, #65248	; 0xfee0
            modeNames[Reverb2] = "REVERB2";
 801fdd0:	9a02      	ldr	r2, [sp, #8]
            knobParamNames[LivingString][11] = "FREQ3";
 801fdd2:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[Reverb][3] = "IN LOPASS";
 801fdd6:	f8c3 74bc 	str.w	r7, [r3, #1212]	; 0x4bc
            knobParamNames[LivingString][0] = "FREQ1";
 801fdda:	f64f 7758 	movw	r7, #65368	; 0xff58
            knobParamNames[Reverb][4] = "FB GAIN";
 801fdde:	f8c3 64c0 	str.w	r6, [r3, #1216]	; 0x4c0
            knobParamNames[Reverb][0] = "SIZE";
 801fde2:	f6c0 0802 	movt	r8, #2050	; 0x802
            modeNamesDetails[Reverb] = "DATTORRO ALG";
 801fde6:	630d      	str	r5, [r1, #48]	; 0x30
            knobParamNames[LivingString][0] = "FREQ1";
 801fde8:	f6c0 0702 	movt	r7, #2050	; 0x802
            modeNames[Reverb2] = "REVERB2";
 801fdec:	6354      	str	r4, [r2, #52]	; 0x34
            knobParamNames[LivingString][13] = "FREQ5";
 801fdee:	f64f 72c0 	movw	r2, #65472	; 0xffc0
            knobParamNames[Delay][3] = "LOWPASS";
 801fdf2:	9c05      	ldr	r4, [sp, #20]
            knobParamNames[LivingString][10] = "FREQ2";
 801fdf4:	f64f 75a8 	movw	r5, #65448	; 0xffa8
            knobParamNames[LivingString][13] = "FREQ5";
 801fdf8:	f6c0 0202 	movt	r2, #2050	; 0x802
            modeNamesDetails[Reverb2] = "NREVERB ALG";
 801fdfc:	6348      	str	r0, [r1, #52]	; 0x34
            knobParamNames[Delay][3] = "LOWPASS";
 801fdfe:	f8c3 4458 	str.w	r4, [r3, #1112]	; 0x458
            knobParamNames[LivingString][10] = "FREQ2";
 801fe02:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[Delay][2] = "HIGHPASS";
 801fe06:	9907      	ldr	r1, [sp, #28]
            knobParamNames[LivingString][4] = "PICK POS";
 801fe08:	f64f 7678 	movw	r6, #65400	; 0xff78
            knobParamNames[Reverb2][1] = "LOWPASS";
 801fe0c:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
            knobParamNames[LivingString][12] = "FREQ4";
 801fe10:	f6c0 0b02 	movt	fp, #2050	; 0x802
            knobParamNames[LivingString][8] = "";
 801fe14:	9c03      	ldr	r4, [sp, #12]
            knobParamNames[LivingString][4] = "PICK POS";
 801fe16:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[LivingString][13] = "FREQ5";
 801fe1a:	9206      	str	r2, [sp, #24]
            knobParamNames[Delay][4] = "FEEDBACK";
 801fe1c:	9808      	ldr	r0, [sp, #32]
            knobParamNames[Delay][2] = "HIGHPASS";
 801fe1e:	f8c3 1454 	str.w	r1, [r3, #1108]	; 0x454
            knobParamNames[LivingString][8] = "";
 801fe22:	f8c3 4598 	str.w	r4, [r3, #1432]	; 0x598
            knobParamNames[Reverb2][2] = "HIGHPASS";
 801fe26:	9907      	ldr	r1, [sp, #28]
            knobParamNames[LivingString][9] = "";
 801fe28:	f8c3 459c 	str.w	r4, [r3, #1436]	; 0x59c
            knobParamNames[LivingString][13] = "FREQ5";
 801fe2c:	9c06      	ldr	r4, [sp, #24]
            knobParamNames[Delay][4] = "FEEDBACK";
 801fe2e:	f8c3 045c 	str.w	r0, [r3, #1116]	; 0x45c
            knobParamNames[LivingString][14] = "FREQ6";
 801fe32:	f64f 70c8 	movw	r0, #65480	; 0xffc8
            knobParamNames[Reverb][0] = "SIZE";
 801fe36:	f8c3 84b0 	str.w	r8, [r3, #1200]	; 0x4b0
            knobParamNames[Reverb2][0] = "SIZE";
 801fe3a:	f8c3 8514 	str.w	r8, [r3, #1300]	; 0x514

            modeNames[LivingStringSynth] = "STRING2";
            shortModeNames[LivingStringSynth] = "SS";
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
            numPages[LivingStringSynth] = 2;
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
 801fe3e:	f64f 78e8 	movw	r8, #65512	; 0xffe8
            knobParamNames[Reverb2][2] = "HIGHPASS";
 801fe42:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
 801fe46:	f64f 71f4 	movw	r1, #65524	; 0xfff4
            knobParamNames[LivingString][0] = "FREQ1";
 801fe4a:	f8c3 7578 	str.w	r7, [r3, #1400]	; 0x578
            shortModeNames[LivingString] = "LS";
 801fe4e:	f64f 7748 	movw	r7, #65352	; 0xff48
            knobParamNames[LivingString][13] = "FREQ5";
 801fe52:	f8c3 45ac 	str.w	r4, [r3, #1452]	; 0x5ac
            knobParamNames[LivingString][2] = "DECAY";
 801fe56:	f64f 7468 	movw	r4, #65384	; 0xff68
            shortModeNames[Reverb] = "RV";
 801fe5a:	9a00      	ldr	r2, [sp, #0]
            knobParamNames[LivingString][14] = "FREQ6";
 801fe5c:	f6c0 0002 	movt	r0, #2050	; 0x802
            knobParamNames[LivingString][10] = "FREQ2";
 801fe60:	f8c3 55a0 	str.w	r5, [r3, #1440]	; 0x5a0
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
 801fe64:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
 801fe68:	f6c0 0102 	movt	r1, #2050	; 0x802
            shortModeNames[LivingString] = "LS";
 801fe6c:	f6c0 0702 	movt	r7, #2050	; 0x802
            knobParamNames[LivingString][2] = "DECAY";
 801fe70:	f6c0 0402 	movt	r4, #2050	; 0x802
            modeNames[LivingStringSynth] = "STRING2";
 801fe74:	f64f 75d0 	movw	r5, #65488	; 0xffd0
            shortModeNames[Reverb] = "RV";
 801fe78:	f8c2 9030 	str.w	r9, [r2, #48]	; 0x30
            shortModeNames[Reverb2] = "RV";
 801fe7c:	f8c2 9034 	str.w	r9, [r2, #52]	; 0x34
            modeNames[LivingStringSynth] = "STRING2";
 801fe80:	f6c0 0502 	movt	r5, #2050	; 0x802
            knobParamNames[Reverb2][3] = "PEAK_FREQ";
 801fe84:	f8c3 e520 	str.w	lr, [r3, #1312]	; 0x520
            shortModeNames[LivingStringSynth] = "SS";
 801fe88:	f240 0ed0 	movw	lr, #208	; 0xd0
            knobParamNames[Reverb2][4] = "PEAK_GAIN";
 801fe8c:	f8c3 c524 	str.w	ip, [r3, #1316]	; 0x524
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801fe90:	f64f 79d8 	movw	r9, #65496	; 0xffd8
            knobParamNames[LivingString][4] = "PICK POS";
 801fe94:	f8c3 6588 	str.w	r6, [r3, #1416]	; 0x588
            shortModeNames[LivingStringSynth] = "SS";
 801fe98:	f6c0 0e03 	movt	lr, #2051	; 0x803
            knobParamNames[LivingString][11] = "FREQ3";
 801fe9c:	f8c3 a5a4 	str.w	sl, [r3, #1444]	; 0x5a4
            modeNamesDetails[LivingString] = "SYMP STRING";
 801fea0:	f64f 764c 	movw	r6, #65356	; 0xff4c
            knobParamNames[LivingString][12] = "FREQ4";
 801fea4:	f8c3 b5a8 	str.w	fp, [r3, #1448]	; 0x5a8
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801fea8:	f6c0 0902 	movt	r9, #2050	; 0x802
            knobParamNames[LivingString][14] = "FREQ6";
 801feac:	f8c3 05b0 	str.w	r0, [r3, #1456]	; 0x5b0
            modeNamesDetails[LivingString] = "SYMP STRING";
 801feb0:	f6c0 0602 	movt	r6, #2050	; 0x802
            knobParamNames[LivingStringSynth][0] = "PLUCK VOL";
 801feb4:	f8c3 85dc 	str.w	r8, [r3, #1500]	; 0x5dc
            modeNames[LivingString] = "STRING1";
 801feb8:	f64f 7c40 	movw	ip, #65344	; 0xff40
            knobParamNames[LivingString][2] = "DECAY";
 801febc:	9406      	str	r4, [sp, #24]
            knobParamNames[LivingString][5] = "PREP POS";
 801febe:	f64f 7484 	movw	r4, #65412	; 0xff84
            knobParamNames[LivingStringSynth][1] = "PLUCK TONE";
 801fec2:	f8c3 15e0 	str.w	r1, [r3, #1504]	; 0x5e0
            numPages[Vocoder] = 2;
 801fec6:	f648 0b10 	movw	fp, #34832	; 0x8810
            modeNames[LivingString] = "STRING1";
 801feca:	9902      	ldr	r1, [sp, #8]
            knobParamNames[LivingString][5] = "PREP POS";
 801fecc:	f6c0 0402 	movt	r4, #2050	; 0x802
            shortModeNames[LivingString] = "LS";
 801fed0:	6397      	str	r7, [r2, #56]	; 0x38
            numPages[Vocoder] = 2;
 801fed2:	f2c2 0b01 	movt	fp, #8193	; 0x2001
            modeNames[LivingStringSynth] = "STRING2";
 801fed6:	9a02      	ldr	r2, [sp, #8]
            modeNames[LivingString] = "STRING1";
 801fed8:	f6c0 0c02 	movt	ip, #2050	; 0x802
            modeNamesDetails[LivingString] = "SYMP STRING";
 801fedc:	9f01      	ldr	r7, [sp, #4]
            knobParamNames[LivingString][6] = "PREP FORCE";
 801fede:	f64f 7090 	movw	r0, #65424	; 0xff90
            modeNames[LivingStringSynth] = "STRING2";
 801fee2:	63d5      	str	r5, [r2, #60]	; 0x3c
            knobParamNames[LivingString][1] = "DETUNE";
 801fee4:	f64f 7a60 	movw	sl, #65376	; 0xff60
            shortModeNames[LivingStringSynth] = "SS";
 801fee8:	9d00      	ldr	r5, [sp, #0]
            knobParamNames[LivingString][6] = "PREP FORCE";
 801feea:	f6c0 0002 	movt	r0, #2050	; 0x802
            modeNamesDetails[LivingString] = "SYMP STRING";
 801feee:	63be      	str	r6, [r7, #56]	; 0x38
            numPages[Vocoder] = 2;
 801fef0:	f240 1701 	movw	r7, #257	; 0x101
            shortModeNames[LivingStringSynth] = "SS";
 801fef4:	f8c5 e03c 	str.w	lr, [r5, #60]	; 0x3c
            knobParamNames[LivingStringSynth][2] = "DECAY";
            knobParamNames[LivingStringSynth][3] = "DAMPING";
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
 801fef8:	f240 0500 	movw	r5, #0
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801fefc:	9e01      	ldr	r6, [sp, #4]
            knobParamNames[LivingString][3] = "DAMPING";
 801fefe:	f64f 7870 	movw	r8, #65392	; 0xff70
            knobParamNames[LivingString][5] = "PREP POS";
 801ff02:	f8c3 458c 	str.w	r4, [r3, #1420]	; 0x58c
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
 801ff06:	f6c0 0503 	movt	r5, #2051	; 0x803
            knobParamNames[LivingStringSynth][5] = "PREP POS";
 801ff0a:	f8c3 45f0 	str.w	r4, [r3, #1520]	; 0x5f0
            knobParamNames[ClassicSynth][8] = "RELEASE";
            knobParamNames[ClassicSynth][9] = "LEAK";
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
            knobParamNames[ClassicSynth][11] = "F_DECAY";
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ff0e:	f240 0488 	movw	r4, #136	; 0x88
            modeNamesDetails[LivingStringSynth] = "STRING SYNTH";
 801ff12:	f8c6 903c 	str.w	r9, [r6, #60]	; 0x3c
            numPages[Vocoder] = 2;
 801ff16:	463e      	mov	r6, r7
            knobParamNames[LivingStringSynth][4] = "PICK_POS";
 801ff18:	f8c3 55ec 	str.w	r5, [r3, #1516]	; 0x5ec
            numPages[Vocoder] = 2;
 801ff1c:	f2c0 2703 	movt	r7, #515	; 0x203
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ff20:	f6c0 0403 	movt	r4, #2051	; 0x803
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801ff24:	f240 0594 	movw	r5, #148	; 0x94
            modeNames[LivingString] = "STRING1";
 801ff28:	f8c1 c038 	str.w	ip, [r1, #56]	; 0x38
            numPages[Vocoder] = 2;
 801ff2c:	f2c0 2602 	movt	r6, #514	; 0x202
 801ff30:	f8cb 700c 	str.w	r7, [fp, #12]
            knobParamNames[LivingString][7] = "LET RING";
 801ff34:	f64f 719c 	movw	r1, #65436	; 0xff9c
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ff38:	9407      	str	r4, [sp, #28]
            numPages[Vocoder] = 2;
 801ff3a:	f240 3c02 	movw	ip, #770	; 0x302
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801ff3e:	462c      	mov	r4, r5
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
 801ff40:	f240 0768 	movw	r7, #104	; 0x68
            knobParamNames[LivingString][2] = "DECAY";
 801ff44:	9a06      	ldr	r2, [sp, #24]
            knobParamNames[LivingString][1] = "DETUNE";
 801ff46:	f6c0 0a02 	movt	sl, #2050	; 0x802
            knobParamNames[LivingString][3] = "DAMPING";
 801ff4a:	f6c0 0802 	movt	r8, #2050	; 0x802
            knobParamNames[LivingString][7] = "LET RING";
 801ff4e:	f6c0 0102 	movt	r1, #2050	; 0x802
            knobParamNames[LivingString][6] = "PREP FORCE";
 801ff52:	f8c3 0590 	str.w	r0, [r3, #1424]	; 0x590
            numPages[Vocoder] = 2;
 801ff56:	f2c0 1c02 	movt	ip, #258	; 0x102
 801ff5a:	f8cb 6004 	str.w	r6, [fp, #4]
            numPages[ClassicSynth] = 4;
 801ff5e:	f04f 0904 	mov.w	r9, #4
            numPages[Vocoder] = 2;
 801ff62:	f8cb 6008 	str.w	r6, [fp, #8]
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
 801ff66:	f6c0 0703 	movt	r7, #2051	; 0x803
            knobParamNames[LivingStringSynth][6] = "PREP FORCE";
 801ff6a:	f8c3 05f4 	str.w	r0, [r3, #1524]	; 0x5f4
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801ff6e:	f6c0 0403 	movt	r4, #2051	; 0x803
            knobParamNames[ClassicSynth][0] = "VOLUME";
 801ff72:	9804      	ldr	r0, [sp, #16]
            knobParamNames[ClassicSynth][11] = "F_DECAY";
 801ff74:	f240 0674 	movw	r6, #116	; 0x74
            knobParamNames[LivingString][1] = "DETUNE";
 801ff78:	f8c3 a57c 	str.w	sl, [r3, #1404]	; 0x57c
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
 801ff7c:	f240 0e38 	movw	lr, #56	; 0x38
            knobParamNames[LivingString][2] = "DECAY";
 801ff80:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
            knobParamNames[ClassicSynth][11] = "F_DECAY";
 801ff84:	f6c0 0603 	movt	r6, #2051	; 0x803
            knobParamNames[LivingStringSynth][2] = "DECAY";
 801ff88:	f8c3 25e4 	str.w	r2, [r3, #1508]	; 0x5e4
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
 801ff8c:	f240 059c 	movw	r5, #156	; 0x9c
            knobParamNames[LivingString][3] = "DAMPING";
 801ff90:	f8c3 8584 	str.w	r8, [r3, #1412]	; 0x584
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
 801ff94:	f6c0 0e03 	movt	lr, #2051	; 0x803
            knobParamNames[LivingStringSynth][3] = "DAMPING";
 801ff98:	f8c3 85e8 	str.w	r8, [r3, #1512]	; 0x5e8
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
 801ff9c:	f6c0 0503 	movt	r5, #2051	; 0x803
            knobParamNames[LivingString][7] = "LET RING";
 801ffa0:	f8c3 1594 	str.w	r1, [r3, #1428]	; 0x594
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
 801ffa4:	f240 080c 	movw	r8, #12
            numPages[Vocoder] = 2;
 801ffa8:	f8cb c000 	str.w	ip, [fp]
            knobParamNames[ClassicSynth][4] = "FILTER Q";
 801ffac:	f240 0c44 	movw	ip, #68	; 0x44
            numPages[ClassicSynth] = 4;
 801ffb0:	f88b 9010 	strb.w	r9, [fp, #16]
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
 801ffb4:	f240 097c 	movw	r9, #124	; 0x7c
            knobParamNames[LivingStringSynth][7] = "LET RING";
 801ffb8:	f8c3 15f8 	str.w	r1, [r3, #1528]	; 0x5f8
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
 801ffbc:	f6c0 0803 	movt	r8, #2051	; 0x803
            knobParamNames[ClassicSynth][0] = "VOLUME";
 801ffc0:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
            modeNames[ClassicSynth] = "POLYSYNTH";
 801ffc4:	f240 0020 	movw	r0, #32
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801ffc8:	9404      	str	r4, [sp, #16]
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
 801ffca:	f240 04a8 	movw	r4, #168	; 0xa8
            knobParamNames[ClassicSynth][10] = "F_ATTACK";
 801ffce:	f8c3 7668 	str.w	r7, [r3, #1640]	; 0x668
            knobParamNames[ClassicSynth][18] = "";
            knobParamNames[ClassicSynth][19] = "";

            modeNames[Rhodes] = "RHODES";
            shortModeNames[Rhodes] = "RD";
            modeNamesDetails[Rhodes] = "DARK";
 801ffd2:	f240 07c0 	movw	r7, #192	; 0xc0
            knobParamNames[ClassicSynth][11] = "F_DECAY";
 801ffd6:	f8c3 666c 	str.w	r6, [r3, #1644]	; 0x66c
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
 801ffda:	f6c0 0403 	movt	r4, #2051	; 0x803
            modeNamesDetails[Rhodes] = "DARK";
 801ffde:	463e      	mov	r6, r7
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ffe0:	9f07      	ldr	r7, [sp, #28]
            knobParamNames[ClassicSynth][1] = "LOWPASS";
 801ffe2:	9905      	ldr	r1, [sp, #20]
            modeNames[ClassicSynth] = "POLYSYNTH";
 801ffe4:	f6c0 0003 	movt	r0, #2051	; 0x803
            knobParamNames[ClassicSynth][13] = "F_RELEASE";
 801ffe8:	f8c3 7674 	str.w	r7, [r3, #1652]	; 0x674
            knobParamNames[ClassicSynth][4] = "FILTER Q";
 801ffec:	f6c0 0c03 	movt	ip, #2051	; 0x803
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801fff0:	9f04      	ldr	r7, [sp, #16]
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
 801fff2:	f6c0 0903 	movt	r9, #2051	; 0x803
            knobParamNames[ClassicSynth][1] = "LOWPASS";
 801fff6:	f8c3 1644 	str.w	r1, [r3, #1604]	; 0x644
            shortModeNames[ClassicSynth] = "CS";
 801fffa:	f240 012c 	movw	r1, #44	; 0x2c
            knobParamNames[ClassicSynth][14] = "F_LEAK";
 801fffe:	f8c3 7678 	str.w	r7, [r3, #1656]	; 0x678
            numPages[Rhodes] = 5;
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 8020002:	f240 07c8 	movw	r7, #200	; 0xc8
            knobParamNames[ClassicSynth][6] = "DECAY";
 8020006:	f8c3 2658 	str.w	r2, [r3, #1624]	; 0x658
            shortModeNames[ClassicSynth] = "CS";
 802000a:	f6c0 0103 	movt	r1, #2051	; 0x803
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 802000e:	f6c0 0703 	movt	r7, #2051	; 0x803
            knobParamNames[ClassicSynth][17] = "";
 8020012:	9a03      	ldr	r2, [sp, #12]
            knobParamNames[ClassicSynth][2] = "KEYFOLLOW";
 8020014:	f8c3 e648 	str.w	lr, [r3, #1608]	; 0x648
            modeNames[Rhodes] = "RHODES";
 8020018:	f240 0eb4 	movw	lr, #180	; 0xb4
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 802001c:	9704      	str	r7, [sp, #16]
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 802001e:	f240 07d4 	movw	r7, #212	; 0xd4
            knobParamNames[ClassicSynth][15] = "F_AMOUNT";
 8020022:	f8c3 567c 	str.w	r5, [r3, #1660]	; 0x67c
            modeNames[Rhodes] = "RHODES";
 8020026:	f6c0 0e03 	movt	lr, #2051	; 0x803
            knobParamNames[ClassicSynth][16] = "SAW/PULSE";
 802002a:	f8c3 4680 	str.w	r4, [r3, #1664]	; 0x680
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 802002e:	463d      	mov	r5, r7
            modeNames[ClassicSynth] = "POLYSYNTH";
 8020030:	9c02      	ldr	r4, [sp, #8]
            modeNamesDetails[Rhodes] = "DARK";
 8020032:	f6c0 0603 	movt	r6, #2051	; 0x803
            knobParamNames[ClassicSynth][17] = "";
 8020036:	f8c3 2684 	str.w	r2, [r3, #1668]	; 0x684
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 802003a:	f6c0 0503 	movt	r5, #2051	; 0x803
            knobParamNames[ClassicSynth][18] = "";
 802003e:	f8c3 2688 	str.w	r2, [r3, #1672]	; 0x688
            knobParamNames[ClassicSynth][19] = "";
 8020042:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 8020046:	f240 0230 	movw	r2, #48	; 0x30
            modeNames[ClassicSynth] = "POLYSYNTH";
 802004a:	6420      	str	r0, [r4, #64]	; 0x40
            shortModeNames[ClassicSynth] = "CS";
 802004c:	9800      	ldr	r0, [sp, #0]
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 802004e:	f6c0 0203 	movt	r2, #2051	; 0x803
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 8020052:	9503      	str	r5, [sp, #12]
            knobParamNames[Rhodes][2] = "TREM RATE";
 8020054:	f240 05e0 	movw	r5, #224	; 0xe0
            shortModeNames[ClassicSynth] = "CS";
 8020058:	6401      	str	r1, [r0, #64]	; 0x40
            modeNames[Rhodes] = "RHODES";
 802005a:	f8c4 e044 	str.w	lr, [r4, #68]	; 0x44
            knobParamNames[Rhodes][3] = "DRIVE";
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 802005e:	f240 04f4 	movw	r4, #244	; 0xf4
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 8020062:	9901      	ldr	r1, [sp, #4]
            knobParamNames[Rhodes][2] = "TREM RATE";
 8020064:	462f      	mov	r7, r5
            knobParamNames[Rhodes][3] = "DRIVE";
 8020066:	f240 05ec 	movw	r5, #236	; 0xec
            knobParamNames[ClassicSynth][3] = "DETUNE";
 802006a:	f8c3 a64c 	str.w	sl, [r3, #1612]	; 0x64c
            modeNamesDetails[ClassicSynth] = "VCO+VCF";
 802006e:	640a      	str	r2, [r1, #64]	; 0x40
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 8020070:	4622      	mov	r2, r4
            knobParamNames[Rhodes][2] = "TREM RATE";
 8020072:	463c      	mov	r4, r7
            knobParamNames[Rhodes][3] = "DRIVE";
 8020074:	f6c0 0503 	movt	r5, #2051	; 0x803
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 8020078:	4696      	mov	lr, r2
            knobParamNames[LivingStringSynth][8] = "FB LEVEL";
 802007a:	f8c3 85fc 	str.w	r8, [r3, #1532]	; 0x5fc
            knobParamNames[Rhodes][2] = "TREM RATE";
 802007e:	f6c0 0403 	movt	r4, #2051	; 0x803
            knobParamNames[ClassicSynth][4] = "FILTER Q";
 8020082:	f8c3 c650 	str.w	ip, [r3, #1616]	; 0x650
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 8020086:	f6c0 0e03 	movt	lr, #2051	; 0x803
            modeNamesDetails[Rhodes] = "DARK";
 802008a:	9605      	str	r6, [sp, #20]
            knobParamNames[ClassicSynth][12] = "F_SUSTAIN";
 802008c:	f8c3 9670 	str.w	r9, [r3, #1648]	; 0x670
            shortModeNames[Rhodes] = "RD";
 8020090:	f240 0cbc 	movw	ip, #188	; 0xbc
            knobParamNames[Rhodes][2] = "TREM RATE";
 8020094:	9401      	str	r4, [sp, #4]
            knobParamNames[Rhodes][5] = "ATTACK";
            knobParamNames[Rhodes][6] = "DECAY";
            knobParamNames[Rhodes][7] = "SUSTAIN";
            knobParamNames[Rhodes][8] = "RELEASE";
            knobParamNames[Rhodes][9] = "LEAK";
            knobParamNames[Rhodes][10] = "INDEX1";
 8020096:	f240 1400 	movw	r4, #256	; 0x100
            knobParamNames[Rhodes][3] = "DRIVE";
 802009a:	9502      	str	r5, [sp, #8]
            knobParamNames[LivingStringSynth][9] = "RELEASE";
 802009c:	f240 0618 	movw	r6, #24
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 80200a0:	f8cd e01c 	str.w	lr, [sp, #28]
            knobParamNames[Rhodes][10] = "INDEX1";
 80200a4:	f6c0 0403 	movt	r4, #2051	; 0x803
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 80200a8:	9f04      	ldr	r7, [sp, #16]
            knobParamNames[ClassicSynth][5] = "ATTACK";
 80200aa:	f240 0950 	movw	r9, #80	; 0x50
            modeNamesDetails[Rhodes] = "DARK";
 80200ae:	9a05      	ldr	r2, [sp, #20]
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
 80200b0:	f240 0a58 	movw	sl, #88	; 0x58
            knobParamNames[Rhodes][0] = "BRIGHTNESS";
 80200b4:	f8c3 76a4 	str.w	r7, [r3, #1700]	; 0x6a4
            knobParamNames[ClassicSynth][9] = "LEAK";
 80200b8:	f240 0860 	movw	r8, #96	; 0x60
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 80200bc:	9f03      	ldr	r7, [sp, #12]
            knobParamNames[Rhodes][11] = "INDEX2";
 80200be:	f240 1e08 	movw	lr, #264	; 0x108
            modeNamesDetails[Rhodes] = "DARK";
 80200c2:	644a      	str	r2, [r1, #68]	; 0x44
            knobParamNames[Rhodes][12] = "INDEX3";
            knobParamNames[Rhodes][13] = "INDEX4";
            knobParamNames[Rhodes][14] = "INDEX5";
 80200c4:	f240 1220 	movw	r2, #288	; 0x120
            knobParamNames[Rhodes][1] = "TREM DEPTH";
 80200c8:	f8c3 76a8 	str.w	r7, [r3, #1704]	; 0x6a8
            knobParamNames[Rhodes][13] = "INDEX4";
 80200cc:	f240 1118 	movw	r1, #280	; 0x118
            knobParamNames[Rhodes][2] = "TREM RATE";
 80200d0:	9f01      	ldr	r7, [sp, #4]
            knobParamNames[Rhodes][14] = "INDEX5";
 80200d2:	f6c0 0203 	movt	r2, #2051	; 0x803
            knobParamNames[Rhodes][13] = "INDEX4";
 80200d6:	f6c0 0103 	movt	r1, #2051	; 0x803
            knobParamNames[Rhodes][10] = "INDEX1";
 80200da:	9400      	str	r4, [sp, #0]
            knobParamNames[Rhodes][2] = "TREM RATE";
 80200dc:	f8c3 76ac 	str.w	r7, [r3, #1708]	; 0x6ac
            knobParamNames[LivingStringSynth][9] = "RELEASE";
 80200e0:	f6c0 0603 	movt	r6, #2051	; 0x803
            knobParamNames[Rhodes][3] = "DRIVE";
 80200e4:	9f02      	ldr	r7, [sp, #8]
            knobParamNames[ClassicSynth][5] = "ATTACK";
 80200e6:	f6c0 0903 	movt	r9, #2051	; 0x803
            knobParamNames[Rhodes][14] = "INDEX5";
 80200ea:	9209      	str	r2, [sp, #36]	; 0x24
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
 80200ec:	f6c0 0a03 	movt	sl, #2051	; 0x803
            knobParamNames[Rhodes][6] = "DECAY";
 80200f0:	9a06      	ldr	r2, [sp, #24]
            knobParamNames[ClassicSynth][9] = "LEAK";
 80200f2:	f6c0 0803 	movt	r8, #2051	; 0x803
            knobParamNames[Rhodes][3] = "DRIVE";
 80200f6:	f8c3 76b0 	str.w	r7, [r3, #1712]	; 0x6b0
            shortModeNames[Rhodes] = "RD";
 80200fa:	f6c0 0c03 	movt	ip, #2051	; 0x803
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 80200fe:	9f07      	ldr	r7, [sp, #28]
            knobParamNames[Rhodes][11] = "INDEX2";
 8020100:	f6c0 0e03 	movt	lr, #2051	; 0x803
            knobParamNames[Rhodes][13] = "INDEX4";
 8020104:	9105      	str	r1, [sp, #20]
            numPages[Rhodes] = 5;
 8020106:	f04f 0105 	mov.w	r1, #5
            knobParamNames[Rhodes][6] = "DECAY";
 802010a:	f8c3 26bc 	str.w	r2, [r3, #1724]	; 0x6bc
            knobParamNames[Rhodes][15] = "RATIO1";
 802010e:	f240 1528 	movw	r5, #296	; 0x128
            knobParamNames[Rhodes][16] = "RATIO2";
            knobParamNames[Rhodes][17] = "RATIO3";
            knobParamNames[Rhodes][18] = "RATIO4";
            knobParamNames[Rhodes][19] = "RATIO5";
            knobParamNames[Rhodes][20] = "RATIO6";
            knobParamNames[Rhodes][21] = "FEEDBACK";
 8020112:	9a08      	ldr	r2, [sp, #32]
            knobParamNames[Rhodes][16] = "RATIO2";
 8020114:	f240 1430 	movw	r4, #304	; 0x130
            knobParamNames[Rhodes][4] = "PAN SPREAD";
 8020118:	f8c3 76b4 	str.w	r7, [r3, #1716]	; 0x6b4
            knobParamNames[Rhodes][15] = "RATIO1";
 802011c:	f6c0 0503 	movt	r5, #2051	; 0x803
            knobParamNames[Rhodes][10] = "INDEX1";
 8020120:	9f00      	ldr	r7, [sp, #0]
            knobParamNames[Rhodes][16] = "RATIO2";
 8020122:	f6c0 0403 	movt	r4, #2051	; 0x803
            shortModeNames[Rhodes] = "RD";
 8020126:	f8c0 c044 	str.w	ip, [r0, #68]	; 0x44
            knobParamNames[Rhodes][12] = "INDEX3";
 802012a:	f240 1c10 	movw	ip, #272	; 0x110
            knobParamNames[LivingStringSynth][9] = "RELEASE";
 802012e:	f8c3 6600 	str.w	r6, [r3, #1536]	; 0x600
            knobParamNames[Rhodes][17] = "RATIO3";
 8020132:	f240 1038 	movw	r0, #312	; 0x138
            knobParamNames[ClassicSynth][8] = "RELEASE";
 8020136:	f8c3 6660 	str.w	r6, [r3, #1632]	; 0x660
            knobParamNames[Rhodes][12] = "INDEX3";
 802013a:	f6c0 0c03 	movt	ip, #2051	; 0x803
            knobParamNames[ClassicSynth][5] = "ATTACK";
 802013e:	f8c3 9654 	str.w	r9, [r3, #1620]	; 0x654
            knobParamNames[Rhodes][17] = "RATIO3";
 8020142:	f6c0 0003 	movt	r0, #2051	; 0x803
            knobParamNames[ClassicSynth][7] = "SUSTAIN";
 8020146:	f8c3 a65c 	str.w	sl, [r3, #1628]	; 0x65c
            knobParamNames[ClassicSynth][9] = "LEAK";
 802014a:	f8c3 8664 	str.w	r8, [r3, #1636]	; 0x664
            numPages[Rhodes] = 5;
 802014e:	f88b 1011 	strb.w	r1, [fp, #17]
            knobParamNames[Rhodes][18] = "RATIO4";
 8020152:	f240 1140 	movw	r1, #320	; 0x140
            knobParamNames[Rhodes][5] = "ATTACK";
 8020156:	f8c3 96b8 	str.w	r9, [r3, #1720]	; 0x6b8
            knobParamNames[Rhodes][19] = "RATIO5";
 802015a:	f240 1948 	movw	r9, #328	; 0x148
            knobParamNames[Rhodes][7] = "SUSTAIN";
 802015e:	f8c3 a6c0 	str.w	sl, [r3, #1728]	; 0x6c0
            knobParamNames[Rhodes][20] = "RATIO6";
 8020162:	f240 1a50 	movw	sl, #336	; 0x150
            knobParamNames[Rhodes][8] = "RELEASE";
 8020166:	f8c3 66c4 	str.w	r6, [r3, #1732]	; 0x6c4
            knobParamNames[Rhodes][22] = "TUNE SNAP";
 802016a:	f240 1658 	movw	r6, #344	; 0x158
            knobParamNames[Rhodes][9] = "LEAK";
 802016e:	f8c3 86c8 	str.w	r8, [r3, #1736]	; 0x6c8
            knobParamNames[Rhodes][23] = "RAND DECAY";
 8020172:	f240 1864 	movw	r8, #356	; 0x164
            knobParamNames[Rhodes][21] = "FEEDBACK";
 8020176:	f8c3 26f8 	str.w	r2, [r3, #1784]	; 0x6f8
            knobParamNames[Rhodes][24] = "RAND SUST";
 802017a:	f240 1270 	movw	r2, #368	; 0x170
            knobParamNames[Rhodes][10] = "INDEX1";
 802017e:	f8c3 76cc 	str.w	r7, [r3, #1740]	; 0x6cc
            knobParamNames[Rhodes][18] = "RATIO4";
 8020182:	f6c0 0103 	movt	r1, #2051	; 0x803
            knobParamNames[Rhodes][11] = "INDEX2";
 8020186:	f8c3 e6d0 	str.w	lr, [r3, #1744]	; 0x6d0
            knobParamNames[Rhodes][19] = "RATIO5";
 802018a:	f6c0 0903 	movt	r9, #2051	; 0x803
            knobParamNames[Rhodes][13] = "INDEX4";
 802018e:	9f05      	ldr	r7, [sp, #20]
            knobParamNames[Rhodes][20] = "RATIO6";
 8020190:	f6c0 0a03 	movt	sl, #2051	; 0x803
            knobParamNames[Rhodes][22] = "TUNE SNAP";
 8020194:	f6c0 0603 	movt	r6, #2051	; 0x803
            knobParamNames[Rhodes][23] = "RAND DECAY";
 8020198:	f6c0 0803 	movt	r8, #2051	; 0x803
            knobParamNames[Rhodes][24] = "RAND SUST";
 802019c:	f6c0 0203 	movt	r2, #2051	; 0x803
            knobParamNames[Rhodes][13] = "INDEX4";
 80201a0:	f8c3 76d8 	str.w	r7, [r3, #1752]	; 0x6d8
            knobParamNames[Rhodes][14] = "INDEX5";
 80201a4:	9f09      	ldr	r7, [sp, #36]	; 0x24
            knobParamNames[Rhodes][12] = "INDEX3";
 80201a6:	f8c3 c6d4 	str.w	ip, [r3, #1748]	; 0x6d4
            knobParamNames[Rhodes][14] = "INDEX5";
 80201aa:	f8c3 76dc 	str.w	r7, [r3, #1756]	; 0x6dc
            knobParamNames[Rhodes][15] = "RATIO1";
 80201ae:	f8c3 56e0 	str.w	r5, [r3, #1760]	; 0x6e0
            knobParamNames[Rhodes][16] = "RATIO2";
 80201b2:	f8c3 46e4 	str.w	r4, [r3, #1764]	; 0x6e4
            knobParamNames[Rhodes][17] = "RATIO3";
 80201b6:	f8c3 06e8 	str.w	r0, [r3, #1768]	; 0x6e8
            knobParamNames[Rhodes][18] = "RATIO4";
 80201ba:	f8c3 16ec 	str.w	r1, [r3, #1772]	; 0x6ec
            knobParamNames[Rhodes][19] = "RATIO5";
 80201be:	f8c3 96f0 	str.w	r9, [r3, #1776]	; 0x6f0
            knobParamNames[Rhodes][20] = "RATIO6";
 80201c2:	f8c3 a6f4 	str.w	sl, [r3, #1780]	; 0x6f4
            knobParamNames[Rhodes][22] = "TUNE SNAP";
 80201c6:	f8c3 66fc 	str.w	r6, [r3, #1788]	; 0x6fc
            knobParamNames[Rhodes][23] = "RAND DECAY";
 80201ca:	f8c3 8700 	str.w	r8, [r3, #1792]	; 0x700
            knobParamNames[Rhodes][24] = "RAND SUST";
 80201ce:	f8c3 2704 	str.w	r2, [r3, #1796]	; 0x704
        }
 80201d2:	b00b      	add	sp, #44	; 0x2c
 80201d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080201d8 <buttonCheck>:

        void buttonCheck(void)
        {
#ifndef __cplusplus
            if (codecReady)
 80201d8:	f240 43f8 	movw	r3, #1272	; 0x4f8
 80201dc:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80201e0:	781b      	ldrb	r3, [r3, #0]
 80201e2:	2b00      	cmp	r3, #0
 80201e4:	f000 8112 	beq.w	802040c <buttonCheck+0x234>
                 buttonValues[8] = !HAL_GPIO_ReadPin(GPIOG, GPIO_PIN_11); // D
                 buttonValues[9] = !HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_10); // E
                 */

                //A little more efficient since it avoids a function call
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 80201e8:	f44f 6180 	mov.w	r1, #1024	; 0x400
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 80201ec:	f44f 53c0 	mov.w	r3, #6144	; 0x1800
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 80201f0:	f249 026c 	movw	r2, #36972	; 0x906c
 80201f4:	f240 20ce 	movw	r0, #718	; 0x2ce
 80201f8:	f6c5 0102 	movt	r1, #22530	; 0x5802
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 80201fc:	f6c5 0302 	movt	r3, #22530	; 0x5802
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 8020200:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8020204:	f2c2 0000 	movt	r0, #8192	; 0x2000
        {
 8020208:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802020c:	b08b      	sub	sp, #44	; 0x2c
 802020e:	f240 26cd 	movw	r6, #717	; 0x2cd
 8020212:	4605      	mov	r5, r0
                            writeButtonFlag = i;
                            writeActionFlag = ActionHoldContinuous;
                        }
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
                        {
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 8020214:	f240 28bc 	movw	r8, #700	; 0x2bc
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 8020218:	9303      	str	r3, [sp, #12]
 802021a:	f2c2 0600 	movt	r6, #8192	; 0x2000
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 802021e:	690b      	ldr	r3, [r1, #16]
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 8020220:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8020224:	9608      	str	r6, [sp, #32]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 8020226:	f240 27c0 	movw	r7, #704	; 0x2c0
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 802022a:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 802022e:	9009      	str	r0, [sp, #36]	; 0x24
 8020230:	f995 5000 	ldrsb.w	r5, [r5]
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
 8020234:	f44f 6440 	mov.w	r4, #3072	; 0xc00
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 8020238:	f3c3 3340 	ubfx	r3, r3, #13, #1
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 802023c:	f2c2 0700 	movt	r7, #8192	; 0x2000
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
 8020240:	f6c5 0402 	movt	r4, #22530	; 0x5802
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 8020244:	f240 29c4 	movw	r9, #708	; 0x2c4
                buttonValues[0] =!(GPIOB->IDR & GPIO_PIN_13);
 8020248:	7013      	strb	r3, [r2, #0]
 802024a:	f648 0654 	movw	r6, #34900	; 0x8854
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 802024e:	6908      	ldr	r0, [r1, #16]
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 8020250:	f2c2 0900 	movt	r9, #8192	; 0x2000
 8020254:	9501      	str	r5, [sp, #4]
                    for (int i = 0; i < NUM_BUTTONS; i++)
 8020256:	2300      	movs	r3, #0
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 8020258:	f480 5080 	eor.w	r0, r0, #4096	; 0x1000
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 802025c:	f8d8 5000 	ldr.w	r5, [r8]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 8020260:	683f      	ldr	r7, [r7, #0]
 8020262:	f248 7e88 	movw	lr, #34696	; 0x8788
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 8020266:	f3c0 3000 	ubfx	r0, r0, #12, #1
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 802026a:	f8d9 9000 	ldr.w	r9, [r9]
 802026e:	f648 0ac8 	movw	sl, #35016	; 0x88c8
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 8020272:	f248 6be4 	movw	fp, #34532	; 0x86e4
                buttonValues[1] =!(GPIOB->IDR & GPIO_PIN_12);
 8020276:	7050      	strb	r0, [r2, #1]
 8020278:	f2c2 0601 	movt	r6, #8193	; 0x2001
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 802027c:	6908      	ldr	r0, [r1, #16]
 802027e:	4694      	mov	ip, r2
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 8020280:	9506      	str	r5, [sp, #24]
 8020282:	f2c2 0e01 	movt	lr, #8193	; 0x2001
 8020286:	9d08      	ldr	r5, [sp, #32]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 8020288:	f480 4080 	eor.w	r0, r0, #16384	; 0x4000
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 802028c:	9707      	str	r7, [sp, #28]
 802028e:	f248 67bf 	movw	r7, #34495	; 0x86bf
 8020292:	f995 5000 	ldrsb.w	r5, [r5]
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 8020296:	f3c0 3080 	ubfx	r0, r0, #14, #1
 802029a:	f2c2 0a01 	movt	sl, #8193	; 0x2001
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 802029e:	f2c2 0b01 	movt	fp, #8193	; 0x2001
 80202a2:	9502      	str	r5, [sp, #8]
                            }
                        }
                        else
                        {
                            cleanButtonValues[i] = buttonValues[i];
                            buttonHysteresis[i] = 0;
 80202a4:	4698      	mov	r8, r3
                buttonValues[2] =!(GPIOB->IDR & GPIO_PIN_14);
 80202a6:	7090      	strb	r0, [r2, #2]
 80202a8:	f2c2 0701 	movt	r7, #8193	; 0x2001
                buttonValues[3] =!(GPIOD->IDR & GPIO_PIN_11);
 80202ac:	6920      	ldr	r0, [r4, #16]
 80202ae:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 80202b2:	f3c0 20c0 	ubfx	r0, r0, #11, #1
 80202b6:	70d0      	strb	r0, [r2, #3]
                buttonValues[4] =!(GPIOB->IDR & GPIO_PIN_15);
 80202b8:	6908      	ldr	r0, [r1, #16]
 80202ba:	f480 4000 	eor.w	r0, r0, #32768	; 0x8000
 80202be:	f3c0 30c0 	ubfx	r0, r0, #15, #1
 80202c2:	7110      	strb	r0, [r2, #4]
                buttonValues[5] =!(GPIOB->IDR & GPIO_PIN_1);
 80202c4:	6908      	ldr	r0, [r1, #16]
 80202c6:	f080 0002 	eor.w	r0, r0, #2
 80202ca:	f3c0 0040 	ubfx	r0, r0, #1, #1
 80202ce:	7150      	strb	r0, [r2, #5]
                buttonValues[6] =!(GPIOD->IDR & GPIO_PIN_7);
 80202d0:	6920      	ldr	r0, [r4, #16]
 80202d2:	f248 745c 	movw	r4, #34652	; 0x875c
 80202d6:	f080 0080 	eor.w	r0, r0, #128	; 0x80
 80202da:	f2c2 0401 	movt	r4, #8193	; 0x2001
 80202de:	f3c0 10c0 	ubfx	r0, r0, #7, #1
 80202e2:	7190      	strb	r0, [r2, #6]
                buttonValues[7] =!(GPIOB->IDR & GPIO_PIN_11);
 80202e4:	6908      	ldr	r0, [r1, #16]
 80202e6:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 80202ea:	f3c0 20c0 	ubfx	r0, r0, #11, #1
 80202ee:	71d0      	strb	r0, [r2, #7]
                buttonValues[8] =!(GPIOG->IDR & GPIO_PIN_11);
 80202f0:	9803      	ldr	r0, [sp, #12]
 80202f2:	6900      	ldr	r0, [r0, #16]
 80202f4:	f480 6000 	eor.w	r0, r0, #2048	; 0x800
 80202f8:	f3c0 20c0 	ubfx	r0, r0, #11, #1
 80202fc:	7210      	strb	r0, [r2, #8]
                buttonValues[9] =!(GPIOB->IDR & GPIO_PIN_10);
 80202fe:	6909      	ldr	r1, [r1, #16]
 8020300:	9603      	str	r6, [sp, #12]
 8020302:	f481 6180 	eor.w	r1, r1, #1024	; 0x400
 8020306:	f3c1 2180 	ubfx	r1, r1, #10, #1
 802030a:	7251      	strb	r1, [r2, #9]
 802030c:	e00f      	b.n	802032e <buttonCheck+0x156>
                            if (buttonCounters[i] < buttonHoldMax) buttonCounters[i]++;
 802030e:	f85a 1002 	ldr.w	r1, [sl, r2]
 8020312:	9806      	ldr	r0, [sp, #24]
 8020314:	4281      	cmp	r1, r0
 8020316:	d202      	bcs.n	802031e <buttonCheck+0x146>
 8020318:	3101      	adds	r1, #1
 802031a:	f84a 1002 	str.w	r1, [sl, r2]
                            if ((buttonCounters[i] >= buttonHoldThreshold) && (cleanButtonValues[i] == 1))
 802031e:	9807      	ldr	r0, [sp, #28]
 8020320:	4288      	cmp	r0, r1
 8020322:	d801      	bhi.n	8020328 <buttonCheck+0x150>
 8020324:	2d01      	cmp	r5, #1
 8020326:	d072      	beq.n	802040e <buttonCheck+0x236>
                    for (int i = 0; i < NUM_BUTTONS; i++)
 8020328:	3301      	adds	r3, #1
 802032a:	2b0a      	cmp	r3, #10
 802032c:	d035      	beq.n	802039a <buttonCheck+0x1c2>
                        if (buttonValues[i] != buttonValuesPrev[i])
 802032e:	f81c 1b01 	ldrb.w	r1, [ip], #1
 8020332:	f817 2f01 	ldrb.w	r2, [r7, #1]!
 8020336:	f854 0f04 	ldr.w	r0, [r4, #4]!
 802033a:	428a      	cmp	r2, r1
 802033c:	d001      	beq.n	8020342 <buttonCheck+0x16a>
                            buttonHysteresis[i]++;
 802033e:	3001      	adds	r0, #1
 8020340:	6020      	str	r0, [r4, #0]
                        if (cleanButtonValues[i] == 1)
 8020342:	f81e 5003 	ldrb.w	r5, [lr, r3]
 8020346:	009a      	lsls	r2, r3, #2
 8020348:	2d01      	cmp	r5, #1
 802034a:	d10d      	bne.n	8020368 <buttonCheck+0x190>
                            writeActionFlag = ActionHoldContinuous;
 802034c:	2603      	movs	r6, #3
 802034e:	9602      	str	r6, [sp, #8]
                            writeButtonFlag = i;
 8020350:	b25e      	sxtb	r6, r3
 8020352:	9601      	str	r6, [sp, #4]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 8020354:	eb0b 0602 	add.w	r6, fp, r2
 8020358:	9604      	str	r6, [sp, #16]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
 802035a:	9e03      	ldr	r6, [sp, #12]
 802035c:	4416      	add	r6, r2
 802035e:	9605      	str	r6, [sp, #20]
                            buttonActionsSFX[i][ActionHoldContinuous] = TRUE;
 8020360:	9e04      	ldr	r6, [sp, #16]
 8020362:	70f5      	strb	r5, [r6, #3]
                            buttonActionsUI[i][ActionHoldContinuous] = TRUE;
 8020364:	9e05      	ldr	r6, [sp, #20]
 8020366:	70f5      	strb	r5, [r6, #3]
                        if (buttonHysteresis[i] < buttonHysteresisThreshold)
 8020368:	4581      	cmp	r9, r0
 802036a:	d8d0      	bhi.n	802030e <buttonCheck+0x136>
                            buttonCounters[i] = 0;

                            if (cleanButtonValues[i] == 1)
 802036c:	2901      	cmp	r1, #1
                            cleanButtonValues[i] = buttonValues[i];
 802036e:	f80e 1003 	strb.w	r1, [lr, r3]
                            buttonHysteresis[i] = 0;
 8020372:	f8c4 8000 	str.w	r8, [r4]
                            buttonCounters[i] = 0;
 8020376:	f84a 8002 	str.w	r8, [sl, r2]
                            if (cleanButtonValues[i] == 1)
 802037a:	d03d      	beq.n	80203f8 <buttonCheck+0x220>
                                buttonActionsSFX[i][ActionPress] = TRUE;
                                buttonActionsUI[i][ActionPress] = TRUE;
                                writeButtonFlag = i;
                                writeActionFlag = ActionPress;
                            }
                            else if (cleanButtonValues[i] == 0)
 802037c:	b949      	cbnz	r1, 8020392 <buttonCheck+0x1ba>
                            {
                                buttonActionsSFX[i][ActionRelease] = TRUE;
                                buttonActionsUI[i][ActionRelease] = TRUE;
 802037e:	9d03      	ldr	r5, [sp, #12]
                                buttonActionsSFX[i][ActionRelease] = TRUE;
 8020380:	eb0b 0002 	add.w	r0, fp, r2
                                buttonActionsUI[i][ActionRelease] = TRUE;
 8020384:	442a      	add	r2, r5
                                writeButtonFlag = i;
 8020386:	b25d      	sxtb	r5, r3
 8020388:	9501      	str	r5, [sp, #4]
                                writeActionFlag = ActionRelease;
 802038a:	2501      	movs	r5, #1
 802038c:	9502      	str	r5, [sp, #8]
                                buttonActionsSFX[i][ActionRelease] = TRUE;
 802038e:	7045      	strb	r5, [r0, #1]
                                buttonActionsUI[i][ActionRelease] = TRUE;
 8020390:	7055      	strb	r5, [r2, #1]
                            }
                            buttonValuesPrev[i] = buttonValues[i];
 8020392:	7039      	strb	r1, [r7, #0]
                    for (int i = 0; i < NUM_BUTTONS; i++)
 8020394:	3301      	adds	r3, #1
 8020396:	2b0a      	cmp	r3, #10
 8020398:	d1c9      	bne.n	802032e <buttonCheck+0x156>
 802039a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 802039c:	9e03      	ldr	r6, [sp, #12]
 802039e:	4611      	mov	r1, r2
 80203a0:	9a01      	ldr	r2, [sp, #4]

                    // make some if statements if you want to find the "attack" of the buttons (getting the "press" action)

                    /// DEFINE GLOBAL BUTTON BEHAVIOR HERE

                    if (buttonActionsUI[ButtonLeft][ActionPress] == 1)
 80203a2:	7933      	ldrb	r3, [r6, #4]
 80203a4:	700a      	strb	r2, [r1, #0]
 80203a6:	9a08      	ldr	r2, [sp, #32]
 80203a8:	2b01      	cmp	r3, #1
 80203aa:	4611      	mov	r1, r2
 80203ac:	9a02      	ldr	r2, [sp, #8]
 80203ae:	700a      	strb	r2, [r1, #0]
 80203b0:	f000 816a 	beq.w	8020688 <buttonCheck+0x4b0>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
 80203b4:	7a33      	ldrb	r3, [r6, #8]
 80203b6:	2b01      	cmp	r3, #1
 80203b8:	f000 81ad 	beq.w	8020716 <buttonCheck+0x53e>
                        loadingPreset = 1;
                        OLED_writePreset();
                        writeCurrentPresetToFlash();
                        clearButtonActions();
                    }
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
 80203bc:	f896 3020 	ldrb.w	r3, [r6, #32]
 80203c0:	2b01      	cmp	r3, #1
 80203c2:	f000 81f0 	beq.w	80207a6 <buttonCheck+0x5ce>
                        }
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonD][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
 80203c6:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 80203ca:	2b01      	cmp	r3, #1
 80203cc:	f000 822f 	beq.w	802082e <buttonCheck+0x656>
                        changeTuning();
                        OLED_writeTuning();
                        buttonActionsUI[ButtonE][ActionPress] = 0;
                    }

                    if (buttonActionsUI[ButtonEdit][ActionPress])
 80203d0:	7833      	ldrb	r3, [r6, #0]
 80203d2:	2b00      	cmp	r3, #0
 80203d4:	f040 821f 	bne.w	8020816 <buttonCheck+0x63e>
                    {
                        OLED_writeEditScreen();
                        setLED_Edit(1);
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 80203d8:	78f3      	ldrb	r3, [r6, #3]
 80203da:	2b01      	cmp	r3, #1
 80203dc:	d024      	beq.n	8020428 <buttonCheck+0x250>
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        }

                        //            OLEDdrawFloatArray(audioDisplayBuffer, -1.0f, 1.0f, 128, displayBufferIndex, 0, BothLines);
                    }
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
 80203de:	7873      	ldrb	r3, [r6, #1]
 80203e0:	2b01      	cmp	r3, #1
 80203e2:	d03e      	beq.n	8020462 <buttonCheck+0x28a>
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;

                    }
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
 80203e4:	7b33      	ldrb	r3, [r6, #12]
 80203e6:	2b01      	cmp	r3, #1
 80203e8:	d04c      	beq.n	8020484 <buttonCheck+0x2ac>
                        decrementPage();
                        OLEDwriteString("P", 1, 110, FirstLine);
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
                    }
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
 80203ea:	7c33      	ldrb	r3, [r6, #16]
 80203ec:	2b01      	cmp	r3, #1
 80203ee:	f000 80df 	beq.w	80205b0 <buttonCheck+0x3d8>
                    //            OLEDwriteString(" ", 1, getCursorX(), SecondLine);
                    //            OLEDwriteString(paramNames[orderedParams[currentParamIndex]], getCursorX(), SecondLine);
                    //            buttonActionsUI[ButtonEdit][ActionPress] = 0;
                    //        }
                }
            }
 80203f2:	b00b      	add	sp, #44	; 0x2c
 80203f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                                writeButtonFlag = i;
 80203f8:	b258      	sxtb	r0, r3
                                buttonActionsSFX[i][ActionPress] = TRUE;
 80203fa:	f80b 1002 	strb.w	r1, [fp, r2]
                            buttonValuesPrev[i] = buttonValues[i];
 80203fe:	7039      	strb	r1, [r7, #0]
                                writeButtonFlag = i;
 8020400:	9001      	str	r0, [sp, #4]
                                buttonActionsUI[i][ActionPress] = TRUE;
 8020402:	9803      	ldr	r0, [sp, #12]
 8020404:	5481      	strb	r1, [r0, r2]
                                writeActionFlag = ActionPress;
 8020406:	2200      	movs	r2, #0
 8020408:	9202      	str	r2, [sp, #8]
 802040a:	e7c3      	b.n	8020394 <buttonCheck+0x1bc>
 802040c:	4770      	bx	lr
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 802040e:	9803      	ldr	r0, [sp, #12]
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
 8020410:	eb0b 0102 	add.w	r1, fp, r2
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 8020414:	4402      	add	r2, r0
                                writeButtonFlag = i;
 8020416:	b258      	sxtb	r0, r3
 8020418:	9001      	str	r0, [sp, #4]
                                buttonActionsSFX[i][ActionHoldInstant] = TRUE;
 802041a:	f04f 0001 	mov.w	r0, #1
 802041e:	7088      	strb	r0, [r1, #2]
                                writeActionFlag = ActionHoldInstant;
 8020420:	2102      	movs	r1, #2
                                buttonActionsUI[i][ActionHoldInstant] = TRUE;
 8020422:	7090      	strb	r0, [r2, #2]
                                writeActionFlag = ActionHoldInstant;
 8020424:	9102      	str	r1, [sp, #8]
 8020426:	e77f      	b.n	8020328 <buttonCheck+0x150>
                        if (buttonActionsUI[ButtonC][ActionPress] == 1)
 8020428:	7f34      	ldrb	r4, [r6, #28]
 802042a:	2c01      	cmp	r4, #1
 802042c:	f000 8282 	beq.w	8020934 <buttonCheck+0x75c>
                        if (buttonActionsUI[ButtonDown][ActionPress])
 8020430:	7b33      	ldrb	r3, [r6, #12]
 8020432:	b19b      	cbz	r3, 802045c <buttonCheck+0x284>
                            cvAddParam[currentPreset] = -1;
 8020434:	f240 6155 	movw	r1, #1621	; 0x655
 8020438:	f648 1938 	movw	r9, #35128	; 0x8938
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
 802043c:	f248 62e4 	movw	r2, #34532	; 0x86e4
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
 8020440:	2300      	movs	r3, #0
                            cvAddParam[currentPreset] = -1;
 8020442:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020446:	20ff      	movs	r0, #255	; 0xff
 8020448:	f2c2 0901 	movt	r9, #8193	; 0x2001
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
 802044c:	f2c2 0201 	movt	r2, #8193	; 0x2001
                            cvAddParam[currentPreset] = -1;
 8020450:	7809      	ldrb	r1, [r1, #0]
                            buttonActionsSFX[ButtonDown][ActionPress] = 0;
 8020452:	7313      	strb	r3, [r2, #12]
                            cvAddParam[currentPreset] = -1;
 8020454:	f809 0001 	strb.w	r0, [r9, r1]
                            buttonActionsUI[ButtonDown][ActionPress] = 0;
 8020458:	7333      	strb	r3, [r6, #12]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 802045a:	70f3      	strb	r3, [r6, #3]
                    if (buttonActionsUI[ButtonEdit][ActionRelease] == 1)
 802045c:	7873      	ldrb	r3, [r6, #1]
 802045e:	2b01      	cmp	r3, #1
 8020460:	d1c3      	bne.n	80203ea <buttonCheck+0x212>
                        OLED_writePreset();
 8020462:	f7f5 fab3 	bl	80159cc <OLED_writePreset>
                        setLED_Edit(0);
 8020466:	2000      	movs	r0, #0
 8020468:	f7f5 fa00 	bl	801586c <setLED_Edit>
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
 802046c:	f248 62e4 	movw	r2, #34532	; 0x86e4
 8020470:	2300      	movs	r3, #0
 8020472:	f2c2 0201 	movt	r2, #8193	; 0x2001
                        buttonActionsUI[ButtonEdit][ActionRelease] = 0;
 8020476:	7073      	strb	r3, [r6, #1]
                        buttonActionsSFX[ButtonEdit][ActionRelease] = 0;
 8020478:	7053      	strb	r3, [r2, #1]
                        buttonActionsSFX[ButtonEdit][ActionHoldContinuous] = 0;
 802047a:	70d3      	strb	r3, [r2, #3]
                        buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 802047c:	70f3      	strb	r3, [r6, #3]
                    if (buttonActionsUI[ButtonDown][ActionPress] == 1)
 802047e:	7b33      	ldrb	r3, [r6, #12]
 8020480:	2b01      	cmp	r3, #1
 8020482:	d1b2      	bne.n	80203ea <buttonCheck+0x212>

            }

            void decrementPage(void)
            {
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
 8020484:	f240 6756 	movw	r7, #1622	; 0x656
 8020488:	f240 6455 	movw	r4, #1621	; 0x655
 802048c:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8020490:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8020494:	783b      	ldrb	r3, [r7, #0]
 8020496:	7821      	ldrb	r1, [r4, #0]
 8020498:	2b00      	cmp	r3, #0
 802049a:	f000 823f 	beq.w	802091c <buttonCheck+0x744>
                else knobPage--;
 802049e:	3b01      	subs	r3, #1
 80204a0:	b2db      	uxtb	r3, r3
 80204a2:	461d      	mov	r5, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80204a4:	f642 5310 	movw	r3, #11536	; 0x2d10
 80204a8:	2064      	movs	r0, #100	; 0x64
                    {
                        knob = 5;
                    }
                    knobActive[knob] = 0;
                    floatADCUI[knob] = -1.0f;
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80204aa:	f04f 0c14 	mov.w	ip, #20
 80204ae:	f648 1938 	movw	r9, #35128	; 0x8938
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80204b2:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80204b6:	f648 083c 	movw	r8, #34876	; 0x883c
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80204ba:	fb1c c205 	smlabb	r2, ip, r5, ip
 80204be:	9606      	str	r6, [sp, #24]
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80204c0:	fb00 3301 	mla	r3, r0, r1, r3
 80204c4:	f647 1014 	movw	r0, #30996	; 0x7914
 80204c8:	f2c2 0901 	movt	r9, #8193	; 0x2001
 80204cc:	f2c2 0801 	movt	r8, #8193	; 0x2001
 80204d0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80204d4:	9303      	str	r3, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80204d6:	4413      	add	r3, r2
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80204d8:	f04f 0a00 	mov.w	sl, #0
 80204dc:	9002      	str	r0, [sp, #8]
 80204de:	f648 0024 	movw	r0, #34852	; 0x8824
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80204e2:	9305      	str	r3, [sp, #20]
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80204e4:	462a      	mov	r2, r5
 80204e6:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80204ea:	703d      	strb	r5, [r7, #0]
 80204ec:	462e      	mov	r6, r5
 80204ee:	9404      	str	r4, [sp, #16]
 80204f0:	9001      	str	r0, [sp, #4]
 80204f2:	e015      	b.n	8020520 <buttonCheck+0x348>
                    knobActive[knob] = 0;
 80204f4:	9b02      	ldr	r3, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80204f6:	ed9b 0a00 	vldr	s0, [fp]
                    knobActive[knob] = 0;
 80204fa:	f803 e00a 	strb.w	lr, [r3, sl]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80204fe:	f10a 0a01 	add.w	sl, sl, #1
                    floatADCUI[knob] = -1.0f;
 8020502:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020506:	f005 fd47 	bl	8025f98 <tExpSmooth_setValAndDest>

                    smoothedADC[knob] = values[knob];
 802050a:	9b01      	ldr	r3, [sp, #4]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 802050c:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 8020510:	441d      	add	r5, r3
 8020512:	f8db 3000 	ldr.w	r3, [fp]
 8020516:	602b      	str	r3, [r5, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 8020518:	d034      	beq.n	8020584 <buttonCheck+0x3ac>
 802051a:	9b04      	ldr	r3, [sp, #16]
 802051c:	783a      	ldrb	r2, [r7, #0]
 802051e:	7819      	ldrb	r1, [r3, #0]
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020520:	2305      	movs	r3, #5
 8020522:	ea4f 058a 	mov.w	r5, sl, lsl #2
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020526:	2414      	movs	r4, #20
 8020528:	f248 70f8 	movw	r0, #34808	; 0x87f8
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 802052c:	f919 1001 	ldrsb.w	r1, [r9, r1]
 8020530:	fb13 a302 	smlabb	r3, r3, r2, sl
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020534:	fb14 5b06 	smlabb	fp, r4, r6, r5
 8020538:	f2c2 0001 	movt	r0, #8193	; 0x2001
 802053c:	9c03      	ldr	r4, [sp, #12]
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 802053e:	428b      	cmp	r3, r1
                    floatADCUI[knob] = -1.0f;
 8020540:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    knobActive[knob] = 0;
 8020544:	f04f 0e00 	mov.w	lr, #0
                    floatADCUI[knob] = -1.0f;
 8020548:	eb08 0c05 	add.w	ip, r8, r5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 802054c:	44a3      	add	fp, r4
 802054e:	4428      	add	r0, r5
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020550:	d1d0      	bne.n	80204f4 <buttonCheck+0x31c>
                    floatADCUI[knob] = -1.0f;
 8020552:	2300      	movs	r3, #0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020554:	9c05      	ldr	r4, [sp, #20]
 8020556:	f648 000c 	movw	r0, #34828	; 0x880c
                    knobActive[knob] = 0;
 802055a:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
 802055c:	f6cb 7380 	movt	r3, #49024	; 0xbf80
                    knobActive[knob] = 0;
 8020560:	9902      	ldr	r1, [sp, #8]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 8020562:	f10a 0a01 	add.w	sl, sl, #1
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020566:	ed94 0a00 	vldr	s0, [r4]
 802056a:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    knobActive[knob] = 0;
 802056e:	714a      	strb	r2, [r1, #5]
                    floatADCUI[knob] = -1.0f;
 8020570:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020574:	f005 fd10 	bl	8025f98 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 8020578:	6823      	ldr	r3, [r4, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 802057a:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 802057e:	9a01      	ldr	r2, [sp, #4]
 8020580:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 8020582:	d1ca      	bne.n	802051a <buttonCheck+0x342>
                        OLEDwriteString("P", 1, 110, FirstLine);
 8020584:	f240 1060 	movw	r0, #352	; 0x160
 8020588:	2300      	movs	r3, #0
 802058a:	226e      	movs	r2, #110	; 0x6e
 802058c:	2101      	movs	r1, #1
 802058e:	f6c0 0003 	movt	r0, #2051	; 0x803
 8020592:	9e06      	ldr	r6, [sp, #24]
 8020594:	f7f5 fc62 	bl	8015e5c <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
 8020598:	2300      	movs	r3, #0
 802059a:	7838      	ldrb	r0, [r7, #0]
 802059c:	2278      	movs	r2, #120	; 0x78
 802059e:	2101      	movs	r1, #1
 80205a0:	f7f5 fc90 	bl	8015ec4 <OLEDwriteInt>
                        buttonActionsUI[ButtonDown][ActionPress] = 0;
 80205a4:	2300      	movs	r3, #0
 80205a6:	7333      	strb	r3, [r6, #12]
                    if (buttonActionsUI[ButtonUp][ActionPress] == 1)
 80205a8:	7c33      	ldrb	r3, [r6, #16]
 80205aa:	2b01      	cmp	r3, #1
 80205ac:	f47f af21 	bne.w	80203f2 <buttonCheck+0x21a>
                knobPage = (knobPage + 1) % numPages[currentPreset];
 80205b0:	f240 6455 	movw	r4, #1621	; 0x655
 80205b4:	f240 6756 	movw	r7, #1622	; 0x656
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80205b8:	f642 5210 	movw	r2, #11536	; 0x2d10
                knobPage = (knobPage + 1) % numPages[currentPreset];
 80205bc:	f648 0010 	movw	r0, #34832	; 0x8810
 80205c0:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80205c4:	f2c2 0400 	movt	r4, #8192	; 0x2000
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80205c8:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80205cc:	2564      	movs	r5, #100	; 0x64
                knobPage = (knobPage + 1) % numPages[currentPreset];
 80205ce:	783b      	ldrb	r3, [r7, #0]
 80205d0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80205d4:	7821      	ldrb	r1, [r4, #0]
 80205d6:	f648 1938 	movw	r9, #35128	; 0x8938
 80205da:	f648 083c 	movw	r8, #34876	; 0x883c
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80205de:	f04f 0a00 	mov.w	sl, #0
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80205e2:	fb05 2501 	mla	r5, r5, r1, r2
                knobPage = (knobPage + 1) % numPages[currentPreset];
 80205e6:	1c5a      	adds	r2, r3, #1
 80205e8:	f647 1314 	movw	r3, #30996	; 0x7914
 80205ec:	5c40      	ldrb	r0, [r0, r1]
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 80205ee:	9504      	str	r5, [sp, #16]
 80205f0:	f648 0524 	movw	r5, #34852	; 0x8824
 80205f4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80205f8:	f2c2 0901 	movt	r9, #8193	; 0x2001
 80205fc:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8020600:	f2c2 0801 	movt	r8, #8193	; 0x2001
 8020604:	9302      	str	r3, [sp, #8]
 8020606:	9501      	str	r5, [sp, #4]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020608:	9d04      	ldr	r5, [sp, #16]
                knobPage = (knobPage + 1) % numPages[currentPreset];
 802060a:	fb92 f3f0 	sdiv	r3, r2, r0
 802060e:	fb00 2313 	mls	r3, r0, r3, r2
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 8020612:	eb03 0283 	add.w	r2, r3, r3, lsl #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
 8020616:	b2db      	uxtb	r3, r3
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 8020618:	0092      	lsls	r2, r2, #2
                knobPage = (knobPage + 1) % numPages[currentPreset];
 802061a:	703b      	strb	r3, [r7, #0]
                setKnobValues(presetKnobValues[currentPreset] + (knobPage * KNOB_PAGE_SIZE));
 802061c:	9203      	str	r2, [sp, #12]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 802061e:	3214      	adds	r2, #20
 8020620:	18aa      	adds	r2, r5, r2
 8020622:	e9cd 2604 	strd	r2, r6, [sp, #16]
 8020626:	462e      	mov	r6, r5
 8020628:	ea4f 058a 	mov.w	r5, sl, lsl #2
 802062c:	9a03      	ldr	r2, [sp, #12]
 802062e:	f248 70f8 	movw	r0, #34808	; 0x87f8
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020632:	f919 1001 	ldrsb.w	r1, [r9, r1]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020636:	eb02 0b05 	add.w	fp, r2, r5
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 802063a:	2205      	movs	r2, #5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 802063c:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    floatADCUI[knob] = -1.0f;
 8020640:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020644:	fb12 a203 	smlabb	r2, r2, r3, sl
                    knobActive[knob] = 0;
 8020648:	f04f 0e00 	mov.w	lr, #0
                    floatADCUI[knob] = -1.0f;
 802064c:	eb08 0c05 	add.w	ip, r8, r5
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020650:	44b3      	add	fp, r6
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020652:	428a      	cmp	r2, r1
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 8020654:	4428      	add	r0, r5
                    if (knob + (knobPage * KNOB_PAGE_SIZE) == cvAddParam[currentPreset])
 8020656:	f000 812c 	beq.w	80208b2 <buttonCheck+0x6da>
                    knobActive[knob] = 0;
 802065a:	9b02      	ldr	r3, [sp, #8]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 802065c:	ed9b 0a00 	vldr	s0, [fp]
                    knobActive[knob] = 0;
 8020660:	f803 e00a 	strb.w	lr, [r3, sl]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 8020664:	f10a 0a01 	add.w	sl, sl, #1
                    floatADCUI[knob] = -1.0f;
 8020668:	edcc 7a00 	vstr	s15, [ip]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 802066c:	f005 fc94 	bl	8025f98 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 8020670:	9b01      	ldr	r3, [sp, #4]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 8020672:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 8020676:	441d      	add	r5, r3
 8020678:	f8db 3000 	ldr.w	r3, [fp]
 802067c:	602b      	str	r3, [r5, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 802067e:	f000 8132 	beq.w	80208e6 <buttonCheck+0x70e>
 8020682:	783b      	ldrb	r3, [r7, #0]
 8020684:	7821      	ldrb	r1, [r4, #0]
 8020686:	e7cf      	b.n	8020628 <buttonCheck+0x450>
                        previousPreset = currentPreset;
 8020688:	f240 6455 	movw	r4, #1621	; 0x655
 802068c:	f240 22cc 	movw	r2, #716	; 0x2cc
 8020690:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8020694:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020698:	7823      	ldrb	r3, [r4, #0]
 802069a:	7013      	strb	r3, [r2, #0]
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
 802069c:	2b00      	cmp	r3, #0
 802069e:	f000 813b 	beq.w	8020918 <buttonCheck+0x740>
                        else currentPreset = (VocodecPresetType)((int)currentPreset - 1);
 80206a2:	3b01      	subs	r3, #1
 80206a4:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
 80206a6:	f240 6257 	movw	r2, #1623	; 0x657
 80206aa:	2101      	movs	r1, #1
 80206ac:	7023      	strb	r3, [r4, #0]
 80206ae:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80206b2:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
 80206b4:	f7f5 f98a 	bl	80159cc <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
 80206b8:	f240 0318 	movw	r3, #24
 80206bc:	7821      	ldrb	r1, [r4, #0]
 80206be:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80206c2:	8818      	ldrh	r0, [r3, #0]
 80206c4:	f7f3 fa88 	bl	8013bd8 <EE_WriteVariable>
 80206c8:	b108      	cbz	r0, 80206ce <buttonCheck+0x4f6>
                    Error_Handler();
 80206ca:	f7f5 f8cb 	bl	8015864 <Error_Handler>
                        buttonActionsSFX[b][a] = 0;
 80206ce:	f248 62e4 	movw	r2, #34532	; 0x86e4
                        buttonActionsUI[b][a] = 0;
 80206d2:	2300      	movs	r3, #0
 80206d4:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
 80206d6:	f2c2 0201 	movt	r2, #8193	; 0x2001
                        buttonActionsUI[b][a] = 0;
 80206da:	60b3      	str	r3, [r6, #8]
 80206dc:	6033      	str	r3, [r6, #0]
 80206de:	6073      	str	r3, [r6, #4]
                        buttonActionsSFX[b][a] = 0;
 80206e0:	6013      	str	r3, [r2, #0]
 80206e2:	6053      	str	r3, [r2, #4]
 80206e4:	6093      	str	r3, [r2, #8]
 80206e6:	60d3      	str	r3, [r2, #12]
 80206e8:	6113      	str	r3, [r2, #16]
 80206ea:	6153      	str	r3, [r2, #20]
 80206ec:	6193      	str	r3, [r2, #24]
 80206ee:	61d3      	str	r3, [r2, #28]
 80206f0:	6213      	str	r3, [r2, #32]
 80206f2:	6253      	str	r3, [r2, #36]	; 0x24
 80206f4:	6293      	str	r3, [r2, #40]	; 0x28
                        buttonActionsUI[b][a] = 0;
 80206f6:	60f3      	str	r3, [r6, #12]
 80206f8:	6133      	str	r3, [r6, #16]
 80206fa:	6173      	str	r3, [r6, #20]
 80206fc:	61b3      	str	r3, [r6, #24]
 80206fe:	61f3      	str	r3, [r6, #28]
 8020700:	6233      	str	r3, [r6, #32]
 8020702:	6273      	str	r3, [r6, #36]	; 0x24
 8020704:	62b3      	str	r3, [r6, #40]	; 0x28
 8020706:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020708:	7019      	strb	r1, [r3, #0]
 802070a:	9b08      	ldr	r3, [sp, #32]
 802070c:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonRight][ActionPress] == 1)
 802070e:	7a33      	ldrb	r3, [r6, #8]
 8020710:	2b01      	cmp	r3, #1
 8020712:	f47f ae53 	bne.w	80203bc <buttonCheck+0x1e4>
                        previousPreset = currentPreset;
 8020716:	f240 6455 	movw	r4, #1621	; 0x655
 802071a:	f240 22cc 	movw	r2, #716	; 0x2cc
 802071e:	f2c2 0400 	movt	r4, #8192	; 0x2000
 8020722:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020726:	7823      	ldrb	r3, [r4, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 8020728:	2b10      	cmp	r3, #16
                        previousPreset = currentPreset;
 802072a:	7013      	strb	r3, [r2, #0]
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 802072c:	f200 80f2 	bhi.w	8020914 <buttonCheck+0x73c>
                        else currentPreset = (VocodecPresetType)((int)currentPreset + 1);
 8020730:	3301      	adds	r3, #1
 8020732:	b2db      	uxtb	r3, r3
                        loadingPreset = 1;
 8020734:	f240 6257 	movw	r2, #1623	; 0x657
 8020738:	2101      	movs	r1, #1
 802073a:	7023      	strb	r3, [r4, #0]
 802073c:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020740:	7011      	strb	r1, [r2, #0]
                        OLED_writePreset();
 8020742:	f7f5 f943 	bl	80159cc <OLED_writePreset>
                if((EE_WriteVariable(VirtAddVarTab[0],  currentPreset)) != HAL_OK)
 8020746:	f240 0318 	movw	r3, #24
 802074a:	7821      	ldrb	r1, [r4, #0]
 802074c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020750:	8818      	ldrh	r0, [r3, #0]
 8020752:	f7f3 fa41 	bl	8013bd8 <EE_WriteVariable>
 8020756:	b108      	cbz	r0, 802075c <buttonCheck+0x584>
                    Error_Handler();
 8020758:	f7f5 f884 	bl	8015864 <Error_Handler>
                        buttonActionsSFX[b][a] = 0;
 802075c:	f248 62e4 	movw	r2, #34532	; 0x86e4
                        buttonActionsUI[b][a] = 0;
 8020760:	2300      	movs	r3, #0
 8020762:	21ff      	movs	r1, #255	; 0xff
                        buttonActionsSFX[b][a] = 0;
 8020764:	f2c2 0201 	movt	r2, #8193	; 0x2001
                        buttonActionsUI[b][a] = 0;
 8020768:	6233      	str	r3, [r6, #32]
 802076a:	6033      	str	r3, [r6, #0]
 802076c:	6073      	str	r3, [r6, #4]
                        buttonActionsSFX[b][a] = 0;
 802076e:	6013      	str	r3, [r2, #0]
 8020770:	6053      	str	r3, [r2, #4]
 8020772:	6093      	str	r3, [r2, #8]
 8020774:	60d3      	str	r3, [r2, #12]
 8020776:	6113      	str	r3, [r2, #16]
 8020778:	6153      	str	r3, [r2, #20]
 802077a:	6193      	str	r3, [r2, #24]
 802077c:	61d3      	str	r3, [r2, #28]
 802077e:	6213      	str	r3, [r2, #32]
 8020780:	6253      	str	r3, [r2, #36]	; 0x24
 8020782:	6293      	str	r3, [r2, #40]	; 0x28
                        buttonActionsUI[b][a] = 0;
 8020784:	60b3      	str	r3, [r6, #8]
 8020786:	60f3      	str	r3, [r6, #12]
 8020788:	6133      	str	r3, [r6, #16]
 802078a:	6173      	str	r3, [r6, #20]
 802078c:	61b3      	str	r3, [r6, #24]
 802078e:	61f3      	str	r3, [r6, #28]
 8020790:	6273      	str	r3, [r6, #36]	; 0x24
 8020792:	62b3      	str	r3, [r6, #40]	; 0x28
 8020794:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8020796:	7019      	strb	r1, [r3, #0]
 8020798:	9b08      	ldr	r3, [sp, #32]
 802079a:	7019      	strb	r1, [r3, #0]
                    if (buttonActionsUI[ButtonD][ActionPress] == 1)
 802079c:	f896 3020 	ldrb.w	r3, [r6, #32]
 80207a0:	2b01      	cmp	r3, #1
 80207a2:	f47f ae10 	bne.w	80203c6 <buttonCheck+0x1ee>
                        if (currentTuning == 0)
 80207a6:	f240 6250 	movw	r2, #1616	; 0x650
 80207aa:	f2c2 0200 	movt	r2, #8192	; 0x2000
 80207ae:	6813      	ldr	r3, [r2, #0]
 80207b0:	2b00      	cmp	r3, #0
 80207b2:	f040 80ad 	bne.w	8020910 <buttonCheck+0x738>
                            currentTuning = NUM_TUNINGS - 1;
 80207b6:	233e      	movs	r3, #62	; 0x3e
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 80207b8:	f64e 6404 	movw	r4, #60932	; 0xee04
 80207bc:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 80207c0:	f240 6720 	movw	r7, #1568	; 0x620
 80207c4:	6013      	str	r3, [r2, #0]
 80207c6:	f6c0 0402 	movt	r4, #2050	; 0x802
 80207ca:	f2c2 0700 	movt	r7, #8192	; 0x2000
 80207ce:	eb04 1401 	add.w	r4, r4, r1, lsl #4
 80207d2:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 80207d6:	6820      	ldr	r0, [r4, #0]
 80207d8:	3410      	adds	r4, #16
 80207da:	f854 1c0c 	ldr.w	r1, [r4, #-12]
 80207de:	463d      	mov	r5, r7
 80207e0:	f854 2c08 	ldr.w	r2, [r4, #-8]
 80207e4:	3710      	adds	r7, #16
 80207e6:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80207ea:	4564      	cmp	r4, ip
 80207ec:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80207ee:	d1f2      	bne.n	80207d6 <buttonCheck+0x5fe>
                if (currentPreset == AutotuneMono)
 80207f0:	f240 6355 	movw	r3, #1621	; 0x655
 80207f4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 80207f8:	781b      	ldrb	r3, [r3, #0]
 80207fa:	2b03      	cmp	r3, #3
 80207fc:	f000 8097 	beq.w	802092e <buttonCheck+0x756>
                        OLED_writeTuning();
 8020800:	f7f5 fa76 	bl	8015cf0 <OLED_writeTuning>
                        buttonActionsUI[ButtonD][ActionPress] = 0;
 8020804:	2300      	movs	r3, #0
 8020806:	f886 3020 	strb.w	r3, [r6, #32]
                    if (buttonActionsUI[ButtonE][ActionPress] == 1)
 802080a:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 802080e:	2b01      	cmp	r3, #1
 8020810:	f47f adde 	bne.w	80203d0 <buttonCheck+0x1f8>
 8020814:	e00b      	b.n	802082e <buttonCheck+0x656>
                        OLED_writeEditScreen();
 8020816:	f7f5 fa0d 	bl	8015c34 <OLED_writeEditScreen>
                        setLED_Edit(1);
 802081a:	2001      	movs	r0, #1
 802081c:	f7f5 f826 	bl	801586c <setLED_Edit>
                        buttonActionsUI[ButtonEdit][ActionPress] = 0;
 8020820:	2300      	movs	r3, #0
 8020822:	7033      	strb	r3, [r6, #0]
                    if (buttonActionsUI[ButtonEdit][ActionHoldContinuous] == 1)
 8020824:	78f3      	ldrb	r3, [r6, #3]
 8020826:	2b01      	cmp	r3, #1
 8020828:	f47f add9 	bne.w	80203de <buttonCheck+0x206>
 802082c:	e5fc      	b.n	8020428 <buttonCheck+0x250>
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 802082e:	f240 6150 	movw	r1, #1616	; 0x650
 8020832:	f244 1305 	movw	r3, #16645	; 0x4105
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 8020836:	f64e 6404 	movw	r4, #60932	; 0xee04
 802083a:	f240 6720 	movw	r7, #1568	; 0x620
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 802083e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020842:	f2c0 4310 	movt	r3, #1040	; 0x410
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 8020846:	f6c0 0402 	movt	r4, #2050	; 0x802
 802084a:	f2c2 0700 	movt	r7, #8192	; 0x2000
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 802084e:	680a      	ldr	r2, [r1, #0]
 8020850:	3201      	adds	r2, #1
 8020852:	fba3 0302 	umull	r0, r3, r3, r2
 8020856:	1ad0      	subs	r0, r2, r3
 8020858:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 802085c:	095b      	lsrs	r3, r3, #5
 802085e:	ebc3 1383 	rsb	r3, r3, r3, lsl #6
 8020862:	1ad3      	subs	r3, r2, r3
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 8020864:	eb03 0243 	add.w	r2, r3, r3, lsl #1
                        currentTuning = (currentTuning + 1) % NUM_TUNINGS;
 8020868:	600b      	str	r3, [r1, #0]
                    centsDeviation[i] = tuningPresets[currentTuning][i];
 802086a:	eb04 1402 	add.w	r4, r4, r2, lsl #4
 802086e:	f104 0c30 	add.w	ip, r4, #48	; 0x30
 8020872:	6820      	ldr	r0, [r4, #0]
 8020874:	3410      	adds	r4, #16
 8020876:	f854 1c0c 	ldr.w	r1, [r4, #-12]
 802087a:	463d      	mov	r5, r7
 802087c:	f854 2c08 	ldr.w	r2, [r4, #-8]
 8020880:	3710      	adds	r7, #16
 8020882:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8020886:	4564      	cmp	r4, ip
 8020888:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 802088a:	d1f2      	bne.n	8020872 <buttonCheck+0x69a>
                if (currentPreset == AutotuneMono)
 802088c:	f240 6355 	movw	r3, #1621	; 0x655
 8020890:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020894:	781b      	ldrb	r3, [r3, #0]
 8020896:	2b03      	cmp	r3, #3
 8020898:	d101      	bne.n	802089e <buttonCheck+0x6c6>
                    calculateNoteArray();
 802089a:	f7fd fdcd 	bl	801e438 <calculateNoteArray>
                        OLED_writeTuning();
 802089e:	f7f5 fa27 	bl	8015cf0 <OLED_writeTuning>
                        buttonActionsUI[ButtonE][ActionPress] = 0;
 80208a2:	2300      	movs	r3, #0
 80208a4:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
                    if (buttonActionsUI[ButtonEdit][ActionPress])
 80208a8:	7833      	ldrb	r3, [r6, #0]
 80208aa:	2b00      	cmp	r3, #0
 80208ac:	f43f ad94 	beq.w	80203d8 <buttonCheck+0x200>
 80208b0:	e7b1      	b.n	8020816 <buttonCheck+0x63e>
                    floatADCUI[knob] = -1.0f;
 80208b2:	2300      	movs	r3, #0
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80208b4:	9d04      	ldr	r5, [sp, #16]
 80208b6:	f648 000c 	movw	r0, #34828	; 0x880c
                    knobActive[knob] = 0;
 80208ba:	2200      	movs	r2, #0
                    floatADCUI[knob] = -1.0f;
 80208bc:	f6cb 7380 	movt	r3, #49024	; 0xbf80
                    knobActive[knob] = 0;
 80208c0:	9902      	ldr	r1, [sp, #8]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80208c2:	f10a 0a01 	add.w	sl, sl, #1
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80208c6:	ed95 0a00 	vldr	s0, [r5]
 80208ca:	f2c2 0001 	movt	r0, #8193	; 0x2001
                    knobActive[knob] = 0;
 80208ce:	714a      	strb	r2, [r1, #5]
                    floatADCUI[knob] = -1.0f;
 80208d0:	f8c8 3014 	str.w	r3, [r8, #20]
                    tExpSmooth_setValAndDest(&adc[knob], values[knob]);
 80208d4:	f005 fb60 	bl	8025f98 <tExpSmooth_setValAndDest>
                    smoothedADC[knob] = values[knob];
 80208d8:	682b      	ldr	r3, [r5, #0]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80208da:	f1ba 0f05 	cmp.w	sl, #5
                    smoothedADC[knob] = values[knob];
 80208de:	9a01      	ldr	r2, [sp, #4]
 80208e0:	6153      	str	r3, [r2, #20]
                for (int i = 0; i < KNOB_PAGE_SIZE; i++)
 80208e2:	f47f aece 	bne.w	8020682 <buttonCheck+0x4aa>
                        OLEDwriteString("P", 1, 110, FirstLine);
 80208e6:	f240 1060 	movw	r0, #352	; 0x160
 80208ea:	2300      	movs	r3, #0
 80208ec:	226e      	movs	r2, #110	; 0x6e
 80208ee:	2101      	movs	r1, #1
 80208f0:	f6c0 0003 	movt	r0, #2051	; 0x803
 80208f4:	9e05      	ldr	r6, [sp, #20]
 80208f6:	f7f5 fab1 	bl	8015e5c <OLEDwriteString>
                        OLEDwriteInt(knobPage, 1, 120, FirstLine);
 80208fa:	7838      	ldrb	r0, [r7, #0]
 80208fc:	2300      	movs	r3, #0
 80208fe:	2278      	movs	r2, #120	; 0x78
 8020900:	2101      	movs	r1, #1
 8020902:	f7f5 fadf 	bl	8015ec4 <OLEDwriteInt>
                        buttonActionsUI[ButtonUp][ActionPress] = 0;
 8020906:	2300      	movs	r3, #0
 8020908:	7433      	strb	r3, [r6, #16]
            }
 802090a:	b00b      	add	sp, #44	; 0x2c
 802090c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                            currentTuning = (currentTuning - 1);
 8020910:	3b01      	subs	r3, #1
 8020912:	e751      	b.n	80207b8 <buttonCheck+0x5e0>
                        if (currentPreset >= PresetNil - 1) currentPreset = (VocodecPresetType)0;
 8020914:	2300      	movs	r3, #0
 8020916:	e70d      	b.n	8020734 <buttonCheck+0x55c>
                        if (currentPreset <= 0) currentPreset = (VocodecPresetType)((int)PresetNil - 1);
 8020918:	2311      	movs	r3, #17
 802091a:	e6c4      	b.n	80206a6 <buttonCheck+0x4ce>
                if (knobPage == 0) knobPage = numPages[currentPreset] - 1;
 802091c:	f648 0310 	movw	r3, #34832	; 0x8810
 8020920:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8020924:	5c5b      	ldrb	r3, [r3, r1]
 8020926:	3b01      	subs	r3, #1
 8020928:	b2db      	uxtb	r3, r3
 802092a:	461d      	mov	r5, r3
 802092c:	e5ba      	b.n	80204a4 <buttonCheck+0x2cc>
                    calculateNoteArray();
 802092e:	f7fd fd83 	bl	801e438 <calculateNoteArray>
 8020932:	e765      	b.n	8020800 <buttonCheck+0x628>
                            keyCenter = (keyCenter + 1) % 12;
 8020934:	f240 6554 	movw	r5, #1620	; 0x654
 8020938:	f64a 23ab 	movw	r3, #43691	; 0xaaab
                            OLEDclearLine(SecondLine);
 802093c:	4620      	mov	r0, r4
                            keyCenter = (keyCenter + 1) % 12;
 802093e:	f2c2 0500 	movt	r5, #8192	; 0x2000
 8020942:	f6ca 23aa 	movt	r3, #43690	; 0xaaaa
 8020946:	782a      	ldrb	r2, [r5, #0]
 8020948:	3201      	adds	r2, #1
 802094a:	fba3 1302 	umull	r1, r3, r3, r2
 802094e:	08db      	lsrs	r3, r3, #3
 8020950:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8020954:	eba2 0383 	sub.w	r3, r2, r3, lsl #2
 8020958:	702b      	strb	r3, [r5, #0]
                            OLEDclearLine(SecondLine);
 802095a:	f7f5 fa69 	bl	8015e30 <OLEDclearLine>
                            OLEDwriteString("KEY: ", 5, 0, SecondLine);
 802095e:	f64f 30c4 	movw	r0, #64452	; 0xfbc4
 8020962:	2200      	movs	r2, #0
 8020964:	4623      	mov	r3, r4
 8020966:	2105      	movs	r1, #5
 8020968:	f6c0 0002 	movt	r0, #2050	; 0x802
 802096c:	f7f5 fa76 	bl	8015e5c <OLEDwriteString>
                            OLEDwritePitchClass(keyCenter+60, 64, SecondLine);
 8020970:	782b      	ldrb	r3, [r5, #0]
 8020972:	4621      	mov	r1, r4
 8020974:	2040      	movs	r0, #64	; 0x40
 8020976:	333c      	adds	r3, #60	; 0x3c
 8020978:	ee00 3a10 	vmov	s0, r3
 802097c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8020980:	f7f5 fb16 	bl	8015fb0 <OLEDwritePitchClass>
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
 8020984:	f248 62e4 	movw	r2, #34532	; 0x86e4
                            buttonActionsUI[ButtonC][ActionPress] = 0;
 8020988:	2300      	movs	r3, #0
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
 802098a:	f2c2 0201 	movt	r2, #8193	; 0x2001
                            buttonActionsUI[ButtonC][ActionPress] = 0;
 802098e:	7733      	strb	r3, [r6, #28]
                            buttonActionsSFX[ButtonC][ActionPress] = 0;
 8020990:	7713      	strb	r3, [r2, #28]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 8020992:	70f3      	strb	r3, [r6, #3]
 8020994:	e54c      	b.n	8020430 <buttonCheck+0x258>
 8020996:	bf00      	nop

08020998 <adcCheck>:
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 8020998:	f241 0180 	movw	r1, #4224	; 0x1080
 802099c:	f04f 526a 	mov.w	r2, #981467136	; 0x3a800000
 80209a0:	f248 63cc 	movw	r3, #34508	; 0x86cc
 80209a4:	f2c3 0100 	movt	r1, #12288	; 0x3000
 80209a8:	ee07 2a90 	vmov	s15, r2
 80209ac:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 80209b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 80209b4:	880c      	ldrh	r4, [r1, #0]
                if (firstADCPass)
 80209b6:	f240 25c8 	movw	r5, #712	; 0x2c8
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 80209ba:	8848      	ldrh	r0, [r1, #2]
            {
 80209bc:	b083      	sub	sp, #12
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 80209be:	888a      	ldrh	r2, [r1, #4]
 80209c0:	09a4      	lsrs	r4, r4, #6
 80209c2:	0980      	lsrs	r0, r0, #6
                if (firstADCPass)
 80209c4:	f2c2 0500 	movt	r5, #8192	; 0x2000
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 80209c8:	ee04 4a90 	vmov	s9, r4
 80209cc:	0992      	lsrs	r2, r2, #6
 80209ce:	88cc      	ldrh	r4, [r1, #6]
 80209d0:	ee05 0a10 	vmov	s10, r0
 80209d4:	ee05 2a90 	vmov	s11, r2
 80209d8:	8908      	ldrh	r0, [r1, #8]
 80209da:	894a      	ldrh	r2, [r1, #10]
 80209dc:	09a1      	lsrs	r1, r4, #6
 80209de:	eef8 4ae4 	vcvt.f32.s32	s9, s9
 80209e2:	ee06 1a10 	vmov	s12, r1
 80209e6:	0992      	lsrs	r2, r2, #6
 80209e8:	0981      	lsrs	r1, r0, #6
 80209ea:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
 80209ee:	ee07 2a10 	vmov	s14, r2
 80209f2:	eef8 5ae5 	vcvt.f32.s32	s11, s11
 80209f6:	ee06 1a90 	vmov	s13, r1
 80209fa:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 80209fe:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
                if (firstADCPass)
 8020a02:	6829      	ldr	r1, [r5, #0]
                    floatADC[i] = (float) (ADC_values[i]>>6) * INV_TWO_TO_10;
 8020a04:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8020a08:	ee64 4aa7 	vmul.f32	s9, s9, s15
 8020a0c:	ee25 5a27 	vmul.f32	s10, s10, s15
 8020a10:	ee65 5aa7 	vmul.f32	s11, s11, s15
 8020a14:	ee26 6a27 	vmul.f32	s12, s12, s15
 8020a18:	edc3 4a00 	vstr	s9, [r3]
 8020a1c:	ee66 6aa7 	vmul.f32	s13, s13, s15
 8020a20:	ed83 5a01 	vstr	s10, [r3, #4]
 8020a24:	ee67 7a27 	vmul.f32	s15, s14, s15
 8020a28:	edc3 5a02 	vstr	s11, [r3, #8]
 8020a2c:	ed83 6a03 	vstr	s12, [r3, #12]
 8020a30:	edc3 6a04 	vstr	s13, [r3, #16]
 8020a34:	edc3 7a05 	vstr	s15, [r3, #20]
                if (firstADCPass)
 8020a38:	b161      	cbz	r1, 8020a54 <adcCheck+0xbc>
 8020a3a:	461c      	mov	r4, r3
 8020a3c:	f648 164c 	movw	r6, #35148	; 0x894c
                    firstADCPass = 0;
 8020a40:	2300      	movs	r3, #0
 8020a42:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8020a46:	602b      	str	r3, [r5, #0]
 8020a48:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 8020a4a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8020a4c:	e894 0003 	ldmia.w	r4, {r0, r1}
 8020a50:	e886 0003 	stmia.w	r6, {r0, r1}
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020a54:	f248 73f8 	movw	r3, #34808	; 0x87f8
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020a58:	f648 1238 	movw	r2, #35128	; 0x8938
 8020a5c:	f248 65cc 	movw	r5, #34508	; 0x86cc
 8020a60:	f648 164c 	movw	r6, #35148	; 0x894c
 8020a64:	f648 043c 	movw	r4, #34876	; 0x883c
 8020a68:	f648 0724 	movw	r7, #34852	; 0x8824
 8020a6c:	f240 28b8 	movw	r8, #696	; 0x2b8
 8020a70:	f647 1914 	movw	r9, #30996	; 0x7914
                            else writeKnobFlag = i;
 8020a74:	f240 2acf 	movw	sl, #719	; 0x2cf
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020a78:	f2c2 0301 	movt	r3, #8193	; 0x2001
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020a7c:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8020a80:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8020a84:	f2c2 0601 	movt	r6, #8193	; 0x2001
 8020a88:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8020a8c:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8020a90:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8020a94:	f2c2 0901 	movt	r9, #8193	; 0x2001
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020a98:	9300      	str	r3, [sp, #0]
                            else writeKnobFlag = i;
 8020a9a:	f2c2 0a00 	movt	sl, #8192	; 0x2000
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020a9e:	9201      	str	r2, [sp, #4]
            {
 8020aa0:	f04f 0b00 	mov.w	fp, #0
 8020aa4:	e03a      	b.n	8020b1c <adcCheck+0x184>
                        if (buttonActionsUI[ButtonEdit][ActionHoldContinuous])
 8020aa6:	f648 0254 	movw	r2, #34900	; 0x8854
 8020aaa:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8020aae:	78d1      	ldrb	r1, [r2, #3]
 8020ab0:	b199      	cbz	r1, 8020ada <adcCheck+0x142>
                            if (i != 5) cvAddParam[currentPreset] = i + (knobPage * KNOB_PAGE_SIZE);;
 8020ab2:	f1bb 0f05 	cmp.w	fp, #5
 8020ab6:	d00e      	beq.n	8020ad6 <adcCheck+0x13e>
 8020ab8:	f240 6156 	movw	r1, #1622	; 0x656
 8020abc:	f240 6055 	movw	r0, #1621	; 0x655
 8020ac0:	9b01      	ldr	r3, [sp, #4]
 8020ac2:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020ac6:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8020aca:	7809      	ldrb	r1, [r1, #0]
 8020acc:	7800      	ldrb	r0, [r0, #0]
 8020ace:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8020ad2:	4459      	add	r1, fp
 8020ad4:	5419      	strb	r1, [r3, r0]
                            buttonActionsUI[ButtonEdit][ActionHoldContinuous] = 0;
 8020ad6:	2100      	movs	r1, #0
 8020ad8:	70d1      	strb	r1, [r2, #3]
                        lastFloatADC[i] = floatADC[i];
 8020ada:	ed15 0a01 	vldr	s0, [r5, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020ade:	f1bb 0f05 	cmp.w	fp, #5
                        lastFloatADC[i] = floatADC[i];
 8020ae2:	ed06 0a01 	vstr	s0, [r6, #-4]
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020ae6:	d065      	beq.n	8020bb4 <adcCheck+0x21c>
                        else writeKnobFlag = i;
 8020ae8:	fa4f f28b 	sxtb.w	r2, fp
                    if (floatADCUI[i] >= 0.0f)
 8020aec:	edd4 7a00 	vldr	s15, [r4]
                        knobActive[i] = 1;
 8020af0:	2101      	movs	r1, #1
 8020af2:	f88a 2000 	strb.w	r2, [sl]
                    if (floatADCUI[i] >= 0.0f)
 8020af6:	eef5 7ac0 	vcmpe.f32	s15, #0.0
                        knobActive[i] = 1;
 8020afa:	f809 100b 	strb.w	r1, [r9, fp]
                    if (floatADCUI[i] >= 0.0f)
 8020afe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b02:	da28      	bge.n	8020b56 <adcCheck+0x1be>
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020b04:	9b00      	ldr	r3, [sp, #0]
 8020b06:	eb03 008b 	add.w	r0, r3, fp, lsl #2
 8020b0a:	f005 fa41 	bl	8025f90 <tExpSmooth_setDest>
                for (int i = 0; i < 6; i++)
 8020b0e:	f10b 0b01 	add.w	fp, fp, #1
 8020b12:	3404      	adds	r4, #4
 8020b14:	3704      	adds	r7, #4
 8020b16:	f1bb 0f06 	cmp.w	fp, #6
 8020b1a:	d048      	beq.n	8020bae <adcCheck+0x216>
                    if (fastabsf(floatADC[i] - lastFloatADC[i]) > adcHysteresisThreshold)
 8020b1c:	ecf6 7a01 	vldmia	r6!, {s15}
 8020b20:	ecb5 0a01 	vldmia	r5!, {s0}
 8020b24:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020b28:	f006 fe5a 	bl	80277e0 <fastabsf>
 8020b2c:	edd8 7a00 	vldr	s15, [r8]
 8020b30:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8020b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b38:	dcb5      	bgt.n	8020aa6 <adcCheck+0x10e>
                    if (floatADCUI[i] >= 0.0f)
 8020b3a:	edd4 7a00 	vldr	s15, [r4]
 8020b3e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8020b42:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b46:	da06      	bge.n	8020b56 <adcCheck+0x1be>
 8020b48:	f819 200b 	ldrb.w	r2, [r9, fp]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020b4c:	2a00      	cmp	r2, #0
 8020b4e:	d0de      	beq.n	8020b0e <adcCheck+0x176>
 8020b50:	ed15 0a01 	vldr	s0, [r5, #-4]
 8020b54:	e7d6      	b.n	8020b04 <adcCheck+0x16c>
                        if (fastabsf(smoothedADC[i] - floatADCUI[i]) > adcHysteresisThreshold)
 8020b56:	ed97 0a00 	vldr	s0, [r7]
 8020b5a:	ee30 0a67 	vsub.f32	s0, s0, s15
 8020b5e:	f006 fe3f 	bl	80277e0 <fastabsf>
 8020b62:	edd8 7a00 	vldr	s15, [r8]
 8020b66:	f819 200b 	ldrb.w	r2, [r9, fp]
 8020b6a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8020b6e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8020b72:	ddeb      	ble.n	8020b4c <adcCheck+0x1b4>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020b74:	f1bb 0f05 	cmp.w	fp, #5
 8020b78:	d004      	beq.n	8020b84 <adcCheck+0x1ec>
                            else writeKnobFlag = i;
 8020b7a:	f88a b000 	strb.w	fp, [sl]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020b7e:	2a00      	cmp	r2, #0
 8020b80:	d0c5      	beq.n	8020b0e <adcCheck+0x176>
 8020b82:	e7e5      	b.n	8020b50 <adcCheck+0x1b8>
                            if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020b84:	f240 6156 	movw	r1, #1622	; 0x656
 8020b88:	f240 6055 	movw	r0, #1621	; 0x655
 8020b8c:	9b01      	ldr	r3, [sp, #4]
 8020b8e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020b92:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8020b96:	7809      	ldrb	r1, [r1, #0]
 8020b98:	7800      	ldrb	r0, [r0, #0]
 8020b9a:	ebc1 1c81 	rsb	ip, r1, r1, lsl #6
 8020b9e:	5c18      	ldrb	r0, [r3, r0]
 8020ba0:	ebc1 018c 	rsb	r1, r1, ip, lsl #2
 8020ba4:	4401      	add	r1, r0
 8020ba6:	f88a 1000 	strb.w	r1, [sl]
                    if (knobActive[i]) tExpSmooth_setDest(&adc[i], floatADC[i]);
 8020baa:	2a00      	cmp	r2, #0
 8020bac:	d1d0      	bne.n	8020b50 <adcCheck+0x1b8>
            }
 8020bae:	b003      	add	sp, #12
 8020bb0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                        if (i == 5) writeKnobFlag = cvAddParam[currentPreset] - (knobPage * KNOB_PAGE_SIZE);
 8020bb4:	f240 6156 	movw	r1, #1622	; 0x656
 8020bb8:	f240 6255 	movw	r2, #1621	; 0x655
 8020bbc:	9b01      	ldr	r3, [sp, #4]
 8020bbe:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020bc2:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020bc6:	7809      	ldrb	r1, [r1, #0]
 8020bc8:	7812      	ldrb	r2, [r2, #0]
 8020bca:	ebc1 1081 	rsb	r0, r1, r1, lsl #6
 8020bce:	5c9a      	ldrb	r2, [r3, r2]
 8020bd0:	ebc1 0180 	rsb	r1, r1, r0, lsl #2
 8020bd4:	440a      	add	r2, r1
 8020bd6:	b252      	sxtb	r2, r2
 8020bd8:	e788      	b.n	8020aec <adcCheck+0x154>
 8020bda:	bf00      	nop

08020bdc <resetKnobValues>:
            {
 8020bdc:	f648 0324 	movw	r3, #34852	; 0x8824
                    floatADCUI[i] = -1.0f;
 8020be0:	2000      	movs	r0, #0
                    knobActive[i] = 0;
 8020be2:	f04f 0c00 	mov.w	ip, #0
                    floatADCUI[i] = -1.0f;
 8020be6:	f6cb 7080 	movt	r0, #49024	; 0xbf80
 8020bea:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8020bee:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
                    knobActive[i] = 0;
 8020bf2:	f647 1914 	movw	r9, #30996	; 0x7914
                    floatADCUI[i] = -1.0f;
 8020bf6:	f648 0b3c 	movw	fp, #34876	; 0x883c
 8020bfa:	f248 75f8 	movw	r5, #34808	; 0x87f8
 8020bfe:	f642 5810 	movw	r8, #11536	; 0x2d10
 8020c02:	f240 6755 	movw	r7, #1621	; 0x655
 8020c06:	f240 6656 	movw	r6, #1622	; 0x656
                    knobActive[i] = 0;
 8020c0a:	f2c2 0901 	movt	r9, #8193	; 0x2001
                    floatADCUI[i] = -1.0f;
 8020c0e:	f2c2 0b01 	movt	fp, #8193	; 0x2001
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8020c12:	4664      	mov	r4, ip
 8020c14:	469a      	mov	sl, r3
 8020c16:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8020c1a:	f2c2 0800 	movt	r8, #8192	; 0x2000
 8020c1e:	f2c2 0700 	movt	r7, #8192	; 0x2000
 8020c22:	f2c2 0600 	movt	r6, #8192	; 0x2000
                    knobActive[i] = 0;
 8020c26:	f809 cb01 	strb.w	ip, [r9], #1
                    floatADCUI[i] = -1.0f;
 8020c2a:	f84b 0b04 	str.w	r0, [fp], #4
            {
 8020c2e:	ed2d 8b02 	vpush	{d8}
                    floatADCUI[i] = -1.0f;
 8020c32:	ee08 0a90 	vmov	s17, r0
            {
 8020c36:	b083      	sub	sp, #12
 8020c38:	9301      	str	r3, [sp, #4]
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 8020c3a:	783b      	ldrb	r3, [r7, #0]
 8020c3c:	2105      	movs	r1, #5
 8020c3e:	7832      	ldrb	r2, [r6, #0]
                    tExpSmooth_setValAndDest(&adc[i], value);
 8020c40:	4628      	mov	r0, r5
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 8020c42:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8020c46:	3504      	adds	r5, #4
 8020c48:	fb11 4202 	smlabb	r2, r1, r2, r4
                for (int i = 0; i < NUM_ADC_CHANNELS; i++)
 8020c4c:	3401      	adds	r4, #1
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 8020c4e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 8020c52:	4413      	add	r3, r2
 8020c54:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8020c58:	ed93 8a00 	vldr	s16, [r3]
                    tExpSmooth_setValAndDest(&adc[i], value);
 8020c5c:	eeb0 0a48 	vmov.f32	s0, s16
 8020c60:	f005 f99a 	bl	8025f98 <tExpSmooth_setValAndDest>
                    knobActive[i] = 0;
 8020c64:	f04f 0300 	mov.w	r3, #0
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 8020c68:	2c05      	cmp	r4, #5
                    smoothedADC[i] = value;
 8020c6a:	ecaa 8a01 	vstmia	sl!, {s16}
                    knobActive[i] = 0;
 8020c6e:	f809 3b01 	strb.w	r3, [r9], #1
                    floatADCUI[i] = -1.0f;
 8020c72:	eceb 8a01 	vstmia	fp!, {s17}
                    if (i != 5) value = presetKnobValues[currentPreset][i + (knobPage * KNOB_PAGE_SIZE)];
 8020c76:	d1e0      	bne.n	8020c3a <resetKnobValues+0x5e>
                    tExpSmooth_setValAndDest(&adc[i], value);
 8020c78:	2300      	movs	r3, #0
 8020c7a:	f648 000c 	movw	r0, #34828	; 0x880c
 8020c7e:	ee00 3a10 	vmov	s0, r3
 8020c82:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8020c86:	ee08 3a10 	vmov	s16, r3
 8020c8a:	f005 f985 	bl	8025f98 <tExpSmooth_setValAndDest>
                    smoothedADC[i] = value;
 8020c8e:	9b01      	ldr	r3, [sp, #4]
 8020c90:	ed83 8a05 	vstr	s16, [r3, #20]
            }
 8020c94:	b003      	add	sp, #12
 8020c96:	ecbd 8b02 	vpop	{d8}
 8020c9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8020c9e:	bf00      	nop

08020ca0 <UIVocoderButtons>:
            }

            const char* UIVocoderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8020ca0:	f648 0354 	movw	r3, #34900	; 0x8854
 8020ca4:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8020ca8:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8020caa:	7d1a      	ldrb	r2, [r3, #20]
 8020cac:	2a01      	cmp	r2, #1
 8020cae:	d030      	beq.n	8020d12 <UIVocoderButtons+0x72>
                const char* writeString = "";
 8020cb0:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020cb4:	f6c0 0002 	movt	r0, #2050	; 0x802
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 8020cb8:	7e1a      	ldrb	r2, [r3, #24]
 8020cba:	2a01      	cmp	r2, #1
 8020cbc:	d111      	bne.n	8020ce2 <UIVocoderButtons+0x42>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020cbe:	f240 519c 	movw	r1, #1436	; 0x59c
 8020cc2:	f64f 307c 	movw	r0, #64380	; 0xfb7c
 8020cc6:	f64f 3288 	movw	r2, #64392	; 0xfb88
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020cca:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020ccc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020cd0:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020cd4:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020cd8:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020cda:	7809      	ldrb	r1, [r1, #0]
 8020cdc:	42a1      	cmp	r1, r4
 8020cde:	bf08      	it	eq
 8020ce0:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 8020ce2:	7f1a      	ldrb	r2, [r3, #28]
 8020ce4:	2a01      	cmp	r2, #1
 8020ce6:	d111      	bne.n	8020d0c <UIVocoderButtons+0x6c>
                {
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 8020ce8:	f240 6114 	movw	r1, #1556	; 0x614
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020cec:	2400      	movs	r4, #0
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 8020cee:	f64f 3094 	movw	r0, #64404	; 0xfb94
 8020cf2:	f64f 329c 	movw	r2, #64412	; 0xfb9c
 8020cf6:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020cfa:	771c      	strb	r4, [r3, #28]
                    writeString = vocFreezeLPC ? "FROZEN" : "UNFROZEN";
 8020cfc:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020d00:	f6c0 0202 	movt	r2, #2050	; 0x802
 8020d04:	680b      	ldr	r3, [r1, #0]
 8020d06:	42a3      	cmp	r3, r4
 8020d08:	bf08      	it	eq
 8020d0a:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 8020d0c:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020d10:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020d12:	f240 2150 	movw	r1, #592	; 0x250
 8020d16:	f64f 306c 	movw	r0, #64364	; 0xfb6c
 8020d1a:	f64f 3274 	movw	r2, #64372	; 0xfb74
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020d1e:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020d20:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020d24:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020d28:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020d2c:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020d2e:	7809      	ldrb	r1, [r1, #0]
 8020d30:	2901      	cmp	r1, #1
 8020d32:	bf98      	it	ls
 8020d34:	4610      	movls	r0, r2
 8020d36:	e7bf      	b.n	8020cb8 <UIVocoderButtons+0x18>

08020d38 <UIVocoderChButtons>:

            const char* UIVocoderChButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8020d38:	f648 0354 	movw	r3, #34900	; 0x8854
 8020d3c:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8020d40:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8020d42:	7d1a      	ldrb	r2, [r3, #20]
 8020d44:	2a01      	cmp	r2, #1
 8020d46:	d030      	beq.n	8020daa <UIVocoderChButtons+0x72>
                const char* writeString = "";
 8020d48:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020d4c:	f6c0 0002 	movt	r0, #2050	; 0x802
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 8020d50:	7e1a      	ldrb	r2, [r3, #24]
 8020d52:	2a01      	cmp	r2, #1
 8020d54:	d111      	bne.n	8020d7a <UIVocoderChButtons+0x42>
                {
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020d56:	f240 519c 	movw	r1, #1436	; 0x59c
 8020d5a:	f64f 307c 	movw	r0, #64380	; 0xfb7c
 8020d5e:	f64f 3288 	movw	r2, #64392	; 0xfb88
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020d62:	2400      	movs	r4, #0
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020d64:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020d68:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020d6c:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020d70:	761c      	strb	r4, [r3, #24]
                    writeString = internalExternal ? "EXTERNAL" : "INTERNAL";
 8020d72:	7809      	ldrb	r1, [r1, #0]
 8020d74:	42a1      	cmp	r1, r4
 8020d76:	bf08      	it	eq
 8020d78:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 8020d7a:	7f1a      	ldrb	r2, [r3, #28]
 8020d7c:	2a01      	cmp	r2, #1
 8020d7e:	d111      	bne.n	8020da4 <UIVocoderChButtons+0x6c>
                {
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 8020d80:	f240 6110 	movw	r1, #1552	; 0x610
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020d84:	2400      	movs	r4, #0
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 8020d86:	f64f 3094 	movw	r0, #64404	; 0xfb94
 8020d8a:	f64f 329c 	movw	r2, #64412	; 0xfb9c
 8020d8e:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020d92:	771c      	strb	r4, [r3, #28]
                    writeString = vocChFreeze ? "FROZEN" : "UNFROZEN";
 8020d94:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020d98:	f6c0 0202 	movt	r2, #2050	; 0x802
 8020d9c:	680b      	ldr	r3, [r1, #0]
 8020d9e:	42a3      	cmp	r3, r4
 8020da0:	bf08      	it	eq
 8020da2:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 8020da4:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020da8:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020daa:	f240 2150 	movw	r1, #592	; 0x250
 8020dae:	f64f 306c 	movw	r0, #64364	; 0xfb6c
 8020db2:	f64f 3274 	movw	r2, #64372	; 0xfb74
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020db6:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020db8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020dbc:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020dc0:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020dc4:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8020dc6:	7809      	ldrb	r1, [r1, #0]
 8020dc8:	2901      	cmp	r1, #1
 8020dca:	bf98      	it	ls
 8020dcc:	4610      	movls	r0, r2
 8020dce:	e7bf      	b.n	8020d50 <UIVocoderChButtons+0x18>

08020dd0 <UIPitchShiftButtons>:

            const char* UIPitchShiftButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                return writeString;
            }
 8020dd0:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020dd4:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020dd8:	4770      	bx	lr
 8020dda:	bf00      	nop

08020ddc <UINeartuneButtons>:

            const char* UINeartuneButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 8020ddc:	f648 0354 	movw	r3, #34900	; 0x8854
 8020de0:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8020de4:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 8020de6:	7d1a      	ldrb	r2, [r3, #20]
 8020de8:	b342      	cbz	r2, 8020e3c <UINeartuneButtons+0x60>
                {
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 8020dea:	f240 511c 	movw	r1, #1308	; 0x51c
 8020dee:	f64f 2070 	movw	r0, #64112	; 0xfa70
 8020df2:	f64f 2280 	movw	r2, #64128	; 0xfa80
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020df6:	2400      	movs	r4, #0
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 8020df8:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8020dfc:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020e00:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8020e04:	751c      	strb	r4, [r3, #20]
                    writeString = autotuneChromatic ? "AUTOCHROM ON" : "AUTOCHROM OFF";
 8020e06:	7809      	ldrb	r1, [r1, #0]
 8020e08:	42a1      	cmp	r1, r4
 8020e0a:	bf08      	it	eq
 8020e0c:	4610      	moveq	r0, r2
                }

                if (buttonActionsUI[ButtonC][ActionPress])
 8020e0e:	7f1a      	ldrb	r2, [r3, #28]
 8020e10:	b18a      	cbz	r2, 8020e36 <UINeartuneButtons+0x5a>
                {
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 8020e12:	f240 5120 	movw	r1, #1312	; 0x520
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020e16:	2400      	movs	r4, #0
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 8020e18:	f64f 2090 	movw	r0, #64144	; 0xfa90
 8020e1c:	f64f 22a0 	movw	r2, #64160	; 0xfaa0
 8020e20:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020e24:	771c      	strb	r4, [r3, #28]
                    writeString = autotuneLock ? "CHORD LOCK ON" : "CHORD LOCK OFF";
 8020e26:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020e2a:	f6c0 0202 	movt	r2, #2050	; 0x802
 8020e2e:	680b      	ldr	r3, [r1, #0]
 8020e30:	42a3      	cmp	r3, r4
 8020e32:	bf08      	it	eq
 8020e34:	4610      	moveq	r0, r2
                }


                return writeString;
            }
 8020e36:	f85d 4b04 	ldr.w	r4, [sp], #4
 8020e3a:	4770      	bx	lr
                const char* writeString = "";
 8020e3c:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020e40:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020e44:	e7e3      	b.n	8020e0e <UINeartuneButtons+0x32>
 8020e46:	bf00      	nop

08020e48 <UIAutotuneButtons>:
 8020e48:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020e4c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020e50:	4770      	bx	lr
 8020e52:	bf00      	nop

08020e54 <UISamplerBPButtons>:
                const char* writeString = "";
                return writeString;
            }

            const char* UISamplerBPButtons(VocodecButton button, ButtonAction action)
            {
 8020e54:	b538      	push	{r3, r4, r5, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 8020e56:	f648 0454 	movw	r4, #34900	; 0x8854
 8020e5a:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8020e5e:	7f23      	ldrb	r3, [r4, #28]
 8020e60:	2b00      	cmp	r3, #0
 8020e62:	d163      	bne.n	8020f2c <UISamplerBPButtons+0xd8>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
                    buttonActionsUI[ButtonC][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
 8020e64:	7e23      	ldrb	r3, [r4, #24]
 8020e66:	2b00      	cmp	r3, #0
 8020e68:	d145      	bne.n	8020ef6 <UISamplerBPButtons+0xa2>
                {
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionHoldContinuous])
 8020e6a:	7de3      	ldrb	r3, [r4, #23]
 8020e6c:	bb53      	cbnz	r3, 8020ec4 <UISamplerBPButtons+0x70>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
                }
                if (buttonActionsUI[ButtonA][ActionRelease])
 8020e6e:	7d63      	ldrb	r3, [r4, #21]
 8020e70:	b31b      	cbz	r3, 8020eba <UISamplerBPButtons+0x66>
                {
                    OLEDclearLine(SecondLine);
 8020e72:	2001      	movs	r0, #1
 8020e74:	f7f4 ffdc 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
 8020e78:	f240 53fc 	movw	r3, #1532	; 0x5fc
 8020e7c:	2101      	movs	r1, #1
 8020e7e:	2000      	movs	r0, #0
 8020e80:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020e84:	ed93 0a00 	vldr	s0, [r3]
 8020e88:	f7f5 f8cc 	bl	8016024 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 8020e8c:	f240 22a4 	movw	r2, #676	; 0x2a4
 8020e90:	f64f 301c 	movw	r0, #64284	; 0xfb1c
 8020e94:	f64f 3124 	movw	r1, #64292	; 0xfb24
 8020e98:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020e9c:	2301      	movs	r3, #1
 8020e9e:	f6c0 0102 	movt	r1, #2050	; 0x802
 8020ea2:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020ea6:	7815      	ldrb	r5, [r2, #0]
 8020ea8:	2230      	movs	r2, #48	; 0x30
 8020eaa:	2d00      	cmp	r5, #0
 8020eac:	bf08      	it	eq
 8020eae:	4608      	moveq	r0, r1
 8020eb0:	2107      	movs	r1, #7
 8020eb2:	f7f4 ffd3 	bl	8015e5c <OLEDwriteString>
                    buttonActionsUI[ButtonA][ActionRelease] = 0;
 8020eb6:	2300      	movs	r3, #0
 8020eb8:	7563      	strb	r3, [r4, #21]
                }
                return writeString;
            }
 8020eba:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8020ebe:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020ec2:	bd38      	pop	{r3, r4, r5, pc}
                    OLEDclearLine(SecondLine);
 8020ec4:	2001      	movs	r0, #1
 8020ec6:	f7f4 ffb3 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteString("RECORDING", 9, 0, SecondLine);
 8020eca:	f64f 304c 	movw	r0, #64332	; 0xfb4c
 8020ece:	2301      	movs	r3, #1
 8020ed0:	2200      	movs	r2, #0
 8020ed2:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020ed6:	2109      	movs	r1, #9
 8020ed8:	f7f4 ffc0 	bl	8015e5c <OLEDwriteString>
                    OLEDwriteFloat(sampleLength, 84, SecondLine);
 8020edc:	f240 53fc 	movw	r3, #1532	; 0x5fc
 8020ee0:	2101      	movs	r1, #1
 8020ee2:	2054      	movs	r0, #84	; 0x54
 8020ee4:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020ee8:	ed93 0a00 	vldr	s0, [r3]
 8020eec:	f7f5 f89a 	bl	8016024 <OLEDwriteFloat>
                    buttonActionsUI[ButtonA][ActionHoldContinuous] = 0;
 8020ef0:	2300      	movs	r3, #0
 8020ef2:	75e3      	strb	r3, [r4, #23]
 8020ef4:	e7bb      	b.n	8020e6e <UISamplerBPButtons+0x1a>
                    OLEDclearLine(SecondLine);
 8020ef6:	2001      	movs	r0, #1
 8020ef8:	f7f4 ff9a 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteString(bpMode ? "BACKANDFORTH" : "FORWARD     ", 12, 0, SecondLine);
 8020efc:	f240 5224 	movw	r2, #1316	; 0x524
 8020f00:	f64f 302c 	movw	r0, #64300	; 0xfb2c
 8020f04:	f64f 313c 	movw	r1, #64316	; 0xfb3c
 8020f08:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020f0c:	2301      	movs	r3, #1
 8020f0e:	f6c0 0102 	movt	r1, #2050	; 0x802
 8020f12:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020f16:	6815      	ldr	r5, [r2, #0]
 8020f18:	2200      	movs	r2, #0
 8020f1a:	4295      	cmp	r5, r2
 8020f1c:	bf08      	it	eq
 8020f1e:	4608      	moveq	r0, r1
 8020f20:	210c      	movs	r1, #12
 8020f22:	f7f4 ff9b 	bl	8015e5c <OLEDwriteString>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020f26:	2300      	movs	r3, #0
 8020f28:	7623      	strb	r3, [r4, #24]
 8020f2a:	e79e      	b.n	8020e6a <UISamplerBPButtons+0x16>
                    OLEDclearLine(SecondLine);
 8020f2c:	2001      	movs	r0, #1
 8020f2e:	f7f4 ff7f 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteFloat(sampleLength, 0, SecondLine);
 8020f32:	f240 53fc 	movw	r3, #1532	; 0x5fc
 8020f36:	2101      	movs	r1, #1
 8020f38:	2000      	movs	r0, #0
 8020f3a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020f3e:	ed93 0a00 	vldr	s0, [r3]
 8020f42:	f7f5 f86f 	bl	8016024 <OLEDwriteFloat>
                    OLEDwriteString(samplePlaying ? "PLAYING" : "STOPPED", 7, 48, SecondLine);
 8020f46:	f240 22a4 	movw	r2, #676	; 0x2a4
 8020f4a:	f64f 301c 	movw	r0, #64284	; 0xfb1c
 8020f4e:	f64f 3124 	movw	r1, #64292	; 0xfb24
 8020f52:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020f56:	2301      	movs	r3, #1
 8020f58:	f6c0 0102 	movt	r1, #2050	; 0x802
 8020f5c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020f60:	7815      	ldrb	r5, [r2, #0]
 8020f62:	2230      	movs	r2, #48	; 0x30
 8020f64:	2d00      	cmp	r5, #0
 8020f66:	bf08      	it	eq
 8020f68:	4608      	moveq	r0, r1
 8020f6a:	2107      	movs	r1, #7
 8020f6c:	f7f4 ff76 	bl	8015e5c <OLEDwriteString>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8020f70:	2300      	movs	r3, #0
 8020f72:	7723      	strb	r3, [r4, #28]
 8020f74:	e776      	b.n	8020e64 <UISamplerBPButtons+0x10>
 8020f76:	bf00      	nop

08020f78 <UISamplerKButtons>:

            const char* UISamplerKButtons(VocodecButton button, ButtonAction action)
            {
 8020f78:	b510      	push	{r4, lr}
                const char* writeString = "";


                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
 8020f7a:	f648 0454 	movw	r4, #34900	; 0x8854
 8020f7e:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8020f82:	f894 302b 	ldrb.w	r3, [r4, #43]	; 0x2b
            {
 8020f86:	ed2d 8b02 	vpush	{d8}
                if (buttonActionsUI[ExtraMessage][ActionHoldContinuous] || buttonActionsUI[ButtonA][ActionPress])
 8020f8a:	b9cb      	cbnz	r3, 8020fc0 <UISamplerKButtons+0x48>
 8020f8c:	7d23      	ldrb	r3, [r4, #20]
 8020f8e:	b9bb      	cbnz	r3, 8020fc0 <UISamplerKButtons+0x48>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }

                if (buttonActionsUI[ButtonB][ActionPress])
 8020f90:	7e23      	ldrb	r3, [r4, #24]
 8020f92:	2b00      	cmp	r3, #0
 8020f94:	d03b      	beq.n	802100e <UISamplerKButtons+0x96>
                {
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 8020f96:	f240 5260 	movw	r2, #1376	; 0x560
 8020f9a:	f64f 3058 	movw	r0, #64344	; 0xfb58
 8020f9e:	f64f 3360 	movw	r3, #64352	; 0xfb60
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020fa2:	2100      	movs	r1, #0
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 8020fa4:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8020fa8:	f6c0 0002 	movt	r0, #2050	; 0x802
 8020fac:	f6c0 0302 	movt	r3, #2050	; 0x802
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8020fb0:	7621      	strb	r1, [r4, #24]
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 8020fb2:	6812      	ldr	r2, [r2, #0]
                }
                return writeString;
            }
 8020fb4:	ecbd 8b02 	vpop	{d8}
                    writeString = controlAllKeys ? "MOD ALL" : "MOD SINGLE";
 8020fb8:	428a      	cmp	r2, r1
 8020fba:	bf08      	it	eq
 8020fbc:	4618      	moveq	r0, r3
            }
 8020fbe:	bd10      	pop	{r4, pc}
                    OLEDclearLine(SecondLine);
 8020fc0:	2001      	movs	r0, #1
 8020fc2:	f7f4 ff35 	bl	8015e30 <OLEDclearLine>
                    OLEDwritePitch(currentSamplerKeyGlobal + LOWEST_SAMPLER_KEY, 0, SecondLine, false);
 8020fc6:	f240 2320 	movw	r3, #544	; 0x220
 8020fca:	2200      	movs	r2, #0
 8020fcc:	2101      	movs	r1, #1
 8020fce:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020fd2:	4610      	mov	r0, r2
 8020fd4:	681b      	ldr	r3, [r3, #0]
 8020fd6:	3324      	adds	r3, #36	; 0x24
 8020fd8:	ee00 3a10 	vmov	s0, r3
 8020fdc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8020fe0:	f7f4 ffac 	bl	8015f3c <OLEDwritePitch>
                    OLEDwriteFloat(sampleLength, OLEDgetCursor(), SecondLine);
 8020fe4:	f240 53fc 	movw	r3, #1532	; 0x5fc
 8020fe8:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8020fec:	ed93 8a00 	vldr	s16, [r3]
 8020ff0:	f7f5 fa22 	bl	8016438 <OLEDgetCursor>
 8020ff4:	2101      	movs	r1, #1
 8020ff6:	b2c0      	uxtb	r0, r0
 8020ff8:	eeb0 0a48 	vmov.f32	s0, s16
 8020ffc:	f7f5 f812 	bl	8016024 <OLEDwriteFloat>
                    buttonActionsUI[ExtraMessage][ActionHoldContinuous] = 0;
 8021000:	2300      	movs	r3, #0
 8021002:	f884 302b 	strb.w	r3, [r4, #43]	; 0x2b
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021006:	7523      	strb	r3, [r4, #20]
                if (buttonActionsUI[ButtonB][ActionPress])
 8021008:	7e23      	ldrb	r3, [r4, #24]
 802100a:	2b00      	cmp	r3, #0
 802100c:	d1c3      	bne.n	8020f96 <UISamplerKButtons+0x1e>
                const char* writeString = "";
 802100e:	f64f 3048 	movw	r0, #64328	; 0xfb48
            }
 8021012:	ecbd 8b02 	vpop	{d8}
                const char* writeString = "";
 8021016:	f6c0 0002 	movt	r0, #2050	; 0x802
            }
 802101a:	bd10      	pop	{r4, pc}

0802101c <UISamplerAutoButtons>:

            const char* UISamplerAutoButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 802101c:	f648 0354 	movw	r3, #34900	; 0x8854
 8021020:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8021024:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 8021026:	7d1a      	ldrb	r2, [r3, #20]
 8021028:	b1a2      	cbz	r2, 8021054 <UISamplerAutoButtons+0x38>
                {
                    if (samplerMode == PlayLoop)
 802102a:	f240 22a5 	movw	r2, #677	; 0x2a5
 802102e:	f2c2 0200 	movt	r2, #8192	; 0x2000
 8021032:	7812      	ldrb	r2, [r2, #0]
 8021034:	2a01      	cmp	r2, #1
 8021036:	d03c      	beq.n	80210b2 <UISamplerAutoButtons+0x96>
                    {
                        writeString = "LOOP";
                    }
                    else if (samplerMode == PlayBackAndForth)
                    {
                        writeString = "BACK'N'FORTH";
 8021038:	f64f 3048 	movw	r0, #64328	; 0xfb48
 802103c:	f64f 21dc 	movw	r1, #64220	; 0xfadc
 8021040:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021044:	f6c0 0102 	movt	r1, #2050	; 0x802
 8021048:	2a02      	cmp	r2, #2
 802104a:	bf08      	it	eq
 802104c:	4608      	moveq	r0, r1
                    }
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 802104e:	2200      	movs	r2, #0
 8021050:	751a      	strb	r2, [r3, #20]
 8021052:	e003      	b.n	802105c <UISamplerAutoButtons+0x40>
                const char* writeString = "";
 8021054:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8021058:	f6c0 0002 	movt	r0, #2050	; 0x802
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 802105c:	7e1a      	ldrb	r2, [r3, #24]
 802105e:	b18a      	cbz	r2, 8021084 <UISamplerAutoButtons+0x68>
                {
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 8021060:	f240 610d 	movw	r1, #1549	; 0x60d
 8021064:	f64f 20ec 	movw	r0, #64236	; 0xfaec
 8021068:	f64f 22f8 	movw	r2, #64248	; 0xfaf8
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 802106c:	2400      	movs	r4, #0
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 802106e:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021072:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021076:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 802107a:	761c      	strb	r4, [r3, #24]
                    writeString = triggerChannel ? "CH2 TRIG" : "CH1 TRIG";
 802107c:	7809      	ldrb	r1, [r1, #0]
 802107e:	42a1      	cmp	r1, r4
 8021080:	bf08      	it	eq
 8021082:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress])
 8021084:	7f1a      	ldrb	r2, [r3, #28]
 8021086:	b18a      	cbz	r2, 80210ac <UISamplerAutoButtons+0x90>
                {
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 8021088:	f240 51dc 	movw	r1, #1500	; 0x5dc
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 802108c:	2400      	movs	r4, #0
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 802108e:	f64f 3004 	movw	r0, #64260	; 0xfb04
 8021092:	f64f 3210 	movw	r2, #64272	; 0xfb10
 8021096:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 802109a:	771c      	strb	r4, [r3, #28]
                    writeString = pitchQuantization ? "QUANT SPEED" : "CONT SPEED";
 802109c:	f6c0 0002 	movt	r0, #2050	; 0x802
 80210a0:	f6c0 0202 	movt	r2, #2050	; 0x802
 80210a4:	680b      	ldr	r3, [r1, #0]
 80210a6:	42a3      	cmp	r3, r4
 80210a8:	bf08      	it	eq
 80210aa:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 80210ac:	f85d 4b04 	ldr.w	r4, [sp], #4
 80210b0:	4770      	bx	lr
                        writeString = "LOOP";
 80210b2:	f64f 20d4 	movw	r0, #64212	; 0xfad4
 80210b6:	f6c0 0002 	movt	r0, #2050	; 0x802
 80210ba:	e7c8      	b.n	802104e <UISamplerAutoButtons+0x32>

080210bc <UIDistortionButtons>:

            const char* UIDistortionButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 80210bc:	f648 0354 	movw	r3, #34900	; 0x8854
 80210c0:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80210c4:	7d1a      	ldrb	r2, [r3, #20]
 80210c6:	b1aa      	cbz	r2, 80210f4 <UIDistortionButtons+0x38>
                {
                    writeString = distortionMode ? "SHAPER" : "TANH";
 80210c8:	f240 517c 	movw	r1, #1404	; 0x57c
 80210cc:	f64f 2000 	movw	r0, #64000	; 0xfa00
 80210d0:	f64f 2208 	movw	r2, #64008	; 0xfa08
 80210d4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80210d8:	f6c0 0002 	movt	r0, #2050	; 0x802
 80210dc:	f6c0 0202 	movt	r2, #2050	; 0x802
            {
 80210e0:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 80210e2:	2400      	movs	r4, #0
 80210e4:	751c      	strb	r4, [r3, #20]
                    writeString = distortionMode ? "SHAPER" : "TANH";
 80210e6:	780b      	ldrb	r3, [r1, #0]
 80210e8:	42a3      	cmp	r3, r4
 80210ea:	bf08      	it	eq
 80210ec:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 80210ee:	f85d 4b04 	ldr.w	r4, [sp], #4
 80210f2:	4770      	bx	lr
                const char* writeString = "";
 80210f4:	f64f 3048 	movw	r0, #64328	; 0xfb48
 80210f8:	f6c0 0002 	movt	r0, #2050	; 0x802
            }
 80210fc:	4770      	bx	lr
 80210fe:	bf00      	nop

08021100 <UIWaveFolderButtons>:

            const char* UIWaveFolderButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 8021100:	f648 0354 	movw	r3, #34900	; 0x8854
 8021104:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8021108:	7d1a      	ldrb	r2, [r3, #20]
 802110a:	b1aa      	cbz	r2, 8021138 <UIWaveFolderButtons+0x38>
                {
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
 802110c:	f240 518c 	movw	r1, #1420	; 0x58c
 8021110:	f64f 30a8 	movw	r0, #64424	; 0xfba8
 8021114:	f64f 32b8 	movw	r2, #64440	; 0xfbb8
 8021118:	f2c2 0100 	movt	r1, #8192	; 0x2000
 802111c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021120:	f6c0 0202 	movt	r2, #2050	; 0x802
            {
 8021124:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021126:	2400      	movs	r4, #0
 8021128:	751c      	strb	r4, [r3, #20]
                    writeString = foldMode ? "TWO IN SERIES" : "OVERSAMPLED";
 802112a:	680b      	ldr	r3, [r1, #0]
 802112c:	42a3      	cmp	r3, r4
 802112e:	bf08      	it	eq
 8021130:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 8021132:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021136:	4770      	bx	lr
                const char* writeString = "";
 8021138:	f64f 3048 	movw	r0, #64328	; 0xfb48
 802113c:	f6c0 0002 	movt	r0, #2050	; 0x802
            }
 8021140:	4770      	bx	lr
 8021142:	bf00      	nop

08021144 <UIBitcrusherButtons>:

            const char* UIBitcrusherButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";

                if (buttonActionsUI[ButtonA][ActionPress])
 8021144:	f648 0354 	movw	r3, #34900	; 0x8854
 8021148:	f2c2 0301 	movt	r3, #8193	; 0x2001
 802114c:	7d1a      	ldrb	r2, [r3, #20]
 802114e:	b1aa      	cbz	r2, 802117c <UIBitcrusherButtons+0x38>
                {
                    writeString = crusherStereo ? "STEREO" : "MONO";
 8021150:	f240 5168 	movw	r1, #1384	; 0x568
 8021154:	f64f 4078 	movw	r0, #64632	; 0xfc78
 8021158:	f64f 3274 	movw	r2, #64372	; 0xfb74
 802115c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021160:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021164:	f6c0 0202 	movt	r2, #2050	; 0x802
            {
 8021168:	b410      	push	{r4}
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 802116a:	2400      	movs	r4, #0
 802116c:	751c      	strb	r4, [r3, #20]
                    writeString = crusherStereo ? "STEREO" : "MONO";
 802116e:	680b      	ldr	r3, [r1, #0]
 8021170:	42a3      	cmp	r3, r4
 8021172:	bf08      	it	eq
 8021174:	4610      	moveq	r0, r2
                }


                return writeString;
            }
 8021176:	f85d 4b04 	ldr.w	r4, [sp], #4
 802117a:	4770      	bx	lr
                const char* writeString = "";
 802117c:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8021180:	f6c0 0002 	movt	r0, #2050	; 0x802
            }
 8021184:	4770      	bx	lr
 8021186:	bf00      	nop

08021188 <UIDelayButtons>:

            const char* UIDelayButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress])
 8021188:	f648 0354 	movw	r3, #34900	; 0x8854
 802118c:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8021190:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress])
 8021192:	7d1a      	ldrb	r2, [r3, #20]
 8021194:	b342      	cbz	r2, 80211e8 <UIDelayButtons+0x60>
                {
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 8021196:	f240 5178 	movw	r1, #1400	; 0x578
 802119a:	f64f 10d4 	movw	r0, #63956	; 0xf9d4
 802119e:	f64f 12e0 	movw	r2, #63968	; 0xf9e0
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 80211a2:	2400      	movs	r4, #0
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 80211a4:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80211a8:	f6c0 0002 	movt	r0, #2050	; 0x802
 80211ac:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 80211b0:	751c      	strb	r4, [r3, #20]
                    writeString = delayShaper ? "SHAPER ON" : "SHAPER OFF";
 80211b2:	6809      	ldr	r1, [r1, #0]
 80211b4:	42a1      	cmp	r1, r4
 80211b6:	bf08      	it	eq
 80211b8:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 80211ba:	7e1a      	ldrb	r2, [r3, #24]
 80211bc:	b18a      	cbz	r2, 80211e2 <UIDelayButtons+0x5a>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 80211be:	f240 5128 	movw	r1, #1320	; 0x528
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 80211c2:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 80211c4:	f64f 10ec 	movw	r0, #63980	; 0xf9ec
 80211c8:	f64f 12f4 	movw	r2, #63988	; 0xf9f4
 80211cc:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 80211d0:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 80211d2:	f6c0 0002 	movt	r0, #2050	; 0x802
 80211d6:	f6c0 0202 	movt	r2, #2050	; 0x802
 80211da:	780b      	ldrb	r3, [r1, #0]
 80211dc:	42a3      	cmp	r3, r4
 80211de:	bf08      	it	eq
 80211e0:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 80211e2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80211e6:	4770      	bx	lr
                const char* writeString = "";
 80211e8:	f64f 3048 	movw	r0, #64328	; 0xfb48
 80211ec:	f6c0 0002 	movt	r0, #2050	; 0x802
 80211f0:	e7e3      	b.n	80211ba <UIDelayButtons+0x32>
 80211f2:	bf00      	nop

080211f4 <UIReverbButtons>:

            const char* UIReverbButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 80211f4:	f648 0354 	movw	r3, #34900	; 0x8854
 80211f8:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 80211fc:	b410      	push	{r4}
                if (buttonActionsUI[ButtonC][ActionPress])
 80211fe:	7f1a      	ldrb	r2, [r3, #28]
 8021200:	b342      	cbz	r2, 8021254 <UIReverbButtons+0x60>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 8021202:	f240 5190 	movw	r1, #1424	; 0x590
 8021206:	f64f 20b0 	movw	r0, #64176	; 0xfab0
 802120a:	f64f 22b8 	movw	r2, #64184	; 0xfab8
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 802120e:	2400      	movs	r4, #0
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 8021210:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021214:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021218:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 802121c:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 802121e:	6809      	ldr	r1, [r1, #0]
 8021220:	42a1      	cmp	r1, r4
 8021222:	bf08      	it	eq
 8021224:	4610      	moveq	r0, r2
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 8021226:	7e1a      	ldrb	r2, [r3, #24]
 8021228:	b18a      	cbz	r2, 802124e <UIReverbButtons+0x5a>
                {
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 802122a:	f240 5128 	movw	r1, #1320	; 0x528
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 802122e:	2400      	movs	r4, #0
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 8021230:	f64f 10ec 	movw	r0, #63980	; 0xf9ec
 8021234:	f64f 12f4 	movw	r2, #63988	; 0xf9f4
 8021238:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 802123c:	761c      	strb	r4, [r3, #24]
                    writeString = capFeedback ? "FB CAP" : "FB UNCAP";
 802123e:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021242:	f6c0 0202 	movt	r2, #2050	; 0x802
 8021246:	780b      	ldrb	r3, [r1, #0]
 8021248:	42a3      	cmp	r3, r4
 802124a:	bf08      	it	eq
 802124c:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 802124e:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021252:	4770      	bx	lr
                const char* writeString = "";
 8021254:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8021258:	f6c0 0002 	movt	r0, #2050	; 0x802
 802125c:	e7e3      	b.n	8021226 <UIReverbButtons+0x32>
 802125e:	bf00      	nop

08021260 <UIReverb2Buttons>:

            const char* UIReverb2Buttons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonC][ActionPress])
 8021260:	f648 0354 	movw	r3, #34900	; 0x8854
 8021264:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8021268:	7f1a      	ldrb	r2, [r3, #28]
 802126a:	b1aa      	cbz	r2, 8021298 <UIReverb2Buttons+0x38>
                {
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 802126c:	f240 5190 	movw	r1, #1424	; 0x590
 8021270:	f64f 20b0 	movw	r0, #64176	; 0xfab0
 8021274:	f64f 22b8 	movw	r2, #64184	; 0xfab8
 8021278:	f2c2 0100 	movt	r1, #8192	; 0x2000
 802127c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021280:	f6c0 0202 	movt	r2, #2050	; 0x802
            {
 8021284:	b410      	push	{r4}
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8021286:	2400      	movs	r4, #0
 8021288:	771c      	strb	r4, [r3, #28]
                    writeString = freeze ? "FREEZE" : "UNFREEZE";
 802128a:	680b      	ldr	r3, [r1, #0]
 802128c:	42a3      	cmp	r3, r4
 802128e:	bf08      	it	eq
 8021290:	4610      	moveq	r0, r2
                }
                return writeString;
            }
 8021292:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021296:	4770      	bx	lr
                const char* writeString = "";
 8021298:	f64f 3048 	movw	r0, #64328	; 0xfb48
 802129c:	f6c0 0002 	movt	r0, #2050	; 0x802
            }
 80212a0:	4770      	bx	lr
 80212a2:	bf00      	nop

080212a4 <UILivingStringButtons>:

            const char* UILivingStringButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 80212a4:	f648 0354 	movw	r3, #34900	; 0x8854
 80212a8:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 80212ac:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 80212ae:	7d1a      	ldrb	r2, [r3, #20]
 80212b0:	2a01      	cmp	r2, #1
 80212b2:	d030      	beq.n	8021316 <UILivingStringButtons+0x72>
                const char* writeString = "";
 80212b4:	f64f 3048 	movw	r0, #64328	; 0xfb48
 80212b8:	f6c0 0002 	movt	r0, #2050	; 0x802
                {
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 80212bc:	7f1a      	ldrb	r2, [r3, #28]
 80212be:	2a01      	cmp	r2, #1
 80212c0:	d111      	bne.n	80212e6 <UILivingStringButtons+0x42>
                {
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 80212c2:	f240 51a0 	movw	r1, #1440	; 0x5a0
 80212c6:	f64f 2028 	movw	r0, #64040	; 0xfa28
 80212ca:	f64f 2230 	movw	r2, #64048	; 0xfa30
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 80212ce:	2400      	movs	r4, #0
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 80212d0:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80212d4:	f6c0 0002 	movt	r0, #2050	; 0x802
 80212d8:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 80212dc:	771c      	strb	r4, [r3, #28]
                    writeString = (levMode > 0) ? "FB MODE" : "DECAY MODE";
 80212de:	6809      	ldr	r1, [r1, #0]
 80212e0:	42a1      	cmp	r1, r4
 80212e2:	bfd8      	it	le
 80212e4:	4610      	movle	r0, r2
                }

                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 80212e6:	7e1a      	ldrb	r2, [r3, #24]
 80212e8:	2a01      	cmp	r2, #1
 80212ea:	d111      	bne.n	8021310 <UILivingStringButtons+0x6c>
                {
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 80212ec:	f240 5198 	movw	r1, #1432	; 0x598
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 80212f0:	2400      	movs	r4, #0
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 80212f2:	f64f 203c 	movw	r0, #64060	; 0xfa3c
 80212f6:	f64f 224c 	movw	r2, #64076	; 0xfa4c
 80212fa:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 80212fe:	761c      	strb	r4, [r3, #24]
                    writeString = (independentStrings > 0) ? "INDIV CONTROL" : "KNOB1=>ALL";
 8021300:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021304:	f6c0 0202 	movt	r2, #2050	; 0x802
 8021308:	680b      	ldr	r3, [r1, #0]
 802130a:	42a3      	cmp	r3, r4
 802130c:	bfd8      	it	le
 802130e:	4610      	movle	r0, r2
                }

                return writeString;
            }
 8021310:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021314:	4770      	bx	lr
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 8021316:	f240 5194 	movw	r1, #1428	; 0x594
 802131a:	f64f 2010 	movw	r0, #64016	; 0xfa10
 802131e:	f64f 221c 	movw	r2, #64028	; 0xfa1c
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021322:	2400      	movs	r4, #0
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 8021324:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021328:	f6c0 0002 	movt	r0, #2050	; 0x802
 802132c:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021330:	751c      	strb	r4, [r3, #20]
                    writeString = (ignoreFreqKnobs > 0) ? "MIDI PITCH" : "KNOB PITCH";
 8021332:	6809      	ldr	r1, [r1, #0]
 8021334:	42a1      	cmp	r1, r4
 8021336:	bfd8      	it	le
 8021338:	4610      	movle	r0, r2
 802133a:	e7bf      	b.n	80212bc <UILivingStringButtons+0x18>

0802133c <UILivingStringSynthButtons>:

            const char* UILivingStringSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 802133c:	f648 0354 	movw	r3, #34900	; 0x8854
 8021340:	f2c2 0301 	movt	r3, #8193	; 0x2001
            {
 8021344:	b410      	push	{r4}
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8021346:	7d1a      	ldrb	r2, [r3, #20]
 8021348:	2a01      	cmp	r2, #1
 802134a:	d030      	beq.n	80213ae <UILivingStringSynthButtons+0x72>
                const char* writeString = "";
 802134c:	f64f 3048 	movw	r0, #64328	; 0xfb48
 8021350:	f6c0 0002 	movt	r0, #2050	; 0x802
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 8021354:	7e1a      	ldrb	r2, [r3, #24]
 8021356:	2a01      	cmp	r2, #1
 8021358:	d111      	bne.n	802137e <UILivingStringSynthButtons+0x42>
                {
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 802135a:	f240 6118 	movw	r1, #1560	; 0x618
 802135e:	f64f 2058 	movw	r0, #64088	; 0xfa58
 8021362:	f64f 2264 	movw	r2, #64100	; 0xfa64
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8021366:	2400      	movs	r4, #0
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 8021368:	f2c2 0100 	movt	r1, #8192	; 0x2000
 802136c:	f6c0 0002 	movt	r0, #2050	; 0x802
 8021370:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8021374:	761c      	strb	r4, [r3, #24]
                    writeString = (voicePluck > 0) ? "AUDIO IN" : "NO AUDIO IN";
 8021376:	6809      	ldr	r1, [r1, #0]
 8021378:	42a1      	cmp	r1, r4
 802137a:	bfd8      	it	le
 802137c:	4610      	movle	r0, r2
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 802137e:	7f1a      	ldrb	r2, [r3, #28]
 8021380:	2a01      	cmp	r2, #1
 8021382:	d111      	bne.n	80213a8 <UILivingStringSynthButtons+0x6c>
                {
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 8021384:	f240 51a4 	movw	r1, #1444	; 0x5a4
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8021388:	2400      	movs	r4, #0
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 802138a:	f64f 2028 	movw	r0, #64040	; 0xfa28
 802138e:	f64f 2230 	movw	r2, #64048	; 0xfa30
 8021392:	f2c2 0100 	movt	r1, #8192	; 0x2000
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 8021396:	771c      	strb	r4, [r3, #28]
                    writeString = (levModeStr > 0) ? "FB MODE" : "DECAY MODE";
 8021398:	f6c0 0002 	movt	r0, #2050	; 0x802
 802139c:	f6c0 0202 	movt	r2, #2050	; 0x802
 80213a0:	680b      	ldr	r3, [r1, #0]
 80213a2:	42a3      	cmp	r3, r4
 80213a4:	bfd8      	it	le
 80213a6:	4610      	movle	r0, r2
                }
                return writeString;
            }
 80213a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 80213ac:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 80213ae:	f240 2150 	movw	r1, #592	; 0x250
 80213b2:	f64f 306c 	movw	r0, #64364	; 0xfb6c
 80213b6:	f64f 3274 	movw	r2, #64372	; 0xfb74
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 80213ba:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 80213bc:	f2c2 0100 	movt	r1, #8192	; 0x2000
 80213c0:	f6c0 0002 	movt	r0, #2050	; 0x802
 80213c4:	f6c0 0202 	movt	r2, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 80213c8:	751c      	strb	r4, [r3, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 80213ca:	7809      	ldrb	r1, [r1, #0]
 80213cc:	2901      	cmp	r1, #1
 80213ce:	bf98      	it	ls
 80213d0:	4610      	movls	r0, r2
 80213d2:	e7bf      	b.n	8021354 <UILivingStringSynthButtons+0x18>

080213d4 <UIClassicSynthButtons>:

            const char* UIClassicSynthButtons(VocodecButton button, ButtonAction action)
            {
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 80213d4:	f648 0354 	movw	r3, #34900	; 0x8854
 80213d8:	f2c2 0301 	movt	r3, #8193	; 0x2001
 80213dc:	7d1a      	ldrb	r2, [r3, #20]
 80213de:	2a01      	cmp	r2, #1
 80213e0:	d009      	beq.n	80213f6 <UIClassicSynthButtons+0x22>
                const char* writeString = "";
 80213e2:	f64f 3048 	movw	r0, #64328	; 0xfb48
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress])
 80213e6:	7e1a      	ldrb	r2, [r3, #24]
                const char* writeString = "";
 80213e8:	f6c0 0002 	movt	r0, #2050	; 0x802
                if (buttonActionsUI[ButtonB][ActionPress])
 80213ec:	b112      	cbz	r2, 80213f4 <UIClassicSynthButtons+0x20>
                {
                    //writeString = knobPage == 0 ? "SETTINGS" : "ADSR";
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 80213ee:	2200      	movs	r2, #0
 80213f0:	761a      	strb	r2, [r3, #24]
 80213f2:	4770      	bx	lr
                }
                return writeString;
            }
 80213f4:	4770      	bx	lr
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 80213f6:	f240 2150 	movw	r1, #592	; 0x250
 80213fa:	f64f 306c 	movw	r0, #64364	; 0xfb6c
 80213fe:	f64f 3274 	movw	r2, #64372	; 0xfb74
 8021402:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021406:	f6c0 0002 	movt	r0, #2050	; 0x802
 802140a:	f6c0 0202 	movt	r2, #2050	; 0x802
            {
 802140e:	b410      	push	{r4}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021410:	7809      	ldrb	r1, [r1, #0]
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021412:	2400      	movs	r4, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021414:	2901      	cmp	r1, #1
 8021416:	bf98      	it	ls
 8021418:	4610      	movls	r0, r2
                if (buttonActionsUI[ButtonB][ActionPress])
 802141a:	7e1a      	ldrb	r2, [r3, #24]
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 802141c:	751c      	strb	r4, [r3, #20]
                if (buttonActionsUI[ButtonB][ActionPress])
 802141e:	b10a      	cbz	r2, 8021424 <UIClassicSynthButtons+0x50>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8021420:	2200      	movs	r2, #0
 8021422:	761a      	strb	r2, [r3, #24]
            }
 8021424:	f85d 4b04 	ldr.w	r4, [sp], #4
 8021428:	4770      	bx	lr
 802142a:	bf00      	nop

0802142c <UIRhodesButtons>:

            const char* UIRhodesButtons(VocodecButton button, ButtonAction action)
            {
 802142c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                const char* writeString = "";
                if (buttonActionsUI[ButtonA][ActionPress] == 1)
 8021430:	f648 0454 	movw	r4, #34900	; 0x8854
 8021434:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8021438:	7d23      	ldrb	r3, [r4, #20]
 802143a:	2b01      	cmp	r3, #1
 802143c:	d00c      	beq.n	8021458 <UIRhodesButtons+0x2c>
                {
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
                    buttonActionsUI[ButtonA][ActionPress] = 0;
                }
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 802143e:	7e26      	ldrb	r6, [r4, #24]
                const char* writeString = "";
 8021440:	f64f 3548 	movw	r5, #64328	; 0xfb48
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 8021444:	2e01      	cmp	r6, #1
                const char* writeString = "";
 8021446:	f6c0 0502 	movt	r5, #2050	; 0x802
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 802144a:	d01a      	beq.n	8021482 <UIRhodesButtons+0x56>
                {
                    buttonActionsUI[ButtonB][ActionPress] = 0;
                    OLEDclearLine(SecondLine);
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
                }
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 802144c:	7f26      	ldrb	r6, [r4, #28]
 802144e:	2e01      	cmp	r6, #1
 8021450:	d031      	beq.n	80214b6 <UIRhodesButtons+0x8a>
                    OLEDclearLine(SecondLine);
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
                }
                return writeString;
            }
 8021452:	4628      	mov	r0, r5
 8021454:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021458:	f240 2250 	movw	r2, #592	; 0x250
 802145c:	f64f 356c 	movw	r5, #64364	; 0xfb6c
 8021460:	f64f 3374 	movw	r3, #64372	; 0xfb74
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 8021464:	7e26      	ldrb	r6, [r4, #24]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021466:	f2c2 0200 	movt	r2, #8192	; 0x2000
 802146a:	f6c0 0502 	movt	r5, #2050	; 0x802
 802146e:	f6c0 0302 	movt	r3, #2050	; 0x802
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021472:	2100      	movs	r1, #0
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021474:	7812      	ldrb	r2, [r2, #0]
                    buttonActionsUI[ButtonA][ActionPress] = 0;
 8021476:	7521      	strb	r1, [r4, #20]
                    writeString = (numVoices > 1) ? "POLY" : "MONO";
 8021478:	2a01      	cmp	r2, #1
 802147a:	bf98      	it	ls
 802147c:	461d      	movls	r5, r3
                if (buttonActionsUI[ButtonB][ActionPress] == 1)
 802147e:	2e01      	cmp	r6, #1
 8021480:	d1e4      	bne.n	802144c <UIRhodesButtons+0x20>
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 8021482:	f04f 0800 	mov.w	r8, #0
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 8021486:	f240 5710 	movw	r7, #1296	; 0x510
                    OLEDclearLine(SecondLine);
 802148a:	4630      	mov	r0, r6
                    buttonActionsUI[ButtonB][ActionPress] = 0;
 802148c:	f884 8018 	strb.w	r8, [r4, #24]
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 8021490:	f2c2 0700 	movt	r7, #8192	; 0x2000
                    OLEDclearLine(SecondLine);
 8021494:	f7f4 fccc 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteString(soundNames[Rsound], 6, 0, SecondLine);
 8021498:	f247 40e8 	movw	r0, #29928	; 0x74e8
 802149c:	4633      	mov	r3, r6
 802149e:	683e      	ldr	r6, [r7, #0]
 80214a0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80214a4:	4642      	mov	r2, r8
 80214a6:	2106      	movs	r1, #6
 80214a8:	f850 0026 	ldr.w	r0, [r0, r6, lsl #2]
 80214ac:	f7f4 fcd6 	bl	8015e5c <OLEDwriteString>
                if (buttonActionsUI[ButtonC][ActionPress] == 1)
 80214b0:	7f26      	ldrb	r6, [r4, #28]
 80214b2:	2e01      	cmp	r6, #1
 80214b4:	d1cd      	bne.n	8021452 <UIRhodesButtons+0x26>
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 80214b6:	2700      	movs	r7, #0
                    OLEDclearLine(SecondLine);
 80214b8:	4630      	mov	r0, r6
                    buttonActionsUI[ButtonC][ActionPress] = 0;
 80214ba:	7727      	strb	r7, [r4, #28]
                    OLEDclearLine(SecondLine);
 80214bc:	f7f4 fcb8 	bl	8015e30 <OLEDclearLine>
                    OLEDwriteString("STEREO TREMO", 12, 0, SecondLine);
 80214c0:	f64f 20c4 	movw	r0, #64196	; 0xfac4
 80214c4:	4633      	mov	r3, r6
 80214c6:	463a      	mov	r2, r7
 80214c8:	210c      	movs	r1, #12
 80214ca:	f6c0 0002 	movt	r0, #2050	; 0x802
 80214ce:	f7f4 fcc5 	bl	8015e5c <OLEDwriteString>
                    OLEDwriteInt(tremoloStereo, 1, 110, SecondLine);
 80214d2:	f240 600c 	movw	r0, #1548	; 0x60c
 80214d6:	4633      	mov	r3, r6
 80214d8:	4631      	mov	r1, r6
 80214da:	f2c2 0000 	movt	r0, #8192	; 0x2000
 80214de:	226e      	movs	r2, #110	; 0x6e
 80214e0:	7800      	ldrb	r0, [r0, #0]
 80214e2:	f7f4 fcef 	bl	8015ec4 <OLEDwriteInt>
            }
 80214e6:	4628      	mov	r0, r5
 80214e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080214ec <USBH_UserProcess>:
 * user callback definition
 */
static void USBH_UserProcess  (USBH_HandleTypeDef *phost, uint8_t id)
{
  /* USER CODE BEGIN CALL_BACK_1 */
  switch(id)
 80214ec:	2904      	cmp	r1, #4
 80214ee:	d011      	beq.n	8021514 <USBH_UserProcess+0x28>
 80214f0:	2905      	cmp	r1, #5
 80214f2:	d008      	beq.n	8021506 <USBH_UserProcess+0x1a>
 80214f4:	2902      	cmp	r1, #2
 80214f6:	d000      	beq.n	80214fa <USBH_UserProcess+0xe>

  default:
  break;
  }
  /* USER CODE END CALL_BACK_1 */
}
 80214f8:	4770      	bx	lr
  Appli_state = APPLICATION_READY;
 80214fa:	f240 6358 	movw	r3, #1624	; 0x658
 80214fe:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021502:	7019      	strb	r1, [r3, #0]
  break;
 8021504:	4770      	bx	lr
  Appli_state = APPLICATION_DISCONNECT;
 8021506:	f240 6358 	movw	r3, #1624	; 0x658
 802150a:	2204      	movs	r2, #4
 802150c:	f2c2 0300 	movt	r3, #8192	; 0x2000
 8021510:	701a      	strb	r2, [r3, #0]
  break;
 8021512:	4770      	bx	lr
  Appli_state = APPLICATION_START;
 8021514:	f240 6358 	movw	r3, #1624	; 0x658
 8021518:	2201      	movs	r2, #1
 802151a:	f2c2 0300 	movt	r3, #8192	; 0x2000
 802151e:	701a      	strb	r2, [r3, #0]
}
 8021520:	4770      	bx	lr
 8021522:	bf00      	nop

08021524 <MX_USB_HOST_Init>:
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 8021524:	f241 41ed 	movw	r1, #5357	; 0x14ed
 8021528:	f241 00a0 	movw	r0, #4256	; 0x10a0
 802152c:	2201      	movs	r2, #1
 802152e:	f6c0 0102 	movt	r1, #2050	; 0x802
 8021532:	f2c3 0000 	movt	r0, #12288	; 0x3000
{
 8021536:	b508      	push	{r3, lr}
  if (USBH_Init(&hUsbHostFS, USBH_UserProcess, HOST_FS) != USBH_OK)
 8021538:	f7ef fbfa 	bl	8010d30 <USBH_Init>
 802153c:	b9d0      	cbnz	r0, 8021574 <MX_USB_HOST_Init+0x50>
  if (USBH_RegisterClass(&hUsbHostFS, USBH_MIDI_CLASS) != USBH_OK)
 802153e:	f240 21d0 	movw	r1, #720	; 0x2d0
 8021542:	f241 00a0 	movw	r0, #4256	; 0x10a0
 8021546:	f2c2 0100 	movt	r1, #8192	; 0x2000
 802154a:	f2c3 0000 	movt	r0, #12288	; 0x3000
 802154e:	f7ef fc55 	bl	8010dfc <USBH_RegisterClass>
 8021552:	b960      	cbnz	r0, 802156e <MX_USB_HOST_Init+0x4a>
  if (USBH_Start(&hUsbHostFS) != USBH_OK)
 8021554:	f241 00a0 	movw	r0, #4256	; 0x10a0
 8021558:	f2c3 0000 	movt	r0, #12288	; 0x3000
 802155c:	f7ef fd3e 	bl	8010fdc <USBH_Start>
 8021560:	b108      	cbz	r0, 8021566 <MX_USB_HOST_Init+0x42>
    Error_Handler();
 8021562:	f7f4 f97f 	bl	8015864 <Error_Handler>
}
 8021566:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_EnableUSBVoltageDetector();
 802156a:	f7e7 bced 	b.w	8008f48 <HAL_PWREx_EnableUSBVoltageDetector>
    Error_Handler();
 802156e:	f7f4 f979 	bl	8015864 <Error_Handler>
 8021572:	e7ef      	b.n	8021554 <MX_USB_HOST_Init+0x30>
    Error_Handler();
 8021574:	f7f4 f976 	bl	8015864 <Error_Handler>
 8021578:	e7e1      	b.n	802153e <MX_USB_HOST_Init+0x1a>
 802157a:	bf00      	nop

0802157c <MX_USB_HOST_DeInit>:
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
 802157c:	f241 00a0 	movw	r0, #4256	; 0x10a0
{
 8021580:	b508      	push	{r3, lr}
  if (USBH_Stop(&hUsbHostFS) != USBH_OK)
 8021582:	f2c3 0000 	movt	r0, #12288	; 0x3000
 8021586:	f7ef fd33 	bl	8010ff0 <USBH_Stop>
 802158a:	b960      	cbnz	r0, 80215a6 <MX_USB_HOST_DeInit+0x2a>
  if (USBH_DeInit(&hUsbHostFS) != USBH_OK)
 802158c:	f241 00a0 	movw	r0, #4256	; 0x10a0
 8021590:	f2c3 0000 	movt	r0, #12288	; 0x3000
 8021594:	f7ef fc04 	bl	8010da0 <USBH_DeInit>
 8021598:	b108      	cbz	r0, 802159e <MX_USB_HOST_DeInit+0x22>
    Error_Handler();
 802159a:	f7f4 f963 	bl	8015864 <Error_Handler>
}
 802159e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_PWREx_DisableUSBVoltageDetector();
 80215a2:	f7e7 bcdb 	b.w	8008f5c <HAL_PWREx_DisableUSBVoltageDetector>
    Error_Handler();
 80215a6:	f7f4 f95d 	bl	8015864 <Error_Handler>
 80215aa:	e7ef      	b.n	802158c <MX_USB_HOST_DeInit+0x10>

080215ac <MX_USB_HOST_Process>:
{
 80215ac:	b508      	push	{r3, lr}
	MIDI_Application();
 80215ae:	f7f0 ffbf 	bl	8012530 <MIDI_Application>
	USBH_Process(&hUsbHostFS);
 80215b2:	f241 00a0 	movw	r0, #4256	; 0x10a0
}
 80215b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	USBH_Process(&hUsbHostFS);
 80215ba:	f2c3 0000 	movt	r0, #12288	; 0x3000
 80215be:	f7ef bd29 	b.w	8011014 <USBH_Process>
 80215c2:	bf00      	nop

080215c4 <USBH_MIDI_ClassRequest>:
 *         for MIDI class.
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_ClassRequest (USBH_HandleTypeDef *phost)
{   
 80215c4:	b508      	push	{r3, lr}

	phost->pUser(phost, HOST_USER_CLASS_ACTIVE);
 80215c6:	2102      	movs	r1, #2
 80215c8:	f8d0 3544 	ldr.w	r3, [r0, #1348]	; 0x544
 80215cc:	4798      	blx	r3

	return USBH_OK;
}
 80215ce:	2000      	movs	r0, #0
 80215d0:	bd08      	pop	{r3, pc}
 80215d2:	bf00      	nop

080215d4 <USBH_MIDI_Process>:
 *         (background process)
 * @param  phost: Host handle
 * @retval USBH Status
 */
static USBH_StatusTypeDef USBH_MIDI_Process (USBH_HandleTypeDef *phost)
{
 80215d4:	b510      	push	{r4, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 80215d6:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 80215da:	69dc      	ldr	r4, [r3, #28]

	switch(MIDI_Handle->state)
 80215dc:	7823      	ldrb	r3, [r4, #0]
 80215de:	b153      	cbz	r3, 80215f6 <USBH_MIDI_Process+0x22>
 80215e0:	2b02      	cmp	r3, #2
 80215e2:	d106      	bne.n	80215f2 <USBH_MIDI_Process+0x1e>
		//MIDI_ProcessTransmission(phost);
		//MIDI_ProcessReception(phost);
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
 80215e4:	2100      	movs	r1, #0
 80215e6:	f7f0 fddf 	bl	80121a8 <USBH_ClrFeature>

		if(req_status == USBH_OK )
 80215ea:	b910      	cbnz	r0, 80215f2 <USBH_MIDI_Process+0x1e>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
 80215ec:	7020      	strb	r0, [r4, #0]
	USBH_StatusTypeDef status = USBH_BUSY;
 80215ee:	2001      	movs	r0, #1
		break;

	}

	return status;
}
 80215f0:	bd10      	pop	{r4, pc}
	USBH_StatusTypeDef status = USBH_BUSY;
 80215f2:	2001      	movs	r0, #1
}
 80215f4:	bd10      	pop	{r4, pc}
		status = USBH_OK;
 80215f6:	4618      	mov	r0, r3
}
 80215f8:	bd10      	pop	{r4, pc}
 80215fa:	bf00      	nop

080215fc <USBH_MIDI_SOFProcess>:
  *         The function is for managing SOF callback
  * @param  phost: Host handle
  * @retval USBH Status
  */
static USBH_StatusTypeDef USBH_MIDI_SOFProcess (USBH_HandleTypeDef *phost)
{
 80215fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	USBH_StatusTypeDef status = USBH_BUSY;
	USBH_StatusTypeDef req_status = USBH_OK;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 8021600:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
 8021604:	b083      	sub	sp, #12
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 8021606:	69dc      	ldr	r4, [r3, #28]
	USBH_URBStateTypeDef URB_Status = USBH_URB_IDLE;
	uint16_t length;
	switch(MIDI_Handle->state)
 8021608:	7823      	ldrb	r3, [r4, #0]
 802160a:	2b01      	cmp	r3, #1
 802160c:	d00a      	beq.n	8021624 <USBH_MIDI_SOFProcess+0x28>
 802160e:	2b02      	cmp	r3, #2
 8021610:	d104      	bne.n	802161c <USBH_MIDI_SOFProcess+0x20>
				break;
		}
		break;

	case MIDI_ERROR_STATE:
		req_status = USBH_ClrFeature(phost, 0x00);
 8021612:	2100      	movs	r1, #0
 8021614:	f7f0 fdc8 	bl	80121a8 <USBH_ClrFeature>

		if(req_status == USBH_OK )
 8021618:	b900      	cbnz	r0, 802161c <USBH_MIDI_SOFProcess+0x20>
		{
			/*Change the state to waiting*/
			MIDI_Handle->state = MIDI_IDLE_STATE ;
 802161a:	7020      	strb	r0, [r4, #0]
		break;

	}

	return USBH_OK;
}
 802161c:	2000      	movs	r0, #0
 802161e:	b003      	add	sp, #12
 8021620:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch(MIDI_Handle->data_rx_state)
 8021624:	7e63      	ldrb	r3, [r4, #25]
 8021626:	2b03      	cmp	r3, #3
 8021628:	f000 8084 	beq.w	8021734 <USBH_MIDI_SOFProcess+0x138>
 802162c:	2b04      	cmp	r3, #4
 802162e:	d1f5      	bne.n	802161c <USBH_MIDI_SOFProcess+0x20>
				URB_Status = USBH_LL_GetURBState(phost, MIDI_Handle->InPipe);
 8021630:	7861      	ldrb	r1, [r4, #1]
 8021632:	4605      	mov	r5, r0
 8021634:	f000 fa68 	bl	8021b08 <USBH_LL_GetURBState>
				if(URB_Status == USBH_URB_DONE )
 8021638:	2801      	cmp	r0, #1
 802163a:	d1ef      	bne.n	802161c <USBH_MIDI_SOFProcess+0x20>
					length = USBH_LL_GetLastXferSize(phost, MIDI_Handle->InPipe);
 802163c:	7861      	ldrb	r1, [r4, #1]
 802163e:	4628      	mov	r0, r5
 8021640:	f000 fa14 	bl	8021a6c <USBH_LL_GetLastXferSize>
					if(((MIDI_Handle->RxDataLength - length) > 0) && (length > MIDI_Handle->InEpSize))
 8021644:	8ae3      	ldrh	r3, [r4, #22]
 8021646:	b286      	uxth	r6, r0
 8021648:	1b9a      	subs	r2, r3, r6
 802164a:	2a00      	cmp	r2, #0
 802164c:	dd02      	ble.n	8021654 <USBH_MIDI_SOFProcess+0x58>
 802164e:	8922      	ldrh	r2, [r4, #8]
 8021650:	42b2      	cmp	r2, r6
 8021652:	d37a      	bcc.n	802174a <USBH_MIDI_SOFProcess+0x14e>
						MIDI_write_buffer = !MIDI_write_buffer;
 8021654:	f240 0008 	movw	r0, #8
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 8021658:	f240 41cc 	movw	r1, #1228	; 0x4cc
						MIDI_Handle->data_rx_state = MIDI_IDLE;
 802165c:	2300      	movs	r3, #0
						MIDI_write_buffer = !MIDI_write_buffer;
 802165e:	f2c2 0000 	movt	r0, #8192	; 0x2000
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 8021662:	f2c2 0100 	movt	r1, #8192	; 0x2000
						MIDI_Handle->data_rx_state = MIDI_IDLE;
 8021666:	7663      	strb	r3, [r4, #25]
						MIDI_write_buffer = !MIDI_write_buffer;
 8021668:	f890 c000 	ldrb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 802166c:	780a      	ldrb	r2, [r1, #0]
						MIDI_write_buffer = !MIDI_write_buffer;
 802166e:	fabc fc8c 	clz	ip, ip
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 8021672:	fab2 f282 	clz	r2, r2
						MIDI_write_buffer = !MIDI_write_buffer;
 8021676:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 802167a:	0952      	lsrs	r2, r2, #5
						MIDI_write_buffer = !MIDI_write_buffer;
 802167c:	f880 c000 	strb.w	ip, [r0]
						MIDI_read_buffer = !MIDI_read_buffer; //switch buffers for double buffer fun
 8021680:	700a      	strb	r2, [r1, #0]
						for (int i = 0; i < length; i++)
 8021682:	2e00      	cmp	r6, #0
 8021684:	d040      	beq.n	8021708 <USBH_MIDI_SOFProcess+0x10c>
 8021686:	f240 0700 	movw	r7, #0
 802168a:	f240 615c 	movw	r1, #1628	; 0x65c
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 802168e:	f249 00dc 	movw	r0, #37084	; 0x90dc
								myUSB_FIFO_overflowBit = 1;
 8021692:	f240 6e59 	movw	lr, #1625	; 0x659
 8021696:	f2c3 0700 	movt	r7, #12288	; 0x3000
								myUSB_FIFO_writePointer = 0;
 802169a:	4698      	mov	r8, r3
 802169c:	f2c2 0100 	movt	r1, #8192	; 0x2000
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 80216a0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80216a4:	eb07 1282 	add.w	r2, r7, r2, lsl #6
								myUSB_FIFO_overflowBit = 1;
 80216a8:	f2c2 0e00 	movt	lr, #8192	; 0x2000
 80216ac:	f04f 0901 	mov.w	r9, #1
 80216b0:	9401      	str	r4, [sp, #4]
							if ((i % 4) == 0)
 80216b2:	f003 0703 	and.w	r7, r3, #3
 80216b6:	3301      	adds	r3, #1
 80216b8:	b9df      	cbnz	r7, 80216f2 <USBH_MIDI_SOFProcess+0xf6>
								if (MIDI_RX_Buffer[MIDI_read_buffer][i] > 0)
 80216ba:	7817      	ldrb	r7, [r2, #0]
 80216bc:	b1cf      	cbz	r7, 80216f2 <USBH_MIDI_SOFProcess+0xf6>
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 80216be:	f8b1 b000 	ldrh.w	fp, [r1]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 80216c2:	f892 a001 	ldrb.w	sl, [r2, #1]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 80216c6:	fa1f fb8b 	uxth.w	fp, fp
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
 80216ca:	7894      	ldrb	r4, [r2, #2]
									myUSB_FIFO[myUSB_FIFO_writePointer] = MIDI_RX_Buffer[MIDI_read_buffer][i];
 80216cc:	f800 700b 	strb.w	r7, [r0, fp]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 80216d0:	880f      	ldrh	r7, [r1, #0]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
 80216d2:	f892 b003 	ldrb.w	fp, [r2, #3]
									myUSB_FIFO[myUSB_FIFO_writePointer+1] = MIDI_RX_Buffer[MIDI_read_buffer][i+1];
 80216d6:	3701      	adds	r7, #1
 80216d8:	f800 a007 	strb.w	sl, [r0, r7]
									myUSB_FIFO[myUSB_FIFO_writePointer+2] = MIDI_RX_Buffer[MIDI_read_buffer][i+2];
 80216dc:	880f      	ldrh	r7, [r1, #0]
 80216de:	3702      	adds	r7, #2
 80216e0:	55c4      	strb	r4, [r0, r7]
									myUSB_FIFO[myUSB_FIFO_writePointer+3] = MIDI_RX_Buffer[MIDI_read_buffer][i+3];
 80216e2:	880f      	ldrh	r7, [r1, #0]
 80216e4:	3703      	adds	r7, #3
 80216e6:	f800 b007 	strb.w	fp, [r0, r7]
									myUSB_FIFO_writePointer+=4;
 80216ea:	880f      	ldrh	r7, [r1, #0]
 80216ec:	3704      	adds	r7, #4
 80216ee:	b2bf      	uxth	r7, r7
 80216f0:	800f      	strh	r7, [r1, #0]
							if (myUSB_FIFO_writePointer >= 256)
 80216f2:	880f      	ldrh	r7, [r1, #0]
 80216f4:	3201      	adds	r2, #1
 80216f6:	2fff      	cmp	r7, #255	; 0xff
 80216f8:	d903      	bls.n	8021702 <USBH_MIDI_SOFProcess+0x106>
								myUSB_FIFO_writePointer = 0;
 80216fa:	f8a1 8000 	strh.w	r8, [r1]
								myUSB_FIFO_overflowBit = 1;
 80216fe:	f88e 9000 	strb.w	r9, [lr]
						for (int i = 0; i < length; i++)
 8021702:	429e      	cmp	r6, r3
 8021704:	d1d5      	bne.n	80216b2 <USBH_MIDI_SOFProcess+0xb6>
 8021706:	9c01      	ldr	r4, [sp, #4]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 8021708:	2304      	movs	r3, #4
 802170a:	7663      	strb	r3, [r4, #25]
 * @retval None
 */
USBH_StatusTypeDef  USBH_MIDI_Receive(USBH_HandleTypeDef *phost, uint8_t *pbuff, uint16_t length)
{
	USBH_StatusTypeDef Status = USBH_BUSY;
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 802170c:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 8021710:	69db      	ldr	r3, [r3, #28]

	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
 8021712:	781a      	ldrb	r2, [r3, #0]
 8021714:	2a01      	cmp	r2, #1
 8021716:	d881      	bhi.n	802161c <USBH_MIDI_SOFProcess+0x20>
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
 8021718:	f240 0200 	movw	r2, #0
	{
		MIDI_Handle->pRxData = pbuff;
		MIDI_Handle->RxDataLength = length;
 802171c:	2440      	movs	r4, #64	; 0x40
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 802171e:	2001      	movs	r0, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 8021720:	2103      	movs	r1, #3
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
 8021722:	f2c3 0200 	movt	r2, #12288	; 0x3000
		MIDI_Handle->RxDataLength = length;
 8021726:	82dc      	strh	r4, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 8021728:	7018      	strb	r0, [r3, #0]
						USBH_MIDI_Receive(phost, &MIDI_RX_Buffer[MIDI_write_buffer][0], RX_BUFF_SIZE); // start a new reception
 802172a:	eb02 128c 	add.w	r2, r2, ip, lsl #6
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 802172e:	7659      	strb	r1, [r3, #25]
		MIDI_Handle->pRxData = pbuff;
 8021730:	611a      	str	r2, [r3, #16]
 8021732:	e773      	b.n	802161c <USBH_MIDI_SOFProcess+0x20>
				USBH_BulkReceiveData (phost,
 8021734:	7863      	ldrb	r3, [r4, #1]
 8021736:	8922      	ldrh	r2, [r4, #8]
 8021738:	6921      	ldr	r1, [r4, #16]
 802173a:	f7f0 fe55 	bl	80123e8 <USBH_BulkReceiveData>
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 802173e:	2304      	movs	r3, #4
}
 8021740:	2000      	movs	r0, #0
				MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA_WAIT;
 8021742:	7663      	strb	r3, [r4, #25]
}
 8021744:	b003      	add	sp, #12
 8021746:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						MIDI_Handle->pRxData += length;
 802174a:	6922      	ldr	r2, [r4, #16]
						MIDI_Handle->RxDataLength -= length ;
 802174c:	1b98      	subs	r0, r3, r6
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 802174e:	2303      	movs	r3, #3
						MIDI_Handle->pRxData += length;
 8021750:	4432      	add	r2, r6
						MIDI_Handle->RxDataLength -= length ;
 8021752:	82e0      	strh	r0, [r4, #22]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 8021754:	7663      	strb	r3, [r4, #25]
						MIDI_Handle->pRxData += length;
 8021756:	6122      	str	r2, [r4, #16]
						MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 8021758:	e760      	b.n	802161c <USBH_MIDI_SOFProcess+0x20>
 802175a:	bf00      	nop

0802175c <USBH_MIDI_InterfaceDeInit>:
{
 802175c:	b538      	push	{r3, r4, r5, lr}
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 802175e:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
{
 8021762:	4605      	mov	r5, r0
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 8021764:	69dc      	ldr	r4, [r3, #28]
	if ( MIDI_Handle->OutPipe)
 8021766:	78a1      	ldrb	r1, [r4, #2]
 8021768:	b949      	cbnz	r1, 802177e <USBH_MIDI_InterfaceDeInit+0x22>
	if ( MIDI_Handle->InPipe)
 802176a:	7861      	ldrb	r1, [r4, #1]
 802176c:	b991      	cbnz	r1, 8021794 <USBH_MIDI_InterfaceDeInit+0x38>
	if(phost->pActiveClass->pData)
 802176e:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
 8021772:	69da      	ldr	r2, [r3, #28]
 8021774:	b10a      	cbz	r2, 802177a <USBH_MIDI_InterfaceDeInit+0x1e>
		phost->pActiveClass->pData = 0;
 8021776:	2200      	movs	r2, #0
 8021778:	61da      	str	r2, [r3, #28]
}
 802177a:	2000      	movs	r0, #0
 802177c:	bd38      	pop	{r3, r4, r5, pc}
		USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
 802177e:	f7f0 fe55 	bl	801242c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->OutPipe);
 8021782:	78a1      	ldrb	r1, [r4, #2]
 8021784:	4628      	mov	r0, r5
 8021786:	f7f0 fea1 	bl	80124cc <USBH_FreePipe>
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
 802178a:	2300      	movs	r3, #0
	if ( MIDI_Handle->InPipe)
 802178c:	7861      	ldrb	r1, [r4, #1]
		MIDI_Handle->OutPipe = 0;     /* Reset the Channel as Free */
 802178e:	70a3      	strb	r3, [r4, #2]
	if ( MIDI_Handle->InPipe)
 8021790:	2900      	cmp	r1, #0
 8021792:	d0ec      	beq.n	802176e <USBH_MIDI_InterfaceDeInit+0x12>
		USBH_ClosePipe(phost, MIDI_Handle->InPipe);
 8021794:	4628      	mov	r0, r5
 8021796:	f7f0 fe49 	bl	801242c <USBH_ClosePipe>
		USBH_FreePipe  (phost, MIDI_Handle->InPipe);
 802179a:	7861      	ldrb	r1, [r4, #1]
 802179c:	4628      	mov	r0, r5
 802179e:	f7f0 fe95 	bl	80124cc <USBH_FreePipe>
		MIDI_Handle->InPipe = 0;     /* Reset the Channel as Free */
 80217a2:	2300      	movs	r3, #0
 80217a4:	7063      	strb	r3, [r4, #1]
 80217a6:	e7e2      	b.n	802176e <USBH_MIDI_InterfaceDeInit+0x12>

080217a8 <USBH_MIDI_InterfaceInit>:
{	
 80217a8:	b5f0      	push	{r4, r5, r6, r7, lr}
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 80217aa:	23ff      	movs	r3, #255	; 0xff
{	
 80217ac:	b085      	sub	sp, #20
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 80217ae:	2203      	movs	r2, #3
 80217b0:	2101      	movs	r1, #1
{	
 80217b2:	4605      	mov	r5, r0
	interface = USBH_FindInterface(phost, USB_AUDIO_CLASS, USB_MIDISTREAMING_SubCLASS, 0xFF);
 80217b4:	f7ef fb3a 	bl	8010e2c <USBH_FindInterface>
	if(interface == 0xFF) /* No Valid Interface */
 80217b8:	28ff      	cmp	r0, #255	; 0xff
 80217ba:	d05b      	beq.n	8021874 <USBH_MIDI_InterfaceInit+0xcc>
		phost->pActiveClass->pData = &myMIDIHandle;
 80217bc:	f249 04c0 	movw	r4, #37056	; 0x90c0
		USBH_SelectInterface (phost, interface);
 80217c0:	4601      	mov	r1, r0
 80217c2:	4628      	mov	r0, r5
 80217c4:	f7ef fb28 	bl	8010e18 <USBH_SelectInterface>
		phost->pActiveClass->pData = &myMIDIHandle;
 80217c8:	f2c2 0401 	movt	r4, #8193	; 0x2001
 80217cc:	f8d5 34ec 	ldr.w	r3, [r5, #1260]	; 0x4ec
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 80217d0:	222a      	movs	r2, #42	; 0x2a
		phost->pActiveClass->pData = &myMIDIHandle;
 80217d2:	61dc      	str	r4, [r3, #28]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 80217d4:	f895 3324 	ldrb.w	r3, [r5, #804]	; 0x324
 80217d8:	fb02 5203 	mla	r2, r2, r3, r5
 80217dc:	f892 134e 	ldrb.w	r1, [r2, #846]	; 0x34e
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 80217e0:	f8b2 2350 	ldrh.w	r2, [r2, #848]	; 0x350
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress & 0x80)
 80217e4:	0608      	lsls	r0, r1, #24
 80217e6:	d442      	bmi.n	802186e <USBH_MIDI_InterfaceInit+0xc6>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
 80217e8:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 80217ea:	80e2      	strh	r2, [r4, #6]
		if(phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress & 0x80)
 80217ec:	222a      	movs	r2, #42	; 0x2a
 80217ee:	fb02 5303 	mla	r3, r2, r3, r5
 80217f2:	f893 1356 	ldrb.w	r1, [r3, #854]	; 0x356
 80217f6:	f8b3 3358 	ldrh.w	r3, [r3, #856]	; 0x358
 80217fa:	060a      	lsls	r2, r1, #24
 80217fc:	d43d      	bmi.n	802187a <USBH_MIDI_InterfaceInit+0xd2>
			myMIDIHandle.OutEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
 80217fe:	70e1      	strb	r1, [r4, #3]
			myMIDIHandle.OutEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
 8021800:	80e3      	strh	r3, [r4, #6]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 8021802:	4628      	mov	r0, r5
		USBH_OpenPipe  (phost,
 8021804:	2702      	movs	r7, #2
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 8021806:	f7f0 fe17 	bl	8012438 <USBH_AllocPipe>
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 802180a:	7921      	ldrb	r1, [r4, #4]
		myMIDIHandle.OutPipe = USBH_AllocPipe(phost, myMIDIHandle.OutEp);
 802180c:	70a0      	strb	r0, [r4, #2]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 802180e:	4628      	mov	r0, r5
 8021810:	f7f0 fe12 	bl	8012438 <USBH_AllocPipe>
		USBH_OpenPipe  (phost,
 8021814:	f8b4 c006 	ldrh.w	ip, [r4, #6]
		myMIDIHandle.InPipe = USBH_AllocPipe(phost, myMIDIHandle.InEp);
 8021818:	7060      	strb	r0, [r4, #1]
		myMIDIHandle.state = MIDI_IDLE_STATE;
 802181a:	2600      	movs	r6, #0
		USBH_OpenPipe  (phost,
 802181c:	f895 031d 	ldrb.w	r0, [r5, #797]	; 0x31d
 8021820:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
 8021824:	78e2      	ldrb	r2, [r4, #3]
 8021826:	78a1      	ldrb	r1, [r4, #2]
 8021828:	9000      	str	r0, [sp, #0]
 802182a:	4628      	mov	r0, r5
 802182c:	e9cd 7c01 	strd	r7, ip, [sp, #4]
 8021830:	f7f0 fdec 	bl	801240c <USBH_OpenPipe>
		USBH_OpenPipe  (phost,
 8021834:	f895 331c 	ldrb.w	r3, [r5, #796]	; 0x31c
 8021838:	f8b4 c008 	ldrh.w	ip, [r4, #8]
 802183c:	4628      	mov	r0, r5
 802183e:	9701      	str	r7, [sp, #4]
 8021840:	f895 731d 	ldrb.w	r7, [r5, #797]	; 0x31d
 8021844:	7922      	ldrb	r2, [r4, #4]
 8021846:	f8cd c008 	str.w	ip, [sp, #8]
 802184a:	7861      	ldrb	r1, [r4, #1]
 802184c:	9700      	str	r7, [sp, #0]
 802184e:	f7f0 fddd 	bl	801240c <USBH_OpenPipe>
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
 8021852:	4632      	mov	r2, r6
 8021854:	7861      	ldrb	r1, [r4, #1]
 8021856:	4628      	mov	r0, r5
		myMIDIHandle.state = MIDI_IDLE_STATE;
 8021858:	7026      	strb	r6, [r4, #0]
		USBH_LL_SetToggle  (phost, myMIDIHandle.InPipe,0);
 802185a:	f000 f96b 	bl	8021b34 <USBH_LL_SetToggle>
		USBH_LL_SetToggle  (phost, myMIDIHandle.OutPipe,0);
 802185e:	4632      	mov	r2, r6
 8021860:	78a1      	ldrb	r1, [r4, #2]
 8021862:	4628      	mov	r0, r5
 8021864:	f000 f966 	bl	8021b34 <USBH_LL_SetToggle>
 8021868:	4630      	mov	r0, r6
}
 802186a:	b005      	add	sp, #20
 802186c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].bEndpointAddress);
 802186e:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[0].wMaxPacketSize;
 8021870:	8122      	strh	r2, [r4, #8]
 8021872:	e7bb      	b.n	80217ec <USBH_MIDI_InterfaceInit+0x44>
		status = USBH_FAIL;
 8021874:	2002      	movs	r0, #2
}
 8021876:	b005      	add	sp, #20
 8021878:	bdf0      	pop	{r4, r5, r6, r7, pc}
			myMIDIHandle.InEp = (phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].bEndpointAddress);
 802187a:	7121      	strb	r1, [r4, #4]
			myMIDIHandle.InEpSize  = phost->device.CfgDesc.Itf_Desc[phost->device.current_interface].Ep_Desc[1].wMaxPacketSize;
 802187c:	8123      	strh	r3, [r4, #8]
 802187e:	78e1      	ldrb	r1, [r4, #3]
 8021880:	e7bf      	b.n	8021802 <USBH_MIDI_InterfaceInit+0x5a>
 8021882:	bf00      	nop

08021884 <USBH_MIDI_Stop>:
  if(phost->gState == HOST_CLASS)
 8021884:	7802      	ldrb	r2, [r0, #0]
 8021886:	2a0b      	cmp	r2, #11
 8021888:	d001      	beq.n	802188e <USBH_MIDI_Stop+0xa>
}
 802188a:	2000      	movs	r0, #0
 802188c:	4770      	bx	lr
{
 802188e:	b538      	push	{r3, r4, r5, lr}
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 8021890:	f8d0 24ec 	ldr.w	r2, [r0, #1260]	; 0x4ec
    MIDI_Handle->state = MIDI_IDLE_STATE;
 8021894:	2300      	movs	r3, #0
 8021896:	4604      	mov	r4, r0
  MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 8021898:	69d5      	ldr	r5, [r2, #28]
    MIDI_Handle->state = MIDI_IDLE_STATE;
 802189a:	702b      	strb	r3, [r5, #0]
    USBH_ClosePipe(phost, MIDI_Handle->InPipe);
 802189c:	7869      	ldrb	r1, [r5, #1]
 802189e:	f7f0 fdc5 	bl	801242c <USBH_ClosePipe>
    USBH_ClosePipe(phost, MIDI_Handle->OutPipe);
 80218a2:	78a9      	ldrb	r1, [r5, #2]
 80218a4:	4620      	mov	r0, r4
 80218a6:	f7f0 fdc1 	bl	801242c <USBH_ClosePipe>
}
 80218aa:	2000      	movs	r0, #0
 80218ac:	bd38      	pop	{r3, r4, r5, pc}
 80218ae:	bf00      	nop

080218b0 <USBH_MIDI_Receive>:
	MIDI_HandleTypeDef *MIDI_Handle =  phost->pActiveClass->pData;
 80218b0:	f8d0 34ec 	ldr.w	r3, [r0, #1260]	; 0x4ec
 80218b4:	69db      	ldr	r3, [r3, #28]
	if((MIDI_Handle->state == MIDI_IDLE_STATE) || (MIDI_Handle->state == MIDI_TRANSFER_DATA))
 80218b6:	7818      	ldrb	r0, [r3, #0]
 80218b8:	2801      	cmp	r0, #1
 80218ba:	d901      	bls.n	80218c0 <USBH_MIDI_Receive+0x10>
	USBH_StatusTypeDef Status = USBH_BUSY;
 80218bc:	2001      	movs	r0, #1
#if (USBH_USE_OS == 1)
		osMessagePut ( phost->os_event, USBH_CLASS_EVENT, 0);
#endif
	}
	return Status;
}
 80218be:	4770      	bx	lr
{
 80218c0:	b430      	push	{r4, r5}
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 80218c2:	2501      	movs	r5, #1
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 80218c4:	2403      	movs	r4, #3
		MIDI_Handle->pRxData = pbuff;
 80218c6:	6119      	str	r1, [r3, #16]
		Status = USBH_OK;
 80218c8:	2000      	movs	r0, #0
		MIDI_Handle->RxDataLength = length;
 80218ca:	82da      	strh	r2, [r3, #22]
		MIDI_Handle->state = MIDI_TRANSFER_DATA;
 80218cc:	701d      	strb	r5, [r3, #0]
		MIDI_Handle->data_rx_state = MIDI_RECEIVE_DATA;
 80218ce:	765c      	strb	r4, [r3, #25]
}
 80218d0:	bc30      	pop	{r4, r5}
 80218d2:	4770      	bx	lr

080218d4 <HAL_HCD_MspInit>:
/* MSP Init */

void HAL_HCD_MspInit(HCD_HandleTypeDef* hcdHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  if(hcdHandle->Instance==USB_OTG_FS)
 80218d4:	2300      	movs	r3, #0
{
 80218d6:	b570      	push	{r4, r5, r6, lr}
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80218d8:	461c      	mov	r4, r3
  if(hcdHandle->Instance==USB_OTG_FS)
 80218da:	6802      	ldr	r2, [r0, #0]
 80218dc:	f2c4 0308 	movt	r3, #16392	; 0x4008
{
 80218e0:	b088      	sub	sp, #32
  if(hcdHandle->Instance==USB_OTG_FS)
 80218e2:	429a      	cmp	r2, r3
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 80218e4:	9407      	str	r4, [sp, #28]
 80218e6:	e9cd 4403 	strd	r4, r4, [sp, #12]
 80218ea:	e9cd 4405 	strd	r4, r4, [sp, #20]
  if(hcdHandle->Instance==USB_OTG_FS)
 80218ee:	d001      	beq.n	80218f4 <HAL_HCD_MspInit+0x20>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
  /* USER CODE BEGIN USB_OTG_FS_MspInit 1 */
//
  /* USER CODE END USB_OTG_FS_MspInit 1 */
  }
}
 80218f0:	b008      	add	sp, #32
 80218f2:	bd70      	pop	{r4, r5, r6, pc}
    __HAL_RCC_GPIOA_CLK_ENABLE();
 80218f4:	f44f 4588 	mov.w	r5, #17408	; 0x4400
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 80218f8:	f44f 56c0 	mov.w	r6, #6144	; 0x1800
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 80218fc:	2202      	movs	r2, #2
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 80218fe:	4620      	mov	r0, r4
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8021900:	f6c5 0502 	movt	r5, #22530	; 0x5802
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8021904:	a903      	add	r1, sp, #12
 8021906:	f6c5 0002 	movt	r0, #22530	; 0x5802
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802190a:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
 802190e:	f043 0301 	orr.w	r3, r3, #1
 8021912:	f8c5 30e0 	str.w	r3, [r5, #224]	; 0xe0
 8021916:	f8d5 30e0 	ldr.w	r3, [r5, #224]	; 0xe0
    GPIO_InitStruct.Pin = GPIO_PIN_11|GPIO_PIN_12;
 802191a:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 802191c:	2603      	movs	r6, #3
    __HAL_RCC_GPIOA_CLK_ENABLE();
 802191e:	f003 0301 	and.w	r3, r3, #1
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8021922:	9204      	str	r2, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 8021924:	220a      	movs	r2, #10
    __HAL_RCC_GPIOA_CLK_ENABLE();
 8021926:	9301      	str	r3, [sp, #4]
 8021928:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Alternate = GPIO_AF10_OTG1_FS;
 802192a:	e9cd 6206 	strd	r6, r2, [sp, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 802192e:	f7e4 fad9 	bl	8005ee4 <HAL_GPIO_Init>
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8021932:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
 8021936:	4622      	mov	r2, r4
 8021938:	2101      	movs	r1, #1
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 802193a:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
 802193e:	2065      	movs	r0, #101	; 0x65
    __HAL_RCC_USB_OTG_FS_CLK_ENABLE();
 8021940:	f8c5 30d8 	str.w	r3, [r5, #216]	; 0xd8
 8021944:	f8d5 30d8 	ldr.w	r3, [r5, #216]	; 0xd8
 8021948:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 802194c:	9302      	str	r3, [sp, #8]
 802194e:	9b02      	ldr	r3, [sp, #8]
    HAL_NVIC_SetPriority(OTG_FS_IRQn, 1, 0);
 8021950:	f7e0 fe36 	bl	80025c0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(OTG_FS_IRQn);
 8021954:	2065      	movs	r0, #101	; 0x65
 8021956:	f7e0 fe83 	bl	8002660 <HAL_NVIC_EnableIRQ>
}
 802195a:	b008      	add	sp, #32
 802195c:	bd70      	pop	{r4, r5, r6, pc}
 802195e:	bf00      	nop

08021960 <HAL_HCD_SOF_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_SOF_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_IncTimer(hhcd->pData);
 8021960:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8021964:	f7ef bdbe 	b.w	80114e4 <USBH_LL_IncTimer>

08021968 <HAL_HCD_Connect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Connect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Connect(hhcd->pData);
 8021968:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 802196c:	f7ef bdd2 	b.w	8011514 <USBH_LL_Connect>

08021970 <HAL_HCD_Disconnect_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_Disconnect_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_Disconnect(hhcd->pData);
 8021970:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8021974:	f7ef bdda 	b.w	801152c <USBH_LL_Disconnect>

08021978 <HAL_HCD_HC_NotifyURBChange_Callback>:
{
  /* To be used with OS to sync URB state with the global state machine */
#if (USBH_USE_OS == 1)
  USBH_LL_NotifyURBChange(hhcd->pData);
#endif
}
 8021978:	4770      	bx	lr
 802197a:	bf00      	nop

0802197c <HAL_HCD_PortEnabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortEnabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortEnabled(hhcd->pData);
 802197c:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8021980:	f7ef bdc0 	b.w	8011504 <USBH_LL_PortEnabled>

08021984 <HAL_HCD_PortDisabled_Callback>:
  * @param  hhcd: HCD handle
  * @retval None
  */
void HAL_HCD_PortDisabled_Callback(HCD_HandleTypeDef *hhcd)
{
  USBH_LL_PortDisabled(hhcd->pData);
 8021984:	f8d0 02c0 	ldr.w	r0, [r0, #704]	; 0x2c0
 8021988:	f7ef bdc0 	b.w	801150c <USBH_LL_PortDisabled>

0802198c <USBH_LL_Init>:
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Init(USBH_HandleTypeDef *phost)
{
  /* Init USB_IP */
  if (phost->id == HOST_FS) {
 802198c:	f890 253c 	ldrb.w	r2, [r0, #1340]	; 0x53c
 8021990:	2a01      	cmp	r2, #1
 8021992:	d001      	beq.n	8021998 <USBH_LL_Init+0xc>
  }

  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
  }
  return USBH_OK;
}
 8021994:	2000      	movs	r0, #0
 8021996:	4770      	bx	lr
{
 8021998:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 802199a:	f249 13dc 	movw	r3, #37340	; 0x91dc
 802199e:	2100      	movs	r1, #0
 80219a0:	4604      	mov	r4, r0
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
 80219a2:	2706      	movs	r7, #6
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80219a4:	f2c2 0301 	movt	r3, #8193	; 0x2001
  hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED;
 80219a8:	2602      	movs	r6, #2
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80219aa:	f2c4 0108 	movt	r1, #16392	; 0x4008
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 80219ae:	2500      	movs	r5, #0
  phost->pData = &hhcd_USB_OTG_FS;
 80219b0:	f8c0 3540 	str.w	r3, [r0, #1344]	; 0x540
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 80219b4:	4618      	mov	r0, r3
  hhcd_USB_OTG_FS.pData = phost;
 80219b6:	f8c3 42c0 	str.w	r4, [r3, #704]	; 0x2c0
  hhcd_USB_OTG_FS.Instance = USB_OTG_FS;
 80219ba:	6019      	str	r1, [r3, #0]
  hhcd_USB_OTG_FS.Init.Host_channels = 6;
 80219bc:	609f      	str	r7, [r3, #8]
  hhcd_USB_OTG_FS.Init.dma_enable = ENABLE;
 80219be:	e9c3 2203 	strd	r2, r2, [r3, #12]
  hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;
 80219c2:	e9c3 6506 	strd	r6, r5, [r3, #24]
  if (HAL_HCD_Init(&hhcd_USB_OTG_FS) != HAL_OK)
 80219c6:	f7e4 fea3 	bl	8006710 <HAL_HCD_Init>
 80219ca:	b958      	cbnz	r0, 80219e4 <USBH_LL_Init+0x58>
  USBH_LL_SetTimer(phost, HAL_HCD_GetCurrentFrame(&hhcd_USB_OTG_FS));
 80219cc:	f249 10dc 	movw	r0, #37340	; 0x91dc
 80219d0:	f2c2 0001 	movt	r0, #8193	; 0x2001
 80219d4:	f7e5 fb42 	bl	800705c <HAL_HCD_GetCurrentFrame>
 80219d8:	4601      	mov	r1, r0
 80219da:	4620      	mov	r0, r4
 80219dc:	f7ef fd7e 	bl	80114dc <USBH_LL_SetTimer>
}
 80219e0:	2000      	movs	r0, #0
 80219e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    Error_Handler( );
 80219e4:	f7f3 ff3e 	bl	8015864 <Error_Handler>
 80219e8:	e7f0      	b.n	80219cc <USBH_LL_Init+0x40>
 80219ea:	bf00      	nop

080219ec <USBH_LL_Start>:
  * @brief  Start the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Start(USBH_HandleTypeDef *phost)
{
 80219ec:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Start(phost->pData);
 80219ee:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 80219f2:	f7e5 faf9 	bl	8006fe8 <HAL_HCD_Start>
 80219f6:	2803      	cmp	r0, #3
 80219f8:	d805      	bhi.n	8021a06 <USBH_LL_Start+0x1a>
 80219fa:	f240 1388 	movw	r3, #392	; 0x188
 80219fe:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021a02:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8021a04:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Start(phost->pData);
 8021a06:	2002      	movs	r0, #2
}
 8021a08:	bd08      	pop	{r3, pc}
 8021a0a:	bf00      	nop

08021a0c <USBH_LL_Stop>:
  * @brief  Stop the low level portion of the host driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_Stop(USBH_HandleTypeDef *phost)
{
 8021a0c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_Stop(phost->pData);
 8021a0e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021a12:	f7e5 faff 	bl	8007014 <HAL_HCD_Stop>
 8021a16:	2803      	cmp	r0, #3
 8021a18:	d805      	bhi.n	8021a26 <USBH_LL_Stop+0x1a>
 8021a1a:	f240 1388 	movw	r3, #392	; 0x188
 8021a1e:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021a22:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
 
  return usb_status;
}
 8021a24:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_Stop(phost->pData);
 8021a26:	2002      	movs	r0, #2
}
 8021a28:	bd08      	pop	{r3, pc}
 8021a2a:	bf00      	nop

08021a2c <USBH_LL_GetSpeed>:
  * @brief  Return the USB host speed from the low level driver.
  * @param  phost: Host handle
  * @retval USBH speeds
  */
USBH_SpeedTypeDef USBH_LL_GetSpeed(USBH_HandleTypeDef *phost)
{
 8021a2c:	b508      	push	{r3, lr}
  USBH_SpeedTypeDef speed = USBH_SPEED_FULL;

  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 8021a2e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021a32:	f7e5 fb17 	bl	8007064 <HAL_HCD_GetCurrentSpeed>
 8021a36:	2802      	cmp	r0, #2
 8021a38:	d805      	bhi.n	8021a46 <USBH_LL_GetSpeed+0x1a>
 8021a3a:	f240 1384 	movw	r3, #388	; 0x184
 8021a3e:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021a42:	5c18      	ldrb	r0, [r3, r0]
  default:
   speed = USBH_SPEED_FULL;
    break;
  }
  return  speed;
}
 8021a44:	bd08      	pop	{r3, pc}
  switch (HAL_HCD_GetCurrentSpeed(phost->pData))
 8021a46:	2001      	movs	r0, #1
}
 8021a48:	bd08      	pop	{r3, pc}
 8021a4a:	bf00      	nop

08021a4c <USBH_LL_ResetPort>:
  * @brief  Reset the Host port of the low level driver.
  * @param  phost: Host handle
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ResetPort(USBH_HandleTypeDef *phost)
{
 8021a4c:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_ResetPort(phost->pData);
 8021a4e:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021a52:	f7e5 faf1 	bl	8007038 <HAL_HCD_ResetPort>
 8021a56:	2803      	cmp	r0, #3
 8021a58:	d805      	bhi.n	8021a66 <USBH_LL_ResetPort+0x1a>
 8021a5a:	f240 1388 	movw	r3, #392	; 0x188
 8021a5e:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021a62:	5c18      	ldrb	r0, [r3, r0]
  
  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8021a64:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_ResetPort(phost->pData);
 8021a66:	2002      	movs	r0, #2
}
 8021a68:	bd08      	pop	{r3, pc}
 8021a6a:	bf00      	nop

08021a6c <USBH_LL_GetLastXferSize>:
  * @param  pipe: Pipe index
  * @retval Packet size
  */
uint32_t USBH_LL_GetLastXferSize(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return HAL_HCD_HC_GetXferCount(phost->pData, pipe);
 8021a6c:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021a70:	f7e5 baee 	b.w	8007050 <HAL_HCD_HC_GetXferCount>

08021a74 <USBH_LL_OpenPipe>:
  * @param  mps: Endpoint max packet size
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_OpenPipe(USBH_HandleTypeDef *phost, uint8_t pipe_num, uint8_t epnum,
                                    uint8_t dev_address, uint8_t speed, uint8_t ep_type, uint16_t mps)
{
 8021a74:	b530      	push	{r4, r5, lr}
 8021a76:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8021a78:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
 8021a7c:	f89d 4020 	ldrb.w	r4, [sp, #32]
 8021a80:	f89d 5024 	ldrb.w	r5, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8021a84:	9400      	str	r4, [sp, #0]
{
 8021a86:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8021a8a:	e9cd 5401 	strd	r5, r4, [sp, #4]
 8021a8e:	f7e4 fdf1 	bl	8006674 <HAL_HCD_HC_Init>
 8021a92:	2803      	cmp	r0, #3
 8021a94:	d806      	bhi.n	8021aa4 <USBH_LL_OpenPipe+0x30>
 8021a96:	f240 1388 	movw	r3, #392	; 0x188
 8021a9a:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021a9e:	5c18      	ldrb	r0, [r3, r0]
                               dev_address, speed, ep_type, mps);

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8021aa0:	b005      	add	sp, #20
 8021aa2:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_Init(phost->pData, pipe_num, epnum,
 8021aa4:	2002      	movs	r0, #2
}
 8021aa6:	b005      	add	sp, #20
 8021aa8:	bd30      	pop	{r4, r5, pc}
 8021aaa:	bf00      	nop

08021aac <USBH_LL_ClosePipe>:
  * @param  phost: Host handle
  * @param  pipe: Pipe index
  * @retval USBH status
  */
USBH_StatusTypeDef USBH_LL_ClosePipe(USBH_HandleTypeDef *phost, uint8_t pipe)
{
 8021aac:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 8021aae:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021ab2:	f7e4 fe1b 	bl	80066ec <HAL_HCD_HC_Halt>
 8021ab6:	2803      	cmp	r0, #3
 8021ab8:	d805      	bhi.n	8021ac6 <USBH_LL_ClosePipe+0x1a>
 8021aba:	f240 1388 	movw	r3, #392	; 0x188
 8021abe:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021ac2:	5c18      	ldrb	r0, [r3, r0]

  usb_status = USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8021ac4:	bd08      	pop	{r3, pc}
  hal_status = HAL_HCD_HC_Halt(phost->pData, pipe);
 8021ac6:	2002      	movs	r0, #2
}
 8021ac8:	bd08      	pop	{r3, pc}
 8021aca:	bf00      	nop

08021acc <USBH_LL_SubmitURB>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SubmitURB(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t direction,
                                     uint8_t ep_type, uint8_t token, uint8_t *pbuff, uint16_t length,
                                     uint8_t do_ping)
{
 8021acc:	b530      	push	{r4, r5, lr}
 8021ace:	b085      	sub	sp, #20
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBH_StatusTypeDef usb_status = USBH_OK;

  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8021ad0:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
{
 8021ad4:	f89d 5020 	ldrb.w	r5, [sp, #32]
 8021ad8:	9c09      	ldr	r4, [sp, #36]	; 0x24
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8021ada:	9500      	str	r5, [sp, #0]
 8021adc:	9401      	str	r4, [sp, #4]
{
 8021ade:	f8bd 5028 	ldrh.w	r5, [sp, #40]	; 0x28
 8021ae2:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8021ae6:	e9cd 5402 	strd	r5, r4, [sp, #8]
 8021aea:	f7e4 fe73 	bl	80067d4 <HAL_HCD_HC_SubmitRequest>
 8021aee:	2803      	cmp	r0, #3
 8021af0:	d806      	bhi.n	8021b00 <USBH_LL_SubmitURB+0x34>
 8021af2:	f240 1388 	movw	r3, #392	; 0x188
 8021af6:	f6c0 0303 	movt	r3, #2051	; 0x803
 8021afa:	5c18      	ldrb	r0, [r3, r0]
                                        ep_type, token, pbuff, length,
                                        do_ping);
  usb_status =  USBH_Get_USB_Status(hal_status);
  
  return usb_status;
}
 8021afc:	b005      	add	sp, #20
 8021afe:	bd30      	pop	{r4, r5, pc}
  hal_status = HAL_HCD_HC_SubmitRequest(phost->pData, pipe, direction ,
 8021b00:	2002      	movs	r0, #2
}
 8021b02:	b005      	add	sp, #20
 8021b04:	bd30      	pop	{r4, r5, pc}
 8021b06:	bf00      	nop

08021b08 <USBH_LL_GetURBState>:
  *            @arg URB_ERROR
  *            @arg URB_STALL
  */
USBH_URBStateTypeDef USBH_LL_GetURBState(USBH_HandleTypeDef *phost, uint8_t pipe)
{
  return (USBH_URBStateTypeDef)HAL_HCD_HC_GetURBState (phost->pData, pipe);
 8021b08:	f8d0 0540 	ldr.w	r0, [r0, #1344]	; 0x540
 8021b0c:	f7e5 ba98 	b.w	8007040 <HAL_HCD_HC_GetURBState>

08021b10 <USBH_LL_DriverVBUS>:
  *           0 : VBUS Active
  *           1 : VBUS Inactive
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_DriverVBUS(USBH_HandleTypeDef *phost, uint8_t state)
{
 8021b10:	b508      	push	{r3, lr}
  if (phost->id == HOST_FS) {
 8021b12:	f890 353c 	ldrb.w	r3, [r0, #1340]	; 0x53c
 8021b16:	2b01      	cmp	r3, #1
 8021b18:	d004      	beq.n	8021b24 <USBH_LL_DriverVBUS+0x14>

  /* USER CODE BEGIN 0 */

  /* USER CODE END 0*/

  HAL_Delay(200);
 8021b1a:	20c8      	movs	r0, #200	; 0xc8
 8021b1c:	f7de ff94 	bl	8000a48 <HAL_Delay>
  return USBH_OK;
}
 8021b20:	2000      	movs	r0, #0
 8021b22:	bd08      	pop	{r3, pc}
    MX_DriverVbusFS(state);
 8021b24:	4608      	mov	r0, r1
 8021b26:	f000 f819 	bl	8021b5c <MX_DriverVbusFS>
  HAL_Delay(200);
 8021b2a:	20c8      	movs	r0, #200	; 0xc8
 8021b2c:	f7de ff8c 	bl	8000a48 <HAL_Delay>
}
 8021b30:	2000      	movs	r0, #0
 8021b32:	bd08      	pop	{r3, pc}

08021b34 <USBH_LL_SetToggle>:
  * @retval Status
  */
USBH_StatusTypeDef USBH_LL_SetToggle(USBH_HandleTypeDef *phost, uint8_t pipe, uint8_t toggle)
{
  HCD_HandleTypeDef *pHandle;
  pHandle = phost->pData;
 8021b34:	f8d0 3540 	ldr.w	r3, [r0, #1344]	; 0x540

  if(pHandle->hc[pipe].ep_is_in)
 8021b38:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8021b3c:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
 8021b40:	f891 303b 	ldrb.w	r3, [r1, #59]	; 0x3b
 8021b44:	b91b      	cbnz	r3, 8021b4e <USBH_LL_SetToggle+0x1a>
  {
    pHandle->hc[pipe].toggle_in = toggle;
  }
  else
  {
    pHandle->hc[pipe].toggle_out = toggle;
 8021b46:	f881 2051 	strb.w	r2, [r1, #81]	; 0x51
  }

  return USBH_OK;
}
 8021b4a:	2000      	movs	r0, #0
 8021b4c:	4770      	bx	lr
    pHandle->hc[pipe].toggle_in = toggle;
 8021b4e:	f881 2050 	strb.w	r2, [r1, #80]	; 0x50
}
 8021b52:	2000      	movs	r0, #0
 8021b54:	4770      	bx	lr
 8021b56:	bf00      	nop

08021b58 <USBH_Delay>:
  * @param  Delay: Delay in ms
  * @retval None
  */
void USBH_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 8021b58:	f7de bf76 	b.w	8000a48 <HAL_Delay>

08021b5c <MX_DriverVbusFS>:
  {
    /* Drive low Charge pump */
    data = GPIO_PIN_RESET;
  }
  /* USER CODE END PREPARE_GPIO_DATA_VBUS_FS */
  HAL_GPIO_WritePin(GPIOF,GPIO_PIN_6,(GPIO_PinState)data);
 8021b5c:	fab0 f280 	clz	r2, r0
 8021b60:	f44f 50a0 	mov.w	r0, #5120	; 0x1400
 8021b64:	2140      	movs	r1, #64	; 0x40
 8021b66:	0952      	lsrs	r2, r2, #5
 8021b68:	f6c5 0002 	movt	r0, #22530	; 0x5802
 8021b6c:	f7e4 bd64 	b.w	8006638 <HAL_GPIO_WritePin>

08021b70 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8021b70:	f8df d034 	ldr.w	sp, [pc, #52]	; 8021ba8 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8021b74:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 8021b76:	e003      	b.n	8021b80 <LoopCopyDataInit>

08021b78 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 8021b78:	4b0c      	ldr	r3, [pc, #48]	; (8021bac <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 8021b7a:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8021b7c:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8021b7e:	3104      	adds	r1, #4

08021b80 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8021b80:	480b      	ldr	r0, [pc, #44]	; (8021bb0 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8021b82:	4b0c      	ldr	r3, [pc, #48]	; (8021bb4 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8021b84:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8021b86:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8021b88:	d3f6      	bcc.n	8021b78 <CopyDataInit>
  ldr  r2, =_sbss
 8021b8a:	4a0b      	ldr	r2, [pc, #44]	; (8021bb8 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8021b8c:	e002      	b.n	8021b94 <LoopFillZerobss>

08021b8e <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 8021b8e:	2300      	movs	r3, #0
  str  r3, [r2], #4
 8021b90:	f842 3b04 	str.w	r3, [r2], #4

08021b94 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8021b94:	4b09      	ldr	r3, [pc, #36]	; (8021bbc <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8021b96:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8021b98:	d3f9      	bcc.n	8021b8e <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8021b9a:	f7fd fc41 	bl	801f420 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8021b9e:	f009 f863 	bl	802ac68 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 8021ba2:	f7f3 fd15 	bl	80155d0 <main>
  bx  lr    
 8021ba6:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8021ba8:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8021bac:	080502f0 	.word	0x080502f0
  ldr  r0, =_sdata
 8021bb0:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8021bb4:	2000049c 	.word	0x2000049c
  ldr  r2, =_sbss
 8021bb8:	200004a0 	.word	0x200004a0
  ldr  r3, = _ebss
 8021bbc:	200194d0 	.word	0x200194d0

08021bc0 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8021bc0:	e7fe      	b.n	8021bc0 <ADC3_IRQHandler>
	...

08021bc4 <mayer_fht>:
 REAL f0,g0,f1,g1,f2,g2,f3,g3; */
 int  k,k1,k2,k3,k4,kx;
 REAL *fi,*fn,*gi;
 TRIG_VARS;

 for (k1=1,k2=0;k1<n;k1++)
 8021bc4:	2901      	cmp	r1, #1
{
 8021bc6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8021bca:	468e      	mov	lr, r1
 8021bcc:	ed2d 8b02 	vpush	{d8}
 8021bd0:	b08d      	sub	sp, #52	; 0x34
 for (k1=1,k2=0;k1<n;k1++)
 8021bd2:	f340 824e 	ble.w	8022072 <mayer_fht+0x4ae>
    {
     REAL aa;
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 8021bd6:	ea4f 0a61 	mov.w	sl, r1, asr #1
 8021bda:	f100 0904 	add.w	r9, r0, #4
 for (k1=1,k2=0;k1<n;k1++)
 8021bde:	f04f 0c00 	mov.w	ip, #0
 8021be2:	f04f 0801 	mov.w	r8, #1
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 8021be6:	ea3a 010c 	bics.w	r1, sl, ip
 8021bea:	ea8a 040c 	eor.w	r4, sl, ip
 8021bee:	f040 823e 	bne.w	802206e <mayer_fht+0x4aa>
 8021bf2:	4651      	mov	r1, sl
 8021bf4:	1049      	asrs	r1, r1, #1
 8021bf6:	ea81 0c04 	eor.w	ip, r1, r4
 8021bfa:	ea21 0504 	bic.w	r5, r1, r4
 8021bfe:	4664      	mov	r4, ip
 8021c00:	2d00      	cmp	r5, #0
 8021c02:	d0f7      	beq.n	8021bf4 <mayer_fht+0x30>
     if (k1>k2)
 8021c04:	45e0      	cmp	r8, ip
 8021c06:	dd07      	ble.n	8021c18 <mayer_fht+0x54>
        {
             aa=fz[k1];fz[k1]=fz[k2];fz[k2]=aa;
 8021c08:	eb00 018c 	add.w	r1, r0, ip, lsl #2
 8021c0c:	f8d9 4000 	ldr.w	r4, [r9]
 8021c10:	680d      	ldr	r5, [r1, #0]
 8021c12:	f8c9 5000 	str.w	r5, [r9]
 8021c16:	600c      	str	r4, [r1, #0]
 for (k1=1,k2=0;k1<n;k1++)
 8021c18:	f108 0801 	add.w	r8, r8, #1
 8021c1c:	f109 0904 	add.w	r9, r9, #4
 8021c20:	45c6      	cmp	lr, r8
 8021c22:	d1e0      	bne.n	8021be6 <mayer_fht+0x22>
        }
    }
 for ( k=0 ; (1<<k)<n ; k++ );
 8021c24:	2100      	movs	r1, #0
 8021c26:	2501      	movs	r5, #1
 8021c28:	3101      	adds	r1, #1
 8021c2a:	fa05 f401 	lsl.w	r4, r5, r1
 8021c2e:	4544      	cmp	r4, r8
 8021c30:	dbfa      	blt.n	8021c28 <mayer_fht+0x64>
 k  &= 1;
 if (k==0)
 8021c32:	f011 0101 	ands.w	r1, r1, #1
 8021c36:	eb00 0a88 	add.w	sl, r0, r8, lsl #2
 8021c3a:	9101      	str	r1, [sp, #4]
 8021c3c:	f000 821b 	beq.w	8022076 <mayer_fht+0x4b2>
             fi[1 ] = (f1+f3);
            }
    }
 else
    {
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
 8021c40:	4550      	cmp	r0, sl
 8021c42:	d26e      	bcs.n	8021d22 <mayer_fht+0x15e>
 8021c44:	f100 0420 	add.w	r4, r0, #32
             bf0     = (bs1 + bs2);
             bg1     = (bc1 - bc2);     
             bg0     = (bc1 + bc2);
             bf3     = (bs3 - bs4);     
             bf2     = (bs3 + bs4);
             bg3     = SQRT2*bc4;               
 8021c48:	f643 36cd 	movw	r6, #15309	; 0x3bcd
 8021c4c:	f24a 079e 	movw	r7, #41118	; 0xa09e
 8021c50:	f100 0540 	add.w	r5, r0, #64	; 0x40
 8021c54:	f1c4 011f 	rsb	r1, r4, #31
 8021c58:	f2c6 667f 	movt	r6, #26239	; 0x667f
 8021c5c:	f6c3 77f6 	movt	r7, #16374	; 0x3ff6
 8021c60:	4451      	add	r1, sl
 8021c62:	f021 011f 	bic.w	r1, r1, #31
 8021c66:	4429      	add	r1, r5
 8021c68:	ec47 6b13 	vmov	d3, r6, r7
             bc3     = fi[4 ] - gi[4 ];
 8021c6c:	ed54 7a03 	vldr	s15, [r4, #-12]
 8021c70:	3420      	adds	r4, #32
             bc4     = fi[6 ] - gi[6 ];
 8021c72:	ed14 6a0a 	vldr	s12, [r4, #-40]	; 0xffffffd8
 8021c76:	ed14 7a09 	vldr	s14, [r4, #-36]	; 0xffffffdc
             bc3     = fi[4 ] - gi[4 ];
 8021c7a:	ed54 6a0c 	vldr	s13, [r4, #-48]	; 0xffffffd0
             bc4     = fi[6 ] - gi[6 ];
 8021c7e:	ee36 2a47 	vsub.f32	s4, s12, s14
             bc1     = fi[0 ] - gi[0 ];
 8021c82:	ed54 5a0f 	vldr	s11, [r4, #-60]	; 0xffffffc4
             bc3     = fi[4 ] - gi[4 ];
 8021c86:	ee36 0ae7 	vsub.f32	s0, s13, s15
             bc2     = fi[2 ] - gi[2 ];
 8021c8a:	ed54 4a0e 	vldr	s9, [r4, #-56]	; 0xffffffc8
             bc1     = fi[0 ] - gi[0 ];
 8021c8e:	ed14 5a10 	vldr	s10, [r4, #-64]	; 0xffffffc0
             bs3     = fi[4 ] + gi[4 ];
 8021c92:	ee76 6aa7 	vadd.f32	s13, s13, s15
             bg3     = SQRT2*bc4;               
 8021c96:	eeb7 2ac2 	vcvt.f64.f32	d2, s4
             bc2     = fi[2 ] - gi[2 ];
 8021c9a:	ed54 7a0d 	vldr	s15, [r4, #-52]	; 0xffffffcc
             bg2     = SQRT2*bc3;
 8021c9e:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
             bc1     = fi[0 ] - gi[0 ];
 8021ca2:	ee75 1a65 	vsub.f32	s3, s10, s11
             bg3     = SQRT2*bc4;               
 8021ca6:	ee22 2b03 	vmul.f64	d2, d2, d3
             bg2     = SQRT2*bc3;
 8021caa:	ee20 0b03 	vmul.f64	d0, d0, d3
             bc2     = fi[2 ] - gi[2 ];
 8021cae:	ee34 4ae7 	vsub.f32	s8, s9, s15
             bs1     = fi[0 ] + gi[0 ];
 8021cb2:	ee35 5a25 	vadd.f32	s10, s10, s11
             bg3     = SQRT2*bc4;               
 8021cb6:	eeb7 2bc2 	vcvt.f32.f64	s4, d2
             bs2     = fi[2 ] + gi[2 ];
 8021cba:	ee74 5aa7 	vadd.f32	s11, s9, s15
             bg2     = SQRT2*bc3;
 8021cbe:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
             bs4     = fi[6 ] + gi[6 ];
 8021cc2:	ee76 7a07 	vadd.f32	s15, s12, s14
             bg0     = (bc1 + bc2);
 8021cc6:	ee31 1a84 	vadd.f32	s2, s3, s8
             bg1     = (bc1 - bc2);     
 8021cca:	ee71 4ac4 	vsub.f32	s9, s3, s8
             bf1     = (bs1 - bs2);     
 8021cce:	ee35 7a65 	vsub.f32	s14, s10, s11
             bf2     = (bs3 + bs4);
 8021cd2:	ee36 6aa7 	vadd.f32	s12, s13, s15
             bf0     = (bs1 + bs2);
 8021cd6:	ee75 5a25 	vadd.f32	s11, s10, s11
             bf3     = (bs3 - bs4);     
 8021cda:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[4 ] = bf0 - bf2;
             fi[0 ] = bf0 + bf2;
             fi[6 ] = bf1 - bf3;
             fi[2 ] = bf1 + bf3;
             gi[4 ] = bg0 - bg2;
 8021cde:	ee31 5a40 	vsub.f32	s10, s2, s0
             gi[0 ] = bg0 + bg2;
             gi[6 ] = bg1 - bg3;
 8021ce2:	ee74 6ac2 	vsub.f32	s13, s9, s4
             gi[0 ] = bg0 + bg2;
 8021ce6:	ee31 0a00 	vadd.f32	s0, s2, s0
             gi[4 ] = bg0 - bg2;
 8021cea:	ed04 5a0b 	vstr	s10, [r4, #-44]	; 0xffffffd4
             gi[2 ] = bg1 + bg3;
 8021cee:	ee34 2a82 	vadd.f32	s4, s9, s4
             gi[6 ] = bg1 - bg3;
 8021cf2:	ed44 6a09 	vstr	s13, [r4, #-36]	; 0xffffffdc
             fi[4 ] = bf0 - bf2;
 8021cf6:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[6 ] = bf1 - bf3;
 8021cfa:	ee77 6a67 	vsub.f32	s13, s14, s15
             gi[0 ] = bg0 + bg2;
 8021cfe:	ed04 0a0f 	vstr	s0, [r4, #-60]	; 0xffffffc4
             fi[0 ] = bf0 + bf2;
 8021d02:	ee35 6a86 	vadd.f32	s12, s11, s12
             gi[2 ] = bg1 + bg3;
 8021d06:	ed04 2a0d 	vstr	s4, [r4, #-52]	; 0xffffffcc
             fi[2 ] = bf1 + bf3;
 8021d0a:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[4 ] = bf0 - bf2;
 8021d0e:	ed04 5a0c 	vstr	s10, [r4, #-48]	; 0xffffffd0
             fi[6 ] = bf1 - bf3;
 8021d12:	ed44 6a0a 	vstr	s13, [r4, #-40]	; 0xffffffd8
             fi[0 ] = bf0 + bf2;
 8021d16:	ed04 6a10 	vstr	s12, [r4, #-64]	; 0xffffffc0
             fi[2 ] = bf1 + bf3;
 8021d1a:	ed44 7a0e 	vstr	s15, [r4, #-56]	; 0xffffffc8
         for (fi=fz,fn=fz+n,gi=fi+1;fi<fn;fi+=8,gi+=8)
 8021d1e:	42a1      	cmp	r1, r4
 8021d20:	d1a4      	bne.n	8021c6c <mayer_fht+0xa8>
            }
    }
 if (n<16) return;
 8021d22:	f1be 0f0f 	cmp.w	lr, #15
 8021d26:	f340 819d 	ble.w	8022064 <mayer_fht+0x4a0>
 8021d2a:	9901      	ldr	r1, [sp, #4]
             fi[0 ]  = f0         + f2;
             fi[k3]  = f1         - f3;
             fi[k1]  = f1         + f3;
             g1      = gi[0 ] - gi[k1];
             g0      = gi[0 ] + gi[k1];
             g3      = SQRT2  * gi[k3];
 8021d2c:	f643 32cd 	movw	r2, #15309	; 0x3bcd
 8021d30:	f24a 039e 	movw	r3, #41118	; 0xa09e
 8021d34:	3101      	adds	r1, #1
 8021d36:	f2c6 627f 	movt	r2, #26239	; 0x667f
 8021d3a:	f6c3 73f6 	movt	r3, #16374	; 0x3ff6
 8021d3e:	0089      	lsls	r1, r1, #2
 8021d40:	9107      	str	r1, [sp, #28]
            } while (fi<fn);
     TRIG_INIT(k,c1,s1);
     for (ii=1;ii<kx;ii++)
        {
         REAL c2,s2;
         TRIG_NEXT(k,c1,s1);
 8021d42:	f240 11dc 	movw	r1, #476	; 0x1dc
 8021d46:	f6c0 0103 	movt	r1, #2051	; 0x803
             g3      = SQRT2  * gi[k3];
 8021d4a:	ec43 2b18 	vmov	d8, r2, r3
 8021d4e:	e9cd 0e0a 	strd	r0, lr, [sp, #40]	; 0x28
         TRIG_NEXT(k,c1,s1);
 8021d52:	9108      	str	r1, [sp, #32]
     k  += 2;
 8021d54:	9901      	ldr	r1, [sp, #4]
     k1  = 1  << k;
 8021d56:	2501      	movs	r5, #1
             f1      = fi[0 ] - fi[k1];
 8021d58:	2204      	movs	r2, #4
             gi     += k4;
 8021d5a:	980a      	ldr	r0, [sp, #40]	; 0x28
     k  += 2;
 8021d5c:	3102      	adds	r1, #2
             gi     += k4;
 8021d5e:	4603      	mov	r3, r0
     k1  = 1  << k;
 8021d60:	408d      	lsls	r5, r1
             f1      = fi[0 ] - fi[k1];
 8021d62:	fa02 f401 	lsl.w	r4, r2, r1
     k  += 2;
 8021d66:	9101      	str	r1, [sp, #4]
     kx  = k1 >> 1;
 8021d68:	106f      	asrs	r7, r5, #1
 8021d6a:	eb00 0e04 	add.w	lr, r0, r4
     k3  = k2 + k1;
 8021d6e:	eb05 0145 	add.w	r1, r5, r5, lsl #1
             f1      = fi[0 ] - fi[k1];
 8021d72:	9404      	str	r4, [sp, #16]
         gi  = fi + kx;
 8021d74:	eb00 0287 	add.w	r2, r0, r7, lsl #2
     kx  = k1 >> 1;
 8021d78:	9703      	str	r7, [sp, #12]
             f3      = fi[k2] - fi[k3];
 8021d7a:	0089      	lsls	r1, r1, #2
 8021d7c:	00ee      	lsls	r6, r5, #3
 8021d7e:	eb02 0c04 	add.w	ip, r2, r4
 8021d82:	460c      	mov	r4, r1
 8021d84:	9106      	str	r1, [sp, #24]
 8021d86:	9605      	str	r6, [sp, #20]
 8021d88:	1857      	adds	r7, r2, r1
 8021d8a:	1906      	adds	r6, r0, r4
 8021d8c:	4601      	mov	r1, r0
 8021d8e:	00ec      	lsls	r4, r5, #3
 8021d90:	1910      	adds	r0, r2, r4
 8021d92:	4421      	add	r1, r4
     k4  = k2 << 1;
 8021d94:	00ac      	lsls	r4, r5, #2
 8021d96:	9409      	str	r4, [sp, #36]	; 0x24
             gi     += k4;
 8021d98:	012c      	lsls	r4, r5, #4
             f1      = fi[0 ] - fi[k1];
 8021d9a:	ed93 6a00 	vldr	s12, [r3]
             f3      = fi[k2] - fi[k3];
 8021d9e:	edd6 6a00 	vldr	s13, [r6]
             f1      = fi[0 ] - fi[k1];
 8021da2:	ed9e 7a00 	vldr	s14, [lr]
             f3      = fi[k2] - fi[k3];
 8021da6:	edd1 7a00 	vldr	s15, [r1]
             f0      = fi[0 ] + fi[k1];
 8021daa:	ee76 5a07 	vadd.f32	s11, s12, s14
             f1      = fi[0 ] - fi[k1];
 8021dae:	ee36 7a47 	vsub.f32	s14, s12, s14
             f2      = fi[k2] + fi[k3];
 8021db2:	ee37 6aa6 	vadd.f32	s12, s15, s13
             f3      = fi[k2] - fi[k3];
 8021db6:	ee77 7ae6 	vsub.f32	s15, s15, s13
             fi[k2]  = f0         - f2;
 8021dba:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[k3]  = f1         - f3;
 8021dbe:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ]  = f0         + f2;
 8021dc2:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[k1]  = f1         + f3;
 8021dc6:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[k2]  = f0         - f2;
 8021dca:	ed81 5a00 	vstr	s10, [r1]
 8021dce:	4421      	add	r1, r4
             fi[0 ]  = f0         + f2;
 8021dd0:	ed83 6a00 	vstr	s12, [r3]
             fi     += k4;
 8021dd4:	4423      	add	r3, r4
             fi[k3]  = f1         - f3;
 8021dd6:	edc6 6a00 	vstr	s13, [r6]
 8021dda:	4426      	add	r6, r4
             fi[k1]  = f1         + f3;
 8021ddc:	edce 7a00 	vstr	s15, [lr]
            } while (fi<fn);
 8021de0:	4553      	cmp	r3, sl
             g2      = SQRT2  * gi[k2];
 8021de2:	ed90 5a00 	vldr	s10, [r0]
 8021de6:	44a6      	add	lr, r4
             g3      = SQRT2  * gi[k3];
 8021de8:	ed97 7a00 	vldr	s14, [r7]
             g2      = SQRT2  * gi[k2];
 8021dec:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
             g1      = gi[0 ] - gi[k1];
 8021df0:	ed92 6a00 	vldr	s12, [r2]
             g3      = SQRT2  * gi[k3];
 8021df4:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
             g1      = gi[0 ] - gi[k1];
 8021df8:	eddc 6a00 	vldr	s13, [ip]
             g2      = SQRT2  * gi[k2];
 8021dfc:	ee25 5b08 	vmul.f64	d5, d5, d8
             g3      = SQRT2  * gi[k3];
 8021e00:	ee27 7b08 	vmul.f64	d7, d7, d8
             g2      = SQRT2  * gi[k2];
 8021e04:	eeb7 5bc5 	vcvt.f32.f64	s10, d5
             g0      = gi[0 ] + gi[k1];
 8021e08:	ee76 5a26 	vadd.f32	s11, s12, s13
             g1      = gi[0 ] - gi[k1];
 8021e0c:	ee76 6a66 	vsub.f32	s13, s12, s13
             g3      = SQRT2  * gi[k3];
 8021e10:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
             gi[k2]  = g0         - g2;
 8021e14:	ee35 6ac5 	vsub.f32	s12, s11, s10
             gi[0 ]  = g0         + g2;
 8021e18:	ee35 5a85 	vadd.f32	s10, s11, s10
             gi[k3]  = g1         - g3;
 8021e1c:	ee76 7ac7 	vsub.f32	s15, s13, s14
             gi[k1]  = g1         + g3;
 8021e20:	ee36 7a87 	vadd.f32	s14, s13, s14
             gi[k2]  = g0         - g2;
 8021e24:	ed80 6a00 	vstr	s12, [r0]
             gi[0 ]  = g0         + g2;
 8021e28:	ed82 5a00 	vstr	s10, [r2]
 8021e2c:	4420      	add	r0, r4
             gi[k3]  = g1         - g3;
 8021e2e:	edc7 7a00 	vstr	s15, [r7]
             gi     += k4;
 8021e32:	4422      	add	r2, r4
             gi[k1]  = g1         + g3;
 8021e34:	ed8c 7a00 	vstr	s14, [ip]
 8021e38:	4427      	add	r7, r4
 8021e3a:	44a4      	add	ip, r4
            } while (fi<fn);
 8021e3c:	d3ad      	bcc.n	8021d9a <mayer_fht+0x1d6>
     TRIG_INIT(k,c1,s1);
 8021e3e:	9b01      	ldr	r3, [sp, #4]
 8021e40:	2b01      	cmp	r3, #1
 8021e42:	dd16      	ble.n	8021e72 <mayer_fht+0x2ae>
 8021e44:	9e07      	ldr	r6, [sp, #28]
 8021e46:	f240 1194 	movw	r1, #404	; 0x194
 8021e4a:	f240 20f8 	movw	r0, #760	; 0x2f8
 8021e4e:	4632      	mov	r2, r6
 8021e50:	f6c0 0103 	movt	r1, #2051	; 0x803
 8021e54:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8021e58:	f008 ff44 	bl	802ace4 <memcpy>
 8021e5c:	f240 2134 	movw	r1, #564	; 0x234
 8021e60:	f240 3048 	movw	r0, #840	; 0x348
 8021e64:	4632      	mov	r2, r6
 8021e66:	f6c0 0103 	movt	r1, #2051	; 0x803
 8021e6a:	f2c2 0000 	movt	r0, #8192	; 0x2000
 8021e6e:	f008 ff39 	bl	802ace4 <memcpy>
     for (ii=1;ii<kx;ii++)
 8021e72:	9b03      	ldr	r3, [sp, #12]
 8021e74:	2b01      	cmp	r3, #1
 8021e76:	f340 80ed 	ble.w	8022054 <mayer_fht+0x490>
 8021e7a:	f64f 78ff 	movw	r8, #65535	; 0xffff
 8021e7e:	f240 21f0 	movw	r1, #752	; 0x2f0
 8021e82:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8021e84:	f240 3b40 	movw	fp, #832	; 0x340
 8021e88:	f6c3 78ff 	movt	r8, #16383	; 0x3fff
 8021e8c:	f2c2 0100 	movt	r1, #8192	; 0x2000
 8021e90:	f102 0904 	add.w	r9, r2, #4
 8021e94:	f2c2 0b00 	movt	fp, #8192	; 0x2000
 8021e98:	44a8      	add	r8, r5
         TRIG_NEXT(k,c1,s1);
 8021e9a:	f04f 0e01 	mov.w	lr, #1
 8021e9e:	2300      	movs	r3, #0
 8021ea0:	4608      	mov	r0, r1
 8021ea2:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 8021ea6:	9102      	str	r1, [sp, #8]
 8021ea8:	9a01      	ldr	r2, [sp, #4]
 8021eaa:	1ad2      	subs	r2, r2, r3
 8021eac:	0091      	lsls	r1, r2, #2
 8021eae:	2a01      	cmp	r2, #1
 8021eb0:	eb0b 0501 	add.w	r5, fp, r1
 8021eb4:	4408      	add	r0, r1
 8021eb6:	ed95 2a00 	vldr	s4, [r5]
 8021eba:	edd0 2a00 	vldr	s5, [r0]
 8021ebe:	dd30      	ble.n	8021f22 <mayer_fht+0x35e>
 8021ec0:	3302      	adds	r3, #2
 8021ec2:	fa4e f003 	asr.w	r0, lr, r3
 8021ec6:	07c5      	lsls	r5, r0, #31
 8021ec8:	d504      	bpl.n	8021ed4 <mayer_fht+0x310>
 8021eca:	3301      	adds	r3, #1
 8021ecc:	fa4e f003 	asr.w	r0, lr, r3
 8021ed0:	07c0      	lsls	r0, r0, #31
 8021ed2:	d4fa      	bmi.n	8021eca <mayer_fht+0x306>
 8021ed4:	9801      	ldr	r0, [sp, #4]
 8021ed6:	3a01      	subs	r2, #1
 8021ed8:	9e02      	ldr	r6, [sp, #8]
 8021eda:	1ac3      	subs	r3, r0, r3
 8021edc:	9808      	ldr	r0, [sp, #32]
 8021ede:	0092      	lsls	r2, r2, #2
 8021ee0:	4408      	add	r0, r1
 8021ee2:	009b      	lsls	r3, r3, #2
 8021ee4:	eb0b 0502 	add.w	r5, fp, r2
 8021ee8:	4432      	add	r2, r6
 8021eea:	edd0 7a00 	vldr	s15, [r0]
 8021eee:	eb0b 0003 	add.w	r0, fp, r3
 8021ef2:	4433      	add	r3, r6
 8021ef4:	edd2 6a00 	vldr	s13, [r2]
 8021ef8:	ed90 6a00 	vldr	s12, [r0]
 8021efc:	eb0b 0001 	add.w	r0, fp, r1
 8021f00:	edd5 5a00 	vldr	s11, [r5]
 8021f04:	4431      	add	r1, r6
 8021f06:	ed93 7a00 	vldr	s14, [r3]
 8021f0a:	ee35 6a86 	vadd.f32	s12, s11, s12
 8021f0e:	ee36 7a87 	vadd.f32	s14, s13, s14
 8021f12:	ee66 6a27 	vmul.f32	s13, s12, s15
 8021f16:	ee67 7a27 	vmul.f32	s15, s14, s15
 8021f1a:	edc0 6a00 	vstr	s13, [r0]
 8021f1e:	edc1 7a00 	vstr	s15, [r1]
 8021f22:	9a04      	ldr	r2, [sp, #16]
         c2 = c1*c1 - s1*s1;
 8021f24:	ee22 3a42 	vnmul.f32	s6, s4, s4
         s2 = 2*(c1*s1);
 8021f28:	ee62 3a22 	vmul.f32	s7, s4, s5
             fn = fz + n;
             fi = fz +ii;
 8021f2c:	464b      	mov	r3, r9
 8021f2e:	eb02 0709 	add.w	r7, r2, r9
 8021f32:	eb02 0608 	add.w	r6, r2, r8
 8021f36:	9a06      	ldr	r2, [sp, #24]
         c2 = c1*c1 - s1*s1;
 8021f38:	eea2 3aa2 	vfma.f32	s6, s5, s5
         s2 = 2*(c1*s1);
 8021f3c:	ee73 3aa3 	vadd.f32	s7, s7, s7
             gi = fz +k1-ii;
 8021f40:	46c4      	mov	ip, r8
 8021f42:	eb02 0509 	add.w	r5, r2, r9
 8021f46:	eb02 0008 	add.w	r0, r2, r8
 8021f4a:	9a05      	ldr	r2, [sp, #20]
 8021f4c:	4611      	mov	r1, r2
 8021f4e:	4442      	add	r2, r8
 8021f50:	4449      	add	r1, r9
                 a       = c2*fi[k1] + s2*gi[k1];
                 f1      = fi[0 ]    - a;
                 f0      = fi[0 ]    + a;
                 g1      = gi[0 ]    - b;
                 g0      = gi[0 ]    + b;
                 b       = s2*fi[k3] - c2*gi[k3];
 8021f52:	edd0 4a00 	vldr	s9, [r0]
 8021f56:	edd5 7a00 	vldr	s15, [r5]
 8021f5a:	ee63 1a64 	vnmul.f32	s3, s6, s9
                 a       = c2*fi[k3] + s2*gi[k3];
                 f3      = fi[k2]    - a;
                 f2      = fi[k2]    + a;
                 g3      = gi[k2]    - b;
 8021f5e:	ed92 1a00 	vldr	s2, [r2]
                 a       = c2*fi[k3] + s2*gi[k3];
 8021f62:	ee64 4aa3 	vmul.f32	s9, s9, s7
                 b       = s2*fi[k1] - c2*gi[k1];
 8021f66:	edd6 5a00 	vldr	s11, [r6]
                 f3      = fi[k2]    - a;
 8021f6a:	ed91 6a00 	vldr	s12, [r1]
                 b       = s2*fi[k3] - c2*gi[k3];
 8021f6e:	eee7 1aa3 	vfma.f32	s3, s15, s7
                 b       = s2*fi[k1] - c2*gi[k1];
 8021f72:	ed97 0a00 	vldr	s0, [r7]
                 a       = c2*fi[k3] + s2*gi[k3];
 8021f76:	eee7 4a83 	vfma.f32	s9, s15, s6
                 f1      = fi[0 ]    - a;
 8021f7a:	edd3 6a00 	vldr	s13, [r3]
                 a       = c2*fi[k1] + s2*gi[k1];
 8021f7e:	ee25 7aa3 	vmul.f32	s14, s11, s7
                 g1      = gi[0 ]    - b;
 8021f82:	ed9c 5a00 	vldr	s10, [ip]
                 b       = s2*fi[k1] - c2*gi[k1];
 8021f86:	ee63 5a65 	vnmul.f32	s11, s6, s11
                 a       = c2*fi[k1] + s2*gi[k1];
 8021f8a:	eea0 7a03 	vfma.f32	s14, s0, s6
                 g3      = gi[k2]    - b;
 8021f8e:	ee31 4a61 	vsub.f32	s8, s2, s3
                 f3      = fi[k2]    - a;
 8021f92:	ee76 7a64 	vsub.f32	s15, s12, s9
                 g2      = gi[k2]    + b;
 8021f96:	ee71 1a21 	vadd.f32	s3, s2, s3
                 b       = s1*f2     - c1*g3;
                 a       = c1*f2     + s1*g3;
 8021f9a:	ee62 0a04 	vmul.f32	s1, s4, s8
                 f2      = fi[k2]    + a;
 8021f9e:	ee76 4a24 	vadd.f32	s9, s12, s9
                 b       = s1*f2     - c1*g3;
 8021fa2:	ee24 4a62 	vnmul.f32	s8, s8, s5
                 a       = c1*f2     + s1*g3;
 8021fa6:	eeb0 1a60 	vmov.f32	s2, s1
                 b       = s2*fi[k1] - c2*gi[k1];
 8021faa:	eee0 5a23 	vfma.f32	s11, s0, s7
                 fi[k2]  = f0        - a;
                 fi[0 ]  = f0        + a;
                 gi[k3]  = g1        - b;
                 gi[k1]  = g1        + b;
                 b       = c1*g2     - s1*f3;
                 a       = s1*g2     + c1*f3;
 8021fae:	ee22 6aa7 	vmul.f32	s12, s5, s15
                 a       = c1*f2     + s1*g3;
 8021fb2:	eea2 1aa4 	vfma.f32	s2, s5, s9
                 b       = s1*f2     - c1*g3;
 8021fb6:	eea2 4a24 	vfma.f32	s8, s4, s9
                 b       = c1*g2     - s1*f3;
 8021fba:	ee67 7ac2 	vnmul.f32	s15, s15, s4
                 a       = s1*g2     + c1*f3;
 8021fbe:	eea2 6a21 	vfma.f32	s12, s4, s3
                 b       = c1*g2     - s1*f3;
 8021fc2:	eee2 7aa1 	vfma.f32	s15, s5, s3
                 f0      = fi[0 ]    + a;
 8021fc6:	ee76 1a87 	vadd.f32	s3, s13, s14
                 b       = s1*f2     - c1*g3;
 8021fca:	eef0 4a44 	vmov.f32	s9, s8
                 f1      = fi[0 ]    - a;
 8021fce:	ee36 7ac7 	vsub.f32	s14, s13, s14
                 g1      = gi[0 ]    - b;
 8021fd2:	ee35 4a65 	vsub.f32	s8, s10, s11
                 g0      = gi[0 ]    + b;
 8021fd6:	ee75 6a25 	vadd.f32	s13, s10, s11
                 fi[k2]  = f0        - a;
 8021fda:	ee71 5ac1 	vsub.f32	s11, s3, s2
                 fi[0 ]  = f0        + a;
 8021fde:	ee31 1a81 	vadd.f32	s2, s3, s2
                 gi[k3]  = g1        - b;
 8021fe2:	ee34 5a64 	vsub.f32	s10, s8, s9
                 fi[k2]  = f0        - a;
 8021fe6:	edc1 5a00 	vstr	s11, [r1]
                 gi[k1]  = g1        + b;
 8021fea:	ee74 4a24 	vadd.f32	s9, s8, s9
                 fi[0 ]  = f0        + a;
 8021fee:	ed83 1a00 	vstr	s2, [r3]
                 gi[k2]  = g0        - a;
                 gi[0 ]  = g0        + a;
                 fi[k3]  = f1        - b;
                 fi[k1]  = f1        + b;
                 gi     += k4;
                 fi     += k4;
 8021ff2:	4423      	add	r3, r4
                 gi[k2]  = g0        - a;
 8021ff4:	ee76 5ac6 	vsub.f32	s11, s13, s12
                 gi[k3]  = g1        - b;
 8021ff8:	ed80 5a00 	vstr	s10, [r0]
                 gi[0 ]  = g0        + a;
 8021ffc:	ee36 6a86 	vadd.f32	s12, s13, s12
                } while (fi<fn);
 8022000:	4553      	cmp	r3, sl
                 fi[k3]  = f1        - b;
 8022002:	ee77 6a67 	vsub.f32	s13, s14, s15
                 gi[k1]  = g1        + b;
 8022006:	edc6 4a00 	vstr	s9, [r6]
                 fi[k1]  = f1        + b;
 802200a:	ee77 7a27 	vadd.f32	s15, s14, s15
                 gi[k2]  = g0        - a;
 802200e:	edc2 5a00 	vstr	s11, [r2]
 8022012:	4421      	add	r1, r4
                 gi[0 ]  = g0        + a;
 8022014:	ed8c 6a00 	vstr	s12, [ip]
 8022018:	4420      	add	r0, r4
                 fi[k3]  = f1        - b;
 802201a:	edc5 6a00 	vstr	s13, [r5]
 802201e:	4426      	add	r6, r4
                 fi[k1]  = f1        + b;
 8022020:	edc7 7a00 	vstr	s15, [r7]
 8022024:	4422      	add	r2, r4
                 gi     += k4;
 8022026:	44a4      	add	ip, r4
 8022028:	4425      	add	r5, r4
 802202a:	4427      	add	r7, r4
                } while (fi<fn);
 802202c:	d391      	bcc.n	8021f52 <mayer_fht+0x38e>
     for (ii=1;ii<kx;ii++)
 802202e:	f10e 0e01 	add.w	lr, lr, #1
 8022032:	9b03      	ldr	r3, [sp, #12]
 8022034:	4573      	cmp	r3, lr
 8022036:	d00d      	beq.n	8022054 <mayer_fht+0x490>
         TRIG_NEXT(k,c1,s1);
 8022038:	f01e 0301 	ands.w	r3, lr, #1
 802203c:	d14d      	bne.n	80220da <mayer_fht+0x516>
 802203e:	3301      	adds	r3, #1
 8022040:	fa4e f203 	asr.w	r2, lr, r3
 8022044:	07d6      	lsls	r6, r2, #31
 8022046:	d5fa      	bpl.n	802203e <mayer_fht+0x47a>
 8022048:	f109 0904 	add.w	r9, r9, #4
 802204c:	f1a8 0804 	sub.w	r8, r8, #4
 8022050:	9802      	ldr	r0, [sp, #8]
 8022052:	e729      	b.n	8021ea8 <mayer_fht+0x2e4>
 8022054:	9b07      	ldr	r3, [sp, #28]
        }
     TRIG_RESET(k,c1,s1);
    } while (k4<n);
 8022056:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8022058:	3308      	adds	r3, #8
 802205a:	9307      	str	r3, [sp, #28]
 802205c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 802205e:	4293      	cmp	r3, r2
 8022060:	f73f ae78 	bgt.w	8021d54 <mayer_fht+0x190>
}
 8022064:	b00d      	add	sp, #52	; 0x34
 8022066:	ecbd 8b02 	vpop	{d8}
 802206a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     for (k=n>>1; (!((k2^=k)&k)); k>>=1);
 802206e:	46a4      	mov	ip, r4
 8022070:	e5c8      	b.n	8021c04 <mayer_fht+0x40>
 8022072:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
 8022076:	4582      	cmp	sl, r0
 8022078:	d92c      	bls.n	80220d4 <mayer_fht+0x510>
 802207a:	f100 0110 	add.w	r1, r0, #16
 802207e:	f100 0520 	add.w	r5, r0, #32
 8022082:	f1c1 040f 	rsb	r4, r1, #15
 8022086:	4454      	add	r4, sl
 8022088:	f024 040f 	bic.w	r4, r4, #15
 802208c:	442c      	add	r4, r5
             f1     = fi[0 ]-fi[1 ];
 802208e:	ed11 6a03 	vldr	s12, [r1, #-12]
 8022092:	3110      	adds	r1, #16
             f3     = fi[2 ]-fi[3 ];
 8022094:	ed51 6a06 	vldr	s13, [r1, #-24]	; 0xffffffe8
             f1     = fi[0 ]-fi[1 ];
 8022098:	ed51 5a08 	vldr	s11, [r1, #-32]	; 0xffffffe0
             f3     = fi[2 ]-fi[3 ];
 802209c:	ed51 7a05 	vldr	s15, [r1, #-20]	; 0xffffffec
             f1     = fi[0 ]-fi[1 ];
 80220a0:	ee35 7ac6 	vsub.f32	s14, s11, s12
             f0     = fi[0 ]+fi[1 ];
 80220a4:	ee75 5a86 	vadd.f32	s11, s11, s12
             f2     = fi[2 ]+fi[3 ];
 80220a8:	ee36 6aa7 	vadd.f32	s12, s13, s15
             f3     = fi[2 ]-fi[3 ];
 80220ac:	ee76 7ae7 	vsub.f32	s15, s13, s15
             fi[2 ] = (f0-f2);  
 80220b0:	ee35 5ac6 	vsub.f32	s10, s11, s12
             fi[3 ] = (f1-f3);  
 80220b4:	ee77 6a67 	vsub.f32	s13, s14, s15
             fi[0 ] = (f0+f2);
 80220b8:	ee35 6a86 	vadd.f32	s12, s11, s12
             fi[1 ] = (f1+f3);
 80220bc:	ee77 7a27 	vadd.f32	s15, s14, s15
             fi[2 ] = (f0-f2);  
 80220c0:	ed01 5a06 	vstr	s10, [r1, #-24]	; 0xffffffe8
             fi[3 ] = (f1-f3);  
 80220c4:	ed41 6a05 	vstr	s13, [r1, #-20]	; 0xffffffec
             fi[0 ] = (f0+f2);
 80220c8:	ed01 6a08 	vstr	s12, [r1, #-32]	; 0xffffffe0
             fi[1 ] = (f1+f3);
 80220cc:	ed41 7a07 	vstr	s15, [r1, #-28]	; 0xffffffe4
         for (fi=fz,fn=fz+n;fi<fn;fi+=4)
 80220d0:	428c      	cmp	r4, r1
 80220d2:	d1dc      	bne.n	802208e <mayer_fht+0x4ca>
 80220d4:	2100      	movs	r1, #0
 80220d6:	9101      	str	r1, [sp, #4]
 80220d8:	e623      	b.n	8021d22 <mayer_fht+0x15e>
         TRIG_NEXT(k,c1,s1);
 80220da:	2300      	movs	r3, #0
 80220dc:	e7b4      	b.n	8022048 <mayer_fht+0x484>
 80220de:	bf00      	nop

080220e0 <mayer_realfft>:
  real[i] = (q-t)*0.5;  real[j] = (q+t)*0.5;
 }
}

void mayer_realfft(int n, REAL *real)
{
 80220e0:	b538      	push	{r3, r4, r5, lr}
 80220e2:	460c      	mov	r4, r1
 80220e4:	4605      	mov	r5, r0
    REAL a,b;
 int i,j,k;
 mayer_fht(real,n);
 80220e6:	4601      	mov	r1, r0
 80220e8:	4620      	mov	r0, r4
 80220ea:	f7ff fd6b 	bl	8021bc4 <mayer_fht>
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 80220ee:	1e2a      	subs	r2, r5, #0
 80220f0:	f105 33ff 	add.w	r3, r5, #4294967295	; 0xffffffff
 80220f4:	bfb8      	it	lt
 80220f6:	3201      	addlt	r2, #1
 80220f8:	1052      	asrs	r2, r2, #1
 80220fa:	2a01      	cmp	r2, #1
 80220fc:	dd19      	ble.n	8022132 <mayer_realfft+0x52>
 80220fe:	eb04 0383 	add.w	r3, r4, r3, lsl #2
  a = real[i];
  b = real[j];
  real[j] = (a-b)*0.5;
 8022102:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8022106:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 802210a:	1d21      	adds	r1, r4, #4
 802210c:	3304      	adds	r3, #4
  a = real[i];
 802210e:	edd1 7a00 	vldr	s15, [r1]
  b = real[j];
 8022112:	ed73 6a01 	vldmdb	r3!, {s13}
  real[j] = (a-b)*0.5;
 8022116:	ee37 7ae6 	vsub.f32	s14, s15, s13
  real[i] = (a+b)*0.5;
 802211a:	ee77 7aa6 	vadd.f32	s15, s15, s13
  real[j] = (a-b)*0.5;
 802211e:	ee27 7a06 	vmul.f32	s14, s14, s12
  real[i] = (a+b)*0.5;
 8022122:	ee67 7a86 	vmul.f32	s15, s15, s12
  real[j] = (a-b)*0.5;
 8022126:	ed83 7a00 	vstr	s14, [r3]
  real[i] = (a+b)*0.5;
 802212a:	ece1 7a01 	vstmia	r1!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 802212e:	428a      	cmp	r2, r1
 8022130:	d1ed      	bne.n	802210e <mayer_realfft+0x2e>
 }
}
 8022132:	bd38      	pop	{r3, r4, r5, pc}

08022134 <mayer_realifft>:

void mayer_realifft(int n, REAL *real)
{
    REAL a,b;
 int i,j,k;
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 8022134:	2800      	cmp	r0, #0
 8022136:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
{
 802213a:	b410      	push	{r4}
 802213c:	460c      	mov	r4, r1
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 802213e:	bfb4      	ite	lt
 8022140:	1c41      	addlt	r1, r0, #1
 8022142:	4601      	movge	r1, r0
 8022144:	1049      	asrs	r1, r1, #1
 8022146:	2901      	cmp	r1, #1
 8022148:	dd13      	ble.n	8022172 <mayer_realifft+0x3e>
 802214a:	eb04 0282 	add.w	r2, r4, r2, lsl #2
 802214e:	1d23      	adds	r3, r4, #4
 8022150:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8022154:	3204      	adds	r2, #4
  a = real[i];
 8022156:	edd3 7a00 	vldr	s15, [r3]
  b = real[j];
 802215a:	ed32 7a01 	vldmdb	r2!, {s14}
  real[j] = (a-b);
 802215e:	ee77 6ac7 	vsub.f32	s13, s15, s14
  real[i] = (a+b);
 8022162:	ee77 7a87 	vadd.f32	s15, s15, s14
  real[j] = (a-b);
 8022166:	edc2 6a00 	vstr	s13, [r2]
  real[i] = (a+b);
 802216a:	ece3 7a01 	vstmia	r3!, {s15}
 for (i=1,j=n-1,k=n/2;i<k;i++,j--) {
 802216e:	4299      	cmp	r1, r3
 8022170:	d1f1      	bne.n	8022156 <mayer_realifft+0x22>
 }
 mayer_fht(real,n);
 8022172:	4601      	mov	r1, r0
 8022174:	4620      	mov	r0, r4
}
 8022176:	f85d 4b04 	ldr.w	r4, [sp], #4
 mayer_fht(real,n);
 802217a:	f7ff bd23 	b.w	8021bc4 <mayer_fht>
 802217e:	bf00      	nop

08022180 <tEnvelopeFollower_init>:
//===========================================================================
/* Envelope Follower */
//===========================================================================

void    tEnvelopeFollower_init(tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff)
{
 8022180:	b538      	push	{r3, r4, r5, lr}
    tEnvelopeFollower_initToPool(ef, attackThreshold, decayCoeff, &leaf.mempool);
}

void    tEnvelopeFollower_initToPool    (tEnvelopeFollower* const ef, float attackThreshold, float decayCoeff, tMempool* const mp)
{
    _tMempool* m = *mp;
 8022182:	f249 43a0 	movw	r3, #38048	; 0x94a0
{
 8022186:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 8022188:	2010      	movs	r0, #16
    _tMempool* m = *mp;
 802218a:	f2c2 0301 	movt	r3, #8193	; 0x2001
{
 802218e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022192:	699c      	ldr	r4, [r3, #24]
{
 8022194:	eef0 8a40 	vmov.f32	s17, s0
 8022198:	eeb0 8a60 	vmov.f32	s16, s1
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 802219c:	4621      	mov	r1, r4
 802219e:	f005 fe25 	bl	8027dec <mpool_alloc>
    e->mempool = m;
    
    e->y = 0.0f;
 80221a2:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 80221a4:	6028      	str	r0, [r5, #0]
    e->mempool = m;
 80221a6:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
 80221a8:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
 80221ac:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
 80221b0:	6043      	str	r3, [r0, #4]
}
 80221b2:	ecbd 8b02 	vpop	{d8}
 80221b6:	bd38      	pop	{r3, r4, r5, pc}

080221b8 <tEnvelopeFollower_initToPool>:
{
 80221b8:	b538      	push	{r3, r4, r5, lr}
 80221ba:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80221be:	680c      	ldr	r4, [r1, #0]
{
 80221c0:	eef0 8a40 	vmov.f32	s17, s0
 80221c4:	eeb0 8a60 	vmov.f32	s16, s1
 80221c8:	4605      	mov	r5, r0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 80221ca:	4621      	mov	r1, r4
 80221cc:	2010      	movs	r0, #16
 80221ce:	f005 fe0d 	bl	8027dec <mpool_alloc>
    e->y = 0.0f;
 80221d2:	2300      	movs	r3, #0
    _tEnvelopeFollower* e = *ef = (_tEnvelopeFollower*) mpool_alloc(sizeof(_tEnvelopeFollower), m);
 80221d4:	6028      	str	r0, [r5, #0]
    e->mempool = m;
 80221d6:	6004      	str	r4, [r0, #0]
    e->a_thresh = attackThreshold;
 80221d8:	edc0 8a02 	vstr	s17, [r0, #8]
    e->d_coeff = decayCoeff;
 80221dc:	ed80 8a03 	vstr	s16, [r0, #12]
    e->y = 0.0f;
 80221e0:	6043      	str	r3, [r0, #4]
}
 80221e2:	ecbd 8b02 	vpop	{d8}
 80221e6:	bd38      	pop	{r3, r4, r5, pc}

080221e8 <tEnvelopeFollower_free>:

void    tEnvelopeFollower_free  (tEnvelopeFollower* const ef)
{
    _tEnvelopeFollower* e = *ef;
 80221e8:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)e, e->mempool);
 80221ea:	6801      	ldr	r1, [r0, #0]
 80221ec:	f005 bea8 	b.w	8027f40 <mpool_free>

080221f0 <tEnvelopeFollower_tick>:
}

float   tEnvelopeFollower_tick(tEnvelopeFollower* const ef, float x)
{
    _tEnvelopeFollower* e = *ef;
 80221f0:	6802      	ldr	r2, [r0, #0]
 80221f2:	eeb0 0ac0 	vabs.f32	s0, s0
    
    if (x < 0.0f ) x = -x;  /* Absolute value. */
    
    if ((x >= e->y) && (x > e->a_thresh)) e->y = x;                      /* If we hit a peak, ride the peak to the top. */
 80221f6:	edd2 7a01 	vldr	s15, [r2, #4]
 80221fa:	eef4 7ac0 	vcmpe.f32	s15, s0
 80221fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022202:	d816      	bhi.n	8022232 <tEnvelopeFollower_tick+0x42>
 8022204:	ed92 7a02 	vldr	s14, [r2, #8]
 8022208:	eeb4 7ac0 	vcmpe.f32	s14, s0
 802220c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022210:	d50f      	bpl.n	8022232 <tEnvelopeFollower_tick+0x42>
    //ef->y = envelope_pow[(uint16_t)(ef->y * (float)UINT16_MAX)] * ef->d_coeff; //not quite the right behavior - too much loss of precision?
    //ef->y = powf(ef->y, 1.000009f) * ef->d_coeff;  // too expensive
    
#ifdef NO_DENORMAL_CHECK
#else
    if( e->y < VSF)   e->y = 0.0f;
 8022212:	f24e 33ee 	movw	r3, #58350	; 0xe3ee
 8022216:	f2c0 036c 	movt	r3, #108	; 0x6c
 802221a:	ee07 3a90 	vmov	s15, r3
 802221e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8022222:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022226:	d509      	bpl.n	802223c <tEnvelopeFollower_tick+0x4c>
 8022228:	2300      	movs	r3, #0
 802222a:	ee00 3a10 	vmov	s0, r3
 802222e:	6053      	str	r3, [r2, #4]
#endif
    return e->y;
}
 8022230:	4770      	bx	lr
    else                                    e->y = e->y * e->d_coeff;    /* Else, exponential decay of output. */
 8022232:	ed92 0a03 	vldr	s0, [r2, #12]
 8022236:	ee27 0a80 	vmul.f32	s0, s15, s0
 802223a:	e7ea      	b.n	8022212 <tEnvelopeFollower_tick+0x22>
 802223c:	ed82 0a01 	vstr	s0, [r2, #4]
 8022240:	4770      	bx	lr
 8022242:	bf00      	nop

08022244 <tZeroCrossing_initToPool>:
{
    tZeroCrossing_initToPool   (zc, maxWindowSize, &leaf.mempool);
}

void    tZeroCrossing_initToPool   (tZeroCrossing* const zc, int maxWindowSize, tMempool* const mp)
{
 8022244:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
 8022246:	6816      	ldr	r6, [r2, #0]
{
 8022248:	460d      	mov	r5, r1
 802224a:	4607      	mov	r7, r0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 802224c:	2024      	movs	r0, #36	; 0x24
 802224e:	4631      	mov	r1, r6
 8022250:	f005 fdcc 	bl	8027dec <mpool_alloc>
    z->mempool = m;

    z->count = 0;
    z->maxWindowSize = maxWindowSize;
    z->currentWindowSize = maxWindowSize;
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
 8022254:	ee07 5a90 	vmov	s15, r5
 8022258:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 802225c:	4604      	mov	r4, r0
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
 802225e:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
    z->count = 0;
 8022262:	2300      	movs	r3, #0
    _tZeroCrossing* z = *zc = (_tZeroCrossing*) mpool_alloc(sizeof(_tZeroCrossing), m);
 8022264:	6038      	str	r0, [r7, #0]
    z->position = 0;
    z->prevPosition = maxWindowSize;
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 8022266:	4631      	mov	r1, r6
    z->mempool = m;
 8022268:	6006      	str	r6, [r0, #0]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
 802226a:	eec6 7a87 	vdiv.f32	s15, s13, s14
    z->maxWindowSize = maxWindowSize;
 802226e:	6085      	str	r5, [r0, #8]
    z->count = 0;
 8022270:	6063      	str	r3, [r4, #4]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 8022272:	00a8      	lsls	r0, r5, #2
    z->position = 0;
 8022274:	6223      	str	r3, [r4, #32]
    z->currentWindowSize = maxWindowSize;
 8022276:	60e5      	str	r5, [r4, #12]
    z->prevPosition = maxWindowSize;
 8022278:	61e5      	str	r5, [r4, #28]
    z->invCurrentWindowSize = 1.0f / maxWindowSize;
 802227a:	edc4 7a04 	vstr	s15, [r4, #16]
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 802227e:	f005 fe0b 	bl	8027e98 <mpool_calloc>
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
 8022282:	4631      	mov	r1, r6
    z->inBuffer = (float*) mpool_calloc(sizeof(float) * maxWindowSize, m);
 8022284:	6160      	str	r0, [r4, #20]
    z->countBuffer = (uint16_t*) mpool_calloc(sizeof(uint16_t) * maxWindowSize, m);
 8022286:	0068      	lsls	r0, r5, #1
 8022288:	f005 fe06 	bl	8027e98 <mpool_calloc>
 802228c:	61a0      	str	r0, [r4, #24]
}
 802228e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08022290 <tZeroCrossing_free>:

void    tZeroCrossing_free (tZeroCrossing* const zc)
{
 8022290:	b510      	push	{r4, lr}
    _tZeroCrossing* z = *zc;
 8022292:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)z->inBuffer, z->mempool);
 8022294:	6821      	ldr	r1, [r4, #0]
 8022296:	6960      	ldr	r0, [r4, #20]
 8022298:	f005 fe52 	bl	8027f40 <mpool_free>
    mpool_free((char*)z->countBuffer, z->mempool);
 802229c:	6821      	ldr	r1, [r4, #0]
 802229e:	69a0      	ldr	r0, [r4, #24]
 80222a0:	f005 fe4e 	bl	8027f40 <mpool_free>
    mpool_free((char*)z, z->mempool);
 80222a4:	6821      	ldr	r1, [r4, #0]
 80222a6:	4620      	mov	r0, r4
}
 80222a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)z, z->mempool);
 80222ac:	f005 be48 	b.w	8027f40 <mpool_free>

080222b0 <tZeroCrossing_tick>:

//returns proportion of zero crossings within window size (0.0 would be none in window, 1.0 would be all zero crossings)
float   tZeroCrossing_tick         (tZeroCrossing* const zc, float input)
{
 80222b0:	b430      	push	{r4, r5}
    _tZeroCrossing* z = *zc;
 80222b2:	6803      	ldr	r3, [r0, #0]

    z->inBuffer[z->position] = input;
 80222b4:	6a19      	ldr	r1, [r3, #32]
 80222b6:	695a      	ldr	r2, [r3, #20]
 80222b8:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 80222bc:	ed82 0a00 	vstr	s0, [r2]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 80222c0:	6a18      	ldr	r0, [r3, #32]
    float output = 0.0f;

    //add new value to count
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 80222c2:	695a      	ldr	r2, [r3, #20]
 80222c4:	69dc      	ldr	r4, [r3, #28]
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 80222c6:	1c41      	adds	r1, r0, #1
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 80222c8:	eb02 0580 	add.w	r5, r2, r0, lsl #2
 80222cc:	eb02 0284 	add.w	r2, r2, r4, lsl #2
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 80222d0:	68dc      	ldr	r4, [r3, #12]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 80222d2:	ed95 7a00 	vldr	s14, [r5]
 80222d6:	edd2 7a00 	vldr	s15, [r2]
 80222da:	ee67 7a87 	vmul.f32	s15, s15, s14
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 80222de:	fb91 f2f4 	sdiv	r2, r1, r4
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 80222e2:	eef5 7ac0 	vcmpe.f32	s15, #0.0
    int futurePosition = ((z->position + 1) % z->currentWindowSize);
 80222e6:	fb04 1112 	mls	r1, r4, r2, r1
    {
        //zero crossing happened, add it to the count array
        z->countBuffer[z->position] = 1;
 80222ea:	699a      	ldr	r2, [r3, #24]
    if ((z->inBuffer[z->position] * z->inBuffer[z->prevPosition]) < 0.0f)
 80222ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80222f0:	d41c      	bmi.n	802232c <tZeroCrossing_tick+0x7c>
        z->count++;
    }
    else
    {
        z->countBuffer[z->position] = 0;
 80222f2:	2400      	movs	r4, #0
 80222f4:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
 80222f8:	685a      	ldr	r2, [r3, #4]
    }

    //remove oldest value from count
    if (z->countBuffer[futurePosition] > 0)
 80222fa:	6998      	ldr	r0, [r3, #24]
 80222fc:	f830 0011 	ldrh.w	r0, [r0, r1, lsl #1]
 8022300:	b110      	cbz	r0, 8022308 <tZeroCrossing_tick+0x58>
    {
        z->count--;
        if (z->count < 0)
 8022302:	3a01      	subs	r2, #1
 8022304:	d40d      	bmi.n	8022322 <tZeroCrossing_tick+0x72>
        z->count--;
 8022306:	605a      	str	r2, [r3, #4]
 8022308:	ee07 2a90 	vmov	s15, r2
 802230c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
        {
            z->count = 0;
        }
    }

    z->prevPosition = z->position;
 8022310:	6a1a      	ldr	r2, [r3, #32]
    z->position = futurePosition;

    output = z->count * z->invCurrentWindowSize;
 8022312:	ed93 0a04 	vldr	s0, [r3, #16]
    z->position = futurePosition;
 8022316:	e9c3 2107 	strd	r2, r1, [r3, #28]

    return output;
}
 802231a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802231e:	bc30      	pop	{r4, r5}
 8022320:	4770      	bx	lr
            z->count = 0;
 8022322:	2200      	movs	r2, #0
 8022324:	ee07 2a90 	vmov	s15, r2
 8022328:	605a      	str	r2, [r3, #4]
 802232a:	e7f1      	b.n	8022310 <tZeroCrossing_tick+0x60>
        z->countBuffer[z->position] = 1;
 802232c:	2401      	movs	r4, #1
 802232e:	f822 4010 	strh.w	r4, [r2, r0, lsl #1]
        z->count++;
 8022332:	685a      	ldr	r2, [r3, #4]
 8022334:	4422      	add	r2, r4
 8022336:	605a      	str	r2, [r3, #4]
 8022338:	e7df      	b.n	80222fa <tZeroCrossing_tick+0x4a>
 802233a:	bf00      	nop

0802233c <tPowerFollower_initToPool>:
{
    tPowerFollower_initToPool(pf, factor, &leaf.mempool);
}

void    tPowerFollower_initToPool   (tPowerFollower* const pf, float factor, tMempool* const mp)
{
 802233c:	b538      	push	{r3, r4, r5, lr}
 802233e:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022342:	680c      	ldr	r4, [r1, #0]
{
 8022344:	4605      	mov	r5, r0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 8022346:	2010      	movs	r0, #16
{
 8022348:	eeb0 8a40 	vmov.f32	s16, s0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 802234c:	4621      	mov	r1, r4
 802234e:	f005 fd4d 	bl	8027dec <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
    p->factor=factor;
    p->oneminusfactor=1.0f-factor;
 8022352:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    p->curr=0.0f;
 8022356:	2300      	movs	r3, #0
    _tPowerFollower* p = *pf = (_tPowerFollower*) mpool_alloc(sizeof(_tPowerFollower), m);
 8022358:	6028      	str	r0, [r5, #0]
    p->mempool = m;
 802235a:	6004      	str	r4, [r0, #0]
    p->oneminusfactor=1.0f-factor;
 802235c:	ee77 7ac8 	vsub.f32	s15, s15, s16
    p->factor=factor;
 8022360:	ed80 8a01 	vstr	s16, [r0, #4]
    p->curr=0.0f;
 8022364:	60c3      	str	r3, [r0, #12]
    p->oneminusfactor=1.0f-factor;
 8022366:	edc0 7a02 	vstr	s15, [r0, #8]
}
 802236a:	ecbd 8b02 	vpop	{d8}
 802236e:	bd38      	pop	{r3, r4, r5, pc}

08022370 <tPowerFollower_free>:

void    tPowerFollower_free (tPowerFollower* const pf)
{
    _tPowerFollower* p = *pf;
 8022370:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)p, p->mempool);
 8022372:	6801      	ldr	r1, [r0, #0]
 8022374:	f005 bde4 	b.w	8027f40 <mpool_free>

08022378 <tPowerFollower_tick>:
    return 0;
}

float   tPowerFollower_tick(tPowerFollower* const pf, float input)
{
    _tPowerFollower* p = *pf;
 8022378:	6803      	ldr	r3, [r0, #0]
    p->curr = p->factor*input*input+p->oneminusfactor*p->curr;
 802237a:	ee20 7a00 	vmul.f32	s14, s0, s0
 802237e:	edd3 7a02 	vldr	s15, [r3, #8]
 8022382:	ed93 0a03 	vldr	s0, [r3, #12]
 8022386:	edd3 6a01 	vldr	s13, [r3, #4]
 802238a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802238e:	eea6 0a87 	vfma.f32	s0, s13, s14
 8022392:	ed83 0a03 	vstr	s0, [r3, #12]
    return p->curr;
}
 8022396:	4770      	bx	lr

08022398 <tEnvPD_initToPool>:
{
    tEnvPD_initToPool(xpd, ws, hs, bs, &leaf.mempool);
}

void    tEnvPD_initToPool       (tEnvPD* const xpd, int ws, int hs, int bs, tMempool* const mp)
{
 8022398:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802239c:	ed2d 8b04 	vpush	{d8-d9}
 80223a0:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 80223a2:	4688      	mov	r8, r1
 80223a4:	4605      	mov	r5, r0
    _tMempool* m = *mp;
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 80223a6:	f241 109c 	movw	r0, #4508	; 0x119c
    _tMempool* m = *mp;
 80223aa:	6824      	ldr	r4, [r4, #0]
{
 80223ac:	4617      	mov	r7, r2
 80223ae:	4699      	mov	r9, r3
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 80223b0:	4621      	mov	r1, r4
 80223b2:	f005 fd71 	bl	8027e98 <mpool_calloc>
    
    int period = hs, npoints = ws;
    
    int i;
    
    if (npoints < 1) npoints = 1024;
 80223b6:	f1b8 0f00 	cmp.w	r8, #0
    _tEnvPD* x = *xpd = (_tEnvPD*) mpool_calloc(sizeof(_tEnvPD), m);
 80223ba:	6028      	str	r0, [r5, #0]
 80223bc:	4606      	mov	r6, r0
    x->mempool = m;
 80223be:	6004      	str	r4, [r0, #0]
    if (npoints < 1) npoints = 1024;
 80223c0:	dd7a      	ble.n	80224b8 <tEnvPD_initToPool+0x120>
 80223c2:	ee07 8a90 	vmov	s15, r8
 80223c6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80223ca:	ea4f 1268 	mov.w	r2, r8, asr #5
 80223ce:	f108 0a40 	add.w	sl, r8, #64	; 0x40
 80223d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80223d6:	fa1f f488 	uxth.w	r4, r8
 80223da:	3201      	adds	r2, #1
 80223dc:	ee87 8a27 	vdiv.f32	s16, s14, s15
    if (period < 1) period = npoints/2;
 80223e0:	2f00      	cmp	r7, #0
    if (period < npoints / MAXOVERLAP + 1)
        period = npoints / MAXOVERLAP + 1;
    
    x->x_npoints = npoints;
    x->x_phase = 0;
    x->x_period = period;
 80223e2:	f241 1106 	movw	r1, #4358	; 0x1106
    
    x->windowSize = npoints;
    x->hopSize = period;
 80223e6:	f241 1396 	movw	r3, #4502	; 0x1196
    x->blockSize = bs;
 80223ea:	f241 1098 	movw	r0, #4504	; 0x1198
    if (period < 1) period = npoints/2;
 80223ee:	bfd8      	it	le
 80223f0:	ea4f 0768 	movle.w	r7, r8, asr #1
    x->x_npoints = npoints;
 80223f4:	f241 150a 	movw	r5, #4362	; 0x110a
    x->blockSize = bs;
 80223f8:	fa1f f989 	uxth.w	r9, r9
    x->x_period = period;
 80223fc:	4297      	cmp	r7, r2
 80223fe:	bfb8      	it	lt
 8022400:	4617      	movlt	r7, r2
    x->x_phase = 0;
 8022402:	f241 1204 	movw	r2, #4356	; 0x1104
    x->x_period = period;
 8022406:	b2bf      	uxth	r7, r7
 8022408:	5277      	strh	r7, [r6, r1]
    x->x_phase = 0;
 802240a:	2100      	movs	r1, #0
    x->hopSize = period;
 802240c:	52f7      	strh	r7, [r6, r3]
    x->windowSize = npoints;
 802240e:	f241 1394 	movw	r3, #4500	; 0x1194
    x->blockSize = bs;
 8022412:	f826 9000 	strh.w	r9, [r6, r0]
 8022416:	f241 1010 	movw	r0, #4368	; 0x1110
    x->x_npoints = npoints;
 802241a:	5374      	strh	r4, [r6, r5]
    
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
    for (i = 0; i < npoints; i++)
 802241c:	460d      	mov	r5, r1
    x->x_phase = 0;
 802241e:	52b1      	strh	r1, [r6, r2]
 8022420:	4430      	add	r0, r6
    x->windowSize = npoints;
 8022422:	52f4      	strh	r4, [r6, r3]
 8022424:	2280      	movs	r2, #128	; 0x80
 8022426:	f008 fc68 	bl	802acfa <memset>
 802242a:	f640 73db 	movw	r3, #4059	; 0xfdb
    for (i = 0; i < MAXOVERLAP; i++) x->x_sumbuf[i] = 0;
 802242e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8022432:	1d34      	adds	r4, r6, #4
 8022434:	f2c4 03c9 	movt	r3, #16585	; 0x40c9
 8022438:	eb04 0b88 	add.w	fp, r4, r8, lsl #2
 802243c:	ee08 3a90 	vmov	s17, r3
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
 8022440:	eeb0 9a40 	vmov.f32	s18, s0
 8022444:	e001      	b.n	802244a <tEnvPD_initToPool+0xb2>
 8022446:	f008 fd79 	bl	802af3c <cosf>
    for (i = 0; i < npoints; i++)
 802244a:	3501      	adds	r5, #1
        x->buf[i] = (1.0f - cosf((2 * PI * i) / npoints))/npoints;
 802244c:	ee39 0a40 	vsub.f32	s0, s18, s0
 8022450:	ee07 5a90 	vmov	s15, r5
 8022454:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8022458:	ee60 7a08 	vmul.f32	s15, s0, s16
 802245c:	ee27 0a28 	vmul.f32	s0, s14, s17
 8022460:	ece4 7a01 	vstmia	r4!, {s15}
    for (i = 0; i < npoints; i++)
 8022464:	45a3      	cmp	fp, r4
 8022466:	ee20 0a08 	vmul.f32	s0, s0, s16
 802246a:	d1ec      	bne.n	8022446 <tEnvPD_initToPool+0xae>
    for (; i < npoints+INITVSTAKEN; i++) x->buf[i] = 0;
 802246c:	45d0      	cmp	r8, sl
 802246e:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 8022472:	da08      	bge.n	8022486 <tEnvPD_initToPool+0xee>
 8022474:	ebaa 0208 	sub.w	r2, sl, r8
 8022478:	eb06 0080 	add.w	r0, r6, r0, lsl #2
 802247c:	2100      	movs	r1, #0
 802247e:	0092      	lsls	r2, r2, #2
 8022480:	3008      	adds	r0, #8
 8022482:	f008 fc3a 	bl	802acfa <memset>
    
    x->x_f = 0;
 8022486:	f241 1290 	movw	r2, #4496	; 0x1190
 802248a:	2100      	movs	r1, #0
    
    x->x_allocforvs = INITVSTAKEN;
 802248c:	f241 109a 	movw	r0, #4506	; 0x119a
 8022490:	2440      	movs	r4, #64	; 0x40
    x->x_f = 0;
 8022492:	4432      	add	r2, r6
    
    // ~ ~ ~ dsp ~ ~ ~
    if (x->x_period % x->blockSize)
 8022494:	fbb7 f3f9 	udiv	r3, r7, r9
 8022498:	fb09 7313 	mls	r3, r9, r3, r7
    x->x_f = 0;
 802249c:	6011      	str	r1, [r2, #0]
    if (x->x_period % x->blockSize)
 802249e:	b29b      	uxth	r3, r3
    x->x_allocforvs = INITVSTAKEN;
 80224a0:	5234      	strh	r4, [r6, r0]
    if (x->x_period % x->blockSize)
 80224a2:	b113      	cbz	r3, 80224aa <tEnvPD_initToPool+0x112>
    {
        x->x_realperiod = x->x_period + x->blockSize - (x->x_period % x->blockSize);
 80224a4:	444f      	add	r7, r9
 80224a6:	1afb      	subs	r3, r7, r3
 80224a8:	b29f      	uxth	r7, r3
 80224aa:	f241 1308 	movw	r3, #4360	; 0x1108
 80224ae:	52f7      	strh	r7, [r6, r3]
    else
    {
        x->x_realperiod = x->x_period;
    }
    // ~ ~ ~ ~ ~ ~ ~ ~
}
 80224b0:	ecbd 8b04 	vpop	{d8-d9}
 80224b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80224b8:	f04f 516a 	mov.w	r1, #981467136	; 0x3a800000
 80224bc:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80224c0:	f44f 6a88 	mov.w	sl, #1088	; 0x440
 80224c4:	2221      	movs	r2, #33	; 0x21
 80224c6:	ee08 1a10 	vmov	s16, r1
    if (npoints < 1) npoints = 1024;
 80224ca:	46a0      	mov	r8, r4
 80224cc:	e788      	b.n	80223e0 <tEnvPD_initToPool+0x48>
 80224ce:	bf00      	nop

080224d0 <tEnvPD_tick>:
}

float tEnvPD_tick (tEnvPD* const xpd)
{
    _tEnvPD* x = *xpd;
    return powtodb(x->x_result);
 80224d0:	6802      	ldr	r2, [r0, #0]
 80224d2:	f241 130c 	movw	r3, #4364	; 0x110c
 80224d6:	4413      	add	r3, r2
 80224d8:	ed93 0a00 	vldr	s0, [r3]
 80224dc:	f005 bc10 	b.w	8027d00 <powtodb>

080224e0 <tSNAC_initToPool>:
{
    tSNAC_initToPool(snac, overlaparg, &leaf.mempool);
}

void    tSNAC_initToPool    (tSNAC* const snac, int overlaparg, tMempool* const mp)
{
 80224e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80224e4:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80224e8:	6816      	ldr	r6, [r2, #0]
{
 80224ea:	4681      	mov	r9, r0
 80224ec:	4688      	mov	r8, r1
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 80224ee:	202c      	movs	r0, #44	; 0x2c
 80224f0:	4631      	mov	r1, r6
    s->mempool = m;
    
    s->biasfactor = DEFBIAS;
    s->timeindex = 0;
    s->periodindex = 0;
    s->periodlength = 0.;
 80224f2:	2500      	movs	r5, #0
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 80224f4:	f005 fc7a 	bl	8027dec <mpool_alloc>
    s->biasfactor = DEFBIAS;
 80224f8:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    s->fidelity = 0.;
    s->minrms = DEFMINRMS;
 80224fc:	f649 33a6 	movw	r3, #39846	; 0x9ba6
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 8022500:	4604      	mov	r4, r0
    s->biasfactor = DEFBIAS;
 8022502:	f6c3 624c 	movt	r2, #15948	; 0x3e4c
    s->timeindex = 0;
 8022506:	f04f 6780 	mov.w	r7, #67108864	; 0x4000000
    s->minrms = DEFMINRMS;
 802250a:	f6c3 3344 	movt	r3, #15172	; 0x3b44
    _tSNAC* s = *snac = (_tSNAC*) mpool_alloc(sizeof(_tSNAC), m);
 802250e:	f8c9 0000 	str.w	r0, [r9]
    s->framesize = SNAC_FRAME_SIZE;

    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 8022512:	4631      	mov	r1, r6
    s->biasfactor = DEFBIAS;
 8022514:	6242      	str	r2, [r0, #36]	; 0x24
    s->minrms = DEFMINRMS;
 8022516:	6283      	str	r3, [r0, #40]	; 0x28
    s->mempool = m;
 8022518:	6006      	str	r6, [r0, #0]
    s->periodindex = 0;
 802251a:	8345      	strh	r5, [r0, #26]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 802251c:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    s->timeindex = 0;
 8022520:	6167      	str	r7, [r4, #20]
    s->periodlength = 0.;
 8022522:	61e5      	str	r5, [r4, #28]
    s->fidelity = 0.;
 8022524:	6225      	str	r5, [r4, #32]
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 8022526:	f005 fcb7 	bl	8027e98 <mpool_calloc>
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 802252a:	4631      	mov	r1, r6
    s->inputbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 802252c:	6060      	str	r0, [r4, #4]
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 802252e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8022532:	f005 fcb1 	bl	8027e98 <mpool_calloc>
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 8022536:	4631      	mov	r1, r6
    s->processbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE * 2), m);
 8022538:	60a0      	str	r0, [r4, #8]
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 802253a:	f44f 6000 	mov.w	r0, #2048	; 0x800
 802253e:	f005 fcab 	bl	8027e98 <mpool_calloc>
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 8022542:	4631      	mov	r1, r6
    s->spectrumbuf = (float*) mpool_calloc(sizeof(float) * (SNAC_FRAME_SIZE / 2), m);
 8022544:	60e0      	str	r0, [r4, #12]
    s->biasbuf = (float*) mpool_calloc(sizeof(float) * SNAC_FRAME_SIZE, m);
 8022546:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 802254a:	f005 fca5 	bl	8027e98 <mpool_calloc>
 802254e:	6120      	str	r0, [r4, #16]
    
    snac_biasbuf(snac);
 8022550:	f8d9 4000 	ldr.w	r4, [r9]
static void snac_biasbuf(tSNAC* const snac)
{
    _tSNAC* s = *snac;
    
    int n;
    int maxperiod = (int)(s->framesize * (float)SEEK);
 8022554:	f649 139a 	movw	r3, #39322	; 0x999a
 8022558:	8ae2      	ldrh	r2, [r4, #22]
 802255a:	f6c3 7359 	movt	r3, #16217	; 0x3f59
 802255e:	ee07 2a90 	vmov	s15, r2
 8022562:	ee07 3a10 	vmov	s14, r3
 8022566:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802256a:	ee67 7a87 	vmul.f32	s15, s15, s14
 802256e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8022572:	ee17 7a90 	vmov	r7, s15
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
 8022576:	1f3b      	subs	r3, r7, #4
 8022578:	ee00 3a10 	vmov	s0, r3
 802257c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8022580:	f008 fda2 	bl	802b0c8 <logf>
 8022584:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    for(n=0; n<5; n++)    // periods < 5 samples can't be tracked
    {
        biasbuf[n] = 0.0f;
    }
    
    for(n=5; n<maxperiod; n++)
 8022588:	2f05      	cmp	r7, #5
    float *biasbuf = s->biasbuf;
 802258a:	6924      	ldr	r4, [r4, #16]
    float bias = s->biasfactor / logf((float)(maxperiod - 4));
 802258c:	ee87 0a80 	vdiv.f32	s0, s15, s0
        biasbuf[n] = 0.0f;
 8022590:	6025      	str	r5, [r4, #0]
 8022592:	6065      	str	r5, [r4, #4]
 8022594:	60a5      	str	r5, [r4, #8]
 8022596:	60e5      	str	r5, [r4, #12]
 8022598:	6125      	str	r5, [r4, #16]
    for(n=5; n<maxperiod; n++)
 802259a:	dd19      	ble.n	80225d0 <tSNAC_initToPool+0xf0>
 802259c:	eeb1 8a40 	vneg.f32	s16, s0
 80225a0:	eb04 0787 	add.w	r7, r4, r7, lsl #2
    {
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
 80225a4:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 80225a8:	3414      	adds	r4, #20
    for(n=5; n<maxperiod; n++)
 80225aa:	2602      	movs	r6, #2
 80225ac:	ee00 5a10 	vmov	s0, r5
 80225b0:	e001      	b.n	80225b6 <tSNAC_initToPool+0xd6>
 80225b2:	f008 fd89 	bl	802b0c8 <logf>
        biasbuf[n] = 1.0f - (float)logf(n - 4) * bias;
 80225b6:	eef0 7a68 	vmov.f32	s15, s17
 80225ba:	ee07 6a10 	vmov	s14, r6
 80225be:	3601      	adds	r6, #1
 80225c0:	eee8 7a00 	vfma.f32	s15, s16, s0
 80225c4:	eeb8 0ac7 	vcvt.f32.s32	s0, s14
 80225c8:	ece4 7a01 	vstmia	r4!, {s15}
    for(n=5; n<maxperiod; n++)
 80225cc:	42bc      	cmp	r4, r7
 80225ce:	d1f0      	bne.n	80225b2 <tSNAC_initToPool+0xd2>
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
 80225d0:	f1b8 0f08 	cmp.w	r8, #8
 80225d4:	bf18      	it	ne
 80225d6:	f1b8 0f04 	cmpne.w	r8, #4
    _tSNAC* s = *snac;
 80225da:	f8d9 3000 	ldr.w	r3, [r9]
    if(!((lap==1)|(lap==2)|(lap==4)|(lap==8))) lap = DEFOVERLAP;
 80225de:	d005      	beq.n	80225ec <tSNAC_initToPool+0x10c>
 80225e0:	f108 32ff 	add.w	r2, r8, #4294967295	; 0xffffffff
 80225e4:	2a01      	cmp	r2, #1
 80225e6:	bf88      	it	hi
 80225e8:	f04f 0801 	movhi.w	r8, #1
    s->overlap = lap;
 80225ec:	f8a3 8018 	strh.w	r8, [r3, #24]
}
 80225f0:	ecbd 8b02 	vpop	{d8}
 80225f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080225f8 <tSNAC_ioSamples>:
{
 80225f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80225fc:	ed2d 8b02 	vpush	{d8}
 8022600:	b08b      	sub	sp, #44	; 0x2c
 8022602:	460d      	mov	r5, r1
 8022604:	9204      	str	r2, [sp, #16]
    _tSNAC* s = *snac;
 8022606:	6802      	ldr	r2, [r0, #0]
{
 8022608:	9002      	str	r0, [sp, #8]
 802260a:	9301      	str	r3, [sp, #4]
    int mask = s->framesize - 1;
 802260c:	8ad0      	ldrh	r0, [r2, #22]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 802260e:	8b13      	ldrh	r3, [r2, #24]
    int timeindex = s->timeindex;
 8022610:	8a94      	ldrh	r4, [r2, #20]
    int mask = s->framesize - 1;
 8022612:	1e46      	subs	r6, r0, #1
    _tSNAC* s = *snac;
 8022614:	9203      	str	r2, [sp, #12]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 8022616:	fbb0 f3f3 	udiv	r3, r0, r3
 802261a:	3b01      	subs	r3, #1
 802261c:	4023      	ands	r3, r4
    float *processbuf = s->processbuf;
 802261e:	e9d2 7801 	ldrd	r7, r8, [r2, #4]
    if(!(timeindex & (s->framesize / s->overlap - 1))) snac_analyzeframe(snac);
 8022622:	9305      	str	r3, [sp, #20]
 8022624:	d019      	beq.n	802265a <tSNAC_ioSamples+0x62>
    while(size--)
 8022626:	9b01      	ldr	r3, [sp, #4]
 8022628:	b183      	cbz	r3, 802264c <tSNAC_ioSamples+0x54>
 802262a:	9a04      	ldr	r2, [sp, #16]
 802262c:	eb05 0c83 	add.w	ip, r5, r3, lsl #2
        inputbuf[timeindex] = *in++;
 8022630:	00a3      	lsls	r3, r4, #2
 8022632:	f855 0b04 	ldr.w	r0, [r5], #4
        out[outindex++] = processbuf[timeindex++];
 8022636:	3401      	adds	r4, #1
        inputbuf[timeindex] = *in++;
 8022638:	18f9      	adds	r1, r7, r3
        out[outindex++] = processbuf[timeindex++];
 802263a:	4443      	add	r3, r8
    while(size--)
 802263c:	4565      	cmp	r5, ip
        timeindex &= mask;
 802263e:	ea04 0406 	and.w	r4, r4, r6
        inputbuf[timeindex] = *in++;
 8022642:	6008      	str	r0, [r1, #0]
        out[outindex++] = processbuf[timeindex++];
 8022644:	681b      	ldr	r3, [r3, #0]
 8022646:	f842 3b04 	str.w	r3, [r2], #4
    while(size--)
 802264a:	d1f1      	bne.n	8022630 <tSNAC_ioSamples+0x38>
    s->timeindex = timeindex;
 802264c:	9b03      	ldr	r3, [sp, #12]
 802264e:	829c      	strh	r4, [r3, #20]
}
 8022650:	b00b      	add	sp, #44	; 0x2c
 8022652:	ecbd 8b02 	vpop	{d8}
 8022656:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    float norm = 1. / sqrt((float)(framesize * 2));
 802265a:	ea4f 0e40 	mov.w	lr, r0, lsl #1
 802265e:	eeb7 5b00 	vmov.f64	d5, #112	; 0x3f800000  1.0
 8022662:	ee07 ea90 	vmov	s15, lr
 8022666:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 802266a:	eeb1 6bc7 	vsqrt.f64	d6, d7
 802266e:	ee85 7b06 	vdiv.f64	d7, d5, d6
 8022672:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    for(n=0; n<framesize; n++)
 8022676:	b178      	cbz	r0, 8022698 <tSNAC_ioSamples+0xa0>
 8022678:	4642      	mov	r2, r8
 802267a:	eb08 0c80 	add.w	ip, r8, r0, lsl #2
    int timeindex = s->timeindex;
 802267e:	4623      	mov	r3, r4
        processbuf[n] = inputbuf[tindex] * norm;
 8022680:	eb07 0183 	add.w	r1, r7, r3, lsl #2
        tindex++;
 8022684:	3301      	adds	r3, #1
        processbuf[n] = inputbuf[tindex] * norm;
 8022686:	edd1 7a00 	vldr	s15, [r1]
        tindex &= mask;
 802268a:	4033      	ands	r3, r6
        processbuf[n] = inputbuf[tindex] * norm;
 802268c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022690:	ece2 7a01 	vstmia	r2!, {s15}
    for(n=0; n<framesize; n++)
 8022694:	4594      	cmp	ip, r2
 8022696:	d1f3      	bne.n	8022680 <tSNAC_ioSamples+0x88>
    for(n=framesize; n<(framesize<<1); n++) processbuf[n] = 0.;
 8022698:	4570      	cmp	r0, lr
 802269a:	da07      	bge.n	80226ac <tSNAC_ioSamples+0xb4>
 802269c:	ebae 0200 	sub.w	r2, lr, r0
 80226a0:	2100      	movs	r1, #0
 80226a2:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 80226a6:	0092      	lsls	r2, r2, #2
 80226a8:	f008 fb27 	bl	802acfa <memset>
    snac_autocorrelation(snac);
 80226ac:	9b02      	ldr	r3, [sp, #8]
 80226ae:	681b      	ldr	r3, [r3, #0]
    int framesize = s->framesize;
 80226b0:	f8b3 9016 	ldrh.w	r9, [r3, #22]
    float *processbuf = s->processbuf;
 80226b4:	f8d3 a008 	ldr.w	sl, [r3, #8]
    int fftsize = framesize * 2;
 80226b8:	ea4f 0b49 	mov.w	fp, r9, lsl #1
    float *spectrumbuf = s->spectrumbuf;
 80226bc:	68db      	ldr	r3, [r3, #12]
    REALFFT(fftsize, processbuf);
 80226be:	4651      	mov	r1, sl
 80226c0:	4658      	mov	r0, fp
    float *spectrumbuf = s->spectrumbuf;
 80226c2:	9306      	str	r3, [sp, #24]
    REALFFT(fftsize, processbuf);
 80226c4:	f7ff fd0c 	bl	80220e0 <mayer_realfft>
    processbuf[0] *= processbuf[0];                      // DC
 80226c8:	edda 7a00 	vldr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
 80226cc:	eb0a 0189 	add.w	r1, sl, r9, lsl #2
    for(n=1; n<framesize; n++)
 80226d0:	f1b9 0f01 	cmp.w	r9, #1
    processbuf[0] *= processbuf[0];                      // DC
 80226d4:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80226d8:	edca 7a00 	vstr	s15, [sl]
    processbuf[framesize] *= processbuf[framesize];      // Nyquist
 80226dc:	edd1 7a00 	vldr	s15, [r1]
 80226e0:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80226e4:	edc1 7a00 	vstr	s15, [r1]
    for(n=1; n<framesize; n++)
 80226e8:	dd11      	ble.n	802270e <tSNAC_ioSamples+0x116>
        processbuf[fftsize-n] = 0.;
 80226ea:	2000      	movs	r0, #0
 80226ec:	f10a 0304 	add.w	r3, sl, #4
 80226f0:	eb0a 028b 	add.w	r2, sl, fp, lsl #2
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
 80226f4:	ed72 7a01 	vldmdb	r2!, {s15}
        processbuf[n] = processbuf[n] * processbuf[n]
 80226f8:	ed93 7a00 	vldr	s14, [r3]
        + processbuf[fftsize-n] * processbuf[fftsize-n]; // imag coefficients appear reversed
 80226fc:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8022700:	eee7 7a07 	vfma.f32	s15, s14, s14
        processbuf[n] = processbuf[n] * processbuf[n]
 8022704:	ece3 7a01 	vstmia	r3!, {s15}
    for(n=1; n<framesize; n++)
 8022708:	4299      	cmp	r1, r3
        processbuf[fftsize-n] = 0.;
 802270a:	6010      	str	r0, [r2, #0]
    for(n=1; n<framesize; n++)
 802270c:	d1f2      	bne.n	80226f4 <tSNAC_ioSamples+0xfc>
    for(m=0; m<(framesize>>1); m++)
 802270e:	ea5f 0969 	movs.w	r9, r9, asr #1
 8022712:	d009      	beq.n	8022728 <tSNAC_ioSamples+0x130>
 8022714:	9a06      	ldr	r2, [sp, #24]
 8022716:	eb0a 0989 	add.w	r9, sl, r9, lsl #2
 802271a:	4653      	mov	r3, sl
        spectrumbuf[m] = processbuf[m];
 802271c:	f853 1b04 	ldr.w	r1, [r3], #4
    for(m=0; m<(framesize>>1); m++)
 8022720:	4599      	cmp	r9, r3
        spectrumbuf[m] = processbuf[m];
 8022722:	f842 1b04 	str.w	r1, [r2], #4
    for(m=0; m<(framesize>>1); m++)
 8022726:	d1f9      	bne.n	802271c <tSNAC_ioSamples+0x124>
    REALIFFT(fftsize, processbuf);
 8022728:	4651      	mov	r1, sl
 802272a:	4658      	mov	r0, fp
 802272c:	f7ff fd02 	bl	8022134 <mayer_realifft>
    snac_normalize(snac);
 8022730:	9b02      	ldr	r3, [sp, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
 8022732:	eef7 4a00 	vmov.f32	s9, #112	; 0x3f800000  1.0
    int seek = framesize * SEEK;
 8022736:	f649 129a 	movw	r2, #39322	; 0x999a
    snac_normalize(snac);
 802273a:	681b      	ldr	r3, [r3, #0]
    int seek = framesize * SEEK;
 802273c:	f6c3 7259 	movt	r2, #16217	; 0x3f59
    int framesize = s->framesize;
 8022740:	8ad9      	ldrh	r1, [r3, #22]
    int seek = framesize * SEEK;
 8022742:	ee07 2a10 	vmov	s14, r2
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
 8022746:	ed93 5a0a 	vldr	s10, [r3, #40]	; 0x28
    int seek = framesize * SEEK;
 802274a:	ee07 1a90 	vmov	s15, r1
    int framesize = s->framesize;
 802274e:	9106      	str	r1, [sp, #24]
    float *processbuf= s->processbuf;
 8022750:	6899      	ldr	r1, [r3, #8]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
 8022752:	eeb7 5ac5 	vcvt.f64.f32	d5, s10
    int seek = framesize * SEEK;
 8022756:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    int framesizeplustimeindex = s->framesize + s->timeindex;
 802275a:	f8b3 a014 	ldrh.w	sl, [r3, #20]
    float rzero = processbuf[0];
 802275e:	460a      	mov	r2, r1
 8022760:	ed91 6a00 	vldr	s12, [r1]
    float *inputbuf = s->inputbuf;
 8022764:	f8d3 9004 	ldr.w	r9, [r3, #4]
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
 8022768:	eec4 6aa7 	vdiv.f32	s13, s9, s15
    processbuf[0] = 1;
 802276c:	edc2 4a00 	vstr	s9, [r2]
    float *processbuf= s->processbuf;
 8022770:	9107      	str	r1, [sp, #28]
    int mask = framesize - 1;
 8022772:	9906      	ldr	r1, [sp, #24]
 8022774:	f101 3eff 	add.w	lr, r1, #4294967295	; 0xffffffff
    int framesizeplustimeindex = s->framesize + s->timeindex;
 8022778:	eb0a 0b01 	add.w	fp, sl, r1
    int seek = framesize * SEEK;
 802277c:	ee67 7a87 	vmul.f32	s15, s15, s14
 8022780:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8022784:	ee17 0a90 	vmov	r0, s15
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 8022788:	2801      	cmp	r0, #1
    float rms = s->minrms / sqrt(1.0f / (float)framesize);
 802278a:	eeb7 7ae6 	vcvt.f64.f32	d7, s13
 802278e:	eeb1 4bc7 	vsqrt.f64	d4, d7
 8022792:	ee85 7b04 	vdiv.f64	d7, d5, d4
 8022796:	eeb7 7bc7 	vcvt.f32.f64	s14, d7
    float minrzero = rms * rms;
 802279a:	ee27 7a07 	vmul.f32	s14, s14, s14
    double normintegral = (double)rzero * 2.;
 802279e:	fe87 6a06 	vmaxnm.f32	s12, s14, s12
 80227a2:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
 80227a6:	ee36 6b06 	vadd.f64	d6, d6, d6
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 80227aa:	dd2b      	ble.n	8022804 <tSNAC_ioSamples+0x20c>
        processbuf[n] /= (float)normintegral * 0.5f;
 80227ac:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
 80227b0:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80227b4:	f102 0c04 	add.w	ip, r2, #4
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 80227b8:	2101      	movs	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
 80227ba:	ebab 0201 	sub.w	r2, fp, r1
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 80227be:	eb0a 0301 	add.w	r3, sl, r1
        processbuf[n] /= (float)normintegral * 0.5f;
 80227c2:	eddc 5a00 	vldr	s11, [ip]
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 80227c6:	3101      	adds	r1, #1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
 80227c8:	ea02 020e 	and.w	r2, r2, lr
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 80227cc:	ea03 030e 	and.w	r3, r3, lr
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 80227d0:	4288      	cmp	r0, r1
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
 80227d2:	eb09 0282 	add.w	r2, r9, r2, lsl #2
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 80227d6:	eb09 0383 	add.w	r3, r9, r3, lsl #2
        signal2 = inputbuf[(framesizeplustimeindex - n)&mask];
 80227da:	ed92 7a00 	vldr	s14, [r2]
        signal1 = inputbuf[(n + timeindexminusone)&mask];
 80227de:	edd3 7a00 	vldr	s15, [r3]
        normintegral -= (double)(signal1 * signal1 + signal2 * signal2);
 80227e2:	ee27 7a07 	vmul.f32	s14, s14, s14
 80227e6:	eea7 7aa7 	vfma.f32	s14, s15, s15
 80227ea:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 80227ee:	ee36 6b47 	vsub.f64	d6, d6, d7
        processbuf[n] /= (float)normintegral * 0.5f;
 80227f2:	eef7 7bc6 	vcvt.f32.f64	s15, d6
 80227f6:	ee67 7a85 	vmul.f32	s15, s15, s10
 80227fa:	ee85 7aa7 	vdiv.f32	s14, s11, s15
 80227fe:	ecac 7a01 	vstmia	ip!, {s14}
    for(n=1, m=s->timeindex+1; n<seek; n++, m++)
 8022802:	d1da      	bne.n	80227ba <tSNAC_ioSamples+0x1c2>
    for(n = seek; n<framesize; n++) processbuf[n] = 0.;
 8022804:	9b06      	ldr	r3, [sp, #24]
 8022806:	4283      	cmp	r3, r0
 8022808:	dd07      	ble.n	802281a <tSNAC_ioSamples+0x222>
 802280a:	1a1a      	subs	r2, r3, r0
 802280c:	9b07      	ldr	r3, [sp, #28]
 802280e:	2100      	movs	r1, #0
 8022810:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 8022814:	0092      	lsls	r2, r2, #2
 8022816:	f008 fa70 	bl	802acfa <memset>
    snac_pickpeak(snac);
 802281a:	9b02      	ldr	r3, [sp, #8]
 802281c:	6819      	ldr	r1, [r3, #0]
    int seek = s->framesize * SEEK;
 802281e:	f649 139a 	movw	r3, #39322	; 0x999a
 8022822:	8aca      	ldrh	r2, [r1, #22]
 8022824:	f6c3 7359 	movt	r3, #16217	; 0x3f59
    snac_pickpeak(snac);
 8022828:	9107      	str	r1, [sp, #28]
    int seek = s->framesize * SEEK;
 802282a:	ee07 2a90 	vmov	s15, r2
 802282e:	ee07 3a10 	vmov	s14, r3
    float *processbuf= s->processbuf;
 8022832:	688a      	ldr	r2, [r1, #8]
    int seek = s->framesize * SEEK;
 8022834:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float *biasbuf = s->biasbuf;
 8022838:	690b      	ldr	r3, [r1, #16]
    int seek = s->framesize * SEEK;
 802283a:	ee67 7a87 	vmul.f32	s15, s15, s14
 802283e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8022842:	ee17 ba90 	vmov	fp, s15
    for(n=1; n<seek; n++)
 8022846:	f1bb 0f01 	cmp.w	fp, #1
 802284a:	f340 808b 	ble.w	8022964 <tSNAC_ioSamples+0x36c>
        if(processbuf[n] < 0.) break;
 802284e:	edd2 7a01 	vldr	s15, [r2, #4]
 8022852:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8022856:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802285a:	f100 8083 	bmi.w	8022964 <tSNAC_ioSamples+0x36c>
 802285e:	f102 0108 	add.w	r1, r2, #8
    for(n=1; n<seek; n++)
 8022862:	f04f 0901 	mov.w	r9, #1
 8022866:	e006      	b.n	8022876 <tSNAC_ioSamples+0x27e>
        if(processbuf[n] < 0.) break;
 8022868:	ecf1 7a01 	vldmia	r1!, {s15}
 802286c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8022870:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022874:	d404      	bmi.n	8022880 <tSNAC_ioSamples+0x288>
    for(n=1; n<seek; n++)
 8022876:	f109 0901 	add.w	r9, r9, #1
 802287a:	45cb      	cmp	fp, r9
 802287c:	d1f4      	bne.n	8022868 <tSNAC_ioSamples+0x270>
 802287e:	46d9      	mov	r9, fp
    for(; n<seek-1; n++)
 8022880:	f10b 3bff 	add.w	fp, fp, #4294967295	; 0xffffffff
 8022884:	45cb      	cmp	fp, r9
 8022886:	dd6b      	ble.n	8022960 <tSNAC_ioSamples+0x368>
 8022888:	ea4f 0a89 	mov.w	sl, r9, lsl #2
 802288c:	2100      	movs	r1, #0
 802288e:	9408      	str	r4, [sp, #32]
 8022890:	4614      	mov	r4, r2
 8022892:	4453      	add	r3, sl
 8022894:	f1aa 0a04 	sub.w	sl, sl, #4
 8022898:	9509      	str	r5, [sp, #36]	; 0x24
 802289a:	ee08 1a10 	vmov	s16, r1
 802289e:	465d      	mov	r5, fp
 80228a0:	9106      	str	r1, [sp, #24]
 80228a2:	4492      	add	sl, r2
 80228a4:	469b      	mov	fp, r3
 80228a6:	e005      	b.n	80228b4 <tSNAC_ioSamples+0x2bc>
 80228a8:	f109 0901 	add.w	r9, r9, #1
 80228ac:	f10b 0b04 	add.w	fp, fp, #4
 80228b0:	45a9      	cmp	r9, r5
 80228b2:	d029      	beq.n	8022908 <tSNAC_ioSamples+0x310>
 80228b4:	4651      	mov	r1, sl
        if(processbuf[n] >= processbuf[n-1])
 80228b6:	f10a 0a04 	add.w	sl, sl, #4
 80228ba:	ed91 7a00 	vldr	s14, [r1]
 80228be:	edda 7a00 	vldr	s15, [sl]
 80228c2:	eef4 7ac7 	vcmpe.f32	s15, s14
 80228c6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80228ca:	dbed      	blt.n	80228a8 <tSNAC_ioSamples+0x2b0>
            if(processbuf[n] > processbuf[n+1])     // we have a local peak
 80228cc:	ed9a 7a01 	vldr	s14, [sl, #4]
 80228d0:	eef4 7ac7 	vcmpe.f32	s15, s14
 80228d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80228d8:	dde6      	ble.n	80228a8 <tSNAC_ioSamples+0x2b0>
                biasedpeak = interpolate3max(processbuf, n) * biasbuf[n];
 80228da:	4649      	mov	r1, r9
 80228dc:	4620      	mov	r0, r4
 80228de:	f004 ff2b 	bl	8027738 <interpolate3max>
 80228e2:	eddb 7a00 	vldr	s15, [fp]
 80228e6:	ee20 0a27 	vmul.f32	s0, s0, s15
                if(biasedpeak > maxvalue)
 80228ea:	eeb4 0ac8 	vcmpe.f32	s0, s16
 80228ee:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80228f2:	ddd9      	ble.n	80228a8 <tSNAC_ioSamples+0x2b0>
 80228f4:	f8cd 9018 	str.w	r9, [sp, #24]
    for(; n<seek-1; n++)
 80228f8:	f109 0901 	add.w	r9, r9, #1
                    maxvalue = biasedpeak;
 80228fc:	eeb0 8a40 	vmov.f32	s16, s0
 8022900:	f10b 0b04 	add.w	fp, fp, #4
    for(; n<seek-1; n++)
 8022904:	45a9      	cmp	r9, r5
 8022906:	d1d5      	bne.n	80228b4 <tSNAC_ioSamples+0x2bc>
 8022908:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 802290c:	e9dd 4508 	ldrd	r4, r5, [sp, #32]
    s->periodindex = peakindex;
 8022910:	9a07      	ldr	r2, [sp, #28]
 8022912:	8353      	strh	r3, [r2, #26]
    _tSNAC* s = *snac;
 8022914:	9b02      	ldr	r3, [sp, #8]
 8022916:	f8d3 a000 	ldr.w	sl, [r3]
    if(s->periodindex)
 802291a:	f8ba 901a 	ldrh.w	r9, [sl, #26]
 802291e:	f1b9 0f00 	cmp.w	r9, #0
 8022922:	f43f ae80 	beq.w	8022626 <tSNAC_ioSamples+0x2e>
        interpolate3phase(s->processbuf, s->periodindex);
 8022926:	4649      	mov	r1, r9
 8022928:	f8da 0008 	ldr.w	r0, [sl, #8]
 802292c:	f004 ff24 	bl	8027778 <interpolate3phase>
        periodlength = (float)s->periodindex +
 8022930:	ee07 9a90 	vmov	s15, r9
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 8022934:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
        periodlength = (float)s->periodindex +
 8022938:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802293c:	ee37 0a80 	vadd.f32	s0, s15, s0
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 8022940:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8022944:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022948:	d40f      	bmi.n	802296a <tSNAC_ioSamples+0x372>
        s->periodlength = periodlength;
 802294a:	ed8a 0a07 	vstr	s0, [sl, #28]
        s->fidelity = interpolate3max(s->processbuf, s->periodindex);
 802294e:	f8ba 101a 	ldrh.w	r1, [sl, #26]
 8022952:	f8da 0008 	ldr.w	r0, [sl, #8]
 8022956:	f004 feef 	bl	8027738 <interpolate3max>
 802295a:	ed8a 0a08 	vstr	s0, [sl, #32]
 802295e:	e662      	b.n	8022626 <tSNAC_ioSamples+0x2e>
    for(; n<seek-1; n++)
 8022960:	2300      	movs	r3, #0
 8022962:	e7d5      	b.n	8022910 <tSNAC_ioSamples+0x318>
    for(n=1; n<seek; n++)
 8022964:	f04f 0901 	mov.w	r9, #1
 8022968:	e78a      	b.n	8022880 <tSNAC_ioSamples+0x288>
    if(periodlength < 4.0f) return periodlength;
 802296a:	eef1 7a00 	vmov.f32	s15, #16	; 0x40800000  4.0
 802296e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8022972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022976:	d4e8      	bmi.n	802294a <tSNAC_ioSamples+0x352>
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 8022978:	9b02      	ldr	r3, [sp, #8]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 802297a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802297e:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 8022982:	eef7 5a04 	vmov.f32	s11, #116	; 0x3fa00000  1.250
        if(periodlength < 8) periodlength = snac_spectralpeak(snac, periodlength);
 8022986:	f8d3 9000 	ldr.w	r9, [r3]
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 802298a:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    int spectrumsize = s->framesize>>1;
 802298e:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    float *spectrumbuf = s->spectrumbuf;
 8022992:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 8022996:	ee07 3a10 	vmov	s14, r3
    int spectrumsize = s->framesize>>1;
 802299a:	085b      	lsrs	r3, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 802299c:	eef8 6ac7 	vcvt.f32.s32	s13, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 80229a0:	ee07 2a10 	vmov	s14, r2
    if(stopbin >= spectrumsize - 1) stopbin = spectrumsize - 1;
 80229a4:	1e5a      	subs	r2, r3, #1
    float peaklocation = (float)(s->framesize * 2.0f) / periodlength;
 80229a6:	ee76 6aa6 	vadd.f32	s13, s13, s13
 80229aa:	ee86 6a80 	vdiv.f32	s12, s13, s0
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 80229ae:	eef0 6a67 	vmov.f32	s13, s15
 80229b2:	eee6 6a25 	vfma.f32	s13, s12, s11
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 80229b6:	eee6 7a07 	vfma.f32	s15, s12, s14
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 80229ba:	eebd 7ae6 	vcvt.s32.f32	s14, s13
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 80229be:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    stopbin = (int)(peaklocation * 1.25f + 0.5f);
 80229c2:	ee17 1a10 	vmov	r1, s14
    startbin = (int)(peaklocation * 0.8f + 0.5f);
 80229c6:	ee17 3a90 	vmov	r3, s15
 80229ca:	4291      	cmp	r1, r2
 80229cc:	bfa8      	it	ge
 80229ce:	4611      	movge	r1, r2
 80229d0:	2b01      	cmp	r3, #1
 80229d2:	bfb8      	it	lt
 80229d4:	2301      	movlt	r3, #1
    for(n=startbin; n<stopbin; n++)
 80229d6:	4299      	cmp	r1, r3
 80229d8:	dd6b      	ble.n	8022ab2 <tSNAC_ioSamples+0x4ba>
 80229da:	f64f 72ff 	movw	r2, #65535	; 0xffff
    float max = 0.;
 80229de:	2000      	movs	r0, #0
 80229e0:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
 80229e4:	ee06 0a90 	vmov	s13, r0
 80229e8:	441a      	add	r2, r3
 80229ea:	eb0c 0282 	add.w	r2, ip, r2, lsl #2
 80229ee:	4610      	mov	r0, r2
        if(spectrumbuf[n] >= spectrumbuf[n-1])
 80229f0:	3204      	adds	r2, #4
 80229f2:	ed90 7a00 	vldr	s14, [r0]
 80229f6:	edd2 7a00 	vldr	s15, [r2]
 80229fa:	eef4 7ac7 	vcmpe.f32	s15, s14
 80229fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022a02:	db0e      	blt.n	8022a22 <tSNAC_ioSamples+0x42a>
            if(spectrumbuf[n] > spectrumbuf[n+1])
 8022a04:	ed92 7a01 	vldr	s14, [r2, #4]
                if(spectrumbuf[n] > max)
 8022a08:	eef4 7a47 	vcmp.f32	s15, s14
 8022a0c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022a10:	dd07      	ble.n	8022a22 <tSNAC_ioSamples+0x42a>
 8022a12:	eef4 7a66 	vcmp.f32	s15, s13
 8022a16:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022a1a:	dd02      	ble.n	8022a22 <tSNAC_ioSamples+0x42a>
                    max = spectrumbuf[n];
 8022a1c:	eef0 6a67 	vmov.f32	s13, s15
                if(spectrumbuf[n] > max)
 8022a20:	9305      	str	r3, [sp, #20]
    for(n=startbin; n<stopbin; n++)
 8022a22:	3301      	adds	r3, #1
 8022a24:	4299      	cmp	r1, r3
 8022a26:	d1e2      	bne.n	80229ee <tSNAC_ioSamples+0x3f6>
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a28:	9905      	ldr	r1, [sp, #20]
 8022a2a:	1e4b      	subs	r3, r1, #1
 8022a2c:	1c8a      	adds	r2, r1, #2
 8022a2e:	ee07 1a90 	vmov	s15, r1
 8022a32:	429a      	cmp	r2, r3
 8022a34:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 8022a38:	dd2a      	ble.n	8022a90 <tSNAC_ioSamples+0x498>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a3a:	009b      	lsls	r3, r3, #2
 8022a3c:	eb0c 0103 	add.w	r1, ip, r3
 8022a40:	ed91 7a00 	vldr	s14, [r1]
 8022a44:	eef1 7ac7 	vsqrt.f32	s15, s14
 8022a48:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a4c:	9905      	ldr	r1, [sp, #20]
 8022a4e:	428a      	cmp	r2, r1
 8022a50:	dd1e      	ble.n	8022a90 <tSNAC_ioSamples+0x498>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a52:	3304      	adds	r3, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a54:	1c48      	adds	r0, r1, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a56:	eb0c 0103 	add.w	r1, ip, r3
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a5a:	4282      	cmp	r2, r0
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a5c:	ed91 7a00 	vldr	s14, [r1]
 8022a60:	eef1 7ac7 	vsqrt.f32	s15, s14
 8022a64:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a68:	dd12      	ble.n	8022a90 <tSNAC_ioSamples+0x498>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a6a:	1d19      	adds	r1, r3, #4
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a6c:	3001      	adds	r0, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a6e:	4461      	add	r1, ip
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a70:	4282      	cmp	r2, r0
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a72:	ed91 7a00 	vldr	s14, [r1]
 8022a76:	eef1 7ac7 	vsqrt.f32	s15, s14
 8022a7a:	edc1 7a00 	vstr	s15, [r1]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022a7e:	dd07      	ble.n	8022a90 <tSNAC_ioSamples+0x498>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022a80:	3308      	adds	r3, #8
 8022a82:	4463      	add	r3, ip
 8022a84:	ed93 7a00 	vldr	s14, [r3]
 8022a88:	eef1 7ac7 	vsqrt.f32	s15, s14
 8022a8c:	edc3 7a00 	vstr	s15, [r3]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
 8022a90:	9905      	ldr	r1, [sp, #20]
 8022a92:	4660      	mov	r0, ip
 8022a94:	f004 fe70 	bl	8027778 <interpolate3phase>
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
 8022a98:	f8b9 3016 	ldrh.w	r3, [r9, #22]
    peaklocation = (float)peakbin + interpolate3phase(spectrumbuf, peakbin);
 8022a9c:	ee30 8a08 	vadd.f32	s16, s0, s16
    periodlength = (float)(s->framesize * 2.0f) / peaklocation;
 8022aa0:	ee07 3a90 	vmov	s15, r3
 8022aa4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8022aa8:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8022aac:	ee87 0a88 	vdiv.f32	s0, s15, s16
 8022ab0:	e74b      	b.n	802294a <tSNAC_ioSamples+0x352>
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022ab2:	ed5c 7a01 	vldr	s15, [ip, #-4]
 8022ab6:	2300      	movs	r3, #0
 8022ab8:	eddc 6a00 	vldr	s13, [ip]
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022abc:	2001      	movs	r0, #1
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022abe:	eeb1 7ae7 	vsqrt.f32	s14, s15
 8022ac2:	ee08 3a10 	vmov	s16, r3
    for(n=(peakbin-1); n<(peakbin+2); n++)
 8022ac6:	2202      	movs	r2, #2
        spectrumbuf[n] = sqrtf(spectrumbuf[n]);
 8022ac8:	eef1 7ae6 	vsqrt.f32	s15, s13
 8022acc:	ed0c 7a01 	vstr	s14, [ip, #-4]
 8022ad0:	edcc 7a00 	vstr	s15, [ip]
 8022ad4:	e7c9      	b.n	8022a6a <tSNAC_ioSamples+0x472>
 8022ad6:	bf00      	nop

08022ad8 <tPeriodDetection_initToPool>:
{
    tPeriodDetection_initToPool(pd, in, out, bufSize, frameSize, &leaf.mempool);
}

void tPeriodDetection_initToPool (tPeriodDetection* const pd, float* in, float* out, int bufSize, int frameSize, tMempool* const mp)
{
 8022ad8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8022adc:	b085      	sub	sp, #20
 8022ade:	4682      	mov	sl, r0
 8022ae0:	468b      	mov	fp, r1
    _tMempool* m = *mp;
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 8022ae2:	2068      	movs	r0, #104	; 0x68
{
 8022ae4:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
 8022ae6:	461d      	mov	r5, r3
 8022ae8:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    p->inBuffer = in;
    p->outBuffer = out;
    p->bufSize = bufSize;
    p->frameSize = frameSize;
    p->framesPerBuffer = p->bufSize / p->frameSize;
    p->curBlock = 1;
 8022aea:	f04f 0801 	mov.w	r8, #1
    _tMempool* m = *mp;
 8022aee:	f8d6 9000 	ldr.w	r9, [r6]
{
 8022af2:	9203      	str	r2, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 8022af4:	4649      	mov	r1, r9
 8022af6:	f005 f9cf 	bl	8027e98 <mpool_calloc>
 8022afa:	4604      	mov	r4, r0
    p->lastBlock = 0;
 8022afc:	f04f 0c00 	mov.w	ip, #0
    p->outBuffer = out;
 8022b00:	9b03      	ldr	r3, [sp, #12]
    _tPeriodDetection* p = *pd = (_tPeriodDetection*) mpool_calloc(sizeof(_tPeriodDetection), m);
 8022b02:	f8ca 4000 	str.w	r4, [sl]
    
    p->hopSize = DEFHOPSIZE;
    p->windowSize = DEFWINDOWSIZE;
    p->fba = FBA;
    
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 8022b06:	2240      	movs	r2, #64	; 0x40
    p->hopSize = DEFHOPSIZE;
 8022b08:	f04f 1040 	mov.w	r0, #4194368	; 0x400040
    p->fba = FBA;
 8022b0c:	2114      	movs	r1, #20
    p->index = 0;
 8022b0e:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
    p->outBuffer = out;
 8022b12:	6123      	str	r3, [r4, #16]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 8022b14:	463b      	mov	r3, r7
    p->hopSize = DEFHOPSIZE;
 8022b16:	63e0      	str	r0, [r4, #60]	; 0x3c
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 8022b18:	1d20      	adds	r0, r4, #4
    p->fba = FBA;
 8022b1a:	f884 1040 	strb.w	r1, [r4, #64]	; 0x40
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 8022b1e:	4611      	mov	r1, r2
    p->mempool = m;
 8022b20:	f8c4 9000 	str.w	r9, [r4]
    p->inBuffer = in;
 8022b24:	f8c4 b00c 	str.w	fp, [r4, #12]
    p->frameSize = frameSize;
 8022b28:	e9c4 7505 	strd	r7, r5, [r4, #20]
    p->framesPerBuffer = p->bufSize / p->frameSize;
 8022b2c:	fb95 f5f7 	sdiv	r5, r5, r7
    p->lastBlock = 0;
 8022b30:	e9c4 8c08 	strd	r8, ip, [r4, #32]
    p->framesPerBuffer = p->bufSize / p->frameSize;
 8022b34:	61e5      	str	r5, [r4, #28]
    tEnvPD_initToPool(&p->env, p->windowSize, p->hopSize, p->frameSize, mp);
 8022b36:	9600      	str	r6, [sp, #0]
 8022b38:	f7ff fc2e 	bl	8022398 <tEnvPD_initToPool>
    
    tSNAC_initToPool(&p->snac, DEFOVERLAP, mp);
 8022b3c:	4632      	mov	r2, r6
 8022b3e:	4641      	mov	r1, r8
 8022b40:	f104 0008 	add.w	r0, r4, #8
 8022b44:	f7ff fccc 	bl	80224e0 <tSNAC_initToPool>

    p->history = 0.0f;
    p->alpha = 1.0f;
    p->tolerance = 1.0f;
    p->timeConstant = DEFTIMECONSTANT;
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b48:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8022b4c:	8fa2      	ldrh	r2, [r4, #60]	; 0x3c
 8022b4e:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
 8022b52:	f2c2 0101 	movt	r1, #8193	; 0x2001
    p->timeConstant = DEFTIMECONSTANT;
 8022b56:	2300      	movs	r3, #0
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b58:	ee00 2a10 	vmov	s0, r2
 8022b5c:	edd1 7a01 	vldr	s15, [r1, #4]
    p->history = 0.0f;
 8022b60:	461a      	mov	r2, r3
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b62:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    p->alpha = 1.0f;
 8022b66:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b6a:	ee67 7a87 	vmul.f32	s15, s15, s14
    p->timeConstant = DEFTIMECONSTANT;
 8022b6e:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    p->history = 0.0f;
 8022b72:	65e2      	str	r2, [r4, #92]	; 0x5c
    p->timeConstant = DEFTIMECONSTANT;
 8022b74:	6463      	str	r3, [r4, #68]	; 0x44
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b76:	ee20 0a27 	vmul.f32	s0, s0, s15
    p->alpha = 1.0f;
 8022b7a:	6621      	str	r1, [r4, #96]	; 0x60
    p->tolerance = 1.0f;
 8022b7c:	6661      	str	r1, [r4, #100]	; 0x64
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b7e:	f008 fa1d 	bl	802afbc <expf>
    p->fidelityThreshold = 0.95;
 8022b82:	f243 3333 	movw	r3, #13107	; 0x3333
    p->radius = expf(-1000.0f * p->hopSize * leaf.invSampleRate / p->timeConstant);
 8022b86:	ed84 0a12 	vstr	s0, [r4, #72]	; 0x48
    p->fidelityThreshold = 0.95;
 8022b8a:	f6c3 7373 	movt	r3, #16243	; 0x3f73
 8022b8e:	65a3      	str	r3, [r4, #88]	; 0x58
}
 8022b90:	b005      	add	sp, #20
 8022b92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8022b96:	bf00      	nop

08022b98 <tPeriodDetection_free>:

void tPeriodDetection_free (tPeriodDetection* const pd)
{
 8022b98:	b538      	push	{r3, r4, r5, lr}
    _tPeriodDetection* p = *pd;
 8022b9a:	6805      	ldr	r5, [r0, #0]
    _tEnvPD* x = *xpd;
 8022b9c:	6868      	ldr	r0, [r5, #4]
    mpool_free((char*)x, x->mempool);
 8022b9e:	6801      	ldr	r1, [r0, #0]
 8022ba0:	f005 f9ce 	bl	8027f40 <mpool_free>
    _tSNAC* s = *snac;
 8022ba4:	68ac      	ldr	r4, [r5, #8]
    mpool_free((char*)s->inputbuf, s->mempool);
 8022ba6:	e9d4 1000 	ldrd	r1, r0, [r4]
 8022baa:	f005 f9c9 	bl	8027f40 <mpool_free>
    mpool_free((char*)s->processbuf, s->mempool);
 8022bae:	6821      	ldr	r1, [r4, #0]
 8022bb0:	68a0      	ldr	r0, [r4, #8]
 8022bb2:	f005 f9c5 	bl	8027f40 <mpool_free>
    mpool_free((char*)s->spectrumbuf, s->mempool);
 8022bb6:	6821      	ldr	r1, [r4, #0]
 8022bb8:	68e0      	ldr	r0, [r4, #12]
 8022bba:	f005 f9c1 	bl	8027f40 <mpool_free>
    mpool_free((char*)s->biasbuf, s->mempool);
 8022bbe:	6821      	ldr	r1, [r4, #0]
 8022bc0:	6920      	ldr	r0, [r4, #16]
 8022bc2:	f005 f9bd 	bl	8027f40 <mpool_free>
    mpool_free((char*)s, s->mempool);
 8022bc6:	6821      	ldr	r1, [r4, #0]
 8022bc8:	4620      	mov	r0, r4
 8022bca:	f005 f9b9 	bl	8027f40 <mpool_free>
    
    tEnvPD_free(&p->env);
    tSNAC_free(&p->snac);
    mpool_free((char*)p, p->mempool);
 8022bce:	6829      	ldr	r1, [r5, #0]
 8022bd0:	4628      	mov	r0, r5
}
 8022bd2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    mpool_free((char*)p, p->mempool);
 8022bd6:	f005 b9b3 	b.w	8027f40 <mpool_free>
 8022bda:	bf00      	nop

08022bdc <tPeriodDetection_tick>:

float tPeriodDetection_tick (tPeriodDetection* pd, float sample)
{
 8022bdc:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tPeriodDetection* p = *pd;
 8022be0:	6804      	ldr	r4, [r0, #0]
    
    int i, iLast;
    
    i = (p->curBlock*p->frameSize);
 8022be2:	6963      	ldr	r3, [r4, #20]
 8022be4:	6a21      	ldr	r1, [r4, #32]
    iLast = (p->lastBlock*p->frameSize)+p->index;
 8022be6:	6b62      	ldr	r2, [r4, #52]	; 0x34
    i = (p->curBlock*p->frameSize);
 8022be8:	fb01 f103 	mul.w	r1, r1, r3
    iLast = (p->lastBlock*p->frameSize)+p->index;
 8022bec:	6a65      	ldr	r5, [r4, #36]	; 0x24
    
    p->i = i;
    p->iLast = iLast;
    
    p->inBuffer[i+p->index] = sample;
 8022bee:	68e0      	ldr	r0, [r4, #12]
    iLast = (p->lastBlock*p->frameSize)+p->index;
 8022bf0:	fb05 2303 	mla	r3, r5, r3, r2
    p->inBuffer[i+p->index] = sample;
 8022bf4:	440a      	add	r2, r1
    p->i = i;
 8022bf6:	62a1      	str	r1, [r4, #40]	; 0x28
    p->inBuffer[i+p->index] = sample;
 8022bf8:	eb00 0282 	add.w	r2, r0, r2, lsl #2
    p->iLast = iLast;
 8022bfc:	6323      	str	r3, [r4, #48]	; 0x30
    p->inBuffer[i+p->index] = sample;
 8022bfe:	ed82 0a00 	vstr	s0, [r2]
    
    p->index++;
 8022c02:	6b63      	ldr	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
    if (p->index >= p->frameSize)
 8022c04:	6962      	ldr	r2, [r4, #20]
    p->index++;
 8022c06:	3301      	adds	r3, #1
    if (p->index >= p->frameSize)
 8022c08:	4293      	cmp	r3, r2
    p->index++;
 8022c0a:	6363      	str	r3, [r4, #52]	; 0x34
    p->indexstore = p->index;
 8022c0c:	62e3      	str	r3, [r4, #44]	; 0x2c
    if (p->index >= p->frameSize)
 8022c0e:	da03      	bge.n	8022c18 <tPeriodDetection_tick+0x3c>
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
        p->lastBlock++;
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
    }
    return p->period;
}
 8022c10:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 8022c14:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    _tEnvPD* x = *xpd;
 8022c18:	f8d4 c004 	ldr.w	ip, [r4, #4]
        p->index = 0;
 8022c1c:	2200      	movs	r2, #0
    int n = x->blockSize;
 8022c1e:	f241 1398 	movw	r3, #4504	; 0x1198
    for (count = x->x_phase, sump = x->x_sumbuf;
 8022c22:	f241 1004 	movw	r0, #4356	; 0x1104
        p->index = 0;
 8022c26:	6362      	str	r2, [r4, #52]	; 0x34
        tEnvPD_processBlock(&p->env, &(p->inBuffer[i]));
 8022c28:	0089      	lsls	r1, r1, #2
    int n = x->blockSize;
 8022c2a:	f83c 5003 	ldrh.w	r5, [ip, r3]
         count < x->x_npoints; count += x->x_realperiod, sump++)
 8022c2e:	f241 130a 	movw	r3, #4362	; 0x110a
    for (count = x->x_phase, sump = x->x_sumbuf;
 8022c32:	f83c 6000 	ldrh.w	r6, [ip, r0]
 8022c36:	f241 1b10 	movw	fp, #4368	; 0x1110
 8022c3a:	f83c 3003 	ldrh.w	r3, [ip, r3]
    in += n;
 8022c3e:	eb01 0985 	add.w	r9, r1, r5, lsl #2
 8022c42:	68e2      	ldr	r2, [r4, #12]
    for (count = x->x_phase, sump = x->x_sumbuf;
 8022c44:	44e3      	add	fp, ip
 8022c46:	42b3      	cmp	r3, r6
    in += n;
 8022c48:	4491      	add	r9, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
 8022c4a:	d924      	bls.n	8022c96 <tPeriodDetection_tick+0xba>
 8022c4c:	f241 1808 	movw	r8, #4360	; 0x1108
 8022c50:	f241 1e0a 	movw	lr, #4362	; 0x110a
 8022c54:	465f      	mov	r7, fp
 8022c56:	f10c 0a04 	add.w	sl, ip, #4
 8022c5a:	44e0      	add	r8, ip
 8022c5c:	44e6      	add	lr, ip
        t_sample *hp = x->buf + count;
 8022c5e:	eb0a 0286 	add.w	r2, sl, r6, lsl #2
        t_sample sum = *sump;
 8022c62:	ecb7 7a01 	vldmia	r7!, {s14}
        for (i = 0; i < n; i++)
 8022c66:	b165      	cbz	r5, 8022c82 <tPeriodDetection_tick+0xa6>
 8022c68:	4648      	mov	r0, r9
 8022c6a:	2300      	movs	r3, #0
            sum += *hp++ * (*fp * *fp);
 8022c6c:	ed70 7a01 	vldmdb	r0!, {s15}
        for (i = 0; i < n; i++)
 8022c70:	3301      	adds	r3, #1
            sum += *hp++ * (*fp * *fp);
 8022c72:	ecf2 6a01 	vldmia	r2!, {s13}
 8022c76:	ee67 7aa7 	vmul.f32	s15, s15, s15
        for (i = 0; i < n; i++)
 8022c7a:	429d      	cmp	r5, r3
            sum += *hp++ * (*fp * *fp);
 8022c7c:	eea6 7aa7 	vfma.f32	s14, s13, s15
        for (i = 0; i < n; i++)
 8022c80:	d1f4      	bne.n	8022c6c <tPeriodDetection_tick+0x90>
        *sump = sum;
 8022c82:	ed07 7a01 	vstr	s14, [r7, #-4]
 8022c86:	46bb      	mov	fp, r7
         count < x->x_npoints; count += x->x_realperiod, sump++)
 8022c88:	f8b8 2000 	ldrh.w	r2, [r8]
 8022c8c:	f8be 3000 	ldrh.w	r3, [lr]
 8022c90:	4416      	add	r6, r2
    for (count = x->x_phase, sump = x->x_sumbuf;
 8022c92:	429e      	cmp	r6, r3
 8022c94:	dbe3      	blt.n	8022c5e <tPeriodDetection_tick+0x82>
    x->x_phase -= n;
 8022c96:	f241 1204 	movw	r2, #4356	; 0x1104
    sump[0] = 0;
 8022c9a:	2300      	movs	r3, #0
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
 8022c9c:	f104 0008 	add.w	r0, r4, #8
    sump[0] = 0;
 8022ca0:	f8cb 3000 	str.w	r3, [fp]
    x->x_phase -= n;
 8022ca4:	f83c 3002 	ldrh.w	r3, [ip, r2]
 8022ca8:	1b5d      	subs	r5, r3, r5
 8022caa:	f82c 5002 	strh.w	r5, [ip, r2]
        tSNAC_ioSamples(&p->snac, &(p->inBuffer[i]), &(p->outBuffer[i]), p->frameSize);
 8022cae:	6963      	ldr	r3, [r4, #20]
 8022cb0:	e9d4 5203 	ldrd	r5, r2, [r4, #12]
 8022cb4:	440a      	add	r2, r1
 8022cb6:	4429      	add	r1, r5
 8022cb8:	f7ff fc9e 	bl	80225f8 <tSNAC_ioSamples>
    _tSNAC* s = *snac;
 8022cbc:	68a3      	ldr	r3, [r4, #8]
        if (fidelity > p->fidelityThreshold)
 8022cbe:	ed94 7a16 	vldr	s14, [r4, #88]	; 0x58
 8022cc2:	edd3 7a08 	vldr	s15, [r3, #32]
 8022cc6:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8022cca:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022cce:	d501      	bpl.n	8022cd4 <tPeriodDetection_tick+0xf8>
    return(s->periodlength);
 8022cd0:	69db      	ldr	r3, [r3, #28]
        	p->period = tSNAC_getPeriod(&p->snac);
 8022cd2:	63a3      	str	r3, [r4, #56]	; 0x38
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 8022cd4:	e9d4 2307 	ldrd	r2, r3, [r4, #28]
        p->curBlock++;
 8022cd8:	3301      	adds	r3, #1
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 8022cda:	4293      	cmp	r3, r2
        p->curBlock++;
 8022cdc:	6223      	str	r3, [r4, #32]
        if (p->curBlock >= p->framesPerBuffer) p->curBlock = 0;
 8022cde:	db01      	blt.n	8022ce4 <tPeriodDetection_tick+0x108>
 8022ce0:	2300      	movs	r3, #0
 8022ce2:	6223      	str	r3, [r4, #32]
        p->lastBlock++;
 8022ce4:	6a63      	ldr	r3, [r4, #36]	; 0x24
}
 8022ce6:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
        p->lastBlock++;
 8022cea:	3301      	adds	r3, #1
        if (p->lastBlock >= p->framesPerBuffer) p->lastBlock = 0;
 8022cec:	429a      	cmp	r2, r3
 8022cee:	bfd8      	it	le
 8022cf0:	2300      	movle	r3, #0
 8022cf2:	6263      	str	r3, [r4, #36]	; 0x24
}
 8022cf4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

08022cf8 <tPeriodDetection_getPeriod>:

float tPeriodDetection_getPeriod(tPeriodDetection* pd)
{
    _tPeriodDetection* p = *pd;
    return p->period;
 8022cf8:	6803      	ldr	r3, [r0, #0]
}
 8022cfa:	ed93 0a0e 	vldr	s0, [r3, #56]	; 0x38
 8022cfe:	4770      	bx	lr

08022d00 <tPeriodDetection_setFidelityThreshold>:
    p->windowSize = ws;
}

void tPeriodDetection_setFidelityThreshold(tPeriodDetection* pd, float threshold)
{
    _tPeriodDetection* p = *pd;
 8022d00:	6803      	ldr	r3, [r0, #0]
    p->fidelityThreshold = threshold;
 8022d02:	ed83 0a16 	vstr	s0, [r3, #88]	; 0x58
}
 8022d06:	4770      	bx	lr

08022d08 <tLinearDelay_initToPool>:
{
    tLinearDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tLinearDelay_initToPool  (tLinearDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
 8022d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8022d0a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022d0e:	6816      	ldr	r6, [r2, #0]
{
 8022d10:	460d      	mov	r5, r1
 8022d12:	4607      	mov	r7, r0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 8022d14:	202c      	movs	r0, #44	; 0x2c
 8022d16:	4631      	mov	r1, r6
{
 8022d18:	eeb0 8a40 	vmov.f32	s16, s0
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 8022d1c:	f005 f866 	bl	8027dec <mpool_alloc>
    d->mempool = m;

    d->maxDelay = maxDelay;

    if (delay > maxDelay)   d->delay = maxDelay;
 8022d20:	ee07 5a90 	vmov	s15, r5
    _tLinearDelay* d = *dl = (_tLinearDelay*) mpool_alloc(sizeof(_tLinearDelay), m);
 8022d24:	6038      	str	r0, [r7, #0]
 8022d26:	4604      	mov	r4, r0
    if (delay > maxDelay)   d->delay = maxDelay;
 8022d28:	eef8 7a67 	vcvt.f32.u32	s15, s15
    d->mempool = m;
 8022d2c:	6006      	str	r6, [r0, #0]
    d->maxDelay = maxDelay;
 8022d2e:	61c5      	str	r5, [r0, #28]
    if (delay > maxDelay)   d->delay = maxDelay;
 8022d30:	eef4 7ac8 	vcmpe.f32	s15, s16
 8022d34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022d38:	d453      	bmi.n	8022de2 <tLinearDelay_initToPool+0xda>
    else if (delay < 0.0f)  d->delay = 0.0f;
 8022d3a:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8022d3e:	2300      	movs	r3, #0
 8022d40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022d44:	bf4c      	ite	mi
 8022d46:	6203      	strmi	r3, [r0, #32]
    else                    d->delay = delay;
 8022d48:	ed80 8a08 	vstrpl	s16, [r0, #32]

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8022d4c:	4631      	mov	r1, r6
 8022d4e:	00a8      	lsls	r0, r5, #2
 8022d50:	f005 f84c 	bl	8027dec <mpool_alloc>

    d->gain = 1.0f;

    d->lastIn = 0.0f;
 8022d54:	2300      	movs	r3, #0
    d->gain = 1.0f;
 8022d56:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8022d5a:	60a0      	str	r0, [r4, #8]
    d->lastOut = 0.0f;
    
    d->inPoint = 0;
 8022d5c:	6163      	str	r3, [r4, #20]

int     tLinearDelay_setDelay (tLinearDelay* const dl, float delay)
{
    _tLinearDelay* d = *dl;

    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 8022d5e:	ee00 3a10 	vmov	s0, r3
    d->lastIn = 0.0f;
 8022d62:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
 8022d64:	60e3      	str	r3, [r4, #12]
    d->gain = 1.0f;
 8022d66:	6061      	str	r1, [r4, #4]
    d->outPoint = 0;
 8022d68:	61a3      	str	r3, [r4, #24]
    _tLinearDelay* d = *dl;
 8022d6a:	683d      	ldr	r5, [r7, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 8022d6c:	edd4 0a08 	vldr	s1, [r4, #32]
 8022d70:	edd5 7a07 	vldr	s15, [r5, #28]
 8022d74:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 8022d78:	f004 fe1e 	bl	80279b8 <LEAF_clip>

    float outPointer = d->inPoint - d->delay;
 8022d7c:	edd5 7a05 	vldr	s15, [r5, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 8022d80:	ed85 0a08 	vstr	s0, [r5, #32]
    float outPointer = d->inPoint - d->delay;
 8022d84:	eef8 7a67 	vcvt.f32.u32	s15, s15

    while ( outPointer < 0 )
        outPointer += d->maxDelay; // modulo maximum length
 8022d88:	69ea      	ldr	r2, [r5, #28]
    float outPointer = d->inPoint - d->delay;
 8022d8a:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
 8022d8e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8022d92:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022d96:	d50a      	bpl.n	8022dae <tLinearDelay_initToPool+0xa6>
        outPointer += d->maxDelay; // modulo maximum length
 8022d98:	ee07 2a90 	vmov	s15, r2
 8022d9c:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8022da0:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
 8022da4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8022da8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022dac:	d4f8      	bmi.n	8022da0 <tLinearDelay_initToPool+0x98>

    d->outPoint = (uint32_t) outPointer;   // integer part
 8022dae:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8022db2:	ee17 3a90 	vmov	r3, s15

    d->alpha = outPointer - d->outPoint; // fractional part
    d->omAlpha = 1.0f - d->alpha;
 8022db6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
 8022dba:	ee07 3a10 	vmov	s14, r3

    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 8022dbe:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
 8022dc0:	61ab      	str	r3, [r5, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
 8022dc2:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8022dc6:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
 8022dca:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
 8022dce:	ed85 0a09 	vstr	s0, [r5, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
 8022dd2:	edc5 7a0a 	vstr	s15, [r5, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 8022dd6:	d101      	bne.n	8022ddc <tLinearDelay_initToPool+0xd4>
 8022dd8:	2300      	movs	r3, #0
 8022dda:	61ab      	str	r3, [r5, #24]
}
 8022ddc:	ecbd 8b02 	vpop	{d8}
 8022de0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (delay > maxDelay)   d->delay = maxDelay;
 8022de2:	edc0 7a08 	vstr	s15, [r0, #32]
 8022de6:	e7b1      	b.n	8022d4c <tLinearDelay_initToPool+0x44>

08022de8 <tLinearDelay_free>:
{
 8022de8:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
 8022dea:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
 8022dec:	6821      	ldr	r1, [r4, #0]
 8022dee:	68a0      	ldr	r0, [r4, #8]
 8022df0:	f005 f8a6 	bl	8027f40 <mpool_free>
    mpool_free((char*)d, d->mempool);
 8022df4:	6821      	ldr	r1, [r4, #0]
 8022df6:	4620      	mov	r0, r4
}
 8022df8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
 8022dfc:	f005 b8a0 	b.w	8027f40 <mpool_free>

08022e00 <tLinearDelay_clear>:
	_tLinearDelay* d = *dl;
 8022e00:	6801      	ldr	r1, [r0, #0]
	for (int i = 0; i < d->maxDelay; i++)
 8022e02:	69cb      	ldr	r3, [r1, #28]
 8022e04:	b14b      	cbz	r3, 8022e1a <tLinearDelay_clear+0x1a>
		d->buff[i] = 0;
 8022e06:	2000      	movs	r0, #0
	for (int i = 0; i < d->maxDelay; i++)
 8022e08:	4603      	mov	r3, r0
		d->buff[i] = 0;
 8022e0a:	688a      	ldr	r2, [r1, #8]
 8022e0c:	eb02 0283 	add.w	r2, r2, r3, lsl #2
	for (int i = 0; i < d->maxDelay; i++)
 8022e10:	3301      	adds	r3, #1
		d->buff[i] = 0;
 8022e12:	6010      	str	r0, [r2, #0]
	for (int i = 0; i < d->maxDelay; i++)
 8022e14:	69ca      	ldr	r2, [r1, #28]
 8022e16:	429a      	cmp	r2, r3
 8022e18:	d8f7      	bhi.n	8022e0a <tLinearDelay_clear+0xa>
}
 8022e1a:	4770      	bx	lr

08022e1c <tLinearDelay_tick>:
{
 8022e1c:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
 8022e1e:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 8022e20:	edd3 7a01 	vldr	s15, [r3, #4]
 8022e24:	6959      	ldr	r1, [r3, #20]
 8022e26:	689a      	ldr	r2, [r3, #8]
 8022e28:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022e2c:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8022e30:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 8022e34:	695a      	ldr	r2, [r3, #20]
 8022e36:	69d9      	ldr	r1, [r3, #28]
 8022e38:	3201      	adds	r2, #1
 8022e3a:	428a      	cmp	r2, r1
 8022e3c:	615a      	str	r2, [r3, #20]
 8022e3e:	d101      	bne.n	8022e44 <tLinearDelay_tick+0x28>
 8022e40:	2200      	movs	r2, #0
 8022e42:	615a      	str	r2, [r3, #20]
    uint32_t idx = (uint32_t) d->outPoint;
 8022e44:	699a      	ldr	r2, [r3, #24]
    d->lastOut = d->buff[idx] * d->omAlpha;
 8022e46:	6898      	ldr	r0, [r3, #8]
    if ((idx + 1) < d->maxDelay)
 8022e48:	1c54      	adds	r4, r2, #1
    d->lastOut = d->buff[idx] * d->omAlpha;
 8022e4a:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 8022e4e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8022e52:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    if ((idx + 1) < d->maxDelay)
 8022e56:	42a1      	cmp	r1, r4
    d->lastOut = d->buff[idx] * d->omAlpha;
 8022e58:	ed92 0a00 	vldr	s0, [r2]
 8022e5c:	ee20 0a07 	vmul.f32	s0, s0, s14
 8022e60:	ed83 0a03 	vstr	s0, [r3, #12]
    if ((idx + 1) < d->maxDelay)
 8022e64:	d909      	bls.n	8022e7a <tLinearDelay_tick+0x5e>
        d->lastOut += d->buff[idx+1] * d->alpha;
 8022e66:	ed92 7a01 	vldr	s14, [r2, #4]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022e6a:	619c      	str	r4, [r3, #24]
        d->lastOut += d->buff[idx+1] * d->alpha;
 8022e6c:	eea7 0a27 	vfma.f32	s0, s14, s15
 8022e70:	ed83 0a03 	vstr	s0, [r3, #12]
}
 8022e74:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022e78:	4770      	bx	lr
        d->lastOut += d->buff[0] * d->alpha;
 8022e7a:	ed90 7a00 	vldr	s14, [r0]
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022e7e:	2200      	movs	r2, #0
        d->lastOut += d->buff[0] * d->alpha;
 8022e80:	eea7 0a27 	vfma.f32	s0, s14, s15
    if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022e84:	619a      	str	r2, [r3, #24]
        d->lastOut += d->buff[0] * d->alpha;
 8022e86:	ed83 0a03 	vstr	s0, [r3, #12]
}
 8022e8a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022e8e:	4770      	bx	lr

08022e90 <tLinearDelay_tickIn>:
    _tLinearDelay* d = *dl;
 8022e90:	6803      	ldr	r3, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 8022e92:	edd3 7a01 	vldr	s15, [r3, #4]
 8022e96:	6959      	ldr	r1, [r3, #20]
 8022e98:	689a      	ldr	r2, [r3, #8]
 8022e9a:	ee27 0a80 	vmul.f32	s0, s15, s0
 8022e9e:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8022ea2:	ed82 0a00 	vstr	s0, [r2]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 8022ea6:	695a      	ldr	r2, [r3, #20]
 8022ea8:	69d9      	ldr	r1, [r3, #28]
 8022eaa:	3201      	adds	r2, #1
 8022eac:	428a      	cmp	r2, r1
 8022eae:	615a      	str	r2, [r3, #20]
 8022eb0:	d101      	bne.n	8022eb6 <tLinearDelay_tickIn+0x26>
 8022eb2:	2200      	movs	r2, #0
 8022eb4:	615a      	str	r2, [r3, #20]
}
 8022eb6:	4770      	bx	lr

08022eb8 <tLinearDelay_tickOut>:
{
 8022eb8:	b410      	push	{r4}
    _tLinearDelay* d = *dl;
 8022eba:	6803      	ldr	r3, [r0, #0]
	uint32_t idx = (uint32_t) d->outPoint;
 8022ebc:	699a      	ldr	r2, [r3, #24]
	d->lastOut = d->buff[idx] * d->omAlpha;
 8022ebe:	6899      	ldr	r1, [r3, #8]
	if ((idx + 1) < d->maxDelay)
 8022ec0:	1c50      	adds	r0, r2, #1
	d->lastOut = d->buff[idx] * d->omAlpha;
 8022ec2:	ed93 7a0a 	vldr	s14, [r3, #40]	; 0x28
 8022ec6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	if ((idx + 1) < d->maxDelay)
 8022eca:	69dc      	ldr	r4, [r3, #28]
 8022ecc:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
	d->lastOut = d->buff[idx] * d->omAlpha;
 8022ed0:	ed92 0a00 	vldr	s0, [r2]
	if ((idx + 1) < d->maxDelay)
 8022ed4:	42a0      	cmp	r0, r4
	d->lastOut = d->buff[idx] * d->omAlpha;
 8022ed6:	ee20 0a07 	vmul.f32	s0, s0, s14
 8022eda:	ed83 0a03 	vstr	s0, [r3, #12]
	if ((idx + 1) < d->maxDelay)
 8022ede:	d209      	bcs.n	8022ef4 <tLinearDelay_tickOut+0x3c>
		d->lastOut += d->buff[idx+1] * d->alpha;
 8022ee0:	ed92 7a01 	vldr	s14, [r2, #4]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022ee4:	6198      	str	r0, [r3, #24]
		d->lastOut += d->buff[idx+1] * d->alpha;
 8022ee6:	eea7 0a27 	vfma.f32	s0, s14, s15
 8022eea:	ed83 0a03 	vstr	s0, [r3, #12]
}
 8022eee:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022ef2:	4770      	bx	lr
		d->lastOut += d->buff[0] * d->alpha;
 8022ef4:	ed91 7a00 	vldr	s14, [r1]
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022ef8:	2200      	movs	r2, #0
		d->lastOut += d->buff[0] * d->alpha;
 8022efa:	eea7 0a27 	vfma.f32	s0, s14, s15
	if ( (++d->outPoint) >= d->maxDelay )   d->outPoint = 0;
 8022efe:	619a      	str	r2, [r3, #24]
		d->lastOut += d->buff[0] * d->alpha;
 8022f00:	ed83 0a03 	vstr	s0, [r3, #12]
}
 8022f04:	f85d 4b04 	ldr.w	r4, [sp], #4
 8022f08:	4770      	bx	lr
 8022f0a:	bf00      	nop

08022f0c <tLinearDelay_setDelay>:
{
 8022f0c:	b510      	push	{r4, lr}
    _tLinearDelay* d = *dl;
 8022f0e:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 8022f10:	2300      	movs	r3, #0
 8022f12:	eef0 0a40 	vmov.f32	s1, s0
 8022f16:	edd4 7a07 	vldr	s15, [r4, #28]
 8022f1a:	ee00 3a10 	vmov	s0, r3
 8022f1e:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 8022f22:	f004 fd49 	bl	80279b8 <LEAF_clip>
    float outPointer = d->inPoint - d->delay;
 8022f26:	edd4 7a05 	vldr	s15, [r4, #20]
    d->delay = LEAF_clip(0.0f, delay,  d->maxDelay);
 8022f2a:	ed84 0a08 	vstr	s0, [r4, #32]
    float outPointer = d->inPoint - d->delay;
 8022f2e:	eef8 7a67 	vcvt.f32.u32	s15, s15
        outPointer += d->maxDelay; // modulo maximum length
 8022f32:	69e2      	ldr	r2, [r4, #28]
    float outPointer = d->inPoint - d->delay;
 8022f34:	ee37 0ac0 	vsub.f32	s0, s15, s0
    while ( outPointer < 0 )
 8022f38:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8022f3c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022f40:	d50a      	bpl.n	8022f58 <tLinearDelay_setDelay+0x4c>
        outPointer += d->maxDelay; // modulo maximum length
 8022f42:	ee07 2a90 	vmov	s15, r2
 8022f46:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8022f4a:	ee30 0a27 	vadd.f32	s0, s0, s15
    while ( outPointer < 0 )
 8022f4e:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 8022f52:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8022f56:	d4f8      	bmi.n	8022f4a <tLinearDelay_setDelay+0x3e>
    d->outPoint = (uint32_t) outPointer;   // integer part
 8022f58:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8022f5c:	ee17 3a90 	vmov	r3, s15
    d->omAlpha = 1.0f - d->alpha;
 8022f60:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->alpha = outPointer - d->outPoint; // fractional part
 8022f64:	ee07 3a10 	vmov	s14, r3
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 8022f68:	4293      	cmp	r3, r2
    d->outPoint = (uint32_t) outPointer;   // integer part
 8022f6a:	61a3      	str	r3, [r4, #24]
    d->alpha = outPointer - d->outPoint; // fractional part
 8022f6c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8022f70:	ee30 0a47 	vsub.f32	s0, s0, s14
    d->omAlpha = 1.0f - d->alpha;
 8022f74:	ee77 7ac0 	vsub.f32	s15, s15, s0
    d->alpha = outPointer - d->outPoint; // fractional part
 8022f78:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    d->omAlpha = 1.0f - d->alpha;
 8022f7c:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
    if ( d->outPoint == d->maxDelay ) d->outPoint = 0;
 8022f80:	d101      	bne.n	8022f86 <tLinearDelay_setDelay+0x7a>
 8022f82:	2300      	movs	r3, #0
 8022f84:	61a3      	str	r3, [r4, #24]

    return 0;
}
 8022f86:	2000      	movs	r0, #0
 8022f88:	bd10      	pop	{r4, pc}
 8022f8a:	bf00      	nop

08022f8c <tLinearDelay_getDelay>:
}

float   tLinearDelay_getDelay (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->delay;
 8022f8c:	6803      	ldr	r3, [r0, #0]
}
 8022f8e:	ed93 0a08 	vldr	s0, [r3, #32]
 8022f92:	4770      	bx	lr

08022f94 <tLinearDelay_getLastOut>:

float   tLinearDelay_getLastOut (tLinearDelay* const dl)
{
    _tLinearDelay* d = *dl;
    return d->lastOut;
 8022f94:	6803      	ldr	r3, [r0, #0]
}
 8022f96:	ed93 0a03 	vldr	s0, [r3, #12]
 8022f9a:	4770      	bx	lr

08022f9c <tTapeDelay_init>:
    return d->gain;
}

// ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ TapeDelay ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ //
void tTapeDelay_init (tTapeDelay* const dl, float delay, uint32_t maxDelay)
{
 8022f9c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tTapeDelay_initToPool(dl, delay, maxDelay, &leaf.mempool);
}

void tTapeDelay_initToPool (tTapeDelay* const dl, float delay, uint32_t maxDelay, tMempool* const mp)
{
    _tMempool* m = *mp;
 8022f9e:	f249 43a0 	movw	r3, #38048	; 0x94a0
{
 8022fa2:	4606      	mov	r6, r0
 8022fa4:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 8022fa6:	202c      	movs	r0, #44	; 0x2c
    _tMempool* m = *mp;
 8022fa8:	f2c2 0301 	movt	r3, #8193	; 0x2001
{
 8022fac:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8022fb0:	699d      	ldr	r5, [r3, #24]
{
 8022fb2:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 8022fb6:	4629      	mov	r1, r5
 8022fb8:	f004 ff18 	bl	8027dec <mpool_alloc>
 8022fbc:	4604      	mov	r4, r0
    d->mempool = m;

    d->maxDelay = maxDelay;

    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8022fbe:	4629      	mov	r1, r5
 8022fc0:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 8022fc2:	6034      	str	r4, [r6, #0]
    d->mempool = m;
 8022fc4:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
 8022fc6:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8022fc8:	f004 ff10 	bl	8027dec <mpool_alloc>

    d->gain = 1.0f;
 8022fcc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

    d->lastIn = 0.0f;
 8022fd0:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8022fd2:	60a0      	str	r0, [r4, #8]
}

void     tTapeDelay_setDelay (tTapeDelay* const dl, float delay)
{
    _tTapeDelay* d = *dl;
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 8022fd4:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
 8022fd8:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 8022fdc:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
 8022fe0:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
 8022fe4:	6163      	str	r3, [r4, #20]
    d->lastIn = 0.0f;
 8022fe6:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
 8022fe8:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
 8022fea:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
 8022fec:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 8022fee:	edd4 7a06 	vldr	s15, [r4, #24]
 8022ff2:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 8022ff6:	f004 fcdf 	bl	80279b8 <LEAF_clip>
 8022ffa:	ed84 0a07 	vstr	s0, [r4, #28]
}
 8022ffe:	ecbd 8b02 	vpop	{d8}
 8023002:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08023004 <tTapeDelay_initToPool>:
{
 8023004:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
 8023006:	6815      	ldr	r5, [r2, #0]
{
 8023008:	4606      	mov	r6, r0
 802300a:	460f      	mov	r7, r1
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 802300c:	202c      	movs	r0, #44	; 0x2c
 802300e:	4629      	mov	r1, r5
{
 8023010:	ed2d 8b02 	vpush	{d8}
 8023014:	eeb0 8a40 	vmov.f32	s16, s0
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 8023018:	f004 fee8 	bl	8027dec <mpool_alloc>
 802301c:	4604      	mov	r4, r0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 802301e:	4629      	mov	r1, r5
 8023020:	00b8      	lsls	r0, r7, #2
    _tTapeDelay* d = *dl = (_tTapeDelay*) mpool_alloc(sizeof(_tTapeDelay), m);
 8023022:	6034      	str	r4, [r6, #0]
    d->mempool = m;
 8023024:	6025      	str	r5, [r4, #0]
    d->maxDelay = maxDelay;
 8023026:	61a7      	str	r7, [r4, #24]
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8023028:	f004 fee0 	bl	8027dec <mpool_alloc>
    d->gain = 1.0f;
 802302c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    d->lastIn = 0.0f;
 8023030:	2300      	movs	r3, #0
    d->buff = (float*) mpool_alloc(sizeof(float) * maxDelay, m);
 8023032:	60a0      	str	r0, [r4, #8]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 8023034:	eef0 0a48 	vmov.f32	s1, s16
    d->gain = 1.0f;
 8023038:	edc4 7a01 	vstr	s15, [r4, #4]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 802303c:	eeb0 0a67 	vmov.f32	s0, s15
    d->inc = 1.0f;
 8023040:	edc4 7a08 	vstr	s15, [r4, #32]
    d->inPoint = 0;
 8023044:	6163      	str	r3, [r4, #20]
    d->lastIn = 0.0f;
 8023046:	6123      	str	r3, [r4, #16]
    d->lastOut = 0.0f;
 8023048:	60e3      	str	r3, [r4, #12]
    d->idx = 0.0f;
 802304a:	6263      	str	r3, [r4, #36]	; 0x24
    _tTapeDelay* d = *dl;
 802304c:	6834      	ldr	r4, [r6, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 802304e:	edd4 7a06 	vldr	s15, [r4, #24]
 8023052:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 8023056:	f004 fcaf 	bl	80279b8 <LEAF_clip>
 802305a:	ed84 0a07 	vstr	s0, [r4, #28]
}
 802305e:	ecbd 8b02 	vpop	{d8}
 8023062:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08023064 <tTapeDelay_free>:
{
 8023064:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
 8023066:	6804      	ldr	r4, [r0, #0]
    mpool_free((char*)d->buff, d->mempool);
 8023068:	6821      	ldr	r1, [r4, #0]
 802306a:	68a0      	ldr	r0, [r4, #8]
 802306c:	f004 ff68 	bl	8027f40 <mpool_free>
    mpool_free((char*)d, d->mempool);
 8023070:	6821      	ldr	r1, [r4, #0]
 8023072:	4620      	mov	r0, r4
}
 8023074:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)d, d->mempool);
 8023078:	f004 bf62 	b.w	8027f40 <mpool_free>

0802307c <tTapeDelay_tick>:
{
 802307c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tTapeDelay* d = *dl;
 802307e:	6804      	ldr	r4, [r0, #0]
    d->buff[d->inPoint] = input * d->gain;
 8023080:	edd4 7a01 	vldr	s15, [r4, #4]
 8023084:	6962      	ldr	r2, [r4, #20]
 8023086:	68a3      	ldr	r3, [r4, #8]
 8023088:	ee27 0a80 	vmul.f32	s0, s15, s0
 802308c:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 8023090:	ed83 0a00 	vstr	s0, [r3]
    if (++(d->inPoint) == d->maxDelay )    d->inPoint = 0;
 8023094:	e9d4 2305 	ldrd	r2, r3, [r4, #20]
 8023098:	3201      	adds	r2, #1
 802309a:	429a      	cmp	r2, r3
 802309c:	6162      	str	r2, [r4, #20]
 802309e:	d101      	bne.n	80230a4 <tTapeDelay_tick+0x28>
 80230a0:	2200      	movs	r2, #0
 80230a2:	6162      	str	r2, [r4, #20]
    int idx =  (int) d->idx;
 80230a4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80230a8:	1e5e      	subs	r6, r3, #1
 80230aa:	68a1      	ldr	r1, [r4, #8]
    int idx =  (int) d->idx;
 80230ac:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 80230b0:	ee17 2a10 	vmov	r2, s14
    float alpha = d->idx - idx;
 80230b4:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[(idx + 1) % d->maxDelay],
 80230b8:	1c57      	adds	r7, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
 80230ba:	f102 0c02 	add.w	ip, r2, #2
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80230be:	4416      	add	r6, r2
 80230c0:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 80230c4:	ee37 2ac2 	vsub.f32	s4, s15, s4
 80230c8:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
 80230cc:	fbb7 f0f3 	udiv	r0, r7, r3
 80230d0:	fb03 7010 	mls	r0, r3, r0, r7
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80230d4:	eb01 0280 	add.w	r2, r1, r0, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
 80230d8:	fbbc f5f3 	udiv	r5, ip, r3
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80230dc:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
 80230e0:	fb03 c515 	mls	r5, r3, r5, ip
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80230e4:	fbb6 f2f3 	udiv	r2, r6, r3
 80230e8:	fb03 6312 	mls	r3, r3, r2, r6
 80230ec:	eb01 0585 	add.w	r5, r1, r5, lsl #2
 80230f0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 80230f4:	edd5 1a00 	vldr	s3, [r5]
 80230f8:	ed91 0a00 	vldr	s0, [r1]
 80230fc:	f004 fd7c 	bl	8027bf8 <LEAF_interpolate_hermite_x>
    float diff = (d->inPoint - d->idx);
 8023100:	edd4 7a05 	vldr	s15, [r4, #20]
 8023104:	edd4 6a09 	vldr	s13, [r4, #36]	; 0x24
 8023108:	eef8 7a67 	vcvt.f32.u32	s15, s15
    while (diff < 0.f) diff += d->maxDelay;
 802310c:	ed94 7a06 	vldr	s14, [r4, #24]
    d->lastOut =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 8023110:	ed84 0a03 	vstr	s0, [r4, #12]
    while (diff < 0.f) diff += d->maxDelay;
 8023114:	eeb8 7a47 	vcvt.f32.u32	s14, s14
    float diff = (d->inPoint - d->idx);
 8023118:	ee77 7ae6 	vsub.f32	s15, s15, s13
    while (diff < 0.f) diff += d->maxDelay;
 802311c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8023120:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023124:	d506      	bpl.n	8023134 <tTapeDelay_tick+0xb8>
 8023126:	ee77 7a87 	vadd.f32	s15, s15, s14
 802312a:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802312e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023132:	d4f8      	bmi.n	8023126 <tTapeDelay_tick+0xaa>
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
 8023134:	edd4 5a07 	vldr	s11, [r4, #28]
 8023138:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
 802313c:	ee77 7ae5 	vsub.f32	s15, s15, s11
 8023140:	ee87 6aa5 	vdiv.f32	s12, s15, s11
 8023144:	ee76 7a05 	vadd.f32	s15, s12, s10
    d->idx += d->inc;
 8023148:	ee76 6aa7 	vadd.f32	s13, s13, s15
    d->inc = 1.0f + (diff - d->delay) / d->delay; //* SMOOTH_FACTOR;
 802314c:	edc4 7a08 	vstr	s15, [r4, #32]
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
 8023150:	eef4 6ac7 	vcmpe.f32	s13, s14
 8023154:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023158:	da02      	bge.n	8023160 <tTapeDelay_tick+0xe4>
    d->idx += d->inc;
 802315a:	edc4 6a09 	vstr	s13, [r4, #36]	; 0x24
}
 802315e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (d->idx >= d->maxDelay) d->idx = 0.0f;
 8023160:	2300      	movs	r3, #0
 8023162:	6263      	str	r3, [r4, #36]	; 0x24
}
 8023164:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8023166:	bf00      	nop

08023168 <tTapeDelay_setDelay>:
{
 8023168:	b510      	push	{r4, lr}
    _tTapeDelay* d = *dl;
 802316a:	6804      	ldr	r4, [r0, #0]
    d->delay = LEAF_clip(1.f, delay,  d->maxDelay);
 802316c:	eef0 0a40 	vmov.f32	s1, s0
 8023170:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8023174:	edd4 7a06 	vldr	s15, [r4, #24]
 8023178:	eeb8 1a67 	vcvt.f32.u32	s2, s15
 802317c:	f004 fc1c 	bl	80279b8 <LEAF_clip>
 8023180:	ed84 0a07 	vstr	s0, [r4, #28]
}
 8023184:	bd10      	pop	{r4, pc}
 8023186:	bf00      	nop

08023188 <tTapeDelay_tapOut>:

float tTapeDelay_tapOut (tTapeDelay* const dl, float tapDelay)
{
 8023188:	b4f0      	push	{r4, r5, r6, r7}
    _tTapeDelay* d = *dl;
 802318a:	6801      	ldr	r1, [r0, #0]

    float tap = (float) d->inPoint - tapDelay - 1.f;
 802318c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8023190:	edd1 7a05 	vldr	s15, [r1, #20]
 8023194:	698b      	ldr	r3, [r1, #24]
 8023196:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802319a:	ee37 0ac0 	vsub.f32	s0, s15, s0

    // Check for wraparound.
    while ( tap < 0.f )   tap += (float)d->maxDelay;
 802319e:	eeb4 0ac7 	vcmpe.f32	s0, s14
    float tap = (float) d->inPoint - tapDelay - 1.f;
 80231a2:	ee70 7a47 	vsub.f32	s15, s0, s14
    while ( tap < 0.f )   tap += (float)d->maxDelay;
 80231a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80231aa:	d50a      	bpl.n	80231c2 <tTapeDelay_tapOut+0x3a>
 80231ac:	ee07 3a10 	vmov	s14, r3
 80231b0:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 80231b4:	ee77 7a87 	vadd.f32	s15, s15, s14
 80231b8:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80231bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80231c0:	d4f8      	bmi.n	80231b4 <tTapeDelay_tapOut+0x2c>

    int idx =  (int) tap;
 80231c2:	eebd 7ae7 	vcvt.s32.f32	s14, s15

    float alpha = tap - idx;

    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80231c6:	6889      	ldr	r1, [r1, #8]
 80231c8:	1e5d      	subs	r5, r3, #1
    int idx =  (int) tap;
 80231ca:	ee17 2a10 	vmov	r2, s14
    float alpha = tap - idx;
 80231ce:	eeb8 2ac7 	vcvt.f32.s32	s4, s14
                                              d->buff[idx],
                                              d->buff[(idx + 1) % d->maxDelay],
 80231d2:	1c56      	adds	r6, r2, #1
                                              d->buff[(idx + 2) % d->maxDelay],
 80231d4:	1c97      	adds	r7, r2, #2
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80231d6:	4415      	add	r5, r2
 80231d8:	eb01 0282 	add.w	r2, r1, r2, lsl #2
 80231dc:	ee37 2ac2 	vsub.f32	s4, s15, s4
 80231e0:	edd2 0a00 	vldr	s1, [r2]
                                              d->buff[(idx + 1) % d->maxDelay],
 80231e4:	fbb6 f0f3 	udiv	r0, r6, r3
 80231e8:	fb03 6210 	mls	r2, r3, r0, r6
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80231ec:	eb01 0282 	add.w	r2, r1, r2, lsl #2
                                              d->buff[(idx + 2) % d->maxDelay],
 80231f0:	fbb7 f4f3 	udiv	r4, r7, r3
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80231f4:	ed92 1a00 	vldr	s2, [r2]
                                              d->buff[(idx + 2) % d->maxDelay],
 80231f8:	fb03 7414 	mls	r4, r3, r4, r7
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 80231fc:	fbb5 f2f3 	udiv	r2, r5, r3
 8023200:	fb03 5312 	mls	r3, r3, r2, r5
 8023204:	eb01 0084 	add.w	r0, r1, r4, lsl #2
 8023208:	eb01 0183 	add.w	r1, r1, r3, lsl #2
 802320c:	edd0 1a00 	vldr	s3, [r0]
 8023210:	ed91 0a00 	vldr	s0, [r1]
                                              alpha);

    return samp;

}
 8023214:	bcf0      	pop	{r4, r5, r6, r7}
    float samp =    LEAF_interpolate_hermite_x (d->buff[((idx - 1) + d->maxDelay) % d->maxDelay],
 8023216:	f004 bcef 	b.w	8027bf8 <LEAF_interpolate_hermite_x>
 802321a:	bf00      	nop

0802321c <tOversampler_initToPool>:
{
    tOversampler_initToPool(osr, ratio, extraQuality, &leaf.mempool);
}

void tOversampler_initToPool (tOversampler* const osr, int ratio, int extraQuality, tMempool* const mp)
{
 802321c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
 8023220:	681e      	ldr	r6, [r3, #0]
{
 8023222:	4690      	mov	r8, r2
 8023224:	460d      	mov	r5, r1
 8023226:	4607      	mov	r7, r0
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 8023228:	4631      	mov	r1, r6
 802322a:	201c      	movs	r0, #28
 802322c:	f004 fdde 	bl	8027dec <mpool_alloc>
    os->mempool = m;
    
    uint8_t offset = 0;
    if (extraQuality) offset = 6;
 8023230:	f1b8 0f00 	cmp.w	r8, #0
    if (ratio == 2 || ratio == 4  ||
 8023234:	f1a5 0102 	sub.w	r1, r5, #2
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 8023238:	6038      	str	r0, [r7, #0]
    if (extraQuality) offset = 6;
 802323a:	bf14      	ite	ne
 802323c:	f04f 0805 	movne.w	r8, #5
 8023240:	f04f 38ff 	moveq.w	r8, #4294967295	; 0xffffffff
    if (ratio == 2 || ratio == 4  ||
 8023244:	291e      	cmp	r1, #30
    _tOversampler* os = *osr = (_tOversampler*) mpool_alloc(sizeof(_tOversampler), m);
 8023246:	4604      	mov	r4, r0
    os->mempool = m;
 8023248:	6006      	str	r6, [r0, #0]
    if (ratio == 2 || ratio == 4  ||
 802324a:	d932      	bls.n	80232b2 <tOversampler_initToPool+0x96>
        ratio == 8 || ratio == 16 ||
        ratio == 32 || ratio == 64) {
 802324c:	2d40      	cmp	r5, #64	; 0x40
 802324e:	d12e      	bne.n	80232ae <tOversampler_initToPool+0x92>
        os->ratio = ratio;
        int idx = (int)(log2f(os->ratio))-1+offset;
 8023250:	ee07 5a90 	vmov	s15, r5
        os->ratio = ratio;
 8023254:	6065      	str	r5, [r4, #4]
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
        os->phaseLength = os->numTaps / os->ratio;
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
 8023256:	f240 37b4 	movw	r7, #948	; 0x3b4
        int idx = (int)(log2f(os->ratio))-1+offset;
 802325a:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 802325e:	f007 ff9b 	bl	802b198 <log2f>
 8023262:	eebd 0ac0 	vcvt.s32.f32	s0, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
 8023266:	f64f 03fc 	movw	r3, #63740	; 0xf8fc
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
 802326a:	f2c2 0700 	movt	r7, #8192	; 0x2000
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 802326e:	4631      	mov	r1, r6
        int idx = (int)(log2f(os->ratio))-1+offset;
 8023270:	ee10 2a10 	vmov	r2, s0
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
 8023274:	f6c0 0304 	movt	r3, #2052	; 0x804
        int idx = (int)(log2f(os->ratio))-1+offset;
 8023278:	4442      	add	r2, r8
        os->numTaps = __leaf_tablesize_firNumTaps[idx];
 802327a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 802327e:	edd3 7a00 	vldr	s15, [r3]
 8023282:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8023286:	ee17 0a90 	vmov	r0, s15
 802328a:	edc4 7a05 	vstr	s15, [r4, #20]
        os->phaseLength = os->numTaps / os->ratio;
 802328e:	fb90 f5f5 	sdiv	r5, r0, r5
 8023292:	61a5      	str	r5, [r4, #24]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 8023294:	00c0      	lsls	r0, r0, #3
        os->pCoeffs = (float*) __leaf_tableref_firCoeffs[idx];
 8023296:	f857 3022 	ldr.w	r3, [r7, r2, lsl #2]
 802329a:	60a3      	str	r3, [r4, #8]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 802329c:	f004 fda6 	bl	8027dec <mpool_alloc>
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 80232a0:	6963      	ldr	r3, [r4, #20]
        os->upState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 80232a2:	60e0      	str	r0, [r4, #12]
        os->downState = (float*) mpool_alloc(sizeof(float) * os->numTaps * 2, m);
 80232a4:	4631      	mov	r1, r6
 80232a6:	00d8      	lsls	r0, r3, #3
 80232a8:	f004 fda0 	bl	8027dec <mpool_alloc>
 80232ac:	6120      	str	r0, [r4, #16]
    }
}
 80232ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (ratio == 2 || ratio == 4  ||
 80232b2:	f244 0345 	movw	r3, #16453	; 0x4045
 80232b6:	f2c4 0300 	movt	r3, #16384	; 0x4000
 80232ba:	40cb      	lsrs	r3, r1
 80232bc:	07db      	lsls	r3, r3, #31
 80232be:	d4c7      	bmi.n	8023250 <tOversampler_initToPool+0x34>
 80232c0:	e7c4      	b.n	802324c <tOversampler_initToPool+0x30>
 80232c2:	bf00      	nop

080232c4 <tOversampler_free>:

void tOversampler_free (tOversampler* const osr)
{
 80232c4:	b510      	push	{r4, lr}
    _tOversampler* os = *osr;
 80232c6:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)os->upState, os->mempool);
 80232c8:	6821      	ldr	r1, [r4, #0]
 80232ca:	68e0      	ldr	r0, [r4, #12]
 80232cc:	f004 fe38 	bl	8027f40 <mpool_free>
    mpool_free((char*)os->downState, os->mempool);
 80232d0:	6821      	ldr	r1, [r4, #0]
 80232d2:	6920      	ldr	r0, [r4, #16]
 80232d4:	f004 fe34 	bl	8027f40 <mpool_free>
    mpool_free((char*)os, os->mempool);
 80232d8:	6821      	ldr	r1, [r4, #0]
 80232da:	4620      	mov	r0, r4
}
 80232dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)os, os->mempool);
 80232e0:	f004 be2e 	b.w	8027f40 <mpool_free>

080232e4 <tOversampler_tick>:

float tOversampler_tick(tOversampler* const osr, float input, float* oversample, float (*effectTick)(float))
{
 80232e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tOversampler* os = *osr;
 80232e8:	f8d0 9000 	ldr.w	r9, [r0]
{
 80232ec:	b083      	sub	sp, #12
 80232ee:	468a      	mov	sl, r1
 80232f0:	4690      	mov	r8, r2
// From CMSIS DSP Library
void tOversampler_upsample(tOversampler* const osr, float input, float* output)
{
    _tOversampler* os = *osr;
    
    float *pState = os->upState;                 /* State pointer */
 80232f2:	f8d9 c00c 	ldr.w	ip, [r9, #12]
    float *pStateCur;
    float *ptr1;                               /* Temporary pointer for state buffer */
    float *ptr2;                               /* Temporary pointer for coefficient buffer */
    float sum0;                                /* Accumulators */
    uint32_t i, tapCnt;                    /* Loop counters */
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
 80232f6:	f8d9 6018 	ldr.w	r6, [r9, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
 80232fa:	f8d9 e008 	ldr.w	lr, [r9, #8]
    /* os->pState buffer contains previous frame (phaseLen - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->upState + (phaseLen - 1U);
    
    /* Copy new input sample into the state buffer */
    *pStateCur = input;
 80232fe:	eb0c 0386 	add.w	r3, ip, r6, lsl #2
{
 8023302:	9001      	str	r0, [sp, #4]
    *pStateCur = input;
 8023304:	ed03 0a01 	vstr	s0, [r3, #-4]
    
    /* Address modifier index of coefficient buffer */
    j = 1U;
    
    /* Loop over the Interpolation factor. */
    i = os->ratio;
 8023308:	f8d9 5004 	ldr.w	r5, [r9, #4]
    
    while (i > 0U)
 802330c:	b33d      	cbz	r5, 802335e <tOversampler_tick+0x7a>
         Repeat until we've computed numTaps-(4*os->L) coefficients. */
        
        /* Initialize tapCnt with number of samples */
        tapCnt = phaseLen;
        
        while (tapCnt > 0U)
 802330e:	2300      	movs	r3, #0
 8023310:	f105 0b01 	add.w	fp, r5, #1
    j = 1U;
 8023314:	2701      	movs	r7, #1
        while (tapCnt > 0U)
 8023316:	ee05 3a90 	vmov	s11, r3
        ptr2 = pCoeffs + (os->ratio - j);
 802331a:	1beb      	subs	r3, r5, r7
 802331c:	ee07 5a90 	vmov	s15, r5
 8023320:	eb0e 0383 	add.w	r3, lr, r3, lsl #2
 8023324:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
        while (tapCnt > 0U)
 8023328:	2e00      	cmp	r6, #0
 802332a:	d067      	beq.n	80233fc <tOversampler_tick+0x118>
        sum0 = 0.0f;
 802332c:	2000      	movs	r0, #0
            sum0 += *ptr1++ * *ptr2;
            
            /* Upsampling is done by stuffing L-1 zeros between each sample.
             * So instead of multiplying zeros with coefficients,
             * Increment the coefficient pointer by interpolation factor times. */
            ptr2 += os->ratio;
 802332e:	00ad      	lsls	r5, r5, #2
 8023330:	4632      	mov	r2, r6
        ptr1 = pState;
 8023332:	4664      	mov	r4, ip
        sum0 = 0.0f;
 8023334:	ee07 0a90 	vmov	s15, r0
            sum0 += *ptr1++ * *ptr2;
 8023338:	edd3 6a00 	vldr	s13, [r3]
        while (tapCnt > 0U)
 802333c:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
 802333e:	ecb4 6a01 	vldmia	r4!, {s12}
            ptr2 += os->ratio;
 8023342:	442b      	add	r3, r5
            sum0 += *ptr1++ * *ptr2;
 8023344:	eee6 7a26 	vfma.f32	s15, s12, s13
        while (tapCnt > 0U)
 8023348:	d1f6      	bne.n	8023338 <tOversampler_tick+0x54>
 802334a:	ee67 7a87 	vmul.f32	s15, s15, s14
        
        /* The result is in the accumulator, store in the destination buffer. */
        *output++ = sum0 * os->ratio;
        
        /* Increment the address modifier index of coefficient buffer */
        j++;
 802334e:	3701      	adds	r7, #1
        *output++ = sum0 * os->ratio;
 8023350:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
 8023354:	455f      	cmp	r7, fp
 8023356:	d002      	beq.n	802335e <tOversampler_tick+0x7a>
 8023358:	f8d9 5004 	ldr.w	r5, [r9, #4]
 802335c:	e7dd      	b.n	802331a <tOversampler_tick+0x36>
    
    /* Initialize tapCnt with number of samples */
    tapCnt = (phaseLen - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
 802335e:	3e01      	subs	r6, #1
    pState = pState + 1;
 8023360:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
 8023364:	f8d9 300c 	ldr.w	r3, [r9, #12]
    while (tapCnt > 0U)
 8023368:	d005      	beq.n	8023376 <tOversampler_tick+0x92>
    {
        *pStateCur++ = *pState++;
 802336a:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
 802336e:	3e01      	subs	r6, #1
        *pStateCur++ = *pState++;
 8023370:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
 8023374:	d1f9      	bne.n	802336a <tOversampler_tick+0x86>
    for (int i = 0; i < os->ratio; ++i) {
 8023376:	f8d9 3004 	ldr.w	r3, [r9, #4]
 802337a:	2b00      	cmp	r3, #0
 802337c:	dd0c      	ble.n	8023398 <tOversampler_tick+0xb4>
 802337e:	4655      	mov	r5, sl
 8023380:	2400      	movs	r4, #0
 8023382:	4646      	mov	r6, r8
        oversample[i] = effectTick(oversample[i]);
 8023384:	ed95 0a00 	vldr	s0, [r5]
    for (int i = 0; i < os->ratio; ++i) {
 8023388:	3401      	adds	r4, #1
        oversample[i] = effectTick(oversample[i]);
 802338a:	47b0      	blx	r6
 802338c:	eca5 0a01 	vstmia	r5!, {s0}
    for (int i = 0; i < os->ratio; ++i) {
 8023390:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8023394:	42a3      	cmp	r3, r4
 8023396:	dcf5      	bgt.n	8023384 <tOversampler_tick+0xa0>
}

// From CMSIS DSP Library
float tOversampler_downsample(tOversampler *const osr, float* input)
{
    _tOversampler* os = *osr;
 8023398:	9b01      	ldr	r3, [sp, #4]
    uint32_t i, tapCnt;
    float output;
    
    /* os->pState buffer contains previous frame (numTaps - 1) samples */
    /* pStateCur points to the location where the new input data should be written */
    pStateCur = os->downState + (numTaps - 1U);
 802339a:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tOversampler* os = *osr;
 802339e:	681d      	ldr	r5, [r3, #0]
    pStateCur = os->downState + (numTaps - 1U);
 80233a0:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
    uint32_t numTaps = os->numTaps;                 /* Number of filter coefficients in the filter */
 80233a4:	696f      	ldr	r7, [r5, #20]
    float *pState = os->downState;                 /* State pointer */
 80233a6:	692c      	ldr	r4, [r5, #16]
    pStateCur = os->downState + (numTaps - 1U);
 80233a8:	443a      	add	r2, r7
    
    /* Copy decimation factor number of new input samples into the state buffer */
    i = os->ratio;
 80233aa:	e9d5 3601 	ldrd	r3, r6, [r5, #4]
    pStateCur = os->downState + (numTaps - 1U);
 80233ae:	eb04 0282 	add.w	r2, r4, r2, lsl #2
    
    do
    {
        *pStateCur++ = *input++;
 80233b2:	f85a 1b04 	ldr.w	r1, [sl], #4
        
    } while (--i);
 80233b6:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
 80233b8:	f842 1b04 	str.w	r1, [r2], #4
    } while (--i);
 80233bc:	d1f9      	bne.n	80233b2 <tOversampler_tick+0xce>
 80233be:	6868      	ldr	r0, [r5, #4]
 80233c0:	1e7b      	subs	r3, r7, #1
 80233c2:	692d      	ldr	r5, [r5, #16]
 80233c4:	461a      	mov	r2, r3
 80233c6:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    pb = pCoeffs;
    
    /* Initialize tapCnt with number of taps */
    tapCnt = numTaps;
    
    while (tapCnt > 0U)
 80233ca:	b1d7      	cbz	r7, 8023402 <tOversampler_tick+0x11e>
    acc0 = 0.0f;
 80233cc:	2100      	movs	r1, #0
 80233ce:	ee00 1a10 	vmov	s0, r1
 80233d2:	e000      	b.n	80233d6 <tOversampler_tick+0xf2>
 80233d4:	3a01      	subs	r2, #1
        
        /* Fetch 1 state variable */
        x0 = *px0++;
        
        /* Perform the multiply-accumulate */
        acc0 += x0 * c0;
 80233d6:	ecb6 7a01 	vldmia	r6!, {s14}
 80233da:	ecf4 7a01 	vldmia	r4!, {s15}
 80233de:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
 80233e2:	2a00      	cmp	r2, #0
 80233e4:	d1f6      	bne.n	80233d4 <tOversampler_tick+0xf0>
    
    /* Initialize tapCnt with number of taps */
    tapCnt = (numTaps - 1U);
    
    /* Copy data */
    while (tapCnt > 0U)
 80233e6:	b133      	cbz	r3, 80233f6 <tOversampler_tick+0x112>
 80233e8:	462a      	mov	r2, r5
    {
        *pStateCur++ = *pState++;
 80233ea:	f850 1b04 	ldr.w	r1, [r0], #4
    while (tapCnt > 0U)
 80233ee:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
 80233f0:	f842 1b04 	str.w	r1, [r2], #4
    while (tapCnt > 0U)
 80233f4:	d1f9      	bne.n	80233ea <tOversampler_tick+0x106>
}
 80233f6:	b003      	add	sp, #12
 80233f8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        while (tapCnt > 0U)
 80233fc:	eef0 7a65 	vmov.f32	s15, s11
 8023400:	e7a5      	b.n	802334e <tOversampler_tick+0x6a>
    acc0 = 0.0f;
 8023402:	2200      	movs	r2, #0
 8023404:	ee00 2a10 	vmov	s0, r2
 8023408:	e7ee      	b.n	80233e8 <tOversampler_tick+0x104>
 802340a:	bf00      	nop

0802340c <tOversampler_upsample>:
{
 802340c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tOversampler* os = *osr;
 8023410:	f8d0 e000 	ldr.w	lr, [r0]
    float *pState = os->upState;                 /* State pointer */
 8023414:	f8de c00c 	ldr.w	ip, [lr, #12]
    uint32_t phaseLen = os->phaseLength;            /* Length of each polyphase filter component */
 8023418:	f8de 6018 	ldr.w	r6, [lr, #24]
    float *pCoeffs = os->pCoeffs;               /* Coefficient pointer */
 802341c:	f8de 8008 	ldr.w	r8, [lr, #8]
    *pStateCur = input;
 8023420:	eb0c 0386 	add.w	r3, ip, r6, lsl #2
 8023424:	ed03 0a01 	vstr	s0, [r3, #-4]
    i = os->ratio;
 8023428:	f8de 5004 	ldr.w	r5, [lr, #4]
    while (i > 0U)
 802342c:	b335      	cbz	r5, 802347c <tOversampler_upsample+0x70>
        while (tapCnt > 0U)
 802342e:	2300      	movs	r3, #0
 8023430:	f105 0901 	add.w	r9, r5, #1
    j = 1U;
 8023434:	2701      	movs	r7, #1
        while (tapCnt > 0U)
 8023436:	ee05 3a90 	vmov	s11, r3
        ptr2 = pCoeffs + (os->ratio - j);
 802343a:	1beb      	subs	r3, r5, r7
 802343c:	ee07 5a90 	vmov	s15, r5
 8023440:	eb08 0383 	add.w	r3, r8, r3, lsl #2
 8023444:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
        while (tapCnt > 0U)
 8023448:	b336      	cbz	r6, 8023498 <tOversampler_upsample+0x8c>
        sum0 = 0.0f;
 802344a:	2000      	movs	r0, #0
            ptr2 += os->ratio;
 802344c:	00ad      	lsls	r5, r5, #2
 802344e:	4632      	mov	r2, r6
        ptr1 = pState;
 8023450:	4664      	mov	r4, ip
        sum0 = 0.0f;
 8023452:	ee07 0a90 	vmov	s15, r0
            sum0 += *ptr1++ * *ptr2;
 8023456:	ed93 7a00 	vldr	s14, [r3]
        while (tapCnt > 0U)
 802345a:	3a01      	subs	r2, #1
            sum0 += *ptr1++ * *ptr2;
 802345c:	ecf4 6a01 	vldmia	r4!, {s13}
            ptr2 += os->ratio;
 8023460:	442b      	add	r3, r5
            sum0 += *ptr1++ * *ptr2;
 8023462:	eee6 7a87 	vfma.f32	s15, s13, s14
        while (tapCnt > 0U)
 8023466:	d1f6      	bne.n	8023456 <tOversampler_upsample+0x4a>
 8023468:	ee67 7a86 	vmul.f32	s15, s15, s12
        j++;
 802346c:	3701      	adds	r7, #1
        *output++ = sum0 * os->ratio;
 802346e:	ece1 7a01 	vstmia	r1!, {s15}
    while (i > 0U)
 8023472:	454f      	cmp	r7, r9
 8023474:	d002      	beq.n	802347c <tOversampler_upsample+0x70>
 8023476:	f8de 5004 	ldr.w	r5, [lr, #4]
 802347a:	e7de      	b.n	802343a <tOversampler_upsample+0x2e>
    while (tapCnt > 0U)
 802347c:	3e01      	subs	r6, #1
    pState = pState + 1;
 802347e:	f10c 0c04 	add.w	ip, ip, #4
    pStateCur = os->upState;
 8023482:	f8de 300c 	ldr.w	r3, [lr, #12]
    while (tapCnt > 0U)
 8023486:	d005      	beq.n	8023494 <tOversampler_upsample+0x88>
        *pStateCur++ = *pState++;
 8023488:	f85c 2b04 	ldr.w	r2, [ip], #4
    while (tapCnt > 0U)
 802348c:	3e01      	subs	r6, #1
        *pStateCur++ = *pState++;
 802348e:	f843 2b04 	str.w	r2, [r3], #4
    while (tapCnt > 0U)
 8023492:	d1f9      	bne.n	8023488 <tOversampler_upsample+0x7c>
}
 8023494:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        while (tapCnt > 0U)
 8023498:	eef0 7a65 	vmov.f32	s15, s11
 802349c:	e7e6      	b.n	802346c <tOversampler_upsample+0x60>
 802349e:	bf00      	nop

080234a0 <tOversampler_downsample>:
{
 80234a0:	b4f0      	push	{r4, r5, r6, r7}
    pStateCur = os->downState + (numTaps - 1U);
 80234a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tOversampler* os = *osr;
 80234a6:	6805      	ldr	r5, [r0, #0]
    pStateCur = os->downState + (numTaps - 1U);
 80234a8:	f6c3 72ff 	movt	r2, #16383	; 0x3fff
    uint32_t numTaps = os->numTaps;                 /* Number of filter coefficients in the filter */
 80234ac:	696f      	ldr	r7, [r5, #20]
    float *pState = os->downState;                 /* State pointer */
 80234ae:	692c      	ldr	r4, [r5, #16]
    pStateCur = os->downState + (numTaps - 1U);
 80234b0:	443a      	add	r2, r7
    i = os->ratio;
 80234b2:	e9d5 3601 	ldrd	r3, r6, [r5, #4]
    pStateCur = os->downState + (numTaps - 1U);
 80234b6:	eb04 0282 	add.w	r2, r4, r2, lsl #2
        *pStateCur++ = *input++;
 80234ba:	f851 0b04 	ldr.w	r0, [r1], #4
    } while (--i);
 80234be:	3b01      	subs	r3, #1
        *pStateCur++ = *input++;
 80234c0:	f842 0b04 	str.w	r0, [r2], #4
    } while (--i);
 80234c4:	d1f9      	bne.n	80234ba <tOversampler_downsample+0x1a>
 80234c6:	6868      	ldr	r0, [r5, #4]
 80234c8:	1e7b      	subs	r3, r7, #1
 80234ca:	692d      	ldr	r5, [r5, #16]
 80234cc:	461a      	mov	r2, r3
 80234ce:	eb04 0080 	add.w	r0, r4, r0, lsl #2
    while (tapCnt > 0U)
 80234d2:	b1b7      	cbz	r7, 8023502 <tOversampler_downsample+0x62>
    acc0 = 0.0f;
 80234d4:	2100      	movs	r1, #0
 80234d6:	ee00 1a10 	vmov	s0, r1
 80234da:	e000      	b.n	80234de <tOversampler_downsample+0x3e>
 80234dc:	3a01      	subs	r2, #1
        acc0 += x0 * c0;
 80234de:	ecb6 7a01 	vldmia	r6!, {s14}
 80234e2:	ecf4 7a01 	vldmia	r4!, {s15}
 80234e6:	eea7 0a27 	vfma.f32	s0, s14, s15
    while (tapCnt > 0U)
 80234ea:	2a00      	cmp	r2, #0
 80234ec:	d1f6      	bne.n	80234dc <tOversampler_downsample+0x3c>
    while (tapCnt > 0U)
 80234ee:	b133      	cbz	r3, 80234fe <tOversampler_downsample+0x5e>
 80234f0:	462a      	mov	r2, r5
        *pStateCur++ = *pState++;
 80234f2:	f850 1b04 	ldr.w	r1, [r0], #4
    while (tapCnt > 0U)
 80234f6:	3b01      	subs	r3, #1
        *pStateCur++ = *pState++;
 80234f8:	f842 1b04 	str.w	r1, [r2], #4
    while (tapCnt > 0U)
 80234fc:	d1f9      	bne.n	80234f2 <tOversampler_downsample+0x52>
        /* Decrement loop counter */
        tapCnt--;
    }
    
    return output;
}
 80234fe:	bcf0      	pop	{r4, r5, r6, r7}
 8023500:	4770      	bx	lr
    acc0 = 0.0f;
 8023502:	2200      	movs	r2, #0
 8023504:	ee00 2a10 	vmov	s0, r2
 8023508:	e7f2      	b.n	80234f0 <tOversampler_downsample+0x50>
 802350a:	bf00      	nop

0802350c <tLockhartWavefolder_initToPool>:
{
	tLockhartWavefolder_initToPool   (wf,  &leaf.mempool);
}

void tLockhartWavefolder_initToPool (tLockhartWavefolder* const wf, tMempool* const mp)
{
 802350c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    w->R = 15e3;
    w->VT = 26e-3;
    w->Is = 10e-16;
    
    w->a = 2.0*w->RL/w->R;
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 8023510:	f241 34b1 	movw	r4, #5041	; 0x13b1
{
 8023514:	b08f      	sub	sp, #60	; 0x3c
    w->half_a = 0.5 * w->a;
    w->longthing = (0.5*w->VT/w->b);
    
    
    // Antialiasing error threshold
    w->AAthresh = 10e-10; //10
 8023516:	f24d 6295 	movw	r2, #54933	; 0xd695
 802351a:	f642 630b 	movw	r3, #11787	; 0x2e0b
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 802351e:	f2cb 143b 	movt	r4, #45371	; 0xb13b
    _tMempool* m = *mp;
 8023522:	6809      	ldr	r1, [r1, #0]
    w->AAthresh = 10e-10; //10
 8023524:	f6ce 0226 	movt	r2, #59430	; 0xe826
 8023528:	f6c3 6311 	movt	r3, #15889	; 0x3e11
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 802352c:	9400      	str	r4, [sp, #0]
    w->longthing = (0.5*w->VT/w->b);
 802352e:	f243 34a4 	movw	r4, #13220	; 0x33a4
{
 8023532:	900a      	str	r0, [sp, #40]	; 0x28
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 8023534:	20e0      	movs	r0, #224	; 0xe0
    w->longthing = (0.5*w->VT/w->b);
 8023536:	f2cf 2430 	movt	r4, #62000	; 0xf230
    _tMempool* m = *mp;
 802353a:	460d      	mov	r5, r1
    w->Is = 10e-16;
 802353c:	f245 6616 	movw	r6, #22038	; 0x5616
 8023540:	f240 37af 	movw	r7, #943	; 0x3af
    w->longthing = (0.5*w->VT/w->b);
 8023544:	9402      	str	r4, [sp, #8]
    w->RL = 7.5e3;
 8023546:	2400      	movs	r4, #0
    w->Is = 10e-16;
 8023548:	f6c9 66e7 	movt	r6, #40679	; 0x9ee7
 802354c:	f6c3 47d2 	movt	r7, #15570	; 0x3cd2
    w->RL = 7.5e3;
 8023550:	9404      	str	r4, [sp, #16]
    w->VT = 26e-3;
 8023552:	f24b 4a39 	movw	sl, #46137	; 0xb439
    w->R = 15e3;
 8023556:	9406      	str	r4, [sp, #24]
    w->Ln1 = 0.0;
 8023558:	2400      	movs	r4, #0
    w->d = (w->RL*w->Is)/w->VT;
 802355a:	f64b 4884 	movw	r8, #48260	; 0xbc84
    w->VT = 26e-3;
 802355e:	f649 7bbe 	movw	fp, #40894	; 0x9fbe
    w->Ln1 = 0.0;
 8023562:	9408      	str	r4, [sp, #32]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 8023564:	f643 3413 	movw	r4, #15123	; 0x3b13
    w->d = (w->RL*w->Is)/w->VT;
 8023568:	f24d 29ab 	movw	r9, #53931	; 0xd2ab
    w->VT = 26e-3;
 802356c:	f2c7 6ac8 	movt	sl, #30408	; 0x76c8
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 8023570:	f2c4 0453 	movt	r4, #16467	; 0x4053
    w->d = (w->RL*w->Is)/w->VT;
 8023574:	f2c4 68f1 	movt	r8, #18161	; 0x46f1
    w->VT = 26e-3;
 8023578:	f6c3 7b9a 	movt	fp, #16282	; 0x3f9a
    w->d = (w->RL*w->Is)/w->VT;
 802357c:	f6c3 59f3 	movt	r9, #15859	; 0x3df3
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 8023580:	9401      	str	r4, [sp, #4]
    w->longthing = (0.5*w->VT/w->b);
 8023582:	f242 64b2 	movw	r4, #9906	; 0x26b2
    w->AAthresh = 10e-10; //10
 8023586:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
    w->RL = 7.5e3;
 802358a:	f44f 4398 	mov.w	r3, #19456	; 0x4c00
    w->longthing = (0.5*w->VT/w->b);
 802358e:	f6c3 7426 	movt	r4, #16166	; 0x3f26
    w->RL = 7.5e3;
 8023592:	f2c4 03bd 	movt	r3, #16573	; 0x40bd
    w->longthing = (0.5*w->VT/w->b);
 8023596:	9403      	str	r4, [sp, #12]
    w->RL = 7.5e3;
 8023598:	9305      	str	r3, [sp, #20]
    w->R = 15e3;
 802359a:	f44f 4398 	mov.w	r3, #19456	; 0x4c00
 802359e:	f2c4 03cd 	movt	r3, #16589	; 0x40cd
 80235a2:	9307      	str	r3, [sp, #28]
    w->Ln1 = 0.0;
 80235a4:	2300      	movs	r3, #0
 80235a6:	9309      	str	r3, [sp, #36]	; 0x24
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 80235a8:	f004 fc20 	bl	8027dec <mpool_alloc>
 80235ac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80235ae:	4684      	mov	ip, r0
    w->a = 2.0*w->RL/w->R;
 80235b0:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
    w->Is = 10e-16;
 80235b4:	4639      	mov	r1, r7
    _tLockhartWavefolder* w = *wf = (_tLockhartWavefolder*) mpool_alloc(sizeof(_tLockhartWavefolder), m);
 80235b6:	6018      	str	r0, [r3, #0]
    w->half_a = 0.5 * w->a;
 80235b8:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
    w->mempool = m;
 80235bc:	f8cc 5000 	str.w	r5, [ip]
    w->Is = 10e-16;
 80235c0:	4630      	mov	r0, r6
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 80235c2:	ed9d 5b00 	vldr	d5, [sp]
    w->AAthresh = 10e-10; //10
 80235c6:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    w->R = 15e3;
 80235ca:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 80235ce:	ed8d 5b0a 	vstr	d5, [sp, #40]	; 0x28
    w->RL = 7.5e3;
 80235d2:	ed9d 5b04 	vldr	d5, [sp, #16]
    w->AAthresh = 10e-10; //10
 80235d6:	4614      	mov	r4, r2
 80235d8:	461d      	mov	r5, r3
    w->RL = 7.5e3;
 80235da:	ed8d 5b00 	vstr	d5, [sp]
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 80235de:	ed9d 5b0a 	vldr	d5, [sp, #40]	; 0x28
    w->Ln1 = 0.0;
 80235e2:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
    w->VT = 26e-3;
 80235e6:	e9cc ab0c 	strd	sl, fp, [ip, #48]	; 0x30
    w->b = (w->R+2.0*w->RL)/(w->VT*w->R);
 80235ea:	ed8c 5b12 	vstr	d5, [ip, #72]	; 0x48
    w->longthing = (0.5*w->VT/w->b);
 80235ee:	ed9d 5b02 	vldr	d5, [sp, #8]
    w->Is = 10e-16;
 80235f2:	e9cc 010e 	strd	r0, r1, [ip, #56]	; 0x38
    w->d = (w->RL*w->Is)/w->VT;
 80235f6:	e9cc 8914 	strd	r8, r9, [ip, #80]	; 0x50
    w->longthing = (0.5*w->VT/w->b);
 80235fa:	ed8c 5b1a 	vstr	d5, [ip, #104]	; 0x68
    w->RL = 7.5e3;
 80235fe:	ed9d 5b00 	vldr	d5, [sp]
    w->AAthresh = 10e-10; //10
 8023602:	e9cc 4516 	strd	r4, r5, [ip, #88]	; 0x58

	w->LambertThresh = 10e-10; //12  //was 8
 8023606:	e9cc 451c 	strd	r4, r5, [ip, #112]	; 0x70
    w->RL = 7.5e3;
 802360a:	ed8c 5b08 	vstr	d5, [ip, #32]
    w->R = 15e3;
 802360e:	e9cc 670a 	strd	r6, r7, [ip, #40]	; 0x28
    w->Ln1 = 0.0;
 8023612:	e9cc 2302 	strd	r2, r3, [ip, #8]
    w->Fn1 = 0.0;
 8023616:	e9cc 2304 	strd	r2, r3, [ip, #16]
    w->xn1 = 0.0;
 802361a:	e9cc 2306 	strd	r2, r3, [ip, #24]


    w->w = 0.0f;
 802361e:	e9cc 231e 	strd	r2, r3, [ip, #120]	; 0x78
    w->expw = 0.0f;
 8023622:	e9cc 2320 	strd	r2, r3, [ip, #128]	; 0x80
    w->p = 0.0f;
 8023626:	e9cc 2322 	strd	r2, r3, [ip, #136]	; 0x88
    w->r = 0.0f;
 802362a:	e9cc 2324 	strd	r2, r3, [ip, #144]	; 0x90
    w->s= 0.0f;
 802362e:	e9cc 2326 	strd	r2, r3, [ip, #152]	; 0x98
    w->myerr = 0.0f;
 8023632:	e9cc 2328 	strd	r2, r3, [ip, #160]	; 0xa0
    w->l = 0.0f;
 8023636:	e9cc 232a 	strd	r2, r3, [ip, #168]	; 0xa8
    w->u = 0.0f;
 802363a:	e9cc 232c 	strd	r2, r3, [ip, #176]	; 0xb0
    w->Ln = 0.0f;
 802363e:	e9cc 232e 	strd	r2, r3, [ip, #184]	; 0xb8
	w->Fn = 0.0f;
 8023642:	e9cc 2330 	strd	r2, r3, [ip, #192]	; 0xc0
    w->tempsDenom = 0.0f;
 8023646:	e9cc 2332 	strd	r2, r3, [ip, #200]	; 0xc8
    w->tempErrDenom = 0.0f;
 802364a:	e9cc 2334 	strd	r2, r3, [ip, #208]	; 0xd0
    w->tempOutDenom = 0.0f;
 802364e:	e9cc 2336 	strd	r2, r3, [ip, #216]	; 0xd8
    w->a = 2.0*w->RL/w->R;
 8023652:	ed8c 6b10 	vstr	d6, [ip, #64]	; 0x40
    w->half_a = 0.5 * w->a;
 8023656:	ed8c 7b18 	vstr	d7, [ip, #96]	; 0x60


}
 802365a:	b00f      	add	sp, #60	; 0x3c
 802365c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08023660 <tLockhartWavefolder_free>:

void tLockhartWavefolder_free (tLockhartWavefolder* const wf)
{
    _tLockhartWavefolder* w = *wf;
 8023660:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)w, w->mempool);
 8023662:	6801      	ldr	r1, [r0, #0]
 8023664:	f004 bc6c 	b.w	8027f40 <mpool_free>

08023668 <tLockhartWavefolder_tick>:
    _tLockhartWavefolder* w = *wf;

    float out = 0.0f;
    
    // Compute Antiderivative
    w->l = (in > 0.0) - (in < 0.0);
 8023668:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
 802366c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    w->l = (in > 0.0) - (in < 0.0);
 802366e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    _tLockhartWavefolder* w = *wf;
 8023672:	6806      	ldr	r6, [r0, #0]
{
 8023674:	4607      	mov	r7, r0
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 8023676:	f640 34b8 	movw	r4, #3000	; 0xbb8
{
 802367a:	ed2d 8b0e 	vpush	{d8-d14}
    w->l = (in > 0.0) - (in < 0.0);
 802367e:	bfc8      	it	gt
 8023680:	2301      	movgt	r3, #1
    w->u = w->d*exp(w->l*w->b*in);
 8023682:	eeb7 eac0 	vcvt.f64.f32	d14, s0
    w->l = (in > 0.0) - (in < 0.0);
 8023686:	bfd8      	it	le
 8023688:	2300      	movle	r3, #0
 802368a:	bf4c      	ite	mi
 802368c:	2201      	movmi	r2, #1
 802368e:	2200      	movpl	r2, #0
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 8023690:	eeb7 bb00 	vmov.f64	d11, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 8023694:	eeb0 9b00 	vmov.f64	d9, #0	; 0x40000000  2.0
    w->l = (in > 0.0) - (in < 0.0);
 8023698:	1a9b      	subs	r3, r3, r2
    w->u = w->d*exp(w->l*w->b*in);
 802369a:	ed96 0b12 	vldr	d0, [r6, #72]	; 0x48
    w->l = (in > 0.0) - (in < 0.0);
 802369e:	ee07 3a90 	vmov	s15, r3
    w->u = w->d*exp(w->l*w->b*in);
 80236a2:	ee2e 0b00 	vmul.f64	d0, d14, d0
    w->l = (in > 0.0) - (in < 0.0);
 80236a6:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 80236aa:	ed86 7b2a 	vstr	d7, [r6, #168]	; 0xa8
    w->u = w->d*exp(w->l*w->b*in);
 80236ae:	ee20 0b07 	vmul.f64	d0, d0, d7
 80236b2:	f007 ffa9 	bl	802b608 <exp>
 80236b6:	ed96 cb14 	vldr	d12, [r6, #80]	; 0x50
    	w->u = 10e-5;
    	LEAF_error();
    }
    */

    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 80236ba:	ed96 8b02 	vldr	d8, [r6, #8]
    w->u = w->d*exp(w->l*w->b*in);
 80236be:	ee20 cb0c 	vmul.f64	d12, d0, d12
 80236c2:	ed86 cb2c 	vstr	d12, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
 80236c6:	683d      	ldr	r5, [r7, #0]
 80236c8:	eeb1 cb4c 	vneg.f64	d12, d12
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 80236cc:	ed95 db1c 	vldr	d13, [r5, #112]	; 0x70
	mwf->w = ln;
 80236d0:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
 80236d4:	e006      	b.n	80236e4 <tLockhartWavefolder_tick+0x7c>
        mwf->w = mwf->w - mwf->myerr;
 80236d6:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
 80236da:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
 80236dc:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
 80236e0:	f000 80c9 	beq.w	8023876 <tLockhartWavefolder_tick+0x20e>
    	mwf->expw = exp(mwf->w);
 80236e4:	eeb0 0b48 	vmov.f64	d0, d8
 80236e8:	f007 ff8e 	bl	802b608 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 80236ec:	ee38 7b0b 	vadd.f64	d7, d8, d11
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 80236f0:	ee38 4b09 	vadd.f64	d4, d8, d9
    	mwf->p = mwf->w*mwf->expw - x;
 80236f4:	eeb0 6b4c 	vmov.f64	d6, d12
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
 80236f8:	ee37 1b07 	vadd.f64	d1, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 80236fc:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 8023700:	ee84 2b01 	vdiv.f64	d2, d4, d1
    	mwf->p = mwf->w*mwf->expw - x;
 8023704:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
 8023708:	eeb0 3b47 	vmov.f64	d3, d7
 802370c:	eea6 3b42 	vfms.f64	d3, d6, d2
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
 8023710:	ee86 5b03 	vdiv.f64	d5, d6, d3
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 8023714:	eeb0 abc5 	vabs.f64	d10, d5
 8023718:	eeb4 abcd 	vcmpe.f64	d10, d13
 802371c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023720:	d5d9      	bpl.n	80236d6 <tLockhartWavefolder_tick+0x6e>
 8023722:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 8023726:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 802372a:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 802372e:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
 8023732:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
 8023736:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
 802373a:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
	{
		w->Ln = 10e-5;
		LEAF_error();
	}
*/
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 802373e:	ee2e 5b0e 	vmul.f64	d5, d14, d14
 8023742:	ee24 4b08 	vmul.f64	d4, d4, d8
 8023746:	ed96 7b18 	vldr	d7, [r6, #96]	; 0x60
		LEAF_error();
	}
	*/
    // Check for ill-conditioning

    if (fabs(in-w->xn1)<w->AAthresh)
 802374a:	ed96 db06 	vldr	d13, [r6, #24]
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 802374e:	ed96 6b1a 	vldr	d6, [r6, #104]	; 0x68
 8023752:	ee27 5b45 	vnmul.f64	d5, d7, d5
    if (fabs(in-w->xn1)<w->AAthresh)
 8023756:	ee3e 3b4d 	vsub.f64	d3, d14, d13
 802375a:	ed96 7b16 	vldr	d7, [r6, #88]	; 0x58
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 802375e:	eea6 5b04 	vfma.f64	d5, d6, d4
    if (fabs(in-w->xn1)<w->AAthresh)
 8023762:	eeb0 6bc3 	vabs.f64	d6, d3
    w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 8023766:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
    if (fabs(in-w->xn1)<w->AAthresh)
 802376a:	eeb4 6bc7 	vcmpe.f64	d6, d7
 802376e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->Fn = (w->longthing*(w->Ln*(w->Ln + 2.0))) - (w->half_a*in*in);
 8023772:	ed86 5b30 	vstr	d5, [r6, #192]	; 0xc0
    if (fabs(in-w->xn1)<w->AAthresh)
 8023776:	d412      	bmi.n	802379e <tLockhartWavefolder_tick+0x136>
    	{
    		w->tempOutDenom = 10e-5;
    		LEAF_error();
    	}
    	*/
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
 8023778:	ed96 7b04 	vldr	d7, [r6, #16]
    	w->tempOutDenom = (in-w->xn1);
 802377c:	ed86 3b36 	vstr	d3, [r6, #216]	; 0xd8
        out = ((w->Fn-w->Fn1)/w->tempOutDenom);
 8023780:	ee35 7b47 	vsub.f64	d7, d5, d7
 8023784:	ee87 0b03 	vdiv.f64	d0, d7, d3
 8023788:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
		*/

    }

    // Update States
    w->Ln1 = w->Ln;
 802378c:	ed86 8b02 	vstr	d8, [r6, #8]
    w->Fn1 = w->Fn;
 8023790:	ed86 5b04 	vstr	d5, [r6, #16]
    w->xn1 = (double)in;
 8023794:	ed86 eb06 	vstr	d14, [r6, #24]
    
    return out;
}
 8023798:	ecbd 8b0e 	vpop	{d8-d14}
 802379c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    	double xn = 0.5*(in+w->xn1);
 802379e:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 80237a2:	f640 34b8 	movw	r4, #3000	; 0xbb8
    	double xn = 0.5*(in+w->xn1);
 80237a6:	ee3e db0d 	vadd.f64	d13, d14, d13
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 80237aa:	eeb7 9b00 	vmov.f64	d9, #112	; 0x3f800000  1.0
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 80237ae:	eeb0 ab00 	vmov.f64	d10, #0	; 0x40000000  2.0
    	double xn = 0.5*(in+w->xn1);
 80237b2:	ee2d db07 	vmul.f64	d13, d13, d7
    	w->u = w->d*exp(w->l*w->b*xn);
 80237b6:	ed96 0b2a 	vldr	d0, [r6, #168]	; 0xa8
 80237ba:	ed96 7b12 	vldr	d7, [r6, #72]	; 0x48
 80237be:	ee20 0b07 	vmul.f64	d0, d0, d7
 80237c2:	ee20 0b0d 	vmul.f64	d0, d0, d13
 80237c6:	f007 ff1f 	bl	802b608 <exp>
 80237ca:	ed96 bb14 	vldr	d11, [r6, #80]	; 0x50
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 80237ce:	ed96 8b02 	vldr	d8, [r6, #8]
    	w->u = w->d*exp(w->l*w->b*xn);
 80237d2:	ee20 bb0b 	vmul.f64	d11, d0, d11
 80237d6:	ed86 bb2c 	vstr	d11, [r6, #176]	; 0xb0
	_tLockhartWavefolder* mwf = *wf;
 80237da:	683d      	ldr	r5, [r7, #0]
 80237dc:	eeb1 bb4b 	vneg.f64	d11, d11
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 80237e0:	ed95 cb1c 	vldr	d12, [r5, #112]	; 0x70
	mwf->w = ln;
 80237e4:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
 80237e8:	e005      	b.n	80237f6 <tLockhartWavefolder_tick+0x18e>
        mwf->w = mwf->w - mwf->myerr;
 80237ea:	ee38 8b45 	vsub.f64	d8, d8, d5
    for(int i=0; i<3000; i+=1) { //1000
 80237ee:	3c01      	subs	r4, #1
        mwf->w = mwf->w - mwf->myerr;
 80237f0:	ed85 8b1e 	vstr	d8, [r5, #120]	; 0x78
    for(int i=0; i<3000; i+=1) { //1000
 80237f4:	d01e      	beq.n	8023834 <tLockhartWavefolder_tick+0x1cc>
    	mwf->expw = exp(mwf->w);
 80237f6:	eeb0 0b48 	vmov.f64	d0, d8
 80237fa:	f007 ff05 	bl	802b608 <exp>
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 80237fe:	ee38 7b09 	vadd.f64	d7, d8, d9
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 8023802:	ee38 5b0a 	vadd.f64	d5, d8, d10
    	mwf->p = mwf->w*mwf->expw - x;
 8023806:	eeb0 6b4b 	vmov.f64	d6, d11
    	mwf->tempsDenom = (2.0*(mwf->w+1.0));
 802380a:	ee37 2b07 	vadd.f64	d2, d7, d7
    	mwf->r = (mwf->w+1.0)*mwf->expw;
 802380e:	ee20 7b07 	vmul.f64	d7, d0, d7
        mwf->s = (mwf->w+2.0)/mwf->tempsDenom;
 8023812:	ee85 3b02 	vdiv.f64	d3, d5, d2
    	mwf->p = mwf->w*mwf->expw - x;
 8023816:	eea0 6b08 	vfma.f64	d6, d0, d8
        mwf->tempErrDenom = (mwf->r-(mwf->p*mwf->s));
 802381a:	eeb0 4b47 	vmov.f64	d4, d7
 802381e:	eea6 4b43 	vfms.f64	d4, d6, d3
        mwf->myerr = (mwf->p/mwf->tempErrDenom);
 8023822:	ee86 5b04 	vdiv.f64	d5, d6, d4
        if ((fabs(mwf->myerr))<mwf->LambertThresh) {
 8023826:	eeb0 1bc5 	vabs.f64	d1, d5
 802382a:	eeb4 1bcc 	vcmpe.f64	d1, d12
 802382e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023832:	d5da      	bpl.n	80237ea <tLockhartWavefolder_tick+0x182>
 8023834:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 8023838:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 802383c:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 8023840:	ed85 2b32 	vstr	d2, [r5, #200]	; 0xc8
 8023844:	ed85 3b26 	vstr	d3, [r5, #152]	; 0x98
 8023848:	ed85 4b34 	vstr	d4, [r5, #208]	; 0xd0
 802384c:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
 8023850:	ed96 5b10 	vldr	d5, [r6, #64]	; 0x40
 8023854:	ed96 7b2a 	vldr	d7, [r6, #168]	; 0xa8
 8023858:	ed96 6b0c 	vldr	d6, [r6, #48]	; 0x30
 802385c:	ee25 db4d 	vnmul.f64	d13, d5, d13
 8023860:	ee27 7b06 	vmul.f64	d7, d7, d6
    	w->Ln = tLockhartWavefolderLambert(wf,w->u,w->Ln1);
 8023864:	ed86 8b2e 	vstr	d8, [r6, #184]	; 0xb8
 8023868:	ed96 5b30 	vldr	d5, [r6, #192]	; 0xc0
        out = (float)((w->l*w->VT*w->Ln) - (w->a*xn));
 802386c:	eea7 db08 	vfma.f64	d13, d7, d8
 8023870:	eeb7 0bcd 	vcvt.f32.f64	s0, d13
 8023874:	e78a      	b.n	802378c <tLockhartWavefolder_tick+0x124>
 8023876:	ed85 0b20 	vstr	d0, [r5, #128]	; 0x80
 802387a:	ed85 6b22 	vstr	d6, [r5, #136]	; 0x88
 802387e:	ed85 7b24 	vstr	d7, [r5, #144]	; 0x90
 8023882:	ed85 1b32 	vstr	d1, [r5, #200]	; 0xc8
 8023886:	ed85 2b26 	vstr	d2, [r5, #152]	; 0x98
 802388a:	ed85 3b34 	vstr	d3, [r5, #208]	; 0xd0
 802388e:	ed85 5b28 	vstr	d5, [r5, #160]	; 0xa0
 8023892:	ee38 4b09 	vadd.f64	d4, d8, d9
 8023896:	e752      	b.n	802373e <tLockhartWavefolder_tick+0xd6>

08023898 <tCrusher_initToPool>:
{
    tCrusher_initToPool(cr, &leaf.mempool);
}

void tCrusher_initToPool (tCrusher* const cr, tMempool* const mp)
{
 8023898:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
 802389a:	680e      	ldr	r6, [r1, #0]
{
 802389c:	460d      	mov	r5, r1
 802389e:	4607      	mov	r7, r0
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 80238a0:	2020      	movs	r0, #32
 80238a2:	4631      	mov	r1, r6
 80238a4:	f004 faa2 	bl	8027dec <mpool_alloc>
    c->mempool = m;
    
    c->op = 4;
    c->div = SCALAR;
 80238a8:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 80238ac:	4604      	mov	r4, r0
    c->rnd = 0.25f;
 80238ae:	f04f 527a 	mov.w	r2, #1048576000	; 0x3e800000
    c->div = SCALAR;
 80238b2:	f2c4 539c 	movt	r3, #17820	; 0x459c
    c->op = 4;
 80238b6:	2104      	movs	r1, #4
    _tCrusher* c = *cr = (_tCrusher*) mpool_alloc(sizeof(_tCrusher), m);
 80238b8:	6038      	str	r0, [r7, #0]
    c->mempool = m;
 80238ba:	6006      	str	r6, [r0, #0]
    s->invRatio = 1.0f;
 80238bc:	f04f 567e 	mov.w	r6, #1065353216	; 0x3f800000
    c->op = 4;
 80238c0:	6141      	str	r1, [r0, #20]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 80238c2:	2010      	movs	r0, #16
    c->rnd = 0.25f;
 80238c4:	6122      	str	r2, [r4, #16]
    c->srr = 0.25f;
 80238c6:	6062      	str	r2, [r4, #4]
    c->div = SCALAR;
 80238c8:	60e3      	str	r3, [r4, #12]
    _tMempool* m = *mp;
 80238ca:	682d      	ldr	r5, [r5, #0]
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 80238cc:	4629      	mov	r1, r5
 80238ce:	f004 fa8d 	bl	8027dec <mpool_alloc>
    tSampleReducer_initToPool(&c->sReducer, mp);
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238d2:	f64c 42f6 	movw	r2, #52470	; 0xccf6
 80238d6:	f649 139a 	movw	r3, #39322	; 0x999a
    s->hold = 0.0f;
 80238da:	2100      	movs	r1, #0
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238dc:	f6c3 1212 	movt	r2, #14610	; 0x3912
    _tSampleReducer* s = *sr = (_tSampleReducer*) mpool_alloc(sizeof(_tSampleReducer), m);
 80238e0:	61e0      	str	r0, [r4, #28]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238e2:	f6c3 6399 	movt	r3, #16025	; 0x3e99
    s->mempool = m;
 80238e6:	6005      	str	r5, [r0, #0]
    s->invRatio = 1.0f;
 80238e8:	6046      	str	r6, [r0, #4]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238ea:	ee07 2a10 	vmov	s14, r2
    s->hold = 0.0f;
 80238ee:	6081      	str	r1, [r0, #8]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238f0:	ee07 3a90 	vmov	s15, r3
    s->count = 0;
 80238f4:	60c1      	str	r1, [r0, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80238f6:	edd4 6a03 	vldr	s13, [r4, #12]
 80238fa:	eee6 7a87 	vfma.f32	s15, s13, s14
 80238fe:	edc4 7a06 	vstr	s15, [r4, #24]
}
 8023902:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08023904 <tCrusher_free>:

void tCrusher_free (tCrusher* const cr)
{
 8023904:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
 8023906:	6804      	ldr	r4, [r0, #0]
    _tSampleReducer* s = *sr;
 8023908:	69e0      	ldr	r0, [r4, #28]
    mpool_free((char*)s, s->mempool);
 802390a:	6801      	ldr	r1, [r0, #0]
 802390c:	f004 fb18 	bl	8027f40 <mpool_free>
    
    tSampleReducer_free(&c->sReducer);
    mpool_free((char*)c, c->mempool);
 8023910:	6821      	ldr	r1, [r4, #0]
 8023912:	4620      	mov	r0, r4
}
 8023914:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)c, c->mempool);
 8023918:	f004 bb12 	b.w	8027f40 <mpool_free>

0802391c <tCrusher_tick>:
{
    _tCrusher* c = *cr;
    
    float sample = input;
    
    sample *= SCALAR; // SCALAR is 5000 by default
 802391c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8023920:	f2c4 539c 	movt	r3, #17820	; 0x459c
 8023924:	ee07 3a90 	vmov	s15, r3
 8023928:	ee20 0a27 	vmul.f32	s0, s0, s15
{
 802392c:	b510      	push	{r4, lr}
    
    sample = (int32_t) sample;
 802392e:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tCrusher* c = *cr;
 8023932:	6804      	ldr	r4, [r0, #0]
    
    sample /= c->div;
 8023934:	ed94 7a03 	vldr	s14, [r4, #12]
    sample = (int32_t) sample;
 8023938:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
    
    sample = LEAF_bitwise_xor(sample, c->op << 23);
 802393c:	6960      	ldr	r0, [r4, #20]
 802393e:	05c0      	lsls	r0, r0, #23
 8023940:	ee80 0a07 	vdiv.f32	s0, s0, s14
 8023944:	f004 f832 	bl	80279ac <LEAF_bitwise_xor>
    
    sample = LEAF_clip(-1.f, sample, 1.f);
 8023948:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 802394c:	eef0 0a40 	vmov.f32	s1, s0
 8023950:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8023954:	f004 f830 	bl	80279b8 <LEAF_clip>
    
    sample = LEAF_round(sample, c->rnd);
 8023958:	edd4 0a04 	vldr	s1, [r4, #16]
 802395c:	f004 f812 	bl	8027984 <LEAF_round>
    _tSampleReducer* s = *sr;
 8023960:	69e3      	ldr	r3, [r4, #28]
    if (s->count > s->invRatio)
 8023962:	68da      	ldr	r2, [r3, #12]
 8023964:	edd3 7a01 	vldr	s15, [r3, #4]
 8023968:	ee07 2a10 	vmov	s14, r2
 802396c:	eeb8 7a47 	vcvt.f32.u32	s14, s14
 8023970:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8023974:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023978:	dd08      	ble.n	802398c <tCrusher_tick+0x70>
        s->hold = input;
 802397a:	2201      	movs	r2, #1
 802397c:	ed83 0a02 	vstr	s0, [r3, #8]
    s->count++;
 8023980:	60da      	str	r2, [r3, #12]
    
    sample = tSampleReducer_tick(&c->sReducer, sample);
    
    return sample * c->gain;
 8023982:	edd4 7a06 	vldr	s15, [r4, #24]
    
}
 8023986:	ee20 0a27 	vmul.f32	s0, s0, s15
 802398a:	bd10      	pop	{r4, pc}
 802398c:	3201      	adds	r2, #1
 802398e:	ed93 0a02 	vldr	s0, [r3, #8]
    s->count++;
 8023992:	60da      	str	r2, [r3, #12]
    return sample * c->gain;
 8023994:	edd4 7a06 	vldr	s15, [r4, #24]
}
 8023998:	ee20 0a27 	vmul.f32	s0, s0, s15
 802399c:	bd10      	pop	{r4, pc}
 802399e:	bf00      	nop

080239a0 <tCrusher_setOperation>:

void    tCrusher_setOperation (tCrusher* const cr, float op)
{
    _tCrusher* c = *cr;
    c->op = (uint32_t) (op * 8.0f);
 80239a0:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    _tCrusher* c = *cr;
 80239a4:	6803      	ldr	r3, [r0, #0]
    c->op = (uint32_t) (op * 8.0f);
 80239a6:	ee20 0a27 	vmul.f32	s0, s0, s15
 80239aa:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 80239ae:	ed83 0a05 	vstr	s0, [r3, #20]
}
 80239b2:	4770      	bx	lr

080239b4 <tCrusher_setQuality>:
// 0.0 - 1.0
void    tCrusher_setQuality (tCrusher* const cr, float val)
{
    _tCrusher* c = *cr;
    
    val = LEAF_clip(0.0f, val, 1.0f);
 80239b4:	2300      	movs	r3, #0
 80239b6:	eef0 0a40 	vmov.f32	s1, s0
 80239ba:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 80239be:	ee00 3a10 	vmov	s0, r3
{
 80239c2:	b510      	push	{r4, lr}
    _tCrusher* c = *cr;
 80239c4:	6804      	ldr	r4, [r0, #0]
    val = LEAF_clip(0.0f, val, 1.0f);
 80239c6:	f003 fff7 	bl	80279b8 <LEAF_clip>
    
    c->div = 0.01f + val * SCALAR;
 80239ca:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80239ce:	f24d 730a 	movw	r3, #55050	; 0xd70a
    
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80239d2:	f64c 41f6 	movw	r1, #52470	; 0xccf6
 80239d6:	f649 129a 	movw	r2, #39322	; 0x999a
    c->div = 0.01f + val * SCALAR;
 80239da:	f2c4 509c 	movt	r0, #17820	; 0x459c
 80239de:	f6c3 4323 	movt	r3, #15395	; 0x3c23
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80239e2:	f6c3 1112 	movt	r1, #14610	; 0x3912
 80239e6:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    c->div = 0.01f + val * SCALAR;
 80239ea:	ee06 0a10 	vmov	s12, r0
 80239ee:	ee07 3a90 	vmov	s15, r3
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80239f2:	ee06 1a90 	vmov	s13, r1
 80239f6:	ee07 2a10 	vmov	s14, r2
    c->div = 0.01f + val * SCALAR;
 80239fa:	eee0 7a06 	vfma.f32	s15, s0, s12
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 80239fe:	eea7 7aa6 	vfma.f32	s14, s15, s13
    c->div = 0.01f + val * SCALAR;
 8023a02:	edc4 7a03 	vstr	s15, [r4, #12]
    c->gain = (c->div / SCALAR) * 0.7f + 0.3f;
 8023a06:	ed84 7a06 	vstr	s14, [r4, #24]
}
 8023a0a:	bd10      	pop	{r4, pc}

08023a0c <tCrusher_setRound>:

// what decimal to round to
void    tCrusher_setRound (tCrusher* const cr, float rnd)
{
    _tCrusher* c = *cr;
    c->rnd = fabsf(rnd);
 8023a0c:	eeb0 0ac0 	vabs.f32	s0, s0
    _tCrusher* c = *cr;
 8023a10:	6803      	ldr	r3, [r0, #0]
    c->rnd = fabsf(rnd);
 8023a12:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8023a16:	4770      	bx	lr

08023a18 <tCrusher_setSamplingRatio>:
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
 8023a18:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0

void    tCrusher_setSamplingRatio (tCrusher* const cr, float ratio)
{
    _tCrusher* c = *cr;
 8023a1c:	6803      	ldr	r3, [r0, #0]
    c->srr = ratio;
 8023a1e:	ed83 0a01 	vstr	s0, [r3, #4]
    if ((ratio <= 1.0f) && (ratio >= 0.0f))
 8023a22:	eeb4 0a67 	vcmp.f32	s0, s15
 8023a26:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023a2a:	d809      	bhi.n	8023a40 <tCrusher_setSamplingRatio+0x28>
 8023a2c:	eeb5 0a40 	vcmp.f32	s0, #0.0
 8023a30:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023a34:	db04      	blt.n	8023a40 <tCrusher_setSamplingRatio+0x28>
        s->invRatio = 1.0f / ratio;
 8023a36:	ee87 7a80 	vdiv.f32	s14, s15, s0
    _tSampleReducer* s = *sr;
 8023a3a:	69db      	ldr	r3, [r3, #28]
        s->invRatio = 1.0f / ratio;
 8023a3c:	ed83 7a01 	vstr	s14, [r3, #4]
    tSampleReducer_setRatio(&c->sReducer, ratio);

}
 8023a40:	4770      	bx	lr
 8023a42:	bf00      	nop

08023a44 <tFeedbackLeveler_init>:
}

/* Feedback Leveler */

void tFeedbackLeveler_init (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode)
{
 8023a44:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    tFeedbackLeveler_initToPool(fb, targetLevel, factor, strength, mode, &leaf.mempool);
}

void tFeedbackLeveler_initToPool (tFeedbackLeveler* const fb, float targetLevel, float factor, float strength, int mode, tMempool* const mp)
{
    _tMempool* m = *mp;
 8023a48:	f249 45a0 	movw	r5, #38048	; 0x94a0
{
 8023a4c:	4680      	mov	r8, r0
 8023a4e:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023a50:	2018      	movs	r0, #24
    _tMempool* m = *mp;
 8023a52:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8023a56:	f855 6f18 	ldr.w	r6, [r5, #24]!
{
 8023a5a:	ed2d 8b04 	vpush	{d8-d9}
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023a5e:	4631      	mov	r1, r6
{
 8023a60:	eef0 8a40 	vmov.f32	s17, s0
 8023a64:	eeb0 9a60 	vmov.f32	s18, s1
 8023a68:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023a6c:	f004 f9be 	bl	8027dec <mpool_alloc>
    p->mempool = m;
    
    p->curr=0.0f;
 8023a70:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023a72:	4604      	mov	r4, r0
 8023a74:	f8c8 0000 	str.w	r0, [r8]
    p->targetLevel=targetLevel;
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023a78:	eeb0 0a49 	vmov.f32	s0, s18
    p->targetLevel=targetLevel;
 8023a7c:	edc0 8a01 	vstr	s17, [r0, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023a80:	4629      	mov	r1, r5
    p->mempool = m;
 8023a82:	6006      	str	r6, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023a84:	3014      	adds	r0, #20
    p->curr=0.0f;
 8023a86:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023a88:	f7fe fc58 	bl	802233c <tPowerFollower_initToPool>
    p->mode=mode;
 8023a8c:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
 8023a8e:	ed84 8a02 	vstr	s16, [r4, #8]
}
 8023a92:	ecbd 8b04 	vpop	{d8-d9}
 8023a96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023a9a:	bf00      	nop

08023a9c <tFeedbackLeveler_initToPool>:
{
 8023a9c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    _tMempool* m = *mp;
 8023aa0:	6815      	ldr	r5, [r2, #0]
{
 8023aa2:	4680      	mov	r8, r0
 8023aa4:	460f      	mov	r7, r1
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023aa6:	2018      	movs	r0, #24
 8023aa8:	4629      	mov	r1, r5
{
 8023aaa:	4616      	mov	r6, r2
 8023aac:	ed2d 8b04 	vpush	{d8-d9}
 8023ab0:	eef0 8a40 	vmov.f32	s17, s0
 8023ab4:	eeb0 9a60 	vmov.f32	s18, s1
 8023ab8:	eeb0 8a41 	vmov.f32	s16, s2
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023abc:	f004 f996 	bl	8027dec <mpool_alloc>
    p->curr=0.0f;
 8023ac0:	2300      	movs	r3, #0
    _tFeedbackLeveler* p = *fb = (_tFeedbackLeveler*) mpool_alloc(sizeof(_tFeedbackLeveler), m);
 8023ac2:	4604      	mov	r4, r0
 8023ac4:	f8c8 0000 	str.w	r0, [r8]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023ac8:	eeb0 0a49 	vmov.f32	s0, s18
    p->targetLevel=targetLevel;
 8023acc:	edc0 8a01 	vstr	s17, [r0, #4]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023ad0:	4631      	mov	r1, r6
    p->mempool = m;
 8023ad2:	6005      	str	r5, [r0, #0]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023ad4:	3014      	adds	r0, #20
    p->curr=0.0f;
 8023ad6:	6123      	str	r3, [r4, #16]
    tPowerFollower_initToPool(&p->pwrFlw,factor, mp);
 8023ad8:	f7fe fc30 	bl	802233c <tPowerFollower_initToPool>
    p->mode=mode;
 8023adc:	60e7      	str	r7, [r4, #12]
    p->strength=strength;
 8023ade:	ed84 8a02 	vstr	s16, [r4, #8]
}
 8023ae2:	ecbd 8b04 	vpop	{d8-d9}
 8023ae6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8023aea:	bf00      	nop

08023aec <tFeedbackLeveler_free>:

void tFeedbackLeveler_free (tFeedbackLeveler* const fb)
{
 8023aec:	b510      	push	{r4, lr}
    _tFeedbackLeveler* p = *fb;
 8023aee:	6804      	ldr	r4, [r0, #0]
    
    tPowerFollower_free(&p->pwrFlw);
 8023af0:	f104 0014 	add.w	r0, r4, #20
 8023af4:	f7fe fc3c 	bl	8022370 <tPowerFollower_free>
    mpool_free((char*)p, p->mempool);
 8023af8:	6821      	ldr	r1, [r4, #0]
 8023afa:	4620      	mov	r0, r4
}
 8023afc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 8023b00:	f004 ba1e 	b.w	8027f40 <mpool_free>

08023b04 <tFeedbackLeveler_setMode>:
    tPowerFollower_setFactor(&p->pwrFlw,factor);
}

void     tFeedbackLeveler_setMode(tFeedbackLeveler* const fb, int mode)
{    // 0 for decaying with upwards lev limiting, 1 for constrained absolute level (also downwards limiting)
    _tFeedbackLeveler* p = *fb;
 8023b04:	6803      	ldr	r3, [r0, #0]
    p->mode=mode;
 8023b06:	60d9      	str	r1, [r3, #12]
}
 8023b08:	4770      	bx	lr
 8023b0a:	bf00      	nop

08023b0c <tFeedbackLeveler_tick>:

float   tFeedbackLeveler_tick(tFeedbackLeveler* const fb, float input)
{
 8023b0c:	b510      	push	{r4, lr}
 8023b0e:	ed2d 8b02 	vpush	{d8}
    _tFeedbackLeveler* p = *fb;
 8023b12:	6804      	ldr	r4, [r0, #0]
{
 8023b14:	eeb0 8a40 	vmov.f32	s16, s0
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
 8023b18:	f104 0014 	add.w	r0, r4, #20
 8023b1c:	f7fe fc2c 	bl	8022378 <tPowerFollower_tick>
 8023b20:	edd4 7a01 	vldr	s15, [r4, #4]
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
 8023b24:	68e3      	ldr	r3, [r4, #12]
    float levdiff=(tPowerFollower_tick(&p->pwrFlw, input)-p->targetLevel);
 8023b26:	ee70 7a67 	vsub.f32	s15, s0, s15
    if (p->mode==0 && levdiff<0.0f) levdiff=0.0f;
 8023b2a:	b943      	cbnz	r3, 8023b3e <tFeedbackLeveler_tick+0x32>
 8023b2c:	eef5 7a40 	vcmp.f32	s15, #0.0
 8023b30:	ee07 3a10 	vmov	s14, r3
 8023b34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023b38:	bf48      	it	mi
 8023b3a:	eef0 7a47 	vmovmi.f32	s15, s14
    p->curr=input*(1.0f-p->strength*levdiff);
 8023b3e:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8023b42:	ed94 7a02 	vldr	s14, [r4, #8]
 8023b46:	eea7 0a67 	vfms.f32	s0, s14, s15
 8023b4a:	ee20 0a08 	vmul.f32	s0, s0, s16
 8023b4e:	ed84 0a04 	vstr	s0, [r4, #16]
    return p->curr;
}
 8023b52:	ecbd 8b02 	vpop	{d8}
 8023b56:	bd10      	pop	{r4, pc}

08023b58 <tFeedbackLeveler_setTargetLevel>:
}


void     tFeedbackLeveler_setTargetLevel   (tFeedbackLeveler* const fb, float TargetLevel)
{
    _tFeedbackLeveler* p = *fb;
 8023b58:	6803      	ldr	r3, [r0, #0]
    p->targetLevel=TargetLevel;
 8023b5a:	ed83 0a01 	vstr	s0, [r3, #4]
}
 8023b5e:	4770      	bx	lr

08023b60 <tTalkbox_lpcDurbin>:
    }

}

void tTalkbox_lpcDurbin(float *r, int p, float *k, float *a, float *at, float *g)
{
 8023b60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i, j;
    float e=r[0];

    for(i=0; i<=p; i++)
 8023b64:	1e0f      	subs	r7, r1, #0
{
 8023b66:	ed2d 8b02 	vpush	{d8}
 8023b6a:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    float e=r[0];
 8023b6c:	ed90 8a00 	vldr	s16, [r0]
    for(i=0; i<=p; i++)
 8023b70:	f2c0 8094 	blt.w	8023c9c <tTalkbox_lpcDurbin+0x13c>
 8023b74:	4692      	mov	sl, r2
    {
    	a[i] = 0.0f; //probably don't need to clear at[] or k[]
 8023b76:	1c7a      	adds	r2, r7, #1
 8023b78:	4606      	mov	r6, r0
 8023b7a:	2100      	movs	r1, #0
 8023b7c:	0092      	lsls	r2, r2, #2
 8023b7e:	4618      	mov	r0, r3
 8023b80:	f007 f8bb 	bl	802acfa <memset>
    }
	k[0] = 0.0f;
 8023b84:	2200      	movs	r2, #0
    at[0] = 0.0f;
    for(i=1; i<=p; i++)
 8023b86:	4297      	cmp	r7, r2
	k[0] = 0.0f;
 8023b88:	f8ca 2000 	str.w	r2, [sl]
    at[0] = 0.0f;
 8023b8c:	6022      	str	r2, [r4, #0]
    for(i=1; i<=p; i++)
 8023b8e:	dd5b      	ble.n	8023c48 <tTalkbox_lpcDurbin+0xe8>
        for(j=1; j<i; j++)
        {
            at[j] = a[j];
            k[i] -= a[j] * r[i-j];
        }
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8023b90:	f24e 5508 	movw	r5, #58632	; 0xe508
 8023b94:	f104 0904 	add.w	r9, r4, #4
 8023b98:	f100 0804 	add.w	r8, r0, #4
        k[i] /= e;

        a[i] = k[i];
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];

        e *= 1.0f - k[i] * k[i];
 8023b9c:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8023ba0:	f6c1 653c 	movt	r5, #7740	; 0x1e3c
 8023ba4:	1d31      	adds	r1, r6, #4
 8023ba6:	f10a 0204 	add.w	r2, sl, #4
 8023baa:	4646      	mov	r6, r8
 8023bac:	ee05 5a90 	vmov	s11, r5
    for(i=1; i<=p; i++)
 8023bb0:	46cc      	mov	ip, r9
 8023bb2:	f04f 0e01 	mov.w	lr, #1
        k[i] = -r[i];
 8023bb6:	edd1 7a00 	vldr	s15, [r1]
        for(j=1; j<i; j++)
 8023bba:	f1be 0f01 	cmp.w	lr, #1
 8023bbe:	f101 0a04 	add.w	sl, r1, #4
 8023bc2:	eeb0 6ac8 	vabs.f32	s12, s16
        k[i] = -r[i];
 8023bc6:	eef1 7a67 	vneg.f32	s15, s15
 8023bca:	ece2 7a01 	vstmia	r2!, {s15}
        for(j=1; j<i; j++)
 8023bce:	d059      	beq.n	8023c84 <tTalkbox_lpcDurbin+0x124>
 8023bd0:	4645      	mov	r5, r8
 8023bd2:	4648      	mov	r0, r9
 8023bd4:	4643      	mov	r3, r8
            at[j] = a[j];
 8023bd6:	f8d3 b000 	ldr.w	fp, [r3]
 8023bda:	f840 bb04 	str.w	fp, [r0], #4
            k[i] -= a[j] * r[i-j];
 8023bde:	ecf3 6a01 	vldmia	r3!, {s13}
 8023be2:	ed31 7a01 	vldmdb	r1!, {s14}
 8023be6:	ed52 7a01 	vldr	s15, [r2, #-4]
        for(j=1; j<i; j++)
 8023bea:	429e      	cmp	r6, r3
            k[i] -= a[j] * r[i-j];
 8023bec:	eee6 7ac7 	vfms.f32	s15, s13, s14
 8023bf0:	ed42 7a01 	vstr	s15, [r2, #-4]
        for(j=1; j<i; j++)
 8023bf4:	d1ef      	bne.n	8023bd6 <tTalkbox_lpcDurbin+0x76>
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8023bf6:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8023bfa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023bfe:	d437      	bmi.n	8023c70 <tTalkbox_lpcDurbin+0x110>
        k[i] /= e;
 8023c00:	ee87 7a88 	vdiv.f32	s14, s15, s16
        a[i] = k[i];
 8023c04:	4661      	mov	r1, ip
 8023c06:	464b      	mov	r3, r9
        k[i] /= e;
 8023c08:	ed02 7a01 	vstr	s14, [r2, #-4]
        a[i] = k[i];
 8023c0c:	ed86 7a00 	vstr	s14, [r6]
        for(j=1; j<i; j++) a[j] = at[j] + k[i] * at[i-j];
 8023c10:	ecf3 7a01 	vldmia	r3!, {s15}
 8023c14:	ed52 6a01 	vldr	s13, [r2, #-4]
 8023c18:	ed31 7a01 	vldmdb	r1!, {s14}
 8023c1c:	459c      	cmp	ip, r3
 8023c1e:	eee6 7a87 	vfma.f32	s15, s13, s14
 8023c22:	ece5 7a01 	vstmia	r5!, {s15}
 8023c26:	d1f3      	bne.n	8023c10 <tTalkbox_lpcDurbin+0xb0>
        e *= 1.0f - k[i] * k[i];
 8023c28:	eeb0 7a45 	vmov.f32	s14, s10
 8023c2c:	ed52 7a01 	vldr	s15, [r2, #-4]
    for(i=1; i<=p; i++)
 8023c30:	f10e 0e01 	add.w	lr, lr, #1
 8023c34:	f10c 0c04 	add.w	ip, ip, #4
 8023c38:	3604      	adds	r6, #4
 8023c3a:	4651      	mov	r1, sl
        e *= 1.0f - k[i] * k[i];
 8023c3c:	eea7 7ae7 	vfms.f32	s14, s15, s15
    for(i=1; i<=p; i++)
 8023c40:	4577      	cmp	r7, lr
        e *= 1.0f - k[i] * k[i];
 8023c42:	ee28 8a07 	vmul.f32	s16, s16, s14
    for(i=1; i<=p; i++)
 8023c46:	dab6      	bge.n	8023bb6 <tTalkbox_lpcDurbin+0x56>
    }

    if(e < 1.0e-20f) e = 0.0f;
 8023c48:	f24e 5308 	movw	r3, #58632	; 0xe508
 8023c4c:	f6c1 633c 	movt	r3, #7740	; 0x1e3c
 8023c50:	ee07 3a90 	vmov	s15, r3
 8023c54:	eeb4 8ae7 	vcmpe.f32	s16, s15
 8023c58:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023c5c:	d408      	bmi.n	8023c70 <tTalkbox_lpcDurbin+0x110>
 8023c5e:	eef1 7ac8 	vsqrt.f32	s15, s16
    *g = sqrtf(e);
 8023c62:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023c64:	edc3 7a00 	vstr	s15, [r3]
}
 8023c68:	ecbd 8b02 	vpop	{d8}
 8023c6c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        a[i] = k[i];
 8023c70:	2300      	movs	r3, #0
 8023c72:	ee07 3a90 	vmov	s15, r3
    *g = sqrtf(e);
 8023c76:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8023c78:	edc3 7a00 	vstr	s15, [r3]
}
 8023c7c:	ecbd 8b02 	vpop	{d8}
 8023c80:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if(fabs(e) < 1.0e-20f) { e = 0.0f;  break; }
 8023c84:	eeb4 6ae5 	vcmpe.f32	s12, s11
 8023c88:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8023c8c:	d4f0      	bmi.n	8023c70 <tTalkbox_lpcDurbin+0x110>
        k[i] /= e;
 8023c8e:	ee87 7a88 	vdiv.f32	s14, s15, s16
 8023c92:	ed02 7a01 	vstr	s14, [r2, #-4]
        a[i] = k[i];
 8023c96:	ed86 7a00 	vstr	s14, [r6]
 8023c9a:	e7c5      	b.n	8023c28 <tTalkbox_lpcDurbin+0xc8>
	k[0] = 0.0f;
 8023c9c:	2300      	movs	r3, #0
 8023c9e:	6013      	str	r3, [r2, #0]
    at[0] = 0.0f;
 8023ca0:	6023      	str	r3, [r4, #0]
 8023ca2:	e7d1      	b.n	8023c48 <tTalkbox_lpcDurbin+0xe8>

08023ca4 <tTalkboxFloat_free>:
    tTalkboxFloat_update(voc);
    tTalkboxFloat_suspend(voc);
}

void tTalkboxFloat_free (tTalkboxFloat* const voc)
{
 8023ca4:	b510      	push	{r4, lr}
    _tTalkboxFloat* v = *voc;
 8023ca6:	6804      	ldr	r4, [r0, #0]

    mpool_free((char*)v->buf1, v->mempool);
 8023ca8:	6821      	ldr	r1, [r4, #0]
 8023caa:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8023cac:	f004 f948 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->buf0, v->mempool);
 8023cb0:	6821      	ldr	r1, [r4, #0]
 8023cb2:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8023cb4:	f004 f944 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->window, v->mempool);
 8023cb8:	6821      	ldr	r1, [r4, #0]
 8023cba:	6a20      	ldr	r0, [r4, #32]
 8023cbc:	f004 f940 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->car1, v->mempool);
 8023cc0:	6821      	ldr	r1, [r4, #0]
 8023cc2:	69e0      	ldr	r0, [r4, #28]
 8023cc4:	f004 f93c 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->car0, v->mempool);
 8023cc8:	6821      	ldr	r1, [r4, #0]
 8023cca:	69a0      	ldr	r0, [r4, #24]
 8023ccc:	f004 f938 	bl	8027f40 <mpool_free>

    mpool_free((char*)v->dl, v->mempool);
 8023cd0:	6821      	ldr	r1, [r4, #0]
 8023cd2:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
 8023cd6:	f004 f933 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->Rt, v->mempool);
 8023cda:	6821      	ldr	r1, [r4, #0]
 8023cdc:	f8d4 0094 	ldr.w	r0, [r4, #148]	; 0x94
 8023ce0:	f004 f92e 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->k, v->mempool);
 8023ce4:	6821      	ldr	r1, [r4, #0]
 8023ce6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 8023ce8:	f004 f92a 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->a, v->mempool);
 8023cec:	6821      	ldr	r1, [r4, #0]
 8023cee:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8023cf0:	f004 f926 	bl	8027f40 <mpool_free>
    mpool_free((char*)v->at, v->mempool);
 8023cf4:	6821      	ldr	r1, [r4, #0]
 8023cf6:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8023cf8:	f004 f922 	bl	8027f40 <mpool_free>
    mpool_free((char*)v, v->mempool);
 8023cfc:	6821      	ldr	r1, [r4, #0]
 8023cfe:	4620      	mov	r0, r4
}
 8023d00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)v, v->mempool);
 8023d04:	f004 b91c 	b.w	8027f40 <mpool_free>

08023d08 <tTalkboxFloat_update>:

    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
    if(n > v->bufsize) n = v->bufsize;

    //O = (VstInt32)(0.0005f * fs);
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d08:	f24b 7217 	movw	r2, #46871	; 0xb717
 8023d0c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
{
 8023d10:	b538      	push	{r3, r4, r5, lr}
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d12:	4613      	mov	r3, r2
 8023d14:	f6c3 12d1 	movt	r2, #14801	; 0x39d1
 8023d18:	f2c4 71bb 	movt	r1, #18363	; 0x47bb
 8023d1c:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8023d20:	ee07 2a90 	vmov	s15, r2
 8023d24:	2200      	movs	r2, #0
 8023d26:	ee05 1a90 	vmov	s11, r1
 8023d2a:	ee07 3a10 	vmov	s14, r3
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 8023d2e:	f24c 637e 	movw	r3, #50814	; 0xc67e
 8023d32:	f2c4 52fa 	movt	r2, #17914	; 0x45fa
 8023d36:	f6c3 4385 	movt	r3, #15493	; 0x3c85
 8023d3a:	ee06 2a10 	vmov	s12, r2
{
 8023d3e:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
 8023d42:	6804      	ldr	r4, [r0, #0]
    float fs = leaf.sampleRate;
 8023d44:	f249 40a0 	movw	r0, #38048	; 0x94a0
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d48:	edd4 6a04 	vldr	s13, [r4, #16]
    float fs = leaf.sampleRate;
 8023d4c:	f2c2 0001 	movt	r0, #8193	; 0x2001
 8023d50:	6961      	ldr	r1, [r4, #20]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d52:	eea6 7aa7 	vfma.f32	s14, s13, s15
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 8023d56:	ee07 3a90 	vmov	s15, r3
 8023d5a:	edd0 6a00 	vldr	s13, [r0]

    if(n != v->N) //recalc hanning window
 8023d5e:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
 8023d60:	fec6 6ae5 	vminnm.f32	s13, s13, s11
 8023d64:	fec6 6a86 	vmaxnm.f32	s13, s13, s12
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 8023d68:	ee66 7aa7 	vmul.f32	s15, s13, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d6c:	ee27 7a26 	vmul.f32	s14, s14, s13
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 8023d70:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d74:	eebd 7ac7 	vcvt.s32.f32	s14, s14
    int32_t n = (int32_t)(0.01633f * fs); //this sets the window time to 16ms if the buffer is large enough. Buffer needs to be at least 784 samples at 48000
 8023d78:	ee17 3a90 	vmov	r3, s15
 8023d7c:	428b      	cmp	r3, r1
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * fs);
 8023d7e:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
 8023d82:	bfa8      	it	ge
 8023d84:	460b      	movge	r3, r1
    if(n != v->N) //recalc hanning window
 8023d86:	429a      	cmp	r2, r3
 8023d88:	d02c      	beq.n	8023de4 <tTalkboxFloat_update+0xdc>
    {
        v->N = n;
        float dp = TWO_PI / v->N;
 8023d8a:	f640 72db 	movw	r2, #4059	; 0xfdb
 8023d8e:	ee07 3a90 	vmov	s15, r3
        float p = 0.0f;
        for(n=0; n<v->N; n++)
 8023d92:	2b00      	cmp	r3, #0
        v->N = n;
 8023d94:	64e3      	str	r3, [r4, #76]	; 0x4c
        float dp = TWO_PI / v->N;
 8023d96:	f2c4 02c9 	movt	r2, #16585	; 0x40c9
 8023d9a:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 8023d9e:	ee07 2a90 	vmov	s15, r2
 8023da2:	eec7 8a87 	vdiv.f32	s17, s15, s14
        for(n=0; n<v->N; n++)
 8023da6:	dd1d      	ble.n	8023de4 <tTalkboxFloat_update+0xdc>
        float p = 0.0f;
 8023da8:	2300      	movs	r3, #0
        for(n=0; n<v->N; n++)
 8023daa:	461d      	mov	r5, r3
        float p = 0.0f;
 8023dac:	ee08 3a10 	vmov	s16, r3
        for(n=0; n<v->N; n++)
 8023db0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        {
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8023db4:	eef6 9a00 	vmov.f32	s19, #96	; 0x3f000000  0.5
 8023db8:	eeb0 9a40 	vmov.f32	s18, s0
 8023dbc:	e001      	b.n	8023dc2 <tTalkboxFloat_update+0xba>
 8023dbe:	f007 f8bd 	bl	802af3c <cosf>
 8023dc2:	ee39 0a40 	vsub.f32	s0, s18, s0
 8023dc6:	6a23      	ldr	r3, [r4, #32]
            p += dp;
 8023dc8:	ee38 8a28 	vadd.f32	s16, s16, s17
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8023dcc:	eb03 0385 	add.w	r3, r3, r5, lsl #2
        for(n=0; n<v->N; n++)
 8023dd0:	3501      	adds	r5, #1
            v->window[n] = 0.5f - 0.5f * cosf(p);
 8023dd2:	ee60 7a29 	vmul.f32	s15, s0, s19
 8023dd6:	eeb0 0a48 	vmov.f32	s0, s16
 8023dda:	edc3 7a00 	vstr	s15, [r3]
        for(n=0; n<v->N; n++)
 8023dde:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8023de0:	42ab      	cmp	r3, r5
 8023de2:	dcec      	bgt.n	8023dbe <tTalkboxFloat_update+0xb6>
        }
    }
    v->wet = 0.5f * v->param[0] * v->param[0];
 8023de4:	ed94 7a01 	vldr	s14, [r4, #4]
 8023de8:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    v->dry = 2.0f * v->param[1] * v->param[1];
 8023dec:	edd4 7a02 	vldr	s15, [r4, #8]
    v->wet = 0.5f * v->param[0] * v->param[0];
 8023df0:	ee27 7a07 	vmul.f32	s14, s14, s14
    v->dry = 2.0f * v->param[1] * v->param[1];
 8023df4:	ee67 7aa7 	vmul.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
 8023df8:	ee27 7a26 	vmul.f32	s14, s14, s13
    v->dry = 2.0f * v->param[1] * v->param[1];
 8023dfc:	ee77 7aa7 	vadd.f32	s15, s15, s15
    v->wet = 0.5f * v->param[0] * v->param[0];
 8023e00:	ed84 7a16 	vstr	s14, [r4, #88]	; 0x58
    v->dry = 2.0f * v->param[1] * v->param[1];
 8023e04:	edc4 7a17 	vstr	s15, [r4, #92]	; 0x5c
}
 8023e08:	ecbd 8b04 	vpop	{d8-d9}
 8023e0c:	bd38      	pop	{r3, r4, r5, pc}
 8023e0e:	bf00      	nop

08023e10 <tTalkboxFloat_initToPool>:
{
 8023e10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
 8023e14:	6817      	ldr	r7, [r2, #0]
{
 8023e16:	4680      	mov	r8, r0
 8023e18:	4689      	mov	r9, r1
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 8023e1a:	2098      	movs	r0, #152	; 0x98
 8023e1c:	4639      	mov	r1, r7
    v->warpOn = 0;
 8023e1e:	2500      	movs	r5, #0
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 8023e20:	f003 ffe4 	bl	8027dec <mpool_alloc>
    v->param[3] = 1.0f;  //quality
 8023e24:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 8023e28:	4606      	mov	r6, r0
    v->param[0] = 0.5f;  //wet
 8023e2a:	f04f 517c 	mov.w	r1, #1056964608	; 0x3f000000
    _tTalkboxFloat* v = *voc = (_tTalkboxFloat*) mpool_alloc(sizeof(_tTalkboxFloat), m);
 8023e2e:	f8c8 0000 	str.w	r0, [r8]
    v->mempool = m;
 8023e32:	6007      	str	r7, [r0, #0]
    v->bufsize = bufsize;
 8023e34:	f8c0 9014 	str.w	r9, [r0, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e38:	ea4f 0089 	mov.w	r0, r9, lsl #2
    v->param[0] = 0.5f;  //wet
 8023e3c:	6071      	str	r1, [r6, #4]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e3e:	4639      	mov	r1, r7
    v->param[3] = 1.0f;  //quality
 8023e40:	6133      	str	r3, [r6, #16]
    v->param[1] = 0.0f;  //dry
 8023e42:	60b5      	str	r5, [r6, #8]
    v->param[2] = 0; // Swap
 8023e44:	60f5      	str	r5, [r6, #12]
    v->warpFactor = 0.0f;
 8023e46:	63b5      	str	r5, [r6, #56]	; 0x38
    v->G = 0.0f;
 8023e48:	f8c6 508c 	str.w	r5, [r6, #140]	; 0x8c
    v->freeze = 0;
 8023e4c:	e9c6 550f 	strd	r5, r5, [r6, #60]	; 0x3c
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e50:	f003 ffcc 	bl	8027dec <mpool_alloc>
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e54:	6973      	ldr	r3, [r6, #20]
    v->car0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e56:	61b0      	str	r0, [r6, #24]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e58:	4639      	mov	r1, r7
 8023e5a:	0098      	lsls	r0, r3, #2
 8023e5c:	f003 ffc6 	bl	8027dec <mpool_alloc>
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e60:	6973      	ldr	r3, [r6, #20]
    v->car1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e62:	61f0      	str	r0, [r6, #28]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e64:	4639      	mov	r1, r7
 8023e66:	0098      	lsls	r0, r3, #2
 8023e68:	f003 ffc0 	bl	8027dec <mpool_alloc>
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e6c:	6973      	ldr	r3, [r6, #20]
    v->window = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e6e:	6230      	str	r0, [r6, #32]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e70:	4639      	mov	r1, r7
 8023e72:	0098      	lsls	r0, r3, #2
 8023e74:	f003 ffba 	bl	8027dec <mpool_alloc>
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e78:	6973      	ldr	r3, [r6, #20]
    v->buf0 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e7a:	6270      	str	r0, [r6, #36]	; 0x24
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e7c:	4639      	mov	r1, r7
 8023e7e:	0098      	lsls	r0, r3, #2
 8023e80:	f003 ffb4 	bl	8027dec <mpool_alloc>
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e84:	6973      	ldr	r3, [r6, #20]
    v->buf1 =   (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e86:	62b0      	str	r0, [r6, #40]	; 0x28
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e88:	4639      	mov	r1, r7
 8023e8a:	0098      	lsls	r0, r3, #2
 8023e8c:	f003 ffae 	bl	8027dec <mpool_alloc>
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e90:	6973      	ldr	r3, [r6, #20]
    v->dl = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e92:	f8c6 0090 	str.w	r0, [r6, #144]	; 0x90
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023e96:	4639      	mov	r1, r7
 8023e98:	0098      	lsls	r0, r3, #2
 8023e9a:	f003 ffa7 	bl	8027dec <mpool_alloc>
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023e9e:	4639      	mov	r1, r7
    v->Rt = (float*) mpool_alloc(sizeof(float) * v->bufsize, m);
 8023ea0:	f8c6 0094 	str.w	r0, [r6, #148]	; 0x94
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023ea4:	2088      	movs	r0, #136	; 0x88
 8023ea6:	f003 ffa1 	bl	8027dec <mpool_alloc>
    v->a = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eaa:	4639      	mov	r1, r7
    v->k = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eac:	62f0      	str	r0, [r6, #44]	; 0x2c
    v->a = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eae:	2088      	movs	r0, #136	; 0x88
 8023eb0:	f003 ff9c 	bl	8027dec <mpool_alloc>
    v->at = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eb4:	4639      	mov	r1, r7
    v->a = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eb6:	6330      	str	r0, [r6, #48]	; 0x30
    v->at = (float*) mpool_alloc(sizeof(float) * ORD_MAX, m);
 8023eb8:	2088      	movs	r0, #136	; 0x88
 8023eba:	f003 ff97 	bl	8027dec <mpool_alloc>
 8023ebe:	6370      	str	r0, [r6, #52]	; 0x34
    tTalkboxFloat_update(voc);
 8023ec0:	4640      	mov	r0, r8
 8023ec2:	f7ff ff21 	bl	8023d08 <tTalkboxFloat_update>

void tTalkboxFloat_suspend(tTalkboxFloat* const voc) ///clear any buffers...
{
    _tTalkboxFloat* v = *voc;
 8023ec6:	f8d8 3000 	ldr.w	r3, [r8]
    v->FX = 0;

    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;

    for (int32_t i = 0; i < v->bufsize; i++)
 8023eca:	695a      	ldr	r2, [r3, #20]
    v->pos = v->K = 0;
 8023ecc:	649d      	str	r5, [r3, #72]	; 0x48
    for (int32_t i = 0; i < v->bufsize; i++)
 8023ece:	42aa      	cmp	r2, r5
    v->pos = v->K = 0;
 8023ed0:	655d      	str	r5, [r3, #84]	; 0x54
    v->emphasis = 0.0f;
 8023ed2:	645d      	str	r5, [r3, #68]	; 0x44
    v->FX = 0;
 8023ed4:	661d      	str	r5, [r3, #96]	; 0x60
    v->u0 = v->u1 = v->u2 = v->u3 = v->u4 = 0.0f;
 8023ed6:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
 8023eda:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 8023ede:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
 8023ee2:	67dd      	str	r5, [r3, #124]	; 0x7c
 8023ee4:	679d      	str	r5, [r3, #120]	; 0x78
    v->d0 = v->d1 = v->d2 = v->d3 = v->d4 = 0.0f;
 8023ee6:	675d      	str	r5, [r3, #116]	; 0x74
 8023ee8:	671d      	str	r5, [r3, #112]	; 0x70
 8023eea:	66dd      	str	r5, [r3, #108]	; 0x6c
 8023eec:	669d      	str	r5, [r3, #104]	; 0x68
 8023eee:	665d      	str	r5, [r3, #100]	; 0x64
    for (int32_t i = 0; i < v->bufsize; i++)
 8023ef0:	dd12      	ble.n	8023f18 <tTalkboxFloat_initToPool+0x108>
 8023ef2:	4629      	mov	r1, r5
    {
        v->buf0[i] = 0;
 8023ef4:	462a      	mov	r2, r5
 8023ef6:	0088      	lsls	r0, r1, #2
 8023ef8:	6a5c      	ldr	r4, [r3, #36]	; 0x24
    for (int32_t i = 0; i < v->bufsize; i++)
 8023efa:	3101      	adds	r1, #1
        v->buf0[i] = 0;
 8023efc:	4404      	add	r4, r0
 8023efe:	6022      	str	r2, [r4, #0]
        v->buf1[i] = 0;
 8023f00:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 8023f02:	4404      	add	r4, r0
 8023f04:	6022      	str	r2, [r4, #0]
        v->car0[i] = 0;
 8023f06:	699c      	ldr	r4, [r3, #24]
 8023f08:	4404      	add	r4, r0
 8023f0a:	6022      	str	r2, [r4, #0]
        v->car1[i] = 0;
 8023f0c:	69dc      	ldr	r4, [r3, #28]
 8023f0e:	4420      	add	r0, r4
 8023f10:	6002      	str	r2, [r0, #0]
    for (int32_t i = 0; i < v->bufsize; i++)
 8023f12:	6958      	ldr	r0, [r3, #20]
 8023f14:	4281      	cmp	r1, r0
 8023f16:	dbee      	blt.n	8023ef6 <tTalkboxFloat_initToPool+0xe6>
}
 8023f18:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08023f1c <tTalkboxFloat_warpedAutocorrelate>:

// warped autocorrelation adapted from ten.enegatum@liam's post on music-dsp 2004-04-07 09:37:51
//find the order-P autocorrelation array, R, for the sequence x of length L and warping of lambda
//wAutocorrelate(&pfSrc[stIndex],siglen,R,P,0);
void tTalkboxFloat_warpedAutocorrelate(float * x, float* dl, float* Rt, unsigned int L, float * R, unsigned int P, float lambda)
{
 8023f1c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    float r1,r2,r1t;
    R[0]=0;
 8023f20:	2400      	movs	r4, #0
{
 8023f22:	e9dd e507 	ldrd	lr, r5, [sp, #28]
    R[0]=0;
 8023f26:	f8ce 4000 	str.w	r4, [lr]
    Rt[0]=0;
 8023f2a:	6014      	str	r4, [r2, #0]
    r1=0;
    r2=0;
    r1t=0;
    for(uint32_t m=0; m<L;m++)
 8023f2c:	b303      	cbz	r3, 8023f70 <tTalkboxFloat_warpedAutocorrelate+0x54>
 8023f2e:	ee07 4a90 	vmov	s15, r4
 8023f32:	460e      	mov	r6, r1
 8023f34:	4604      	mov	r4, r0
 8023f36:	eb00 0783 	add.w	r7, r0, r3, lsl #2
    r2=0;
 8023f3a:	eeb0 7a67 	vmov.f32	s14, s15
    r1=0;
 8023f3e:	eeb0 6a67 	vmov.f32	s12, s15
 8023f42:	e001      	b.n	8023f48 <tTalkboxFloat_warpedAutocorrelate+0x2c>
 8023f44:	edd2 7a00 	vldr	s15, [r2]
    {
                    Rt[0] += (x[m]) * (x[m]);
 8023f48:	edd4 6a00 	vldr	s13, [r4]
 8023f4c:	eee6 7aa6 	vfma.f32	s15, s13, s13
 8023f50:	edc2 7a00 	vstr	s15, [r2]

                    dl[m]= r1 - lambda * (x[m]-r2);
 8023f54:	ecf4 7a01 	vldmia	r4!, {s15}
 8023f58:	ee37 7a67 	vsub.f32	s14, s14, s15
    for(uint32_t m=0; m<L;m++)
 8023f5c:	42bc      	cmp	r4, r7
                    dl[m]= r1 - lambda * (x[m]-r2);
 8023f5e:	eea7 6a00 	vfma.f32	s12, s14, s0
 8023f62:	eeb0 7a46 	vmov.f32	s14, s12
 8023f66:	eca6 6a01 	vstmia	r6!, {s12}
                    r1 = x[m];
 8023f6a:	ed14 6a01 	vldr	s12, [r4, #-4]
    for(uint32_t m=0; m<L;m++)
 8023f6e:	d1e9      	bne.n	8023f44 <tTalkboxFloat_warpedAutocorrelate+0x28>
                    r2 = dl[m];
    }
    for(uint32_t i=1; i<=P; i++)
 8023f70:	b3dd      	cbz	r5, 8023fea <tTalkboxFloat_warpedAutocorrelate+0xce>
 8023f72:	ea4f 0885 	mov.w	r8, r5, lsl #2
    {
            Rt[i]=0;
 8023f76:	2400      	movs	r4, #0
 8023f78:	1d15      	adds	r5, r2, #4
 8023f7a:	4694      	mov	ip, r2
 8023f7c:	f108 0804 	add.w	r8, r8, #4
 8023f80:	ee05 4a10 	vmov	s10, r4
 8023f84:	eb01 0783 	add.w	r7, r1, r3, lsl #2
 8023f88:	eb02 0908 	add.w	r9, r2, r8
 8023f8c:	eca5 5a01 	vstmia	r5!, {s10}
            r1=0;
            r2=0;
            for(unsigned int m=0; m<L;m++)
 8023f90:	b303      	cbz	r3, 8023fd4 <tTalkboxFloat_warpedAutocorrelate+0xb8>
 8023f92:	4606      	mov	r6, r0
 8023f94:	460c      	mov	r4, r1
 8023f96:	eeb0 7a45 	vmov.f32	s14, s10
            r2=0;
 8023f9a:	eef0 7a45 	vmov.f32	s15, s10
            r1=0;
 8023f9e:	eef0 6a45 	vmov.f32	s13, s10
 8023fa2:	e001      	b.n	8023fa8 <tTalkboxFloat_warpedAutocorrelate+0x8c>
 8023fa4:	ed15 7a01 	vldr	s14, [r5, #-4]
            {
                    Rt[i] +=  (dl[m]) * (x[m]);
 8023fa8:	edd4 5a00 	vldr	s11, [r4]
 8023fac:	ecb6 6a01 	vldmia	r6!, {s12}
 8023fb0:	eea5 7a86 	vfma.f32	s14, s11, s12
 8023fb4:	ed05 7a01 	vstr	s14, [r5, #-4]

                    r1t = dl[m];
 8023fb8:	ecb4 7a01 	vldmia	r4!, {s14}
                    dl[m]= r1 - lambda * (r1t-r2);
 8023fbc:	ee77 7ac7 	vsub.f32	s15, s15, s14
            for(unsigned int m=0; m<L;m++)
 8023fc0:	42a7      	cmp	r7, r4
                    dl[m]= r1 - lambda * (r1t-r2);
 8023fc2:	eee7 6a80 	vfma.f32	s13, s15, s0
 8023fc6:	eef0 7a66 	vmov.f32	s15, s13
                    r1 = r1t;
 8023fca:	eef0 6a47 	vmov.f32	s13, s14
                    dl[m]= r1 - lambda * (r1t-r2);
 8023fce:	ed44 7a01 	vstr	s15, [r4, #-4]
            for(unsigned int m=0; m<L;m++)
 8023fd2:	d1e7      	bne.n	8023fa4 <tTalkboxFloat_warpedAutocorrelate+0x88>
    for(uint32_t i=1; i<=P; i++)
 8023fd4:	45a9      	cmp	r9, r5
 8023fd6:	d1d9      	bne.n	8023f8c <tTalkboxFloat_warpedAutocorrelate+0x70>
 8023fd8:	4442      	add	r2, r8
                    r2 = dl[m];
            }
    }
    for(uint32_t i=0; i<=P; i++)
    {
            R[i]=Rt[i];
 8023fda:	f85c 3b04 	ldr.w	r3, [ip], #4
    for(uint32_t i=0; i<=P; i++)
 8023fde:	4562      	cmp	r2, ip
            R[i]=Rt[i];
 8023fe0:	f84e 3b04 	str.w	r3, [lr], #4
    for(uint32_t i=0; i<=P; i++)
 8023fe4:	d1f9      	bne.n	8023fda <tTalkboxFloat_warpedAutocorrelate+0xbe>
    }

}
 8023fe6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            R[i]=Rt[i];
 8023fea:	6813      	ldr	r3, [r2, #0]
 8023fec:	f8ce 3000 	str.w	r3, [lr]
}
 8023ff0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

08023ff4 <tTalkboxFloat_lpc>:
    return o;
}


void tTalkboxFloat_lpc(float *buf, float *car, float* dl, float* Rt, int32_t n, int32_t o, float warp, int warpOn, float *k, float *a, float *at, int freeze, float *G)
{
 8023ff4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8023ff8:	ed2d 8b02 	vpush	{d8}
 8023ffc:	b0c9      	sub	sp, #292	; 0x124
 8023ffe:	4604      	mov	r4, r0
 8024000:	9f56      	ldr	r7, [sp, #344]	; 0x158
 8024002:	9103      	str	r1, [sp, #12]
 8024004:	9d54      	ldr	r5, [sp, #336]	; 0x150
 8024006:	9e55      	ldr	r6, [sp, #340]	; 0x154
 8024008:	f8dd 816c 	ldr.w	r8, [sp, #364]	; 0x16c
    float z[ORD_MAX], r[ORD_MAX], x;
    int32_t i, j, nn=n;


	if (warpOn == 0)
 802400c:	2f00      	cmp	r7, #0
 802400e:	d042      	beq.n	8024096 <tTalkboxFloat_lpc+0xa2>
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
		}
	}
	else
	{
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 8024010:	2e00      	cmp	r6, #0
 8024012:	4691      	mov	r9, r2
 8024014:	469a      	mov	sl, r3
 8024016:	eeb0 8a40 	vmov.f32	s16, s0
 802401a:	f2c0 80c5 	blt.w	80241a8 <tTalkboxFloat_lpc+0x1b4>
		{
			z[j] = r[j] = 0.0f;
 802401e:	1c77      	adds	r7, r6, #1
 8024020:	f10d 0b98 	add.w	fp, sp, #152	; 0x98
 8024024:	2100      	movs	r1, #0
 8024026:	00bf      	lsls	r7, r7, #2
 8024028:	4658      	mov	r0, fp
 802402a:	463a      	mov	r2, r7
 802402c:	f006 fe65 	bl	802acfa <memset>
 8024030:	463a      	mov	r2, r7
 8024032:	2100      	movs	r1, #0
 8024034:	a804      	add	r0, sp, #16
 8024036:	f006 fe60 	bl	802acfa <memset>
		}
		tTalkboxFloat_warpedAutocorrelate(buf, dl, Rt, n, r, o, warp);
 802403a:	9601      	str	r6, [sp, #4]
 802403c:	eeb0 0a48 	vmov.f32	s0, s16
 8024040:	f8cd b000 	str.w	fp, [sp]
 8024044:	4652      	mov	r2, sl
 8024046:	4649      	mov	r1, r9
 8024048:	462b      	mov	r3, r5
 802404a:	4620      	mov	r0, r4
 802404c:	f7ff ff66 	bl	8023f1c <tTalkboxFloat_warpedAutocorrelate>
	}

	r[0] *= 1.001f;  //stability fix
 8024050:	f242 03c5 	movw	r3, #8389	; 0x20c5
 8024054:	ed9d 7a26 	vldr	s14, [sp, #152]	; 0x98
 8024058:	f6c3 7380 	movt	r3, #16256	; 0x3f80
 802405c:	ee07 3a90 	vmov	s15, r3

	float min = 0.000001f;
	if (!freeze)
 8024060:	9b5a      	ldr	r3, [sp, #360]	; 0x168
	r[0] *= 1.001f;  //stability fix
 8024062:	ee67 7a27 	vmul.f32	s15, s14, s15
 8024066:	edcd 7a26 	vstr	s15, [sp, #152]	; 0x98
	if (!freeze)
 802406a:	2b00      	cmp	r3, #0
 802406c:	d13e      	bne.n	80240ec <tTalkboxFloat_lpc+0xf8>
	{
		if(r[0] < min)
		{
            for(i=0; i<n; i++)
 802406e:	2d00      	cmp	r5, #0
 8024070:	dd6a      	ble.n	8024148 <tTalkboxFloat_lpc+0x154>
		if(r[0] < min)
 8024072:	f243 73bd 	movw	r3, #14269	; 0x37bd
 8024076:	f2c3 5386 	movt	r3, #13702	; 0x3586
 802407a:	ee07 3a10 	vmov	s14, r3
            for(i=0; i<n; i++)
 802407e:	eef4 7a47 	vcmp.f32	s15, s14
 8024082:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024086:	d55f      	bpl.n	8024148 <tTalkboxFloat_lpc+0x154>
            {
				buf[i] = 0.0f;
 8024088:	2300      	movs	r3, #0
 802408a:	6023      	str	r3, [r4, #0]
            x -= k[j] * z[j-1];
            z[j] = z[j-1] + k[j] * x;
        }
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
    }
}
 802408c:	b049      	add	sp, #292	; 0x124
 802408e:	ecbd 8b02 	vpop	{d8}
 8024092:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 8024096:	2e00      	cmp	r6, #0
 8024098:	dbda      	blt.n	8024050 <tTalkboxFloat_lpc+0x5c>
 802409a:	ea6f 0b06 	mvn.w	fp, r6
			z[j] = r[j] = 0.0f;
 802409e:	f04f 0900 	mov.w	r9, #0
 80240a2:	f10d 0e98 	add.w	lr, sp, #152	; 0x98
 80240a6:	f10d 0a10 	add.w	sl, sp, #16
 80240aa:	44ab      	add	fp, r5
 80240ac:	eb00 0085 	add.w	r0, r0, r5, lsl #2
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 80240b0:	46a4      	mov	ip, r4
 80240b2:	462f      	mov	r7, r5
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
 80240b4:	2f00      	cmp	r7, #0
			z[j] = r[j] = 0.0f;
 80240b6:	f84e 9b04 	str.w	r9, [lr], #4
 80240ba:	f84a 9b04 	str.w	r9, [sl], #4
			for(i=0; i<nn; i++) r[j] += buf[i] * buf[i+j]; //autocorrelation
 80240be:	dd0e      	ble.n	80240de <tTalkboxFloat_lpc+0xea>
 80240c0:	2100      	movs	r1, #0
 80240c2:	4662      	mov	r2, ip
 80240c4:	4623      	mov	r3, r4
 80240c6:	ee07 1a90 	vmov	s15, r1
 80240ca:	ecf3 6a01 	vldmia	r3!, {s13}
 80240ce:	ecb2 7a01 	vldmia	r2!, {s14}
 80240d2:	4298      	cmp	r0, r3
 80240d4:	eee6 7a87 	vfma.f32	s15, s13, s14
 80240d8:	d1f7      	bne.n	80240ca <tTalkboxFloat_lpc+0xd6>
 80240da:	ed4e 7a01 	vstr	s15, [lr, #-4]
		for(j=0; j<=o; j++, nn--)  //buf[] is already emphasized and windowed
 80240de:	3f01      	subs	r7, #1
 80240e0:	f10c 0c04 	add.w	ip, ip, #4
 80240e4:	3804      	subs	r0, #4
 80240e6:	45bb      	cmp	fp, r7
 80240e8:	d1e4      	bne.n	80240b4 <tTalkboxFloat_lpc+0xc0>
 80240ea:	e7b1      	b.n	8024050 <tTalkboxFloat_lpc+0x5c>
    for(i=0; i<n; i++)
 80240ec:	2d00      	cmp	r5, #0
 80240ee:	ddcd      	ble.n	802408c <tTalkboxFloat_lpc+0x98>
 80240f0:	1c77      	adds	r7, r6, #1
 80240f2:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 80240f4:	9803      	ldr	r0, [sp, #12]
 80240f6:	00bf      	lsls	r7, r7, #2
 80240f8:	1d19      	adds	r1, r3, #4
 80240fa:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 80240fe:	eb03 0c07 	add.w	ip, r3, r7
 8024102:	ab04      	add	r3, sp, #16
 8024104:	441f      	add	r7, r3
        x = G[0] * car[i];
 8024106:	ecb0 7a01 	vldmia	r0!, {s14}
        for(j=o; j>0; j--)  //lattice filter
 802410a:	2e00      	cmp	r6, #0
        x = G[0] * car[i];
 802410c:	edd8 7a00 	vldr	s15, [r8]
 8024110:	ee27 7a27 	vmul.f32	s14, s14, s15
        for(j=o; j>0; j--)  //lattice filter
 8024114:	dd0d      	ble.n	8024132 <tTalkboxFloat_lpc+0x13e>
 8024116:	463a      	mov	r2, r7
 8024118:	4663      	mov	r3, ip
            x -= k[j] * z[j-1];
 802411a:	ed73 6a01 	vldmdb	r3!, {s13}
 802411e:	ed52 7a02 	vldr	s15, [r2, #-8]
        for(j=o; j>0; j--)  //lattice filter
 8024122:	4299      	cmp	r1, r3
            x -= k[j] * z[j-1];
 8024124:	eea6 7ae7 	vfms.f32	s14, s13, s15
            z[j] = z[j-1] + k[j] * x;
 8024128:	eee6 7a87 	vfma.f32	s15, s13, s14
 802412c:	ed62 7a01 	vstmdb	r2!, {s15}
        for(j=o; j>0; j--)  //lattice filter
 8024130:	d1f3      	bne.n	802411a <tTalkboxFloat_lpc+0x126>
    for(i=0; i<n; i++)
 8024132:	4285      	cmp	r5, r0
        buf[i] = z[0] = x;  //output buf[] will be windowed elsewhere
 8024134:	ed8d 7a04 	vstr	s14, [sp, #16]
 8024138:	eca4 7a01 	vstmia	r4!, {s14}
    for(i=0; i<n; i++)
 802413c:	d1e3      	bne.n	8024106 <tTalkboxFloat_lpc+0x112>
}
 802413e:	b049      	add	sp, #292	; 0x124
 8024140:	ecbd 8b02 	vpop	{d8}
 8024144:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		tTalkbox_lpcDurbin(r, o, k, a, at, G);  //calc reflection coeffs
 8024148:	9a59      	ldr	r2, [sp, #356]	; 0x164
 802414a:	4631      	mov	r1, r6
 802414c:	f8cd 8004 	str.w	r8, [sp, #4]
 8024150:	a826      	add	r0, sp, #152	; 0x98
 8024152:	9200      	str	r2, [sp, #0]
 8024154:	9b58      	ldr	r3, [sp, #352]	; 0x160
 8024156:	9a57      	ldr	r2, [sp, #348]	; 0x15c
 8024158:	f7ff fd02 	bl	8023b60 <tTalkbox_lpcDurbin>
		for(i=0; i<=o; i++)
 802415c:	2e00      	cmp	r6, #0
 802415e:	dbc5      	blt.n	80240ec <tTalkboxFloat_lpc+0xf8>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
 8024160:	f647 43ee 	movw	r3, #31982	; 0x7cee
 8024164:	9a57      	ldr	r2, [sp, #348]	; 0x15c
 8024166:	4619      	mov	r1, r3
 8024168:	3204      	adds	r2, #4
 802416a:	f6c3 737f 	movt	r3, #16255	; 0x3f7f
 802416e:	f6cb 717f 	movt	r1, #49023	; 0xbf7f
 8024172:	eb02 0286 	add.w	r2, r2, r6, lsl #2
 8024176:	ee07 3a10 	vmov	s14, r3
 802417a:	9b57      	ldr	r3, [sp, #348]	; 0x15c
 802417c:	ee06 1a90 	vmov	s13, r1
 8024180:	e003      	b.n	802418a <tTalkboxFloat_lpc+0x196>
 8024182:	ed03 7a01 	vstr	s14, [r3, #-4]
		for(i=0; i<=o; i++)
 8024186:	429a      	cmp	r2, r3
 8024188:	d0b0      	beq.n	80240ec <tTalkboxFloat_lpc+0xf8>
			if(k[i] > 0.998f) k[i] = 0.998f; else if(k[i] < -0.998f) k[i] = -.998f;
 802418a:	ecf3 7a01 	vldmia	r3!, {s15}
 802418e:	eef4 7ac7 	vcmpe.f32	s15, s14
 8024192:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024196:	dcf4      	bgt.n	8024182 <tTalkboxFloat_lpc+0x18e>
 8024198:	eef4 7ae6 	vcmpe.f32	s15, s13
 802419c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80241a0:	bf48      	it	mi
 80241a2:	ed43 6a01 	vstrmi	s13, [r3, #-4]
 80241a6:	e7ee      	b.n	8024186 <tTalkboxFloat_lpc+0x192>
 80241a8:	f10d 0b98 	add.w	fp, sp, #152	; 0x98
 80241ac:	e745      	b.n	802403a <tTalkboxFloat_lpc+0x46>
 80241ae:	bf00      	nop

080241b0 <tTalkboxFloat_tick>:
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241b0:	f649 129a 	movw	r2, #39322	; 0x999a
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241b4:	f641 63b8 	movw	r3, #7864	; 0x1eb8
{
 80241b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241bc:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241c0:	f6c3 7345 	movt	r3, #16197	; 0x3f45
{
 80241c4:	ed2d 8b04 	vpush	{d8-d9}
    _tTalkboxFloat* v = *voc;
 80241c8:	6804      	ldr	r4, [r0, #0]
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241ca:	ee07 3a10 	vmov	s14, r3
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241ce:	ee06 2a90 	vmov	s13, r2
{
 80241d2:	b088      	sub	sp, #32
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241d4:	ed94 6a1d 	vldr	s12, [r4, #116]	; 0x74
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241d8:	edd4 7a19 	vldr	s15, [r4, #100]	; 0x64
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241dc:	edd4 5a1b 	vldr	s11, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241e0:	eee0 7a26 	vfma.f32	s15, s0, s13
    v->d4 = x;
 80241e4:	ed84 0a1d 	vstr	s0, [r4, #116]	; 0x74
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241e8:	eee6 5a07 	vfma.f32	s11, s12, s14
 80241ec:	6f23      	ldr	r3, [r4, #112]	; 0x70
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241ee:	6ea1      	ldr	r1, [r4, #104]	; 0x68
    if(v->K++)
 80241f0:	6ca2      	ldr	r2, [r4, #72]	; 0x48
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241f2:	66e3      	str	r3, [r4, #108]	; 0x6c
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 80241f4:	6661      	str	r1, [r4, #100]	; 0x64
 80241f6:	eea7 0ae6 	vfms.f32	s0, s15, s13
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 80241fa:	6d65      	ldr	r5, [r4, #84]	; 0x54
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 80241fc:	eea5 6ac7 	vfms.f32	s12, s11, s14
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8024200:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
    float e=v->emphasis, w, o, x, fx=v->FX;
 8024202:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
 8024206:	ed94 8a18 	vldr	s16, [r4, #96]	; 0x60
    p = v->d0 + h0 *  x; v->d0 = v->d1;  v->d1 = x  - h0 * p;
 802420a:	ed84 0a1a 	vstr	s0, [r4, #104]	; 0x68
    q = v->d2 + h1 * v->d4; v->d2 = v->d3;  v->d3 = v->d4 - h1 * q;
 802420e:	ed84 6a1c 	vstr	s12, [r4, #112]	; 0x70
    if(v->K++)
 8024212:	2a00      	cmp	r2, #0
 8024214:	d075      	beq.n	8024302 <tTalkboxFloat_tick+0x152>
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8024216:	2b00      	cmp	r3, #0
 8024218:	461e      	mov	r6, r3
        v->car0[p0] = v->car1[p1] = x; //carrier input
 802421a:	69e0      	ldr	r0, [r4, #28]
    x = p + q;
 802421c:	ee77 7aa5 	vadd.f32	s15, s15, s11
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8024220:	bfb8      	it	lt
 8024222:	1c5e      	addlt	r6, r3, #1
        v->K = 0;
 8024224:	2700      	movs	r7, #0
        v->car0[p0] = v->car1[p1] = x; //carrier input
 8024226:	00a9      	lsls	r1, r5, #2
        x = o - e;  e = o;  //6dB/oct pre-emphasis
 8024228:	ee70 8ac7 	vsub.f32	s17, s1, s14
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 802422c:	eb05 0266 	add.w	r2, r5, r6, asr #1
        v->K = 0;
 8024230:	64a7      	str	r7, [r4, #72]	; 0x48
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p0 = 0; }
 8024232:	3501      	adds	r5, #1
 8024234:	eeb0 9a60 	vmov.f32	s18, s1
    int32_t  p0=v->pos, p1 = (v->pos + v->N/2) % v->N;
 8024238:	fb92 f6f3 	sdiv	r6, r2, r3
 802423c:	fb03 2616 	mls	r6, r3, r6, r2
        v->car0[p0] = v->car1[p1] = x; //carrier input
 8024240:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8024244:	4440      	add	r0, r8
 8024246:	edc0 7a00 	vstr	s15, [r0]
 802424a:	69a3      	ldr	r3, [r4, #24]
 802424c:	440b      	add	r3, r1
 802424e:	edc3 7a00 	vstr	s15, [r3]
        w = v->window[p0]; fx = v->buf0[p0] * w;  v->buf0[p0] = x * w;  //50% overlapping hanning windows
 8024252:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
 8024256:	440a      	add	r2, r1
 8024258:	440b      	add	r3, r1
 802425a:	edd2 9a00 	vldr	s19, [r2]
 802425e:	ed93 8a00 	vldr	s16, [r3]
 8024262:	ee68 7aa9 	vmul.f32	s15, s17, s19
 8024266:	ee29 8a88 	vmul.f32	s16, s19, s16
 802426a:	edc3 7a00 	vstr	s15, [r3]
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p0 = 0; }
 802426e:	f8d4 c04c 	ldr.w	ip, [r4, #76]	; 0x4c
 8024272:	45ac      	cmp	ip, r5
 8024274:	dd63      	ble.n	802433e <tTalkboxFloat_tick+0x18e>
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
 8024276:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802427a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p1 = 0; }
 802427c:	3601      	adds	r6, #1
        w = 1.0f - w;  fx += v->buf1[p1] * w;  v->buf1[p1] = x * w;
 802427e:	4498      	add	r8, r3
 8024280:	ee77 7ae9 	vsub.f32	s15, s15, s19
 8024284:	edd8 6a00 	vldr	s13, [r8]
 8024288:	ee28 7aa7 	vmul.f32	s14, s17, s15
 802428c:	eea6 8aa7 	vfma.f32	s16, s13, s15
 8024290:	ed88 7a00 	vstr	s14, [r8]
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p1 = 0; }
 8024294:	6ce7      	ldr	r7, [r4, #76]	; 0x4c
 8024296:	42b7      	cmp	r7, r6
 8024298:	dd38      	ble.n	802430c <tTalkboxFloat_tick+0x15c>
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 802429a:	f649 129a 	movw	r2, #39322	; 0x999a
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 802429e:	f641 63b8 	movw	r3, #7864	; 0x1eb8
 80242a2:	edd4 6a22 	vldr	s13, [r4, #136]	; 0x88
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 80242a6:	eef0 5a48 	vmov.f32	s11, s16
 80242aa:	f6c3 6299 	movt	r2, #16025	; 0x3e99
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80242ae:	f6c3 7345 	movt	r3, #16197	; 0x3f45
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 80242b2:	ed94 0a1e 	vldr	s0, [r4, #120]	; 0x78
 80242b6:	ee07 2a10 	vmov	s14, r2
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80242ba:	ee07 3a90 	vmov	s15, r3
 80242be:	ed94 6a20 	vldr	s12, [r4, #128]	; 0x80
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 80242c2:	eea8 0a07 	vfma.f32	s0, s16, s14
 80242c6:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80242c8:	eea6 6aa7 	vfma.f32	s12, s13, s15
 80242cc:	f8d4 3084 	ldr.w	r3, [r4, #132]	; 0x84
    v->emphasis = e;
 80242d0:	ed84 9a11 	vstr	s18, [r4, #68]	; 0x44
    v->pos = p0;
 80242d4:	6565      	str	r5, [r4, #84]	; 0x54
    v->FX = fx;
 80242d6:	ed84 8a18 	vstr	s16, [r4, #96]	; 0x60
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 80242da:	67a2      	str	r2, [r4, #120]	; 0x78
 80242dc:	eee0 5a47 	vfms.f32	s11, s0, s14
    v->u4 = fx;
 80242e0:	ed84 8a22 	vstr	s16, [r4, #136]	; 0x88
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80242e4:	eee6 6a67 	vfms.f32	s13, s12, s15
 80242e8:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
}
 80242ec:	ee30 0a06 	vadd.f32	s0, s0, s12
    p = v->u0 + h0 * fx; v->u0 = v->u1;  v->u1 = fx - h0 * p;
 80242f0:	edc4 5a1f 	vstr	s11, [r4, #124]	; 0x7c
    q = v->u2 + h1 * v->u4; v->u2 = v->u3;  v->u3 = v->u4 - h1 * q;
 80242f4:	edc4 6a21 	vstr	s13, [r4, #132]	; 0x84
}
 80242f8:	b008      	add	sp, #32
 80242fa:	ecbd 8b04 	vpop	{d8-d9}
 80242fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(v->K++)
 8024302:	2301      	movs	r3, #1
    float e=v->emphasis, w, o, x, fx=v->FX;
 8024304:	eeb0 9a47 	vmov.f32	s18, s14
    if(v->K++)
 8024308:	64a3      	str	r3, [r4, #72]	; 0x48
 802430a:	e7c6      	b.n	802429a <tTalkboxFloat_tick+0xea>
        if(++p1 >= v->N) { tTalkboxFloat_lpc(v->buf1, v->car1, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p1 = 0; }
 802430c:	f104 068c 	add.w	r6, r4, #140	; 0x8c
 8024310:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 8024314:	69e1      	ldr	r1, [r4, #28]
 8024316:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8024318:	e9d4 2324 	ldrd	r2, r3, [r4, #144]	; 0x90
 802431c:	9607      	str	r6, [sp, #28]
 802431e:	6c26      	ldr	r6, [r4, #64]	; 0x40
 8024320:	9606      	str	r6, [sp, #24]
 8024322:	6b66      	ldr	r6, [r4, #52]	; 0x34
 8024324:	9605      	str	r6, [sp, #20]
 8024326:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8024328:	9604      	str	r6, [sp, #16]
 802432a:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 802432c:	9603      	str	r6, [sp, #12]
 802432e:	6be6      	ldr	r6, [r4, #60]	; 0x3c
 8024330:	9602      	str	r6, [sp, #8]
 8024332:	6d26      	ldr	r6, [r4, #80]	; 0x50
 8024334:	e9cd 7600 	strd	r7, r6, [sp]
 8024338:	f7ff fe5c 	bl	8023ff4 <tTalkboxFloat_lpc>
 802433c:	e7ad      	b.n	802429a <tTalkboxFloat_tick+0xea>
        if(++p0 >= v->N) { tTalkboxFloat_lpc(v->buf0, v->car0, v->dl, v->Rt, v->N, v->O, v->warpFactor, v->warpOn, v->k, v->a, v->at, v->freeze, &v->G);  p0 = 0; }
 802433e:	f104 0e8c 	add.w	lr, r4, #140	; 0x8c
 8024342:	ed94 0a0e 	vldr	s0, [r4, #56]	; 0x38
 8024346:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 802434a:	463d      	mov	r5, r7
 802434c:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8024350:	69a1      	ldr	r1, [r4, #24]
 8024352:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8024354:	f8cd e01c 	str.w	lr, [sp, #28]
 8024358:	6c27      	ldr	r7, [r4, #64]	; 0x40
 802435a:	9706      	str	r7, [sp, #24]
 802435c:	6b67      	ldr	r7, [r4, #52]	; 0x34
 802435e:	9705      	str	r7, [sp, #20]
 8024360:	6b27      	ldr	r7, [r4, #48]	; 0x30
 8024362:	9704      	str	r7, [sp, #16]
 8024364:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8024366:	9703      	str	r7, [sp, #12]
 8024368:	6be7      	ldr	r7, [r4, #60]	; 0x3c
 802436a:	9702      	str	r7, [sp, #8]
 802436c:	6d27      	ldr	r7, [r4, #80]	; 0x50
 802436e:	e9cd c700 	strd	ip, r7, [sp]
 8024372:	f7ff fe3f 	bl	8023ff4 <tTalkboxFloat_lpc>
 8024376:	e77e      	b.n	8024276 <tTalkboxFloat_tick+0xc6>

08024378 <tTalkboxFloat_setQuality>:

void tTalkboxFloat_setQuality(tTalkboxFloat* const voc, float quality)
{
    _tTalkboxFloat* v = *voc;
    v->param[3] = quality;
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 8024378:	f24b 7217 	movw	r2, #46871	; 0xb717
 802437c:	f249 41a0 	movw	r1, #38048	; 0x94a0
    _tTalkboxFloat* v = *voc;
 8024380:	6800      	ldr	r0, [r0, #0]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 8024382:	4613      	mov	r3, r2
 8024384:	f6c3 12d1 	movt	r2, #14801	; 0x39d1
 8024388:	f2c2 0101 	movt	r1, #8193	; 0x2001
    v->param[3] = quality;
 802438c:	ed80 0a04 	vstr	s0, [r0, #16]
    v->O = (int32_t)((0.0001f + 0.0004f * v->param[3]) * leaf.sampleRate);
 8024390:	f6c3 03d1 	movt	r3, #14545	; 0x38d1
 8024394:	ee07 2a10 	vmov	s14, r2
 8024398:	edd1 6a00 	vldr	s13, [r1]
 802439c:	ee07 3a90 	vmov	s15, r3
 80243a0:	eee0 7a07 	vfma.f32	s15, s0, s14
 80243a4:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80243a8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80243ac:	ee17 3a90 	vmov	r3, s15
    if (v->O >= ORD_MAX)
 80243b0:	2b21      	cmp	r3, #33	; 0x21
    {
    	v->O = ORD_MAX-1;
 80243b2:	bfc8      	it	gt
 80243b4:	2321      	movgt	r3, #33	; 0x21
 80243b6:	6503      	str	r3, [r0, #80]	; 0x50
    }
}
 80243b8:	4770      	bx	lr
 80243ba:	bf00      	nop

080243bc <tTalkboxFloat_setWarpFactor>:

void tTalkboxFloat_setWarpFactor(tTalkboxFloat* const voc, float warpFactor)
{
    _tTalkboxFloat* v = *voc;
 80243bc:	6803      	ldr	r3, [r0, #0]

    v->warpFactor = warpFactor;
 80243be:	ed83 0a0e 	vstr	s0, [r3, #56]	; 0x38
}
 80243c2:	4770      	bx	lr

080243c4 <tTalkboxFloat_setWarpOn>:

void tTalkboxFloat_setWarpOn(tTalkboxFloat* const voc, float warpOn)
{
    _tTalkboxFloat* v = *voc;

    v->warpOn = warpOn;
 80243c4:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
 80243c8:	6803      	ldr	r3, [r0, #0]
    v->warpOn = warpOn;
 80243ca:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
}
 80243ce:	4770      	bx	lr

080243d0 <tTalkboxFloat_setFreeze>:

void tTalkboxFloat_setFreeze(tTalkboxFloat* const voc, float freeze)
{
    _tTalkboxFloat* v = *voc;

    v->freeze = freeze;
 80243d0:	eebd 0ac0 	vcvt.s32.f32	s0, s0
    _tTalkboxFloat* v = *voc;
 80243d4:	6803      	ldr	r3, [r0, #0]
    v->freeze = freeze;
 80243d6:	ed83 0a10 	vstr	s0, [r3, #64]	; 0x40
}
 80243da:	4770      	bx	lr

080243dc <tRosenbergGlottalPulse_initToPool>:
{
    tRosenbergGlottalPulse_initToPool(gp, &leaf.mempool);
}

void tRosenbergGlottalPulse_initToPool (tRosenbergGlottalPulse* const gp, tMempool* const mp)
{
 80243dc:	b538      	push	{r3, r4, r5, lr}
     _tMempool* m = *mp;
 80243de:	680c      	ldr	r4, [r1, #0]
{
 80243e0:	4605      	mov	r5, r0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
 80243e2:	201c      	movs	r0, #28
 80243e4:	4621      	mov	r1, r4
 80243e6:	f003 fd01 	bl	8027dec <mpool_alloc>
    g->mempool = m;

    g->phase  = 0.0f;
 80243ea:	2300      	movs	r3, #0
    _tRosenbergGlottalPulse* g = *gp = (_tRosenbergGlottalPulse*) mpool_alloc(sizeof(_tRosenbergGlottalPulse), m);
 80243ec:	6028      	str	r0, [r5, #0]
    g->mempool = m;
 80243ee:	6004      	str	r4, [r0, #0]
    g->phase  = 0.0f;
 80243f0:	6043      	str	r3, [r0, #4]
    g->openLength = 0.0f;
 80243f2:	6083      	str	r3, [r0, #8]
    g->pulseLength = 0.0f;
 80243f4:	60c3      	str	r3, [r0, #12]
    g->freq = 0.0f;
 80243f6:	6143      	str	r3, [r0, #20]
    g->inc = 0.0f;
 80243f8:	6183      	str	r3, [r0, #24]


}
 80243fa:	bd38      	pop	{r3, r4, r5, pc}

080243fc <tRosenbergGlottalPulse_free>:
void tRosenbergGlottalPulse_free (tRosenbergGlottalPulse* const gp)
{
    _tRosenbergGlottalPulse* g = *gp;
 80243fc:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)g, g->mempool);
 80243fe:	6801      	ldr	r1, [r0, #0]
 8024400:	f003 bd9e 	b.w	8027f40 <mpool_free>

08024404 <tRosenbergGlottalPulse_tick>:
}

float   tRosenbergGlottalPulse_tick           (tRosenbergGlottalPulse* const gp)
{
 8024404:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
 8024406:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8024408:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
 802440c:	ed93 7a01 	vldr	s14, [r3, #4]
 8024410:	edd3 7a06 	vldr	s15, [r3, #24]
 8024414:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8024418:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
 802441c:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8024420:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024424:	db5a      	blt.n	80244dc <tRosenbergGlottalPulse_tick+0xd8>
 8024426:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 802442a:	eeb4 7ac6 	vcmpe.f32	s14, s12
 802442e:	ee77 7a66 	vsub.f32	s15, s14, s13
 8024432:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024436:	eeb0 7a67 	vmov.f32	s14, s15
 802443a:	daf6      	bge.n	802442a <tRosenbergGlottalPulse_tick+0x26>
 802443c:	edc3 7a01 	vstr	s15, [r3, #4]
    while (g->phase < 0.0f) g->phase += 1.0f;
 8024440:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024444:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024448:	d545      	bpl.n	80244d6 <tRosenbergGlottalPulse_tick+0xd2>
 802444a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802444e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8024452:	eef4 7ac7 	vcmpe.f32	s15, s14
 8024456:	ee37 0aa6 	vadd.f32	s0, s15, s13
 802445a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802445e:	eef0 7a40 	vmov.f32	s15, s0
 8024462:	d4f6      	bmi.n	8024452 <tRosenbergGlottalPulse_tick+0x4e>
 8024464:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
 8024468:	edd3 7a02 	vldr	s15, [r3, #8]
 802446c:	eef4 7ac0 	vcmpe.f32	s15, s0
 8024470:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024474:	dc1c      	bgt.n	80244b0 <tRosenbergGlottalPulse_tick+0xac>
    {
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
 8024476:	ed93 7a03 	vldr	s14, [r3, #12]
 802447a:	eeb4 7ac0 	vcmpe.f32	s14, s0
 802447e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024482:	dc03      	bgt.n	802448c <tRosenbergGlottalPulse_tick+0x88>
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
    }

    else
    {
        output = 0.0f;
 8024484:	2300      	movs	r3, #0
 8024486:	ee00 3a10 	vmov	s0, r3
    }
    return output;
}
 802448a:	bd08      	pop	{r3, pc}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 802448c:	f640 72db 	movw	r2, #4059	; 0xfdb
 8024490:	ed93 7a04 	vldr	s14, [r3, #16]
 8024494:	ee30 0a67 	vsub.f32	s0, s0, s15
 8024498:	f6c3 72c9 	movt	r2, #16329	; 0x3fc9
 802449c:	ee07 2a90 	vmov	s15, r2
 80244a0:	ee67 7a27 	vmul.f32	s15, s14, s15
}
 80244a4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = fastercosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 80244a8:	ee27 0a80 	vmul.f32	s0, s15, s0
 80244ac:	f003 b982 	b.w	80277b4 <fastercosf>
        output = 0.5f*(1.0f-fastercosf(PI * g->phase));
 80244b0:	f640 73db 	movw	r3, #4059	; 0xfdb
 80244b4:	f2c4 0349 	movt	r3, #16457	; 0x4049
 80244b8:	ee07 3a90 	vmov	s15, r3
 80244bc:	ee20 0a27 	vmul.f32	s0, s0, s15
 80244c0:	f003 f978 	bl	80277b4 <fastercosf>
 80244c4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80244c8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80244cc:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80244d0:	ee20 0a07 	vmul.f32	s0, s0, s14
}
 80244d4:	bd08      	pop	{r3, pc}
    while (g->phase < 0.0f) g->phase += 1.0f;
 80244d6:	eeb0 0a67 	vmov.f32	s0, s15
 80244da:	e7c5      	b.n	8024468 <tRosenbergGlottalPulse_tick+0x64>
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 80244dc:	eef0 7a47 	vmov.f32	s15, s14
 80244e0:	e7ae      	b.n	8024440 <tRosenbergGlottalPulse_tick+0x3c>
 80244e2:	bf00      	nop

080244e4 <tRosenbergGlottalPulse_tickHQ>:


float   tRosenbergGlottalPulse_tickHQ           (tRosenbergGlottalPulse* const gp)
{
 80244e4:	b508      	push	{r3, lr}
    _tRosenbergGlottalPulse* g = *gp;
 80244e6:	6803      	ldr	r3, [r0, #0]

    float output = 0.0f;

    // Phasor increment
    g->phase += g->inc;
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 80244e8:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    g->phase += g->inc;
 80244ec:	ed93 7a01 	vldr	s14, [r3, #4]
 80244f0:	edd3 7a06 	vldr	s15, [r3, #24]
 80244f4:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 80244f8:	eeb4 7ae6 	vcmpe.f32	s14, s13
    g->phase += g->inc;
 80244fc:	ed83 7a01 	vstr	s14, [r3, #4]
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 8024500:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024504:	db57      	blt.n	80245b6 <tRosenbergGlottalPulse_tickHQ+0xd2>
 8024506:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 802450a:	eeb4 7ac6 	vcmpe.f32	s14, s12
 802450e:	ee77 7a66 	vsub.f32	s15, s14, s13
 8024512:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024516:	eeb0 7a67 	vmov.f32	s14, s15
 802451a:	daf6      	bge.n	802450a <tRosenbergGlottalPulse_tickHQ+0x26>
    while (g->phase < 0.0f) g->phase += 1.0f;
 802451c:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024520:	edc3 7a01 	vstr	s15, [r3, #4]
 8024524:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024528:	d54c      	bpl.n	80245c4 <tRosenbergGlottalPulse_tickHQ+0xe0>
 802452a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802452e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 8024532:	eef4 7ac7 	vcmpe.f32	s15, s14
 8024536:	ee37 0aa6 	vadd.f32	s0, s15, s13
 802453a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802453e:	eef0 7a40 	vmov.f32	s15, s0
 8024542:	d4f6      	bmi.n	8024532 <tRosenbergGlottalPulse_tickHQ+0x4e>
 8024544:	ed83 0a01 	vstr	s0, [r3, #4]

    if (g->phase < g->openLength)
 8024548:	edd3 7a02 	vldr	s15, [r3, #8]
 802454c:	eef4 7ac0 	vcmpe.f32	s15, s0
 8024550:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024554:	dc1c      	bgt.n	8024590 <tRosenbergGlottalPulse_tickHQ+0xac>
    {
        output = 0.5f*(1.0f-cosf(PI * g->phase));
    }

    else if (g->phase < g->pulseLength)
 8024556:	ed93 7a03 	vldr	s14, [r3, #12]
 802455a:	eeb4 7ac0 	vcmpe.f32	s14, s0
 802455e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024562:	dd11      	ble.n	8024588 <tRosenbergGlottalPulse_tickHQ+0xa4>
    {
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8024564:	f640 72db 	movw	r2, #4059	; 0xfdb
 8024568:	ed93 7a04 	vldr	s14, [r3, #16]
 802456c:	ee30 0a67 	vsub.f32	s0, s0, s15
 8024570:	f6c3 72c9 	movt	r2, #16329	; 0x3fc9
 8024574:	ee07 2a90 	vmov	s15, r2
 8024578:	ee67 7a27 	vmul.f32	s15, s14, s15
    else
    {
        output = 0.0f;
    }
    return output;
}
 802457c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        output = cosf(HALF_PI * (g->phase-g->openLength)* g->invPulseLengthMinusOpenLength);
 8024580:	ee27 0a80 	vmul.f32	s0, s15, s0
 8024584:	f006 bcda 	b.w	802af3c <cosf>
        output = 0.0f;
 8024588:	2300      	movs	r3, #0
 802458a:	ee00 3a10 	vmov	s0, r3
}
 802458e:	bd08      	pop	{r3, pc}
        output = 0.5f*(1.0f-cosf(PI * g->phase));
 8024590:	f640 73db 	movw	r3, #4059	; 0xfdb
 8024594:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8024598:	ee07 3a90 	vmov	s15, r3
 802459c:	ee20 0a27 	vmul.f32	s0, s0, s15
 80245a0:	f006 fccc 	bl	802af3c <cosf>
 80245a4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80245a8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 80245ac:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80245b0:	ee20 0a07 	vmul.f32	s0, s0, s14
}
 80245b4:	bd08      	pop	{r3, pc}
    while (g->phase >= 1.0f) g->phase -= 1.0f;
 80245b6:	eef0 7a47 	vmov.f32	s15, s14
    while (g->phase < 0.0f) g->phase += 1.0f;
 80245ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80245be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80245c2:	d4b2      	bmi.n	802452a <tRosenbergGlottalPulse_tickHQ+0x46>
 80245c4:	eeb0 0a67 	vmov.f32	s0, s15
 80245c8:	e7be      	b.n	8024548 <tRosenbergGlottalPulse_tickHQ+0x64>
 80245ca:	bf00      	nop

080245cc <tRosenbergGlottalPulse_setFreq>:

void   tRosenbergGlottalPulse_setFreq           (tRosenbergGlottalPulse* const gp, float freq)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->freq = freq;
    g->inc = freq * leaf.invSampleRate;
 80245cc:	f249 43a0 	movw	r3, #38048	; 0x94a0
    _tRosenbergGlottalPulse* g = *gp;
 80245d0:	6802      	ldr	r2, [r0, #0]
    g->inc = freq * leaf.invSampleRate;
 80245d2:	f2c2 0301 	movt	r3, #8193	; 0x2001
    g->freq = freq;
 80245d6:	ed82 0a05 	vstr	s0, [r2, #20]
    g->inc = freq * leaf.invSampleRate;
 80245da:	edd3 7a01 	vldr	s15, [r3, #4]
 80245de:	ee27 0a80 	vmul.f32	s0, s15, s0
 80245e2:	ed82 0a06 	vstr	s0, [r2, #24]
}
 80245e6:	4770      	bx	lr

080245e8 <tRosenbergGlottalPulse_setOpenLength>:

void   tRosenbergGlottalPulse_setOpenLength           (tRosenbergGlottalPulse* const gp, float openLength)
{
    _tRosenbergGlottalPulse* g = *gp;
 80245e8:	6803      	ldr	r3, [r0, #0]
    g->openLength = openLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 80245ea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80245ee:	edd3 7a03 	vldr	s15, [r3, #12]
    g->openLength = openLength;
 80245f2:	ed83 0a02 	vstr	s0, [r3, #8]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 80245f6:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80245fa:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80245fe:	edc3 7a04 	vstr	s15, [r3, #16]
}
 8024602:	4770      	bx	lr

08024604 <tRosenbergGlottalPulse_setPulseLength>:

void   tRosenbergGlottalPulse_setPulseLength           (tRosenbergGlottalPulse* const gp, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
 8024604:	6803      	ldr	r3, [r0, #0]
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8024606:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802460a:	edd3 7a02 	vldr	s15, [r3, #8]
    g->pulseLength = pulseLength;
 802460e:	ed83 0a03 	vstr	s0, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8024612:	ee30 0a67 	vsub.f32	s0, s0, s15
 8024616:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802461a:	edc3 7a04 	vstr	s15, [r3, #16]
}
 802461e:	4770      	bx	lr

08024620 <tRosenbergGlottalPulse_setOpenLengthAndPulseLength>:
void   tRosenbergGlottalPulse_setOpenLengthAndPulseLength           (tRosenbergGlottalPulse* const gp, float openLength, float pulseLength)
{
    _tRosenbergGlottalPulse* g = *gp;
    g->openLength = openLength;
    g->pulseLength = pulseLength;
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8024620:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    _tRosenbergGlottalPulse* g = *gp;
 8024624:	6803      	ldr	r3, [r0, #0]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8024626:	ee30 7ac0 	vsub.f32	s14, s1, s0
    g->openLength = openLength;
 802462a:	ed83 0a02 	vstr	s0, [r3, #8]
    g->pulseLength = pulseLength;
 802462e:	edc3 0a03 	vstr	s1, [r3, #12]
    g->invPulseLengthMinusOpenLength = 1.0f / (g->pulseLength - g->openLength);
 8024632:	eec6 7a87 	vdiv.f32	s15, s13, s14
 8024636:	edc3 7a04 	vstr	s15, [r3, #16]
}
 802463a:	4770      	bx	lr

0802463c <tSOLAD_ioSamples>:
    mpool_free((char*)w, w->mempool);
}

// send one block of input samples, receive one block of output samples
void tSOLAD_ioSamples(tSOLAD* const wp, float* in, float* out, int blocksize)
{
 802463c:	b4f0      	push	{r4, r5, r6, r7}
 802463e:	ed2d 8b02 	vpush	{d8}
    _tSOLAD* w = *wp;
 8024642:	6800      	ldr	r0, [r0, #0]
 8024644:	b29f      	uxth	r7, r3
    
    int i = w->timeindex;
 8024646:	8884      	ldrh	r4, [r0, #4]
    int n = w->blocksize = blocksize;
 8024648:	80c3      	strh	r3, [r0, #6]
    
    if(!i) w->delaybuf[LOOPSIZE] = in[0];   // copy one sample for interpolation
 802464a:	b924      	cbnz	r4, 8024656 <tSOLAD_ioSamples+0x1a>
 802464c:	6a05      	ldr	r5, [r0, #32]
 802464e:	680e      	ldr	r6, [r1, #0]
 8024650:	f505 4580 	add.w	r5, r5, #16384	; 0x4000
 8024654:	602e      	str	r6, [r5, #0]
    while(n--) w->delaybuf[i++] = *in++;    // copy one input block to delay buffer
 8024656:	b167      	cbz	r7, 8024672 <tSOLAD_ioSamples+0x36>
 8024658:	eb01 0787 	add.w	r7, r1, r7, lsl #2
 802465c:	ebc1 0c84 	rsb	ip, r1, r4, lsl #2
 8024660:	eb0c 0601 	add.w	r6, ip, r1
 8024664:	6a04      	ldr	r4, [r0, #32]
 8024666:	f851 5b04 	ldr.w	r5, [r1], #4
 802466a:	4434      	add	r4, r6
 802466c:	428f      	cmp	r7, r1
 802466e:	6025      	str	r5, [r4, #0]
 8024670:	d1f6      	bne.n	8024660 <tSOLAD_ioSamples+0x24>
    
    if(w->pitchfactor > 1) pitchup(w, out);
 8024672:	eeb7 2a00 	vmov.f32	s4, #112	; 0x3f800000  1.0
 8024676:	edd0 6a02 	vldr	s13, [r0, #8]
 802467a:	8881      	ldrh	r1, [r0, #4]
 802467c:	edd0 3a04 	vldr	s7, [r0, #16]
 8024680:	eef4 6ac2 	vcmpe.f32	s13, s4
 8024684:	f501 5480 	add.w	r4, r1, #4096	; 0x1000
 8024688:	edd0 7a03 	vldr	s15, [r0, #12]
 802468c:	ee06 4a10 	vmov	s12, r4
 8024690:	88c6      	ldrh	r6, [r0, #6]
 8024692:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024696:	edd0 5a05 	vldr	s11, [r0, #20]
 802469a:	eeb8 6ac6 	vcvt.f32.s32	s12, s12
 802469e:	ed90 7a07 	vldr	s14, [r0, #28]
 80246a2:	ed90 3a06 	vldr	s6, [r0, #24]
 80246a6:	f340 80bc 	ble.w	8024822 <tSOLAD_ioSamples+0x1e6>
    float xfadelength = w->xfadelength;
    
    float readlagstep = pitchfactor - 1;
    float xfadespeed = pitchfactor * pitchfactor;
    float xfadestep = xfadespeed / xfadelength;
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
 80246aa:	f247 04a4 	movw	r4, #28836	; 0x70a4
    float xfadespeed = pitchfactor * pitchfactor;
 80246ae:	ee66 1aa6 	vmul.f32	s3, s13, s13
    float readlagstep = pitchfactor - 1;
 80246b2:	ee36 2ac2 	vsub.f32	s4, s13, s4
    float limitfactor = (pitchfactor - (float)0.99) / xfadespeed;
 80246b6:	f6c3 747d 	movt	r4, #16253	; 0x3f7d
 80246ba:	ee05 4a10 	vmov	s10, r4
 80246be:	ee76 6ac5 	vsub.f32	s13, s13, s10
 80246c2:	ee86 5aa1 	vdiv.f32	s10, s13, s3
    float limit = period * limitfactor;
 80246c6:	ee25 1a23 	vmul.f32	s2, s10, s7
    float readindex, outputsample;
    
    if((readlag > (period + 2 * limit)) & (xfadevalue < 0))
 80246ca:	ee71 6a01 	vadd.f32	s13, s2, s2
 80246ce:	ee76 4aa3 	vadd.f32	s9, s13, s7
 80246d2:	eef4 4a67 	vcmp.f32	s9, s15
 80246d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80246da:	f140 808a 	bpl.w	80247f2 <tSOLAD_ioSamples+0x1b6>
 80246de:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80246e2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80246e6:	f140 8084 	bpl.w	80247f2 <tSOLAD_ioSamples+0x1b6>
 80246ea:	ee77 6ae6 	vsub.f32	s13, s15, s13
    {
        jump = period;                                        // jump forward
 80246ee:	eef0 5a63 	vmov.f32	s11, s7
 80246f2:	e001      	b.n	80246f8 <tSOLAD_ioSamples+0xbc>
        while((jump * 2) < (readlag - 2 * limit)) jump *= 2;  // use available space
 80246f4:	eef0 5a47 	vmov.f32	s11, s14
 80246f8:	ee35 7aa5 	vadd.f32	s14, s11, s11
 80246fc:	eeb4 7ae6 	vcmpe.f32	s14, s13
 8024700:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024704:	d4f6      	bmi.n	80246f4 <tSOLAD_ioSamples+0xb8>
        readlag -= jump;                                      // reduce read pointer lag
        xfadevalue = 1;                                       // start crossfade
        xfadelength = period - 1;
 8024706:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
        readlag -= jump;                                      // reduce read pointer lag
 802470a:	ee77 7ae5 	vsub.f32	s15, s15, s11
        xfadelength = period - 1;
 802470e:	ee33 3ac7 	vsub.f32	s6, s7, s14
        xfadestep = xfadespeed / xfadelength;
 8024712:	eec1 0a83 	vdiv.f32	s1, s3, s6
    }
    
    while(n--)
 8024716:	1e75      	subs	r5, r6, #1
 8024718:	2e00      	cmp	r6, #0
 802471a:	d05a      	beq.n	80247d2 <tSOLAD_ioSamples+0x196>
 802471c:	eef7 2a00 	vmov.f32	s5, #112	; 0x3f800000  1.0
            {
                xfadelength = readlag / limitfactor;
                if(xfadelength < 1) xfadelength = 1;
                xfadestep = xfadespeed / xfadelength;
                
                jump = -period;         // jump backward
 8024720:	eeb1 8a63 	vneg.f32	s16, s7
 8024724:	ee82 0a85 	vdiv.f32	s0, s5, s10
        if(readlag < limit)  // check if read pointer should jump backward...
 8024728:	eeb4 1ae7 	vcmpe.f32	s2, s15
 802472c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024730:	dd0b      	ble.n	802474a <tSOLAD_ioSamples+0x10e>
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
 8024732:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
                xfadelength = readlag / limitfactor;
 8024736:	ee60 6a27 	vmul.f32	s13, s0, s15
            if((xfadevalue < 0) | (readlag < 0)) // ...but try not to interrupt crossfade
 802473a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802473e:	d465      	bmi.n	802480c <tSOLAD_ioSamples+0x1d0>
 8024740:	eef5 7a40 	vcmp.f32	s15, #0.0
 8024744:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024748:	d460      	bmi.n	802480c <tSOLAD_ioSamples+0x1d0>
                readlag += period;      // increase read pointer lag
                xfadevalue = 1;         // start crossfade
            }
        }
        
        readindex = refindex - readlag;
 802474a:	ee76 6a67 	vsub.f32	s13, s12, s15
        outputsample = read_sample(w, readindex);
 802474e:	6a01      	ldr	r1, [r0, #32]
        
        if(xfadevalue > 0)
 8024750:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
        {
            outputsample *= (1 - xfadevalue);
 8024754:	ee72 8ac7 	vsub.f32	s17, s5, s14
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 8024758:	ee36 4ae5 	vsub.f32	s8, s13, s11
}

// read one sample from delay buffer, with linear interpolation
static inline float read_sample(_tSOLAD* const w, float floatindex)
{
    int index = (int)floatindex;
 802475c:	eefd 4ae6 	vcvt.s32.f32	s9, s13
        if(xfadevalue > 0)
 8024760:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    int index = (int)floatindex;
 8024764:	eebd 5ac4 	vcvt.s32.f32	s10, s8
    float fraction = floatindex - (float)index;
    float *buf = w->delaybuf;
    index &= LOOPMASK;
 8024768:	ee14 4a90 	vmov	r4, s9
    float fraction = floatindex - (float)index;
 802476c:	eef8 4ae4 	vcvt.f32.s32	s9, s9
    index &= LOOPMASK;
 8024770:	f3c4 040b 	ubfx	r4, r4, #0, #12
 8024774:	ee15 6a10 	vmov	r6, s10
    float fraction = floatindex - (float)index;
 8024778:	eeb8 5ac5 	vcvt.f32.s32	s10, s10
    
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 802477c:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    float fraction = floatindex - (float)index;
 8024780:	ee76 6ae4 	vsub.f32	s13, s13, s9
    index &= LOOPMASK;
 8024784:	f3c6 060b 	ubfx	r6, r6, #0, #12
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8024788:	edd4 4a00 	vldr	s9, [r4]
    float fraction = floatindex - (float)index;
 802478c:	ee34 5a45 	vsub.f32	s10, s8, s10
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8024790:	ed94 4a01 	vldr	s8, [r4, #4]
 8024794:	eb01 0186 	add.w	r1, r1, r6, lsl #2
 8024798:	ee34 4a64 	vsub.f32	s8, s8, s9
 802479c:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
 80247a0:	dd2a      	ble.n	80247f8 <tSOLAD_ioSamples+0x1bc>
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 80247a2:	edd1 6a00 	vldr	s13, [r1]
    while(n--)
 80247a6:	3d01      	subs	r5, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 80247a8:	ed91 4a01 	vldr	s8, [r1, #4]
        refindex += 1;
 80247ac:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 80247b0:	1c6f      	adds	r7, r5, #1
        readlag -= readlagstep;
 80247b2:	ee77 7ac2 	vsub.f32	s15, s15, s4
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 80247b6:	ee34 4a66 	vsub.f32	s8, s8, s13
 80247ba:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 80247be:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
 80247c2:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;
 80247c6:	eee4 6aa8 	vfma.f32	s13, s9, s17
        *out++ = outputsample;
 80247ca:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
 80247ce:	d1ab      	bne.n	8024728 <tSOLAD_ioSamples+0xec>
 80247d0:	8881      	ldrh	r1, [r0, #4]
    w->readlag = readlag;               // state variables
 80247d2:	edc0 7a03 	vstr	s15, [r0, #12]
    w->jump = jump;
 80247d6:	edc0 5a05 	vstr	s11, [r0, #20]
    w->xfadelength = xfadelength;
 80247da:	ed80 3a06 	vstr	s6, [r0, #24]
    w->xfadevalue = xfadevalue;
 80247de:	ed80 7a07 	vstr	s14, [r0, #28]
    w->timeindex += blocksize;
 80247e2:	440b      	add	r3, r1
    w->timeindex &= LOOPMASK;
 80247e4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80247e8:	8083      	strh	r3, [r0, #4]
}
 80247ea:	ecbd 8b02 	vpop	{d8}
 80247ee:	bcf0      	pop	{r4, r5, r6, r7}
 80247f0:	4770      	bx	lr
    float xfadestep = xfadespeed / xfadelength;
 80247f2:	eec1 0a83 	vdiv.f32	s1, s3, s6
 80247f6:	e78e      	b.n	8024716 <tSOLAD_ioSamples+0xda>
    while(n--)
 80247f8:	3d01      	subs	r5, #1
        *out++ = outputsample;
 80247fa:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
 80247fe:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 8024802:	1c6e      	adds	r6, r5, #1
        readlag -= readlagstep;
 8024804:	ee77 7ac2 	vsub.f32	s15, s15, s4
    while(n--)
 8024808:	d18e      	bne.n	8024728 <tSOLAD_ioSamples+0xec>
 802480a:	e7e1      	b.n	80247d0 <tSOLAD_ioSamples+0x194>
 802480c:	fe86 3aa2 	vmaxnm.f32	s6, s13, s5
                jump = -period;         // jump backward
 8024810:	eef0 5a48 	vmov.f32	s11, s16
                xfadestep = xfadespeed / xfadelength;
 8024814:	eec1 0a83 	vdiv.f32	s1, s3, s6
                readlag += period;      // increase read pointer lag
 8024818:	ee77 7aa3 	vadd.f32	s15, s15, s7
                xfadevalue = 1;         // start crossfade
 802481c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8024820:	e793      	b.n	802474a <tSOLAD_ioSamples+0x10e>
    if(pitchfactor > 0.5) xfadespeed = pitchfactor;
 8024822:	eeb6 5a00 	vmov.f32	s10, #96	; 0x3f000000  0.5
    while(n--)
 8024826:	1e75      	subs	r5, r6, #1
    float readlagstep = 1 - pitchfactor;
 8024828:	ee72 1a66 	vsub.f32	s3, s4, s13
    else xfadespeed = 1 - pitchfactor;
 802482c:	eef4 6ac5 	vcmpe.f32	s13, s10
 8024830:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024834:	fe76 6aa1 	vselgt.f32	s13, s13, s3
    xfadestep = xfadespeed / xfadelength;
 8024838:	eec6 0a83 	vdiv.f32	s1, s13, s6
    while(n--)
 802483c:	2e00      	cmp	r6, #0
 802483e:	d053      	beq.n	80248e8 <tSOLAD_ioSamples+0x2ac>
        refindex += 1;
 8024840:	eef0 2a42 	vmov.f32	s5, s4
                xfadelength = period - 1;
 8024844:	ee33 2ac2 	vsub.f32	s4, s7, s4
                xfadestep = xfadespeed / xfadelength;
 8024848:	ee86 0a82 	vdiv.f32	s0, s13, s4
            if(xfadevalue <= 0)      // ...but do not interrupt crossfade
 802484c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8024850:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024854:	d804      	bhi.n	8024860 <tSOLAD_ioSamples+0x224>
 8024856:	eef4 7a63 	vcmp.f32	s15, s7
 802485a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802485e:	dc56      	bgt.n	802490e <tSOLAD_ioSamples+0x2d2>
        readindex = refindex - readlag;
 8024860:	ee36 5a67 	vsub.f32	s10, s12, s15
        outputsample = read_sample(w, readindex);
 8024864:	6a04      	ldr	r4, [r0, #32]
        if(xfadevalue > 0)
 8024866:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
    int index = (int)floatindex;
 802486a:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        if(xfadevalue > 0)
 802486e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    index &= LOOPMASK;
 8024872:	ee16 1a90 	vmov	r1, s13
    float fraction = floatindex - (float)index;
 8024876:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
 802487a:	f3c1 010b 	ubfx	r1, r1, #0, #12
    float fraction = floatindex - (float)index;
 802487e:	ee75 6a66 	vsub.f32	s13, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 8024882:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 8024886:	edd1 4a00 	vldr	s9, [r1]
 802488a:	ed91 4a01 	vldr	s8, [r1, #4]
 802488e:	ee34 4a64 	vsub.f32	s8, s8, s9
 8024892:	eee6 4a84 	vfma.f32	s9, s13, s8
        if(xfadevalue > 0)
 8024896:	dd30      	ble.n	80248fa <tSOLAD_ioSamples+0x2be>
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 8024898:	ee35 5a65 	vsub.f32	s10, s10, s11
    while(n--)
 802489c:	3d01      	subs	r5, #1
            outputsample *= (1 - xfadevalue);                               // fadein
 802489e:	ee32 1ac7 	vsub.f32	s2, s5, s14
        refindex += 1;
 80248a2:	ee36 6a22 	vadd.f32	s12, s12, s5
    int index = (int)floatindex;
 80248a6:	eefd 6ac5 	vcvt.s32.f32	s13, s10
        readlag += readlagstep;
 80248aa:	ee77 7aa1 	vadd.f32	s15, s15, s3
    index &= LOOPMASK;
 80248ae:	ee16 1a90 	vmov	r1, s13
    float fraction = floatindex - (float)index;
 80248b2:	eef8 6ae6 	vcvt.f32.s32	s13, s13
    index &= LOOPMASK;
 80248b6:	f3c1 010b 	ubfx	r1, r1, #0, #12
    float fraction = floatindex - (float)index;
 80248ba:	ee35 5a66 	vsub.f32	s10, s10, s13
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 80248be:	eb04 0481 	add.w	r4, r4, r1, lsl #2
 80248c2:	edd4 6a00 	vldr	s13, [r4]
 80248c6:	ed94 4a01 	vldr	s8, [r4, #4]
    while(n--)
 80248ca:	1c6c      	adds	r4, r5, #1
    return (buf[index] + (fraction * (buf[index+1] - buf[index])));
 80248cc:	ee34 4a66 	vsub.f32	s8, s8, s13
 80248d0:	eee5 6a04 	vfma.f32	s13, s10, s8
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 80248d4:	ee66 6a87 	vmul.f32	s13, s13, s14
            xfadevalue -= xfadestep;
 80248d8:	ee37 7a60 	vsub.f32	s14, s14, s1
            outputsample += read_sample(w, readindex - jump) * xfadevalue;  // fadeout
 80248dc:	eee4 6a81 	vfma.f32	s13, s9, s2
        *out++ = outputsample;
 80248e0:	ece2 6a01 	vstmia	r2!, {s13}
    while(n--)
 80248e4:	d1b2      	bne.n	802484c <tSOLAD_ioSamples+0x210>
 80248e6:	8881      	ldrh	r1, [r0, #4]
    w->jump = jump;                 // state variables
 80248e8:	edc0 5a05 	vstr	s11, [r0, #20]
    w->readlag = readlag;
 80248ec:	edc0 7a03 	vstr	s15, [r0, #12]
    w->xfadevalue = xfadevalue;
 80248f0:	ed80 7a07 	vstr	s14, [r0, #28]
    w->xfadelength = xfadelength;
 80248f4:	ed80 3a06 	vstr	s6, [r0, #24]
 80248f8:	e773      	b.n	80247e2 <tSOLAD_ioSamples+0x1a6>
    while(n--)
 80248fa:	3d01      	subs	r5, #1
        *out++ = outputsample;
 80248fc:	ece2 4a01 	vstmia	r2!, {s9}
        refindex += 1;
 8024900:	ee36 6a22 	vadd.f32	s12, s12, s5
    while(n--)
 8024904:	1c69      	adds	r1, r5, #1
        readlag += readlagstep;
 8024906:	ee77 7aa1 	vadd.f32	s15, s15, s3
    while(n--)
 802490a:	d19f      	bne.n	802484c <tSOLAD_ioSamples+0x210>
 802490c:	e7eb      	b.n	80248e6 <tSOLAD_ioSamples+0x2aa>
                jump = period;                           // jump forward
 802490e:	eef0 5a63 	vmov.f32	s11, s7
 8024912:	e001      	b.n	8024918 <tSOLAD_ioSamples+0x2dc>
                while((jump * 2) < readlag) jump *= 2;   // use available space
 8024914:	eef0 5a47 	vmov.f32	s11, s14
 8024918:	ee35 7aa5 	vadd.f32	s14, s11, s11
 802491c:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8024920:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024924:	d4f6      	bmi.n	8024914 <tSOLAD_ioSamples+0x2d8>
                readlag -= jump;                         // reduce read pointer lag
 8024926:	ee77 7ae5 	vsub.f32	s15, s15, s11
                xfadestep = xfadespeed / xfadelength;
 802492a:	eef0 0a40 	vmov.f32	s1, s0
                xfadevalue = 1;                          // start crossfade
 802492e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
                xfadelength = period - 1;
 8024932:	eeb0 3a42 	vmov.f32	s6, s4
 8024936:	e793      	b.n	8024860 <tSOLAD_ioSamples+0x224>

08024938 <tRetune_initToPool>:
{
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tRetune_initToPool (tRetune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
 8024938:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802493c:	ed2d 8b02 	vpush	{d8}
 8024940:	b085      	sub	sp, #20
 8024942:	4604      	mov	r4, r0
 8024944:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
 8024946:	203c      	movs	r0, #60	; 0x3c
{
 8024948:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 802494c:	4617      	mov	r7, r2
 802494e:	469a      	mov	sl, r3
    _tMempool* m = *mp;
 8024950:	f8d8 6000 	ldr.w	r6, [r8]
    _tRetune* r = *rt = (_tRetune*) mpool_alloc(sizeof(_tRetune), m);
 8024954:	4631      	mov	r1, r6
 8024956:	f003 fa49 	bl	8027dec <mpool_alloc>
 802495a:	4605      	mov	r5, r0
 802495c:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 802495e:	4631      	mov	r1, r6
    r->mempool = *mp;
 8024960:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
 8024964:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8024968:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
 802496a:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
 802496c:	61ef      	str	r7, [r5, #28]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
    
    r->hopSize = DEFHOPSIZE;
 802496e:	f04f 1740 	mov.w	r7, #4194368	; 0x400040
    r->numVoices = numVoices;
 8024972:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 8024976:	f003 fa8f 	bl	8027e98 <mpool_calloc>
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 802497a:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->inBuffer = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 802497c:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 802497e:	4631      	mov	r1, r6
 8024980:	0098      	lsls	r0, r3, #2
 8024982:	f003 fa89 	bl	8027e98 <mpool_calloc>
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
 8024986:	2114      	movs	r1, #20
void tRetune_setTimeConstant(tRetune* const rt, float tc)
{
    _tRetune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024988:	f249 42a0 	movw	r2, #38048	; 0x94a0
    r->outBuffers = (float**) mpool_calloc(sizeof(float*) * r->numVoices, m);
 802498c:	6128      	str	r0, [r5, #16]
    r->fba = FBA;
 802498e:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024992:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->hopSize = DEFHOPSIZE;
 8024996:	622f      	str	r7, [r5, #32]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024998:	f2c2 0201 	movt	r2, #8193	; 0x2001
    _tRetune* r = *rt;
 802499c:	6824      	ldr	r4, [r4, #0]
    r->timeConstant = tc;
 802499e:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80249a0:	ed92 0a01 	vldr	s0, [r2, #4]
 80249a4:	8c22      	ldrh	r2, [r4, #32]
    r->timeConstant = tc;
 80249a6:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80249aa:	ee20 0a07 	vmul.f32	s0, s0, s14
 80249ae:	ee07 2a90 	vmov	s15, r2
    r->timeConstant = tc;
 80249b2:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80249b4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80249b8:	ee20 0a27 	vmul.f32	s0, s0, s15
 80249bc:	f006 fafe 	bl	802afbc <expf>
    r->inputPeriod = 0.0f;
 80249c0:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 80249c2:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 80249c6:	4631      	mov	r1, r6
 80249c8:	6ba8      	ldr	r0, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
 80249ca:	636b      	str	r3, [r5, #52]	; 0x34
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 80249cc:	0080      	lsls	r0, r0, #2
 80249ce:	f003 fa63 	bl	8027e98 <mpool_calloc>
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249d2:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->ps = (tPitchShift*) mpool_calloc(sizeof(tPitchShift) * r->numVoices, m);
 80249d4:	60a8      	str	r0, [r5, #8]
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249d6:	4631      	mov	r1, r6
 80249d8:	0098      	lsls	r0, r3, #2
 80249da:	f003 fa5d 	bl	8027e98 <mpool_calloc>
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249de:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->pitchFactor = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249e0:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249e2:	4631      	mov	r1, r6
 80249e4:	0098      	lsls	r0, r3, #2
 80249e6:	f003 fa57 	bl	8027e98 <mpool_calloc>
    for (int i = 0; i < r->numVoices; ++i)
 80249ea:	6bab      	ldr	r3, [r5, #56]	; 0x38
    r->tickOutput = (float*) mpool_calloc(sizeof(float) * r->numVoices, m);
 80249ec:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
 80249ee:	2b00      	cmp	r3, #0
 80249f0:	dd0c      	ble.n	8024a0c <tRetune_initToPool+0xd4>
 80249f2:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_calloc(sizeof(float) * r->bufSize, m);
 80249f4:	69e8      	ldr	r0, [r5, #28]
 80249f6:	4631      	mov	r1, r6
 80249f8:	692f      	ldr	r7, [r5, #16]
 80249fa:	0080      	lsls	r0, r0, #2
 80249fc:	f003 fa4c 	bl	8027e98 <mpool_calloc>
 8024a00:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8024a04:	3401      	adds	r4, #1
 8024a06:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8024a08:	42a3      	cmp	r3, r4
 8024a0a:	dcf3      	bgt.n	80249f4 <tRetune_initToPool+0xbc>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
 8024a0c:	692a      	ldr	r2, [r5, #16]
 8024a0e:	1d28      	adds	r0, r5, #4
 8024a10:	69eb      	ldr	r3, [r5, #28]
 8024a12:	6812      	ldr	r2, [r2, #0]
 8024a14:	68e9      	ldr	r1, [r5, #12]
 8024a16:	f8cd 8004 	str.w	r8, [sp, #4]
 8024a1a:	69ac      	ldr	r4, [r5, #24]
 8024a1c:	9003      	str	r0, [sp, #12]
 8024a1e:	9400      	str	r4, [sp, #0]
 8024a20:	f7fe f85a 	bl	8022ad8 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
 8024a24:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8024a26:	2b00      	cmp	r3, #0
 8024a28:	dd5b      	ble.n	8024ae2 <tRetune_initToPool+0x1aa>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024a2a:	2300      	movs	r3, #0
    w->period = INITPERIOD;
 8024a2c:	f04f 4985 	mov.w	r9, #1115684864	; 0x42800000
    for (int i = 0; i < r->numVoices; ++i)
 8024a30:	461f      	mov	r7, r3
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024a32:	f2c4 2320 	movt	r3, #16928	; 0x4220
 8024a36:	ee08 3a90 	vmov	s17, r3
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024a3a:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024a3c:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
 8024a3e:	f8d8 b000 	ldr.w	fp, [r8]
    ps->pitchFactor = 1.0f;
 8024a42:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024a46:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024a4a:	4659      	mov	r1, fp
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024a4c:	69ee      	ldr	r6, [r5, #28]
 8024a4e:	f8d5 a008 	ldr.w	sl, [r5, #8]
 8024a52:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024a54:	f003 fa20 	bl	8027e98 <mpool_calloc>
    ps->outBuffer = out;
 8024a58:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024a5a:	4604      	mov	r4, r0
    ps->curBlock = 1;
 8024a5c:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
 8024a60:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024a62:	f84a 4027 	str.w	r4, [sl, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024a66:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
 8024a68:	f8c4 b000 	str.w	fp, [r4]
    for (int i = 0; i < r->numVoices; ++i)
 8024a6c:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
 8024a6e:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
 8024a70:	6121      	str	r1, [r4, #16]
    ps->p = pd;
 8024a72:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
 8024a74:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
 8024a76:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
 8024a78:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
 8024a7a:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
 8024a7e:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
 8024a80:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 8024a84:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
 8024a88:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 8024a8c:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
 8024a8e:	f8d8 b000 	ldr.w	fp, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024a92:	4659      	mov	r1, fp
 8024a94:	f003 fa00 	bl	8027e98 <mpool_calloc>
 8024a98:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024a9a:	4659      	mov	r1, fp
 8024a9c:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024aa0:	6066      	str	r6, [r4, #4]
    w->mempool = m;
 8024aa2:	f8c6 b000 	str.w	fp, [r6]
    w->pitchfactor = 1.;
 8024aa6:	ed86 8a02 	vstr	s16, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024aaa:	f003 f9f5 	bl	8027e98 <mpool_calloc>
    w->xfadevalue = -1;
 8024aae:	2200      	movs	r2, #0
    w->timeindex = 0;
 8024ab0:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024ab4:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
 8024ab6:	f6cb 7280 	movt	r2, #49024	; 0xbf80
    w->period = INITPERIOD;
 8024aba:	f8c6 9010 	str.w	r9, [r6, #16]
    w->timeindex = 0;
 8024abe:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024ac0:	f104 0008 	add.w	r0, r4, #8
    w->xfadevalue = -1;
 8024ac4:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024ac6:	4641      	mov	r1, r8
    w->readlag = INITPERIOD;
 8024ac8:	f8c6 900c 	str.w	r9, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024acc:	eeb0 0a68 	vmov.f32	s0, s17
 8024ad0:	f001 fd7a 	bl	80265c8 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
 8024ad4:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
 8024ad6:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8024ada:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
 8024adc:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8024ade:	42bb      	cmp	r3, r7
 8024ae0:	dcab      	bgt.n	8024a3a <tRetune_initToPool+0x102>
}
 8024ae2:	b005      	add	sp, #20
 8024ae4:	ecbd 8b02 	vpop	{d8}
 8024ae8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08024aec <tRetune_init>:
{
 8024aec:	b510      	push	{r4, lr}
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 8024aee:	f249 44b8 	movw	r4, #38072	; 0x94b8
{
 8024af2:	b082      	sub	sp, #8
    tRetune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 8024af4:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8024af8:	9400      	str	r4, [sp, #0]
 8024afa:	f7ff ff1d 	bl	8024938 <tRetune_initToPool>
}
 8024afe:	b002      	add	sp, #8
 8024b00:	bd10      	pop	{r4, pc}
 8024b02:	bf00      	nop

08024b04 <tRetune_free>:
{
 8024b04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tRetune* r = *rt;
 8024b06:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
 8024b08:	1d20      	adds	r0, r4, #4
 8024b0a:	f7fe f845 	bl	8022b98 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
 8024b0e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024b10:	2b00      	cmp	r3, #0
 8024b12:	dd1e      	ble.n	8024b52 <tRetune_free+0x4e>
 8024b14:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
 8024b16:	68a3      	ldr	r3, [r4, #8]
 8024b18:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
 8024b1c:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
 8024b1e:	6839      	ldr	r1, [r7, #0]
 8024b20:	6a38      	ldr	r0, [r7, #32]
 8024b22:	f003 fa0d 	bl	8027f40 <mpool_free>
    mpool_free((char*)w, w->mempool);
 8024b26:	6839      	ldr	r1, [r7, #0]
 8024b28:	4638      	mov	r0, r7
 8024b2a:	f003 fa09 	bl	8027f40 <mpool_free>
    tHighpass_free(&ps->hp);
 8024b2e:	f106 0008 	add.w	r0, r6, #8
 8024b32:	f001 fd6b 	bl	802660c <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
 8024b36:	6831      	ldr	r1, [r6, #0]
 8024b38:	4630      	mov	r0, r6
 8024b3a:	f003 fa01 	bl	8027f40 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8024b3e:	6923      	ldr	r3, [r4, #16]
 8024b40:	6821      	ldr	r1, [r4, #0]
 8024b42:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8024b46:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8024b48:	f003 f9fa 	bl	8027f40 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
 8024b4c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8024b4e:	42ab      	cmp	r3, r5
 8024b50:	dce1      	bgt.n	8024b16 <tRetune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
 8024b52:	6821      	ldr	r1, [r4, #0]
 8024b54:	6960      	ldr	r0, [r4, #20]
 8024b56:	f003 f9f3 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->pitchFactor, r->mempool);
 8024b5a:	6821      	ldr	r1, [r4, #0]
 8024b5c:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8024b5e:	f003 f9ef 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
 8024b62:	6821      	ldr	r1, [r4, #0]
 8024b64:	68a0      	ldr	r0, [r4, #8]
 8024b66:	f003 f9eb 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
 8024b6a:	6821      	ldr	r1, [r4, #0]
 8024b6c:	68e0      	ldr	r0, [r4, #12]
 8024b6e:	f003 f9e7 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
 8024b72:	6821      	ldr	r1, [r4, #0]
 8024b74:	6920      	ldr	r0, [r4, #16]
 8024b76:	f003 f9e3 	bl	8027f40 <mpool_free>
    mpool_free((char*)r, r->mempool);
 8024b7a:	6821      	ldr	r1, [r4, #0]
 8024b7c:	4620      	mov	r0, r4
}
 8024b7e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 8024b82:	f003 b9dd 	b.w	8027f40 <mpool_free>
 8024b86:	bf00      	nop

08024b88 <tRetune_tick>:
{
 8024b88:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8024b8c:	ed2d 8b04 	vpush	{d8-d9}
    _tRetune* r = *rt;
 8024b90:	6807      	ldr	r7, [r0, #0]
{
 8024b92:	b083      	sub	sp, #12
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
 8024b94:	1d38      	adds	r0, r7, #4
 8024b96:	f7fe f821 	bl	8022bdc <tPeriodDetection_tick>
    for (int v = 0; v < r->numVoices; ++v)
 8024b9a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
    r->inputPeriod = tPeriodDetection_tick(&r->pd, sample);
 8024b9c:	ed87 0a0d 	vstr	s0, [r7, #52]	; 0x34
    for (int v = 0; v < r->numVoices; ++v)
 8024ba0:	2b00      	cmp	r3, #0
 8024ba2:	f340 808a 	ble.w	8024cba <tRetune_tick+0x132>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024ba6:	2300      	movs	r3, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
 8024ba8:	f64c 42cd 	movw	r2, #52429	; 0xcccd
    for (int v = 0; v < r->numVoices; ++v)
 8024bac:	461d      	mov	r5, r3
    if(period > MAXPERIOD) period = MAXPERIOD;
 8024bae:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024bb2:	f2c4 2370 	movt	r3, #17008	; 0x4270
    if(period > MAXPERIOD) period = MAXPERIOD;
 8024bb6:	ee08 2a90 	vmov	s17, r2
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024bba:	ee09 3a10 	vmov	s18, r3
 8024bbe:	e005      	b.n	8024bcc <tRetune_tick+0x44>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 8024bc0:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
 8024bc4:	3501      	adds	r5, #1
 8024bc6:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8024bc8:	42ab      	cmp	r3, r5
 8024bca:	dd76      	ble.n	8024cba <tRetune_tick+0x132>
    _tPitchShift* ps = *psr;
 8024bcc:	68bb      	ldr	r3, [r7, #8]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 8024bce:	697e      	ldr	r6, [r7, #20]
    _tPitchShift* ps = *psr;
 8024bd0:	f853 4025 	ldr.w	r4, [r3, r5, lsl #2]
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 8024bd4:	eb06 0685 	add.w	r6, r6, r5, lsl #2
    _tPeriodDetection* p = *ps->p;
 8024bd8:	68e2      	ldr	r2, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8024bda:	f104 0008 	add.w	r0, r4, #8
 8024bde:	6923      	ldr	r3, [r4, #16]
    _tPeriodDetection* p = *ps->p;
 8024be0:	6812      	ldr	r2, [r2, #0]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8024be2:	6b11      	ldr	r1, [r2, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
 8024be4:	9201      	str	r2, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8024be6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
    i = p->i;
 8024bea:	f8d2 8028 	ldr.w	r8, [r2, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8024bee:	ed93 0a00 	vldr	s0, [r3]
 8024bf2:	f001 fd1f 	bl	8026634 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
 8024bf6:	9a01      	ldr	r2, [sp, #4]
 8024bf8:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8024bfa:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->indexstore >= ps->frameSize)
 8024bfe:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8024c00:	429a      	cmp	r2, r3
 8024c02:	dbdd      	blt.n	8024bc0 <tRetune_tick+0x38>
        period = tPeriodDetection_getPeriod(&p);
 8024c04:	a801      	add	r0, sp, #4
 8024c06:	f7fe f877 	bl	8022cf8 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
 8024c0a:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
 8024c0c:	eef0 9a40 	vmov.f32	s19, s0
    _tPeriodDetection* p = *ps->p;
 8024c10:	f8d3 9000 	ldr.w	r9, [r3]
    envout = tEnvPD_tick(&p->env);
 8024c14:	f109 0004 	add.w	r0, r9, #4
 8024c18:	f7fd fc5a 	bl	80224d0 <tEnvPD_tick>
    if (envout >= 1.0f)
 8024c1c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8024c20:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8024c24:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c28:	db0e      	blt.n	8024c48 <tRetune_tick+0xc0>
        p->lastmax = p->max;
 8024c2a:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
        if (envout > p->max)
 8024c2e:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
 8024c32:	edc9 7a14 	vstr	s15, [r9, #80]	; 0x50
 8024c36:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
 8024c3a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c3e:	dd6e      	ble.n	8024d1e <tRetune_tick+0x196>
            p->max = envout;
 8024c40:	ed89 0a13 	vstr	s0, [r9, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
 8024c44:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
 8024c48:	f899 3040 	ldrb.w	r3, [r9, #64]	; 0x40
 8024c4c:	9901      	ldr	r1, [sp, #4]
 8024c4e:	2b00      	cmp	r3, #0
 8024c50:	d039      	beq.n	8024cc6 <tRetune_tick+0x13e>
 8024c52:	3b01      	subs	r3, #1
 8024c54:	b2db      	uxtb	r3, r3
 8024c56:	f889 3040 	strb.w	r3, [r9, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024c5a:	b3a3      	cbz	r3, 8024cc6 <tRetune_tick+0x13e>
 8024c5c:	6862      	ldr	r2, [r4, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
 8024c5e:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 8024c60:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
 8024c64:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 8024c68:	ee00 3a10 	vmov	s0, r3
 8024c6c:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 8024c70:	ee20 0a28 	vmul.f32	s0, s0, s17
 8024c74:	fe80 0a69 	vminnm.f32	s0, s0, s19
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 8024c78:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8024c7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024c80:	dd02      	ble.n	8024c88 <tRetune_tick+0x100>
 8024c82:	ed82 0a04 	vstr	s0, [r2, #16]
 8024c86:	6862      	ldr	r2, [r4, #4]
        tSOLAD_setPitchFactor(&ps->sola, ps->pitchFactor);
 8024c88:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 8024c8c:	ea4f 0888 	mov.w	r8, r8, lsl #2
 8024c90:	1d20      	adds	r0, r4, #4
    for (int v = 0; v < r->numVoices; ++v)
 8024c92:	3501      	adds	r5, #1
    if (pitchfactor <= 0.0f) return;
 8024c94:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8024c98:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    w->pitchfactor = pitchfactor;
 8024c9c:	bf88      	it	hi
 8024c9e:	edc2 7a02 	vstrhi	s15, [r2, #8]
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 8024ca2:	68c9      	ldr	r1, [r1, #12]
 8024ca4:	6922      	ldr	r2, [r4, #16]
 8024ca6:	6963      	ldr	r3, [r4, #20]
 8024ca8:	4441      	add	r1, r8
 8024caa:	4442      	add	r2, r8
 8024cac:	f7ff fcc6 	bl	802463c <tSOLAD_ioSamples>
        r->tickOutput[v] = tPitchShift_shift(&r->ps[v]);
 8024cb0:	ed86 8a00 	vstr	s16, [r6]
    for (int v = 0; v < r->numVoices; ++v)
 8024cb4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8024cb6:	42ab      	cmp	r3, r5
 8024cb8:	dc88      	bgt.n	8024bcc <tRetune_tick+0x44>
}
 8024cba:	6978      	ldr	r0, [r7, #20]
 8024cbc:	b003      	add	sp, #12
 8024cbe:	ecbd 8b04 	vpop	{d8-d9}
 8024cc2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024cc6:	edd9 7a13 	vldr	s15, [r9, #76]	; 0x4c
 8024cca:	eef4 7ac9 	vcmpe.f32	s15, s18
 8024cce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024cd2:	ddc3      	ble.n	8024c5c <tRetune_tick+0xd4>
 8024cd4:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 8024cd8:	ed99 7a15 	vldr	s14, [r9, #84]	; 0x54
 8024cdc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8024ce0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024ce4:	ddba      	ble.n	8024c5c <tRetune_tick+0xd4>
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8024ce6:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
 8024ce8:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8024cea:	ee07 2a90 	vmov	s15, r2
            p->fba = 5;
 8024cee:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
    _tSOLAD* w = *wp;
 8024cf2:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8024cf4:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
 8024cf8:	ed92 7a03 	vldr	s14, [r2, #12]
 8024cfc:	eef4 7ac7 	vcmpe.f32	s15, s14
 8024d00:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024d04:	d5ab      	bpl.n	8024c5e <tRetune_tick+0xd6>
        w->jump = w->readlag - readlag;
 8024d06:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
 8024d0a:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
 8024d0e:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
 8024d12:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
 8024d16:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
 8024d1a:	61d3      	str	r3, [r2, #28]
 8024d1c:	e79e      	b.n	8024c5c <tRetune_tick+0xd4>
            p->deltamax = envout - p->max;
 8024d1e:	ed89 7a15 	vstr	s14, [r9, #84]	; 0x54
            p->max = p->max * ps->radius;
 8024d22:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
 8024d26:	ee67 6aa6 	vmul.f32	s13, s15, s13
 8024d2a:	ee36 7ae7 	vsub.f32	s14, s13, s15
 8024d2e:	edc9 6a13 	vstr	s13, [r9, #76]	; 0x4c
 8024d32:	e787      	b.n	8024c44 <tRetune_tick+0xbc>

08024d34 <tRetune_setPitchFactor>:
{
 8024d34:	b410      	push	{r4}
    _tRetune* r = *rt;
 8024d36:	6802      	ldr	r2, [r0, #0]
    r->pitchFactor[voice] = pf;
 8024d38:	008c      	lsls	r4, r1, #2
 8024d3a:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8024d3c:	4420      	add	r0, r4
 8024d3e:	ed80 0a00 	vstr	s0, [r0]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 8024d42:	6a93      	ldr	r3, [r2, #40]	; 0x28
    _tPitchShift* ps = *psr;
 8024d44:	6892      	ldr	r2, [r2, #8]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 8024d46:	4423      	add	r3, r4
    _tPitchShift* ps = *psr;
 8024d48:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    tPitchShift_setPitchFactor(&r->ps[voice], r->pitchFactor[voice]);
 8024d4c:	681b      	ldr	r3, [r3, #0]
    ps->pitchFactor = pf;
 8024d4e:	62d3      	str	r3, [r2, #44]	; 0x2c
}
 8024d50:	f85d 4b04 	ldr.w	r4, [sp], #4
 8024d54:	4770      	bx	lr
 8024d56:	bf00      	nop

08024d58 <tRetune_setFidelityThreshold>:

void tRetune_setFidelityThreshold(tRetune* const rt, float threshold)
{
    _tRetune* r = *rt;
    
    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
 8024d58:	6800      	ldr	r0, [r0, #0]
 8024d5a:	3004      	adds	r0, #4
 8024d5c:	f7fd bfd0 	b.w	8022d00 <tPeriodDetection_setFidelityThreshold>

08024d60 <tRetune_getInputPeriod>:

float tRetune_getInputPeriod(tRetune* const rt)
{
    _tRetune* r = *rt;
    
    return (r->inputPeriod * leaf.invSampleRate);
 8024d60:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8024d64:	6802      	ldr	r2, [r0, #0]
 8024d66:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8024d6a:	ed92 0a0d 	vldr	s0, [r2, #52]	; 0x34
 8024d6e:	edd3 7a01 	vldr	s15, [r3, #4]
}
 8024d72:	ee20 0a27 	vmul.f32	s0, s0, s15
 8024d76:	4770      	bx	lr

08024d78 <tAutotune_initToPool>:
{
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
}

void tAutotune_initToPool (tAutotune* const rt, int numVoices, int bufSize, int frameSize, tMempool* const mp)
{
 8024d78:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8024d7c:	ed2d 8b02 	vpush	{d8}
 8024d80:	b085      	sub	sp, #20
 8024d82:	4604      	mov	r4, r0
 8024d84:	4689      	mov	r9, r1
    _tMempool* m = *mp;
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
 8024d86:	2040      	movs	r0, #64	; 0x40
{
 8024d88:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
 8024d8c:	4617      	mov	r7, r2
 8024d8e:	469a      	mov	sl, r3
    _tMempool* m = *mp;
 8024d90:	f8d8 6000 	ldr.w	r6, [r8]
    _tAutotune* r = *rt = (_tAutotune*) mpool_alloc(sizeof(_tAutotune), m);
 8024d94:	4631      	mov	r1, r6
 8024d96:	f003 f829 	bl	8027dec <mpool_alloc>
 8024d9a:	4605      	mov	r5, r0
 8024d9c:	6020      	str	r0, [r4, #0]
    
    r->bufSize = bufSize;
    r->frameSize = frameSize;
    r->numVoices = numVoices;
    
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 8024d9e:	4631      	mov	r1, r6
    r->mempool = *mp;
 8024da0:	f8d8 2000 	ldr.w	r2, [r8]
    r->frameSize = frameSize;
 8024da4:	f8c0 a018 	str.w	sl, [r0, #24]
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 8024da8:	00b8      	lsls	r0, r7, #2
    r->mempool = *mp;
 8024daa:	602a      	str	r2, [r5, #0]
    r->bufSize = bufSize;
 8024dac:	61ef      	str	r7, [r5, #28]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
    
    r->hopSize = DEFHOPSIZE;
 8024dae:	f04f 1740 	mov.w	r7, #4194368	; 0x400040
    r->numVoices = numVoices;
 8024db2:	f8c5 903c 	str.w	r9, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 8024db6:	f003 f819 	bl	8027dec <mpool_alloc>
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 8024dba:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->inBuffer = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 8024dbc:	60e8      	str	r0, [r5, #12]
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 8024dbe:	4631      	mov	r1, r6
 8024dc0:	0098      	lsls	r0, r3, #2
 8024dc2:	f003 f813 	bl	8027dec <mpool_alloc>
    r->windowSize = DEFWINDOWSIZE;
    r->fba = FBA;
 8024dc6:	2114      	movs	r1, #20
void tAutotune_setTimeConstant(tAutotune* const rt, float tc)
{
    _tAutotune* r = *rt;
    
    r->timeConstant = tc;
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024dc8:	f249 42a0 	movw	r2, #38048	; 0x94a0
    r->outBuffers = (float**) mpool_alloc(sizeof(float*) * r->numVoices, m);
 8024dcc:	6128      	str	r0, [r5, #16]
    r->fba = FBA;
 8024dce:	f885 1024 	strb.w	r1, [r5, #36]	; 0x24
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024dd2:	eeba 7a04 	vmov.f32	s14, #164	; 0xc1200000 -10.0
    r->hopSize = DEFHOPSIZE;
 8024dd6:	622f      	str	r7, [r5, #32]
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024dd8:	f2c2 0201 	movt	r2, #8193	; 0x2001
    _tAutotune* r = *rt;
 8024ddc:	6824      	ldr	r4, [r4, #0]
    r->timeConstant = tc;
 8024dde:	2300      	movs	r3, #0
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024de0:	ed92 0a01 	vldr	s0, [r2, #4]
 8024de4:	8c22      	ldrh	r2, [r4, #32]
    r->timeConstant = tc;
 8024de6:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024dea:	ee20 0a07 	vmul.f32	s0, s0, s14
 8024dee:	ee07 2a90 	vmov	s15, r2
    r->timeConstant = tc;
 8024df2:	62e3      	str	r3, [r4, #44]	; 0x2c
    r->radius = expf(-1000.0f * r->hopSize * leaf.invSampleRate / r->timeConstant);
 8024df4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8024df8:	ee20 0a27 	vmul.f32	s0, s0, s15
 8024dfc:	f006 f8de 	bl	802afbc <expf>
 8024e00:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
 8024e04:	6be8      	ldr	r0, [r5, #60]	; 0x3c
 8024e06:	4631      	mov	r1, r6
 8024e08:	0080      	lsls	r0, r0, #2
 8024e0a:	f002 ffef 	bl	8027dec <mpool_alloc>
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e0e:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->ps = (tPitchShift*) mpool_alloc(sizeof(tPitchShift) * r->numVoices, m);
 8024e10:	60a8      	str	r0, [r5, #8]
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e12:	4631      	mov	r1, r6
 8024e14:	0098      	lsls	r0, r3, #2
 8024e16:	f002 ffe9 	bl	8027dec <mpool_alloc>
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e1a:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->freq = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e1c:	62a8      	str	r0, [r5, #40]	; 0x28
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e1e:	4631      	mov	r1, r6
 8024e20:	0098      	lsls	r0, r3, #2
 8024e22:	f002 ffe3 	bl	8027dec <mpool_alloc>
    for (int i = 0; i < r->numVoices; ++i)
 8024e26:	6beb      	ldr	r3, [r5, #60]	; 0x3c
    r->tickOutput = (float*) mpool_alloc(sizeof(float) * r->numVoices, m);
 8024e28:	6168      	str	r0, [r5, #20]
    for (int i = 0; i < r->numVoices; ++i)
 8024e2a:	2b00      	cmp	r3, #0
 8024e2c:	dd0c      	ble.n	8024e48 <tAutotune_initToPool+0xd0>
 8024e2e:	2400      	movs	r4, #0
        r->outBuffers[i] = (float*) mpool_alloc(sizeof(float) * r->bufSize, m);
 8024e30:	69e8      	ldr	r0, [r5, #28]
 8024e32:	4631      	mov	r1, r6
 8024e34:	692f      	ldr	r7, [r5, #16]
 8024e36:	0080      	lsls	r0, r0, #2
 8024e38:	f002 ffd8 	bl	8027dec <mpool_alloc>
 8024e3c:	f847 0024 	str.w	r0, [r7, r4, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8024e40:	3401      	adds	r4, #1
 8024e42:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024e44:	42a3      	cmp	r3, r4
 8024e46:	dcf3      	bgt.n	8024e30 <tAutotune_initToPool+0xb8>
    tPeriodDetection_initToPool(&r->pd, r->inBuffer, r->outBuffers[0], r->bufSize, r->frameSize, mp);
 8024e48:	692a      	ldr	r2, [r5, #16]
 8024e4a:	1d28      	adds	r0, r5, #4
 8024e4c:	69eb      	ldr	r3, [r5, #28]
 8024e4e:	6812      	ldr	r2, [r2, #0]
 8024e50:	68e9      	ldr	r1, [r5, #12]
 8024e52:	f8cd 8004 	str.w	r8, [sp, #4]
 8024e56:	69ac      	ldr	r4, [r5, #24]
 8024e58:	9003      	str	r0, [sp, #12]
 8024e5a:	9400      	str	r4, [sp, #0]
 8024e5c:	f7fd fe3c 	bl	8022ad8 <tPeriodDetection_initToPool>
    for (int i = 0; i < r->numVoices; ++i)
 8024e60:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024e62:	2b00      	cmp	r3, #0
 8024e64:	dd5b      	ble.n	8024f1e <tAutotune_initToPool+0x1a6>
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024e66:	2300      	movs	r3, #0
    w->period = INITPERIOD;
 8024e68:	f04f 4985 	mov.w	r9, #1115684864	; 0x42800000
    for (int i = 0; i < r->numVoices; ++i)
 8024e6c:	461f      	mov	r7, r3
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024e6e:	f2c4 2320 	movt	r3, #16928	; 0x4220
 8024e72:	ee08 3a90 	vmov	s17, r3
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024e76:	692b      	ldr	r3, [r5, #16]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024e78:	2038      	movs	r0, #56	; 0x38
    _tMempool* m = *mp;
 8024e7a:	f8d8 b000 	ldr.w	fp, [r8]
    ps->pitchFactor = 1.0f;
 8024e7e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024e82:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024e86:	4659      	mov	r1, fp
        tPitchShift_initToPool(&r->ps[i], &r->pd, r->outBuffers[i], r->bufSize, mp);
 8024e88:	69ee      	ldr	r6, [r5, #28]
 8024e8a:	f8d5 a008 	ldr.w	sl, [r5, #8]
 8024e8e:	9302      	str	r3, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024e90:	f003 f802 	bl	8027e98 <mpool_calloc>
    ps->outBuffer = out;
 8024e94:	9902      	ldr	r1, [sp, #8]
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024e96:	4604      	mov	r4, r0
    ps->curBlock = 1;
 8024e98:	f04f 0c01 	mov.w	ip, #1
    ps->lastBlock = 0;
 8024e9c:	2200      	movs	r2, #0
    _tPitchShift* ps = *psr = (_tPitchShift*) mpool_calloc(sizeof(_tPitchShift), m);
 8024e9e:	f84a 4027 	str.w	r4, [sl, r7, lsl #2]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024ea2:	2024      	movs	r0, #36	; 0x24
    ps->mempool = m;
 8024ea4:	f8c4 b000 	str.w	fp, [r4]
    for (int i = 0; i < r->numVoices; ++i)
 8024ea8:	4467      	add	r7, ip
    _tPeriodDetection* p = *pd;
 8024eaa:	686b      	ldr	r3, [r5, #4]
    ps->outBuffer = out;
 8024eac:	6121      	str	r1, [r4, #16]
    ps->p = pd;
 8024eae:	9903      	ldr	r1, [sp, #12]
    ps->bufSize = bufSize;
 8024eb0:	61a6      	str	r6, [r4, #24]
    ps->p = pd;
 8024eb2:	60e1      	str	r1, [r4, #12]
    ps->frameSize = p->frameSize;
 8024eb4:	695b      	ldr	r3, [r3, #20]
    ps->curBlock = 1;
 8024eb6:	f8c4 c020 	str.w	ip, [r4, #32]
    ps->frameSize = p->frameSize;
 8024eba:	6163      	str	r3, [r4, #20]
    ps->pitchFactor = 1.0f;
 8024ebc:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 8024ec0:	fb96 f6f3 	sdiv	r6, r6, r3
    ps->index = 0;
 8024ec4:	e9c4 2209 	strd	r2, r2, [r4, #36]	; 0x24
    ps->framesPerBuffer = ps->bufSize / ps->frameSize;
 8024ec8:	61e6      	str	r6, [r4, #28]
    _tMempool* m = *mp;
 8024eca:	f8d8 b000 	ldr.w	fp, [r8]
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024ece:	4659      	mov	r1, fp
 8024ed0:	f002 ffe2 	bl	8027e98 <mpool_calloc>
 8024ed4:	4606      	mov	r6, r0
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024ed6:	4659      	mov	r1, fp
 8024ed8:	f244 0040 	movw	r0, #16448	; 0x4040
    _tSOLAD* w = *wp = (_tSOLAD*) mpool_calloc(sizeof(_tSOLAD), m);
 8024edc:	6066      	str	r6, [r4, #4]
    w->mempool = m;
 8024ede:	f8c6 b000 	str.w	fp, [r6]
    w->pitchfactor = 1.;
 8024ee2:	ed86 8a02 	vstr	s16, [r6, #8]
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024ee6:	f002 ffd7 	bl	8027e98 <mpool_calloc>
    w->xfadevalue = -1;
 8024eea:	2200      	movs	r2, #0
    w->timeindex = 0;
 8024eec:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
    w->delaybuf = (float*) mpool_calloc(sizeof(float) * (LOOPSIZE+16), m);
 8024ef0:	6230      	str	r0, [r6, #32]
    w->xfadevalue = -1;
 8024ef2:	f6cb 7280 	movt	r2, #49024	; 0xbf80
    w->period = INITPERIOD;
 8024ef6:	f8c6 9010 	str.w	r9, [r6, #16]
    w->timeindex = 0;
 8024efa:	6073      	str	r3, [r6, #4]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024efc:	f104 0008 	add.w	r0, r4, #8
    w->xfadevalue = -1;
 8024f00:	61f2      	str	r2, [r6, #28]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024f02:	4641      	mov	r1, r8
    w->readlag = INITPERIOD;
 8024f04:	f8c6 900c 	str.w	r9, [r6, #12]
    tHighpass_initToPool(&ps->hp, HPFREQ, mp);
 8024f08:	eeb0 0a68 	vmov.f32	s0, s17
 8024f0c:	f001 fb5c 	bl	80265c8 <tHighpass_initToPool>
    _tSOLAD* w = *wp;
 8024f10:	6863      	ldr	r3, [r4, #4]
    w->pitchfactor = pitchfactor;
 8024f12:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8024f16:	609a      	str	r2, [r3, #8]
    for (int i = 0; i < r->numVoices; ++i)
 8024f18:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 8024f1a:	42bb      	cmp	r3, r7
 8024f1c:	dcab      	bgt.n	8024e76 <tAutotune_initToPool+0xfe>
    r->inputPeriod = 0.0f;
 8024f1e:	2300      	movs	r3, #0
    r->shiftOn = 0;
 8024f20:	63ab      	str	r3, [r5, #56]	; 0x38
    r->inputPeriod = 0.0f;
 8024f22:	636b      	str	r3, [r5, #52]	; 0x34
}
 8024f24:	b005      	add	sp, #20
 8024f26:	ecbd 8b02 	vpop	{d8}
 8024f2a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8024f2e:	bf00      	nop

08024f30 <tAutotune_init>:
{
 8024f30:	b510      	push	{r4, lr}
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 8024f32:	f249 44b8 	movw	r4, #38072	; 0x94b8
{
 8024f36:	b082      	sub	sp, #8
    tAutotune_initToPool(rt, numVoices, bufSize, frameSize, &leaf.mempool);
 8024f38:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8024f3c:	9400      	str	r4, [sp, #0]
 8024f3e:	f7ff ff1b 	bl	8024d78 <tAutotune_initToPool>
}
 8024f42:	b002      	add	sp, #8
 8024f44:	bd10      	pop	{r4, pc}
 8024f46:	bf00      	nop

08024f48 <tAutotune_free>:
{
 8024f48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tAutotune* r = *rt;
 8024f4a:	6804      	ldr	r4, [r0, #0]
    tPeriodDetection_free(&r->pd);
 8024f4c:	1d20      	adds	r0, r4, #4
 8024f4e:	f7fd fe23 	bl	8022b98 <tPeriodDetection_free>
    for (int i = 0; i < r->numVoices; ++i)
 8024f52:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024f54:	2b00      	cmp	r3, #0
 8024f56:	dd1e      	ble.n	8024f96 <tAutotune_free+0x4e>
 8024f58:	2500      	movs	r5, #0
    _tPitchShift* ps = *psr;
 8024f5a:	68a3      	ldr	r3, [r4, #8]
 8024f5c:	f853 6025 	ldr.w	r6, [r3, r5, lsl #2]
    _tSOLAD* w = *wp;
 8024f60:	6877      	ldr	r7, [r6, #4]
    mpool_free((char*)w->delaybuf, w->mempool);
 8024f62:	6839      	ldr	r1, [r7, #0]
 8024f64:	6a38      	ldr	r0, [r7, #32]
 8024f66:	f002 ffeb 	bl	8027f40 <mpool_free>
    mpool_free((char*)w, w->mempool);
 8024f6a:	6839      	ldr	r1, [r7, #0]
 8024f6c:	4638      	mov	r0, r7
 8024f6e:	f002 ffe7 	bl	8027f40 <mpool_free>
    tHighpass_free(&ps->hp);
 8024f72:	f106 0008 	add.w	r0, r6, #8
 8024f76:	f001 fb49 	bl	802660c <tHighpass_free>
    mpool_free((char*)ps, ps->mempool);
 8024f7a:	6831      	ldr	r1, [r6, #0]
 8024f7c:	4630      	mov	r0, r6
 8024f7e:	f002 ffdf 	bl	8027f40 <mpool_free>
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8024f82:	6923      	ldr	r3, [r4, #16]
 8024f84:	6821      	ldr	r1, [r4, #0]
 8024f86:	f853 0025 	ldr.w	r0, [r3, r5, lsl #2]
    for (int i = 0; i < r->numVoices; ++i)
 8024f8a:	3501      	adds	r5, #1
        mpool_free((char*)r->outBuffers[i], r->mempool);
 8024f8c:	f002 ffd8 	bl	8027f40 <mpool_free>
    for (int i = 0; i < r->numVoices; ++i)
 8024f90:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8024f92:	42ab      	cmp	r3, r5
 8024f94:	dce1      	bgt.n	8024f5a <tAutotune_free+0x12>
    mpool_free((char*)r->tickOutput, r->mempool);
 8024f96:	6821      	ldr	r1, [r4, #0]
 8024f98:	6960      	ldr	r0, [r4, #20]
 8024f9a:	f002 ffd1 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->freq, r->mempool);
 8024f9e:	6821      	ldr	r1, [r4, #0]
 8024fa0:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8024fa2:	f002 ffcd 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->ps, r->mempool);
 8024fa6:	6821      	ldr	r1, [r4, #0]
 8024fa8:	68a0      	ldr	r0, [r4, #8]
 8024faa:	f002 ffc9 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->inBuffer, r->mempool);
 8024fae:	6821      	ldr	r1, [r4, #0]
 8024fb0:	68e0      	ldr	r0, [r4, #12]
 8024fb2:	f002 ffc5 	bl	8027f40 <mpool_free>
    mpool_free((char*)r->outBuffers, r->mempool);
 8024fb6:	6821      	ldr	r1, [r4, #0]
 8024fb8:	6920      	ldr	r0, [r4, #16]
 8024fba:	f002 ffc1 	bl	8027f40 <mpool_free>
    mpool_free((char*)r, r->mempool);
 8024fbe:	6821      	ldr	r1, [r4, #0]
 8024fc0:	4620      	mov	r0, r4
}
 8024fc2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 8024fc6:	f002 bfbb 	b.w	8027f40 <mpool_free>
 8024fca:	bf00      	nop

08024fcc <tAutotune_tick>:
{
 8024fcc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8024fd0:	ed2d 8b06 	vpush	{d8-d10}
    _tAutotune* r = *rt;
 8024fd4:	6806      	ldr	r6, [r0, #0]
{
 8024fd6:	b082      	sub	sp, #8
    float tempPeriod = tPeriodDetection_tick(&r->pd, sample);
 8024fd8:	1d30      	adds	r0, r6, #4
 8024fda:	f7fd fdff 	bl	8022bdc <tPeriodDetection_tick>
    if (tempPeriod < 1000.0f) //to avoid trying to follow consonants JS
 8024fde:	2300      	movs	r3, #0
 8024fe0:	f2c4 437a 	movt	r3, #17530	; 0x447a
 8024fe4:	ee07 3a90 	vmov	s15, r3
 8024fe8:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8024fec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8024ff0:	d501      	bpl.n	8024ff6 <tAutotune_tick+0x2a>
		r->inputPeriod = tempPeriod;
 8024ff2:	ed86 0a0d 	vstr	s0, [r6, #52]	; 0x34
	for (int v = 0; v < r->numVoices; ++v)
 8024ff6:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8024ff8:	2b00      	cmp	r3, #0
 8024ffa:	f340 80a0 	ble.w	802513e <tAutotune_tick+0x172>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8024ffe:	2300      	movs	r3, #0
    if(period > MAXPERIOD) period = MAXPERIOD;
 8025000:	f64c 42cd 	movw	r2, #52429	; 0xcccd
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
 8025004:	f249 48a0 	movw	r8, #38048	; 0x94a0
	for (int v = 0; v < r->numVoices; ++v)
 8025008:	461d      	mov	r5, r3
    if(period > MAXPERIOD) period = MAXPERIOD;
 802500a:	f6c3 724c 	movt	r2, #16204	; 0x3f4c
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 802500e:	f2c4 2370 	movt	r3, #17008	; 0x4270
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
 8025012:	f2c2 0801 	movt	r8, #8193	; 0x2001
    if(period > MAXPERIOD) period = MAXPERIOD;
 8025016:	ee09 2a90 	vmov	s19, r2
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 802501a:	ee0a 3a10 	vmov	s20, r3
 802501e:	e006      	b.n	802502e <tAutotune_tick+0x62>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8025020:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
 8025024:	3501      	adds	r5, #1
 8025026:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8025028:	42ab      	cmp	r3, r5
 802502a:	f340 8088 	ble.w	802513e <tAutotune_tick+0x172>
    _tPitchShift* ps = *psr;
 802502e:	68b1      	ldr	r1, [r6, #8]
 8025030:	00ab      	lsls	r3, r5, #2
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8025032:	6ab2      	ldr	r2, [r6, #40]	; 0x28
    _tPitchShift* ps = *psr;
 8025034:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8025038:	6977      	ldr	r7, [r6, #20]
 802503a:	eb02 0c03 	add.w	ip, r2, r3
    _tPeriodDetection* p = *ps->p;
 802503e:	68e1      	ldr	r1, [r4, #12]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8025040:	f104 0008 	add.w	r0, r4, #8
 8025044:	6922      	ldr	r2, [r4, #16]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8025046:	441f      	add	r7, r3
    _tPeriodDetection* p = *ps->p;
 8025048:	6809      	ldr	r1, [r1, #0]
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 802504a:	ed9c 8a00 	vldr	s16, [ip]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 802504e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
    _tPeriodDetection* p = *ps->p;
 8025050:	9101      	str	r1, [sp, #4]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8025052:	eb02 0283 	add.w	r2, r2, r3, lsl #2
    i = p->i;
 8025056:	f8d1 9028 	ldr.w	r9, [r1, #40]	; 0x28
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 802505a:	ed92 0a00 	vldr	s0, [r2]
 802505e:	f001 fae9 	bl	8026634 <tHighpass_tick>
    if (p->indexstore >= ps->frameSize)
 8025062:	9a01      	ldr	r2, [sp, #4]
 8025064:	6963      	ldr	r3, [r4, #20]
    out = tHighpass_tick(&ps->hp, ps->outBuffer[iLast]);
 8025066:	eef0 8a40 	vmov.f32	s17, s0
    if (p->indexstore >= ps->frameSize)
 802506a:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 802506c:	429a      	cmp	r2, r3
 802506e:	dbd7      	blt.n	8025020 <tAutotune_tick+0x54>
        period = tPeriodDetection_getPeriod(&p);
 8025070:	a801      	add	r0, sp, #4
 8025072:	f7fd fe41 	bl	8022cf8 <tPeriodDetection_getPeriod>
    _tPeriodDetection* p = *ps->p;
 8025076:	68e3      	ldr	r3, [r4, #12]
        period = tPeriodDetection_getPeriod(&p);
 8025078:	eeb0 9a40 	vmov.f32	s18, s0
    _tPeriodDetection* p = *ps->p;
 802507c:	f8d3 a000 	ldr.w	sl, [r3]
    envout = tEnvPD_tick(&p->env);
 8025080:	f10a 0004 	add.w	r0, sl, #4
 8025084:	f7fd fa24 	bl	80224d0 <tEnvPD_tick>
    if (envout >= 1.0f)
 8025088:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802508c:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8025090:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025094:	db0f      	blt.n	80250b6 <tAutotune_tick+0xea>
        p->lastmax = p->max;
 8025096:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
        if (envout > p->max)
 802509a:	eeb4 0ae7 	vcmpe.f32	s0, s15
        p->lastmax = p->max;
 802509e:	edca 7a14 	vstr	s15, [sl, #80]	; 0x50
 80250a2:	ee30 7a67 	vsub.f32	s14, s0, s15
        if (envout > p->max)
 80250a6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80250aa:	f340 8083 	ble.w	80251b4 <tAutotune_tick+0x1e8>
            p->max = envout;
 80250ae:	ed8a 0a13 	vstr	s0, [sl, #76]	; 0x4c
        p->deltamax = p->max - p->lastmax;
 80250b2:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
    p->fba = p->fba ? (p->fba - 1) : 0;
 80250b6:	f89a 3040 	ldrb.w	r3, [sl, #64]	; 0x40
 80250ba:	2b00      	cmp	r3, #0
 80250bc:	d04c      	beq.n	8025158 <tAutotune_tick+0x18c>
 80250be:	3b01      	subs	r3, #1
 80250c0:	b2db      	uxtb	r3, r3
 80250c2:	f88a 3040 	strb.w	r3, [sl, #64]	; 0x40
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 80250c6:	2b00      	cmp	r3, #0
 80250c8:	d046      	beq.n	8025158 <tAutotune_tick+0x18c>
 80250ca:	6862      	ldr	r2, [r4, #4]
 80250cc:	9901      	ldr	r1, [sp, #4]
    if(period > MAXPERIOD) period = MAXPERIOD;
 80250ce:	88d3      	ldrh	r3, [r2, #6]
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 80250d0:	eeb2 7a00 	vmov.f32	s14, #32	; 0x41000000  8.0
    if(period > MAXPERIOD) period = MAXPERIOD;
 80250d4:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 80250d8:	ee07 3a90 	vmov	s15, r3
 80250dc:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 80250e0:	ee67 7aa9 	vmul.f32	s15, s15, s19
 80250e4:	fec7 7ac9 	vminnm.f32	s15, s15, s18
    if(period > MINPERIOD) w->period = period;  // ignore period when too small
 80250e8:	eef4 7ac7 	vcmpe.f32	s15, s14
 80250ec:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80250f0:	dd02      	ble.n	80250f8 <tAutotune_tick+0x12c>
 80250f2:	edc2 7a04 	vstr	s15, [r2, #16]
 80250f6:	6862      	ldr	r2, [r4, #4]
        if (period != 0) ps->pitchFactor = period*freq*leaf.invSampleRate;
 80250f8:	eeb5 9a40 	vcmp.f32	s18, #0.0
 80250fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025100:	d023      	beq.n	802514a <tAutotune_tick+0x17e>
 8025102:	edd8 7a01 	vldr	s15, [r8, #4]
 8025106:	ee28 8a27 	vmul.f32	s16, s16, s15
 802510a:	ee28 8a09 	vmul.f32	s16, s16, s18
    if (pitchfactor <= 0.0f) return;
 802510e:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 8025112:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
 8025116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802511a:	d81a      	bhi.n	8025152 <tAutotune_tick+0x186>
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 802511c:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8025120:	68c9      	ldr	r1, [r1, #12]
 8025122:	6922      	ldr	r2, [r4, #16]
 8025124:	1d20      	adds	r0, r4, #4
 8025126:	6963      	ldr	r3, [r4, #20]
 8025128:	4449      	add	r1, r9
 802512a:	444a      	add	r2, r9
	for (int v = 0; v < r->numVoices; ++v)
 802512c:	3501      	adds	r5, #1
        tSOLAD_ioSamples(&ps->sola, &(p->inBuffer[i]), &(ps->outBuffer[i]), ps->frameSize);
 802512e:	f7ff fa85 	bl	802463c <tSOLAD_ioSamples>
		r->tickOutput[v] = tPitchShift_shiftToFreq(&r->ps[v], r->freq[v]);
 8025132:	edc7 8a00 	vstr	s17, [r7]
	for (int v = 0; v < r->numVoices; ++v)
 8025136:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
 8025138:	42ab      	cmp	r3, r5
 802513a:	f73f af78 	bgt.w	802502e <tAutotune_tick+0x62>
    return r->tickOutput;
 802513e:	6970      	ldr	r0, [r6, #20]
}
 8025140:	b002      	add	sp, #8
 8025142:	ecbd 8b06 	vpop	{d8-d10}
 8025146:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 802514a:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
 802514e:	ed84 8a0b 	vstr	s16, [r4, #44]	; 0x2c
    w->pitchfactor = pitchfactor;
 8025152:	ed82 8a02 	vstr	s16, [r2, #8]
 8025156:	e7e1      	b.n	802511c <tAutotune_tick+0x150>
    return (p->fba == 0 && (p->max > 60 && p->deltamax > 6)) ? 1 : 0;
 8025158:	edda 7a13 	vldr	s15, [sl, #76]	; 0x4c
 802515c:	eef4 7aca 	vcmpe.f32	s15, s20
 8025160:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025164:	ddb1      	ble.n	80250ca <tAutotune_tick+0xfe>
 8025166:	eef1 7a08 	vmov.f32	s15, #24	; 0x40c00000  6.0
 802516a:	ed9a 7a15 	vldr	s14, [sl, #84]	; 0x54
 802516e:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8025172:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025176:	dda8      	ble.n	80250ca <tAutotune_tick+0xfe>
            p->fba = 5;
 8025178:	9901      	ldr	r1, [sp, #4]
 802517a:	2305      	movs	r3, #5
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 802517c:	8fca      	ldrh	r2, [r1, #62]	; 0x3e
            p->fba = 5;
 802517e:	f881 3040 	strb.w	r3, [r1, #64]	; 0x40
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8025182:	ee07 2a90 	vmov	s15, r2
    _tSOLAD* w = *wp;
 8025186:	6862      	ldr	r2, [r4, #4]
            tSOLAD_setReadLag(&ps->sola, p->windowSize);
 8025188:	eef8 7a67 	vcvt.f32.u32	s15, s15
    if(readlag < w->readlag)               // do not jump backward, only forward
 802518c:	ed92 7a03 	vldr	s14, [r2, #12]
 8025190:	eef4 7ac7 	vcmpe.f32	s15, s14
 8025194:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025198:	d599      	bpl.n	80250ce <tAutotune_tick+0x102>
        w->jump = w->readlag - readlag;
 802519a:	ee37 7a67 	vsub.f32	s14, s14, s15
        w->xfadevalue = 1;
 802519e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
        w->readlag = readlag;
 80251a2:	edc2 7a03 	vstr	s15, [r2, #12]
        w->xfadelength = readlag;
 80251a6:	edc2 7a06 	vstr	s15, [r2, #24]
        w->jump = w->readlag - readlag;
 80251aa:	ed82 7a05 	vstr	s14, [r2, #20]
        w->xfadevalue = 1;
 80251ae:	61d3      	str	r3, [r2, #28]
 80251b0:	6862      	ldr	r2, [r4, #4]
 80251b2:	e78c      	b.n	80250ce <tAutotune_tick+0x102>
            p->deltamax = envout - p->max;
 80251b4:	ed8a 7a15 	vstr	s14, [sl, #84]	; 0x54
            p->max = p->max * ps->radius;
 80251b8:	edd4 6a0d 	vldr	s13, [r4, #52]	; 0x34
 80251bc:	ee67 6aa6 	vmul.f32	s13, s15, s13
 80251c0:	ee36 7ae7 	vsub.f32	s14, s13, s15
 80251c4:	edca 6a13 	vstr	s13, [sl, #76]	; 0x4c
 80251c8:	e773      	b.n	80250b2 <tAutotune_tick+0xe6>
 80251ca:	bf00      	nop

080251cc <tAutotune_setFreq>:
    r->freq[voice] = f;
 80251cc:	6803      	ldr	r3, [r0, #0]
 80251ce:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80251d0:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 80251d4:	ed81 0a00 	vstr	s0, [r1]
}
 80251d8:	4770      	bx	lr
 80251da:	bf00      	nop

080251dc <tAutotune_setFidelityThreshold>:

void tAutotune_setFidelityThreshold(tAutotune* const rt, float threshold)
{
    _tAutotune* r = *rt;

    tPeriodDetection_setFidelityThreshold(&r->pd, threshold);
 80251dc:	6800      	ldr	r0, [r0, #0]
 80251de:	3004      	adds	r0, #4
 80251e0:	f7fd bd8e 	b.w	8022d00 <tPeriodDetection_setFidelityThreshold>

080251e4 <tFormantShifter_initToPool>:
{
    tFormantShifter_initToPool(fsr, order, &leaf.mempool);
}

void tFormantShifter_initToPool (tFormantShifter* const fsr, int order, tMempool* const mp)
{
 80251e4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80251e8:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 80251ec:	6815      	ldr	r5, [r2, #0]
{
 80251ee:	4688      	mov	r8, r1
 80251f0:	4681      	mov	r9, r0
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
 80251f2:	2068      	movs	r0, #104	; 0x68
 80251f4:	4629      	mov	r1, r5
{
 80251f6:	4616      	mov	r6, r2
    _tFormantShifter* fs = *fsr = (_tFormantShifter*) mpool_alloc(sizeof(_tFormantShifter), m);
 80251f8:	f002 fdf8 	bl	8027dec <mpool_alloc>
 80251fc:	4604      	mov	r4, r0
 80251fe:	f8c9 0000 	str.w	r0, [r9]
    fs->mempool = m;
    
    fs->ford = order;
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025202:	4629      	mov	r1, r5
 8025204:	ea4f 0088 	mov.w	r0, r8, lsl #2
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
    
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);

    
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 8025208:	f249 47a0 	movw	r7, #38048	; 0x94a0
    fs->ford = order;
 802520c:	e9c4 5800 	strd	r5, r8, [r4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025210:	f002 fe42 	bl	8027e98 <mpool_calloc>
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025214:	6863      	ldr	r3, [r4, #4]
    fs->fk = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025216:	6120      	str	r0, [r4, #16]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025218:	4629      	mov	r1, r5
 802521a:	0098      	lsls	r0, r3, #2
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 802521c:	f2c2 0701 	movt	r7, #8193	; 0x2001
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025220:	f002 fe3a 	bl	8027e98 <mpool_calloc>
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025224:	6863      	ldr	r3, [r4, #4]
    fs->fb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025226:	6160      	str	r0, [r4, #20]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025228:	4629      	mov	r1, r5
 802522a:	0098      	lsls	r0, r3, #2
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
    fs->fhp = 0.0f;
    fs->flp = 0.0f;
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
    fs->fmute = 1.0f;
 802522c:	f04f 587e 	mov.w	r8, #1065353216	; 0x3f800000
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025230:	f002 fe32 	bl	8027e98 <mpool_calloc>
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025234:	6863      	ldr	r3, [r4, #4]
    fs->fc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025236:	61a0      	str	r0, [r4, #24]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025238:	4629      	mov	r1, r5
 802523a:	0098      	lsls	r0, r3, #2
 802523c:	f002 fe2c 	bl	8027e98 <mpool_calloc>
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025240:	6863      	ldr	r3, [r4, #4]
    fs->frb = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025242:	61e0      	str	r0, [r4, #28]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025244:	4629      	mov	r1, r5
 8025246:	0098      	lsls	r0, r3, #2
 8025248:	f002 fe26 	bl	8027e98 <mpool_calloc>
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802524c:	6863      	ldr	r3, [r4, #4]
    fs->frc = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802524e:	6220      	str	r0, [r4, #32]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025250:	4629      	mov	r1, r5
 8025252:	0098      	lsls	r0, r3, #2
 8025254:	f002 fe20 	bl	8027e98 <mpool_calloc>
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025258:	6863      	ldr	r3, [r4, #4]
    fs->fsig = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802525a:	6260      	str	r0, [r4, #36]	; 0x24
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 802525c:	4629      	mov	r1, r5
 802525e:	0098      	lsls	r0, r3, #2
 8025260:	f002 fe1a 	bl	8027e98 <mpool_calloc>
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025264:	6863      	ldr	r3, [r4, #4]
    fs->fsmooth = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025266:	62a0      	str	r0, [r4, #40]	; 0x28
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025268:	4629      	mov	r1, r5
 802526a:	0098      	lsls	r0, r3, #2
 802526c:	f002 fe14 	bl	8027e98 <mpool_calloc>
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 8025270:	6863      	ldr	r3, [r4, #4]
 8025272:	4629      	mov	r1, r5
    fs->ftvec = (float*) mpool_calloc(sizeof(float) * fs->ford, m);
 8025274:	63e0      	str	r0, [r4, #60]	; 0x3c
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 8025276:	0098      	lsls	r0, r3, #2
 8025278:	f002 fe0e 	bl	8027e98 <mpool_calloc>
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 802527c:	f241 236f 	movw	r3, #4719	; 0x126f
 8025280:	eef2 0a04 	vmov.f32	s1, #36	; 0x41200000  10.0
 8025284:	ed97 9a01 	vldr	s18, [r7, #4]
 8025288:	f6c3 2383 	movt	r3, #14979	; 0x3a83
    fs->fbuff = (float*) mpool_calloc(sizeof(float*) * fs->ford, m);
 802528c:	63a0      	str	r0, [r4, #56]	; 0x38
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 802528e:	ee69 0a20 	vmul.f32	s1, s18, s1
 8025292:	ee00 3a10 	vmov	s0, r3
 8025296:	ee08 3a10 	vmov	s16, r3
 802529a:	f005 fffd 	bl	802b298 <powf>
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 802529e:	f24d 13e1 	movw	r3, #53729	; 0xd1e1
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 80252a2:	eef0 8a40 	vmov.f32	s17, s0
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80252a6:	ed97 0a00 	vldr	s0, [r7]
 80252aa:	f6c3 5386 	movt	r3, #15750	; 0x3d86
    fs->falph = powf(0.001f, 10.0f * leaf.invSampleRate);
 80252ae:	edc4 8a02 	vstr	s17, [r4, #8]
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80252b2:	ee07 3a90 	vmov	s15, r3
 80252b6:	ee20 0a27 	vmul.f32	s0, s0, s15
 80252ba:	f005 fd6d 	bl	802ad98 <atanf>
 80252be:	eef1 6ac0 	vsqrt.f32	s13, s0
 80252c2:	f640 1203 	movw	r2, #2307	; 0x903
 80252c6:	f243 23ca 	movw	r3, #13002	; 0x32ca
    fs->fhp = 0.0f;
 80252ca:	2100      	movs	r1, #0
    fs->flpa = powf(0.001f, 10.0f * leaf.invSampleRate);
 80252cc:	edc4 8a0d 	vstr	s17, [r4, #52]	; 0x34
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80252d0:	f6c3 725a 	movt	r2, #16218	; 0x3f5a
 80252d4:	f6c3 6344 	movt	r3, #15940	; 0x3e44
    fs->fhp = 0.0f;
 80252d8:	62e1      	str	r1, [r4, #44]	; 0x2c
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80252da:	ee07 2a10 	vmov	s14, r2
 80252de:	ee07 3a90 	vmov	s15, r3
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80252e2:	eef0 0a49 	vmov.f32	s1, s18
    fs->flp = 0.0f;
 80252e6:	6321      	str	r1, [r4, #48]	; 0x30
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80252e8:	eeb0 0a48 	vmov.f32	s0, s16
    fs->fmute = 1.0f;
 80252ec:	f8c4 8040 	str.w	r8, [r4, #64]	; 0x40
    fs->flamb = -(0.8517f*sqrtf(atanf(0.06583f*leaf.sampleRate))-0.1916f);
 80252f0:	eee6 7ac7 	vfms.f32	s15, s13, s14
 80252f4:	edc4 7a03 	vstr	s15, [r4, #12]
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80252f8:	f005 ffce 	bl	802b298 <powf>
    fs->cbi = 0;
 80252fc:	2300      	movs	r3, #0
    fs->fmutealph = powf(0.001f, 1.0f * leaf.invSampleRate);
 80252fe:	ed84 0a11 	vstr	s0, [r4, #68]	; 0x44
    fs->intensity = 1.0f;
    fs->invIntensity = 1.0f;
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 8025302:	4631      	mov	r1, r6
    fs->cbi = 0;
 8025304:	64a3      	str	r3, [r4, #72]	; 0x48
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 8025306:	f104 0058 	add.w	r0, r4, #88	; 0x58
    fs->intensity = 1.0f;
 802530a:	f8c4 8050 	str.w	r8, [r4, #80]	; 0x50
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 802530e:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
    fs->invIntensity = 1.0f;
 8025312:	f8c4 8054 	str.w	r8, [r4, #84]	; 0x54
    tHighpass_initToPool(&fs->hp, 20.0f, mp);
 8025316:	f001 f957 	bl	80265c8 <tHighpass_initToPool>
    tHighpass_initToPool(&fs->hp2, 20.0f, mp);
 802531a:	4631      	mov	r1, r6
 802531c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8025320:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8025324:	f001 f950 	bl	80265c8 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl1, 0.8f, .005f, 0.125, 1, mp);
 8025328:	f24d 710a 	movw	r1, #55050	; 0xd70a
 802532c:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8025330:	4632      	mov	r2, r6
 8025332:	f6c3 31a3 	movt	r1, #15267	; 0x3ba3
 8025336:	f104 0060 	add.w	r0, r4, #96	; 0x60
 802533a:	f6c3 734c 	movt	r3, #16204	; 0x3f4c
 802533e:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
 8025342:	ee08 1a90 	vmov	s17, r1
 8025346:	2101      	movs	r1, #1
 8025348:	ee08 3a10 	vmov	s16, r3
 802534c:	ee00 3a10 	vmov	s0, r3
 8025350:	eef0 0a68 	vmov.f32	s1, s17
 8025354:	f7fe fba2 	bl	8023a9c <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
 8025358:	eef0 0a68 	vmov.f32	s1, s17
 802535c:	eeb0 0a48 	vmov.f32	s0, s16
 8025360:	4632      	mov	r2, r6
 8025362:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8025366:	2101      	movs	r1, #1
 8025368:	eeb4 1a00 	vmov.f32	s2, #64	; 0x3e000000  0.125
}
 802536c:	ecbd 8b04 	vpop	{d8-d9}
 8025370:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tFeedbackLeveler_initToPool(&fs->fbl2, 0.8f, .005f, 0.125, 1, mp);
 8025374:	f7fe bb92 	b.w	8023a9c <tFeedbackLeveler_initToPool>

08025378 <tFormantShifter_free>:

void tFormantShifter_free (tFormantShifter* const fsr)
{
 8025378:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
 802537a:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)fs->fk, fs->mempool);
 802537c:	6821      	ldr	r1, [r4, #0]
 802537e:	6920      	ldr	r0, [r4, #16]
 8025380:	f002 fdde 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->fb, fs->mempool);
 8025384:	6821      	ldr	r1, [r4, #0]
 8025386:	6960      	ldr	r0, [r4, #20]
 8025388:	f002 fdda 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->fc, fs->mempool);
 802538c:	6821      	ldr	r1, [r4, #0]
 802538e:	69a0      	ldr	r0, [r4, #24]
 8025390:	f002 fdd6 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->frb, fs->mempool);
 8025394:	6821      	ldr	r1, [r4, #0]
 8025396:	69e0      	ldr	r0, [r4, #28]
 8025398:	f002 fdd2 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->frc, fs->mempool);
 802539c:	6821      	ldr	r1, [r4, #0]
 802539e:	6a20      	ldr	r0, [r4, #32]
 80253a0:	f002 fdce 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->fsig, fs->mempool);
 80253a4:	6821      	ldr	r1, [r4, #0]
 80253a6:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80253a8:	f002 fdca 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->fsmooth, fs->mempool);
 80253ac:	6821      	ldr	r1, [r4, #0]
 80253ae:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80253b0:	f002 fdc6 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->ftvec, fs->mempool);
 80253b4:	6821      	ldr	r1, [r4, #0]
 80253b6:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80253b8:	f002 fdc2 	bl	8027f40 <mpool_free>
    mpool_free((char*)fs->fbuff, fs->mempool);
 80253bc:	6821      	ldr	r1, [r4, #0]
 80253be:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 80253c0:	f002 fdbe 	bl	8027f40 <mpool_free>
    tHighpass_free(&fs->hp);
 80253c4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80253c8:	f001 f920 	bl	802660c <tHighpass_free>
    tHighpass_free(&fs->hp2);
 80253cc:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 80253d0:	f001 f91c 	bl	802660c <tHighpass_free>
    tFeedbackLeveler_free(&fs->fbl1);
 80253d4:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80253d8:	f7fe fb88 	bl	8023aec <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&fs->fbl2);
 80253dc:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80253e0:	f7fe fb84 	bl	8023aec <tFeedbackLeveler_free>
    mpool_free((char*)fs, fs->mempool);
 80253e4:	6821      	ldr	r1, [r4, #0]
 80253e6:	4620      	mov	r0, r4
}
 80253e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)fs, fs->mempool);
 80253ec:	f002 bda8 	b.w	8027f40 <mpool_free>

080253f0 <tFormantShifter_remove>:
{
    return tFormantShifter_add(fsr, tFormantShifter_remove(fsr, in));
}

float tFormantShifter_remove(tFormantShifter* const fsr, float in)
{
 80253f0:	b510      	push	{r4, lr}
    _tFormantShifter* fs = *fsr;
 80253f2:	6804      	ldr	r4, [r0, #0]
    in = tFeedbackLeveler_tick(&fs->fbl1, in);
 80253f4:	f104 0060 	add.w	r0, r4, #96	; 0x60
 80253f8:	f7fe fb88 	bl	8023b0c <tFeedbackLeveler_tick>
    in = tHighpass_tick(&fs->hp, in * fs->intensity);
 80253fc:	edd4 7a14 	vldr	s15, [r4, #80]	; 0x50
 8025400:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8025404:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025408:	f001 f914 	bl	8026634 <tHighpass_tick>
    

    float fa, fb, fc, foma, falph, ford, flamb, tf, fk;

    ford = fs->ford;
 802540c:	edd4 7a01 	vldr	s15, [r4, #4]
    falph = fs->falph;
    foma = (1.0f - falph);
 8025410:	eef7 5a00 	vmov.f32	s11, #112	; 0x3f800000  1.0
    flamb = fs->flamb;
    
    tf = in;
    
    fa = tf - fs->fhp;
 8025414:	edd4 6a0b 	vldr	s13, [r4, #44]	; 0x2c
    ford = fs->ford;
 8025418:	eef8 3ae7 	vcvt.f32.s32	s7, s15
    falph = fs->falph;
 802541c:	ed94 5a02 	vldr	s10, [r4, #8]
    fs->fhp = tf;
 8025420:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
    fa = tf - fs->fhp;
 8025424:	ee70 6a66 	vsub.f32	s13, s0, s13
    foma = (1.0f - falph);
 8025428:	ee75 5ac5 	vsub.f32	s11, s11, s10
    flamb = fs->flamb;
 802542c:	edd4 2a03 	vldr	s5, [r4, #12]
    fb = fa;
    for(int i = 0; i < ford; i++)
 8025430:	eef5 3ac0 	vcmpe.f32	s7, #0.0
 8025434:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025438:	dd5a      	ble.n	80254f0 <tFormantShifter_remove+0x100>
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
        fs->fc[i] = fc;
        fs->fb[i] = fb;
        fk = fa*fc*foma + fs->fk[i]*falph;
        fs->fk[i] = fk;
        tf = fk/(fs->fsig[i] + 0.000001f);
 802543a:	f243 73bd 	movw	r3, #14269	; 0x37bd
    fa = tf - fs->fhp;
 802543e:	eeb0 0a66 	vmov.f32	s0, s13
    for(int i = 0; i < ford; i++)
 8025442:	2100      	movs	r1, #0
        tf = fk/(fs->fsig[i] + 0.000001f);
 8025444:	f2c3 5386 	movt	r3, #13702	; 0x3586
 8025448:	ee03 3a10 	vmov	s6, r3
 802544c:	008b      	lsls	r3, r1, #2
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 802544e:	6a62      	ldr	r2, [r4, #36]	; 0x24
    for(int i = 0; i < ford; i++)
 8025450:	3101      	adds	r1, #1
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8025452:	ee20 7a00 	vmul.f32	s14, s0, s0
 8025456:	441a      	add	r2, r3
        fk = fa*fc*foma + fs->fk[i]*falph;
 8025458:	ee25 6a80 	vmul.f32	s12, s11, s0
    for(int i = 0; i < ford; i++)
 802545c:	ee07 1a90 	vmov	s15, r1
 8025460:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8025464:	edd2 7a00 	vldr	s15, [r2]
 8025468:	ee65 7a27 	vmul.f32	s15, s10, s15
    for(int i = 0; i < ford; i++)
 802546c:	eef4 4ae3 	vcmpe.f32	s9, s7
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8025470:	eee5 7a87 	vfma.f32	s15, s11, s14
    for(int i = 0; i < ford; i++)
 8025474:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->fsig[i] = fa*fa*foma + fs->fsig[i]*falph;
 8025478:	edc2 7a00 	vstr	s15, [r2]
        fc = (fb - fs->fc[i])*flamb + fs->fb[i];
 802547c:	e9d4 0205 	ldrd	r0, r2, [r4, #20]
 8025480:	441a      	add	r2, r3
 8025482:	4418      	add	r0, r3
 8025484:	edd2 7a00 	vldr	s15, [r2]
 8025488:	ed90 7a00 	vldr	s14, [r0]
 802548c:	ee76 7ae7 	vsub.f32	s15, s13, s15
 8025490:	eea7 7aa2 	vfma.f32	s14, s15, s5
        fs->fc[i] = fc;
 8025494:	ed82 7a00 	vstr	s14, [r2]
        fs->fb[i] = fb;
 8025498:	6962      	ldr	r2, [r4, #20]
 802549a:	441a      	add	r2, r3
 802549c:	edc2 6a00 	vstr	s13, [r2]
        fk = fa*fc*foma + fs->fk[i]*falph;
 80254a0:	6922      	ldr	r2, [r4, #16]
 80254a2:	441a      	add	r2, r3
 80254a4:	edd2 6a00 	vldr	s13, [r2]
 80254a8:	ee65 6a26 	vmul.f32	s13, s10, s13
 80254ac:	eee6 6a07 	vfma.f32	s13, s12, s14
        fs->fk[i] = fk;
 80254b0:	edc2 6a00 	vstr	s13, [r2]
        tf = tf*foma + fs->fsmooth[i]*falph;
 80254b4:	e9d4 0209 	ldrd	r0, r2, [r4, #36]	; 0x24
        tf = fk/(fs->fsig[i] + 0.000001f);
 80254b8:	4418      	add	r0, r3
        tf = tf*foma + fs->fsmooth[i]*falph;
 80254ba:	441a      	add	r2, r3
        tf = fk/(fs->fsig[i] + 0.000001f);
 80254bc:	ed90 6a00 	vldr	s12, [r0]
        tf = tf*foma + fs->fsmooth[i]*falph;
 80254c0:	edd2 7a00 	vldr	s15, [r2]
        tf = fk/(fs->fsig[i] + 0.000001f);
 80254c4:	ee36 6a03 	vadd.f32	s12, s12, s6
        tf = tf*foma + fs->fsmooth[i]*falph;
 80254c8:	ee65 7a27 	vmul.f32	s15, s10, s15
        tf = fk/(fs->fsig[i] + 0.000001f);
 80254cc:	ee86 4a86 	vdiv.f32	s8, s13, s12
        fs->fsmooth[i] = tf;
        fs->fbuff[i] = tf;
        fb = fc - tf*fa;
 80254d0:	eef0 6a47 	vmov.f32	s13, s14
        tf = tf*foma + fs->fsmooth[i]*falph;
 80254d4:	eee5 7a84 	vfma.f32	s15, s11, s8
        fs->fsmooth[i] = tf;
 80254d8:	edc2 7a00 	vstr	s15, [r2]
        fb = fc - tf*fa;
 80254dc:	eee7 6ac0 	vfms.f32	s13, s15, s0
        fs->fbuff[i] = tf;
 80254e0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        fa = fa - tf*fc;
 80254e2:	eea7 0a67 	vfms.f32	s0, s14, s15
        fs->fbuff[i] = tf;
 80254e6:	4413      	add	r3, r2
 80254e8:	edc3 7a00 	vstr	s15, [r3]
    for(int i = 0; i < ford; i++)
 80254ec:	d4ae      	bmi.n	802544c <tFormantShifter_remove+0x5c>
    }

    //return fa * 0.1f;
    return fa;
}
 80254ee:	bd10      	pop	{r4, pc}
    fa = tf - fs->fhp;
 80254f0:	eeb0 0a66 	vmov.f32	s0, s13
}
 80254f4:	bd10      	pop	{r4, pc}
 80254f6:	bf00      	nop

080254f8 <tFormantShifter_add>:

float tFormantShifter_add(tFormantShifter* const fsr, float in)
{
 80254f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80254fa:	ed2d 8b02 	vpush	{d8}
    _tFormantShifter* fs = *fsr;
 80254fe:	6804      	ldr	r4, [r0, #0]
    float fa, fb, fc, ford, flpa, flamb, tf, tf2, f0resp, f1resp, frlamb;
    ford = fs->ford;

    flpa = fs->flpa;
    flamb = fs->flamb;
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8025500:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    frlamb = (tf-1.0f)/(tf+1.0f);
    
    tf2 = in;
    fa = 0.0f;
    fb = fa;
 8025504:	2300      	movs	r3, #0
    flamb = fs->flamb;
 8025506:	edd4 7a03 	vldr	s15, [r4, #12]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 802550a:	ed94 5a13 	vldr	s10, [r4, #76]	; 0x4c
 802550e:	ee37 6a87 	vadd.f32	s12, s15, s14
    flpa = fs->flpa;
 8025512:	ed94 3a0d 	vldr	s6, [r4, #52]	; 0x34
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8025516:	ee77 6a67 	vsub.f32	s13, s14, s15
    ford = fs->ford;
 802551a:	edd4 7a01 	vldr	s15, [r4, #4]
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 802551e:	ee26 6a05 	vmul.f32	s12, s12, s10
    ford = fs->ford;
 8025522:	eef8 5ae7 	vcvt.f32.s32	s11, s15
    tf = fs->shiftFactor * (1.0f+flamb)/(1.0f-flamb);
 8025526:	eec6 7a26 	vdiv.f32	s15, s12, s13
    for (int i=0; i<ford; i++)
 802552a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 802552e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    frlamb = (tf-1.0f)/(tf+1.0f);
 8025532:	ee77 6ac7 	vsub.f32	s13, s15, s14
 8025536:	ee77 7a87 	vadd.f32	s15, s15, s14
 802553a:	ee86 5aa7 	vdiv.f32	s10, s13, s15
    for (int i=0; i<ford; i++)
 802553e:	f340 8109 	ble.w	8025754 <tFormantShifter_add+0x25c>
 8025542:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8025544:	4619      	mov	r1, r3
    fb = fa;
 8025546:	ee06 3a90 	vmov	s13, r3
    fa = 0.0f;
 802554a:	ee07 3a90 	vmov	s15, r3
 802554e:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 8025550:	3101      	adds	r1, #1
 8025552:	ee04 1a90 	vmov	s9, r1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
 8025556:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025558:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
 802555c:	eef8 4ae4 	vcvt.f32.s32	s9, s9
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025560:	18c6      	adds	r6, r0, r3
 8025562:	441d      	add	r5, r3
        tf = fs->fbuff[i];
 8025564:	6ba0      	ldr	r0, [r4, #56]	; 0x38
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025566:	ed96 6a00 	vldr	s12, [r6]
    for (int i=0; i<ford; i++)
 802556a:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 802556e:	ed95 7a00 	vldr	s14, [r5]
        tf = fs->fbuff[i];
 8025572:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025574:	ee76 6ac6 	vsub.f32	s13, s13, s12
        tf = fs->fbuff[i];
 8025578:	ed90 6a00 	vldr	s12, [r0]
    for (int i=0; i<ford; i++)
 802557c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025580:	eea6 7a85 	vfma.f32	s14, s13, s10
        fs->ftvec[i] = tf*fc;
 8025584:	ee27 4a06 	vmul.f32	s8, s14, s12
        fb = fc - tf*fa;
 8025588:	eea6 7a67 	vfms.f32	s14, s12, s15
        fs->ftvec[i] = tf*fc;
 802558c:	ed82 4a00 	vstr	s8, [r2]
        fa = fa - fs->ftvec[i];
 8025590:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8025592:	4413      	add	r3, r2
        fb = fc - tf*fa;
 8025594:	eef0 6a47 	vmov.f32	s13, s14
        fa = fa - fs->ftvec[i];
 8025598:	ed93 7a00 	vldr	s14, [r3]
 802559c:	ee77 7ac7 	vsub.f32	s15, s15, s14
    for (int i=0; i<ford; i++)
 80255a0:	d4d5      	bmi.n	802554e <tFormantShifter_add+0x56>
 80255a2:	eeb1 7a67 	vneg.f32	s14, s15
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
 80255a6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80255aa:	ee75 7ae7 	vsub.f32	s15, s11, s15
 80255ae:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 80255b2:	ee17 7a90 	vmov	r7, s15
 80255b6:	2f00      	cmp	r7, #0
 80255b8:	f2c0 80c4 	blt.w	8025744 <tFormantShifter_add+0x24c>
    {
        tf = tf + fs->ftvec[i];
 80255bc:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80255be:	1c7b      	adds	r3, r7, #1
 80255c0:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 80255c4:	ed71 7a01 	vldmdb	r1!, {s15}
    for (int i=ford-1; i>=0; i--)
 80255c8:	428a      	cmp	r2, r1
        tf = tf + fs->ftvec[i];
 80255ca:	ee37 7a27 	vadd.f32	s14, s14, s15
    for (int i=ford-1; i>=0; i--)
 80255ce:	d1f9      	bne.n	80255c4 <tFormantShifter_add+0xcc>
    f0resp = tf;
    
    //  second time: compute 1-response
    fa = 1.0f;
    fb = fa;
    for (int i=0; i<ford; i++)
 80255d0:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 80255d4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80255d8:	f340 80c1 	ble.w	802575e <tFormantShifter_add+0x266>
    fb = fa;
 80255dc:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    for (int i=0; i<ford; i++)
 80255e0:	2100      	movs	r1, #0
    fa = 1.0f;
 80255e2:	eef0 7a46 	vmov.f32	s15, s12
 80255e6:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 80255e8:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 80255ea:	e9d4 5007 	ldrd	r5, r0, [r4, #28]
    for (int i=0; i<ford; i++)
 80255ee:	ee04 1a10 	vmov	s8, r1
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
        fs->ftvec[i] = tf*fc;
 80255f2:	441a      	add	r2, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 80255f4:	18c6      	adds	r6, r0, r3
 80255f6:	441d      	add	r5, r3
        tf = fs->fbuff[i];
 80255f8:	6ba0      	ldr	r0, [r4, #56]	; 0x38
    for (int i=0; i<ford; i++)
 80255fa:	eeb8 4ac4 	vcvt.f32.s32	s8, s8
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 80255fe:	edd6 4a00 	vldr	s9, [r6]
 8025602:	edd5 6a00 	vldr	s13, [r5]
        tf = fs->fbuff[i];
 8025606:	4418      	add	r0, r3
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025608:	ee36 6a64 	vsub.f32	s12, s12, s9
        tf = fs->fbuff[i];
 802560c:	edd0 4a00 	vldr	s9, [r0]
    for (int i=0; i<ford; i++)
 8025610:	eeb4 4ae5 	vcmpe.f32	s8, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025614:	eee6 6a05 	vfma.f32	s13, s12, s10
    for (int i=0; i<ford; i++)
 8025618:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->ftvec[i] = tf*fc;
 802561c:	ee66 3aa4 	vmul.f32	s7, s13, s9
        fb = fc - tf*fa;
 8025620:	eee4 6ae7 	vfms.f32	s13, s9, s15
        fs->ftvec[i] = tf*fc;
 8025624:	edc2 3a00 	vstr	s7, [r2]
        fa = fa - fs->ftvec[i];
 8025628:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 802562a:	4413      	add	r3, r2
        fb = fc - tf*fa;
 802562c:	eeb0 6a66 	vmov.f32	s12, s13
        fa = fa - fs->ftvec[i];
 8025630:	edd3 6a00 	vldr	s13, [r3]
 8025634:	ee77 7ae6 	vsub.f32	s15, s15, s13
    for (int i=0; i<ford; i++)
 8025638:	d4d5      	bmi.n	80255e6 <tFormantShifter_add+0xee>
    }
    tf = -fa;
    for (int i=ford-1; i>=0; i--)
 802563a:	2f00      	cmp	r7, #0
 802563c:	eef1 7a67 	vneg.f32	s15, s15
 8025640:	db08      	blt.n	8025654 <tFormantShifter_add+0x15c>
 8025642:	1c7b      	adds	r3, r7, #1
 8025644:	eb02 0383 	add.w	r3, r2, r3, lsl #2
    {
        tf = tf + fs->ftvec[i];
 8025648:	ed73 6a01 	vldmdb	r3!, {s13}
    for (int i=ford-1; i>=0; i--)
 802564c:	429a      	cmp	r2, r3
        tf = tf + fs->ftvec[i];
 802564e:	ee77 7aa6 	vadd.f32	s15, s15, s13
    for (int i=ford-1; i>=0; i--)
 8025652:	d1f9      	bne.n	8025648 <tFormantShifter_add+0x150>
    f1resp = tf;
    
    //  now solve equations for output, based on 0-response and 1-response
    tf = 2.0f*tf2;
    tf2 = tf;
    tf = (1.0f - f1resp + f0resp);
 8025654:	ee77 7a67 	vsub.f32	s15, s14, s15
    if (tf!=0.0f)
 8025658:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 802565c:	eef4 7a66 	vcmp.f32	s15, s13
 8025660:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025664:	d066      	beq.n	8025734 <tFormantShifter_add+0x23c>
    {
        tf2 = (tf2 + f0resp) / tf;
 8025666:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
    tf = (1.0f - f1resp + f0resp);
 802566a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
        tf2 = (tf2 + f0resp) / tf;
 802566e:	eea0 7a06 	vfma.f32	s14, s0, s12
    tf = (1.0f - f1resp + f0resp);
 8025672:	ee77 7aa6 	vadd.f32	s15, s15, s13
        tf2 = (tf2 + f0resp) / tf;
 8025676:	ee87 0a27 	vdiv.f32	s0, s14, s15
    }
    
    //  third time: update delay registers
    fa = tf2;
    fb = fa;
    for (int i=0; i<ford; i++)
 802567a:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 802567e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025682:	dd2b      	ble.n	80256dc <tFormantShifter_add+0x1e4>
    fb = fa;
 8025684:	eeb0 6a40 	vmov.f32	s12, s0
    for (int i=0; i<ford; i++)
 8025688:	2100      	movs	r1, #0
    fa = tf2;
 802568a:	eef0 6a40 	vmov.f32	s13, s0
 802568e:	008b      	lsls	r3, r1, #2
    for (int i=0; i<ford; i++)
 8025690:	3101      	adds	r1, #1
    {
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 8025692:	e9d4 0207 	ldrd	r0, r2, [r4, #28]
    for (int i=0; i<ford; i++)
 8025696:	ee07 1a90 	vmov	s15, r1
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 802569a:	441a      	add	r2, r3
 802569c:	4418      	add	r0, r3
    for (int i=0; i<ford; i++)
 802569e:	eef8 4ae7 	vcvt.f32.s32	s9, s15
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 80256a2:	ed92 7a00 	vldr	s14, [r2]
 80256a6:	edd0 7a00 	vldr	s15, [r0]
 80256aa:	ee36 7a47 	vsub.f32	s14, s12, s14
    for (int i=0; i<ford; i++)
 80256ae:	eef4 4ae5 	vcmpe.f32	s9, s11
        fc = (fb-fs->frc[i])*frlamb + fs->frb[i];
 80256b2:	eee7 7a05 	vfma.f32	s15, s14, s10
    for (int i=0; i<ford; i++)
 80256b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        fs->frc[i] = fc;
 80256ba:	edc2 7a00 	vstr	s15, [r2]
        fs->frb[i] = fb;
 80256be:	69e2      	ldr	r2, [r4, #28]
 80256c0:	441a      	add	r2, r3
 80256c2:	ed82 6a00 	vstr	s12, [r2]
        tf = fs->fbuff[i];
        fb = fc - tf*fa;
 80256c6:	eeb0 6a67 	vmov.f32	s12, s15
        tf = fs->fbuff[i];
 80256ca:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80256cc:	4413      	add	r3, r2
 80256ce:	ed93 7a00 	vldr	s14, [r3]
        fb = fc - tf*fa;
 80256d2:	eea7 6a66 	vfms.f32	s12, s14, s13
        fa = fa - tf*fc;
 80256d6:	eee7 6ac7 	vfms.f32	s13, s15, s14
    for (int i=0; i<ford; i++)
 80256da:	d4d8      	bmi.n	802568e <tFormantShifter_add+0x196>
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
    fs->flp = tf;
    
    // Bring up the gain slowly when formant correction goes from disabled
    // to enabled, while things stabilize.
    if (fs->fmute>0.5f)
 80256dc:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
 80256e0:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
 80256e4:	ed94 8a10 	vldr	s16, [r4, #64]	; 0x40
    tf = tf + flpa * fs->flp;  // lowpass post-emphasis filter
 80256e8:	eea7 0a03 	vfma.f32	s0, s14, s6
    if (fs->fmute>0.5f)
 80256ec:	eeb4 8ae7 	vcmpe.f32	s16, s15
 80256f0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    fs->flp = tf;
 80256f4:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
    if (fs->fmute>0.5f)
 80256f8:	dd20      	ble.n	802573c <tFormantShifter_add+0x244>
    {
        tf = tf*(fs->fmute - 0.5f)*2.0f;
 80256fa:	ee78 7a67 	vsub.f32	s15, s16, s15
 80256fe:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8025702:	ee27 0a80 	vmul.f32	s0, s15, s0
 8025706:	f005 ff2d 	bl	802b564 <tanhf>
    else
    {
        tf = 0.0f;
    }
    tf2 = fs->fmutealph;
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
 802570a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802570e:	ed94 7a11 	vldr	s14, [r4, #68]	; 0x44
    // now tf is signal output
    // ...and we're done messing with formants
    //tf = tFeedbackLeveler_tick(&fs->fbl2, tf);
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
 8025712:	f104 005c 	add.w	r0, r4, #92	; 0x5c
    fs->fmute = (1.0f-tf2) + tf2*fs->fmute;
 8025716:	ee38 8a67 	vsub.f32	s16, s16, s15
 802571a:	eee8 7a07 	vfma.f32	s15, s16, s14
 802571e:	edc4 7a10 	vstr	s15, [r4, #64]	; 0x40
    tf = tHighpass_tick(&fs->hp2, tanhf(tf));
 8025722:	f000 ff87 	bl	8026634 <tHighpass_tick>

    return tf * fs->invIntensity;
 8025726:	edd4 7a15 	vldr	s15, [r4, #84]	; 0x54
}
 802572a:	ecbd 8b02 	vpop	{d8}
    return tf * fs->invIntensity;
 802572e:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8025732:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        tf2 = 0.0f;
 8025734:	2300      	movs	r3, #0
 8025736:	ee00 3a10 	vmov	s0, r3
 802573a:	e79e      	b.n	802567a <tFormantShifter_add+0x182>
 802573c:	2300      	movs	r3, #0
 802573e:	ee00 3a10 	vmov	s0, r3
 8025742:	e7e2      	b.n	802570a <tFormantShifter_add+0x212>
    for (int i=0; i<ford; i++)
 8025744:	eef5 5ac0 	vcmpe.f32	s11, #0.0
 8025748:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802574c:	dc05      	bgt.n	802575a <tFormantShifter_add+0x262>
 802574e:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8025752:	e77f      	b.n	8025654 <tFormantShifter_add+0x15c>
    for (int i=0; i<ford; i++)
 8025754:	ee07 3a10 	vmov	s14, r3
 8025758:	e725      	b.n	80255a6 <tFormantShifter_add+0xae>
 802575a:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 802575c:	e73e      	b.n	80255dc <tFormantShifter_add+0xe4>
    for (int i=0; i<ford; i++)
 802575e:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 8025762:	e76f      	b.n	8025644 <tFormantShifter_add+0x14c>

08025764 <tFormantShifter_setShiftFactor>:

// 1.0f is no change, 2.0f is an octave up, 0.5f is an octave down
void tFormantShifter_setShiftFactor(tFormantShifter* const fsr, float shiftFactor)
{
    _tFormantShifter* fs = *fsr;
 8025764:	6803      	ldr	r3, [r0, #0]
    fs->shiftFactor = shiftFactor;
 8025766:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
 802576a:	4770      	bx	lr

0802576c <tFormantShifter_setIntensity>:
{
    _tFormantShifter* fs = *fsr;



    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 802576c:	2300      	movs	r3, #0
 802576e:	eef0 0a40 	vmov.f32	s1, s0
 8025772:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8025776:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
{
 802577a:	b510      	push	{r4, lr}
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 802577c:	ee01 3a10 	vmov	s2, r3
    _tFormantShifter* fs = *fsr;
 8025780:	6804      	ldr	r4, [r0, #0]
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 8025782:	f002 f919 	bl	80279b8 <LEAF_clip>

   // tFeedbackLeveler_setTargetLevel(&fs->fbl1, fs->intensity);
    //tFeedbackLeveler_setTargetLevel(&fs->fbl2, fs->intensity);
    //make sure you don't divide by zero, doofies
    if (fs->intensity != 0.0f)
 8025786:	eeb5 0a40 	vcmp.f32	s0, #0.0
    fs->intensity = LEAF_clip(1.0f, intensity, 100.0f);
 802578a:	ed84 0a14 	vstr	s0, [r4, #80]	; 0x50
    if (fs->intensity != 0.0f)
 802578e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025792:	d104      	bne.n	802579e <tFormantShifter_setIntensity+0x32>
    {
    	fs->invIntensity = 1.0f/fs->intensity;
    }
    else
    {
    	fs->invIntensity = 1.0f;
 8025794:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025798:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
    }

}
 802579c:	bd10      	pop	{r4, pc}
    	fs->invIntensity = 1.0f/fs->intensity;
 802579e:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 80257a2:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80257a6:	edc4 7a15 	vstr	s15, [r4, #84]	; 0x54
}
 80257aa:	bd10      	pop	{r4, pc}

080257ac <tADSR4_initToPool>:
}

//initialize with an exponential function that decays -- i.e. a call to LEAF_generate_exp(expBuffer, 0.001f, 0.0f, 1.0f, -0.0008f, EXP_BUFFER_SIZE);
//times are in ms
void    tADSR4_initToPool    (tADSR4* const adsrenv, float attack, float decay, float sustain, float release, float* expBuffer, int bufferSize, tMempool* const mp)
{
 80257ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80257ae:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 80257b2:	681d      	ldr	r5, [r3, #0]
{
 80257b4:	4607      	mov	r7, r0
 80257b6:	460e      	mov	r6, r1
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 80257b8:	2050      	movs	r0, #80	; 0x50
 80257ba:	4629      	mov	r1, r5
{
 80257bc:	4614      	mov	r4, r2
 80257be:	eef0 8a61 	vmov.f32	s17, s3
 80257c2:	eef0 9a40 	vmov.f32	s19, s0
 80257c6:	eeb0 9a60 	vmov.f32	s18, s1
 80257ca:	eeb0 8a41 	vmov.f32	s16, s2
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 80257ce:	f002 fb0d 	bl	8027dec <mpool_alloc>

    adsr->exp_buff = expBuffer;
    adsr->buff_size = bufferSize;
    adsr->buff_sizeMinusOne = bufferSize - 1;

    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 80257d2:	f249 42a0 	movw	r2, #38048	; 0x94a0
 80257d6:	f241 216f 	movw	r1, #4719	; 0x126f
    _tADSR4* adsr = *adsrenv = (_tADSR4*) mpool_alloc(sizeof(_tADSR4), m);
 80257da:	6038      	str	r0, [r7, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 80257dc:	ee07 4a90 	vmov	s15, r4
 80257e0:	f2c2 0201 	movt	r2, #8193	; 0x2001
 80257e4:	f6c3 2183 	movt	r1, #14979	; 0x3a83
    adsr->mempool = m;
 80257e8:	6005      	str	r5, [r0, #0]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 80257ea:	eeb8 5ae7 	vcvt.f32.s32	s10, s15
 80257ee:	ed92 6a00 	vldr	s12, [r2]
 80257f2:	ee06 1a90 	vmov	s13, r1
 80257f6:	2300      	movs	r3, #0
    adsr->sustain = sustain;

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 80257f8:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 80257fc:	ee66 6a26 	vmul.f32	s13, s12, s13
    adsr->buff_sizeMinusOne = bufferSize - 1;
 8025800:	1e62      	subs	r2, r4, #1
    adsr->sustain = sustain;
 8025802:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8025806:	ee07 3a10 	vmov	s14, r3
    adsr->exp_buff = expBuffer;
 802580a:	6046      	str	r6, [r0, #4]
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 802580c:	eec5 7a26 	vdiv.f32	s15, s10, s13
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8025810:	fec9 9a87 	vmaxnm.f32	s19, s19, s14
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8025814:	fe89 9a07 	vmaxnm.f32	s18, s18, s14
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8025818:	fec8 1a87 	vmaxnm.f32	s3, s17, s14
 802581c:	fe88 8a07 	vmaxnm.f32	s16, s16, s14

    adsr->leakFactor = 1.0f;
 8025820:	ed80 6a13 	vstr	s12, [r0, #76]	; 0x4c
    adsr->sustain = sustain;
 8025824:	fe88 8a46 	vminnm.f32	s16, s16, s12
    adsr->buff_size = bufferSize;
 8025828:	6084      	str	r4, [r0, #8]
    adsr->buff_sizeMinusOne = bufferSize - 1;
 802582a:	60c2      	str	r2, [r0, #12]
    adsr->whichStage = env_idle;
 802582c:	6283      	str	r3, [r0, #40]	; 0x28
    adsr->next = 0.0f;
 802582e:	6143      	str	r3, [r0, #20]
    adsr->sustain = sustain;
 8025830:	ed80 8a0b 	vstr	s16, [r0, #44]	; 0x2c
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8025834:	ee87 6aa9 	vdiv.f32	s12, s15, s19
    adsr->bufferSizeDividedBySampleRateInMs = bufferSize / (leaf.sampleRate * 0.001f);
 8025838:	edc0 7a04 	vstr	s15, [r0, #16]
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 802583c:	eec7 6a89 	vdiv.f32	s13, s15, s18
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8025840:	ee87 7aa1 	vdiv.f32	s14, s15, s3
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 8025844:	ee67 7aa5 	vmul.f32	s15, s15, s11
    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 8025848:	ed80 6a06 	vstr	s12, [r0, #24]
    adsr->rampInc = adsr->bufferSizeDividedBySampleRateInMs / 8.0f;
 802584c:	edc0 7a09 	vstr	s15, [r0, #36]	; 0x24
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8025850:	edc0 6a07 	vstr	s13, [r0, #28]
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 8025854:	ed80 7a08 	vstr	s14, [r0, #32]
}
 8025858:	ecbd 8b04 	vpop	{d8-d9}
 802585c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 802585e:	bf00      	nop

08025860 <tADSR4_free>:

void    tADSR4_free  (tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 8025860:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)adsr, adsr->mempool);
 8025862:	6801      	ldr	r1, [r0, #0]
 8025864:	f002 bb6c 	b.w	8027f40 <mpool_free>

08025868 <tADSR4_setAttack>:
}

void     tADSR4_setAttack(tADSR4* const adsrenv, float attack)
{
    _tADSR4* adsr = *adsrenv;
 8025868:	6802      	ldr	r2, [r0, #0]
    if (attack < 0.0f)
    {
        attack = 0.0f;
    }

    adsr->attackInc = adsr->bufferSizeDividedBySampleRateInMs / attack;
 802586a:	2300      	movs	r3, #0
 802586c:	ed92 7a04 	vldr	s14, [r2, #16]
 8025870:	ee07 3a90 	vmov	s15, r3
 8025874:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 8025878:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802587c:	edc2 7a06 	vstr	s15, [r2, #24]
}
 8025880:	4770      	bx	lr
 8025882:	bf00      	nop

08025884 <tADSR4_setDecay>:

void     tADSR4_setDecay(tADSR4* const adsrenv, float decay)
{
    _tADSR4* adsr = *adsrenv;
 8025884:	6802      	ldr	r2, [r0, #0]

    if (decay < 0.0f)
    {
        decay = 0.0f;
    }
    adsr->decayInc = adsr->bufferSizeDividedBySampleRateInMs / decay;
 8025886:	2300      	movs	r3, #0
 8025888:	ed92 7a04 	vldr	s14, [r2, #16]
 802588c:	ee07 3a90 	vmov	s15, r3
 8025890:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 8025894:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8025898:	edc2 7a07 	vstr	s15, [r2, #28]
}
 802589c:	4770      	bx	lr
 802589e:	bf00      	nop

080258a0 <tADSR4_setSustain>:

void     tADSR4_setSustain(tADSR4* const adsrenv, float sustain)
{
    _tADSR4* adsr = *adsrenv;

    if (sustain > 1.0f)      adsr->sustain = 1.0f;
 80258a0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tADSR4* adsr = *adsrenv;
 80258a4:	6803      	ldr	r3, [r0, #0]
    if (sustain > 1.0f)      adsr->sustain = 1.0f;
 80258a6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80258aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80258ae:	dd02      	ble.n	80258b6 <tADSR4_setSustain+0x16>
 80258b0:	edc3 7a0b 	vstr	s15, [r3, #44]	; 0x2c
 80258b4:	4770      	bx	lr
    else if (sustain < 0.0f) adsr->sustain = 0.0f;
 80258b6:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 80258ba:	2200      	movs	r2, #0
 80258bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80258c0:	bf4c      	ite	mi
 80258c2:	62da      	strmi	r2, [r3, #44]	; 0x2c
    else                     adsr->sustain = sustain;
 80258c4:	ed83 0a0b 	vstrpl	s0, [r3, #44]	; 0x2c
}
 80258c8:	4770      	bx	lr
 80258ca:	bf00      	nop

080258cc <tADSR4_setRelease>:

void     tADSR4_setRelease(tADSR4* const adsrenv, float release)
{
    _tADSR4* adsr = *adsrenv;
 80258cc:	6802      	ldr	r2, [r0, #0]

    if (release < 0.0f)
    {
        release = 0.0f;
    }
    adsr->releaseInc = adsr->bufferSizeDividedBySampleRateInMs / release;
 80258ce:	2300      	movs	r3, #0
 80258d0:	ed92 7a04 	vldr	s14, [r2, #16]
 80258d4:	ee07 3a90 	vmov	s15, r3
 80258d8:	fe80 0a27 	vmaxnm.f32	s0, s0, s15
 80258dc:	eec7 7a00 	vdiv.f32	s15, s14, s0
 80258e0:	edc2 7a08 	vstr	s15, [r2, #32]
}
 80258e4:	4770      	bx	lr
 80258e6:	bf00      	nop

080258e8 <tADSR4_setLeakFactor>:

// 0.999999 is slow leak, 0.9 is fast leak
void     tADSR4_setLeakFactor(tADSR4* const adsrenv, float leakFactor)
{
    _tADSR4* adsr = *adsrenv;
 80258e8:	6803      	ldr	r3, [r0, #0]


    adsr->leakFactor = leakFactor;
 80258ea:	ed83 0a13 	vstr	s0, [r3, #76]	; 0x4c
}
 80258ee:	4770      	bx	lr

080258f0 <tADSR4_on>:

void tADSR4_on(tADSR4* const adsrenv, float velocity)
{
    _tADSR4* adsr = *adsrenv;
 80258f0:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage != env_idle) // In case ADSR retriggered while it is still happening.
 80258f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80258f4:	b942      	cbnz	r2, 8025908 <tADSR4_on+0x18>
        adsr->whichStage = env_ramp;
        adsr->rampPeak = adsr->next;
    }
    else // Normal start.
    {
        adsr->whichStage = env_attack;
 80258f6:	2101      	movs	r1, #1
    }

    adsr->attackPhase = 0;
 80258f8:	2200      	movs	r2, #0
 80258fa:	6299      	str	r1, [r3, #40]	; 0x28
    adsr->decayPhase = 0;
    adsr->releasePhase = 0;
    adsr->gain = velocity;
 80258fc:	ed83 0a0c 	vstr	s0, [r3, #48]	; 0x30
    adsr->attackPhase = 0;
 8025900:	63da      	str	r2, [r3, #60]	; 0x3c
    adsr->decayPhase = 0;
 8025902:	641a      	str	r2, [r3, #64]	; 0x40
    adsr->releasePhase = 0;
 8025904:	645a      	str	r2, [r3, #68]	; 0x44
}
 8025906:	4770      	bx	lr
        adsr->rampPhase = 0;
 8025908:	2200      	movs	r2, #0
        adsr->rampPeak = adsr->next;
 802590a:	6958      	ldr	r0, [r3, #20]
        adsr->whichStage = env_ramp;
 802590c:	2105      	movs	r1, #5
        adsr->rampPeak = adsr->next;
 802590e:	6358      	str	r0, [r3, #52]	; 0x34
        adsr->rampPhase = 0;
 8025910:	649a      	str	r2, [r3, #72]	; 0x48
 8025912:	e7f1      	b.n	80258f8 <tADSR4_on+0x8>

08025914 <tADSR4_off>:

void tADSR4_off(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 8025914:	6803      	ldr	r3, [r0, #0]

    if (adsr->whichStage == env_idle)
 8025916:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8025918:	b11a      	cbz	r2, 8025922 <tADSR4_off+0xe>
    {
        return;
    }
    else
    {
        adsr->whichStage = env_release;
 802591a:	2104      	movs	r1, #4
        adsr->releasePeak = adsr->next;
 802591c:	695a      	ldr	r2, [r3, #20]
        adsr->whichStage = env_release;
 802591e:	6299      	str	r1, [r3, #40]	; 0x28
        adsr->releasePeak = adsr->next;
 8025920:	639a      	str	r2, [r3, #56]	; 0x38
    }
}
 8025922:	4770      	bx	lr

08025924 <tADSR4_tick>:

float   tADSR4_tick(tADSR4* const adsrenv)
{
 8025924:	b510      	push	{r4, lr}
    _tADSR4* adsr = *adsrenv;
 8025926:	6804      	ldr	r4, [r0, #0]
{
 8025928:	ed2d 8b02 	vpush	{d8}

    switch (adsr->whichStage)
 802592c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802592e:	3b01      	subs	r3, #1
 8025930:	2b04      	cmp	r3, #4
 8025932:	f200 8087 	bhi.w	8025a44 <tADSR4_tick+0x120>
 8025936:	e8df f003 	tbb	[pc, r3]
 802593a:	4920      	.short	0x4920
 802593c:	693c      	.short	0x693c
 802593e:	03          	.byte	0x03
 802593f:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
 8025940:	edd4 7a03 	vldr	s15, [r4, #12]
 8025944:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
 8025948:	eef8 7a67 	vcvt.f32.u32	s15, s15
 802594c:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8025950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025954:	f340 80de 	ble.w	8025b14 <tADSR4_tick+0x1f0>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
 8025958:	2300      	movs	r3, #0
                adsr->whichStage = env_attack;
 802595a:	2201      	movs	r2, #1
                adsr->next = 0.0f;
 802595c:	ee08 3a10 	vmov	s16, r3
                adsr->whichStage = env_attack;
 8025960:	62a2      	str	r2, [r4, #40]	; 0x28
                adsr->next = 0.0f;
 8025962:	6163      	str	r3, [r4, #20]
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
                }
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
            }

            adsr->rampPhase += adsr->rampInc;
 8025964:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
            break;
    }
    return adsr->next;
}
 8025968:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->rampPhase += adsr->rampInc;
 802596c:	ee37 1a81 	vadd.f32	s2, s15, s2
 8025970:	ed84 1a12 	vstr	s2, [r4, #72]	; 0x48
}
 8025974:	ecbd 8b02 	vpop	{d8}
 8025978:	bd10      	pop	{r4, pc}
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
 802597a:	edd4 7a03 	vldr	s15, [r4, #12]
 802597e:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 8025982:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8025986:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
 802598a:	eeb4 1ae7 	vcmpe.f32	s2, s15
 802598e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025992:	dd5e      	ble.n	8025a52 <tADSR4_tick+0x12e>
                adsr->whichStage = env_decay;
 8025994:	2302      	movs	r3, #2
                adsr->next = adsr->gain;
 8025996:	ed84 8a05 	vstr	s16, [r4, #20]
                adsr->whichStage = env_decay;
 802599a:	62a3      	str	r3, [r4, #40]	; 0x28
            adsr->attackPhase += adsr->attackInc;
 802599c:	edd4 7a06 	vldr	s15, [r4, #24]
}
 80259a0:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->attackPhase += adsr->attackInc;
 80259a4:	ee37 1a81 	vadd.f32	s2, s15, s2
 80259a8:	ed84 1a0f 	vstr	s2, [r4, #60]	; 0x3c
}
 80259ac:	ecbd 8b02 	vpop	{d8}
 80259b0:	bd10      	pop	{r4, pc}
            adsr->next = adsr->next * adsr->leakFactor;
 80259b2:	ed94 8a05 	vldr	s16, [r4, #20]
 80259b6:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 80259ba:	ee28 8a27 	vmul.f32	s16, s16, s15
}
 80259be:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->next = adsr->next * adsr->leakFactor;
 80259c2:	ed84 8a05 	vstr	s16, [r4, #20]
}
 80259c6:	ecbd 8b02 	vpop	{d8}
 80259ca:	bd10      	pop	{r4, pc}
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
 80259cc:	edd4 7a03 	vldr	s15, [r4, #12]
 80259d0:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
 80259d4:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80259d8:	eeb4 1ae7 	vcmpe.f32	s2, s15
 80259dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80259e0:	dd63      	ble.n	8025aaa <tADSR4_tick+0x186>
                adsr->next = adsr->gain * adsr->sustain;
 80259e2:	ed94 8a0c 	vldr	s16, [r4, #48]	; 0x30
                adsr->whichStage = env_sustain;
 80259e6:	2303      	movs	r3, #3
                adsr->next = adsr->gain * adsr->sustain;
 80259e8:	edd4 7a0b 	vldr	s15, [r4, #44]	; 0x2c
                adsr->whichStage = env_sustain;
 80259ec:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = adsr->gain * adsr->sustain;
 80259ee:	ee28 8a27 	vmul.f32	s16, s16, s15
 80259f2:	ed84 8a05 	vstr	s16, [r4, #20]
            adsr->decayPhase += adsr->decayInc;
 80259f6:	edd4 7a07 	vldr	s15, [r4, #28]
}
 80259fa:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->decayPhase += adsr->decayInc;
 80259fe:	ee37 1a81 	vadd.f32	s2, s15, s2
 8025a02:	ed84 1a10 	vstr	s2, [r4, #64]	; 0x40
}
 8025a06:	ecbd 8b02 	vpop	{d8}
 8025a0a:	bd10      	pop	{r4, pc}
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
 8025a0c:	edd4 7a03 	vldr	s15, [r4, #12]
 8025a10:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
 8025a14:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8025a18:	eeb4 1ae7 	vcmpe.f32	s2, s15
 8025a1c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025a20:	f340 80a1 	ble.w	8025b66 <tADSR4_tick+0x242>
                adsr->next = 0.0f;
 8025a24:	2300      	movs	r3, #0
 8025a26:	ee08 3a10 	vmov	s16, r3
                adsr->whichStage = env_idle;
 8025a2a:	62a3      	str	r3, [r4, #40]	; 0x28
                adsr->next = 0.0f;
 8025a2c:	6163      	str	r3, [r4, #20]
            adsr->releasePhase += adsr->releaseInc;
 8025a2e:	edd4 7a08 	vldr	s15, [r4, #32]
}
 8025a32:	eeb0 0a48 	vmov.f32	s0, s16
            adsr->releasePhase += adsr->releaseInc;
 8025a36:	ee37 1a81 	vadd.f32	s2, s15, s2
 8025a3a:	ed84 1a11 	vstr	s2, [r4, #68]	; 0x44
}
 8025a3e:	ecbd 8b02 	vpop	{d8}
 8025a42:	bd10      	pop	{r4, pc}
 8025a44:	ed94 8a05 	vldr	s16, [r4, #20]
 8025a48:	eeb0 0a48 	vmov.f32	s0, s16
 8025a4c:	ecbd 8b02 	vpop	{d8}
 8025a50:	bd10      	pop	{r4, pc}
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025a52:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025a56:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->attackPhase;
 8025a58:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025a5c:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->attackPhase - intPart;
 8025a60:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025a64:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->attackPhase - intPart;
 8025a68:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->attackPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025a6c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025a70:	f100 80ae 	bmi.w	8025bd0 <tADSR4_tick+0x2ac>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->attackPhase)+1)];
 8025a74:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025a78:	ee17 3a90 	vmov	r3, s15
 8025a7c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025a80:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->gain * (1.0f - LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // inverted and backwards to get proper rising exponential shape/perception
 8025a84:	ee16 3a90 	vmov	r3, s13
 8025a88:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8025a8c:	ed92 0a00 	vldr	s0, [r2]
 8025a90:	f002 f8d0 	bl	8027c34 <LEAF_interpolation_linear>
 8025a94:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025a98:	ed94 1a0f 	vldr	s2, [r4, #60]	; 0x3c
 8025a9c:	ee37 0ac0 	vsub.f32	s0, s15, s0
 8025aa0:	ee28 8a00 	vmul.f32	s16, s16, s0
 8025aa4:	ed84 8a05 	vstr	s16, [r4, #20]
 8025aa8:	e778      	b.n	802599c <tADSR4_tick+0x78>
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025aaa:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025aae:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->decayPhase;
 8025ab0:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025ab4:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->decayPhase - intPart;
 8025ab8:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025abc:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->decayPhase - intPart;
 8025ac0:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->decayPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025ac4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025ac8:	d47e      	bmi.n	8025bc8 <tADSR4_tick+0x2a4>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->decayPhase)+1)];
 8025aca:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025ace:	ee17 3a90 	vmov	r3, s15
 8025ad2:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025ad6:	edd3 0a00 	vldr	s1, [r3]
                float interpValue = (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart));
 8025ada:	ee16 3a90 	vmov	r3, s13
 8025ade:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8025ae2:	ed92 0a00 	vldr	s0, [r2]
 8025ae6:	f002 f8a5 	bl	8027c34 <LEAF_interpolation_linear>
                adsr->next = (adsr->gain * (adsr->sustain + (interpValue * (1.0f - adsr->sustain)))) * adsr->leakFactor; // do interpolation !
 8025aea:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025aee:	ed94 8a0b 	vldr	s16, [r4, #44]	; 0x2c
 8025af2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 8025af6:	ee37 7a48 	vsub.f32	s14, s14, s16
 8025afa:	edd4 6a13 	vldr	s13, [r4, #76]	; 0x4c
 8025afe:	ed94 1a10 	vldr	s2, [r4, #64]	; 0x40
 8025b02:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8025b06:	eea7 8a00 	vfma.f32	s16, s14, s0
 8025b0a:	ee27 8a88 	vmul.f32	s16, s15, s16
 8025b0e:	ed84 8a05 	vstr	s16, [r4, #20]
 8025b12:	e770      	b.n	80259f6 <tADSR4_tick+0xd2>
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b14:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025b18:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->rampPhase;
 8025b1a:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b1e:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->rampPhase - intPart;
 8025b22:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b26:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->rampPhase - intPart;
 8025b2a:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->rampPhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b2e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025b32:	d445      	bmi.n	8025bc0 <tADSR4_tick+0x29c>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->rampPhase)+1)];
 8025b34:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025b38:	ee17 3a90 	vmov	r3, s15
 8025b3c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025b40:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->rampPeak * LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart);
 8025b44:	ee16 3a90 	vmov	r3, s13
 8025b48:	ed94 8a0d 	vldr	s16, [r4, #52]	; 0x34
 8025b4c:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8025b50:	ed92 0a00 	vldr	s0, [r2]
 8025b54:	f002 f86e 	bl	8027c34 <LEAF_interpolation_linear>
 8025b58:	ee28 8a00 	vmul.f32	s16, s16, s0
 8025b5c:	ed94 1a12 	vldr	s2, [r4, #72]	; 0x48
 8025b60:	ed84 8a05 	vstr	s16, [r4, #20]
 8025b64:	e6fe      	b.n	8025964 <tADSR4_tick+0x40>
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b66:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025b6a:	6862      	ldr	r2, [r4, #4]
                uint32_t intPart = (uint32_t)adsr->releasePhase;
 8025b6c:	eefc 6ac1 	vcvt.u32.f32	s13, s2
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b70:	ee31 7a07 	vadd.f32	s14, s2, s14
                float floatPart = adsr->releasePhase - intPart;
 8025b74:	eeb8 6a66 	vcvt.f32.u32	s12, s13
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b78:	eef4 7ac7 	vcmpe.f32	s15, s14
                float floatPart = adsr->releasePhase - intPart;
 8025b7c:	ee31 1a46 	vsub.f32	s2, s2, s12
                if (adsr->releasePhase + 1.0f > adsr->buff_sizeMinusOne)
 8025b80:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025b84:	d418      	bmi.n	8025bb8 <tADSR4_tick+0x294>
                    secondValue = adsr->exp_buff[(uint32_t)((adsr->releasePhase)+1)];
 8025b86:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8025b8a:	ee17 3a90 	vmov	r3, s15
 8025b8e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 8025b92:	edd3 0a00 	vldr	s1, [r3]
                adsr->next = adsr->releasePeak * (LEAF_interpolation_linear(adsr->exp_buff[intPart], secondValue, floatPart)); // do interpolation !
 8025b96:	ee16 3a90 	vmov	r3, s13
 8025b9a:	ed94 8a0e 	vldr	s16, [r4, #56]	; 0x38
 8025b9e:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 8025ba2:	ed92 0a00 	vldr	s0, [r2]
 8025ba6:	f002 f845 	bl	8027c34 <LEAF_interpolation_linear>
 8025baa:	ee28 8a00 	vmul.f32	s16, s16, s0
 8025bae:	ed94 1a11 	vldr	s2, [r4, #68]	; 0x44
 8025bb2:	ed84 8a05 	vstr	s16, [r4, #20]
 8025bb6:	e73a      	b.n	8025a2e <tADSR4_tick+0x10a>
                    secondValue = 0.0f;
 8025bb8:	2300      	movs	r3, #0
 8025bba:	ee00 3a90 	vmov	s1, r3
 8025bbe:	e7ea      	b.n	8025b96 <tADSR4_tick+0x272>
                    secondValue = 0.0f;
 8025bc0:	2300      	movs	r3, #0
 8025bc2:	ee00 3a90 	vmov	s1, r3
 8025bc6:	e7bd      	b.n	8025b44 <tADSR4_tick+0x220>
                    secondValue = 0.0f;
 8025bc8:	2300      	movs	r3, #0
 8025bca:	ee00 3a90 	vmov	s1, r3
 8025bce:	e784      	b.n	8025ada <tADSR4_tick+0x1b6>
                    secondValue = 0.0f;
 8025bd0:	2300      	movs	r3, #0
 8025bd2:	ee00 3a90 	vmov	s1, r3
 8025bd6:	e755      	b.n	8025a84 <tADSR4_tick+0x160>

08025bd8 <tADSR4_tickNoInterp>:

float   tADSR4_tickNoInterp(tADSR4* const adsrenv)
{
    _tADSR4* adsr = *adsrenv;
 8025bd8:	6803      	ldr	r3, [r0, #0]

    switch (adsr->whichStage)
 8025bda:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8025bdc:	3a01      	subs	r2, #1
 8025bde:	2a04      	cmp	r2, #4
 8025be0:	d873      	bhi.n	8025cca <tADSR4_tickNoInterp+0xf2>
 8025be2:	e8df f002 	tbb	[pc, r2]
 8025be6:	3e1d      	.short	0x3e1d
 8025be8:	5a35      	.short	0x5a35
 8025bea:	03          	.byte	0x03
 8025beb:	00          	.byte	0x00
    {
        case env_ramp:
            if (adsr->rampPhase > adsr->buff_sizeMinusOne)
 8025bec:	edd3 7a03 	vldr	s15, [r3, #12]
 8025bf0:	edd3 6a12 	vldr	s13, [r3, #72]	; 0x48
 8025bf4:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8025bf8:	eef4 6ac7 	vcmpe.f32	s13, s14
 8025bfc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025c00:	f340 808c 	ble.w	8025d1c <tADSR4_tickNoInterp+0x144>
            {
                adsr->whichStage = env_attack;
                adsr->next = 0.0f;
 8025c04:	2200      	movs	r2, #0
                adsr->whichStage = env_attack;
 8025c06:	2101      	movs	r1, #1
                adsr->next = 0.0f;
 8025c08:	ee00 2a10 	vmov	s0, r2
                adsr->whichStage = env_attack;
 8025c0c:	6299      	str	r1, [r3, #40]	; 0x28
            else
            {
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
            }

            adsr->rampPhase += adsr->rampInc;
 8025c0e:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
 8025c12:	ed83 0a05 	vstr	s0, [r3, #20]
 8025c16:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8025c1a:	edc3 7a12 	vstr	s15, [r3, #72]	; 0x48
            break;
 8025c1e:	4770      	bx	lr


        case env_attack:

            // If attack done, time to turn around.
            if (adsr->attackPhase > adsr->buff_sizeMinusOne)
 8025c20:	edd3 7a03 	vldr	s15, [r3, #12]
 8025c24:	edd3 6a0f 	vldr	s13, [r3, #60]	; 0x3c
 8025c28:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8025c2c:	ed93 0a0c 	vldr	s0, [r3, #48]	; 0x30
 8025c30:	eef4 6ac7 	vcmpe.f32	s13, s14
 8025c34:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025c38:	dd4a      	ble.n	8025cd0 <tADSR4_tickNoInterp+0xf8>
            {
                adsr->whichStage = env_decay;
 8025c3a:	2202      	movs	r2, #2
 8025c3c:	629a      	str	r2, [r3, #40]	; 0x28
            {
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
            }

            // Increment ADSR attack.
            adsr->attackPhase += adsr->attackInc;
 8025c3e:	edd3 7a06 	vldr	s15, [r3, #24]
 8025c42:	ed83 0a05 	vstr	s0, [r3, #20]
 8025c46:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8025c4a:	edc3 7a0f 	vstr	s15, [r3, #60]	; 0x3c
            break;
 8025c4e:	4770      	bx	lr
            // Increment ADSR decay.
            adsr->decayPhase += adsr->decayInc;
            break;

        case env_sustain:
            adsr->next = adsr->next * adsr->leakFactor;
 8025c50:	ed93 0a05 	vldr	s0, [r3, #20]
 8025c54:	edd3 7a13 	vldr	s15, [r3, #76]	; 0x4c
 8025c58:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025c5c:	ed83 0a05 	vstr	s0, [r3, #20]
            break;
 8025c60:	4770      	bx	lr
            if (adsr->decayPhase > adsr->buff_sizeMinusOne)
 8025c62:	edd3 7a03 	vldr	s15, [r3, #12]
 8025c66:	edd3 6a10 	vldr	s13, [r3, #64]	; 0x40
 8025c6a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8025c6e:	ed93 0a0b 	vldr	s0, [r3, #44]	; 0x2c
 8025c72:	edd3 7a0c 	vldr	s15, [r3, #48]	; 0x30
 8025c76:	eef4 6ac7 	vcmpe.f32	s13, s14
 8025c7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025c7e:	dd37      	ble.n	8025cf0 <tADSR4_tickNoInterp+0x118>
                adsr->next = adsr->gain * adsr->sustain;
 8025c80:	ee20 0a27 	vmul.f32	s0, s0, s15
                adsr->whichStage = env_sustain;
 8025c84:	2203      	movs	r2, #3
 8025c86:	629a      	str	r2, [r3, #40]	; 0x28
            adsr->decayPhase += adsr->decayInc;
 8025c88:	edd3 7a07 	vldr	s15, [r3, #28]
 8025c8c:	ed83 0a05 	vstr	s0, [r3, #20]
 8025c90:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8025c94:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
            break;
 8025c98:	4770      	bx	lr

        case env_release:
            // If release done, finish.
            if (adsr->releasePhase > adsr->buff_sizeMinusOne)
 8025c9a:	edd3 7a03 	vldr	s15, [r3, #12]
 8025c9e:	edd3 6a11 	vldr	s13, [r3, #68]	; 0x44
 8025ca2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8025ca6:	eef4 6ac7 	vcmpe.f32	s13, s14
 8025caa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025cae:	dd43      	ble.n	8025d38 <tADSR4_tickNoInterp+0x160>
            {
                adsr->whichStage = env_idle;
 8025cb0:	2100      	movs	r1, #0
                adsr->next = 0.0f;
 8025cb2:	ee00 1a10 	vmov	s0, r1
                adsr->whichStage = env_idle;
 8025cb6:	6299      	str	r1, [r3, #40]	; 0x28
            else {
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
            }

            // Increment envelope release;
            adsr->releasePhase += adsr->releaseInc;
 8025cb8:	edd3 7a08 	vldr	s15, [r3, #32]
 8025cbc:	ed83 0a05 	vstr	s0, [r3, #20]
 8025cc0:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8025cc4:	edc3 7a11 	vstr	s15, [r3, #68]	; 0x44
            break;
    }
    return adsr->next;
}
 8025cc8:	4770      	bx	lr
 8025cca:	ed93 0a05 	vldr	s0, [r3, #20]
 8025cce:	4770      	bx	lr
                adsr->next = adsr->gain * (1.0f - adsr->exp_buff[(uint32_t)adsr->attackPhase]); // inverted and backwards to get proper rising exponential shape/perception
 8025cd0:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 8025cd4:	685a      	ldr	r2, [r3, #4]
 8025cd6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025cda:	ee17 1a10 	vmov	r1, s14
 8025cde:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8025ce2:	ed92 7a00 	vldr	s14, [r2]
 8025ce6:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8025cea:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025cee:	e7a6      	b.n	8025c3e <tADSR4_tickNoInterp+0x66>
                adsr->next = (adsr->gain * (adsr->sustain + (adsr->exp_buff[(uint32_t)adsr->decayPhase] * (1.0f - adsr->sustain)))) * adsr->leakFactor;
 8025cf0:	eefc 5ae6 	vcvt.u32.f32	s11, s13
 8025cf4:	685a      	ldr	r2, [r3, #4]
 8025cf6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8025cfa:	ed93 6a13 	vldr	s12, [r3, #76]	; 0x4c
 8025cfe:	ee15 1a90 	vmov	r1, s11
 8025d02:	ee67 7a86 	vmul.f32	s15, s15, s12
 8025d06:	ee37 7a40 	vsub.f32	s14, s14, s0
 8025d0a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8025d0e:	ed92 6a00 	vldr	s12, [r2]
 8025d12:	eea6 0a07 	vfma.f32	s0, s12, s14
 8025d16:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025d1a:	e7b5      	b.n	8025c88 <tADSR4_tickNoInterp+0xb0>
                adsr->next = adsr->rampPeak * adsr->exp_buff[(uint32_t)adsr->rampPhase];
 8025d1c:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 8025d20:	685a      	ldr	r2, [r3, #4]
 8025d22:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
 8025d26:	ee17 1a10 	vmov	r1, s14
 8025d2a:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8025d2e:	ed92 0a00 	vldr	s0, [r2]
 8025d32:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025d36:	e76a      	b.n	8025c0e <tADSR4_tickNoInterp+0x36>
                adsr->next = adsr->releasePeak * adsr->exp_buff[(uint32_t)adsr->releasePhase];
 8025d38:	eebc 7ae6 	vcvt.u32.f32	s14, s13
 8025d3c:	685a      	ldr	r2, [r3, #4]
 8025d3e:	edd3 7a0e 	vldr	s15, [r3, #56]	; 0x38
 8025d42:	ee17 1a10 	vmov	r1, s14
 8025d46:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8025d4a:	ed92 0a00 	vldr	s0, [r2]
 8025d4e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025d52:	e7b1      	b.n	8025cb8 <tADSR4_tickNoInterp+0xe0>

08025d54 <tRamp_init>:


/////-----------------
/* Ramp */
void    tRamp_init(tRamp* const r, float time, int samples_per_tick)
{
 8025d54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    tRamp_initToPool(r, time, samples_per_tick, &leaf.mempool);
}

void    tRamp_initToPool    (tRamp* const r, float time, int samples_per_tick, tMempool* const mp)
{
    _tMempool* m = *mp;
 8025d56:	f249 44a0 	movw	r4, #38048	; 0x94a0
{
 8025d5a:	460d      	mov	r5, r1
 8025d5c:	4607      	mov	r7, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025d5e:	2024      	movs	r0, #36	; 0x24
    _tMempool* m = *mp;
 8025d60:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8025d64:	69a6      	ldr	r6, [r4, #24]
{
 8025d66:	ed2d 8b02 	vpush	{d8}
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025d6a:	4631      	mov	r1, r6
{
 8025d6c:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025d70:	f002 f83c 	bl	8027dec <mpool_alloc>
    ramp->mempool = m;
    
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025d74:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025d78:	6038      	str	r0, [r7, #0]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025d7a:	ee07 5a90 	vmov	s15, r5
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025d7e:	f2c4 4279 	movt	r2, #17529	; 0x4479
    ramp->mempool = m;
 8025d82:	6006      	str	r6, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025d84:	ed94 6a00 	vldr	s12, [r4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025d88:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025d8c:	ee07 2a10 	vmov	s14, r2
    ramp->curr = 0.0f;
 8025d90:	2300      	movs	r3, #0
    }
    else
    {
        ramp->time = time;
    }
    ramp->samples_per_tick = samples_per_tick;
 8025d92:	6205      	str	r5, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025d94:	eec7 6a06 	vdiv.f32	s13, s14, s12
    ramp->curr = 0.0f;
 8025d98:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
 8025d9a:	6143      	str	r3, [r0, #20]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
 8025d9c:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025d9e:	ee67 7aa6 	vmul.f32	s15, s15, s13
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025da2:	edc0 6a02 	vstr	s13, [r0, #8]
 8025da6:	fe88 0a27 	vmaxnm.f32	s0, s16, s15
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8025daa:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8025dae:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025db2:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8025db6:	ed80 7a07 	vstr	s14, [r0, #28]
}
 8025dba:	ecbd 8b02 	vpop	{d8}
 8025dbe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08025dc0 <tRamp_initToPool>:
{
 8025dc0:	b570      	push	{r4, r5, r6, lr}
 8025dc2:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8025dc6:	6815      	ldr	r5, [r2, #0]
{
 8025dc8:	460c      	mov	r4, r1
 8025dca:	4606      	mov	r6, r0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025dcc:	2024      	movs	r0, #36	; 0x24
 8025dce:	4629      	mov	r1, r5
{
 8025dd0:	eeb0 8a40 	vmov.f32	s16, s0
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025dd4:	f002 f80a 	bl	8027dec <mpool_alloc>
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025dd8:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8025ddc:	f64f 72ff 	movw	r2, #65535	; 0xffff
    _tRamp* ramp = *r = (_tRamp*) mpool_alloc(sizeof(_tRamp), m);
 8025de0:	6030      	str	r0, [r6, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025de2:	f2c2 0101 	movt	r1, #8193	; 0x2001
    ramp->mempool = m;
 8025de6:	6005      	str	r5, [r0, #0]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025de8:	f2c4 4279 	movt	r2, #17529	; 0x4479
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025dec:	ee07 4a90 	vmov	s15, r4
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025df0:	ed91 6a00 	vldr	s12, [r1]
    ramp->curr = 0.0f;
 8025df4:	2300      	movs	r3, #0
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025df6:	ee07 2a10 	vmov	s14, r2
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025dfa:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    ramp->samples_per_tick = samples_per_tick;
 8025dfe:	6204      	str	r4, [r0, #32]
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025e00:	eec7 6a06 	vdiv.f32	s13, s14, s12
    ramp->curr = 0.0f;
 8025e04:	6103      	str	r3, [r0, #16]
    ramp->dest = 0.0f;
 8025e06:	6143      	str	r3, [r0, #20]
    ramp->inc = (ramp->dest - ramp->curr) * ramp->factor;
 8025e08:	6043      	str	r3, [r0, #4]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025e0a:	ee67 7aa6 	vmul.f32	s15, s15, s13
    ramp->inv_sr_ms = 1.0f/(leaf.sampleRate*0.001f);
 8025e0e:	edc0 6a02 	vstr	s13, [r0, #8]
 8025e12:	fe87 0a88 	vmaxnm.f32	s0, s15, s16
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8025e16:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8025e1a:	ed80 0a06 	vstr	s0, [r0, #24]
    ramp->minimum_time = ramp->inv_sr_ms * samples_per_tick;
 8025e1e:	edc0 7a03 	vstr	s15, [r0, #12]
    ramp->factor = (1.0f / ramp->time) * ramp->inv_sr_ms * (float)ramp->samples_per_tick;
 8025e22:	ed80 7a07 	vstr	s14, [r0, #28]
}
 8025e26:	ecbd 8b02 	vpop	{d8}
 8025e2a:	bd70      	pop	{r4, r5, r6, pc}

08025e2c <tRamp_free>:

void    tRamp_free (tRamp* const r)
{
    _tRamp* ramp = *r;
 8025e2c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)ramp, ramp->mempool);
 8025e2e:	6801      	ldr	r1, [r0, #0]
 8025e30:	f002 b886 	b.w	8027f40 <mpool_free>

08025e34 <tRamp_setDest>:

}

void     tRamp_setDest(tRamp* const ramp, float dest)
{
    _tRamp* r = *ramp;
 8025e34:	6803      	ldr	r3, [r0, #0]
    r->dest = dest;
    r->inc = (r->dest - r->curr) * r->factor;
 8025e36:	edd3 7a04 	vldr	s15, [r3, #16]
 8025e3a:	ed93 7a07 	vldr	s14, [r3, #28]
 8025e3e:	ee70 7a67 	vsub.f32	s15, s0, s15
    r->dest = dest;
 8025e42:	ed83 0a05 	vstr	s0, [r3, #20]
    r->inc = (r->dest - r->curr) * r->factor;
 8025e46:	ee67 7a87 	vmul.f32	s15, s15, s14
 8025e4a:	edc3 7a01 	vstr	s15, [r3, #4]
}
 8025e4e:	4770      	bx	lr

08025e50 <tRamp_setVal>:

void     tRamp_setVal(tRamp* const ramp, float val)
{
    _tRamp* r = *ramp;
 8025e50:	6803      	ldr	r3, [r0, #0]
    r->curr = val;
    r->inc = (r->dest - r->curr) * r->factor;
 8025e52:	edd3 7a05 	vldr	s15, [r3, #20]
 8025e56:	ed93 7a07 	vldr	s14, [r3, #28]
 8025e5a:	ee77 7ac0 	vsub.f32	s15, s15, s0
    r->curr = val;
 8025e5e:	ed83 0a04 	vstr	s0, [r3, #16]
    r->inc = (r->dest - r->curr) * r->factor;
 8025e62:	ee67 7a87 	vmul.f32	s15, s15, s14
 8025e66:	edc3 7a01 	vstr	s15, [r3, #4]
}
 8025e6a:	4770      	bx	lr

08025e6c <tRamp_tick>:

float   tRamp_tick(tRamp* const ramp)
{
    _tRamp* r = *ramp;
 8025e6c:	6803      	ldr	r3, [r0, #0]
    
    r->curr += r->inc;
 8025e6e:	edd3 7a01 	vldr	s15, [r3, #4]
 8025e72:	ed93 0a04 	vldr	s0, [r3, #16]
    
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 8025e76:	eef5 7a40 	vcmp.f32	s15, #0.0
 8025e7a:	ed93 7a05 	vldr	s14, [r3, #20]
    r->curr += r->inc;
 8025e7e:	ee37 0a80 	vadd.f32	s0, s15, s0
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 8025e82:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    r->curr += r->inc;
 8025e86:	ed83 0a04 	vstr	s0, [r3, #16]
    if (((r->curr >= r->dest) && (r->inc > 0.0f)) || ((r->curr <= r->dest) && (r->inc < 0.0f)))
 8025e8a:	dd04      	ble.n	8025e96 <tRamp_tick+0x2a>
 8025e8c:	eeb4 0ac7 	vcmpe.f32	s0, s14
 8025e90:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025e94:	da0a      	bge.n	8025eac <tRamp_tick+0x40>
 8025e96:	eef5 7a40 	vcmp.f32	s15, #0.0
 8025e9a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025e9e:	d504      	bpl.n	8025eaa <tRamp_tick+0x3e>
 8025ea0:	eeb4 0a47 	vcmp.f32	s0, s14
 8025ea4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8025ea8:	d900      	bls.n	8025eac <tRamp_tick+0x40>
		r->inc = 0.0f;
		r->curr=r->dest;
	}
    
    return r->curr;
}
 8025eaa:	4770      	bx	lr
		r->inc = 0.0f;
 8025eac:	2200      	movs	r2, #0
		r->curr=r->dest;
 8025eae:	eeb0 0a47 	vmov.f32	s0, s14
 8025eb2:	ed83 7a04 	vstr	s14, [r3, #16]
		r->inc = 0.0f;
 8025eb6:	605a      	str	r2, [r3, #4]
}
 8025eb8:	4770      	bx	lr
 8025eba:	bf00      	nop

08025ebc <tRamp_sample>:

float   tRamp_sample(tRamp* const ramp)
{
    _tRamp* r = *ramp;
    return r->curr;
 8025ebc:	6803      	ldr	r3, [r0, #0]
}
 8025ebe:	ed93 0a04 	vldr	s0, [r3, #16]
 8025ec2:	4770      	bx	lr

08025ec4 <tExpSmooth_init>:



/* Exponential Smoother */
void    tExpSmooth_init(tExpSmooth* const expsmooth, float val, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 8025ec4:	b538      	push	{r3, r4, r5, lr}
    tExpSmooth_initToPool(expsmooth, val, factor, &leaf.mempool);
}

void    tExpSmooth_initToPool   (tExpSmooth* const expsmooth, float val, float factor, tMempool* const mp)
{
    _tMempool* m = *mp;
 8025ec6:	f249 43a0 	movw	r3, #38048	; 0x94a0
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 8025eca:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8025ecc:	2014      	movs	r0, #20
    _tMempool* m = *mp;
 8025ece:	f2c2 0301 	movt	r3, #8193	; 0x2001
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 8025ed2:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8025ed6:	699c      	ldr	r4, [r3, #24]
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 8025ed8:	eef0 8a40 	vmov.f32	s17, s0
 8025edc:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8025ee0:	4621      	mov	r1, r4
 8025ee2:	f001 ff83 	bl	8027dec <mpool_alloc>
 8025ee6:	2300      	movs	r3, #0
 8025ee8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025eec:	6028      	str	r0, [r5, #0]
 8025eee:	ee07 3a10 	vmov	s14, r3
    smooth->mempool = m;
 8025ef2:	6004      	str	r4, [r0, #0]
    
    smooth->curr=val;
 8025ef4:	edc0 8a03 	vstr	s17, [r0, #12]
 8025ef8:	fec8 0a67 	vminnm.f32	s1, s16, s15
 8025efc:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->dest=val;
    if (factor<0) factor=0;
    if (factor>1) factor=1;
    smooth->factor=factor;
    smooth->oneminusfactor=1.0f-factor;
 8025f00:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->dest=val;
 8025f04:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
 8025f08:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
 8025f0c:	edc0 7a02 	vstr	s15, [r0, #8]
}
 8025f10:	ecbd 8b02 	vpop	{d8}
 8025f14:	bd38      	pop	{r3, r4, r5, pc}
 8025f16:	bf00      	nop

08025f18 <tExpSmooth_initToPool>:
{
 8025f18:	b538      	push	{r3, r4, r5, lr}
 8025f1a:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8025f1e:	680c      	ldr	r4, [r1, #0]
{
 8025f20:	4605      	mov	r5, r0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8025f22:	2014      	movs	r0, #20
{
 8025f24:	eef0 8a40 	vmov.f32	s17, s0
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8025f28:	4621      	mov	r1, r4
{
 8025f2a:	eeb0 8a60 	vmov.f32	s16, s1
    _tExpSmooth* smooth = *expsmooth = (_tExpSmooth*) mpool_alloc(sizeof(_tExpSmooth), m);
 8025f2e:	f001 ff5d 	bl	8027dec <mpool_alloc>
 8025f32:	2300      	movs	r3, #0
 8025f34:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8025f38:	6028      	str	r0, [r5, #0]
 8025f3a:	ee07 3a10 	vmov	s14, r3
    smooth->mempool = m;
 8025f3e:	6004      	str	r4, [r0, #0]
    smooth->curr=val;
 8025f40:	edc0 8a03 	vstr	s17, [r0, #12]
 8025f44:	fec8 0a67 	vminnm.f32	s1, s16, s15
 8025f48:	fec0 0a87 	vmaxnm.f32	s1, s1, s14
    smooth->oneminusfactor=1.0f-factor;
 8025f4c:	ee77 7ae0 	vsub.f32	s15, s15, s1
    smooth->dest=val;
 8025f50:	edc0 8a04 	vstr	s17, [r0, #16]
    smooth->factor=factor;
 8025f54:	edc0 0a01 	vstr	s1, [r0, #4]
    smooth->oneminusfactor=1.0f-factor;
 8025f58:	edc0 7a02 	vstr	s15, [r0, #8]
}
 8025f5c:	ecbd 8b02 	vpop	{d8}
 8025f60:	bd38      	pop	{r3, r4, r5, pc}
 8025f62:	bf00      	nop

08025f64 <tExpSmooth_free>:

void    tExpSmooth_free (tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
 8025f64:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)smooth, smooth->mempool);
 8025f66:	6801      	ldr	r1, [r0, #0]
 8025f68:	f001 bfea 	b.w	8027f40 <mpool_free>

08025f6c <tExpSmooth_setFactor>:
}

void     tExpSmooth_setFactor(tExpSmooth* const expsmooth, float factor)
{	// factor is usually a value between 0 and 0.1. Lower value is slower. 0.01 for example gives you a smoothing time of about 10ms
 8025f6c:	2300      	movs	r3, #0
 8025f6e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tExpSmooth* smooth = *expsmooth;
 8025f72:	6802      	ldr	r2, [r0, #0]
 8025f74:	ee07 3a10 	vmov	s14, r3
 8025f78:	fe80 0a67 	vminnm.f32	s0, s0, s15
 8025f7c:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
	if (factor<0)
		factor=0;
	else
		if (factor>1) factor=1;
	smooth->factor=factor;
	smooth->oneminusfactor=1.0f-factor;
 8025f80:	ee77 7ac0 	vsub.f32	s15, s15, s0
	smooth->factor=factor;
 8025f84:	ed82 0a01 	vstr	s0, [r2, #4]
	smooth->oneminusfactor=1.0f-factor;
 8025f88:	edc2 7a02 	vstr	s15, [r2, #8]
}
 8025f8c:	4770      	bx	lr
 8025f8e:	bf00      	nop

08025f90 <tExpSmooth_setDest>:

void     tExpSmooth_setDest(tExpSmooth* const expsmooth, float dest)
{
    _tExpSmooth* smooth = *expsmooth;
 8025f90:	6803      	ldr	r3, [r0, #0]
	smooth->dest=dest;
 8025f92:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8025f96:	4770      	bx	lr

08025f98 <tExpSmooth_setValAndDest>:
	smooth->curr=val;
}

void     tExpSmooth_setValAndDest(tExpSmooth* const expsmooth, float val)
{
    _tExpSmooth* smooth = *expsmooth;
 8025f98:	6803      	ldr	r3, [r0, #0]
	smooth->curr=val;
 8025f9a:	ed83 0a03 	vstr	s0, [r3, #12]
	smooth->dest=val;
 8025f9e:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8025fa2:	4770      	bx	lr

08025fa4 <tExpSmooth_tick>:

float   tExpSmooth_tick(tExpSmooth* const expsmooth)
{
    _tExpSmooth* smooth = *expsmooth;
 8025fa4:	6803      	ldr	r3, [r0, #0]
    smooth->curr = smooth->factor*smooth->dest+smooth->oneminusfactor*smooth->curr;
 8025fa6:	edd3 7a03 	vldr	s15, [r3, #12]
 8025faa:	ed93 0a02 	vldr	s0, [r3, #8]
 8025fae:	ed93 7a01 	vldr	s14, [r3, #4]
 8025fb2:	ee20 0a27 	vmul.f32	s0, s0, s15
 8025fb6:	edd3 7a04 	vldr	s15, [r3, #16]
 8025fba:	eea7 0a27 	vfma.f32	s0, s14, s15
 8025fbe:	ed83 0a03 	vstr	s0, [r3, #12]
    return smooth->curr;
}
 8025fc2:	4770      	bx	lr

08025fc4 <tSlide_initToPool>:
{
	tSlide_initToPool    (sl, upSlide, downSlide, &leaf.mempool);
}

void    tSlide_initToPool    (tSlide* const sl, float upSlide, float downSlide, tMempool* const mp)
{
 8025fc4:	b538      	push	{r3, r4, r5, lr}
 8025fc6:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 8025fca:	680c      	ldr	r4, [r1, #0]
{
 8025fcc:	4605      	mov	r5, r0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 8025fce:	201c      	movs	r0, #28
{
 8025fd0:	eeb0 8a60 	vmov.f32	s16, s1
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 8025fd4:	4621      	mov	r1, r4
{
 8025fd6:	eef0 8a40 	vmov.f32	s17, s0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 8025fda:	f001 ff07 	bl	8027dec <mpool_alloc>

    if (downSlide < 1.0f)
    {
    	downSlide = 1.0f;
    }
    s->invUpSlide = 1.0f / upSlide;
 8025fde:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    s->prevIn = 0.0f;
 8025fe2:	2300      	movs	r3, #0
    _tSlide* s = *sl = (_tSlide*) mpool_alloc(sizeof(_tSlide), m);
 8025fe4:	6028      	str	r0, [r5, #0]
    s->mempool = m;
 8025fe6:	6004      	str	r4, [r0, #0]
    s->invUpSlide = 1.0f / upSlide;
 8025fe8:	fec8 8aa7 	vmaxnm.f32	s17, s17, s15
    s->invDownSlide = 1.0f / downSlide;
 8025fec:	fec8 0a27 	vmaxnm.f32	s1, s16, s15
    s->invUpSlide = 1.0f / upSlide;
 8025ff0:	eec7 6aa8 	vdiv.f32	s13, s15, s17
    s->prevIn = 0.0f;
 8025ff4:	60c3      	str	r3, [r0, #12]
    s->currentOut = 0.0f;
 8025ff6:	6083      	str	r3, [r0, #8]
    s->prevOut = 0.0f;
 8025ff8:	6043      	str	r3, [r0, #4]
    s->dest = 0.0f;
 8025ffa:	6183      	str	r3, [r0, #24]
    s->invDownSlide = 1.0f / downSlide;
 8025ffc:	ee87 7aa0 	vdiv.f32	s14, s15, s1
    s->invUpSlide = 1.0f / upSlide;
 8026000:	edc0 6a04 	vstr	s13, [r0, #16]
    s->invDownSlide = 1.0f / downSlide;
 8026004:	ed80 7a05 	vstr	s14, [r0, #20]
}
 8026008:	ecbd 8b02 	vpop	{d8}
 802600c:	bd38      	pop	{r3, r4, r5, pc}
 802600e:	bf00      	nop

08026010 <tSlide_free>:

void    tSlide_free  (tSlide* const sl)
{
    _tSlide* s = *sl;
 8026010:	6800      	ldr	r0, [r0, #0]

    mpool_free((char*)s, s->mempool);
 8026012:	6801      	ldr	r1, [r0, #0]
 8026014:	f001 bf94 	b.w	8027f40 <mpool_free>

08026018 <tSlide_setDownSlide>:
}

void tSlide_setDownSlide(tSlide* const sl, float downSlide)
{
	_tSlide* s = *sl;
	s->invDownSlide = 1.0f / downSlide;
 8026018:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	_tSlide* s = *sl;
 802601c:	6803      	ldr	r3, [r0, #0]
	s->invDownSlide = 1.0f / downSlide;
 802601e:	ee87 0a80 	vdiv.f32	s0, s15, s0
 8026022:	ed83 0a05 	vstr	s0, [r3, #20]
}
 8026026:	4770      	bx	lr

08026028 <tSlide_setDest>:

void tSlide_setDest(tSlide* const sl, float dest)
{
	_tSlide* s = *sl;
 8026028:	6803      	ldr	r3, [r0, #0]
	s->dest = dest;
 802602a:	ed83 0a06 	vstr	s0, [r3, #24]
}
 802602e:	4770      	bx	lr

08026030 <tSlide_tickNoInput>:

float tSlide_tickNoInput(tSlide* const sl)
{
	_tSlide* s = *sl;
 8026030:	6803      	ldr	r3, [r0, #0]
	{
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
	}
#ifdef NO_DENORMAL_CHECK
#else
	if (s->currentOut < VSF) s->currentOut = 0.0f;
 8026032:	f24e 32ee 	movw	r2, #58350	; 0xe3ee
	if (in >= s->prevOut)
 8026036:	edd3 7a01 	vldr	s15, [r3, #4]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
 802603a:	f2c0 026c 	movt	r2, #108	; 0x6c
	float in = s->dest;
 802603e:	edd3 6a06 	vldr	s13, [r3, #24]
	if (in >= s->prevOut)
 8026042:	eef4 7ae6 	vcmpe.f32	s15, s13
 8026046:	ee36 7ae7 	vsub.f32	s14, s13, s15
 802604a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invUpSlide);
 802604e:	bf94      	ite	ls
 8026050:	ed93 6a04 	vldrls	s12, [r3, #16]
		s->currentOut = s->prevOut + ((in - s->prevOut) * s->invDownSlide);
 8026054:	ed93 6a05 	vldrhi	s12, [r3, #20]
 8026058:	eee6 7a07 	vfma.f32	s15, s12, s14
	if (s->currentOut < VSF) s->currentOut = 0.0f;
 802605c:	ee07 2a10 	vmov	s14, r2
 8026060:	eef4 7ac7 	vcmpe.f32	s15, s14
 8026064:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8026068:	d50a      	bpl.n	8026080 <tSlide_tickNoInput+0x50>
 802606a:	2200      	movs	r2, #0
#endif
	s->prevIn = in;
 802606c:	edc3 6a03 	vstr	s13, [r3, #12]
	if (s->currentOut < VSF) s->currentOut = 0.0f;
 8026070:	ee07 2a90 	vmov	s15, r2
 8026074:	609a      	str	r2, [r3, #8]
	s->prevOut = s->currentOut;
	return s->currentOut;
}
 8026076:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevOut = s->currentOut;
 802607a:	edc3 7a01 	vstr	s15, [r3, #4]
}
 802607e:	4770      	bx	lr
 8026080:	edc3 7a02 	vstr	s15, [r3, #8]
 8026084:	eeb0 0a67 	vmov.f32	s0, s15
	s->prevIn = in;
 8026088:	edc3 6a03 	vstr	s13, [r3, #12]
	s->prevOut = s->currentOut;
 802608c:	edc3 7a01 	vstr	s15, [r3, #4]
}
 8026090:	4770      	bx	lr
 8026092:	bf00      	nop

08026094 <tAllpass_initToPool>:
{
    tAllpass_initToPool(ft, initDelay, maxDelay, &leaf.mempool);
}

void    tAllpass_initToPool     (tAllpass* const ft, float initDelay, uint32_t maxDelay, tMempool* const mp)
{
 8026094:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8026098:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 802609c:	6814      	ldr	r4, [r2, #0]
{
 802609e:	4680      	mov	r8, r0
 80260a0:	460f      	mov	r7, r1
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80260a2:	2010      	movs	r0, #16
 80260a4:	4621      	mov	r1, r4
{
 80260a6:	4616      	mov	r6, r2
 80260a8:	eeb0 8a40 	vmov.f32	s16, s0
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80260ac:	f001 fe9e 	bl	8027dec <mpool_alloc>
 80260b0:	4603      	mov	r3, r0
    f->mempool = m;
    
    f->gain = 0.7f;
 80260b2:	f243 3033 	movw	r0, #13107	; 0x3333
    
    f->lastOut = 0.0f;
 80260b6:	2500      	movs	r5, #0
    
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80260b8:	4632      	mov	r2, r6
    f->gain = 0.7f;
 80260ba:	f6c3 7033 	movt	r0, #16179	; 0x3f33
    _tAllpass* f = *ft = (_tAllpass*) mpool_alloc(sizeof(_tAllpass), m);
 80260be:	f8c8 3000 	str.w	r3, [r8]
    f->mempool = m;
 80260c2:	601c      	str	r4, [r3, #0]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80260c4:	eeb0 0a48 	vmov.f32	s0, s16
    f->gain = 0.7f;
 80260c8:	4604      	mov	r4, r0
    f->lastOut = 0.0f;
 80260ca:	60dd      	str	r5, [r3, #12]
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80260cc:	4639      	mov	r1, r7
 80260ce:	f103 0008 	add.w	r0, r3, #8
    f->gain = 0.7f;
 80260d2:	605c      	str	r4, [r3, #4]
}
 80260d4:	ecbd 8b02 	vpop	{d8}
 80260d8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    tLinearDelay_initToPool(&f->delay, initDelay, maxDelay, mp);
 80260dc:	f7fc be14 	b.w	8022d08 <tLinearDelay_initToPool>

080260e0 <tAllpass_free>:

void    tAllpass_free  (tAllpass* const ft)
{
 80260e0:	b510      	push	{r4, lr}
    _tAllpass* f = *ft;
 80260e2:	6804      	ldr	r4, [r0, #0]
    
    tLinearDelay_free(&f->delay);
 80260e4:	f104 0008 	add.w	r0, r4, #8
 80260e8:	f7fc fe7e 	bl	8022de8 <tLinearDelay_free>
    mpool_free((char*)f, f->mempool);
 80260ec:	6821      	ldr	r1, [r4, #0]
 80260ee:	4620      	mov	r0, r4
}
 80260f0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)f, f->mempool);
 80260f4:	f001 bf24 	b.w	8027f40 <mpool_free>

080260f8 <tAllpass_setDelay>:

void    tAllpass_setDelay(tAllpass* const ft, float delay)
{
    _tAllpass* f = *ft;
    
    tLinearDelay_setDelay(&f->delay, delay);
 80260f8:	6800      	ldr	r0, [r0, #0]
 80260fa:	3008      	adds	r0, #8
 80260fc:	f7fc bf06 	b.w	8022f0c <tLinearDelay_setDelay>

08026100 <tAllpass_setGain>:
}

void    tAllpass_setGain(tAllpass* const ft, float gain)
{
    _tAllpass* f = *ft;
 8026100:	6803      	ldr	r3, [r0, #0]
    
    f->gain = gain;
 8026102:	ed83 0a01 	vstr	s0, [r3, #4]
}
 8026106:	4770      	bx	lr

08026108 <tAllpass_tick>:

float   tAllpass_tick(tAllpass* const ft, float input)
{
 8026108:	b510      	push	{r4, lr}
 802610a:	ed2d 8b02 	vpush	{d8}
    _tAllpass* f = *ft;
 802610e:	6804      	ldr	r4, [r0, #0]
{
 8026110:	eeb0 8a40 	vmov.f32	s16, s0
    
    float s1 = (-f->gain) * f->lastOut + input;
    
    float s2 = tLinearDelay_tick(&f->delay, s1) + (f->gain) * input;
 8026114:	edd4 7a03 	vldr	s15, [r4, #12]
 8026118:	f104 0008 	add.w	r0, r4, #8
 802611c:	ed94 7a01 	vldr	s14, [r4, #4]
 8026120:	eea7 0a67 	vfms.f32	s0, s14, s15
 8026124:	f7fc fe7a 	bl	8022e1c <tLinearDelay_tick>
 8026128:	edd4 7a01 	vldr	s15, [r4, #4]
 802612c:	eea7 0a88 	vfma.f32	s0, s15, s16
    
    f->lastOut = s2;
 8026130:	ed84 0a03 	vstr	s0, [r4, #12]
    
    return f->lastOut;
}
 8026134:	ecbd 8b02 	vpop	{d8}
 8026138:	bd10      	pop	{r4, pc}
 802613a:	bf00      	nop

0802613c <tOnePole_initToPool>:
{
    tOnePole_initToPool(ft, freq, &leaf.mempool);
}

void    tOnePole_initToPool     (tOnePole* const ft, float freq, tMempool* const mp)
{
 802613c:	b570      	push	{r4, r5, r6, lr}
 802613e:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 8026142:	680e      	ldr	r6, [r1, #0]
{
 8026144:	4605      	mov	r5, r0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 8026146:	2020      	movs	r0, #32
{
 8026148:	eeb0 9a40 	vmov.f32	s18, s0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 802614c:	4631      	mov	r1, r6
    f->mempool = m;
    
    f->gain = 1.0f;
 802614e:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 8026152:	f001 fe4b 	bl	8027dec <mpool_alloc>
}

void        tOnePole_setFreq        (tOnePole* const ft, float freq)
{
    _tOnePole* f = *ft;
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 8026156:	f249 42a0 	movw	r2, #38048	; 0x94a0
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 802615a:	6028      	str	r0, [r5, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 802615c:	2300      	movs	r3, #0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 802615e:	f2c2 0201 	movt	r2, #8193	; 0x2001
    f->gain = 1.0f;
 8026162:	ed80 8a01 	vstr	s16, [r0, #4]
    f->a0 = 1.0;
 8026166:	ed80 8a02 	vstr	s16, [r0, #8]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 802616a:	eeb0 1a48 	vmov.f32	s2, s16
    f->mempool = m;
 802616e:	6006      	str	r6, [r0, #0]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8026170:	ee00 3a10 	vmov	s0, r3
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 8026174:	edd2 0a03 	vldr	s1, [r2, #12]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8026178:	ee08 3a90 	vmov	s17, r3
    _tOnePole* f = *ft;
 802617c:	682d      	ldr	r5, [r5, #0]
    _tOnePole* f = *ft = (_tOnePole*) mpool_alloc(sizeof(_tOnePole), m);
 802617e:	4604      	mov	r4, r0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 8026180:	ee69 0a20 	vmul.f32	s1, s18, s1
 8026184:	edc5 0a04 	vstr	s1, [r5, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8026188:	f001 fc16 	bl	80279b8 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
 802618c:	ee38 8a40 	vsub.f32	s16, s16, s0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 8026190:	ed85 0a04 	vstr	s0, [r5, #16]
    f->a1 = 1.0f - f->b0;
 8026194:	ed85 8a03 	vstr	s16, [r5, #12]
    f->lastIn = 0.0f;
 8026198:	edc4 8a06 	vstr	s17, [r4, #24]
    f->lastOut = 0.0f;
 802619c:	edc4 8a07 	vstr	s17, [r4, #28]
}
 80261a0:	ecbd 8b04 	vpop	{d8-d9}
 80261a4:	bd70      	pop	{r4, r5, r6, pc}
 80261a6:	bf00      	nop

080261a8 <tOnePole_free>:
    _tOnePole* f = *ft;
 80261a8:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
 80261aa:	6801      	ldr	r1, [r0, #0]
 80261ac:	f001 bec8 	b.w	8027f40 <mpool_free>

080261b0 <tOnePole_setFreq>:
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80261b0:	f249 43a0 	movw	r3, #38048	; 0x94a0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80261b4:	2200      	movs	r2, #0
 80261b6:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80261ba:	f2c2 0301 	movt	r3, #8193	; 0x2001
{
 80261be:	b510      	push	{r4, lr}
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80261c0:	edd3 0a03 	vldr	s1, [r3, #12]
    _tOnePole* f = *ft;
 80261c4:	6804      	ldr	r4, [r0, #0]
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80261c6:	ee60 0a20 	vmul.f32	s1, s0, s1
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80261ca:	ee00 2a10 	vmov	s0, r2
    f->b0 = freq * leaf.twoPiTimesInvSampleRate;
 80261ce:	edc4 0a04 	vstr	s1, [r4, #16]
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80261d2:	f001 fbf1 	bl	80279b8 <LEAF_clip>
    f->a1 = 1.0f - f->b0;
 80261d6:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    f->b0 = LEAF_clip(0.0f, f->b0, 1.0f);
 80261da:	ed84 0a04 	vstr	s0, [r4, #16]
    f->a1 = 1.0f - f->b0;
 80261de:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80261e2:	ed84 0a03 	vstr	s0, [r4, #12]
}
 80261e6:	bd10      	pop	{r4, pc}

080261e8 <tOnePole_tick>:
    f->gain = gain;
}

float   tOnePole_tick(tOnePole* const ft, float input)
{
    _tOnePole* f = *ft;
 80261e8:	6803      	ldr	r3, [r0, #0]
    
    float in = input * f->gain;
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80261ea:	ed93 6a07 	vldr	s12, [r3, #28]
    float in = input * f->gain;
 80261ee:	ed93 7a01 	vldr	s14, [r3, #4]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80261f2:	edd3 7a03 	vldr	s15, [r3, #12]
    float in = input * f->gain;
 80261f6:	ee20 7a07 	vmul.f32	s14, s0, s14
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 80261fa:	edd3 6a04 	vldr	s13, [r3, #16]
 80261fe:	ee27 0a86 	vmul.f32	s0, s15, s12
    
    f->lastIn = in;
 8026202:	ed83 7a06 	vstr	s14, [r3, #24]
    float out = (f->b0 * in) + (f->a1 * f->lastOut);
 8026206:	eea6 0a87 	vfma.f32	s0, s13, s14
    f->lastOut = out;
 802620a:	ed83 0a07 	vstr	s0, [r3, #28]
    
    return out;
}
 802620e:	4770      	bx	lr

08026210 <tSVF_init>:
}

// Less efficient, more accurate version of SVF, in which cutoff frequency is taken as floating point Hz value and tanf
// is calculated when frequency changes.
void tSVF_init(tSVF* const svff, SVFType type, float freq, float Q)
{
 8026210:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

}

void    tSVF_initToPool     (tSVF* const svff, SVFType type, float freq, float Q, tMempool* const mp)
{
    _tMempool* m = *mp;
 8026214:	f249 46a0 	movw	r6, #38048	; 0x94a0
{
 8026218:	460f      	mov	r7, r1
 802621a:	4681      	mov	r9, r0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802621c:	203c      	movs	r0, #60	; 0x3c
    _tMempool* m = *mp;
 802621e:	f2c2 0601 	movt	r6, #8193	; 0x2001
    svf->mempool = m;

    svf->type = type;

    svf->ic1eq = 0;
 8026222:	2500      	movs	r5, #0
    _tMempool* m = *mp;
 8026224:	f8d6 8018 	ldr.w	r8, [r6, #24]
{
 8026228:	ed2d 8b02 	vpush	{d8}
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802622c:	4641      	mov	r1, r8
{
 802622e:	eeb0 8a60 	vmov.f32	s16, s1
 8026232:	eef0 8a40 	vmov.f32	s17, s0
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 8026236:	f001 fdd9 	bl	8027dec <mpool_alloc>
    svf->ic2eq = 0;
    svf->Q = Q;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802623a:	f640 73db 	movw	r3, #4059	; 0xfdb
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 802623e:	f8c9 0000 	str.w	r0, [r9]
    svf->mempool = m;
 8026242:	f8c0 8000 	str.w	r8, [r0]
    _tSVF* svf = *svff = (_tSVF*) mpool_alloc(sizeof(_tSVF), m);
 8026246:	4604      	mov	r4, r0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8026248:	f2c4 0349 	movt	r3, #16457	; 0x4049
    svf->type = type;
 802624c:	7107      	strb	r7, [r0, #4]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802624e:	ed96 7a01 	vldr	s14, [r6, #4]
 8026252:	ee07 3a90 	vmov	s15, r3
    svf->Q = Q;
 8026256:	ed80 8a03 	vstr	s16, [r0, #12]
    svf->cutoff = freq;
 802625a:	edc0 8a02 	vstr	s17, [r0, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 802625e:	ee67 7a27 	vmul.f32	s15, s14, s15
    svf->ic1eq = 0;
 8026262:	6105      	str	r5, [r0, #16]
    svf->ic2eq = 0;
 8026264:	6145      	str	r5, [r0, #20]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8026266:	ee27 0aa8 	vmul.f32	s0, s15, s17
 802626a:	f005 f953 	bl	802b514 <tanf>
    svf->k = 1.0f/Q;
 802626e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8026272:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a3 = svf->g*svf->a2;
    svf->cH = 0.0f;
    svf->cB = 0.0f;
    svf->cL = 1.0f;

    if (type == SVFTypeLowpass)
 8026276:	2f01      	cmp	r7, #1
    svf->cH = 0.0f;
 8026278:	62e5      	str	r5, [r4, #44]	; 0x2c
    svf->k = 1.0f/Q;
 802627a:	ee87 7a88 	vdiv.f32	s14, s15, s16
    svf->cB = 0.0f;
 802627e:	6325      	str	r5, [r4, #48]	; 0x30
    svf->cL = 1.0f;
 8026280:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026284:	ee70 6a07 	vadd.f32	s13, s0, s14
    svf->k = 1.0f/Q;
 8026288:	ed84 7a07 	vstr	s14, [r4, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802628c:	eeb0 7a67 	vmov.f32	s14, s15
 8026290:	eea0 7a26 	vfma.f32	s14, s0, s13
 8026294:	eec7 6a87 	vdiv.f32	s13, s15, s14
    svf->a2 = svf->g*svf->a1;
 8026298:	ee20 7a26 	vmul.f32	s14, s0, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802629c:	edc4 6a08 	vstr	s13, [r4, #32]
    svf->a3 = svf->g*svf->a2;
 80262a0:	ee20 0a07 	vmul.f32	s0, s0, s14
    svf->a2 = svf->g*svf->a1;
 80262a4:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
 80262a8:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
    if (type == SVFTypeLowpass)
 80262ac:	d018      	beq.n	80262e0 <tSVF_init+0xd0>
        svf->cH = 0.0f;
        svf->cB = 0.0f;
        svf->cBK = 0.0f;
        svf->cL = 1.0f;
    }
    else if (type == SVFTypeBandpass)
 80262ae:	2f02      	cmp	r7, #2
 80262b0:	d00e      	beq.n	80262d0 <tSVF_init+0xc0>
        svf->cB = 1.0f;
        svf->cBK = 0.0f;
        svf->cL = 0.0f;
    }

    else if (type == SVFTypeHighpass)
 80262b2:	b1d7      	cbz	r7, 80262ea <tSVF_init+0xda>
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
        svf->cL = -1.0f;
    }

    else if (type == SVFTypeNotch)
 80262b4:	2f03      	cmp	r7, #3
 80262b6:	d023      	beq.n	8026300 <tSVF_init+0xf0>
        svf->cBK = -1.0f;
        svf->cL = 0.0f;
    }


    else if (type == SVFTypePeak)
 80262b8:	2f04      	cmp	r7, #4
 80262ba:	d10d      	bne.n	80262d8 <tSVF_init+0xc8>
    {
        svf->cH = 1.0f;
        svf->cB = 0.0f;
        svf->cBK = -1.0f;
 80262bc:	2200      	movs	r2, #0
        svf->cL = -2.0f;
 80262be:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
        svf->cH = 1.0f;
 80262c2:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
 80262c6:	f6cb 7280 	movt	r2, #49024	; 0xbf80
        svf->cL = -2.0f;
 80262ca:	6363      	str	r3, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
 80262cc:	63a2      	str	r2, [r4, #56]	; 0x38
}
 80262ce:	e003      	b.n	80262d8 <tSVF_init+0xc8>
        svf->cB = 1.0f;
 80262d0:	edc4 7a0c 	vstr	s15, [r4, #48]	; 0x30
        svf->cBK = 0.0f;
 80262d4:	63a5      	str	r5, [r4, #56]	; 0x38
        svf->cL = 0.0f;
 80262d6:	6365      	str	r5, [r4, #52]	; 0x34
}
 80262d8:	ecbd 8b02 	vpop	{d8}
 80262dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = 0.0f;
 80262e0:	63a5      	str	r5, [r4, #56]	; 0x38
}
 80262e2:	ecbd 8b02 	vpop	{d8}
 80262e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
 80262ea:	2300      	movs	r3, #0
        svf->cH = 1.0f;
 80262ec:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cBK = -1.0f;
 80262f0:	f6cb 7380 	movt	r3, #49024	; 0xbf80
 80262f4:	63a3      	str	r3, [r4, #56]	; 0x38
        svf->cL = -1.0f;
 80262f6:	6363      	str	r3, [r4, #52]	; 0x34
}
 80262f8:	ecbd 8b02 	vpop	{d8}
 80262fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        svf->cBK = -1.0f;
 8026300:	2300      	movs	r3, #0
        svf->cH = 1.0f;
 8026302:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
        svf->cL = 0.0f;
 8026306:	6365      	str	r5, [r4, #52]	; 0x34
        svf->cBK = -1.0f;
 8026308:	f6cb 7380 	movt	r3, #49024	; 0xbf80
 802630c:	63a3      	str	r3, [r4, #56]	; 0x38
 802630e:	e7e3      	b.n	80262d8 <tSVF_init+0xc8>

08026310 <tSVF_free>:
    }
}

void    tSVF_free   (tSVF* const svff)
{
    _tSVF* svf = *svff;
 8026310:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
 8026312:	6801      	ldr	r1, [r0, #0]
 8026314:	f001 be14 	b.w	8027f40 <mpool_free>

08026318 <tSVF_tick>:
}

float   tSVF_tick(tSVF* const svff, float v0)
{
    _tSVF* svf = *svff;
 8026318:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 802631a:	eef0 4a00 	vmov.f32	s9, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
 802631e:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8026322:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8026326:	eef0 5a66 	vmov.f32	s11, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802632a:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
 802632e:	ee30 4a66 	vsub.f32	s8, s0, s13
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8026332:	edd3 2a0a 	vldr	s5, [r3, #40]	; 0x28
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 8026336:	edd3 3a0e 	vldr	s7, [r3, #56]	; 0x38
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 802633a:	eee6 5a27 	vfma.f32	s11, s12, s15
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802633e:	ed93 3a08 	vldr	s6, [r3, #32]
 8026342:	ee67 7a84 	vmul.f32	s15, s15, s8
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 8026346:	ed93 2a07 	vldr	s4, [r3, #28]
 802634a:	ed93 5a0c 	vldr	s10, [r3, #48]	; 0x30
 802634e:	ed93 7a0d 	vldr	s14, [r3, #52]	; 0x34
 8026352:	eea2 5a23 	vfma.f32	s10, s4, s7
 8026356:	edd3 3a0b 	vldr	s7, [r3, #44]	; 0x2c
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802635a:	eee3 7a06 	vfma.f32	s15, s6, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 802635e:	eee2 5a84 	vfma.f32	s11, s5, s8
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8026362:	ee97 6aa4 	vfnms.f32	s12, s15, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 8026366:	ee25 7a87 	vmul.f32	s14, s11, s14
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 802636a:	eed5 6aa4 	vfnms.f32	s13, s11, s9
    return (v0 * svf->cH) + (v1 * svf->cB) + (svf->k * v1 * svf->cBK) + (v2 * svf->cL);
 802636e:	eea7 7a85 	vfma.f32	s14, s15, s10
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8026372:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 8026376:	edc3 6a05 	vstr	s13, [r3, #20]
}
 802637a:	eea3 7a80 	vfma.f32	s14, s7, s0
 802637e:	eeb0 0a47 	vmov.f32	s0, s14
 8026382:	4770      	bx	lr

08026384 <tSVF_setFreq>:

void     tSVF_setFreq(tSVF* const svff, float freq)
{
    _tSVF* svf = *svff;
    svf->cutoff = freq;
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8026384:	f249 42a0 	movw	r2, #38048	; 0x94a0
 8026388:	f640 73db 	movw	r3, #4059	; 0xfdb
 802638c:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8026390:	f2c4 0349 	movt	r3, #16457	; 0x4049
{
 8026394:	b510      	push	{r4, lr}
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 8026396:	ee07 3a90 	vmov	s15, r3
 802639a:	ed92 7a01 	vldr	s14, [r2, #4]
    _tSVF* svf = *svff;
 802639e:	6804      	ldr	r4, [r0, #0]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 80263a0:	ee67 7a27 	vmul.f32	s15, s14, s15
    svf->cutoff = freq;
 80263a4:	ed84 0a02 	vstr	s0, [r4, #8]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 80263a8:	ee27 0a80 	vmul.f32	s0, s15, s0
 80263ac:	f005 f8b2 	bl	802b514 <tanf>
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 80263b0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 80263b4:	edd4 7a07 	vldr	s15, [r4, #28]
    svf->g = tanf(PI * freq * leaf.invSampleRate);
 80263b8:	ed84 0a06 	vstr	s0, [r4, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 80263bc:	ee70 7a27 	vadd.f32	s15, s0, s15
 80263c0:	eeb0 7a66 	vmov.f32	s14, s13
 80263c4:	eea0 7a27 	vfma.f32	s14, s0, s15
 80263c8:	eef0 7a47 	vmov.f32	s15, s14
 80263cc:	ee86 7aa7 	vdiv.f32	s14, s13, s15
    svf->a2 = svf->g * svf->a1;
 80263d0:	ee60 7a07 	vmul.f32	s15, s0, s14
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 80263d4:	ed84 7a08 	vstr	s14, [r4, #32]
    svf->a3 = svf->g * svf->a2;
 80263d8:	ee20 0a27 	vmul.f32	s0, s0, s15
    svf->a2 = svf->g * svf->a1;
 80263dc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 80263e0:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
}
 80263e4:	bd10      	pop	{r4, pc}
 80263e6:	bf00      	nop

080263e8 <tEfficientSVF_initToPool>:
{
    tEfficientSVF_initToPool(svff, type, input, Q, &leaf.mempool);
}

void    tEfficientSVF_initToPool    (tEfficientSVF* const svff, SVFType type, uint16_t input, float Q, tMempool* const mp)
{
 80263e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80263ea:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80263ee:	681c      	ldr	r4, [r3, #0]
{
 80263f0:	4607      	mov	r7, r0
 80263f2:	460d      	mov	r5, r1
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 80263f4:	202c      	movs	r0, #44	; 0x2c
 80263f6:	4621      	mov	r1, r4
{
 80263f8:	eeb0 8a40 	vmov.f32	s16, s0
 80263fc:	4616      	mov	r6, r2
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 80263fe:	f001 fcf5 	bl	8027dec <mpool_alloc>
    
    svf->ic1eq = 0;
    svf->ic2eq = 0;
    
    svf->g = __leaf_table_filtertan[input];
    svf->k = 1.0f/Q;
 8026402:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
 8026406:	f240 237c 	movw	r3, #636	; 0x27c
    _tEfficientSVF* svf = *svff = (_tEfficientSVF*) mpool_alloc(sizeof(_tEfficientSVF), m);
 802640a:	6038      	str	r0, [r7, #0]
    svf->ic1eq = 0;
 802640c:	2100      	movs	r1, #0
    svf->g = __leaf_table_filtertan[input];
 802640e:	f6c0 0303 	movt	r3, #2051	; 0x803
    svf->mempool = m;
 8026412:	6004      	str	r4, [r0, #0]
    svf->k = 1.0f/Q;
 8026414:	eec7 6a08 	vdiv.f32	s13, s14, s16
    svf->type = type;
 8026418:	7105      	strb	r5, [r0, #4]
    svf->g = __leaf_table_filtertan[input];
 802641a:	eb03 0386 	add.w	r3, r3, r6, lsl #2
    svf->ic1eq = 0;
 802641e:	6101      	str	r1, [r0, #16]
    svf->ic2eq = 0;
 8026420:	6141      	str	r1, [r0, #20]
    svf->g = __leaf_table_filtertan[input];
 8026422:	edd3 7a00 	vldr	s15, [r3]
 8026426:	edc0 7a06 	vstr	s15, [r0, #24]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 802642a:	ee37 6aa6 	vadd.f32	s12, s15, s13
    svf->k = 1.0f/Q;
 802642e:	edc0 6a07 	vstr	s13, [r0, #28]
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 8026432:	eef0 6a47 	vmov.f32	s13, s14
 8026436:	eee7 6a86 	vfma.f32	s13, s15, s12
 802643a:	eeb0 6a66 	vmov.f32	s12, s13
 802643e:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g*svf->a1;
 8026442:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f+svf->g*(svf->g+svf->k));
 8026446:	edc0 6a08 	vstr	s13, [r0, #32]
    svf->a3 = svf->g*svf->a2;
 802644a:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g*svf->a1;
 802644e:	ed80 7a09 	vstr	s14, [r0, #36]	; 0x24
    svf->a3 = svf->g*svf->a2;
 8026452:	edc0 7a0a 	vstr	s15, [r0, #40]	; 0x28
}
 8026456:	ecbd 8b02 	vpop	{d8}
 802645a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802645c <tEfficientSVF_free>:

void    tEfficientSVF_free (tEfficientSVF* const svff)
{
    _tEfficientSVF* svf = *svff;
 802645c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)svf, svf->mempool);
 802645e:	6801      	ldr	r1, [r0, #0]
 8026460:	f001 bd6e 	b.w	8027f40 <mpool_free>

08026464 <tEfficientSVF_tick>:
}

float   tEfficientSVF_tick(tEfficientSVF* const svff, float v0)
{
    _tEfficientSVF* svf = *svff;
 8026464:	6803      	ldr	r3, [r0, #0]
    
    float v1,v2,v3;
    v3 = v0 - svf->ic2eq;
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 8026466:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
    v3 = v0 - svf->ic2eq;
 802646a:	edd3 6a05 	vldr	s13, [r3, #20]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802646e:	ed93 6a04 	vldr	s12, [r3, #16]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8026472:	eeb0 7a66 	vmov.f32	s14, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8026476:	edd3 7a09 	vldr	s15, [r3, #36]	; 0x24
    v3 = v0 - svf->ic2eq;
 802647a:	ee70 5a66 	vsub.f32	s11, s0, s13
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802647e:	ed93 4a08 	vldr	s8, [r3, #32]
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8026482:	edd3 4a0a 	vldr	s9, [r3, #40]	; 0x28
 8026486:	eea6 7a27 	vfma.f32	s14, s12, s15
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
    
    if (svf->type == SVFTypeLowpass)        return v2;
 802648a:	791a      	ldrb	r2, [r3, #4]
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 802648c:	ee67 7aa5 	vmul.f32	s15, s15, s11
    if (svf->type == SVFTypeLowpass)        return v2;
 8026490:	2a01      	cmp	r2, #1
    v1 = (svf->a1 * svf->ic1eq) + (svf->a2 * v3);
 8026492:	eee4 7a06 	vfma.f32	s15, s8, s12
    v2 = svf->ic2eq + (svf->a2 * svf->ic1eq) + (svf->a3 * v3);
 8026496:	eea4 7aa5 	vfma.f32	s14, s9, s11
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 802649a:	ee97 6a85 	vfnms.f32	s12, s15, s10
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 802649e:	ee77 5a07 	vadd.f32	s11, s14, s14
 80264a2:	ee75 6ae6 	vsub.f32	s13, s11, s13
    svf->ic1eq = (2.0f * v1) - svf->ic1eq;
 80264a6:	ed83 6a04 	vstr	s12, [r3, #16]
    svf->ic2eq = (2.0f * v2) - svf->ic2eq;
 80264aa:	edc3 6a05 	vstr	s13, [r3, #20]
    if (svf->type == SVFTypeLowpass)        return v2;
 80264ae:	d009      	beq.n	80264c4 <tEfficientSVF_tick+0x60>
    else if (svf->type == SVFTypeBandpass)  return v1;
 80264b0:	2a02      	cmp	r2, #2
 80264b2:	d00a      	beq.n	80264ca <tEfficientSVF_tick+0x66>
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
 80264b4:	b172      	cbz	r2, 80264d4 <tEfficientSVF_tick+0x70>
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
 80264b6:	2a03      	cmp	r2, #3
 80264b8:	d015      	beq.n	80264e6 <tEfficientSVF_tick+0x82>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
 80264ba:	2a04      	cmp	r2, #4
 80264bc:	d01a      	beq.n	80264f4 <tEfficientSVF_tick+0x90>
    else                                    return 0.0f;
 80264be:	2300      	movs	r3, #0
 80264c0:	ee07 3a10 	vmov	s14, r3
    
}
 80264c4:	eeb0 0a47 	vmov.f32	s0, s14
 80264c8:	4770      	bx	lr
    else if (svf->type == SVFTypeBandpass)  return v1;
 80264ca:	eeb0 7a67 	vmov.f32	s14, s15
}
 80264ce:	eeb0 0a47 	vmov.f32	s0, s14
 80264d2:	4770      	bx	lr
    else if (svf->type == SVFTypeHighpass)  return v0 - (svf->k * v1) - v2;
 80264d4:	edd3 6a07 	vldr	s13, [r3, #28]
 80264d8:	eea6 0ae7 	vfms.f32	s0, s13, s15
 80264dc:	ee30 7a47 	vsub.f32	s14, s0, s14
}
 80264e0:	eeb0 0a47 	vmov.f32	s0, s14
 80264e4:	4770      	bx	lr
    else if (svf->type == SVFTypeNotch)     return v0 - (svf->k * v1);
 80264e6:	ed93 7a07 	vldr	s14, [r3, #28]
 80264ea:	eea7 0a67 	vfms.f32	s0, s14, s15
 80264ee:	eeb0 7a40 	vmov.f32	s14, s0
 80264f2:	e7e7      	b.n	80264c4 <tEfficientSVF_tick+0x60>
    else if (svf->type == SVFTypePeak)      return v0 - (svf->k * v1) - (2.0f * v2);
 80264f4:	ed93 7a07 	vldr	s14, [r3, #28]
 80264f8:	eea7 0a67 	vfms.f32	s0, s14, s15
 80264fc:	ee30 7a65 	vsub.f32	s14, s0, s11
 8026500:	e7e0      	b.n	80264c4 <tEfficientSVF_tick+0x60>
 8026502:	bf00      	nop

08026504 <tEfficientSVF_setFreq>:

void     tEfficientSVF_setFreq(tEfficientSVF* const svff, uint16_t input)
{
    _tEfficientSVF* svf = *svff;
    
    svf->g = __leaf_table_filtertan[input];
 8026504:	f240 227c 	movw	r2, #636	; 0x27c
    _tEfficientSVF* svf = *svff;
 8026508:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802650a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
    svf->g = __leaf_table_filtertan[input];
 802650e:	f6c0 0203 	movt	r2, #2051	; 0x803
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026512:	ed93 7a07 	vldr	s14, [r3, #28]
    svf->g = __leaf_table_filtertan[input];
 8026516:	eb02 0181 	add.w	r1, r2, r1, lsl #2
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802651a:	eef0 6a46 	vmov.f32	s13, s12
    svf->g = __leaf_table_filtertan[input];
 802651e:	edd1 7a00 	vldr	s15, [r1]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026522:	ee37 7a87 	vadd.f32	s14, s15, s14
    svf->g = __leaf_table_filtertan[input];
 8026526:	edc3 7a06 	vstr	s15, [r3, #24]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802652a:	eee7 6a87 	vfma.f32	s13, s15, s14
 802652e:	eeb0 7a66 	vmov.f32	s14, s13
 8026532:	eec6 6a07 	vdiv.f32	s13, s12, s14
    svf->a2 = svf->g * svf->a1;
 8026536:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802653a:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
 802653e:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
 8026542:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 8026546:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
 802654a:	4770      	bx	lr

0802654c <tEfficientSVF_setQ>:

void     tEfficientSVF_setQ(tEfficientSVF* const svff, float Q)
{
    _tEfficientSVF* svf = *svff;
    
    svf->k = 1.0f/Q;
 802654c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    _tEfficientSVF* svf = *svff;
 8026550:	6803      	ldr	r3, [r0, #0]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026552:	edd3 7a06 	vldr	s15, [r3, #24]
    svf->k = 1.0f/Q;
 8026556:	ee87 0a00 	vdiv.f32	s0, s14, s0
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 802655a:	eeb0 6a47 	vmov.f32	s12, s14
 802655e:	ee70 6a27 	vadd.f32	s13, s0, s15
    svf->k = 1.0f/Q;
 8026562:	ed83 0a07 	vstr	s0, [r3, #28]
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026566:	eea7 6aa6 	vfma.f32	s12, s15, s13
 802656a:	eec7 6a06 	vdiv.f32	s13, s14, s12
    svf->a2 = svf->g * svf->a1;
 802656e:	ee27 7aa6 	vmul.f32	s14, s15, s13
    svf->a1 = 1.0f/(1.0f + svf->g * (svf->g + svf->k));
 8026572:	edc3 6a08 	vstr	s13, [r3, #32]
    svf->a3 = svf->g * svf->a2;
 8026576:	ee67 7a87 	vmul.f32	s15, s15, s14
    svf->a2 = svf->g * svf->a1;
 802657a:	ed83 7a09 	vstr	s14, [r3, #36]	; 0x24
    svf->a3 = svf->g * svf->a2;
 802657e:	edc3 7a0a 	vstr	s15, [r3, #40]	; 0x28
}
 8026582:	4770      	bx	lr

08026584 <tHighpass_init>:

/* Highpass */
void    tHighpass_init(tHighpass* const ft, float freq)
{
 8026584:	b570      	push	{r4, r5, r6, lr}
    tHighpass_initToPool(ft, freq, &leaf.mempool);
}

void    tHighpass_initToPool    (tHighpass* const ft, float freq, tMempool* const mp)
{
    _tMempool* m = *mp;
 8026586:	f249 44a0 	movw	r4, #38048	; 0x94a0
{
 802658a:	4606      	mov	r6, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 802658c:	2014      	movs	r0, #20
    _tMempool* m = *mp;
 802658e:	f2c2 0401 	movt	r4, #8193	; 0x2001
 8026592:	69a5      	ldr	r5, [r4, #24]
{
 8026594:	ed2d 8b02 	vpush	{d8}
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 8026598:	4629      	mov	r1, r5
{
 802659a:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 802659e:	f001 fc7b 	bl	8027e98 <mpool_calloc>
    f->mempool = m;
    
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265a2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 80265a6:	6030      	str	r0, [r6, #0]
    f->ys = 0.0f;
 80265a8:	2300      	movs	r3, #0
    f->mempool = m;
 80265aa:	6005      	str	r5, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265ac:	ed94 7a03 	vldr	s14, [r4, #12]
    f->xs = 0.0f;
    
    f->frequency = freq;
 80265b0:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265b4:	eee8 7a47 	vfms.f32	s15, s16, s14
    f->ys = 0.0f;
 80265b8:	6083      	str	r3, [r0, #8]
    f->xs = 0.0f;
 80265ba:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265bc:	edc0 7a03 	vstr	s15, [r0, #12]
}
 80265c0:	ecbd 8b02 	vpop	{d8}
 80265c4:	bd70      	pop	{r4, r5, r6, pc}
 80265c6:	bf00      	nop

080265c8 <tHighpass_initToPool>:
{
 80265c8:	b538      	push	{r3, r4, r5, lr}
 80265ca:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 80265ce:	680c      	ldr	r4, [r1, #0]
{
 80265d0:	4605      	mov	r5, r0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 80265d2:	2014      	movs	r0, #20
{
 80265d4:	eeb0 8a40 	vmov.f32	s16, s0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 80265d8:	4621      	mov	r1, r4
 80265da:	f001 fc5d 	bl	8027e98 <mpool_calloc>
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265de:	f249 42a0 	movw	r2, #38048	; 0x94a0
 80265e2:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft = (_tHighpass*) mpool_calloc(sizeof(_tHighpass), m);
 80265e6:	6028      	str	r0, [r5, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265e8:	f2c2 0201 	movt	r2, #8193	; 0x2001
    f->mempool = m;
 80265ec:	6004      	str	r4, [r0, #0]
    f->ys = 0.0f;
 80265ee:	2300      	movs	r3, #0
    f->frequency = freq;
 80265f0:	ed80 8a04 	vstr	s16, [r0, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265f4:	ed92 7a03 	vldr	s14, [r2, #12]
    f->ys = 0.0f;
 80265f8:	6083      	str	r3, [r0, #8]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 80265fa:	eee7 7a48 	vfms.f32	s15, s14, s16
    f->xs = 0.0f;
 80265fe:	6043      	str	r3, [r0, #4]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8026600:	edc0 7a03 	vstr	s15, [r0, #12]
}
 8026604:	ecbd 8b02 	vpop	{d8}
 8026608:	bd38      	pop	{r3, r4, r5, pc}
 802660a:	bf00      	nop

0802660c <tHighpass_free>:

void    tHighpass_free  (tHighpass* const ft)
{
    _tHighpass* f = *ft;
 802660c:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)f, f->mempool);
 802660e:	6801      	ldr	r1, [r0, #0]
 8026610:	f001 bc96 	b.w	8027f40 <mpool_free>

08026614 <tHighpass_setFreq>:

void     tHighpass_setFreq(tHighpass* const ft, float freq)
{
    _tHighpass* f = *ft;
    f->frequency = freq;
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8026614:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8026618:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tHighpass* f = *ft;
 802661c:	6802      	ldr	r2, [r0, #0]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 802661e:	f2c2 0301 	movt	r3, #8193	; 0x2001
    f->frequency = freq;
 8026622:	ed82 0a04 	vstr	s0, [r2, #16]
    f->R = (1.0f - (freq * leaf.twoPiTimesInvSampleRate));
 8026626:	ed93 7a03 	vldr	s14, [r3, #12]
 802662a:	eee7 7a40 	vfms.f32	s15, s14, s0
 802662e:	edc2 7a03 	vstr	s15, [r2, #12]
    
}
 8026632:	4770      	bx	lr

08026634 <tHighpass_tick>:
}

// From JOS DC Blocker
float   tHighpass_tick(tHighpass* const ft, float x)
{
    _tHighpass* f = *ft;
 8026634:	6803      	ldr	r3, [r0, #0]
    f->ys = x - f->xs + f->R * f->ys;
 8026636:	edd3 7a01 	vldr	s15, [r3, #4]
 802663a:	ed93 7a02 	vldr	s14, [r3, #8]
 802663e:	edd3 6a03 	vldr	s13, [r3, #12]
    f->xs = x;
 8026642:	ed83 0a01 	vstr	s0, [r3, #4]
    f->ys = x - f->xs + f->R * f->ys;
 8026646:	eed6 7a87 	vfnms.f32	s15, s13, s14
 802664a:	ee37 0a80 	vadd.f32	s0, s15, s0
 802664e:	ed83 0a02 	vstr	s0, [r3, #8]
    return f->ys;
}
 8026652:	4770      	bx	lr

08026654 <tVZFilter_initToPool>:
{
	tVZFilter_initToPool(vf, type, freq, bandWidth, &leaf.mempool);
}

void    tVZFilter_initToPool     (tVZFilter* const vf, VZFilterType type, float freq, float bandWidth, tMempool* const mp)
{
 8026654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8026656:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 802665a:	6816      	ldr	r6, [r2, #0]
{
 802665c:	4605      	mov	r5, r0
 802665e:	460f      	mov	r7, r1
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 8026660:	2044      	movs	r0, #68	; 0x44
 8026662:	4631      	mov	r1, r6
{
 8026664:	eef0 8a40 	vmov.f32	s17, s0
 8026668:	eeb0 8a60 	vmov.f32	s16, s1
	f->invG    = 1.0f/ONE_OVER_SQRT2;
	f->B    = bandWidth;
	f->m    = 0.0f;
	f->s1 = 0.0f;
	f->s2 = 0.0f;
	f->sr = leaf.sampleRate;
 802666c:	f249 44a0 	movw	r4, #38048	; 0x94a0
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 8026670:	f001 fbbc 	bl	8027dec <mpool_alloc>
	f->G    = ONE_OVER_SQRT2;
 8026674:	f240 41f3 	movw	r1, #1267	; 0x4f3
	f->sr = leaf.sampleRate;
 8026678:	f2c2 0401 	movt	r4, #8193	; 0x2001
    _tVZFilter* f = *vf = (_tVZFilter*) mpool_alloc(sizeof(_tVZFilter), m);
 802667c:	6028      	str	r0, [r5, #0]
	f->invG    = 1.0f/ONE_OVER_SQRT2;
 802667e:	460a      	mov	r2, r1
    f->mempool = m;
 8026680:	6006      	str	r6, [r0, #0]
	f->type = type;
 8026682:	7107      	strb	r7, [r0, #4]
	f->m    = 0.0f;
 8026684:	2300      	movs	r3, #0
	f->G    = ONE_OVER_SQRT2;
 8026686:	f6c3 7135 	movt	r1, #16181	; 0x3f35
	f->invG    = 1.0f/ONE_OVER_SQRT2;
 802668a:	f6c3 72b5 	movt	r2, #16309	; 0x3fb5
	f->sr = leaf.sampleRate;
 802668e:	6826      	ldr	r6, [r4, #0]
	f->inv_sr = leaf.invSampleRate;
 8026690:	6864      	ldr	r4, [r4, #4]
	f->fc   = freq;
 8026692:	edc0 8a0a 	vstr	s17, [r0, #40]	; 0x28
	f->invG    = 1.0f/ONE_OVER_SQRT2;
 8026696:	6302      	str	r2, [r0, #48]	; 0x30

void   tVZFilter_calcCoeffs           (tVZFilter* const vf)
{

	_tVZFilter* f = *vf;
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8026698:	f640 72db 	movw	r2, #4059	; 0xfdb
	f->m    = 0.0f;
 802669c:	6383      	str	r3, [r0, #56]	; 0x38
	f->s1 = 0.0f;
 802669e:	6083      	str	r3, [r0, #8]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80266a0:	f2c4 0249 	movt	r2, #16457	; 0x4049
	f->s2 = 0.0f;
 80266a4:	60c3      	str	r3, [r0, #12]
	f->B    = bandWidth;
 80266a6:	ed80 8a0d 	vstr	s16, [r0, #52]	; 0x34
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80266aa:	ee07 2a90 	vmov	s15, r2
	f->G    = ONE_OVER_SQRT2;
 80266ae:	62c1      	str	r1, [r0, #44]	; 0x2c
	f->sr = leaf.sampleRate;
 80266b0:	63c6      	str	r6, [r0, #60]	; 0x3c
	f->inv_sr = leaf.invSampleRate;
 80266b2:	6404      	str	r4, [r0, #64]	; 0x40
	_tVZFilter* f = *vf;
 80266b4:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80266b6:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 80266ba:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 80266be:	ee28 8a07 	vmul.f32	s16, s16, s14
 80266c2:	ee28 8a27 	vmul.f32	s16, s16, s15
 80266c6:	eeb0 0a48 	vmov.f32	s0, s16
 80266ca:	f004 ff23 	bl	802b514 <tanf>

	  switch( f->type )
 80266ce:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80266d0:	eef0 8a40 	vmov.f32	s17, s0
 80266d4:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
 80266d8:	2b0a      	cmp	r3, #10
 80266da:	f200 81be 	bhi.w	8026a5a <tVZFilter_initToPool+0x406>
 80266de:	e8df f013 	tbh	[pc, r3, lsl #1]
 80266e2:	0057      	.short	0x0057
 80266e4:	006d0062 	.word	0x006d0062
 80266e8:	00b30078 	.word	0x00b30078
 80266ec:	012200ef 	.word	0x012200ef
 80266f0:	016a0146 	.word	0x016a0146
 80266f4:	000b01b1 	.word	0x000b01b1
}

float tVZFilter_BandwidthToR(tVZFilter* const vf, float B)
{
	_tVZFilter* f = *vf;
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80266f8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80266fc:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026700:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026702:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026706:	ee60 0aa7 	vmul.f32	s1, s1, s15
 802670a:	f004 fdc5 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 802670e:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026712:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026716:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 802671a:	f2c4 0349 	movt	r3, #16457	; 0x4049
 802671e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026722:	ee07 3a10 	vmov	s14, r3
 8026726:	ee67 7a87 	vmul.f32	s15, s15, s14
 802672a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802672e:	f004 fef1 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026732:	ed95 7a04 	vldr	s14, [r5, #16]
							   // unwarped: r = pow(2, -B/2) -> approximation for low
							   // center-frequencies
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026736:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802673a:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802673e:	edc4 7a07 	vstr	s15, [r4, #28]
 8026742:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026746:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802674a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802674e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8026752:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026756:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802675a:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802675e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8026762:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8026766:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802676a:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802676e:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 8026772:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8026776:	ee77 7aa8 	vadd.f32	s15, s15, s17
 802677a:	eef0 6a47 	vmov.f32	s13, s14
 802677e:	eee7 6aa8 	vfma.f32	s13, s15, s17
 8026782:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8026786:	edc4 7a06 	vstr	s15, [r4, #24]
}
 802678a:	ecbd 8b04 	vpop	{d8-d9}
 802678e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026790:	2300      	movs	r3, #0
 8026792:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8026796:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 802679a:	6262      	str	r2, [r4, #36]	; 0x24
 802679c:	61e3      	str	r3, [r4, #28]
 802679e:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
 80267a0:	edc4 7a05 	vstr	s15, [r4, #20]
 80267a4:	e7e5      	b.n	8026772 <tVZFilter_initToPool+0x11e>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80267a6:	2300      	movs	r3, #0
 80267a8:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 80267ac:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 80267b0:	61e2      	str	r2, [r4, #28]
 80267b2:	6223      	str	r3, [r4, #32]
 80267b4:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 80267b6:	edc4 7a05 	vstr	s15, [r4, #20]
 80267ba:	e7da      	b.n	8026772 <tVZFilter_initToPool+0x11e>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80267bc:	2300      	movs	r3, #0
 80267be:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 80267c2:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80267c6:	6222      	str	r2, [r4, #32]
 80267c8:	61e3      	str	r3, [r4, #28]
 80267ca:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 80267cc:	edc4 7a05 	vstr	s15, [r4, #20]
 80267d0:	e7cf      	b.n	8026772 <tVZFilter_initToPool+0x11e>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80267d2:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80267d6:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 80267da:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80267dc:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80267e0:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80267e4:	f004 fd58 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80267e8:	f640 73db 	movw	r3, #4059	; 0xfdb
 80267ec:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 80267f0:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80267f4:	f2c4 0349 	movt	r3, #16457	; 0x4049
 80267f8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80267fc:	ee07 3a10 	vmov	s14, r3
 8026800:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026804:	ee27 0a80 	vmul.f32	s0, s15, s0
 8026808:	f004 fe84 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802680c:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026810:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8026814:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026816:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802681a:	61e3      	str	r3, [r4, #28]
 802681c:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802681e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8026822:	ee20 0a00 	vmul.f32	s0, s0, s0
 8026826:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802682a:	ee20 0a07 	vmul.f32	s0, s0, s14
 802682e:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8026832:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8026836:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802683a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 802683e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8026842:	edc4 7a08 	vstr	s15, [r4, #32]
 8026846:	e794      	b.n	8026772 <tVZFilter_initToPool+0x11e>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026848:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 802684c:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026850:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026852:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026856:	ee60 0aa7 	vmul.f32	s1, s1, s15
 802685a:	f004 fd1d 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 802685e:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026862:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026866:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 802686a:	f2c4 0349 	movt	r3, #16457	; 0x4049
 802686e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026872:	ee07 3a10 	vmov	s14, r3
 8026876:	ee67 7a87 	vmul.f32	s15, s15, s14
 802687a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802687e:	f004 fe49 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026882:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026886:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 802688a:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802688c:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026890:	6223      	str	r3, [r4, #32]
 8026892:	edc4 7a07 	vstr	s15, [r4, #28]
 8026896:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802689a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802689e:	ee20 0a00 	vmul.f32	s0, s0, s0
 80268a2:	ee77 7ac0 	vsub.f32	s15, s15, s0
 80268a6:	ee20 0a07 	vmul.f32	s0, s0, s14
 80268aa:	ee67 7aa7 	vmul.f32	s15, s15, s15
 80268ae:	ee87 7a80 	vdiv.f32	s14, s15, s0
 80268b2:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 80268b6:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80268ba:	edc4 7a05 	vstr	s15, [r4, #20]
 80268be:	e758      	b.n	8026772 <tVZFilter_initToPool+0x11e>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 80268c0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80268c4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 80268c8:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80268cc:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80268d0:	f004 fce2 	bl	802b298 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80268d4:	ee28 0a00 	vmul.f32	s0, s16, s0
 80268d8:	f004 fe1c 	bl	802b514 <tanf>
			float r  = f->g/wl;
 80268dc:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80268e0:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 80268e4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80268e8:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 80268ec:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 80268f0:	edc4 7a07 	vstr	s15, [r4, #28]
 80268f4:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80268f8:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 80268fc:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8026900:	eee0 7a00 	vfma.f32	s15, s0, s0
 8026904:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8026908:	ee76 7a65 	vsub.f32	s15, s12, s11
 802690c:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8026910:	eef1 7ac6 	vsqrt.f32	s15, s12
 8026914:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8026918:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 802691c:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8026920:	ed84 7a08 	vstr	s14, [r4, #32]
 8026924:	e725      	b.n	8026772 <tVZFilter_initToPool+0x11e>
			float A = sqrtf(f->G);
 8026926:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802692a:	f247 2318 	movw	r3, #29208	; 0x7218
 802692e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8026932:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
 8026936:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802693a:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 802693e:	ee07 3a90 	vmov	s15, r3
 8026942:	ee20 0a27 	vmul.f32	s0, s0, s15
 8026946:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802694a:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 802694e:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026952:	f005 f8c9 	bl	802bae8 <sinhf>
 8026956:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 802695a:	ed84 9a07 	vstr	s18, [r4, #28]
 802695e:	6265      	str	r5, [r4, #36]	; 0x24
 8026960:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026964:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8026968:	ed84 8a08 	vstr	s16, [r4, #32]
 802696c:	e701      	b.n	8026772 <tVZFilter_initToPool+0x11e>
		  float A = sqrtf(f->G);
 802696e:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026972:	f247 2318 	movw	r3, #29208	; 0x7218
 8026976:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
 802697a:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802697e:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 8026982:	ee07 3a90 	vmov	s15, r3
 8026986:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802698a:	eef1 7ac8 	vsqrt.f32	s15, s16
 802698e:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8026992:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026996:	f005 f8a7 	bl	802bae8 <sinhf>
 802699a:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 802699e:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 80269a2:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 80269a6:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 80269aa:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 80269ae:	61e3      	str	r3, [r4, #28]
 80269b0:	ed84 8a08 	vstr	s16, [r4, #32]
 80269b4:	e6dd      	b.n	8026772 <tVZFilter_initToPool+0x11e>
		  float x  = 2.0f*f->m-1.0f;
 80269b6:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 80269ba:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 80269be:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
 80269c2:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80269c4:	2300      	movs	r3, #0
			f->R2 = f->invG;
 80269c6:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
 80269c8:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80269cc:	ee00 3a90 	vmov	s1, r3
 80269d0:	eef1 8a48 	vneg.f32	s17, s16
 80269d4:	eeb0 0a68 	vmov.f32	s0, s17
 80269d8:	f001 f9e8 	bl	8027dac <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80269dc:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80269de:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80269e2:	eeb0 0a48 	vmov.f32	s0, s16
 80269e6:	ee00 3a90 	vmov	s1, r3
 80269ea:	f001 f9e3 	bl	8027db4 <minimum>
		  f->cB = 1.0f-x*x;
 80269ee:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80269f2:	edd4 6a07 	vldr	s13, [r4, #28]
 80269f6:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
 80269fa:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80269fe:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 8026a02:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8026a06:	edd4 8a04 	vldr	s17, [r4, #16]
 8026a0a:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8026a0e:	ee27 6a07 	vmul.f32	s12, s14, s14
 8026a12:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8026a16:	eea0 6a00 	vfma.f32	s12, s0, s0
 8026a1a:	eea0 6a45 	vfms.f32	s12, s0, s10
 8026a1e:	ee84 5a86 	vdiv.f32	s10, s9, s12
 8026a22:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8026a26:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
 8026a2a:	ee66 6a86 	vmul.f32	s13, s13, s12
 8026a2e:	ee27 7a06 	vmul.f32	s14, s14, s12
 8026a32:	ee20 0a06 	vmul.f32	s0, s0, s12
 8026a36:	edc4 6a07 	vstr	s13, [r4, #28]
 8026a3a:	ed84 7a08 	vstr	s14, [r4, #32]
 8026a3e:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8026a42:	e696      	b.n	8026772 <tVZFilter_initToPool+0x11e>
		  f->cL = 1.0f;
 8026a44:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8026a48:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
 8026a4c:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8026a4e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
 8026a52:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
 8026a54:	edc4 7a08 	vstr	s15, [r4, #32]
 8026a58:	e68b      	b.n	8026772 <tVZFilter_initToPool+0x11e>
 8026a5a:	edd4 7a05 	vldr	s15, [r4, #20]
 8026a5e:	e688      	b.n	8026772 <tVZFilter_initToPool+0x11e>

08026a60 <tVZFilter_free>:
    _tVZFilter* f = *vf;
 8026a60:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)f, f->mempool);
 8026a62:	6801      	ldr	r1, [r0, #0]
 8026a64:	f001 ba6c 	b.w	8027f40 <mpool_free>

08026a68 <tVZFilter_setSampleRate>:
	f->inv_sr = 1.0f/sampleRate;
 8026a68:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
	_tVZFilter* f = *vf;
 8026a6c:	6803      	ldr	r3, [r0, #0]
	f->sr = sampleRate;
 8026a6e:	ed83 0a0f 	vstr	s0, [r3, #60]	; 0x3c
	f->inv_sr = 1.0f/sampleRate;
 8026a72:	eec7 7a00 	vdiv.f32	s15, s14, s0
 8026a76:	edc3 7a10 	vstr	s15, [r3, #64]	; 0x40
}
 8026a7a:	4770      	bx	lr

08026a7c <tVZFilter_tick>:
{
 8026a7c:	b510      	push	{r4, lr}
	_tVZFilter* f = *vf;
 8026a7e:	6804      	ldr	r4, [r0, #0]
{
 8026a80:	ed2d 8b06 	vpush	{d8-d10}
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 8026a84:	ed94 8a02 	vldr	s16, [r4, #8]
 8026a88:	edd4 7a05 	vldr	s15, [r4, #20]
 8026a8c:	ed94 9a04 	vldr	s18, [r4, #16]
 8026a90:	eea7 0ac8 	vfms.f32	s0, s15, s16
 8026a94:	edd4 9a03 	vldr	s19, [r4, #12]
 8026a98:	edd4 7a06 	vldr	s15, [r4, #24]
 8026a9c:	eea8 0a49 	vfms.f32	s0, s16, s18
 8026aa0:	ee70 8a69 	vsub.f32	s17, s0, s19
 8026aa4:	ee68 8aa7 	vmul.f32	s17, s17, s15
	yB = tanhf(f->g*yH) + f->s1;
 8026aa8:	ee29 aa28 	vmul.f32	s20, s18, s17
 8026aac:	eeb0 0a4a 	vmov.f32	s0, s20
 8026ab0:	f004 fd58 	bl	802b564 <tanhf>
 8026ab4:	ee38 8a00 	vadd.f32	s16, s16, s0
	yL = tanhf(f->g*yB) + f->s2;
 8026ab8:	ee29 9a08 	vmul.f32	s18, s18, s16
	f->s1 = f->g*yH + yB; // state update in 1st integrator
 8026abc:	ee3a aa08 	vadd.f32	s20, s20, s16
	yL = tanhf(f->g*yB) + f->s2;
 8026ac0:	eeb0 0a49 	vmov.f32	s0, s18
	f->s1 = f->g*yH + yB; // state update in 1st integrator
 8026ac4:	ed84 aa02 	vstr	s20, [r4, #8]
	yL = tanhf(f->g*yB) + f->s2;
 8026ac8:	f004 fd4c 	bl	802b564 <tanhf>
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026acc:	edd4 7a08 	vldr	s15, [r4, #32]
	yL = tanhf(f->g*yB) + f->s2;
 8026ad0:	ee79 9a80 	vadd.f32	s19, s19, s0
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026ad4:	ed94 7a07 	vldr	s14, [r4, #28]
 8026ad8:	ee28 0a27 	vmul.f32	s0, s16, s15
 8026adc:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8026ae0:	ee39 9a29 	vadd.f32	s18, s18, s19
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026ae4:	eea7 0a29 	vfma.f32	s0, s14, s19
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8026ae8:	ed84 9a03 	vstr	s18, [r4, #12]
}
 8026aec:	eea7 0aa8 	vfma.f32	s0, s15, s17
 8026af0:	ecbd 8b06 	vpop	{d8-d10}
 8026af4:	bd10      	pop	{r4, pc}
 8026af6:	bf00      	nop

08026af8 <tVZFilter_tickEfficient>:
	_tVZFilter* f = *vf;
 8026af8:	6803      	ldr	r3, [r0, #0]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 8026afa:	ed93 7a02 	vldr	s14, [r3, #8]
 8026afe:	edd3 7a05 	vldr	s15, [r3, #20]
 8026b02:	edd3 5a04 	vldr	s11, [r3, #16]
 8026b06:	eea7 0ac7 	vfms.f32	s0, s15, s14
 8026b0a:	ed93 6a03 	vldr	s12, [r3, #12]
 8026b0e:	ed93 4a06 	vldr	s8, [r3, #24]
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026b12:	edd3 6a09 	vldr	s13, [r3, #36]	; 0x24
 8026b16:	edd3 4a08 	vldr	s9, [r3, #32]
 8026b1a:	ed93 5a07 	vldr	s10, [r3, #28]
	yH = (in - f->R2*f->s1 - f->g*f->s1 - f->s2) * f->h;
 8026b1e:	eea7 0a65 	vfms.f32	s0, s14, s11
 8026b22:	ee70 7a46 	vsub.f32	s15, s0, s12
 8026b26:	ee67 7a84 	vmul.f32	s15, s15, s8
	yB = (f->g*yH) + f->s1;
 8026b2a:	eea5 7aa7 	vfma.f32	s14, s11, s15
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026b2e:	ee27 0aa6 	vmul.f32	s0, s15, s13
	yL = (f->g*yB) + f->s2;
 8026b32:	eef0 6a46 	vmov.f32	s13, s12
 8026b36:	eee5 6a87 	vfma.f32	s13, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
 8026b3a:	eeb0 6a47 	vmov.f32	s12, s14
	return f->cL*yL + f->cB*yB + f->cH*yH;
 8026b3e:	eea4 0a87 	vfma.f32	s0, s9, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
 8026b42:	eea5 6aa7 	vfma.f32	s12, s11, s15
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8026b46:	eef0 7a66 	vmov.f32	s15, s13
}
 8026b4a:	eea5 0a26 	vfma.f32	s0, s10, s13
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8026b4e:	eee5 7a87 	vfma.f32	s15, s11, s14
	f->s1 = f->g*yH + yB; // state update in 1st integrator
 8026b52:	ed83 6a02 	vstr	s12, [r3, #8]
	f->s2 = f->g*yB + yL; // state update in 2nd integrator
 8026b56:	edc3 7a03 	vstr	s15, [r3, #12]
}
 8026b5a:	4770      	bx	lr

08026b5c <tVZFilter_setFreq>:
{
 8026b5c:	b538      	push	{r3, r4, r5, lr}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026b5e:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8026b62:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8026b66:	2200      	movs	r2, #0
	_tVZFilter* f = *vf;
 8026b68:	6804      	ldr	r4, [r0, #0]
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026b6a:	f2c2 0301 	movt	r3, #8193	; 0x2001
{
 8026b6e:	4605      	mov	r5, r0
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026b70:	eef0 0a40 	vmov.f32	s1, s0
 8026b74:	ee00 2a10 	vmov	s0, r2
{
 8026b78:	ed2d 8b04 	vpush	{d8-d9}
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026b7c:	ed93 1a00 	vldr	s2, [r3]
 8026b80:	ee21 1a27 	vmul.f32	s2, s2, s15
 8026b84:	f000 ff18 	bl	80279b8 <LEAF_clip>
 8026b88:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
 8026b8c:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8026b8e:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026b92:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8026b96:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8026b9a:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8026b9e:	ee07 3a90 	vmov	s15, r3
 8026ba2:	ee28 8a07 	vmul.f32	s16, s16, s14
 8026ba6:	ee28 8a27 	vmul.f32	s16, s16, s15
 8026baa:	eeb0 0a48 	vmov.f32	s0, s16
 8026bae:	f004 fcb1 	bl	802b514 <tanf>
	  switch( f->type )
 8026bb2:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8026bb4:	eef0 8a40 	vmov.f32	s17, s0
 8026bb8:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
 8026bbc:	2b0a      	cmp	r3, #10
 8026bbe:	f200 81be 	bhi.w	8026f3e <tVZFilter_setFreq+0x3e2>
 8026bc2:	e8df f013 	tbh	[pc, r3, lsl #1]
 8026bc6:	0057      	.short	0x0057
 8026bc8:	006d0062 	.word	0x006d0062
 8026bcc:	00b30078 	.word	0x00b30078
 8026bd0:	012200ef 	.word	0x012200ef
 8026bd4:	016a0146 	.word	0x016a0146
 8026bd8:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026bdc:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8026be0:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026be4:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026be6:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026bea:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8026bee:	f004 fb53 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8026bf2:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026bf6:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026bfa:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8026bfe:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8026c02:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026c06:	ee07 3a10 	vmov	s14, r3
 8026c0a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026c0e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8026c12:	f004 fc7f 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026c16:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026c1a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026c1e:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8026c22:	edc4 7a07 	vstr	s15, [r4, #28]
 8026c26:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026c2a:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8026c2e:	ee20 0a00 	vmul.f32	s0, s0, s0
 8026c32:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8026c36:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026c3a:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8026c3e:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8026c42:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8026c46:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8026c4a:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8026c4e:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8026c52:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 8026c56:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 8026c5a:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8026c5e:	eef0 6a47 	vmov.f32	s13, s14
 8026c62:	eee7 6aa8 	vfma.f32	s13, s15, s17
 8026c66:	eec7 7a26 	vdiv.f32	s15, s14, s13
 8026c6a:	edc4 7a06 	vstr	s15, [r4, #24]
}
 8026c6e:	ecbd 8b04 	vpop	{d8-d9}
 8026c72:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026c74:	2300      	movs	r3, #0
 8026c76:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8026c7a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026c7e:	6262      	str	r2, [r4, #36]	; 0x24
 8026c80:	61e3      	str	r3, [r4, #28]
 8026c82:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
 8026c84:	edc4 7a05 	vstr	s15, [r4, #20]
 8026c88:	e7e5      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8026c8a:	2300      	movs	r3, #0
 8026c8c:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8026c90:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8026c94:	61e2      	str	r2, [r4, #28]
 8026c96:	6223      	str	r3, [r4, #32]
 8026c98:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 8026c9a:	edc4 7a05 	vstr	s15, [r4, #20]
 8026c9e:	e7da      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8026ca0:	2300      	movs	r3, #0
 8026ca2:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8026ca6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8026caa:	6222      	str	r2, [r4, #32]
 8026cac:	61e3      	str	r3, [r4, #28]
 8026cae:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 8026cb0:	edc4 7a05 	vstr	s15, [r4, #20]
 8026cb4:	e7cf      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026cb6:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8026cba:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026cbe:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026cc0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026cc4:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8026cc8:	f004 fae6 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8026ccc:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026cd0:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026cd4:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8026cd8:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8026cdc:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026ce0:	ee07 3a10 	vmov	s14, r3
 8026ce4:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026ce8:	ee27 0a80 	vmul.f32	s0, s15, s0
 8026cec:	f004 fc12 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026cf0:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026cf4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8026cf8:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026cfa:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8026cfe:	61e3      	str	r3, [r4, #28]
 8026d00:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026d02:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8026d06:	ee20 0a00 	vmul.f32	s0, s0, s0
 8026d0a:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8026d0e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026d12:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8026d16:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8026d1a:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8026d1e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8026d22:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8026d26:	edc4 7a08 	vstr	s15, [r4, #32]
 8026d2a:	e794      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026d2c:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8026d30:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026d34:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026d36:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026d3a:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8026d3e:	f004 faab 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8026d42:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026d46:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026d4a:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8026d4e:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8026d52:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026d56:	ee07 3a10 	vmov	s14, r3
 8026d5a:	ee67 7a87 	vmul.f32	s15, s15, s14
 8026d5e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8026d62:	f004 fbd7 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026d66:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026d6a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026d6e:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8026d70:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8026d74:	6223      	str	r3, [r4, #32]
 8026d76:	edc4 7a07 	vstr	s15, [r4, #28]
 8026d7a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8026d7e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8026d82:	ee20 0a00 	vmul.f32	s0, s0, s0
 8026d86:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8026d8a:	ee20 0a07 	vmul.f32	s0, s0, s14
 8026d8e:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8026d92:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8026d96:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8026d9a:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8026d9e:	edc4 7a05 	vstr	s15, [r4, #20]
 8026da2:	e758      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8026da4:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8026da8:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 8026dac:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026db0:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8026db4:	f004 fa70 	bl	802b298 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8026db8:	ee28 0a00 	vmul.f32	s0, s16, s0
 8026dbc:	f004 fbaa 	bl	802b514 <tanf>
			float r  = f->g/wl;
 8026dc0:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8026dc4:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 8026dc8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8026dcc:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 8026dd0:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8026dd4:	edc4 7a07 	vstr	s15, [r4, #28]
 8026dd8:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8026ddc:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 8026de0:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8026de4:	eee0 7a00 	vfma.f32	s15, s0, s0
 8026de8:	ee87 6a80 	vdiv.f32	s12, s15, s0
 8026dec:	ee76 7a65 	vsub.f32	s15, s12, s11
 8026df0:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 8026df4:	eef1 7ac6 	vsqrt.f32	s15, s12
 8026df8:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8026dfc:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8026e00:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8026e04:	ed84 7a08 	vstr	s14, [r4, #32]
 8026e08:	e725      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
			float A = sqrtf(f->G);
 8026e0a:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026e0e:	f247 2318 	movw	r3, #29208	; 0x7218
 8026e12:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8026e16:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
 8026e1a:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026e1e:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 8026e22:	ee07 3a90 	vmov	s15, r3
 8026e26:	ee20 0a27 	vmul.f32	s0, s0, s15
 8026e2a:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8026e2e:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8026e32:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026e36:	f004 fe57 	bl	802bae8 <sinhf>
 8026e3a:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8026e3e:	ed84 9a07 	vstr	s18, [r4, #28]
 8026e42:	6265      	str	r5, [r4, #36]	; 0x24
 8026e44:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8026e48:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8026e4c:	ed84 8a08 	vstr	s16, [r4, #32]
 8026e50:	e701      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
		  float A = sqrtf(f->G);
 8026e52:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026e56:	f247 2318 	movw	r3, #29208	; 0x7218
 8026e5a:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
 8026e5e:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026e62:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 8026e66:	ee07 3a90 	vmov	s15, r3
 8026e6a:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8026e6e:	eef1 7ac8 	vsqrt.f32	s15, s16
 8026e72:	ee68 8aa7 	vmul.f32	s17, s17, s15
 8026e76:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026e7a:	f004 fe35 	bl	802bae8 <sinhf>
 8026e7e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8026e82:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 8026e86:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 8026e8a:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8026e8e:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8026e92:	61e3      	str	r3, [r4, #28]
 8026e94:	ed84 8a08 	vstr	s16, [r4, #32]
 8026e98:	e6dd      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
		  float x  = 2.0f*f->m-1.0f;
 8026e9a:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8026e9e:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8026ea2:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
 8026ea6:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8026ea8:	2300      	movs	r3, #0
			f->R2 = f->invG;
 8026eaa:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
 8026eac:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8026eb0:	ee00 3a90 	vmov	s1, r3
 8026eb4:	eef1 8a48 	vneg.f32	s17, s16
 8026eb8:	eeb0 0a68 	vmov.f32	s0, s17
 8026ebc:	f000 ff76 	bl	8027dac <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8026ec0:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 8026ec2:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 8026ec6:	eeb0 0a48 	vmov.f32	s0, s16
 8026eca:	ee00 3a90 	vmov	s1, r3
 8026ece:	f000 ff71 	bl	8027db4 <minimum>
		  f->cB = 1.0f-x*x;
 8026ed2:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8026ed6:	edd4 6a07 	vldr	s13, [r4, #28]
 8026eda:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
 8026ede:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 8026ee2:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 8026ee6:	ee36 5aa6 	vadd.f32	s10, s13, s13
 8026eea:	edd4 8a04 	vldr	s17, [r4, #16]
 8026eee:	ee67 4aa7 	vmul.f32	s9, s15, s15
 8026ef2:	ee27 6a07 	vmul.f32	s12, s14, s14
 8026ef6:	eea6 6aa6 	vfma.f32	s12, s13, s13
 8026efa:	eea0 6a00 	vfma.f32	s12, s0, s0
 8026efe:	eea0 6a45 	vfms.f32	s12, s0, s10
 8026f02:	ee84 5a86 	vdiv.f32	s10, s9, s12
 8026f06:	eeb1 6ac5 	vsqrt.f32	s12, s10
 8026f0a:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
 8026f0e:	ee66 6a86 	vmul.f32	s13, s13, s12
 8026f12:	ee27 7a06 	vmul.f32	s14, s14, s12
 8026f16:	ee20 0a06 	vmul.f32	s0, s0, s12
 8026f1a:	edc4 6a07 	vstr	s13, [r4, #28]
 8026f1e:	ed84 7a08 	vstr	s14, [r4, #32]
 8026f22:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 8026f26:	e696      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
		  f->cL = 1.0f;
 8026f28:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8026f2c:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
 8026f30:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8026f32:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
 8026f36:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
 8026f38:	edc4 7a08 	vstr	s15, [r4, #32]
 8026f3c:	e68b      	b.n	8026c56 <tVZFilter_setFreq+0xfa>
 8026f3e:	edd4 7a05 	vldr	s15, [r4, #20]
 8026f42:	e688      	b.n	8026c56 <tVZFilter_setFreq+0xfa>

08026f44 <tVZFilter_setFreqAndBandwidth>:
{
 8026f44:	b538      	push	{r3, r4, r5, lr}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
 8026f46:	2300      	movs	r3, #0
	_tVZFilter* f = *vf;
 8026f48:	6804      	ldr	r4, [r0, #0]
{
 8026f4a:	4605      	mov	r5, r0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
 8026f4c:	461a      	mov	r2, r3
 8026f4e:	f2c4 23c8 	movt	r3, #17096	; 0x42c8
{
 8026f52:	ed2d 8b04 	vpush	{d8-d9}
	f->B = LEAF_clip(0.0f,bw, 100.0f);
 8026f56:	ee01 3a10 	vmov	s2, r3
{
 8026f5a:	eeb0 8a40 	vmov.f32	s16, s0
	f->B = LEAF_clip(0.0f,bw, 100.0f);
 8026f5e:	ee00 2a10 	vmov	s0, r2
 8026f62:	f000 fd29 	bl	80279b8 <LEAF_clip>
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026f66:	f249 43a0 	movw	r3, #38048	; 0x94a0
 8026f6a:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8026f6e:	2200      	movs	r2, #0
 8026f70:	f2c2 0301 	movt	r3, #8193	; 0x2001
	f->B = LEAF_clip(0.0f,bw, 100.0f);
 8026f74:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
	f->fc = LEAF_clip(0.0f, freq, 0.5f*leaf.sampleRate);
 8026f78:	eef0 0a48 	vmov.f32	s1, s16
 8026f7c:	ee00 2a10 	vmov	s0, r2
 8026f80:	ed93 1a00 	vldr	s2, [r3]
 8026f84:	ee21 1a27 	vmul.f32	s2, s2, s15
 8026f88:	f000 fd16 	bl	80279b8 <LEAF_clip>
 8026f8c:	ed84 0a0a 	vstr	s0, [r4, #40]	; 0x28
	_tVZFilter* f = *vf;
 8026f90:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8026f92:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026f96:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8026f9a:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8026f9e:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8026fa2:	ee07 3a90 	vmov	s15, r3
 8026fa6:	ee28 8a07 	vmul.f32	s16, s16, s14
 8026faa:	ee28 8a27 	vmul.f32	s16, s16, s15
 8026fae:	eeb0 0a48 	vmov.f32	s0, s16
 8026fb2:	f004 faaf 	bl	802b514 <tanf>
	  switch( f->type )
 8026fb6:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8026fb8:	eef0 8a40 	vmov.f32	s17, s0
 8026fbc:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
 8026fc0:	2b0a      	cmp	r3, #10
 8026fc2:	f200 81be 	bhi.w	8027342 <tVZFilter_setFreqAndBandwidth+0x3fe>
 8026fc6:	e8df f013 	tbh	[pc, r3, lsl #1]
 8026fca:	0057      	.short	0x0057
 8026fcc:	006d0062 	.word	0x006d0062
 8026fd0:	00b30078 	.word	0x00b30078
 8026fd4:	012200ef 	.word	0x012200ef
 8026fd8:	016a0146 	.word	0x016a0146
 8026fdc:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026fe0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8026fe4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8026fe8:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8026fea:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8026fee:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8026ff2:	f004 f951 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8026ff6:	f640 73db 	movw	r3, #4059	; 0xfdb
 8026ffa:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 8026ffe:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8027002:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8027006:	ee67 7a87 	vmul.f32	s15, s15, s14
 802700a:	ee07 3a10 	vmov	s14, r3
 802700e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8027012:	ee27 0a80 	vmul.f32	s0, s15, s0
 8027016:	f004 fa7d 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802701a:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802701e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8027022:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8027026:	edc4 7a07 	vstr	s15, [r4, #28]
 802702a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802702e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8027032:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027036:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802703a:	ee20 0a07 	vmul.f32	s0, s0, s14
 802703e:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027042:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8027046:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802704a:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802704e:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8027052:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8027056:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 802705a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802705e:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8027062:	eef0 6a47 	vmov.f32	s13, s14
 8027066:	eee7 6aa8 	vfma.f32	s13, s15, s17
 802706a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802706e:	edc4 7a06 	vstr	s15, [r4, #24]
}
 8027072:	ecbd 8b04 	vpop	{d8-d9}
 8027076:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027078:	2300      	movs	r3, #0
 802707a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 802707e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027082:	6262      	str	r2, [r4, #36]	; 0x24
 8027084:	61e3      	str	r3, [r4, #28]
 8027086:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
 8027088:	edc4 7a05 	vstr	s15, [r4, #20]
 802708c:	e7e5      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 802708e:	2300      	movs	r3, #0
 8027090:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8027094:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8027098:	61e2      	str	r2, [r4, #28]
 802709a:	6223      	str	r3, [r4, #32]
 802709c:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 802709e:	edc4 7a05 	vstr	s15, [r4, #20]
 80270a2:	e7da      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80270a4:	2300      	movs	r3, #0
 80270a6:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 80270aa:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 80270ae:	6222      	str	r2, [r4, #32]
 80270b0:	61e3      	str	r3, [r4, #28]
 80270b2:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 80270b4:	edc4 7a05 	vstr	s15, [r4, #20]
 80270b8:	e7cf      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80270ba:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80270be:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 80270c2:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80270c4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80270c8:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80270cc:	f004 f8e4 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80270d0:	f640 73db 	movw	r3, #4059	; 0xfdb
 80270d4:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 80270d8:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80270dc:	f2c4 0349 	movt	r3, #16457	; 0x4049
 80270e0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80270e4:	ee07 3a10 	vmov	s14, r3
 80270e8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80270ec:	ee27 0a80 	vmul.f32	s0, s15, s0
 80270f0:	f004 fa10 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80270f4:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80270f8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 80270fc:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80270fe:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 8027102:	61e3      	str	r3, [r4, #28]
 8027104:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8027106:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 802710a:	ee20 0a00 	vmul.f32	s0, s0, s0
 802710e:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8027112:	ee20 0a07 	vmul.f32	s0, s0, s14
 8027116:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802711a:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802711e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8027122:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8027126:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802712a:	edc4 7a08 	vstr	s15, [r4, #32]
 802712e:	e794      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8027130:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8027134:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8027138:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802713a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802713e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8027142:	f004 f8a9 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8027146:	f640 73db 	movw	r3, #4059	; 0xfdb
 802714a:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 802714e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8027152:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8027156:	ee67 7a87 	vmul.f32	s15, s15, s14
 802715a:	ee07 3a10 	vmov	s14, r3
 802715e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8027162:	ee27 0a80 	vmul.f32	s0, s15, s0
 8027166:	f004 f9d5 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802716a:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802716e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027172:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8027174:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027178:	6223      	str	r3, [r4, #32]
 802717a:	edc4 7a07 	vstr	s15, [r4, #28]
 802717e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8027182:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8027186:	ee20 0a00 	vmul.f32	s0, s0, s0
 802718a:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802718e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8027192:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027196:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802719a:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802719e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 80271a2:	edc4 7a05 	vstr	s15, [r4, #20]
 80271a6:	e758      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 80271a8:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80271ac:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 80271b0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80271b4:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80271b8:	f004 f86e 	bl	802b298 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80271bc:	ee28 0a00 	vmul.f32	s0, s16, s0
 80271c0:	f004 f9a8 	bl	802b514 <tanf>
			float r  = f->g/wl;
 80271c4:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80271c8:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 80271cc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80271d0:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 80271d4:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 80271d8:	edc4 7a07 	vstr	s15, [r4, #28]
 80271dc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80271e0:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 80271e4:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80271e8:	eee0 7a00 	vfma.f32	s15, s0, s0
 80271ec:	ee87 6a80 	vdiv.f32	s12, s15, s0
 80271f0:	ee76 7a65 	vsub.f32	s15, s12, s11
 80271f4:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 80271f8:	eef1 7ac6 	vsqrt.f32	s15, s12
 80271fc:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8027200:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 8027204:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 8027208:	ed84 7a08 	vstr	s14, [r4, #32]
 802720c:	e725      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
			float A = sqrtf(f->G);
 802720e:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8027212:	f247 2318 	movw	r3, #29208	; 0x7218
 8027216:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802721a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
 802721e:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8027222:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 8027226:	ee07 3a90 	vmov	s15, r3
 802722a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802722e:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8027232:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8027236:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802723a:	f004 fc55 	bl	802bae8 <sinhf>
 802723e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8027242:	ed84 9a07 	vstr	s18, [r4, #28]
 8027246:	6265      	str	r5, [r4, #36]	; 0x24
 8027248:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802724c:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8027250:	ed84 8a08 	vstr	s16, [r4, #32]
 8027254:	e701      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
		  float A = sqrtf(f->G);
 8027256:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802725a:	f247 2318 	movw	r3, #29208	; 0x7218
 802725e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
 8027262:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8027266:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 802726a:	ee07 3a90 	vmov	s15, r3
 802726e:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8027272:	eef1 7ac8 	vsqrt.f32	s15, s16
 8027276:	ee68 8aa7 	vmul.f32	s17, s17, s15
 802727a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802727e:	f004 fc33 	bl	802bae8 <sinhf>
 8027282:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8027286:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 802728a:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 802728e:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8027292:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8027296:	61e3      	str	r3, [r4, #28]
 8027298:	ed84 8a08 	vstr	s16, [r4, #32]
 802729c:	e6dd      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
		  float x  = 2.0f*f->m-1.0f;
 802729e:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 80272a2:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 80272a6:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
 80272aa:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80272ac:	2300      	movs	r3, #0
			f->R2 = f->invG;
 80272ae:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
 80272b0:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80272b4:	ee00 3a90 	vmov	s1, r3
 80272b8:	eef1 8a48 	vneg.f32	s17, s16
 80272bc:	eeb0 0a68 	vmov.f32	s0, s17
 80272c0:	f000 fd74 	bl	8027dac <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80272c4:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80272c6:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80272ca:	eeb0 0a48 	vmov.f32	s0, s16
 80272ce:	ee00 3a90 	vmov	s1, r3
 80272d2:	f000 fd6f 	bl	8027db4 <minimum>
		  f->cB = 1.0f-x*x;
 80272d6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80272da:	edd4 6a07 	vldr	s13, [r4, #28]
 80272de:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
 80272e2:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80272e6:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 80272ea:	ee36 5aa6 	vadd.f32	s10, s13, s13
 80272ee:	edd4 8a04 	vldr	s17, [r4, #16]
 80272f2:	ee67 4aa7 	vmul.f32	s9, s15, s15
 80272f6:	ee27 6a07 	vmul.f32	s12, s14, s14
 80272fa:	eea6 6aa6 	vfma.f32	s12, s13, s13
 80272fe:	eea0 6a00 	vfma.f32	s12, s0, s0
 8027302:	eea0 6a45 	vfms.f32	s12, s0, s10
 8027306:	ee84 5a86 	vdiv.f32	s10, s9, s12
 802730a:	eeb1 6ac5 	vsqrt.f32	s12, s10
 802730e:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
 8027312:	ee66 6a86 	vmul.f32	s13, s13, s12
 8027316:	ee27 7a06 	vmul.f32	s14, s14, s12
 802731a:	ee20 0a06 	vmul.f32	s0, s0, s12
 802731e:	edc4 6a07 	vstr	s13, [r4, #28]
 8027322:	ed84 7a08 	vstr	s14, [r4, #32]
 8027326:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 802732a:	e696      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
		  f->cL = 1.0f;
 802732c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8027330:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
 8027334:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8027336:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
 802733a:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
 802733c:	edc4 7a08 	vstr	s15, [r4, #32]
 8027340:	e68b      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>
 8027342:	edd4 7a05 	vldr	s15, [r4, #20]
 8027346:	e688      	b.n	802705a <tVZFilter_setFreqAndBandwidth+0x116>

08027348 <tVZFilter_setGain>:
{
 8027348:	b538      	push	{r3, r4, r5, lr}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
 802734a:	2200      	movs	r2, #0
 802734c:	f243 73bd 	movw	r3, #14269	; 0x37bd
 8027350:	eef0 0a40 	vmov.f32	s1, s0
	_tVZFilter* f = *vf;
 8027354:	6804      	ldr	r4, [r0, #0]
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
 8027356:	f2c4 22c8 	movt	r2, #17096	; 0x42c8
 802735a:	f2c3 5386 	movt	r3, #13702	; 0x3586
{
 802735e:	4605      	mov	r5, r0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
 8027360:	ee01 2a10 	vmov	s2, r2
 8027364:	ee00 3a10 	vmov	s0, r3
{
 8027368:	ed2d 8b04 	vpush	{d8-d9}
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
 802736c:	f000 fb24 	bl	80279b8 <LEAF_clip>
	f->invG = 1.0f/f->G;
 8027370:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
	f->G = LEAF_clip(0.000001f, gain, 100.0f);
 8027374:	ed84 0a0b 	vstr	s0, [r4, #44]	; 0x2c
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8027378:	f640 73db 	movw	r3, #4059	; 0xfdb
	f->invG = 1.0f/f->G;
 802737c:	ee87 7a80 	vdiv.f32	s14, s15, s0
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 8027380:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8027384:	ee07 3a90 	vmov	s15, r3
	f->invG = 1.0f/f->G;
 8027388:	ed84 7a0c 	vstr	s14, [r4, #48]	; 0x30
	_tVZFilter* f = *vf;
 802738c:	682c      	ldr	r4, [r5, #0]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 802738e:	ed94 7a10 	vldr	s14, [r4, #64]	; 0x40
 8027392:	ed94 8a0a 	vldr	s16, [r4, #40]	; 0x28
 8027396:	ee28 8a07 	vmul.f32	s16, s16, s14
 802739a:	ee28 8a27 	vmul.f32	s16, s16, s15
 802739e:	eeb0 0a48 	vmov.f32	s0, s16
 80273a2:	f004 f8b7 	bl	802b514 <tanf>
	  switch( f->type )
 80273a6:	7923      	ldrb	r3, [r4, #4]
	f->g = tanf(PI * f->fc * f->inv_sr);  // embedded integrator gain (Fig 3.11)
 80273a8:	eef0 8a40 	vmov.f32	s17, s0
 80273ac:	ed84 0a04 	vstr	s0, [r4, #16]
	  switch( f->type )
 80273b0:	2b0a      	cmp	r3, #10
 80273b2:	f200 81be 	bhi.w	8027732 <tVZFilter_setGain+0x3ea>
 80273b6:	e8df f013 	tbh	[pc, r3, lsl #1]
 80273ba:	0057      	.short	0x0057
 80273bc:	006d0062 	.word	0x006d0062
 80273c0:	00b30078 	.word	0x00b30078
 80273c4:	012200ef 	.word	0x012200ef
 80273c8:	016a0146 	.word	0x016a0146
 80273cc:	000b01b1 	.word	0x000b01b1
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80273d0:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80273d4:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 80273d8:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80273da:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80273de:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80273e2:	f003 ff59 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80273e6:	f640 73db 	movw	r3, #4059	; 0xfdb
 80273ea:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 80273ee:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80273f2:	f2c4 0349 	movt	r3, #16457	; 0x4049
 80273f6:	ee67 7a87 	vmul.f32	s15, s15, s14
 80273fa:	ee07 3a10 	vmov	s14, r3
 80273fe:	ee67 7a87 	vmul.f32	s15, s15, s14
 8027402:	ee27 0a80 	vmul.f32	s0, s15, s0
 8027406:	f004 f885 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802740a:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802740e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8027412:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8027416:	edc4 7a07 	vstr	s15, [r4, #28]
 802741a:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802741e:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8027422:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027426:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802742a:	ee20 0a07 	vmul.f32	s0, s0, s14
 802742e:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027432:	ee87 7a80 	vdiv.f32	s14, s15, s0
 8027436:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802743a:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 802743e:	eeb1 7a67 	vneg.f32	s14, s15
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8027442:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = -f->R2; f->cH = 1.0f;
 8027446:	ed84 7a08 	vstr	s14, [r4, #32]
	  f->h = 1.0f / (1.0f + f->R2*f->g + f->g*f->g);  // factor for feedback precomputation
 802744a:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802744e:	ee77 7aa8 	vadd.f32	s15, s15, s17
 8027452:	eef0 6a47 	vmov.f32	s13, s14
 8027456:	eee7 6aa8 	vfma.f32	s13, s15, s17
 802745a:	eec7 7a26 	vdiv.f32	s15, s14, s13
 802745e:	edc4 7a06 	vstr	s15, [r4, #24]
}
 8027462:	ecbd 8b04 	vpop	{d8-d9}
 8027466:	bd38      	pop	{r3, r4, r5, pc}
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027468:	2300      	movs	r3, #0
 802746a:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 802746e:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027472:	6262      	str	r2, [r4, #36]	; 0x24
 8027474:	61e3      	str	r3, [r4, #28]
 8027476:	6223      	str	r3, [r4, #32]
			f->R2 = f->invG;
 8027478:	edc4 7a05 	vstr	s15, [r4, #20]
 802747c:	e7e5      	b.n	802744a <tVZFilter_setGain+0x102>
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 802747e:	2300      	movs	r3, #0
 8027480:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 8027484:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 0.0f;
 8027488:	61e2      	str	r2, [r4, #28]
 802748a:	6223      	str	r3, [r4, #32]
 802748c:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 802748e:	edc4 7a05 	vstr	s15, [r4, #20]
 8027492:	e7da      	b.n	802744a <tVZFilter_setGain+0x102>
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 8027494:	2300      	movs	r3, #0
 8027496:	f04f 527e 	mov.w	r2, #1065353216	; 0x3f800000
			f->R2 = f->invG;
 802749a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
			f->cL = 0.0f; f->cB = 1.0f; f->cH = 0.0f;
 802749e:	6222      	str	r2, [r4, #32]
 80274a0:	61e3      	str	r3, [r4, #28]
 80274a2:	6263      	str	r3, [r4, #36]	; 0x24
			f->R2 = f->invG;
 80274a4:	edc4 7a05 	vstr	s15, [r4, #20]
 80274a8:	e7cf      	b.n	802744a <tVZFilter_setGain+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80274aa:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 80274ae:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 80274b2:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 80274b4:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80274b8:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80274bc:	f003 feec 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80274c0:	f640 73db 	movw	r3, #4059	; 0xfdb
 80274c4:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 80274c8:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 80274cc:	f2c4 0349 	movt	r3, #16457	; 0x4049
 80274d0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80274d4:	ee07 3a10 	vmov	s14, r3
 80274d8:	ee67 7a87 	vmul.f32	s15, s15, s14
 80274dc:	ee27 0a80 	vmul.f32	s0, s15, s0
 80274e0:	f004 f818 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80274e4:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80274e8:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 80274ec:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 80274ee:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 80274f2:	61e3      	str	r3, [r4, #28]
 80274f4:	6263      	str	r3, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 80274f6:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 80274fa:	ee20 0a00 	vmul.f32	s0, s0, s0
 80274fe:	ee77 7ac0 	vsub.f32	s15, s15, s0
 8027502:	ee20 0a07 	vmul.f32	s0, s0, s14
 8027506:	ee67 7aa7 	vmul.f32	s15, s15, s15
 802750a:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802750e:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 8027512:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8027516:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 0.0f; f->cB = f->R2; f->cH = 0.0f;
 802751a:	edc4 7a08 	vstr	s15, [r4, #32]
 802751e:	e794      	b.n	802744a <tVZFilter_setGain+0x102>
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 8027520:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 8027524:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
	_tVZFilter* f = *vf;
 8027528:	682d      	ldr	r5, [r5, #0]
  float fl = f->fc*powf(2.0f, -B*0.5f); // lower bandedge frequency (in Hz)
 802752a:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 802752e:	ee60 0aa7 	vmul.f32	s1, s1, s15
 8027532:	f003 feb1 	bl	802b298 <powf>
  float gl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 8027536:	f640 73db 	movw	r3, #4059	; 0xfdb
 802753a:	ed95 7a10 	vldr	s14, [r5, #64]	; 0x40
 802753e:	edd5 7a0a 	vldr	s15, [r5, #40]	; 0x28
 8027542:	f2c4 0349 	movt	r3, #16457	; 0x4049
 8027546:	ee67 7a87 	vmul.f32	s15, s15, s14
 802754a:	ee07 3a10 	vmov	s14, r3
 802754e:	ee67 7a87 	vmul.f32	s15, s15, s14
 8027552:	ee27 0a80 	vmul.f32	s0, s15, s0
 8027556:	f003 ffdd 	bl	802b514 <tanf>
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 802755a:	ed95 7a04 	vldr	s14, [r5, #16]
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 802755e:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027562:	2300      	movs	r3, #0
  float r  = gl/f->g;            // ratio between warped lower bandedge- and center-frequencies
 8027564:	ee80 0a07 	vdiv.f32	s0, s0, s14
			f->cL = 1.0f; f->cB = 0.0f; f->cH = 1.0f;
 8027568:	6223      	str	r3, [r4, #32]
 802756a:	edc4 7a07 	vstr	s15, [r4, #28]
 802756e:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
  return sqrtf((1.0f-r*r)*(1.0f-r*r)/(4.0f*r*r));
 8027572:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8027576:	ee20 0a00 	vmul.f32	s0, s0, s0
 802757a:	ee77 7ac0 	vsub.f32	s15, s15, s0
 802757e:	ee20 0a07 	vmul.f32	s0, s0, s14
 8027582:	ee67 7aa7 	vmul.f32	s15, s15, s15
 8027586:	ee87 7a80 	vdiv.f32	s14, s15, s0
 802758a:	eef1 7ac7 	vsqrt.f32	s15, s14
			f->R2 = 2.0f*tVZFilter_BandwidthToR(vf, f->B);
 802758e:	ee77 7aa7 	vadd.f32	s15, s15, s15
 8027592:	edc4 7a05 	vstr	s15, [r4, #20]
 8027596:	e758      	b.n	802744a <tVZFilter_setGain+0x102>
			float fl = f->fc*powf(2.0f, (-f->B)*0.5f); // lower bandedge frequency (in Hz)
 8027598:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 802759c:	edd4 0a0d 	vldr	s1, [r4, #52]	; 0x34
 80275a0:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 80275a4:	ee60 0aa7 	vmul.f32	s1, s1, s15
 80275a8:	f003 fe76 	bl	802b298 <powf>
			float wl = tanf(PI*fl*f->inv_sr);   // warped radian lower bandedge frequency /(2*fs)
 80275ac:	ee28 0a00 	vmul.f32	s0, s16, s0
 80275b0:	f003 ffb0 	bl	802b514 <tanf>
			float r  = f->g/wl;
 80275b4:	ee88 0a80 	vdiv.f32	s0, s17, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80275b8:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
 80275bc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80275c0:	eef0 5a00 	vmov.f32	s11, #0	; 0x40000000  2.0
 80275c4:	eef1 6a00 	vmov.f32	s13, #16	; 0x40800000  4.0
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 80275c8:	edc4 7a07 	vstr	s15, [r4, #28]
 80275cc:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80275d0:	ee67 6a26 	vmul.f32	s13, s14, s13
			r *= r;    // warped frequency ratio wu/wl == (wc/wl)^2 where wu is the
 80275d4:	ee20 0a00 	vmul.f32	s0, s0, s0
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80275d8:	eee0 7a00 	vfma.f32	s15, s0, s0
 80275dc:	ee87 6a80 	vdiv.f32	s12, s15, s0
 80275e0:	ee76 7a65 	vsub.f32	s15, s12, s11
 80275e4:	ee87 6aa6 	vdiv.f32	s12, s15, s13
 80275e8:	eef1 7ac6 	vsqrt.f32	s15, s12
 80275ec:	ee77 7aa7 	vadd.f32	s15, s15, s15
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 80275f0:	ee27 7a27 	vmul.f32	s14, s14, s15
			f->R2 = 2.0f*sqrtf(((r*r+1.0f)/r-2.0f)/(4.0f*f->G));
 80275f4:	edc4 7a05 	vstr	s15, [r4, #20]
			f->cL = 1.0f; f->cB = f->R2*f->G; f->cH = 1.0f;
 80275f8:	ed84 7a08 	vstr	s14, [r4, #32]
 80275fc:	e725      	b.n	802744a <tVZFilter_setGain+0x102>
			float A = sqrtf(f->G);
 80275fe:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8027602:	f247 2318 	movw	r3, #29208	; 0x7218
 8027606:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 802760a:	f04f 557e 	mov.w	r5, #1065353216	; 0x3f800000
			float A = sqrtf(f->G);
 802760e:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 8027612:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 8027616:	ee07 3a90 	vmov	s15, r3
 802761a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802761e:	eef1 7ac8 	vsqrt.f32	s15, s16
		  f->g /= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8027622:	eec8 8aa7 	vdiv.f32	s17, s17, s15
 8027626:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802762a:	f004 fa5d 	bl	802bae8 <sinhf>
 802762e:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8027632:	ed84 9a07 	vstr	s18, [r4, #28]
 8027636:	6265      	str	r5, [r4, #36]	; 0x24
 8027638:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2*sinhf(f->B*logf(2.0f)*0.5f);
 802763c:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = f->G; f->cB = f->R2*A; f->cH = 1.0f;
 8027640:	ed84 8a08 	vstr	s16, [r4, #32]
 8027644:	e701      	b.n	802744a <tVZFilter_setGain+0x102>
		  float A = sqrtf(f->G);
 8027646:	ed94 9a0b 	vldr	s18, [r4, #44]	; 0x2c
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802764a:	f247 2318 	movw	r3, #29208	; 0x7218
 802764e:	ed94 0a0d 	vldr	s0, [r4, #52]	; 0x34
		  float A = sqrtf(f->G);
 8027652:	eeb1 8ac9 	vsqrt.f32	s16, s18
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8027656:	f6c3 63b1 	movt	r3, #16049	; 0x3eb1
 802765a:	ee07 3a90 	vmov	s15, r3
 802765e:	ee20 0a27 	vmul.f32	s0, s0, s15
		  f->g *= sqrtf(A);               // scale SVF-cutoff frequency for shelvers
 8027662:	eef1 7ac8 	vsqrt.f32	s15, s16
 8027666:	ee68 8aa7 	vmul.f32	s17, s17, s15
 802766a:	edc4 8a04 	vstr	s17, [r4, #16]
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 802766e:	f004 fa3b 	bl	802bae8 <sinhf>
 8027672:	ee70 7a00 	vadd.f32	s15, s0, s0
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8027676:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
 802767a:	ed84 9a09 	vstr	s18, [r4, #36]	; 0x24
 802767e:	ee28 8a27 	vmul.f32	s16, s16, s15
		  f->R2 = 2.0f*sinhf(f->B*logf(2.0f)*0.5f);
 8027682:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cL = 1.0f; f->cB = f->R2*A; f->cH = f->G;
 8027686:	61e3      	str	r3, [r4, #28]
 8027688:	ed84 8a08 	vstr	s16, [r4, #32]
 802768c:	e6dd      	b.n	802744a <tVZFilter_setGain+0x102>
		  float x  = 2.0f*f->m-1.0f;
 802768e:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 8027692:	ed94 7a0e 	vldr	s14, [r4, #56]	; 0x38
 8027696:	eebf 8a00 	vmov.f32	s16, #240	; 0xbf800000 -1.0
			f->R2 = f->invG;
 802769a:	6b22      	ldr	r2, [r4, #48]	; 0x30
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 802769c:	2300      	movs	r3, #0
			f->R2 = f->invG;
 802769e:	6162      	str	r2, [r4, #20]
		  float x  = 2.0f*f->m-1.0f;
 80276a0:	eea7 8a27 	vfma.f32	s16, s14, s15
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80276a4:	ee00 3a90 	vmov	s1, r3
 80276a8:	eef1 8a48 	vneg.f32	s17, s16
 80276ac:	eeb0 0a68 	vmov.f32	s0, s17
 80276b0:	f000 fb7c 	bl	8027dac <maximum>
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80276b4:	2300      	movs	r3, #0
		  f->cL = maximum(-x, 0.0f); /*cL *= cL;*/
 80276b6:	ed84 0a07 	vstr	s0, [r4, #28]
		  f->cH = minimum( x, 0.0f); /*cH *= cH;*/
 80276ba:	eeb0 0a48 	vmov.f32	s0, s16
 80276be:	ee00 3a90 	vmov	s1, r3
 80276c2:	f000 fb77 	bl	8027db4 <minimum>
		  f->cB = 1.0f-x*x;
 80276c6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80276ca:	edd4 6a07 	vldr	s13, [r4, #28]
 80276ce:	edd4 7a05 	vldr	s15, [r4, #20]
		  f->cB = 1.0f-x*x;
 80276d2:	eea8 7a88 	vfma.f32	s14, s17, s16
		  float s = f->G * sqrtf((f->R2*f->R2) / (f->cL*f->cL + f->cB*f->cB + f->cH*f->cH - 2.0f*f->cL*f->cH));
 80276d6:	edd4 5a0b 	vldr	s11, [r4, #44]	; 0x2c
 80276da:	ee36 5aa6 	vadd.f32	s10, s13, s13
 80276de:	edd4 8a04 	vldr	s17, [r4, #16]
 80276e2:	ee67 4aa7 	vmul.f32	s9, s15, s15
 80276e6:	ee27 6a07 	vmul.f32	s12, s14, s14
 80276ea:	eea6 6aa6 	vfma.f32	s12, s13, s13
 80276ee:	eea0 6a00 	vfma.f32	s12, s0, s0
 80276f2:	eea0 6a45 	vfms.f32	s12, s0, s10
 80276f6:	ee84 5a86 	vdiv.f32	s10, s9, s12
 80276fa:	eeb1 6ac5 	vsqrt.f32	s12, s10
 80276fe:	ee26 6a25 	vmul.f32	s12, s12, s11
		  f->cL *= s; f->cB *= s; f->cH *= s;
 8027702:	ee66 6a86 	vmul.f32	s13, s13, s12
 8027706:	ee27 7a06 	vmul.f32	s14, s14, s12
 802770a:	ee20 0a06 	vmul.f32	s0, s0, s12
 802770e:	edc4 6a07 	vstr	s13, [r4, #28]
 8027712:	ed84 7a08 	vstr	s14, [r4, #32]
 8027716:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
 802771a:	e696      	b.n	802744a <tVZFilter_setGain+0x102>
		  f->cL = 1.0f;
 802771c:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8027720:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
		  f->cL = 1.0f;
 8027724:	61e3      	str	r3, [r4, #28]
		  f->R2 = f->invG;  // can we use an arbitrary value here, for example R2 = 1?
 8027726:	edc4 7a05 	vstr	s15, [r4, #20]
		  f->cH = 1.0f;
 802772a:	6263      	str	r3, [r4, #36]	; 0x24
		  f->cB = f->R2;
 802772c:	edc4 7a08 	vstr	s15, [r4, #32]
 8027730:	e68b      	b.n	802744a <tVZFilter_setGain+0x102>
 8027732:	edd4 7a05 	vldr	s15, [r4, #20]
 8027736:	e688      	b.n	802744a <tVZFilter_setGain+0x102>

08027738 <interpolate3max>:
    return(Y);
}

float interpolate3max(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
 8027738:	f64f 73ff 	movw	r3, #65535	; 0xffff
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float realpeak;
    
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
 802773c:	eeb0 5a00 	vmov.f32	s10, #0	; 0x40000000  2.0
 8027740:	eef4 5a00 	vmov.f32	s11, #64	; 0x3e000000  0.125
    float a = buf[peakindex-1];
 8027744:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
 8027748:	440b      	add	r3, r1
 802774a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 802774e:	edd0 7a00 	vldr	s15, [r0]
    float c = buf[peakindex+1];
 8027752:	ed90 6a02 	vldr	s12, [r0, #8]
    float b = buf[peakindex];
 8027756:	edd0 6a01 	vldr	s13, [r0, #4]
    realpeak = b + (float)0.125 * (c - a) * (c - a) / ((float)2. * b - a - c);
 802775a:	ee36 7a67 	vsub.f32	s14, s12, s15
 802775e:	eed6 7a85 	vfnms.f32	s15, s13, s10
 8027762:	ee27 7a07 	vmul.f32	s14, s14, s14
 8027766:	ee27 7a25 	vmul.f32	s14, s14, s11
 802776a:	ee77 7ac6 	vsub.f32	s15, s15, s12
 802776e:	ee87 0a27 	vdiv.f32	s0, s14, s15
    
    return(realpeak);
}
 8027772:	ee30 0a26 	vadd.f32	s0, s0, s13
 8027776:	4770      	bx	lr

08027778 <interpolate3phase>:

float interpolate3phase(float *buf, const int peakindex)
{
    float a = buf[peakindex-1];
 8027778:	f64f 73ff 	movw	r3, #65535	; 0xffff
    float b = buf[peakindex];
    float c = buf[peakindex+1];
    float fraction;
    
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 802777c:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8027780:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
    float a = buf[peakindex-1];
 8027784:	f6c3 73ff 	movt	r3, #16383	; 0x3fff
 8027788:	440b      	add	r3, r1
 802778a:	eb00 0083 	add.w	r0, r0, r3, lsl #2
 802778e:	edd0 7a00 	vldr	s15, [r0]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 8027792:	edd0 5a01 	vldr	s11, [r0, #4]
 8027796:	eeb0 0a67 	vmov.f32	s0, s15
    float c = buf[peakindex+1];
 802779a:	ed90 7a02 	vldr	s14, [r0, #8]
    fraction = ((float)0.5 * (c - a)) / ((float)2. * b - a - c);
 802779e:	ee77 7a67 	vsub.f32	s15, s14, s15
 80277a2:	ee95 0a86 	vfnms.f32	s0, s11, s12
 80277a6:	ee67 7aa6 	vmul.f32	s15, s15, s13
 80277aa:	ee30 0a47 	vsub.f32	s0, s0, s14
    
    return(fraction);
}
 80277ae:	ee87 0a80 	vdiv.f32	s0, s15, s0
 80277b2:	4770      	bx	lr

080277b4 <fastercosf>:
float fastercosf(float fAngle)
{
    float fASqr = fAngle*fAngle;
    float fResult = 3.705e-02f;
    fResult *= fASqr;
    fResult -= 4.967e-01f;
 80277b4:	f24c 12be 	movw	r2, #49598	; 0xc1be
 80277b8:	f644 7376 	movw	r3, #20342	; 0x4f76
    float fASqr = fAngle*fAngle;
 80277bc:	ee60 6a00 	vmul.f32	s13, s0, s0
    fResult -= 4.967e-01f;
 80277c0:	f6c3 5217 	movt	r2, #15639	; 0x3d17
 80277c4:	f6cb 63fe 	movt	r3, #48894	; 0xbefe
    fResult *= fASqr;
    fResult += 1.0f;
 80277c8:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    fResult -= 4.967e-01f;
 80277cc:	ee07 2a10 	vmov	s14, r2
 80277d0:	ee07 3a90 	vmov	s15, r3
 80277d4:	eee6 7a87 	vfma.f32	s15, s13, s14
    return fResult;
}
 80277d8:	eea6 0aa7 	vfma.f32	s0, s13, s15
 80277dc:	4770      	bx	lr
 80277de:	bf00      	nop

080277e0 <fastabsf>:
        unsigned int ui;
    }alias;
    
    alias.f = f;
    alias.ui &= 0x7fffffff;
    return alias.f;
 80277e0:	ee10 3a10 	vmov	r3, s0
 80277e4:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
}
 80277e8:	ee00 3a10 	vmov	s0, r3
 80277ec:	4770      	bx	lr
 80277ee:	bf00      	nop

080277f0 <fastexp2f>:

// fast floating-point exp2 function taken from Robert Bristow Johnson's
// post in the music-dsp list on Date: Tue, 02 Sep 2014 16:50:11 -0400
float fastexp2f(float x)
{
    if (x >= -127.0)
 80277f0:	2300      	movs	r3, #0
 80277f2:	f2cc 23fe 	movt	r3, #49918	; 0xc2fe
 80277f6:	ee07 3a90 	vmov	s15, r3
 80277fa:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80277fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027802:	db44      	blt.n	802788e <fastexp2f+0x9e>
    {
        float accumulator, xPower;
        union {float f; int32_t i;} xBits;
        
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8027804:	f04f 438b 	mov.w	r3, #1166016512	; 0x45800000
        xPower = x*x;
        accumulator += 0.24137976293709f*xPower;
        xPower *= x;
        accumulator += 0.05203236900844f*xPower;
        xPower *= x;
        accumulator += 0.01355574723481f*xPower;
 8027808:	f642 4242 	movw	r2, #11330	; 0x2c42
 802780c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8027810:	f641 71e5 	movw	r1, #8165	; 0x1fe5
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8027814:	ee07 3a10 	vmov	s14, r3
        accumulator += 0.01355574723481f*xPower;
 8027818:	f6c3 6277 	movt	r2, #15991	; 0x3e77
 802781c:	f641 00ed 	movw	r0, #6381	; 0x18ed
 8027820:	f6c3 5155 	movt	r1, #15701	; 0x3d55
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8027824:	ee30 7a07 	vadd.f32	s14, s0, s14
        accumulator += 0.01355574723481f*xPower;
 8027828:	ee04 2a90 	vmov	s9, r2
 802782c:	f646 228e 	movw	r2, #27278	; 0x6a8e
 8027830:	f6c3 405e 	movt	r0, #15454	; 0x3c5e
 8027834:	ee05 1a90 	vmov	s11, r1
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8027838:	eebd 7ac7 	vcvt.s32.f32	s14, s14
        accumulator += 0.01355574723481f*xPower;
 802783c:	f6c3 7231 	movt	r2, #16177	; 0x3f31
 8027840:	ee05 0a10 	vmov	s10, r0
 8027844:	ee06 2a90 	vmov	s13, r2
        xBits.i = (int32_t)(x + 4096.0f) - 4096L;               /* integer part */
 8027848:	ee17 3a10 	vmov	r3, s14
 802784c:	f5a3 5280 	sub.w	r2, r3, #4096	; 0x1000
 8027850:	ee07 2a10 	vmov	s14, r2
        
        xBits.i += 127;                                                    /* bias integer part */
 8027854:	f46f 6278 	mvn.w	r2, #3968	; 0xf80
        x -= (float)(xBits.i);                                             /* fractional part */
 8027858:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
        xBits.i += 127;                                                    /* bias integer part */
 802785c:	4413      	add	r3, r2
        xBits.i<<= 23;                                                     /* move biased int part into exponent bits */
 802785e:	05db      	lsls	r3, r3, #23
        x -= (float)(xBits.i);                                             /* fractional part */
 8027860:	ee30 7a47 	vsub.f32	s14, s0, s14
        xPower = x*x;
 8027864:	ee27 6a07 	vmul.f32	s12, s14, s14
        accumulator += 0.01355574723481f*xPower;
 8027868:	eee6 7a24 	vfma.f32	s15, s12, s9
        xPower *= x;
 802786c:	ee27 6a06 	vmul.f32	s12, s14, s12
        accumulator += 0.01355574723481f*xPower;
 8027870:	eeb0 0a67 	vmov.f32	s0, s15
 8027874:	eef0 7a66 	vmov.f32	s15, s13
 8027878:	eea6 0a25 	vfma.f32	s0, s12, s11
 802787c:	eee6 7a05 	vfma.f32	s15, s12, s10
 8027880:	eea7 0a27 	vfma.f32	s0, s14, s15
        
        return accumulator * xBits.f;
 8027884:	ee07 3a10 	vmov	s14, r3
 8027888:	ee20 0a07 	vmul.f32	s0, s0, s14
 802788c:	4770      	bx	lr
    }
    else
    {
        return 0.0f;
 802788e:	2300      	movs	r3, #0
 8027890:	ee00 3a10 	vmov	s0, r3
    }
}
 8027894:	4770      	bx	lr
 8027896:	bf00      	nop

08027898 <LEAF_crossfade>:
 when t = 0, volumes[0] = 0.707, volumes[1] = 0.707 (equal-power cross fade)
 when t = 1, volumes[0] = 1, volumes[1] = 0
 */

void LEAF_crossfade(float fade, float* volumes) {
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 8027898:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802789c:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 80278a0:	ee30 7a27 	vadd.f32	s14, s0, s15
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 80278a4:	ee77 7ac0 	vsub.f32	s15, s15, s0
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 80278a8:	ee27 7a26 	vmul.f32	s14, s14, s13
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 80278ac:	ee67 7aa6 	vmul.f32	s15, s15, s13
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 80278b0:	eef1 6ac7 	vsqrt.f32	s13, s14
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 80278b4:	eeb1 7ae7 	vsqrt.f32	s14, s15
    volumes[0] = sqrtf(0.5f * (1.0f + fade));
 80278b8:	edc0 6a00 	vstr	s13, [r0]
    volumes[1] = sqrtf(0.5f * (1.0f - fade));
 80278bc:	ed80 7a01 	vstr	s14, [r0, #4]
}
 80278c0:	4770      	bx	lr
 80278c2:	bf00      	nop

080278c4 <LEAF_frequencyToMidi>:
    return out / amp ;
}
#endif

float LEAF_frequencyToMidi(float f)
{
 80278c4:	b508      	push	{r3, lr}
    return (69.0f + 12.0f * log2f(f * INV_440));
 80278c6:	f24f 2309 	movw	r3, #61961	; 0xf209
 80278ca:	f6c3 3314 	movt	r3, #15124	; 0x3b14
 80278ce:	ee07 3a90 	vmov	s15, r3
 80278d2:	ee20 0a27 	vmul.f32	s0, s0, s15
 80278d6:	f003 fc5f 	bl	802b198 <log2f>
 80278da:	2300      	movs	r3, #0
 80278dc:	eeb2 7a08 	vmov.f32	s14, #40	; 0x41400000  12.0
 80278e0:	f2c4 238a 	movt	r3, #17034	; 0x428a
 80278e4:	ee07 3a90 	vmov	s15, r3
}
 80278e8:	eee0 7a07 	vfma.f32	s15, s0, s14
 80278ec:	eeb0 0a67 	vmov.f32	s0, s15
 80278f0:	bd08      	pop	{r3, pc}
 80278f2:	bf00      	nop

080278f4 <LEAF_shaper>:

// Jones shaper
float LEAF_shaper(float input, float m_drive)
{
 80278f4:	f240 43f3 	movw	r3, #1267	; 0x4f3
    float fx = input * 2.0f;    // prescale
 80278f8:	ee30 0a00 	vadd.f32	s0, s0, s0
    
    xc = LEAF_clip(-SQRT8, fx, SQRT8);
    xc2 = xc*xc;
    c = 0.5f*fx*(3.0f - (xc2));
    xc4 = xc2 * xc2;
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 80278fc:	eeb5 7a00 	vmov.f32	s14, #80	; 0x3e800000  0.250
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8027900:	f64c 42cd 	movw	r2, #52429	; 0xcccd
 8027904:	4619      	mov	r1, r3
 8027906:	f2c4 0335 	movt	r3, #16437	; 0x4035
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 802790a:	f04f 5072 	mov.w	r0, #1015021568	; 0x3c800000
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 802790e:	f6c3 524c 	movt	r2, #15692	; 0x3d4c
 8027912:	f2cc 0135 	movt	r1, #49205	; 0xc035
 8027916:	ee07 3a90 	vmov	s15, r3
 802791a:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 802791e:	ee05 2a10 	vmov	s10, r2
 8027922:	ee06 1a90 	vmov	s13, r1
 8027926:	fec0 7a67 	vminnm.f32	s15, s0, s15
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 802792a:	ee04 0a10 	vmov	s8, r0
    shaperOut *= 0.5f;    // post_scale
 802792e:	f642 7305 	movw	r3, #12037	; 0x2f05
 8027932:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
    xc2 = xc*xc;
 8027936:	ee67 7aa7 	vmul.f32	s15, s15, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 802793a:	ee60 5a25 	vmul.f32	s11, s0, s11
    shaperOut *= 0.5f;    // post_scale
 802793e:	f6c3 7327 	movt	r3, #16167	; 0x3f27
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8027942:	eef6 6a08 	vmov.f32	s13, #104	; 0x3f400000  0.750
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 8027946:	ee67 3aa7 	vmul.f32	s7, s15, s15
    shaperOut *= 0.5f;    // post_scale
 802794a:	ee06 3a10 	vmov	s12, r3
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 802794e:	ee27 7a67 	vnmul.f32	s14, s14, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8027952:	ee27 0a85 	vmul.f32	s0, s15, s10
    c = 0.5f*fx*(3.0f - (xc2));
 8027956:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 802795a:	eea3 7a84 	vfma.f32	s14, s7, s8
 802795e:	eeb7 5a00 	vmov.f32	s10, #112	; 0x3f800000  1.0
    c = 0.5f*fx*(3.0f - (xc2));
 8027962:	ee74 4ae7 	vsub.f32	s9, s9, s15
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8027966:	ee70 0aa6 	vadd.f32	s1, s1, s13
 802796a:	eef0 7a40 	vmov.f32	s15, s0
    w = (1.0f - xc2*0.25f + xc4*0.015625f) * WSCALE;
 802796e:	ee37 7a05 	vadd.f32	s14, s14, s10
    float shaperOut = w*(c+ 0.05f*xc2)*(m_drive + 0.75f);
 8027972:	eee4 7aa5 	vfma.f32	s15, s9, s11
    shaperOut *= 0.5f;    // post_scale
 8027976:	ee20 0a86 	vmul.f32	s0, s1, s12
 802797a:	ee27 0a00 	vmul.f32	s0, s14, s0
    return shaperOut;
}
 802797e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8027982:	4770      	bx	lr

08027984 <LEAF_round>:
// round input to nearest rnd
float LEAF_round (float input, float rnd)
{
    rnd = fabsf(rnd);
    
    if (rnd <= 0.0000001f) return input;
 8027984:	f64b 7395 	movw	r3, #49045	; 0xbf95
    rnd = fabsf(rnd);
 8027988:	eef0 0ae0 	vabs.f32	s1, s1
    if (rnd <= 0.0000001f) return input;
 802798c:	f2c3 33d6 	movt	r3, #13270	; 0x33d6
 8027990:	ee07 3a90 	vmov	s15, r3
 8027994:	eef4 0ae7 	vcmpe.f32	s1, s15
 8027998:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802799c:	d905      	bls.n	80279aa <LEAF_round+0x26>
    
    float scale = 1.f / rnd;
    
    return roundf(input * scale) / scale;
 802799e:	eec0 7a20 	vdiv.f32	s15, s0, s1
 80279a2:	feb8 0a67 	vrinta.f32	s0, s15
 80279a6:	ee20 0a20 	vmul.f32	s0, s0, s1
}
 80279aa:	4770      	bx	lr

080279ac <LEAF_bitwise_xor>:
{
    union unholy_t unholy;
    unholy.f = input;
    unholy.i = (unholy.i ^ op);
    
    return unholy.f;
 80279ac:	ee10 3a10 	vmov	r3, s0
 80279b0:	4058      	eors	r0, r3
}
 80279b2:	ee00 0a10 	vmov	s0, r0
 80279b6:	4770      	bx	lr

080279b8 <LEAF_clip>:

float   LEAF_clip(float min, float val, float max)
{
    float tempmin = min;
    float tempmax = max;
    if (min > max)
 80279b8:	eeb4 0ac1 	vcmpe.f32	s0, s2
 80279bc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279c0:	dd05      	ble.n	80279ce <LEAF_clip+0x16>
 80279c2:	eef0 7a40 	vmov.f32	s15, s0
    {
        tempmin = max;
 80279c6:	eeb0 0a41 	vmov.f32	s0, s2
        tempmax = min;
 80279ca:	eeb0 1a67 	vmov.f32	s2, s15
    }
    if (val < tempmin)
 80279ce:	eeb4 0ae0 	vcmpe.f32	s0, s1
 80279d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80279d6:	dc01      	bgt.n	80279dc <LEAF_clip+0x24>
 80279d8:	fe81 0a60 	vminnm.f32	s0, s2, s1
    }
    else
    {
        return val;
    }
}
 80279dc:	4770      	bx	lr
 80279de:	bf00      	nop

080279e0 <LEAF_clipInt>:

int   LEAF_clipInt(int min, int val, int max)
{
    int tempmin = min;
    int tempmax = max;
    if (min > max)
 80279e0:	4290      	cmp	r0, r2
 80279e2:	dd02      	ble.n	80279ea <LEAF_clipInt+0xa>
 80279e4:	4603      	mov	r3, r0
 80279e6:	4610      	mov	r0, r2
 80279e8:	461a      	mov	r2, r3
    {
        tempmin = max;
        tempmax = min;
    }
    if (val < tempmin) {
 80279ea:	4288      	cmp	r0, r1
 80279ec:	dc03      	bgt.n	80279f6 <LEAF_clipInt+0x16>
 80279ee:	428a      	cmp	r2, r1
 80279f0:	bfa8      	it	ge
 80279f2:	460a      	movge	r2, r1
 80279f4:	4610      	mov	r0, r2
    } else if (val > tempmax) {
        return tempmax;
    } else {
        return val;
    }
}
 80279f6:	4770      	bx	lr

080279f8 <LEAF_isPrime>:

int     LEAF_isPrime(uint64_t number )
{
    if ( number == 2 ) return 1;
 80279f8:	2900      	cmp	r1, #0
 80279fa:	bf08      	it	eq
 80279fc:	2802      	cmpeq	r0, #2
 80279fe:	d02a      	beq.n	8027a56 <LEAF_isPrime+0x5e>
    if ( number & 1 ) {
 8027a00:	f000 0201 	and.w	r2, r0, #1
 8027a04:	2300      	movs	r3, #0
 8027a06:	4313      	orrs	r3, r2
{
 8027a08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8027a0c:	4606      	mov	r6, r0
    if ( number & 1 ) {
 8027a0e:	d01f      	beq.n	8027a50 <LEAF_isPrime+0x58>
 8027a10:	460f      	mov	r7, r1
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8027a12:	f7d8 fdef 	bl	80005f4 <__aeabi_ul2d>
 8027a16:	2403      	movs	r4, #3
 8027a18:	2500      	movs	r5, #0
 8027a1a:	ec41 0b17 	vmov	d7, r0, r1
 8027a1e:	eeb1 7bc7 	vsqrt.f64	d7, d7
 8027a22:	eefd 7bc7 	vcvt.s32.f64	s15, d7
 8027a26:	ee17 8a90 	vmov	r8, s15
 8027a2a:	f108 0801 	add.w	r8, r8, #1
 8027a2e:	e006      	b.n	8027a3e <LEAF_isPrime+0x46>
            if ( (number % i) == 0 ) return 0;
 8027a30:	f7d8 fe16 	bl	8000660 <__aeabi_uldivmod>
 8027a34:	3402      	adds	r4, #2
 8027a36:	f145 0500 	adc.w	r5, r5, #0
 8027a3a:	4313      	orrs	r3, r2
 8027a3c:	d008      	beq.n	8027a50 <LEAF_isPrime+0x58>
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8027a3e:	45a0      	cmp	r8, r4
            if ( (number % i) == 0 ) return 0;
 8027a40:	4622      	mov	r2, r4
 8027a42:	462b      	mov	r3, r5
 8027a44:	4630      	mov	r0, r6
 8027a46:	4639      	mov	r1, r7
        for ( int i=3; i<(int)sqrt((double)number)+1; i+=2 )
 8027a48:	dcf2      	bgt.n	8027a30 <LEAF_isPrime+0x38>
    if ( number == 2 ) return 1;
 8027a4a:	2001      	movs	r0, #1
        return 1; // prime
    }
    else return 0; // even
}
 8027a4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else return 0; // even
 8027a50:	2000      	movs	r0, #0
}
 8027a52:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ( number == 2 ) return 1;
 8027a56:	2001      	movs	r0, #1
}
 8027a58:	4770      	bx	lr
 8027a5a:	bf00      	nop

08027a5c <LEAF_tanh>:

// Adapted from MusicDSP: http://www.musicdsp.org/showone.php?id=238
float LEAF_tanh(float x)
{
    
    if( x < -3.0f )
 8027a5c:	eef8 7a08 	vmov.f32	s15, #136	; 0xc0400000 -3.0
 8027a60:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8027a64:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027a68:	d418      	bmi.n	8027a9c <LEAF_tanh+0x40>
        return -1.0f;
    else if( x > 3.0f )
 8027a6a:	eef0 7a08 	vmov.f32	s15, #8	; 0x40400000  3.0
 8027a6e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8027a72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027a76:	dc0e      	bgt.n	8027a96 <LEAF_tanh+0x3a>
        return 1.0f;
    else
        return x * ( 27.0f + x * x ) / ( 27.0f + 9.0f * x * x );
 8027a78:	ee60 6a00 	vmul.f32	s13, s0, s0
 8027a7c:	eef3 7a0b 	vmov.f32	s15, #59	; 0x41d80000  27.0
 8027a80:	eeb2 6a02 	vmov.f32	s12, #34	; 0x41100000  9.0
 8027a84:	ee36 7aa7 	vadd.f32	s14, s13, s15
 8027a88:	eee6 7a86 	vfma.f32	s15, s13, s12
 8027a8c:	ee27 7a00 	vmul.f32	s14, s14, s0
 8027a90:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8027a94:	4770      	bx	lr
        return 1.0f;
 8027a96:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
}
 8027a9a:	4770      	bx	lr
        return -1.0f;
 8027a9c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 8027aa0:	4770      	bx	lr
 8027aa2:	bf00      	nop

08027aa4 <LEAF_generate_exp>:


//0.001 base gives a good curve that goes from 1 to near zero
void LEAF_generate_exp(float* buffer, float base, float start, float end, float offset, int size)
{
	float increment = (end - start) / (float)size;
 8027aa4:	ee07 1a90 	vmov	s15, r1
 8027aa8:	ee31 1a60 	vsub.f32	s2, s2, s1
	float x = start;
	for (int i = 0; i < size; i++)
 8027aac:	2900      	cmp	r1, #0
	float increment = (end - start) / (float)size;
 8027aae:	eef8 7ae7 	vcvt.f32.s32	s15, s15
{
 8027ab2:	b538      	push	{r3, r4, r5, lr}
 8027ab4:	ed2d 8b04 	vpush	{d8-d9}
	float increment = (end - start) / (float)size;
 8027ab8:	eec1 8a27 	vdiv.f32	s17, s2, s15
	for (int i = 0; i < size; i++)
 8027abc:	dd16      	ble.n	8027aec <LEAF_generate_exp+0x48>
 8027abe:	4604      	mov	r4, r0
 8027ac0:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8027ac4:	eeb0 8a60 	vmov.f32	s16, s1
 8027ac8:	eeb0 9a40 	vmov.f32	s18, s0
 8027acc:	eef0 9a61 	vmov.f32	s19, s3
	{
		buffer[i] = powf(base, x) + offset;
 8027ad0:	eef0 0a48 	vmov.f32	s1, s16
 8027ad4:	eeb0 0a49 	vmov.f32	s0, s18
 8027ad8:	f003 fbde 	bl	802b298 <powf>
 8027adc:	ee30 0a29 	vadd.f32	s0, s0, s19
		x += increment;
 8027ae0:	ee38 8a28 	vadd.f32	s16, s16, s17
		buffer[i] = powf(base, x) + offset;
 8027ae4:	eca4 0a01 	vstmia	r4!, {s0}
	for (int i = 0; i < size; i++)
 8027ae8:	42a5      	cmp	r5, r4
 8027aea:	d1f1      	bne.n	8027ad0 <LEAF_generate_exp+0x2c>
    }
}
 8027aec:	ecbd 8b04 	vpop	{d8-d9}
 8027af0:	bd38      	pop	{r3, r4, r5, pc}
 8027af2:	bf00      	nop

08027af4 <LEAF_generate_atodbPositiveClipped>:
    }
}


void LEAF_generate_atodbPositiveClipped(float* buffer, float lowerThreshold, float range, int size)
{
 8027af4:	b538      	push	{r3, r4, r5, lr}
    alias.ui &= 0x7fffffff;
 8027af6:	ee10 3a10 	vmov	r3, s0
    float increment = 1.0f / (float)size;
 8027afa:	ee07 1a90 	vmov	s15, r1
 8027afe:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
    float x = 0.0f;
    float scalar = range / fastabsf(lowerThreshold);
    for (int i = 0; i < size; i++)
 8027b02:	2900      	cmp	r1, #0
    alias.ui &= 0x7fffffff;
 8027b04:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    float increment = 1.0f / (float)size;
 8027b08:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    float scalar = range / fastabsf(lowerThreshold);
 8027b0c:	ee06 3a90 	vmov	s13, r3
{
 8027b10:	ed2d 8b08 	vpush	{d8-d11}
    float scalar = range / fastabsf(lowerThreshold);
 8027b14:	eec0 9aa6 	vdiv.f32	s19, s1, s13
    float increment = 1.0f / (float)size;
 8027b18:	eec7 aa27 	vdiv.f32	s21, s14, s15
    for (int i = 0; i < size; i++)
 8027b1c:	dd2a      	ble.n	8027b74 <LEAF_generate_atodbPositiveClipped+0x80>
 8027b1e:	2300      	movs	r3, #0
 8027b20:	4604      	mov	r4, r0
 8027b22:	eb00 0581 	add.w	r5, r0, r1, lsl #2
 8027b26:	ee09 3a10 	vmov	s18, r3
    float x = 0.0f;
 8027b2a:	ee08 3a10 	vmov	s16, r3
 8027b2e:	fe80 aa49 	vminnm.f32	s20, s0, s18
    {
        float temp = atodb(x);
        temp = LEAF_clip(lowerThreshold, temp, 0.0f);
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b32:	ee7a ba40 	vsub.f32	s23, s20, s0
 8027b36:	eef0 8a40 	vmov.f32	s17, s0
 8027b3a:	fe80 9a09 	vmaxnm.f32	s18, s0, s18
}


float atodb(float a)
{
    return 20.0f*log10f(a);
 8027b3e:	eeb3 ba04 	vmov.f32	s22, #52	; 0x41a00000  20.0
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b42:	ee6b baa9 	vmul.f32	s23, s23, s19
    return 20.0f*log10f(a);
 8027b46:	eeb0 0a48 	vmov.f32	s0, s16
 8027b4a:	f003 ff59 	bl	802ba00 <log10f>
 8027b4e:	ee20 0a0b 	vmul.f32	s0, s0, s22
    if (val < tempmin)
 8027b52:	eeb4 aac0 	vcmpe.f32	s20, s0
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b56:	fec9 7a40 	vminnm.f32	s15, s18, s0
 8027b5a:	ee77 7ae8 	vsub.f32	s15, s15, s17
    if (val < tempmin)
 8027b5e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b62:	ee67 7aa9 	vmul.f32	s15, s15, s19
    if (val < tempmin)
 8027b66:	dc08      	bgt.n	8027b7a <LEAF_generate_atodbPositiveClipped+0x86>
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b68:	ece4 7a01 	vstmia	r4!, {s15}
    for (int i = 0; i < size; i++)
 8027b6c:	42ac      	cmp	r4, r5
        x += increment;
 8027b6e:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
 8027b72:	d1e8      	bne.n	8027b46 <LEAF_generate_atodbPositiveClipped+0x52>
}
 8027b74:	ecbd 8b08 	vpop	{d8-d11}
 8027b78:	bd38      	pop	{r3, r4, r5, pc}
        buffer[i] = (temp-lowerThreshold) * scalar;
 8027b7a:	ece4 ba01 	vstmia	r4!, {s23}
    for (int i = 0; i < size; i++)
 8027b7e:	42a5      	cmp	r5, r4
        x += increment;
 8027b80:	ee38 8a2a 	vadd.f32	s16, s16, s21
    for (int i = 0; i < size; i++)
 8027b84:	d1df      	bne.n	8027b46 <LEAF_generate_atodbPositiveClipped+0x52>
}
 8027b86:	ecbd 8b08 	vpop	{d8-d11}
 8027b8a:	bd38      	pop	{r3, r4, r5, pc}

08027b8c <LEAF_midiToFrequency>:
{
 8027b8c:	b508      	push	{r3, lr}
    if( f <= -1500.0f ) return (0);
 8027b8e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8027b92:	f2cc 43bb 	movt	r3, #50363	; 0xc4bb
 8027b96:	ee07 3a90 	vmov	s15, r3
 8027b9a:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8027b9e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027ba2:	d924      	bls.n	8027bee <LEAF_midiToFrequency+0x62>
    else return ( powf(2.0f, (f - 69.0f) * 0.083333333333333f) * 440.0f );
 8027ba4:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
 8027ba8:	2200      	movs	r2, #0
 8027baa:	eef0 7a40 	vmov.f32	s15, s0
 8027bae:	f64a 23ab 	movw	r3, #43691	; 0xaaab
 8027bb2:	f2c4 41bb 	movt	r1, #17595	; 0x44bb
 8027bb6:	f2c4 228a 	movt	r2, #17034	; 0x428a
 8027bba:	f6c3 53aa 	movt	r3, #15786	; 0x3daa
 8027bbe:	eeb0 0a00 	vmov.f32	s0, #0	; 0x40000000  2.0
 8027bc2:	ee06 1a90 	vmov	s13, r1
 8027bc6:	ee07 2a10 	vmov	s14, r2
 8027bca:	ee00 3a90 	vmov	s1, r3
 8027bce:	fec7 7ae6 	vminnm.f32	s15, s15, s13
 8027bd2:	ee77 7ac7 	vsub.f32	s15, s15, s14
 8027bd6:	ee67 0aa0 	vmul.f32	s1, s15, s1
 8027bda:	f003 fb5d 	bl	802b298 <powf>
 8027bde:	2300      	movs	r3, #0
 8027be0:	f2c4 33dc 	movt	r3, #17372	; 0x43dc
 8027be4:	ee07 3a90 	vmov	s15, r3
 8027be8:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8027bec:	bd08      	pop	{r3, pc}
    if( f <= -1500.0f ) return (0);
 8027bee:	2300      	movs	r3, #0
 8027bf0:	ee00 3a10 	vmov	s0, r3
}
 8027bf4:	bd08      	pop	{r3, pc}
 8027bf6:	bf00      	nop

08027bf8 <LEAF_interpolate_hermite_x>:
    float y0my1 = yy0 - yy1;
 8027bf8:	ee70 7a60 	vsub.f32	s15, s0, s1
    float c1 = 0.5f * (yy2 - yy0);
 8027bfc:	ee31 7a40 	vsub.f32	s14, s2, s0
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
 8027c00:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 8027c04:	ee71 1ae7 	vsub.f32	s3, s3, s15
 8027c08:	ee70 6ac1 	vsub.f32	s13, s1, s2
    float c2 = y0my1 + c1 - c3;
 8027c0c:	eee7 7a06 	vfma.f32	s15, s14, s12
    float c3 = (yy1 - yy2) + 0.5f * (yy3 - y0my1 - yy2);
 8027c10:	ee31 1ac1 	vsub.f32	s2, s3, s2
 8027c14:	eee1 6a06 	vfma.f32	s13, s2, s12
    float c2 = y0my1 + c1 - c3;
 8027c18:	ee77 7ae6 	vsub.f32	s15, s15, s13
    return ((c3 * xx + c2) * xx + c1) * xx + c0;
 8027c1c:	eee6 7a82 	vfma.f32	s15, s13, s4
 8027c20:	ee67 7a82 	vmul.f32	s15, s15, s4
 8027c24:	eee7 7a06 	vfma.f32	s15, s14, s12
}
 8027c28:	eee7 0a82 	vfma.f32	s1, s15, s4
 8027c2c:	eeb0 0a60 	vmov.f32	s0, s1
 8027c30:	4770      	bx	lr
 8027c32:	bf00      	nop

08027c34 <LEAF_interpolation_linear>:
{
 8027c34:	2300      	movs	r3, #0
 8027c36:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8027c3a:	ee07 3a10 	vmov	s14, r3
 8027c3e:	fe81 1a67 	vminnm.f32	s2, s2, s15
 8027c42:	fe81 1a07 	vmaxnm.f32	s2, s2, s14
    float omAlpha = 1.0f - alpha;
 8027c46:	ee77 7ac1 	vsub.f32	s15, s15, s2
    out += B * alpha;
 8027c4a:	ee20 1a81 	vmul.f32	s2, s1, s2
}
 8027c4e:	eea7 1a80 	vfma.f32	s2, s15, s0
 8027c52:	eeb0 0a41 	vmov.f32	s0, s2
 8027c56:	4770      	bx	lr

08027c58 <mtof>:
{
 8027c58:	b508      	push	{r3, lr}
    if (f <= -1500.0f) return(0);
 8027c5a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 8027c5e:	f2cc 43bb 	movt	r3, #50363	; 0xc4bb
 8027c62:	ee07 3a90 	vmov	s15, r3
 8027c66:	eeb4 0ae7 	vcmpe.f32	s0, s15
 8027c6a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027c6e:	d91a      	bls.n	8027ca6 <mtof+0x4e>
    else return (8.17579891564f * expf(0.0577622650f * f));
 8027c70:	f44f 42c0 	mov.w	r2, #24576	; 0x6000
 8027c74:	f649 0320 	movw	r3, #38944	; 0x9820
 8027c78:	f2c4 42bb 	movt	r2, #17595	; 0x44bb
 8027c7c:	f6c3 536c 	movt	r3, #15724	; 0x3d6c
 8027c80:	ee07 2a10 	vmov	s14, r2
 8027c84:	ee07 3a90 	vmov	s15, r3
 8027c88:	fe80 0a47 	vminnm.f32	s0, s0, s14
 8027c8c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8027c90:	f003 f994 	bl	802afbc <expf>
 8027c94:	f24d 0313 	movw	r3, #53267	; 0xd013
 8027c98:	f2c4 1302 	movt	r3, #16642	; 0x4102
 8027c9c:	ee07 3a90 	vmov	s15, r3
 8027ca0:	ee20 0a27 	vmul.f32	s0, s0, s15
}
 8027ca4:	bd08      	pop	{r3, pc}
    if (f <= -1500.0f) return(0);
 8027ca6:	2300      	movs	r3, #0
 8027ca8:	ee00 3a10 	vmov	s0, r3
}
 8027cac:	bd08      	pop	{r3, pc}
 8027cae:	bf00      	nop

08027cb0 <faster_mtof>:
 8027cb0:	f649 0220 	movw	r2, #38944	; 0x9820
 8027cb4:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8027cb8:	f24d 0313 	movw	r3, #53267	; 0xd013
 8027cbc:	f6c3 026c 	movt	r2, #14444	; 0x386c
 8027cc0:	f2c4 1302 	movt	r3, #16642	; 0x4102
 8027cc4:	ee06 2a90 	vmov	s13, r2
 8027cc8:	ee07 3a10 	vmov	s14, r3
 8027ccc:	eee0 7a26 	vfma.f32	s15, s0, s13
 8027cd0:	ee27 0aa7 	vmul.f32	s0, s15, s15
 8027cd4:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cd8:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cdc:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027ce0:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027ce4:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027ce8:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cec:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cf0:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cf4:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027cf8:	ee20 0a07 	vmul.f32	s0, s0, s14
 8027cfc:	4770      	bx	lr
 8027cfe:	bf00      	nop

08027d00 <powtodb>:
    if (f <= 0) return (0);
 8027d00:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
 8027d04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (f <= 0) return (0);
 8027d06:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8027d0a:	f04f 0300 	mov.w	r3, #0
{
 8027d0e:	ed2d 8b02 	vpush	{d8}
    if (f <= 0) return (0);
 8027d12:	ee08 3a10 	vmov	s16, r3
 8027d16:	d91d      	bls.n	8027d54 <powtodb+0x54>
        float val = 100.0f + 10.0f/LOGTEN * logf(f);
 8027d18:	ee18 5a10 	vmov	r5, s16
 8027d1c:	f644 768a 	movw	r6, #20362	; 0x4f8a
 8027d20:	f645 772c 	movw	r7, #24364	; 0x5f2c
 8027d24:	461c      	mov	r4, r3
 8027d26:	f6ce 5638 	movt	r6, #60728	; 0xed38
 8027d2a:	f003 f9cd 	bl	802b0c8 <logf>
 8027d2e:	f2c4 0559 	movt	r5, #16473	; 0x4059
 8027d32:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 8027d36:	f2c4 0711 	movt	r7, #16401	; 0x4011
 8027d3a:	ec45 4b10 	vmov	d0, r4, r5
 8027d3e:	ec47 6b17 	vmov	d7, r6, r7
 8027d42:	eea6 0b07 	vfma.f64	d0, d6, d7
 8027d46:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
        return (val < 0.0f ? 0.0f : val);
 8027d4a:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
}
 8027d4e:	ecbd 8b02 	vpop	{d8}
 8027d52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027d54:	ecbd 8b02 	vpop	{d8}
    if (f <= 0) return (0);
 8027d58:	ee00 3a10 	vmov	s0, r3
}
 8027d5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027d5e:	bf00      	nop

08027d60 <fastdbtoa>:


float fastdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return expf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
 8027d60:	f64c 03e3 	movw	r3, #51427	; 0xc8e3
 8027d64:	f6c3 53eb 	movt	r3, #15851	; 0x3deb
 8027d68:	ee07 3a90 	vmov	s15, r3
 8027d6c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8027d70:	f003 b924 	b.w	802afbc <expf>

08027d74 <fasterdbtoa>:
    x = 1.0f + (x * 0.00390625f);
 8027d74:	f64c 03e3 	movw	r3, #51427	; 0xc8e3
 8027d78:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 8027d7c:	f6c3 13eb 	movt	r3, #14827	; 0x39eb
 8027d80:	ee07 3a10 	vmov	s14, r3
 8027d84:	eee0 7a07 	vfma.f32	s15, s0, s14
    x *= x; x *= x; x *= x; x *= x;
 8027d88:	ee27 0aa7 	vmul.f32	s0, s15, s15
 8027d8c:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027d90:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027d94:	ee20 0a00 	vmul.f32	s0, s0, s0
    x *= x; x *= x; x *= x; x *= x;
 8027d98:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027d9c:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027da0:	ee20 0a00 	vmul.f32	s0, s0, s0

float fasterdbtoa(float db)
{
    //return powf(10.0f, db * 0.05f);
    return fasterexpf(0.115129254649702f * db); //faster version from http://openaudio.blogspot.com/2017/02/faster-log10-and-pow.html
}
 8027da4:	ee20 0a00 	vmul.f32	s0, s0, s0
 8027da8:	4770      	bx	lr
 8027daa:	bf00      	nop

08027dac <maximum>:


float maximum (float num1, float num2)
{
    return (num1 > num2 ) ? num1 : num2;
}
 8027dac:	fe80 0a80 	vmaxnm.f32	s0, s1, s0
 8027db0:	4770      	bx	lr
 8027db2:	bf00      	nop

08027db4 <minimum>:

float minimum (float num1, float num2)
{
    return (num1 < num2 ) ? num1 : num2;
}
 8027db4:	fe80 0ac0 	vminnm.f32	s0, s1, s0
 8027db8:	4770      	bx	lr
 8027dba:	bf00      	nop

08027dbc <leaf_pool_init>:
/**
 * create memory pool
 */
void mpool_create (char* memory, size_t size, _tMempool* pool)
{
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 8027dbc:	f249 43a0 	movw	r3, #38048	; 0x94a0
    
    pool->mpool = (char*)memory;
    pool->usize  = 0;
 8027dc0:	2200      	movs	r2, #0
    */
    //is zeroing out the memory necessary? This takes a long time on large pools - JS
}

void leaf_pool_init(char* memory, size_t size)
{
 8027dc2:	b4f0      	push	{r4, r5, r6, r7}
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 8027dc4:	f2c2 0301 	movt	r3, #8193	; 0x2001
 8027dc8:	2710      	movs	r7, #16
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 8027dca:	f1a1 0610 	sub.w	r6, r1, #16
}

static inline mpool_node_t* create_node(char* block_location, mpool_node_t* next, mpool_node_t* prev, size_t size)
{
    mpool_node_t* node = (mpool_node_t*)block_location;
    node->pool = block_location + leaf.header_size;
 8027dce:	19c5      	adds	r5, r0, r7
    leaf.mempool = &leaf._mempool;
 8027dd0:	f103 041c 	add.w	r4, r3, #28
    pool->mpool = (char*)memory;
 8027dd4:	61d8      	str	r0, [r3, #28]
    pool->msize  = size;
 8027dd6:	6259      	str	r1, [r3, #36]	; 0x24
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 8027dd8:	62df      	str	r7, [r3, #44]	; 0x2c
    pool->usize  = 0;
 8027dda:	621a      	str	r2, [r3, #32]
    node->next = next;
    node->prev = prev;
    node->size = size;
 8027ddc:	60c6      	str	r6, [r0, #12]
    node->pool = block_location + leaf.header_size;
 8027dde:	6005      	str	r5, [r0, #0]
    node->prev = prev;
 8027de0:	e9c0 2201 	strd	r2, r2, [r0, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 8027de4:	6298      	str	r0, [r3, #40]	; 0x28
    leaf.mempool = &leaf._mempool;
 8027de6:	619c      	str	r4, [r3, #24]
}
 8027de8:	bcf0      	pop	{r4, r5, r6, r7}
 8027dea:	4770      	bx	lr

08027dec <mpool_alloc>:
{
 8027dec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
 8027dee:	68cb      	ldr	r3, [r1, #12]
 8027df0:	2b00      	cmp	r3, #0
 8027df2:	d04c      	beq.n	8027e8e <mpool_alloc+0xa2>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
 8027df4:	3007      	adds	r0, #7
 8027df6:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
 8027dfa:	e002      	b.n	8027e02 <mpool_alloc+0x16>
        if (node_to_alloc == NULL)
 8027dfc:	4623      	mov	r3, r4
 8027dfe:	2c00      	cmp	r4, #0
 8027e00:	d045      	beq.n	8027e8e <mpool_alloc+0xa2>
    while (node_to_alloc->size < size_to_alloc)
 8027e02:	68da      	ldr	r2, [r3, #12]
 8027e04:	685c      	ldr	r4, [r3, #4]
 8027e06:	4282      	cmp	r2, r0
 8027e08:	d3f8      	bcc.n	8027dfc <mpool_alloc+0x10>
    if (leftover > leaf.header_size)
 8027e0a:	f249 45a0 	movw	r5, #38048	; 0x94a0
    node_to_alloc->size = size_to_alloc;
 8027e0e:	60d8      	str	r0, [r3, #12]
    size_t leftover = node_to_alloc->size - size_to_alloc;
 8027e10:	1a17      	subs	r7, r2, r0
    if (leftover > leaf.header_size)
 8027e12:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8027e16:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8027e18:	42be      	cmp	r6, r7
 8027e1a:	d327      	bcc.n	8027e6c <mpool_alloc+0x80>
        node_to_alloc->size += leftover;
 8027e1c:	46a4      	mov	ip, r4
 8027e1e:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
 8027e20:	68ca      	ldr	r2, [r1, #12]
 8027e22:	429a      	cmp	r2, r3
        pool->head = new_node;
 8027e24:	bf08      	it	eq
 8027e26:	f8c1 c00c 	streq.w	ip, [r1, #12]
 8027e2a:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
}

static inline void delink_node(mpool_node_t* node)
{
    // If there is a node after the node to remove
    if (node->next != NULL)
 8027e2e:	b108      	cbz	r0, 8027e34 <mpool_alloc+0x48>
    {
        // Close the link
        node->next->prev = node->prev;
 8027e30:	6082      	str	r2, [r0, #8]
 8027e32:	689a      	ldr	r2, [r3, #8]
    }
    // If there is a node before the node to remove
    if (node->prev != NULL)
 8027e34:	b10a      	cbz	r2, 8027e3a <mpool_alloc+0x4e>
    {
        // Close the link
        node->prev->next = node->next;
 8027e36:	6858      	ldr	r0, [r3, #4]
 8027e38:	6050      	str	r0, [r2, #4]
    }
    
    node->next = NULL;
 8027e3a:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 8027e3c:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
 8027e3e:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 8027e42:	6848      	ldr	r0, [r1, #4]
 8027e44:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8027e46:	4430      	add	r0, r6
 8027e48:	4420      	add	r0, r4
 8027e4a:	6048      	str	r0, [r1, #4]
    if (leaf.clearOnAllocation > 0)
 8027e4c:	6969      	ldr	r1, [r5, #20]
 8027e4e:	4291      	cmp	r1, r2
 8027e50:	dd0a      	ble.n	8027e68 <mpool_alloc+0x7c>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8027e52:	68d9      	ldr	r1, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
 8027e54:	6818      	ldr	r0, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8027e56:	b141      	cbz	r1, 8027e6a <mpool_alloc+0x7e>
 8027e58:	3801      	subs	r0, #1
 8027e5a:	4614      	mov	r4, r2
 8027e5c:	f800 4f01 	strb.w	r4, [r0, #1]!
 8027e60:	3201      	adds	r2, #1
 8027e62:	68d9      	ldr	r1, [r3, #12]
 8027e64:	4291      	cmp	r1, r2
 8027e66:	d8f9      	bhi.n	8027e5c <mpool_alloc+0x70>
 8027e68:	6818      	ldr	r0, [r3, #0]
}
 8027e6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8027e6c:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
 8027e6e:	4430      	add	r0, r6
                               node_to_alloc->prev,
 8027e70:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
 8027e74:	1bbf      	subs	r7, r7, r6
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8027e76:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
 8027e7a:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
 8027e7c:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
 8027e80:	4466      	add	r6, ip
 8027e82:	5016      	str	r6, [r2, r0]
    node->size = size;
 8027e84:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
 8027e88:	e9cc 4e01 	strd	r4, lr, [ip, #4]
 8027e8c:	e7c8      	b.n	8027e20 <mpool_alloc+0x34>
}

void leaf_mempool_overrun(void)
{
    LEAF_error(1);
 8027e8e:	2001      	movs	r0, #1
 8027e90:	f002 fee2 	bl	802ac58 <LEAF_error>
        return NULL;
 8027e94:	2000      	movs	r0, #0
}
 8027e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08027e98 <mpool_calloc>:
{
 8027e98:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if (pool->head == NULL)
 8027e9a:	68cb      	ldr	r3, [r1, #12]
 8027e9c:	2b00      	cmp	r3, #0
 8027e9e:	d049      	beq.n	8027f34 <mpool_calloc+0x9c>
    return (size + (MPOOL_ALIGN_SIZE - 1)) & ~(MPOOL_ALIGN_SIZE - 1);
 8027ea0:	3007      	adds	r0, #7
 8027ea2:	f020 0007 	bic.w	r0, r0, #7
    while (node_to_alloc->size < size_to_alloc)
 8027ea6:	e002      	b.n	8027eae <mpool_calloc+0x16>
        if (node_to_alloc == NULL)
 8027ea8:	4623      	mov	r3, r4
 8027eaa:	2c00      	cmp	r4, #0
 8027eac:	d042      	beq.n	8027f34 <mpool_calloc+0x9c>
    while (node_to_alloc->size < size_to_alloc)
 8027eae:	68da      	ldr	r2, [r3, #12]
 8027eb0:	685c      	ldr	r4, [r3, #4]
 8027eb2:	4282      	cmp	r2, r0
 8027eb4:	d3f8      	bcc.n	8027ea8 <mpool_calloc+0x10>
    if (leftover > leaf.header_size)
 8027eb6:	f249 45a0 	movw	r5, #38048	; 0x94a0
    node_to_alloc->size = size_to_alloc;
 8027eba:	60d8      	str	r0, [r3, #12]
    size_t leftover = node_to_alloc->size - size_to_alloc;
 8027ebc:	1a17      	subs	r7, r2, r0
    if (leftover > leaf.header_size)
 8027ebe:	f2c2 0501 	movt	r5, #8193	; 0x2001
 8027ec2:	6aee      	ldr	r6, [r5, #44]	; 0x2c
 8027ec4:	42be      	cmp	r6, r7
 8027ec6:	d324      	bcc.n	8027f12 <mpool_calloc+0x7a>
        node_to_alloc->size += leftover;
 8027ec8:	46a4      	mov	ip, r4
 8027eca:	60da      	str	r2, [r3, #12]
    if (pool->head == node_to_alloc)
 8027ecc:	68ca      	ldr	r2, [r1, #12]
 8027ece:	429a      	cmp	r2, r3
        pool->head = new_node;
 8027ed0:	bf08      	it	eq
 8027ed2:	f8c1 c00c 	streq.w	ip, [r1, #12]
 8027ed6:	e9d3 0201 	ldrd	r0, r2, [r3, #4]
    if (node->next != NULL)
 8027eda:	b108      	cbz	r0, 8027ee0 <mpool_calloc+0x48>
        node->next->prev = node->prev;
 8027edc:	6082      	str	r2, [r0, #8]
 8027ede:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 8027ee0:	b10a      	cbz	r2, 8027ee6 <mpool_calloc+0x4e>
        node->prev->next = node->next;
 8027ee2:	6858      	ldr	r0, [r3, #4]
 8027ee4:	6050      	str	r0, [r2, #4]
    node->next = NULL;
 8027ee6:	2200      	movs	r2, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 8027ee8:	68dc      	ldr	r4, [r3, #12]
    node->prev = NULL;
 8027eea:	e9c3 2201 	strd	r2, r2, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 8027eee:	6848      	ldr	r0, [r1, #4]
 8027ef0:	6aed      	ldr	r5, [r5, #44]	; 0x2c
 8027ef2:	4428      	add	r0, r5
 8027ef4:	4420      	add	r0, r4
 8027ef6:	6048      	str	r0, [r1, #4]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8027ef8:	68d9      	ldr	r1, [r3, #12]
    char* new_pool = (char*)node_to_alloc->pool;
 8027efa:	6818      	ldr	r0, [r3, #0]
    for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8027efc:	b141      	cbz	r1, 8027f10 <mpool_calloc+0x78>
 8027efe:	3801      	subs	r0, #1
 8027f00:	4614      	mov	r4, r2
 8027f02:	f800 4f01 	strb.w	r4, [r0, #1]!
 8027f06:	3201      	adds	r2, #1
 8027f08:	68d9      	ldr	r1, [r3, #12]
 8027f0a:	4291      	cmp	r1, r2
 8027f0c:	d8f9      	bhi.n	8027f02 <mpool_calloc+0x6a>
 8027f0e:	6818      	ldr	r0, [r3, #0]
}
 8027f10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8027f12:	680a      	ldr	r2, [r1, #0]
        offset += leaf.header_size + node_to_alloc->size;
 8027f14:	4430      	add	r0, r6
                               node_to_alloc->prev,
 8027f16:	f8d3 e008 	ldr.w	lr, [r3, #8]
        new_node = create_node(&pool->mpool[offset],
 8027f1a:	1bbf      	subs	r7, r7, r6
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 8027f1c:	eba3 0c02 	sub.w	ip, r3, r2
        offset += leaf.header_size + node_to_alloc->size;
 8027f20:	4460      	add	r0, ip
        new_node = create_node(&pool->mpool[offset],
 8027f22:	eb02 0c00 	add.w	ip, r2, r0
    node->pool = block_location + leaf.header_size;
 8027f26:	4466      	add	r6, ip
 8027f28:	5016      	str	r6, [r2, r0]
    node->size = size;
 8027f2a:	f8cc 700c 	str.w	r7, [ip, #12]
    node->prev = prev;
 8027f2e:	e9cc 4e01 	strd	r4, lr, [ip, #4]
 8027f32:	e7cb      	b.n	8027ecc <mpool_calloc+0x34>
    LEAF_error(1);
 8027f34:	2001      	movs	r0, #1
 8027f36:	f002 fe8f 	bl	802ac58 <LEAF_error>
        return NULL;
 8027f3a:	2000      	movs	r0, #0
}
 8027f3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8027f3e:	bf00      	nop

08027f40 <mpool_free>:
{
 8027f40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
 8027f44:	f249 47a0 	movw	r7, #38048	; 0x94a0
    pool->usize -= leaf.header_size + freed_node->size;
 8027f48:	684a      	ldr	r2, [r1, #4]
    mpool_node_t* other_node = pool->head;
 8027f4a:	68cb      	ldr	r3, [r1, #12]
    mpool_node_t* freed_node = (mpool_node_t*) (ptr - leaf.header_size);
 8027f4c:	f2c2 0701 	movt	r7, #8193	; 0x2001
 8027f50:	6afc      	ldr	r4, [r7, #44]	; 0x2c
 8027f52:	1b00      	subs	r0, r0, r4
    pool->usize -= leaf.header_size + freed_node->size;
 8027f54:	1b12      	subs	r2, r2, r4
 8027f56:	68c4      	ldr	r4, [r0, #12]
 8027f58:	1b12      	subs	r2, r2, r4
 8027f5a:	604a      	str	r2, [r1, #4]
    while (other_node != NULL)
 8027f5c:	2b00      	cmp	r3, #0
 8027f5e:	d03e      	beq.n	8027fde <mpool_free+0x9e>
        if ((long) other_node < (long) pool->mpool ||
 8027f60:	680a      	ldr	r2, [r1, #0]
 8027f62:	4293      	cmp	r3, r2
 8027f64:	db1f      	blt.n	8027fa6 <mpool_free+0x66>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
 8027f66:	688c      	ldr	r4, [r1, #8]
 8027f68:	461d      	mov	r5, r3
 8027f6a:	4422      	add	r2, r4
        if ((long) other_node < (long) pool->mpool ||
 8027f6c:	429a      	cmp	r2, r3
 8027f6e:	d91a      	bls.n	8027fa6 <mpool_free+0x66>
    node->next = NULL;
 8027f70:	f04f 0c00 	mov.w	ip, #0
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
 8027f74:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8027f76:	68c4      	ldr	r4, [r0, #12]
        next_node = other_node->next;
 8027f78:	685e      	ldr	r6, [r3, #4]
        if (((long) freed_node) + (leaf.header_size + freed_node->size) == (long) other_node)
 8027f7a:	eb02 0e04 	add.w	lr, r2, r4
 8027f7e:	f8d3 800c 	ldr.w	r8, [r3, #12]
 8027f82:	eb0e 0900 	add.w	r9, lr, r0
 8027f86:	45a9      	cmp	r9, r5
 8027f88:	d030      	beq.n	8027fec <mpool_free+0xac>
        else if (((long) other_node) + (leaf.header_size + other_node->size) == (long) freed_node)
 8027f8a:	442a      	add	r2, r5
 8027f8c:	4442      	add	r2, r8
 8027f8e:	4290      	cmp	r0, r2
 8027f90:	d00e      	beq.n	8027fb0 <mpool_free+0x70>
    while (other_node != NULL)
 8027f92:	b31e      	cbz	r6, 8027fdc <mpool_free+0x9c>
        if ((long) other_node < (long) pool->mpool ||
 8027f94:	680b      	ldr	r3, [r1, #0]
 8027f96:	42b3      	cmp	r3, r6
 8027f98:	dc05      	bgt.n	8027fa6 <mpool_free+0x66>
            (long) other_node >= (((long) pool->mpool) + pool->msize))
 8027f9a:	688c      	ldr	r4, [r1, #8]
 8027f9c:	4635      	mov	r5, r6
 8027f9e:	441c      	add	r4, r3
 8027fa0:	4633      	mov	r3, r6
        if ((long) other_node < (long) pool->mpool ||
 8027fa2:	42b4      	cmp	r4, r6
 8027fa4:	d8e6      	bhi.n	8027f74 <mpool_free+0x34>
            LEAF_error(2);
 8027fa6:	2002      	movs	r0, #2
}
 8027fa8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
            LEAF_error(2);
 8027fac:	f002 be54 	b.w	802ac58 <LEAF_error>
            other_node->size += leaf.header_size + freed_node->size;
 8027fb0:	eb0e 0408 	add.w	r4, lr, r8
 8027fb4:	60dc      	str	r4, [r3, #12]
            if (other_node != pool->head)
 8027fb6:	68ca      	ldr	r2, [r1, #12]
 8027fb8:	429a      	cmp	r2, r3
 8027fba:	d02b      	beq.n	8028014 <mpool_free+0xd4>
 8027fbc:	689a      	ldr	r2, [r3, #8]
    if (node->next != NULL)
 8027fbe:	b10e      	cbz	r6, 8027fc4 <mpool_free+0x84>
        node->next->prev = node->prev;
 8027fc0:	60b2      	str	r2, [r6, #8]
 8027fc2:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 8027fc4:	b10a      	cbz	r2, 8027fca <mpool_free+0x8a>
        node->prev->next = node->next;
 8027fc6:	6858      	ldr	r0, [r3, #4]
 8027fc8:	6050      	str	r0, [r2, #4]
    node->next = NULL;
 8027fca:	f8c3 c004 	str.w	ip, [r3, #4]
 8027fce:	4618      	mov	r0, r3
    node->prev = NULL;
 8027fd0:	f8c3 c008 	str.w	ip, [r3, #8]
                other_node->next = pool->head;
 8027fd4:	68ca      	ldr	r2, [r1, #12]
 8027fd6:	605a      	str	r2, [r3, #4]
    while (other_node != NULL)
 8027fd8:	2e00      	cmp	r6, #0
 8027fda:	d1db      	bne.n	8027f94 <mpool_free+0x54>
 8027fdc:	68cb      	ldr	r3, [r1, #12]
    freed_node->next = pool->head;
 8027fde:	6043      	str	r3, [r0, #4]
    if (pool->head != NULL) pool->head->prev = freed_node;
 8027fe0:	68cb      	ldr	r3, [r1, #12]
 8027fe2:	b103      	cbz	r3, 8027fe6 <mpool_free+0xa6>
 8027fe4:	6098      	str	r0, [r3, #8]
    pool->head = freed_node;
 8027fe6:	60c8      	str	r0, [r1, #12]
}
 8027fe8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
            freed_node->size += leaf.header_size + other_node->size;
 8027fec:	4444      	add	r4, r8
 8027fee:	4422      	add	r2, r4
 8027ff0:	60c2      	str	r2, [r0, #12]
            if (other_node == pool->head) pool->head = pool->head->next;
 8027ff2:	68ca      	ldr	r2, [r1, #12]
 8027ff4:	429a      	cmp	r2, r3
 8027ff6:	d00a      	beq.n	802800e <mpool_free+0xce>
 8027ff8:	e9d3 4201 	ldrd	r4, r2, [r3, #4]
    if (node->next != NULL)
 8027ffc:	b10c      	cbz	r4, 8028002 <mpool_free+0xc2>
        node->next->prev = node->prev;
 8027ffe:	60a2      	str	r2, [r4, #8]
 8028000:	689a      	ldr	r2, [r3, #8]
    if (node->prev != NULL)
 8028002:	b10a      	cbz	r2, 8028008 <mpool_free+0xc8>
        node->prev->next = node->next;
 8028004:	685c      	ldr	r4, [r3, #4]
 8028006:	6054      	str	r4, [r2, #4]
    node->prev = NULL;
 8028008:	e9c3 cc01 	strd	ip, ip, [r3, #4]
 802800c:	e7c1      	b.n	8027f92 <mpool_free+0x52>
            if (other_node == pool->head) pool->head = pool->head->next;
 802800e:	685a      	ldr	r2, [r3, #4]
 8028010:	60ca      	str	r2, [r1, #12]
 8028012:	e7f1      	b.n	8027ff8 <mpool_free+0xb8>
                pool->head = pool->head->next;
 8028014:	4618      	mov	r0, r3
 8028016:	60ce      	str	r6, [r1, #12]
 8028018:	e7bb      	b.n	8027f92 <mpool_free+0x52>
 802801a:	bf00      	nop

0802801c <tMempool_init>:
    //TODO: we should make a set of real error codes that are in an enum type
}

void tMempool_init(tMempool* const mp, char* memory, size_t size)
{
 802801c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    tMempool_freeFromPool(mp, &leaf.mempool);
}

void    tMempool_initToPool     (tMempool* const mp, char* memory, size_t size, tMempool* const mem)
{
    _tMempool* mm = *mem;
 8028020:	f249 46a0 	movw	r6, #38048	; 0x94a0
{
 8028024:	b082      	sub	sp, #8
    _tMempool* mm = *mem;
 8028026:	f2c2 0601 	movt	r6, #8193	; 0x2001
 802802a:	f8d6 c018 	ldr.w	ip, [r6, #24]
    if (pool->head == NULL)
 802802e:	f8dc 300c 	ldr.w	r3, [ip, #12]
 8028032:	b91b      	cbnz	r3, 802803c <tMempool_init+0x20>
 8028034:	e04c      	b.n	80280d0 <tMempool_init+0xb4>
        if (node_to_alloc == NULL)
 8028036:	462b      	mov	r3, r5
 8028038:	2d00      	cmp	r5, #0
 802803a:	d049      	beq.n	80280d0 <tMempool_init+0xb4>
    while (node_to_alloc->size < size_to_alloc)
 802803c:	68dc      	ldr	r4, [r3, #12]
 802803e:	685d      	ldr	r5, [r3, #4]
 8028040:	2c0f      	cmp	r4, #15
 8028042:	d9f8      	bls.n	8028036 <tMempool_init+0x1a>
    node_to_alloc->size = size_to_alloc;
 8028044:	2710      	movs	r7, #16
    size_t leftover = node_to_alloc->size - size_to_alloc;
 8028046:	f1a4 0e10 	sub.w	lr, r4, #16
    node_to_alloc->size = size_to_alloc;
 802804a:	60df      	str	r7, [r3, #12]
    if (leftover > leaf.header_size)
 802804c:	6af7      	ldr	r7, [r6, #44]	; 0x2c
 802804e:	45be      	cmp	lr, r7
 8028050:	d849      	bhi.n	80280e6 <tMempool_init+0xca>
        node_to_alloc->size += leftover;
 8028052:	46ae      	mov	lr, r5
 8028054:	60dc      	str	r4, [r3, #12]
    if (pool->head == node_to_alloc)
 8028056:	f8dc 400c 	ldr.w	r4, [ip, #12]
 802805a:	42a3      	cmp	r3, r4
        pool->head = new_node;
 802805c:	bf08      	it	eq
 802805e:	f8cc e00c 	streq.w	lr, [ip, #12]
 8028062:	e9d3 5401 	ldrd	r5, r4, [r3, #4]
    if (node->next != NULL)
 8028066:	b10d      	cbz	r5, 802806c <tMempool_init+0x50>
        node->next->prev = node->prev;
 8028068:	60ac      	str	r4, [r5, #8]
 802806a:	689c      	ldr	r4, [r3, #8]
    if (node->prev != NULL)
 802806c:	b10c      	cbz	r4, 8028072 <tMempool_init+0x56>
        node->prev->next = node->next;
 802806e:	685d      	ldr	r5, [r3, #4]
 8028070:	6065      	str	r5, [r4, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 8028072:	68dc      	ldr	r4, [r3, #12]
    node->next = NULL;
 8028074:	2500      	movs	r5, #0
    pool->usize += leaf.header_size + node_to_alloc->size;
 8028076:	9401      	str	r4, [sp, #4]
    node->prev = NULL;
 8028078:	e9c3 5501 	strd	r5, r5, [r3, #4]
    pool->usize += leaf.header_size + node_to_alloc->size;
 802807c:	6af4      	ldr	r4, [r6, #44]	; 0x2c
 802807e:	f8dc 7004 	ldr.w	r7, [ip, #4]
 8028082:	4427      	add	r7, r4
 8028084:	463c      	mov	r4, r7
 8028086:	9f01      	ldr	r7, [sp, #4]
 8028088:	4427      	add	r7, r4
 802808a:	f8cc 7004 	str.w	r7, [ip, #4]
    if (leaf.clearOnAllocation > 0)
 802808e:	6974      	ldr	r4, [r6, #20]
 8028090:	42ac      	cmp	r4, r5
 8028092:	dd0a      	ble.n	80280aa <tMempool_init+0x8e>
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8028094:	68df      	ldr	r7, [r3, #12]
        char* new_pool = (char*)node_to_alloc->pool;
 8028096:	681c      	ldr	r4, [r3, #0]
        for (int i = 0; i < node_to_alloc->size; i++) new_pool[i] = 0;
 8028098:	b147      	cbz	r7, 80280ac <tMempool_init+0x90>
 802809a:	3c01      	subs	r4, #1
 802809c:	46ac      	mov	ip, r5
 802809e:	f804 cf01 	strb.w	ip, [r4, #1]!
 80280a2:	3501      	adds	r5, #1
 80280a4:	68df      	ldr	r7, [r3, #12]
 80280a6:	42bd      	cmp	r5, r7
 80280a8:	d3f9      	bcc.n	802809e <tMempool_init+0x82>
 80280aa:	681c      	ldr	r4, [r3, #0]
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 80280ac:	6004      	str	r4, [r0, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80280ae:	2310      	movs	r3, #16
    pool->usize  = 0;
 80280b0:	2000      	movs	r0, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80280b2:	62f3      	str	r3, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
 80280b4:	6021      	str	r1, [r4, #0]
    pool->usize  = 0;
 80280b6:	e9c4 0201 	strd	r0, r2, [r4, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 80280ba:	6af3      	ldr	r3, [r6, #44]	; 0x2c
    node->next = next;
 80280bc:	6048      	str	r0, [r1, #4]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 80280be:	1ad2      	subs	r2, r2, r3
    node->pool = block_location + leaf.header_size;
 80280c0:	440b      	add	r3, r1
    node->size = size;
 80280c2:	e9c1 0202 	strd	r0, r2, [r1, #8]
    node->pool = block_location + leaf.header_size;
 80280c6:	600b      	str	r3, [r1, #0]
    pool->head = create_node(pool->mpool, NULL, NULL, pool->msize-leaf.header_size);
 80280c8:	60e1      	str	r1, [r4, #12]
}
 80280ca:	b002      	add	sp, #8
 80280cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80280d0:	4605      	mov	r5, r0
    LEAF_error(1);
 80280d2:	2001      	movs	r0, #1
 80280d4:	460c      	mov	r4, r1
 80280d6:	f002 fdbf 	bl	802ac58 <LEAF_error>
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 80280da:	2300      	movs	r3, #0
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80280dc:	2210      	movs	r2, #16
    _tMempool* m = *mp = (_tMempool*) mpool_alloc(sizeof(_tMempool), mm);
 80280de:	602b      	str	r3, [r5, #0]
    leaf.header_size = mpool_align(sizeof(mpool_node_t));
 80280e0:	62f2      	str	r2, [r6, #44]	; 0x2c
    pool->mpool = (char*)memory;
 80280e2:	601c      	str	r4, [r3, #0]
 80280e4:	deff      	udf	#255	; 0xff
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 80280e6:	f8dc 9000 	ldr.w	r9, [ip]
        new_node = create_node(&pool->mpool[offset],
 80280ea:	ebae 0407 	sub.w	r4, lr, r7
        offset += leaf.header_size + node_to_alloc->size;
 80280ee:	f107 0810 	add.w	r8, r7, #16
                               node_to_alloc->prev,
 80280f2:	f8d3 a008 	ldr.w	sl, [r3, #8]
        long offset = (char*) node_to_alloc - (char*) pool->mpool;
 80280f6:	eba3 0e09 	sub.w	lr, r3, r9
        offset += leaf.header_size + node_to_alloc->size;
 80280fa:	44f0      	add	r8, lr
        new_node = create_node(&pool->mpool[offset],
 80280fc:	eb09 0e08 	add.w	lr, r9, r8
    node->pool = block_location + leaf.header_size;
 8028100:	4477      	add	r7, lr
 8028102:	f849 7008 	str.w	r7, [r9, r8]
    node->size = size;
 8028106:	f8ce 400c 	str.w	r4, [lr, #12]
    node->prev = prev;
 802810a:	e9ce 5a01 	strd	r5, sl, [lr, #4]
 802810e:	e7a2      	b.n	8028056 <tMempool_init+0x3a>

08028110 <tSimplePoly_initToPool>:
{
    tSimplePoly_initToPool(polyh, maxNumVoices, &leaf.mempool);
}

void    tSimplePoly_initToPool            (tSimplePoly* const polyh, int maxNumVoices, tMempool* const mp)
{
 8028110:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    _tMempool* m = *mp;
 8028114:	6816      	ldr	r6, [r2, #0]
{
 8028116:	4680      	mov	r8, r0
 8028118:	460c      	mov	r4, r1
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 802811a:	f240 401c 	movw	r0, #1052	; 0x41c
 802811e:	4631      	mov	r1, r6
{
 8028120:	4617      	mov	r7, r2
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 8028122:	f7ff fe63 	bl	8027dec <mpool_alloc>
 8028126:	4605      	mov	r5, r0
    poly->maxNumVoices = maxNumVoices;

    for (int i = 0; i < 128; i++)
    {
        poly->notes[i][0] = -1;
        poly->notes[i][1] = 0;
 8028128:	2100      	movs	r1, #0
        poly->notes[i][0] = -1;
 802812a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802812e:	462b      	mov	r3, r5
 8028130:	f505 6280 	add.w	r2, r5, #1024	; 0x400
    _tSimplePoly* poly = *polyh = (_tSimplePoly*) mpool_alloc(sizeof(_tSimplePoly), m);
 8028134:	f8c8 5000 	str.w	r5, [r8]
    poly->mempool = m;
 8028138:	602e      	str	r6, [r5, #0]
    poly->maxNumVoices = maxNumVoices;
 802813a:	e9c5 4402 	strd	r4, r4, [r5, #8]
        poly->notes[i][1] = 0;
 802813e:	e9c3 0107 	strd	r0, r1, [r3, #28]
 8028142:	3308      	adds	r3, #8
    for (int i = 0; i < 128; i++)
 8028144:	4293      	cmp	r3, r2
 8028146:	d1fa      	bne.n	802813e <tSimplePoly_initToPool+0x2e>
    }
    poly->stealing_on = 1;
 8028148:	2301      	movs	r3, #1
    poly->recover_stolen = 1;
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 802814a:	00a0      	lsls	r0, r4, #2
 802814c:	4631      	mov	r1, r6
    poly->recover_stolen = 1;
 802814e:	e9c5 3305 	strd	r3, r3, [r5, #20]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 8028152:	f7ff fe4b 	bl	8027dec <mpool_alloc>

    for (int i = 0; i < poly->maxNumVoices; ++i)
 8028156:	68eb      	ldr	r3, [r5, #12]
    poly->voices = (int**) mpool_alloc(sizeof(int*) * poly->maxNumVoices, m);
 8028158:	4680      	mov	r8, r0
 802815a:	6128      	str	r0, [r5, #16]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 802815c:	2b00      	cmp	r3, #0
 802815e:	dd14      	ble.n	802818a <tSimplePoly_initToPool+0x7a>
 8028160:	2400      	movs	r4, #0
    {
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
        poly->voices[i][0] = -1;
 8028162:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8028166:	e001      	b.n	802816c <tSimplePoly_initToPool+0x5c>
 8028168:	f8d5 8010 	ldr.w	r8, [r5, #16]
        poly->voices[i] = (int*) mpool_alloc(sizeof(int) * 3, m);
 802816c:	4631      	mov	r1, r6
 802816e:	200c      	movs	r0, #12
 8028170:	f7ff fe3c 	bl	8027dec <mpool_alloc>
 8028174:	f848 0024 	str.w	r0, [r8, r4, lsl #2]
        poly->voices[i][0] = -1;
 8028178:	692b      	ldr	r3, [r5, #16]
 802817a:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 802817e:	3401      	adds	r4, #1
        poly->voices[i][0] = -1;
 8028180:	f8c3 9000 	str.w	r9, [r3]
    for (int i = 0; i < poly->maxNumVoices; ++i)
 8028184:	68eb      	ldr	r3, [r5, #12]
 8028186:	42a3      	cmp	r3, r4
 8028188:	dcee      	bgt.n	8028168 <tSimplePoly_initToPool+0x58>
    _tMempool* m = *mp;
 802818a:	683e      	ldr	r6, [r7, #0]
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 802818c:	f44f 7004 	mov.w	r0, #528	; 0x210
    ns->ordered = 0;
 8028190:	2400      	movs	r4, #0
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 8028192:	4631      	mov	r1, r6
 8028194:	f7ff fe2a 	bl	8027dec <mpool_alloc>
    ns->capacity = STACK_SIZE;
 8028198:	2180      	movs	r1, #128	; 0x80
    _tStack* ns = *stack = (_tStack*) mpool_alloc(sizeof(_tStack), m);
 802819a:	4603      	mov	r3, r0
 802819c:	6068      	str	r0, [r5, #4]
 802819e:	f44f 7200 	mov.w	r2, #512	; 0x200
 80281a2:	3004      	adds	r0, #4
    ns->capacity = STACK_SIZE;
 80281a4:	f8a3 1208 	strh.w	r1, [r3, #520]	; 0x208
 80281a8:	21ff      	movs	r1, #255	; 0xff
    ns->mempool = m;
 80281aa:	601e      	str	r6, [r3, #0]
    ns->ordered = 0;
 80281ac:	f8c3 420c 	str.w	r4, [r3, #524]	; 0x20c
    ns->pos = 0;
 80281b0:	f8c3 4204 	str.w	r4, [r3, #516]	; 0x204
    }
    tStack_initToPool(&poly->stack, mp);

}
 80281b4:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80281b8:	f002 bd9f 	b.w	802acfa <memset>

080281bc <tSimplePoly_noteOn>:
    mpool_free((char*)poly->voices, poly->mempool);
    mpool_free((char*)poly, poly->mempool);
}

int tSimplePoly_noteOn(tSimplePoly* const polyh, int note, uint8_t vel)
{
 80281bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    _tSimplePoly* poly = *polyh;
 80281c0:	6806      	ldr	r6, [r0, #0]
    _tStack* ns = *stack;
 80281c2:	f8d6 c004 	ldr.w	ip, [r6, #4]
    for (int i = 0; i < ns->size; i++)
 80281c6:	f8bc 7206 	ldrh.w	r7, [ip, #518]	; 0x206
 80281ca:	b18f      	cbz	r7, 80281f0 <tSimplePoly_noteOn+0x34>
 80281cc:	b28d      	uxth	r5, r1
        if (ns->data[i] == noteVal)    return i;
 80281ce:	f8dc 3004 	ldr.w	r3, [ip, #4]
 80281d2:	429d      	cmp	r5, r3
 80281d4:	f000 809f 	beq.w	8028316 <tSimplePoly_noteOn+0x15a>
 80281d8:	f10c 0004 	add.w	r0, ip, #4
    for (int i = 0; i < ns->size; i++)
 80281dc:	2300      	movs	r3, #0
 80281de:	e004      	b.n	80281ea <tSimplePoly_noteOn+0x2e>
        if (ns->data[i] == noteVal)    return i;
 80281e0:	f850 4f04 	ldr.w	r4, [r0, #4]!
 80281e4:	42ac      	cmp	r4, r5
 80281e6:	f000 8096 	beq.w	8028316 <tSimplePoly_noteOn+0x15a>
    for (int i = 0; i < ns->size; i++)
 80281ea:	3301      	adds	r3, #1
 80281ec:	42bb      	cmp	r3, r7
 80281ee:	d1f7      	bne.n	80281e0 <tSimplePoly_noteOn+0x24>
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
    else
    {
        alteredVoice = -1;
        int found = 0;
        for (int i = 0; i < poly->numVoices; i++)
 80281f0:	f8d6 8008 	ldr.w	r8, [r6, #8]
 80281f4:	f1b8 0f00 	cmp.w	r8, #0
 80281f8:	dd29      	ble.n	802824e <tSimplePoly_noteOn+0x92>
        {
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 80281fa:	6933      	ldr	r3, [r6, #16]
 80281fc:	f8d3 9000 	ldr.w	r9, [r3]
 8028200:	f8d9 b000 	ldr.w	fp, [r9]
 8028204:	f1bb 3fff 	cmp.w	fp, #4294967295	; 0xffffffff
 8028208:	f000 8089 	beq.w	802831e <tSimplePoly_noteOn+0x162>
 802820c:	469e      	mov	lr, r3
        for (int i = 0; i < poly->numVoices; i++)
 802820e:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 8028210:	461c      	mov	r4, r3
 8028212:	e005      	b.n	8028220 <tSimplePoly_noteOn+0x64>
 8028214:	f854 3f04 	ldr.w	r3, [r4, #4]!
 8028218:	681d      	ldr	r5, [r3, #0]
 802821a:	3501      	adds	r5, #1
 802821c:	f000 8082 	beq.w	8028324 <tSimplePoly_noteOn+0x168>
        for (int i = 0; i < poly->numVoices; i++)
 8028220:	3001      	adds	r0, #1
 8028222:	4540      	cmp	r0, r8
 8028224:	ea4f 0a80 	mov.w	sl, r0, lsl #2
 8028228:	d1f4      	bne.n	8028214 <tSimplePoly_noteOn+0x58>
        if (!found)
        {
            //second preference is grabbing one that is in release phase but not finished sounding yet
            for (int i = 0 ; i < poly->numVoices; i++)
            {
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 802822a:	f11b 0f02 	cmn.w	fp, #2
            for (int i = 0 ; i < poly->numVoices; i++)
 802822e:	f04f 0300 	mov.w	r3, #0
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 8028232:	d107      	bne.n	8028244 <tSimplePoly_noteOn+0x88>
 8028234:	e0b4      	b.n	80283a0 <tSimplePoly_noteOn+0x1e4>
 8028236:	f85e 9f04 	ldr.w	r9, [lr, #4]!
 802823a:	f8d9 4000 	ldr.w	r4, [r9]
 802823e:	3402      	adds	r4, #2
 8028240:	f000 80af 	beq.w	80283a2 <tSimplePoly_noteOn+0x1e6>
            for (int i = 0 ; i < poly->numVoices; i++)
 8028244:	3301      	adds	r3, #1
 8028246:	4298      	cmp	r0, r3
 8028248:	ea4f 0583 	mov.w	r5, r3, lsl #2
 802824c:	d1f3      	bne.n	8028236 <tSimplePoly_noteOn+0x7a>
                    tStack_add(&poly->stack, note);
                    break;
                }
            }
        }
        if ((!found) && (poly->stealing_on)) //steal
 802824e:	6973      	ldr	r3, [r6, #20]
 8028250:	2b00      	cmp	r3, #0
 8028252:	d060      	beq.n	8028316 <tSimplePoly_noteOn+0x15a>
        {
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
 8028254:	1e78      	subs	r0, r7, #1
 8028256:	2f00      	cmp	r7, #0
 8028258:	d05f      	beq.n	802831a <tSimplePoly_noteOn+0x15e>
    return ns->data[which];
 802825a:	eb0c 0380 	add.w	r3, ip, r0, lsl #2
            {
                whichNote = tStack_get(&poly->stack, j);
                whichVoice = poly->notes[whichNote][0];
 802825e:	685b      	ldr	r3, [r3, #4]
 8028260:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 8028264:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
 8028266:	2b00      	cmp	r3, #0
 8028268:	da0b      	bge.n	8028282 <tSimplePoly_noteOn+0xc6>
 802826a:	eb0c 0787 	add.w	r7, ip, r7, lsl #2
            for (int j = tStack_getSize(&poly->stack) - 1; j >= 0; j--)
 802826e:	f110 30ff 	adds.w	r0, r0, #4294967295	; 0xffffffff
 8028272:	d352      	bcc.n	802831a <tSimplePoly_noteOn+0x15e>
                whichVoice = poly->notes[whichNote][0];
 8028274:	f857 3d04 	ldr.w	r3, [r7, #-4]!
 8028278:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 802827c:	69db      	ldr	r3, [r3, #28]
                if (whichVoice >= 0)
 802827e:	2b00      	cmp	r3, #0
 8028280:	dbf5      	blt.n	802826e <tSimplePoly_noteOn+0xb2>
                {
                    oldNote = poly->voices[whichVoice][0];
 8028282:	6930      	ldr	r0, [r6, #16]
                    poly->voices[whichVoice][0] = note;
                    poly->voices[whichVoice][1] = vel;
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
                    poly->notes[note][0] = whichVoice;
 8028284:	eb06 05c1 	add.w	r5, r6, r1, lsl #3
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 8028288:	f06f 0702 	mvn.w	r7, #2
                    oldNote = poly->voices[whichVoice][0];
 802828c:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 8028290:	6820      	ldr	r0, [r4, #0]
                    poly->voices[whichVoice][0] = note;
 8028292:	6021      	str	r1, [r4, #0]
                    poly->voices[whichVoice][1] = vel;
 8028294:	6934      	ldr	r4, [r6, #16]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 8028296:	eb06 00c0 	add.w	r0, r6, r0, lsl #3
                    poly->voices[whichVoice][1] = vel;
 802829a:	f854 c023 	ldr.w	ip, [r4, r3, lsl #2]
 802829e:	f8cc 2004 	str.w	r2, [ip, #4]
                    poly->notes[oldNote][0] = -3; //mark the stolen voice as stolen (in the second dimension of the notes array)
 80282a2:	61c7      	str	r7, [r0, #28]
 80282a4:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = whichVoice;
 80282a6:	61eb      	str	r3, [r5, #28]
                    poly->notes[note][1] = vel;
 80282a8:	622a      	str	r2, [r5, #32]

                    poly->voices[whichVoice][2] = note;
 80282aa:	6932      	ldr	r2, [r6, #16]
 80282ac:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80282b0:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
 80282b2:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
 80282b4:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 80282b8:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
 80282bc:	b1a4      	cbz	r4, 80282e8 <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
 80282be:	f1bc 0f00 	cmp.w	ip, #0
 80282c2:	f000 80a3 	beq.w	802840c <tSimplePoly_noteOn+0x250>
 80282c6:	2200      	movs	r2, #0
 80282c8:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80282cc:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
 80282ce:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80282d0:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
 80282d2:	42be      	cmp	r6, r7
 80282d4:	da04      	bge.n	80282e0 <tSimplePoly_noteOn+0x124>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80282d6:	68aa      	ldr	r2, [r5, #8]
 80282d8:	1c55      	adds	r5, r2, #1
 80282da:	d005      	beq.n	80282e8 <tSimplePoly_noteOn+0x12c>
 80282dc:	42ba      	cmp	r2, r7
 80282de:	dc03      	bgt.n	80282e8 <tSimplePoly_noteOn+0x12c>
        for (j = 0; j < ns->size; j++)
 80282e0:	b2c2      	uxtb	r2, r0
 80282e2:	4562      	cmp	r2, ip
 80282e4:	d3f0      	bcc.n	80282c8 <tSimplePoly_noteOn+0x10c>
    int whereToInsert = 0;
 80282e6:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 80282e8:	fa5f f28c 	uxtb.w	r2, ip
 80282ec:	4294      	cmp	r4, r2
 80282ee:	da08      	bge.n	8028302 <tSimplePoly_noteOn+0x146>
 80282f0:	1e56      	subs	r6, r2, #1
 80282f2:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 80282f6:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 80282fa:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
 80282fc:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
 80282fe:	42a2      	cmp	r2, r4
 8028300:	dcf6      	bgt.n	80282f0 <tSimplePoly_noteOn+0x134>
    ns->data[whereToInsert] = noteVal;
 8028302:	eb01 0484 	add.w	r4, r1, r4, lsl #2
    ns->size++;
 8028306:	f10c 0c01 	add.w	ip, ip, #1
 802830a:	4618      	mov	r0, r3
    ns->data[whereToInsert] = noteVal;
 802830c:	6067      	str	r7, [r4, #4]
    ns->size++;
 802830e:	f8a1 c206 	strh.w	ip, [r1, #518]	; 0x206
                }
            }
        }
        return alteredVoice;
    }
}
 8028312:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (tStack_contains(&poly->stack, note) >= 0) return -1;
 8028316:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 802831a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        for (int i = 0; i < poly->numVoices; i++)
 802831e:	2000      	movs	r0, #0
            if (poly->voices[i][0] == -1)    // if inactive voice, give this note to voice
 8028320:	464b      	mov	r3, r9
 8028322:	4682      	mov	sl, r0
                poly->voices[i][0] = note;
 8028324:	6019      	str	r1, [r3, #0]
                poly->notes[note][0] = i;
 8028326:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                poly->voices[i][1] = vel;
 802832a:	6935      	ldr	r5, [r6, #16]
 802832c:	b28f      	uxth	r7, r1
 802832e:	f855 500a 	ldr.w	r5, [r5, sl]
 8028332:	606a      	str	r2, [r5, #4]
                poly->notes[note][0] = i;
 8028334:	61e0      	str	r0, [r4, #28]
                poly->notes[note][1] = vel;
 8028336:	6222      	str	r2, [r4, #32]
                poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
 8028338:	6933      	ldr	r3, [r6, #16]
 802833a:	f853 300a 	ldr.w	r3, [r3, sl]
 802833e:	6099      	str	r1, [r3, #8]
    _tStack* ns = *stack;
 8028340:	6872      	ldr	r2, [r6, #4]
    if (ns->ordered)
 8028342:	f8d2 420c 	ldr.w	r4, [r2, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 8028346:	f8b2 c206 	ldrh.w	ip, [r2, #518]	; 0x206
    if (ns->ordered)
 802834a:	b19c      	cbz	r4, 8028374 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
 802834c:	f1bc 0f00 	cmp.w	ip, #0
 8028350:	d05e      	beq.n	8028410 <tSimplePoly_noteOn+0x254>
 8028352:	2300      	movs	r3, #0
 8028354:	eb02 0583 	add.w	r5, r2, r3, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 8028358:	1c59      	adds	r1, r3, #1
            if (noteVal > ns->data[j])
 802835a:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 802835c:	460c      	mov	r4, r1
            if (noteVal > ns->data[j])
 802835e:	42be      	cmp	r6, r7
 8028360:	da04      	bge.n	802836c <tSimplePoly_noteOn+0x1b0>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 8028362:	68ab      	ldr	r3, [r5, #8]
 8028364:	1c5d      	adds	r5, r3, #1
 8028366:	d005      	beq.n	8028374 <tSimplePoly_noteOn+0x1b8>
 8028368:	42bb      	cmp	r3, r7
 802836a:	dc03      	bgt.n	8028374 <tSimplePoly_noteOn+0x1b8>
        for (j = 0; j < ns->size; j++)
 802836c:	b2cb      	uxtb	r3, r1
 802836e:	459c      	cmp	ip, r3
 8028370:	d8f0      	bhi.n	8028354 <tSimplePoly_noteOn+0x198>
    int whereToInsert = 0;
 8028372:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 8028374:	fa5f f38c 	uxtb.w	r3, ip
 8028378:	42a3      	cmp	r3, r4
 802837a:	dd08      	ble.n	802838e <tSimplePoly_noteOn+0x1d2>
 802837c:	1e5e      	subs	r6, r3, #1
 802837e:	eb02 0183 	add.w	r1, r2, r3, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 8028382:	f852 5023 	ldr.w	r5, [r2, r3, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 8028386:	b2f3      	uxtb	r3, r6
        ns->data[j] = ns->data[(j - 1)];
 8028388:	604d      	str	r5, [r1, #4]
    for (j = ns->size; j > whereToInsert; j--)
 802838a:	42a3      	cmp	r3, r4
 802838c:	dcf6      	bgt.n	802837c <tSimplePoly_noteOn+0x1c0>
    ns->data[whereToInsert] = noteVal;
 802838e:	eb02 0484 	add.w	r4, r2, r4, lsl #2
    ns->size++;
 8028392:	f10c 0c01 	add.w	ip, ip, #1
    ns->data[whereToInsert] = noteVal;
 8028396:	6067      	str	r7, [r4, #4]
    ns->size++;
 8028398:	f8a2 c206 	strh.w	ip, [r2, #518]	; 0x206
}
 802839c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
                if (poly->voices[i][0] == -2)    // if voice is released but still sounding, take over this voice
 80283a0:	461d      	mov	r5, r3
                    poly->voices[i][0] = note;
 80283a2:	f8c9 1000 	str.w	r1, [r9]
                    poly->notes[note][0] = i;
 80283a6:	eb06 04c1 	add.w	r4, r6, r1, lsl #3
                    poly->voices[i][1] = vel;
 80283aa:	6937      	ldr	r7, [r6, #16]
 80283ac:	597f      	ldr	r7, [r7, r5]
 80283ae:	607a      	str	r2, [r7, #4]
 80283b0:	b28f      	uxth	r7, r1
                    poly->notes[note][0] = i;
 80283b2:	61e3      	str	r3, [r4, #28]
                    poly->notes[note][1] = vel;
 80283b4:	6222      	str	r2, [r4, #32]
                    poly->voices[i][2] = note; // voices[i][2] is the output midi note, (avoiding the -1 when a voice is inactive)
 80283b6:	6932      	ldr	r2, [r6, #16]
 80283b8:	5952      	ldr	r2, [r2, r5]
 80283ba:	6091      	str	r1, [r2, #8]
    _tStack* ns = *stack;
 80283bc:	6871      	ldr	r1, [r6, #4]
    if (ns->ordered)
 80283be:	f8d1 420c 	ldr.w	r4, [r1, #524]	; 0x20c
        for (j = 0; j < ns->size; j++)
 80283c2:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
    if (ns->ordered)
 80283c6:	b19c      	cbz	r4, 80283f0 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
 80283c8:	f1bc 0f00 	cmp.w	ip, #0
 80283cc:	d01e      	beq.n	802840c <tSimplePoly_noteOn+0x250>
 80283ce:	2200      	movs	r2, #0
 80283d0:	eb01 0582 	add.w	r5, r1, r2, lsl #2
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80283d4:	1c50      	adds	r0, r2, #1
            if (noteVal > ns->data[j])
 80283d6:	686e      	ldr	r6, [r5, #4]
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80283d8:	4604      	mov	r4, r0
            if (noteVal > ns->data[j])
 80283da:	42be      	cmp	r6, r7
 80283dc:	da04      	bge.n	80283e8 <tSimplePoly_noteOn+0x22c>
                if ((noteVal < ns->data[j+1]) || (ns->data[j+1] == -1))
 80283de:	68aa      	ldr	r2, [r5, #8]
 80283e0:	1c56      	adds	r6, r2, #1
 80283e2:	d005      	beq.n	80283f0 <tSimplePoly_noteOn+0x234>
 80283e4:	42ba      	cmp	r2, r7
 80283e6:	dc03      	bgt.n	80283f0 <tSimplePoly_noteOn+0x234>
        for (j = 0; j < ns->size; j++)
 80283e8:	b2c2      	uxtb	r2, r0
 80283ea:	4562      	cmp	r2, ip
 80283ec:	d3f0      	bcc.n	80283d0 <tSimplePoly_noteOn+0x214>
    int whereToInsert = 0;
 80283ee:	2400      	movs	r4, #0
    for (j = ns->size; j > whereToInsert; j--)
 80283f0:	fa5f f28c 	uxtb.w	r2, ip
 80283f4:	4294      	cmp	r4, r2
 80283f6:	da84      	bge.n	8028302 <tSimplePoly_noteOn+0x146>
 80283f8:	1e56      	subs	r6, r2, #1
 80283fa:	eb01 0082 	add.w	r0, r1, r2, lsl #2
        ns->data[j] = ns->data[(j - 1)];
 80283fe:	f851 5022 	ldr.w	r5, [r1, r2, lsl #2]
    for (j = ns->size; j > whereToInsert; j--)
 8028402:	b2f2      	uxtb	r2, r6
        ns->data[j] = ns->data[(j - 1)];
 8028404:	6045      	str	r5, [r0, #4]
    for (j = ns->size; j > whereToInsert; j--)
 8028406:	42a2      	cmp	r2, r4
 8028408:	dcf6      	bgt.n	80283f8 <tSimplePoly_noteOn+0x23c>
 802840a:	e77a      	b.n	8028302 <tSimplePoly_noteOn+0x146>
    int whereToInsert = 0;
 802840c:	4664      	mov	r4, ip
 802840e:	e778      	b.n	8028302 <tSimplePoly_noteOn+0x146>
 8028410:	4664      	mov	r4, ip
 8028412:	e7bc      	b.n	802838e <tSimplePoly_noteOn+0x1d2>

08028414 <tSimplePoly_noteOff>:



int tSimplePoly_noteOff(tSimplePoly* const polyh, uint8_t note)
{
 8028414:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
 8028418:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
 802841a:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
 802841e:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
 8028422:	b178      	cbz	r0, 8028444 <tSimplePoly_noteOff+0x30>
        if (ns->data[i] == noteVal)    return i;
 8028424:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8028428:	428b      	cmp	r3, r1
 802842a:	f000 8092 	beq.w	8028552 <tSimplePoly_noteOff+0x13e>
 802842e:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
 8028432:	2600      	movs	r6, #0
 8028434:	e003      	b.n	802843e <tSimplePoly_noteOff+0x2a>
        if (ns->data[i] == noteVal)    return i;
 8028436:	f853 2f04 	ldr.w	r2, [r3, #4]!
 802843a:	428a      	cmp	r2, r1
 802843c:	d01f      	beq.n	802847e <tSimplePoly_noteOff+0x6a>
    for (int i = 0; i < ns->size; i++)
 802843e:	3601      	adds	r6, #1
 8028440:	42b0      	cmp	r0, r6
 8028442:	d1f8      	bne.n	8028436 <tSimplePoly_noteOff+0x22>
    int16_t noteToTest = -1;

    tStack_remove(&poly->stack, note);
    poly->notes[note][0] = -1;
 8028444:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
 8028448:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802844c:	61d8      	str	r0, [r3, #28]

    int deactivatedVoice = -1;
    for (int i = 0; i < poly->maxNumVoices; i++)
 802844e:	68ee      	ldr	r6, [r5, #12]
 8028450:	2e00      	cmp	r6, #0
 8028452:	dd12      	ble.n	802847a <tSimplePoly_noteOff+0x66>
    {
        if (poly->voices[i][0] == note)
 8028454:	692b      	ldr	r3, [r5, #16]
 8028456:	681a      	ldr	r2, [r3, #0]
 8028458:	6814      	ldr	r4, [r2, #0]
 802845a:	42a1      	cmp	r1, r4
 802845c:	d06f      	beq.n	802853e <tSimplePoly_noteOff+0x12a>
    for (int i = 0; i < poly->maxNumVoices; i++)
 802845e:	2000      	movs	r0, #0
 8028460:	e004      	b.n	802846c <tSimplePoly_noteOff+0x58>
        if (poly->voices[i][0] == note)
 8028462:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8028466:	6814      	ldr	r4, [r2, #0]
 8028468:	428c      	cmp	r4, r1
 802846a:	d030      	beq.n	80284ce <tSimplePoly_noteOff+0xba>
    for (int i = 0; i < poly->maxNumVoices; i++)
 802846c:	3001      	adds	r0, #1
 802846e:	4286      	cmp	r6, r0
 8028470:	ea4f 0780 	mov.w	r7, r0, lsl #2
 8028474:	d1f5      	bne.n	8028462 <tSimplePoly_noteOff+0x4e>
                {
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
                    poly->voices[deactivatedVoice][2] = noteToTest;
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
                    return -1;
 8028476:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
                }
            }
        }
    }
    return deactivatedVoice;
}
 802847a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
 802847e:	eba0 0806 	sub.w	r8, r0, r6
 8028482:	f1b8 0f00 	cmp.w	r8, #0
 8028486:	dd58      	ble.n	802853a <tSimplePoly_noteOff+0x126>
            if ((k+foundIndex) >= (ns->capacity - 1))
 8028488:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
 802848c:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
 802848e:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8028492:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
 8028494:	4613      	mov	r3, r2
 8028496:	44ce      	add	lr, r9
 8028498:	e006      	b.n	80284a8 <tSimplePoly_noteOff+0x94>
        for (k = 0; k < (ns->size - foundIndex); k++)
 802849a:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
 802849c:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 80284a0:	b2d2      	uxtb	r2, r2
 80284a2:	4542      	cmp	r2, r8
 80284a4:	4613      	mov	r3, r2
 80284a6:	da0f      	bge.n	80284c8 <tSimplePoly_noteOff+0xb4>
            if ((k+foundIndex) >= (ns->capacity - 1))
 80284a8:	4433      	add	r3, r6
 80284aa:	4573      	cmp	r3, lr
 80284ac:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
 80284b0:	daf3      	bge.n	802849a <tSimplePoly_noteOff+0x86>
        for (k = 0; k < (ns->size - foundIndex); k++)
 80284b2:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
 80284b4:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 80284b6:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
 80284b8:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
 80284ba:	bf08      	it	eq
 80284bc:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 80284c0:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 80284c2:	4542      	cmp	r2, r8
 80284c4:	4613      	mov	r3, r2
 80284c6:	dbef      	blt.n	80284a8 <tSimplePoly_noteOff+0x94>
        ns->size--;
 80284c8:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
 80284cc:	e7ba      	b.n	8028444 <tSimplePoly_noteOff+0x30>
            poly->voices[i][0] = -1;
 80284ce:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
            poly->voices[i][1] = 0;
 80284d2:	2100      	movs	r1, #0
            poly->voices[i][0] = -1;
 80284d4:	6013      	str	r3, [r2, #0]
            poly->voices[i][1] = 0;
 80284d6:	692b      	ldr	r3, [r5, #16]
 80284d8:	59db      	ldr	r3, [r3, r7]
 80284da:	6059      	str	r1, [r3, #4]
    if (poly->recover_stolen)
 80284dc:	69ab      	ldr	r3, [r5, #24]
 80284de:	2b00      	cmp	r3, #0
 80284e0:	d0cb      	beq.n	802847a <tSimplePoly_noteOff+0x66>
    _tStack* ns = *stack;
 80284e2:	6869      	ldr	r1, [r5, #4]
    return ns->size;
 80284e4:	f8b1 c206 	ldrh.w	ip, [r1, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80284e8:	f1bc 0f00 	cmp.w	ip, #0
 80284ec:	d0c5      	beq.n	802847a <tSimplePoly_noteOff+0x66>
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 80284ee:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
 80284f2:	1cdc      	adds	r4, r3, #3
 80284f4:	eb05 02c4 	add.w	r2, r5, r4, lsl #3
 80284f8:	6852      	ldr	r2, [r2, #4]
 80284fa:	3203      	adds	r2, #3
 80284fc:	d00d      	beq.n	802851a <tSimplePoly_noteOff+0x106>
 80284fe:	3104      	adds	r1, #4
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 8028500:	2200      	movs	r2, #0
 8028502:	3201      	adds	r2, #1
 8028504:	4562      	cmp	r2, ip
 8028506:	d0b8      	beq.n	802847a <tSimplePoly_noteOff+0x66>
                noteToTest = tStack_get(&poly->stack, j);
 8028508:	f851 3f04 	ldr.w	r3, [r1, #4]!
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 802850c:	b21b      	sxth	r3, r3
 802850e:	1cdc      	adds	r4, r3, #3
 8028510:	eb05 06c4 	add.w	r6, r5, r4, lsl #3
 8028514:	6876      	ldr	r6, [r6, #4]
 8028516:	3603      	adds	r6, #3
 8028518:	d1f3      	bne.n	8028502 <tSimplePoly_noteOff+0xee>
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
 802851a:	692a      	ldr	r2, [r5, #16]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 802851c:	eb05 01c3 	add.w	r1, r5, r3, lsl #3
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
 8028520:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
                    poly->voices[deactivatedVoice][0] = noteToTest; //set the newly free voice to use the old stolen note
 8028524:	59d2      	ldr	r2, [r2, r7]
 8028526:	6013      	str	r3, [r2, #0]
                    poly->voices[deactivatedVoice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 8028528:	692a      	ldr	r2, [r5, #16]
 802852a:	6a09      	ldr	r1, [r1, #32]
 802852c:	59d2      	ldr	r2, [r2, r7]
 802852e:	6051      	str	r1, [r2, #4]
                    poly->voices[deactivatedVoice][2] = noteToTest;
 8028530:	692a      	ldr	r2, [r5, #16]
 8028532:	59d2      	ldr	r2, [r2, r7]
 8028534:	6093      	str	r3, [r2, #8]
                    poly->notes[noteToTest][0] = deactivatedVoice; //mark that it is no longer stolen and is now active
 8028536:	6060      	str	r0, [r4, #4]
 8028538:	e79d      	b.n	8028476 <tSimplePoly_noteOff+0x62>
 802853a:	3801      	subs	r0, #1
 802853c:	e7c4      	b.n	80284c8 <tSimplePoly_noteOff+0xb4>
            poly->voices[i][0] = -1;
 802853e:	6010      	str	r0, [r2, #0]
            poly->voices[i][1] = 0;
 8028540:	2700      	movs	r7, #0
 8028542:	692b      	ldr	r3, [r5, #16]
 8028544:	681b      	ldr	r3, [r3, #0]
 8028546:	605f      	str	r7, [r3, #4]
    if (poly->recover_stolen)
 8028548:	69a8      	ldr	r0, [r5, #24]
 802854a:	2800      	cmp	r0, #0
 802854c:	d095      	beq.n	802847a <tSimplePoly_noteOff+0x66>
    for (int i = 0; i < poly->maxNumVoices; i++)
 802854e:	4638      	mov	r0, r7
 8028550:	e7c7      	b.n	80284e2 <tSimplePoly_noteOff+0xce>
        if (ns->data[i] == noteVal)    return i;
 8028552:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
 8028554:	2600      	movs	r6, #0
 8028556:	e797      	b.n	8028488 <tSimplePoly_noteOff+0x74>

08028558 <tSimplePoly_deactivateVoice>:


void tSimplePoly_deactivateVoice(tSimplePoly* const polyh, uint8_t voice)
{
 8028558:	b4f0      	push	{r4, r5, r6, r7}
    _tSimplePoly* poly = *polyh;
 802855a:	6803      	ldr	r3, [r0, #0]

    if (poly->voices[voice][0] == -2) //only do this if the voice is waiting for deactivation (not already reassigned while waiting)
 802855c:	b208      	sxth	r0, r1
 802855e:	691a      	ldr	r2, [r3, #16]
 8028560:	f852 4020 	ldr.w	r4, [r2, r0, lsl #2]
 8028564:	6822      	ldr	r2, [r4, #0]
 8028566:	3202      	adds	r2, #2
 8028568:	d001      	beq.n	802856e <tSimplePoly_deactivateVoice+0x16>
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
                }
            }
        }
    }
}
 802856a:	bcf0      	pop	{r4, r5, r6, r7}
 802856c:	4770      	bx	lr
        poly->voices[voice][0] = -1;
 802856e:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8028572:	0085      	lsls	r5, r0, #2
        poly->voices[voice][1] = 0;
 8028574:	2200      	movs	r2, #0
        poly->voices[voice][0] = -1;
 8028576:	6026      	str	r6, [r4, #0]
        poly->voices[voice][1] = 0;
 8028578:	691c      	ldr	r4, [r3, #16]
 802857a:	f854 0020 	ldr.w	r0, [r4, r0, lsl #2]
 802857e:	6042      	str	r2, [r0, #4]
        if (poly->recover_stolen)
 8028580:	6998      	ldr	r0, [r3, #24]
 8028582:	2800      	cmp	r0, #0
 8028584:	d0f1      	beq.n	802856a <tSimplePoly_deactivateVoice+0x12>
    _tStack* ns = *stack;
 8028586:	6858      	ldr	r0, [r3, #4]
    return ns->size;
 8028588:	f8b0 6206 	ldrh.w	r6, [r0, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 802858c:	2e00      	cmp	r6, #0
 802858e:	d0ec      	beq.n	802856a <tSimplePoly_deactivateVoice+0x12>
 8028590:	f240 3c90 	movw	ip, #912	; 0x390
 8028594:	4607      	mov	r7, r0
 8028596:	f2c2 0c00 	movt	ip, #8192	; 0x2000
    return ns->data[which];
 802859a:	eb00 0082 	add.w	r0, r0, r2, lsl #2
                noteToTest = tStack_get(&poly->stack, j);
 802859e:	f9b0 0004 	ldrsh.w	r0, [r0, #4]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 80285a2:	eb03 04c0 	add.w	r4, r3, r0, lsl #3
                noteToTest = tStack_get(&poly->stack, j);
 80285a6:	f8ac 0000 	strh.w	r0, [ip]
                if (poly->notes[noteToTest][0] == -3) //if there is a stolen note waiting (marked inactive but on the stack)
 80285aa:	69e4      	ldr	r4, [r4, #28]
 80285ac:	3403      	adds	r4, #3
 80285ae:	d004      	beq.n	80285ba <tSimplePoly_deactivateVoice+0x62>
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80285b0:	3201      	adds	r2, #1
 80285b2:	42b2      	cmp	r2, r6
 80285b4:	dad9      	bge.n	802856a <tSimplePoly_deactivateVoice+0x12>
{
 80285b6:	4638      	mov	r0, r7
 80285b8:	e7ef      	b.n	802859a <tSimplePoly_deactivateVoice+0x42>
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
 80285ba:	691c      	ldr	r4, [r3, #16]
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80285bc:	3201      	adds	r2, #1
                    poly->voices[voice][0] = noteToTest; //set the newly free voice to use the old stolen note
 80285be:	5964      	ldr	r4, [r4, r5]
 80285c0:	6020      	str	r0, [r4, #0]
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 80285c2:	f9bc 0000 	ldrsh.w	r0, [ip]
 80285c6:	691c      	ldr	r4, [r3, #16]
 80285c8:	eb03 06c0 	add.w	r6, r3, r0, lsl #3
 80285cc:	5967      	ldr	r7, [r4, r5]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
 80285ce:	4634      	mov	r4, r6
                    poly->voices[voice][1] = poly->notes[noteToTest][1]; // set the velocity of the voice to be the velocity of that note
 80285d0:	6a36      	ldr	r6, [r6, #32]
 80285d2:	607e      	str	r6, [r7, #4]
                    poly->voices[voice][2] = noteToTest;
 80285d4:	691e      	ldr	r6, [r3, #16]
 80285d6:	5976      	ldr	r6, [r6, r5]
 80285d8:	60b0      	str	r0, [r6, #8]
                    poly->notes[noteToTest][0] = voice; //mark that it is no longer stolen and is now active
 80285da:	61e1      	str	r1, [r4, #28]
 80285dc:	685f      	ldr	r7, [r3, #4]
 80285de:	f8b7 6206 	ldrh.w	r6, [r7, #518]	; 0x206
            for (int j = 0; j < tStack_getSize(&poly->stack); ++j)
 80285e2:	4296      	cmp	r6, r2
 80285e4:	ddc1      	ble.n	802856a <tSimplePoly_deactivateVoice+0x12>
{
 80285e6:	4638      	mov	r0, r7
 80285e8:	e7d7      	b.n	802859a <tSimplePoly_deactivateVoice+0x42>
 80285ea:	bf00      	nop

080285ec <tSimplePoly_markPendingNoteOff>:
    return voiceWithThatNote;
}


int tSimplePoly_markPendingNoteOff(tSimplePoly* const polyh, uint8_t note)
{
 80285ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    _tSimplePoly* poly = *polyh;
 80285f0:	6805      	ldr	r5, [r0, #0]
    _tStack* ns = *stack;
 80285f2:	f8d5 c004 	ldr.w	ip, [r5, #4]
    for (int i = 0; i < ns->size; i++)
 80285f6:	f8bc 0206 	ldrh.w	r0, [ip, #518]	; 0x206
 80285fa:	b170      	cbz	r0, 802861a <tSimplePoly_markPendingNoteOff+0x2e>
        if (ns->data[i] == noteVal)    return i;
 80285fc:	f8dc 3004 	ldr.w	r3, [ip, #4]
 8028600:	428b      	cmp	r3, r1
 8028602:	d05c      	beq.n	80286be <tSimplePoly_markPendingNoteOff+0xd2>
 8028604:	f10c 0304 	add.w	r3, ip, #4
    for (int i = 0; i < ns->size; i++)
 8028608:	2600      	movs	r6, #0
 802860a:	e003      	b.n	8028614 <tSimplePoly_markPendingNoteOff+0x28>
        if (ns->data[i] == noteVal)    return i;
 802860c:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8028610:	4291      	cmp	r1, r2
 8028612:	d006      	beq.n	8028622 <tSimplePoly_markPendingNoteOff+0x36>
    for (int i = 0; i < ns->size; i++)
 8028614:	3601      	adds	r6, #1
 8028616:	42b0      	cmp	r0, r6
 8028618:	d1f8      	bne.n	802860c <tSimplePoly_markPendingNoteOff+0x20>
    int deactivatedVoice = -1;
 802861a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
        }


    }
    return deactivatedVoice;
}
 802861e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        for (k = 0; k < (ns->size - foundIndex); k++)
 8028622:	eba0 0806 	sub.w	r8, r0, r6
 8028626:	f1b8 0f00 	cmp.w	r8, #0
 802862a:	dd46      	ble.n	80286ba <tSimplePoly_markPendingNoteOff+0xce>
            if ((k+foundIndex) >= (ns->capacity - 1))
 802862c:	f8bc e208 	ldrh.w	lr, [ip, #520]	; 0x208
 8028630:	2200      	movs	r2, #0
                    ns->data[k + foundIndex + 1] = -1;
 8028632:	f04f 39ff 	mov.w	r9, #4294967295	; 0xffffffff
 8028636:	3801      	subs	r0, #1
            if ((k+foundIndex) >= (ns->capacity - 1))
 8028638:	4613      	mov	r3, r2
 802863a:	44ce      	add	lr, r9
 802863c:	e006      	b.n	802864c <tSimplePoly_markPendingNoteOff+0x60>
        for (k = 0; k < (ns->size - foundIndex); k++)
 802863e:	3201      	adds	r2, #1
                ns->data[k + foundIndex] = -1;
 8028640:	f8c4 9004 	str.w	r9, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8028644:	b2d2      	uxtb	r2, r2
 8028646:	4590      	cmp	r8, r2
 8028648:	4613      	mov	r3, r2
 802864a:	dd0f      	ble.n	802866c <tSimplePoly_markPendingNoteOff+0x80>
            if ((k+foundIndex) >= (ns->capacity - 1))
 802864c:	4433      	add	r3, r6
 802864e:	4573      	cmp	r3, lr
 8028650:	eb0c 0483 	add.w	r4, ip, r3, lsl #2
 8028654:	daf3      	bge.n	802863e <tSimplePoly_markPendingNoteOff+0x52>
        for (k = 0; k < (ns->size - foundIndex); k++)
 8028656:	3201      	adds	r2, #1
                if ((k + foundIndex) == (ns->size - 1))
 8028658:	4283      	cmp	r3, r0
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 802865a:	68a7      	ldr	r7, [r4, #8]
        for (k = 0; k < (ns->size - foundIndex); k++)
 802865c:	b2d2      	uxtb	r2, r2
                    ns->data[k + foundIndex + 1] = -1;
 802865e:	bf08      	it	eq
 8028660:	f8c4 9008 	streq.w	r9, [r4, #8]
                ns->data[k + foundIndex] = ns->data[k + foundIndex + 1];
 8028664:	6067      	str	r7, [r4, #4]
        for (k = 0; k < (ns->size - foundIndex); k++)
 8028666:	4590      	cmp	r8, r2
 8028668:	4613      	mov	r3, r2
 802866a:	dcef      	bgt.n	802864c <tSimplePoly_markPendingNoteOff+0x60>
        poly->notes[note][0] = -2;
 802866c:	eb05 03c1 	add.w	r3, r5, r1, lsl #3
 8028670:	f06f 0201 	mvn.w	r2, #1
        ns->size--;
 8028674:	f8ac 0206 	strh.w	r0, [ip, #518]	; 0x206
        poly->notes[note][0] = -2;
 8028678:	61da      	str	r2, [r3, #28]
        for (int i = 0; i < poly->maxNumVoices; i++)
 802867a:	68ee      	ldr	r6, [r5, #12]
 802867c:	2e00      	cmp	r6, #0
 802867e:	ddcc      	ble.n	802861a <tSimplePoly_markPendingNoteOff+0x2e>
            if (poly->voices[i][0] == note)
 8028680:	692b      	ldr	r3, [r5, #16]
 8028682:	681a      	ldr	r2, [r3, #0]
 8028684:	6810      	ldr	r0, [r2, #0]
 8028686:	4281      	cmp	r1, r0
 8028688:	d00c      	beq.n	80286a4 <tSimplePoly_markPendingNoteOff+0xb8>
        for (int i = 0; i < poly->maxNumVoices; i++)
 802868a:	2000      	movs	r0, #0
 802868c:	e004      	b.n	8028698 <tSimplePoly_markPendingNoteOff+0xac>
            if (poly->voices[i][0] == note)
 802868e:	f853 2f04 	ldr.w	r2, [r3, #4]!
 8028692:	6814      	ldr	r4, [r2, #0]
 8028694:	428c      	cmp	r4, r1
 8028696:	d007      	beq.n	80286a8 <tSimplePoly_markPendingNoteOff+0xbc>
        for (int i = 0; i < poly->maxNumVoices; i++)
 8028698:	3001      	adds	r0, #1
 802869a:	42b0      	cmp	r0, r6
 802869c:	ea4f 0780 	mov.w	r7, r0, lsl #2
 80286a0:	d1f5      	bne.n	802868e <tSimplePoly_markPendingNoteOff+0xa2>
 80286a2:	e7ba      	b.n	802861a <tSimplePoly_markPendingNoteOff+0x2e>
 80286a4:	2000      	movs	r0, #0
            if (poly->voices[i][0] == note)
 80286a6:	4607      	mov	r7, r0
                poly->voices[i][0] = -2;
 80286a8:	f06f 0301 	mvn.w	r3, #1
                poly->voices[i][1] = 0;
 80286ac:	2100      	movs	r1, #0
                poly->voices[i][0] = -2;
 80286ae:	6013      	str	r3, [r2, #0]
                poly->voices[i][1] = 0;
 80286b0:	692b      	ldr	r3, [r5, #16]
 80286b2:	59db      	ldr	r3, [r3, r7]
 80286b4:	6059      	str	r1, [r3, #4]
}
 80286b6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80286ba:	3801      	subs	r0, #1
 80286bc:	e7d6      	b.n	802866c <tSimplePoly_markPendingNoteOff+0x80>
        if (ns->data[i] == noteVal)    return i;
 80286be:	4680      	mov	r8, r0
    for (int i = 0; i < ns->size; i++)
 80286c0:	2600      	movs	r6, #0
 80286c2:	e7b3      	b.n	802862c <tSimplePoly_markPendingNoteOff+0x40>

080286c4 <tSimplePoly_setNumVoices>:

void tSimplePoly_setNumVoices(tSimplePoly* const polyh, uint8_t numVoices)
{
    _tSimplePoly* poly = *polyh;
 80286c4:	6802      	ldr	r2, [r0, #0]
    poly->numVoices = (numVoices > poly->maxNumVoices) ? poly->maxNumVoices : numVoices;
 80286c6:	68d3      	ldr	r3, [r2, #12]
 80286c8:	4299      	cmp	r1, r3
 80286ca:	bfa8      	it	ge
 80286cc:	4619      	movge	r1, r3
 80286ce:	6091      	str	r1, [r2, #8]
}
 80286d0:	4770      	bx	lr
 80286d2:	bf00      	nop

080286d4 <tSimplePoly_getNumVoices>:


int tSimplePoly_getNumVoices(tSimplePoly* const polyh)
{
    _tSimplePoly* poly = *polyh;
    return poly->numVoices;
 80286d4:	6803      	ldr	r3, [r0, #0]
}
 80286d6:	6898      	ldr	r0, [r3, #8]
 80286d8:	4770      	bx	lr
 80286da:	bf00      	nop

080286dc <tSimplePoly_getNumActiveVoices>:

int tSimplePoly_getNumActiveVoices(tSimplePoly* const polyh)
{
 80286dc:	b508      	push	{r3, lr}
    _tSimplePoly* poly = *polyh;
 80286de:	6803      	ldr	r3, [r0, #0]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 80286e0:	2100      	movs	r1, #0
    return ns->size;
 80286e2:	685a      	ldr	r2, [r3, #4]
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 80286e4:	ee00 1a10 	vmov	s0, r1
 80286e8:	ed93 1a02 	vldr	s2, [r3, #8]
    return ns->size;
 80286ec:	f8b2 3206 	ldrh.w	r3, [r2, #518]	; 0x206
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 80286f0:	eeb8 1ac1 	vcvt.f32.s32	s2, s2
    return ns->size;
 80286f4:	ee00 3a90 	vmov	s1, r3
    return LEAF_clip(0, tStack_getSize(&poly->stack), poly->numVoices);
 80286f8:	eef8 0ae0 	vcvt.f32.s32	s1, s1
 80286fc:	f7ff f95c 	bl	80279b8 <LEAF_clip>
}
 8028700:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 8028704:	ee17 0a90 	vmov	r0, s15
 8028708:	bd08      	pop	{r3, pc}
 802870a:	bf00      	nop

0802870c <tSimplePoly_getPitch>:


int tSimplePoly_getPitch(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][2];
 802870c:	6803      	ldr	r3, [r0, #0]
 802870e:	691b      	ldr	r3, [r3, #16]
 8028710:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 8028714:	6898      	ldr	r0, [r3, #8]
 8028716:	4770      	bx	lr

08028718 <tSimplePoly_getPitchAndCheckActive>:

//this one returns negative one if the voice is inactive
int tSimplePoly_getPitchAndCheckActive(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][0];
 8028718:	6803      	ldr	r3, [r0, #0]
 802871a:	691b      	ldr	r3, [r3, #16]
 802871c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 8028720:	6818      	ldr	r0, [r3, #0]
 8028722:	4770      	bx	lr

08028724 <tSimplePoly_getVelocity>:

int tSimplePoly_getVelocity(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return poly->voices[voice][1];
 8028724:	6803      	ldr	r3, [r0, #0]
 8028726:	691b      	ldr	r3, [r3, #16]
 8028728:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
}
 802872c:	6858      	ldr	r0, [r3, #4]
 802872e:	4770      	bx	lr

08028730 <tSimplePoly_isOn>:

int tSimplePoly_isOn(tSimplePoly* const polyh, uint8_t voice)
{
    _tSimplePoly* poly = *polyh;
    return (poly->voices[voice][0] > 0) ? 1 : 0;
 8028730:	6803      	ldr	r3, [r0, #0]
 8028732:	691b      	ldr	r3, [r3, #16]
 8028734:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
 8028738:	6818      	ldr	r0, [r3, #0]
}
 802873a:	2800      	cmp	r0, #0
 802873c:	bfd4      	ite	le
 802873e:	2000      	movle	r0, #0
 8028740:	2001      	movgt	r0, #1
 8028742:	4770      	bx	lr

08028744 <tCycle_initToPool>:
{
    tCycle_initToPool(cy, &leaf.mempool);
}

void    tCycle_initToPool   (tCycle* const cy, tMempool* const mp)
{
 8028744:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
 8028746:	680c      	ldr	r4, [r1, #0]
{
 8028748:	4605      	mov	r5, r0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 802874a:	2010      	movs	r0, #16
 802874c:	4621      	mov	r1, r4
 802874e:	f7ff fb4d 	bl	8027dec <mpool_alloc>
    c->mempool = m;
    
    c->inc      =  0.0f;
 8028752:	2300      	movs	r3, #0
    _tCycle* c = *cy = (_tCycle*) mpool_alloc(sizeof(_tCycle), m);
 8028754:	6028      	str	r0, [r5, #0]
    c->mempool = m;
 8028756:	6004      	str	r4, [r0, #0]
    c->inc      =  0.0f;
 8028758:	6083      	str	r3, [r0, #8]
    c->phase    =  0.0f;
 802875a:	6043      	str	r3, [r0, #4]
}
 802875c:	bd38      	pop	{r3, r4, r5, pc}
 802875e:	bf00      	nop

08028760 <tCycle_free>:

void    tCycle_free (tCycle* const cy)
{
    _tCycle* c = *cy;
 8028760:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)c, c->mempool);
 8028762:	6801      	ldr	r1, [r0, #0]
 8028764:	f7ff bbec 	b.w	8027f40 <mpool_free>

08028768 <tCycle_setFreq>:
{
    _tCycle* c = *cy;
    
    c->freq  = freq;

    c->inc = freq * leaf.invSampleRate;
 8028768:	f249 43a0 	movw	r3, #38048	; 0x94a0
    _tCycle* c = *cy;
 802876c:	6802      	ldr	r2, [r0, #0]
    c->inc = freq * leaf.invSampleRate;
 802876e:	f2c2 0301 	movt	r3, #8193	; 0x2001
    c->freq  = freq;
 8028772:	ed82 0a03 	vstr	s0, [r2, #12]
    c->inc = freq * leaf.invSampleRate;
 8028776:	edd3 7a01 	vldr	s15, [r3, #4]
 802877a:	ee27 0a80 	vmul.f32	s0, s15, s0
 802877e:	ed82 0a02 	vstr	s0, [r2, #8]
}
 8028782:	4770      	bx	lr

08028784 <tCycle_tick>:

//need to check bounds and wrap table properly to allow through-zero FM
float   tCycle_tick(tCycle* const cy)
{
    _tCycle* c = *cy;
 8028784:	6803      	ldr	r3, [r0, #0]
    float samp0;
    float samp1;
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8028786:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
 802878a:	ed93 7a01 	vldr	s14, [r3, #4]
 802878e:	edd3 7a02 	vldr	s15, [r3, #8]
 8028792:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8028796:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
 802879a:	ed83 7a01 	vstr	s14, [r3, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 802879e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287a2:	db44      	blt.n	802882e <tCycle_tick+0xaa>
 80287a4:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 80287a8:	eeb4 7ac6 	vcmpe.f32	s14, s12
 80287ac:	ee77 7a66 	vsub.f32	s15, s14, s13
 80287b0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287b4:	eeb0 7a67 	vmov.f32	s14, s15
 80287b8:	daf6      	bge.n	80287a8 <tCycle_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
 80287ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80287be:	edc3 7a01 	vstr	s15, [r3, #4]
 80287c2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287c6:	d539      	bpl.n	802883c <tCycle_tick+0xb8>
 80287c8:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 80287cc:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 80287d0:	eef4 7ae6 	vcmpe.f32	s15, s13
 80287d4:	ee37 7a86 	vadd.f32	s14, s15, s12
 80287d8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80287dc:	eef0 7a47 	vmov.f32	s15, s14
 80287e0:	d4f6      	bmi.n	80287d0 <tCycle_tick+0x4c>
 80287e2:	ed83 7a01 	vstr	s14, [r3, #4]

    // Wavetable synthesis

	temp = SINE_TABLE_SIZE * c->phase;
 80287e6:	f04f 428a 	mov.w	r2, #1157627904	; 0x45000000
	intPart = (int)temp;
	fracPart = temp - (float)intPart;
	samp0 = __leaf_table_sinewave[intPart];
 80287ea:	f64d 03fc 	movw	r3, #55548	; 0xd8fc
	temp = SINE_TABLE_SIZE * c->phase;
 80287ee:	ee07 2a90 	vmov	s15, r2
	samp0 = __leaf_table_sinewave[intPart];
 80287f2:	f6c0 0304 	movt	r3, #2052	; 0x804
	temp = SINE_TABLE_SIZE * c->phase;
 80287f6:	ee27 7a27 	vmul.f32	s14, s14, s15
	intPart = (int)temp;
 80287fa:	eefd 7ac7 	vcvt.s32.f32	s15, s14
 80287fe:	ee17 2a90 	vmov	r2, s15
	fracPart = temp - (float)intPart;
 8028802:	eef8 7ae7 	vcvt.f32.s32	s15, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8028806:	1c51      	adds	r1, r2, #1
	samp0 = __leaf_table_sinewave[intPart];
 8028808:	eb03 0082 	add.w	r0, r3, r2, lsl #2
	fracPart = temp - (float)intPart;
 802880c:	ee37 7a67 	vsub.f32	s14, s14, s15
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8028810:	f5b1 6f00 	cmp.w	r1, #2048	; 0x800
	samp0 = __leaf_table_sinewave[intPart];
 8028814:	ed90 0a00 	vldr	s0, [r0]
	if (++intPart >= SINE_TABLE_SIZE) intPart = 0;
 8028818:	bfa8      	it	ge
 802881a:	2100      	movge	r1, #0
	samp1 = __leaf_table_sinewave[intPart];
 802881c:	eb03 0381 	add.w	r3, r3, r1, lsl #2

    return (samp0 + (samp1 - samp0) * fracPart);
 8028820:	edd3 7a00 	vldr	s15, [r3]
 8028824:	ee77 7ac0 	vsub.f32	s15, s15, s0
}
 8028828:	eea7 0a87 	vfma.f32	s0, s15, s14
 802882c:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 802882e:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
 8028832:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8028836:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802883a:	d4c5      	bmi.n	80287c8 <tCycle_tick+0x44>
 802883c:	eeb0 7a67 	vmov.f32	s14, s15
 8028840:	e7d1      	b.n	80287e6 <tCycle_tick+0x62>
 8028842:	bf00      	nop

08028844 <tSawtooth_initToPool>:
{
    tSawtooth_initToPool(cy, &leaf.mempool);
}

void    tSawtooth_initToPool    (tSawtooth* const cy, tMempool* const mp)
{
 8028844:	b538      	push	{r3, r4, r5, lr}
    _tMempool* m = *mp;
 8028846:	680d      	ldr	r5, [r1, #0]
{
 8028848:	4604      	mov	r4, r0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
 802884a:	2018      	movs	r0, #24
 802884c:	4629      	mov	r1, r5
 802884e:	f7ff facd 	bl	8027dec <mpool_alloc>
    c->mempool = m;
    
    c->inc      = 0.0f;
 8028852:	2200      	movs	r2, #0
{
    _tSawtooth* c = *cy;
    
    c->freq  = freq;
    
    c->inc = c->freq * leaf.invSampleRate;
 8028854:	f249 41a0 	movw	r1, #38048	; 0x94a0
    _tSawtooth* c = *cy = (_tSawtooth*) mpool_alloc(sizeof(_tSawtooth), m);
 8028858:	6020      	str	r0, [r4, #0]
    c->freq  = freq;
 802885a:	4613      	mov	r3, r2
    c->mempool = m;
 802885c:	6005      	str	r5, [r0, #0]
    c->inc = c->freq * leaf.invSampleRate;
 802885e:	f2c2 0101 	movt	r1, #8193	; 0x2001
    c->phase    = 0.0f;
 8028862:	6042      	str	r2, [r0, #4]
    c->freq  = freq;
 8028864:	f2c4 335c 	movt	r3, #17244	; 0x435c
    c->w = c->freq * INV_20;
    for (c->oct = 0; c->w > 2.0f; c->oct++)
    {
        c->w = 0.5f * c->w;
    }
    c->w = 2.0f - c->w;
 8028868:	2500      	movs	r5, #0
    c->inc = c->freq * leaf.invSampleRate;
 802886a:	ed91 7a01 	vldr	s14, [r1, #4]
    c->freq  = freq;
 802886e:	ee07 3a90 	vmov	s15, r3
    c->inc      = 0.0f;
 8028872:	6082      	str	r2, [r0, #8]
    c->w = 2.0f - c->w;
 8028874:	f6c3 7520 	movt	r5, #16160	; 0x3f20
    _tSawtooth* c = *cy;
 8028878:	6823      	ldr	r3, [r4, #0]
    c->inc = c->freq * leaf.invSampleRate;
 802887a:	ee27 7a27 	vmul.f32	s14, s14, s15
 802887e:	2203      	movs	r2, #3
    c->freq  = freq;
 8028880:	edc3 7a03 	vstr	s15, [r3, #12]
 8028884:	611a      	str	r2, [r3, #16]
    c->inc = c->freq * leaf.invSampleRate;
 8028886:	ed83 7a02 	vstr	s14, [r3, #8]
    c->w = 2.0f - c->w;
 802888a:	615d      	str	r5, [r3, #20]
}
 802888c:	bd38      	pop	{r3, r4, r5, pc}
 802888e:	bf00      	nop

08028890 <tSawtooth_free>:
    _tSawtooth* c = *cy;
 8028890:	6800      	ldr	r0, [r0, #0]
    mpool_free((char*)c, c->mempool);
 8028892:	6801      	ldr	r1, [r0, #0]
 8028894:	f7ff bb54 	b.w	8027f40 <mpool_free>

08028898 <tSawtooth_setFreq>:
    c->inc = c->freq * leaf.invSampleRate;
 8028898:	f249 41a0 	movw	r1, #38048	; 0x94a0
    c->w = c->freq * INV_20;
 802889c:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    _tSawtooth* c = *cy;
 80288a0:	6802      	ldr	r2, [r0, #0]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288a2:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
    c->inc = c->freq * leaf.invSampleRate;
 80288a6:	f2c2 0101 	movt	r1, #8193	; 0x2001
    c->w = c->freq * INV_20;
 80288aa:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
    c->freq  = freq;
 80288ae:	ed82 0a03 	vstr	s0, [r2, #12]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288b2:	2000      	movs	r0, #0
    c->inc = c->freq * leaf.invSampleRate;
 80288b4:	edd1 6a01 	vldr	s13, [r1, #4]
    c->w = c->freq * INV_20;
 80288b8:	ee07 3a10 	vmov	s14, r3
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288bc:	6110      	str	r0, [r2, #16]
    c->inc = c->freq * leaf.invSampleRate;
 80288be:	ee66 6a80 	vmul.f32	s13, s13, s0
    c->w = c->freq * INV_20;
 80288c2:	ee20 0a07 	vmul.f32	s0, s0, s14
    c->inc = c->freq * leaf.invSampleRate;
 80288c6:	edc2 6a02 	vstr	s13, [r2, #8]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288ca:	eeb4 0ae7 	vcmpe.f32	s0, s15
    c->w = c->freq * INV_20;
 80288ce:	ed82 0a05 	vstr	s0, [r2, #20]
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288d2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80288d6:	dd0c      	ble.n	80288f2 <tSawtooth_setFreq+0x5a>
        c->w = 0.5f * c->w;
 80288d8:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288dc:	2301      	movs	r3, #1
        c->w = 0.5f * c->w;
 80288de:	ee20 0a07 	vmul.f32	s0, s0, s14
    for (c->oct = 0; c->w > 2.0f; c->oct++)
 80288e2:	4619      	mov	r1, r3
 80288e4:	3301      	adds	r3, #1
 80288e6:	eeb4 0ae7 	vcmpe.f32	s0, s15
 80288ea:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80288ee:	dcf6      	bgt.n	80288de <tSawtooth_setFreq+0x46>
 80288f0:	6111      	str	r1, [r2, #16]
    c->w = 2.0f - c->w;
 80288f2:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 80288f6:	ee37 0ac0 	vsub.f32	s0, s15, s0
 80288fa:	ed82 0a05 	vstr	s0, [r2, #20]
}
 80288fe:	4770      	bx	lr

08028900 <tSawtooth_tick>:

float   tSawtooth_tick(tSawtooth* const cy)
{
    _tSawtooth* c = *cy;
 8028900:	6802      	ldr	r2, [r0, #0]
    
    // Phasor increment
    c->phase += c->inc;
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8028902:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
    c->phase += c->inc;
 8028906:	ed92 7a01 	vldr	s14, [r2, #4]
 802890a:	edd2 7a02 	vldr	s15, [r2, #8]
 802890e:	ee37 7a27 	vadd.f32	s14, s14, s15
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 8028912:	eeb4 7ae6 	vcmpe.f32	s14, s13
    c->phase += c->inc;
 8028916:	ed82 7a01 	vstr	s14, [r2, #4]
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 802891a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802891e:	db3f      	blt.n	80289a0 <tSawtooth_tick+0xa0>
 8028920:	eeb0 6a00 	vmov.f32	s12, #0	; 0x40000000  2.0
 8028924:	eeb4 7ac6 	vcmpe.f32	s14, s12
 8028928:	ee77 7a66 	vsub.f32	s15, s14, s13
 802892c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028930:	eeb0 7a67 	vmov.f32	s14, s15
 8028934:	daf6      	bge.n	8028924 <tSawtooth_tick+0x24>
    while (c->phase < 0.0f) c->phase += 1.0f;
 8028936:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802893a:	edc2 7a01 	vstr	s15, [r2, #4]
 802893e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028942:	d534      	bpl.n	80289ae <tSawtooth_tick+0xae>
 8028944:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 8028948:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 802894c:	eef4 7ae6 	vcmpe.f32	s15, s13
 8028950:	ee37 7a86 	vadd.f32	s14, s15, s12
 8028954:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028958:	eef0 7a47 	vmov.f32	s15, s14
 802895c:	d4f6      	bmi.n	802894c <tSawtooth_tick+0x4c>
 802895e:	ed82 7a01 	vstr	s14, [r2, #4]
    
    float out = 0.0f;
    
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
 8028962:	eef0 7a47 	vmov.f32	s15, s14
    
    // Wavetable synthesis
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8028966:	6910      	ldr	r0, [r2, #16]
 8028968:	ed92 7a05 	vldr	s14, [r2, #20]
 802896c:	f647 01fc 	movw	r1, #30972	; 0x78fc
 8028970:	1c42      	adds	r2, r0, #1
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
 8028972:	eefe 7aea 	vcvt.s32.f32	s15, s15, #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8028976:	f6c0 0103 	movt	r1, #2051	; 0x803
    int idx = (int)(c->phase * SAW_TABLE_SIZE);
 802897a:	ee17 3a90 	vmov	r3, s15
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 802897e:	eb03 20c0 	add.w	r0, r3, r0, lsl #11
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8028982:	eb03 23c2 	add.w	r3, r3, r2, lsl #11
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8028986:	eb01 0080 	add.w	r0, r1, r0, lsl #2
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 802898a:	eb01 0383 	add.w	r3, r1, r3, lsl #2
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 802898e:	edd0 7a00 	vldr	s15, [r0]
    out = __leaf_table_sawtooth[c->oct+1][idx] +
 8028992:	ed93 0a00 	vldr	s0, [r3]
         (__leaf_table_sawtooth[c->oct][idx] - __leaf_table_sawtooth[c->oct+1][idx]) * c->w;
 8028996:	ee77 7ac0 	vsub.f32	s15, s15, s0
    
    return out;
}
 802899a:	eea7 0a87 	vfma.f32	s0, s15, s14
 802899e:	4770      	bx	lr
    while (c->phase >= 1.0f) c->phase -= 1.0f;
 80289a0:	eef0 7a47 	vmov.f32	s15, s14
    while (c->phase < 0.0f) c->phase += 1.0f;
 80289a4:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 80289a8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80289ac:	d4ca      	bmi.n	8028944 <tSawtooth_tick+0x44>
 80289ae:	eeb0 7a67 	vmov.f32	s14, s15
 80289b2:	e7d6      	b.n	8028962 <tSawtooth_tick+0x62>

080289b4 <tNoise_initToPool>:
{
    tNoise_initToPool(ns, type, &leaf.mempool);
}

void    tNoise_initToPool   (tNoise* const ns, NoiseType type, tMempool* const mp)
{
 80289b4:	b570      	push	{r4, r5, r6, lr}
    _tMempool* m = *mp;
 80289b6:	6814      	ldr	r4, [r2, #0]
{
 80289b8:	4606      	mov	r6, r0
 80289ba:	460d      	mov	r5, r1
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
 80289bc:	2018      	movs	r0, #24
 80289be:	4621      	mov	r1, r4
 80289c0:	f7ff fa14 	bl	8027dec <mpool_alloc>
    n->mempool = m;
    
    n->type = type;
    n->rand = leaf.random;
 80289c4:	f249 43a0 	movw	r3, #38048	; 0x94a0
    _tNoise* n = *ns = (_tNoise*) mpool_alloc(sizeof(_tNoise), m);
 80289c8:	6030      	str	r0, [r6, #0]
    n->rand = leaf.random;
 80289ca:	f2c2 0301 	movt	r3, #8193	; 0x2001
    n->mempool = m;
 80289ce:	6004      	str	r4, [r0, #0]
    n->type = type;
 80289d0:	7105      	strb	r5, [r0, #4]
    n->rand = leaf.random;
 80289d2:	691b      	ldr	r3, [r3, #16]
 80289d4:	6143      	str	r3, [r0, #20]
}
 80289d6:	bd70      	pop	{r4, r5, r6, pc}

080289d8 <tNoise_free>:

void    tNoise_free (tNoise* const ns)
{
    _tNoise* n = *ns;
 80289d8:	6800      	ldr	r0, [r0, #0]
    
    mpool_free((char*)n, n->mempool);
 80289da:	6801      	ldr	r1, [r0, #0]
 80289dc:	f7ff bab0 	b.w	8027f40 <mpool_free>

080289e0 <tNoise_tick>:
}

float   tNoise_tick(tNoise* const ns)
{
 80289e0:	b510      	push	{r4, lr}
    _tNoise* n = *ns;
 80289e2:	6804      	ldr	r4, [r0, #0]
    
    float rand = (n->rand() * 2.0f) - 1.0f;
 80289e4:	6963      	ldr	r3, [r4, #20]
 80289e6:	4798      	blx	r3
 80289e8:	eeb0 7a00 	vmov.f32	s14, #0	; 0x40000000  2.0
 80289ec:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
    
    if (n->type == PinkNoise)
 80289f0:	7923      	ldrb	r3, [r4, #4]
 80289f2:	2b01      	cmp	r3, #1
    float rand = (n->rand() * 2.0f) - 1.0f;
 80289f4:	eee0 7a07 	vfma.f32	s15, s0, s14
 80289f8:	eeb0 0a67 	vmov.f32	s0, s15
    if (n->type == PinkNoise)
 80289fc:	d000      	beq.n	8028a00 <tNoise_tick+0x20>
    }
    else // WhiteNoise
    {
        return rand;
    }
}
 80289fe:	bd10      	pop	{r4, pc}
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a00:	f64d 03a1 	movw	r3, #55457	; 0xd8a1
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a04:	f24d 02ff 	movw	r2, #53503	; 0xd0ff
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a08:	f246 50fe 	movw	r0, #26110	; 0x65fe
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a0c:	f248 712b 	movw	r1, #34603	; 0x872b
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a10:	f6c3 53ca 	movt	r3, #15818	; 0x3dca
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a14:	f6c3 6297 	movt	r2, #16023	; 0x3e97
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a18:	f6c3 707f 	movt	r0, #16255	; 0x3f7f
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a1c:	f6c3 7176 	movt	r1, #16246	; 0x3f76
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a20:	ee07 3a90 	vmov	s15, r3
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a24:	ee06 2a90 	vmov	s13, r2
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a28:	ed94 5a02 	vldr	s10, [r4, #8]
 8028a2c:	ee06 0a10 	vmov	s12, r0
 8028a30:	ee60 7a27 	vmul.f32	s15, s0, s15
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a34:	edd4 5a03 	vldr	s11, [r4, #12]
 8028a38:	ee60 6a26 	vmul.f32	s13, s0, s13
 8028a3c:	ee07 1a10 	vmov	s14, r1
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a40:	f64b 6397 	movw	r3, #48791	; 0xbe97
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a44:	f643 4236 	movw	r2, #15414	; 0x3c36
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a48:	eee5 7a06 	vfma.f32	s15, s10, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a4c:	f64e 3185 	movw	r1, #60293	; 0xeb85
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a50:	eee5 6a87 	vfma.f32	s13, s11, s14
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a54:	f6c3 7386 	movt	r3, #16262	; 0x3f86
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a58:	f6c3 623d 	movt	r2, #15933	; 0x3e3d
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a5c:	f6c3 7111 	movt	r1, #16145	; 0x3f11
 8028a60:	ee07 3a10 	vmov	s14, r3
 8028a64:	ed94 5a04 	vldr	s10, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a68:	ee06 2a10 	vmov	s12, r2
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a6c:	ee05 1a90 	vmov	s11, r1
 8028a70:	ee20 7a07 	vmul.f32	s14, s0, s14
        return (tmp * 0.05f);
 8028a74:	f64c 43cd 	movw	r3, #52429	; 0xcccd
        n->pinkb0 = 0.99765f * n->pinkb0 + rand * 0.0990460f;
 8028a78:	edc4 7a02 	vstr	s15, [r4, #8]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a7c:	ee77 7aa6 	vadd.f32	s15, s15, s13
        return (tmp * 0.05f);
 8028a80:	f6c3 534c 	movt	r3, #15692	; 0x3d4c
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a84:	eea5 7a25 	vfma.f32	s14, s10, s11
        n->pinkb1 = 0.96300f * n->pinkb1 + rand * 0.2965164f;
 8028a88:	edc4 6a03 	vstr	s13, [r4, #12]
        return (tmp * 0.05f);
 8028a8c:	ee06 3a90 	vmov	s13, r3
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a90:	eee0 7a06 	vfma.f32	s15, s0, s12
        n->pinkb2 = 0.57000f * n->pinkb2 + rand * 1.0526913f;
 8028a94:	ed84 7a04 	vstr	s14, [r4, #16]
        tmp = n->pinkb0 + n->pinkb1 + n->pinkb2 + rand * 0.1848f;
 8028a98:	ee37 0a87 	vadd.f32	s0, s15, s14
        return (tmp * 0.05f);
 8028a9c:	ee20 0a26 	vmul.f32	s0, s0, s13
}
 8028aa0:	bd10      	pop	{r4, pc}
 8028aa2:	bf00      	nop

08028aa4 <tComplexLivingString_initToPool>:
}

void    tComplexLivingString_initToPool    (tComplexLivingString* const pl, float freq, float pickPos, float prepPos, float prepIndex,
                                     float dampFreq, float decay, float targetLev, float levSmoothFactor,
                                     float levStrength, int levMode, tMempool* const mp)
{
 8028aa4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028aa8:	ed2d 8b0c 	vpush	{d8-d13}
 8028aac:	b083      	sub	sp, #12
    _tMempool* m = *mp;
 8028aae:	f8d2 8000 	ldr.w	r8, [r2]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
    p->mempool = m;

    p->curr=0.0f;
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028ab2:	f249 47a0 	movw	r7, #38048	; 0x94a0
{
 8028ab6:	4606      	mov	r6, r0
 8028ab8:	9100      	str	r1, [sp, #0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8028aba:	2070      	movs	r0, #112	; 0x70
 8028abc:	4641      	mov	r1, r8
{
 8028abe:	eef0 9a42 	vmov.f32	s19, s4
 8028ac2:	eef0 aa41 	vmov.f32	s21, s2
 8028ac6:	4615      	mov	r5, r2
 8028ac8:	eef0 ba43 	vmov.f32	s23, s6
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028acc:	f2c2 0701 	movt	r7, #8193	; 0x2001
{
 8028ad0:	eeb0 ca63 	vmov.f32	s24, s7
 8028ad4:	eef0 ca44 	vmov.f32	s25, s8
 8028ad8:	eeb0 da61 	vmov.f32	s26, s3
 8028adc:	eef0 da62 	vmov.f32	s27, s5
 8028ae0:	eeb0 ba40 	vmov.f32	s22, s0
 8028ae4:	eeb0 aa60 	vmov.f32	s20, s1
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8028ae8:	f7ff f980 	bl	8027dec <mpool_alloc>
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028aec:	f24d 720a 	movw	r2, #55050	; 0xd70a
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8028af0:	6030      	str	r0, [r6, #0]
    p->mempool = m;
 8028af2:	f8c0 8000 	str.w	r8, [r0]
    _tComplexLivingString* p = *pl = (_tComplexLivingString*) mpool_alloc(sizeof(_tComplexLivingString), m);
 8028af6:	4604      	mov	r4, r0
    p->curr=0.0f;
 8028af8:	2300      	movs	r3, #0
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028afa:	f6c3 4223 	movt	r2, #15395	; 0x3c23
 8028afe:	ed97 0a00 	vldr	s0, [r7]
 8028b02:	4629      	mov	r1, r5
 8028b04:	ee00 2a90 	vmov	s1, r2
    p->curr=0.0f;
 8028b08:	62a3      	str	r3, [r4, #40]	; 0x28
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028b0a:	ee80 0a0b 	vdiv.f32	s0, s0, s22
 8028b0e:	3064      	adds	r0, #100	; 0x64
 8028b10:	ee08 2a90 	vmov	s17, r2
    p->curr=0.0f;
 8028b14:	ee09 3a10 	vmov	s18, r3
    tExpSmooth_initToPool(&p->wlSmooth, leaf.sampleRate/freq, 0.01, mp); // smoother for string wavelength (not freq, to avoid expensive divisions)
 8028b18:	f7fd f9fe 	bl	8025f18 <tExpSmooth_initToPool>
void     tComplexLivingString_setFreq(tComplexLivingString* const pl, float freq)
{    // NOTE: It is faster to set wavelength in samples directly
    _tComplexLivingString* p = *pl;
    if (freq<20.0f) freq=20.0f;
    else if (freq>10000.0f) freq=10000.0f;
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b1c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8028b20:	ed97 7a00 	vldr	s14, [r7]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 8028b24:	f104 0b2c 	add.w	fp, r4, #44	; 0x2c
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b28:	f2c4 631c 	movt	r3, #17948	; 0x461c
    _tComplexLivingString* p = *pl;
 8028b2c:	6832      	ldr	r2, [r6, #0]
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b2e:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
 8028b32:	f104 0a34 	add.w	sl, r4, #52	; 0x34
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b36:	ee07 3a90 	vmov	s15, r3
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 8028b3a:	f104 0340 	add.w	r3, r4, #64	; 0x40
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8028b3e:	f102 0064 	add.w	r0, r2, #100	; 0x64
 8028b42:	eeb6 8a00 	vmov.f32	s16, #96	; 0x3f000000  0.5
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b46:	fecb 7a67 	vminnm.f32	s15, s22, s15
 8028b4a:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
 8028b4e:	ee87 0a27 	vdiv.f32	s0, s14, s15
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 8028b52:	9301      	str	r3, [sp, #4]
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
 8028b54:	f104 0930 	add.w	r9, r4, #48	; 0x30
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
 8028b58:	f104 083c 	add.w	r8, r4, #60	; 0x3c
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
 8028b5c:	f104 0738 	add.w	r7, r4, #56	; 0x38
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028b60:	ed82 0a02 	vstr	s0, [r2, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8028b64:	f7fd fa14 	bl	8025f90 <tExpSmooth_setDest>
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
 8028b68:	eef0 0a68 	vmov.f32	s1, s17
 8028b6c:	4629      	mov	r1, r5
 8028b6e:	eeb0 0a4a 	vmov.f32	s0, s20
 8028b72:	f104 0068 	add.w	r0, r4, #104	; 0x68
    p->freq = freq;
 8028b76:	ed84 ba01 	vstr	s22, [r4, #4]
    tExpSmooth_initToPool(&p->pickPosSmooth, pickPos, 0.01f, mp); // smoother for pick position
 8028b7a:	f7fd f9cd 	bl	8025f18 <tExpSmooth_initToPool>
    tExpSmooth_initToPool(&p->prepPosSmooth, prepPos, 0.01f, mp); // smoother for pick position
 8028b7e:	eef0 0a68 	vmov.f32	s1, s17
 8028b82:	4629      	mov	r1, r5
 8028b84:	eeb0 0a6a 	vmov.f32	s0, s21
 8028b88:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8028b8c:	f7fd f9c4 	bl	8025f18 <tExpSmooth_initToPool>
 8028b90:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
}

void     tComplexLivingString_setPickPos(tComplexLivingString* const pl, float pickPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
 8028b94:	6833      	ldr	r3, [r6, #0]
 8028b96:	fe8a 0a40 	vminnm.f32	s0, s20, s0
    if (pickPos<0.5f) pickPos=0.5f;
    else if (pickPos>1.f) pickPos=1.f;
    p->pickPos = pickPos;
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8028b9a:	f103 0068 	add.w	r0, r3, #104	; 0x68
 8028b9e:	fe80 0a08 	vmaxnm.f32	s0, s0, s16
    p->pickPos = pickPos;
 8028ba2:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8028ba6:	f7fd f9f3 	bl	8025f90 <tExpSmooth_setDest>
}

void     tComplexLivingString_setPrepPos(tComplexLivingString* const pl, float prepPos)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
 8028baa:	6833      	ldr	r3, [r6, #0]
 8028bac:	fe8a 0ac8 	vminnm.f32	s0, s21, s16
 8028bb0:	fe80 0a09 	vmaxnm.f32	s0, s0, s18
    if (prepPos<0.f) prepPos=0.f;
    else if (prepPos>0.5f) prepPos=0.5f;
    p->prepPos = prepPos;
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 8028bb4:	f103 006c 	add.w	r0, r3, #108	; 0x6c
    p->prepPos = prepPos;
 8028bb8:	ed83 0a04 	vstr	s0, [r3, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 8028bbc:	f7fd f9e8 	bl	8025f90 <tExpSmooth_setDest>
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 8028bc0:	4658      	mov	r0, fp
 8028bc2:	462a      	mov	r2, r5
 8028bc4:	ed94 0a02 	vldr	s0, [r4, #8]
    p->prepPos=prepPos;
 8028bc8:	edc4 aa04 	vstr	s21, [r4, #16]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 8028bcc:	f44f 6116 	mov.w	r1, #2400	; 0x960
    p->pickPos=pickPos;
 8028bd0:	ed84 aa03 	vstr	s20, [r4, #12]
    tLinearDelay_initToPool(&p->delLF,p->waveLengthInSamples, 2400, mp);
 8028bd4:	f7fa f898 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMF,p->waveLengthInSamples, 2400, mp);
 8028bd8:	4650      	mov	r0, sl
 8028bda:	462a      	mov	r2, r5
 8028bdc:	ed94 0a02 	vldr	s0, [r4, #8]
 8028be0:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028be4:	f7fa f890 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUF,p->waveLengthInSamples, 2400, mp);
 8028be8:	4648      	mov	r0, r9
 8028bea:	462a      	mov	r2, r5
 8028bec:	ed94 0a02 	vldr	s0, [r4, #8]
 8028bf0:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028bf4:	f7fa f888 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delUB,p->waveLengthInSamples, 2400, mp);
 8028bf8:	4640      	mov	r0, r8
 8028bfa:	462a      	mov	r2, r5
 8028bfc:	ed94 0a02 	vldr	s0, [r4, #8]
 8028c00:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028c04:	f7fa f880 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delMB,p->waveLengthInSamples, 2400, mp);
 8028c08:	4638      	mov	r0, r7
 8028c0a:	462a      	mov	r2, r5
 8028c0c:	ed94 0a02 	vldr	s0, [r4, #8]
 8028c10:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028c14:	f7fa f878 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_initToPool(&p->delLB,p->waveLengthInSamples, 2400, mp);
 8028c18:	9e01      	ldr	r6, [sp, #4]
 8028c1a:	462a      	mov	r2, r5
 8028c1c:	ed94 0a02 	vldr	s0, [r4, #8]
 8028c20:	f44f 6116 	mov.w	r1, #2400	; 0x960
 8028c24:	4630      	mov	r0, r6
 8028c26:	f7fa f86f 	bl	8022d08 <tLinearDelay_initToPool>
    tLinearDelay_clear(&p->delLF);
 8028c2a:	4658      	mov	r0, fp
 8028c2c:	f7fa f8e8 	bl	8022e00 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMF);
 8028c30:	4650      	mov	r0, sl
 8028c32:	f7fa f8e5 	bl	8022e00 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUF);
 8028c36:	4648      	mov	r0, r9
 8028c38:	f7fa f8e2 	bl	8022e00 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delUB);
 8028c3c:	4640      	mov	r0, r8
 8028c3e:	f7fa f8df 	bl	8022e00 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delMB);
 8028c42:	4638      	mov	r0, r7
 8028c44:	f7fa f8dc 	bl	8022e00 <tLinearDelay_clear>
    tLinearDelay_clear(&p->delLB);
 8028c48:	4630      	mov	r0, r6
 8028c4a:	f7fa f8d9 	bl	8022e00 <tLinearDelay_clear>
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
 8028c4e:	4629      	mov	r1, r5
 8028c50:	eeb0 0a69 	vmov.f32	s0, s19
 8028c54:	f104 0044 	add.w	r0, r4, #68	; 0x44
    p->dampFreq = dampFreq;
 8028c58:	edc4 9a07 	vstr	s19, [r4, #28]
    tOnePole_initToPool(&p->bridgeFilter, dampFreq, mp);
 8028c5c:	f7fd fa6e 	bl	802613c <tOnePole_initToPool>
    tOnePole_initToPool(&p->nutFilter, dampFreq, mp);
 8028c60:	4629      	mov	r1, r5
 8028c62:	eeb0 0a69 	vmov.f32	s0, s19
 8028c66:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8028c6a:	f7fd fa67 	bl	802613c <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterU, dampFreq, mp);
 8028c6e:	4629      	mov	r1, r5
 8028c70:	eeb0 0a69 	vmov.f32	s0, s19
 8028c74:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8028c78:	f7fd fa60 	bl	802613c <tOnePole_initToPool>
    tOnePole_initToPool(&p->prepFilterL, dampFreq, mp);
 8028c7c:	4629      	mov	r1, r5
 8028c7e:	eeb0 0a69 	vmov.f32	s0, s19
 8028c82:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8028c86:	f7fd fa59 	bl	802613c <tOnePole_initToPool>
    tHighpass_initToPool(&p->DCblockerU,13, mp);
 8028c8a:	4629      	mov	r1, r5
 8028c8c:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8028c90:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 8028c94:	f7fd fc98 	bl	80265c8 <tHighpass_initToPool>
    tHighpass_initToPool(&p->DCblockerL,13, mp);
 8028c98:	4629      	mov	r1, r5
 8028c9a:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8028c9e:	eeb2 0a0a 	vmov.f32	s0, #42	; 0x41500000  13.0
 8028ca2:	f7fd fc91 	bl	80265c8 <tHighpass_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
 8028ca6:	462a      	mov	r2, r5
 8028ca8:	9900      	ldr	r1, [sp, #0]
 8028caa:	eeb0 1a6c 	vmov.f32	s2, s25
 8028cae:	eef0 0a4c 	vmov.f32	s1, s24
 8028cb2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8028cb6:	eeb0 0a6b 	vmov.f32	s0, s23
    p->decay=decay;
 8028cba:	edc4 da08 	vstr	s27, [r4, #32]
    p->prepIndex = prepIndex;
 8028cbe:	ed84 da06 	vstr	s26, [r4, #24]
    tFeedbackLeveler_initToPool(&p->fbLevU, targetLev, levSmoothFactor, levStrength, levMode, mp);
 8028cc2:	f7fa feeb 	bl	8023a9c <tFeedbackLeveler_initToPool>
    tFeedbackLeveler_initToPool(&p->fbLevL, targetLev, levSmoothFactor, levStrength, levMode, mp);
 8028cc6:	462a      	mov	r2, r5
 8028cc8:	9900      	ldr	r1, [sp, #0]
 8028cca:	eeb0 1a6c 	vmov.f32	s2, s25
 8028cce:	eef0 0a4c 	vmov.f32	s1, s24
 8028cd2:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8028cd6:	eeb0 0a6b 	vmov.f32	s0, s23
 8028cda:	f7fa fedf 	bl	8023a9c <tFeedbackLeveler_initToPool>
    p->levMode=levMode;
 8028cde:	eddd 7a00 	vldr	s15, [sp]
 8028ce2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028ce6:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
 8028cea:	b003      	add	sp, #12
 8028cec:	ecbd 8b0c 	vpop	{d8-d13}
 8028cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08028cf4 <tComplexLivingString_init>:
    tComplexLivingString_initToPool(pl, freq, pickPos, prepPos, prepIndex, dampFreq, decay, targetLev, levSmoothFactor, levStrength, levMode, &leaf.mempool);
 8028cf4:	f249 42b8 	movw	r2, #38072	; 0x94b8
 8028cf8:	f2c2 0201 	movt	r2, #8193	; 0x2001
 8028cfc:	f7ff bed2 	b.w	8028aa4 <tComplexLivingString_initToPool>

08028d00 <tComplexLivingString_free>:
{
 8028d00:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
 8028d02:	6804      	ldr	r4, [r0, #0]
    tExpSmooth_free(&p->wlSmooth);
 8028d04:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8028d08:	f7fd f92c 	bl	8025f64 <tExpSmooth_free>
    tExpSmooth_free(&p->pickPosSmooth);
 8028d0c:	f104 0068 	add.w	r0, r4, #104	; 0x68
 8028d10:	f7fd f928 	bl	8025f64 <tExpSmooth_free>
    tExpSmooth_free(&p->prepPosSmooth);
 8028d14:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8028d18:	f7fd f924 	bl	8025f64 <tExpSmooth_free>
    tLinearDelay_free(&p->delLF);
 8028d1c:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8028d20:	f7fa f862 	bl	8022de8 <tLinearDelay_free>
    tLinearDelay_free(&p->delMF);
 8028d24:	f104 0034 	add.w	r0, r4, #52	; 0x34
 8028d28:	f7fa f85e 	bl	8022de8 <tLinearDelay_free>
    tLinearDelay_free(&p->delUF);
 8028d2c:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8028d30:	f7fa f85a 	bl	8022de8 <tLinearDelay_free>
    tLinearDelay_free(&p->delUB);
 8028d34:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 8028d38:	f7fa f856 	bl	8022de8 <tLinearDelay_free>
    tLinearDelay_free(&p->delMB);
 8028d3c:	f104 0038 	add.w	r0, r4, #56	; 0x38
 8028d40:	f7fa f852 	bl	8022de8 <tLinearDelay_free>
    tLinearDelay_free(&p->delLB);
 8028d44:	f104 0040 	add.w	r0, r4, #64	; 0x40
 8028d48:	f7fa f84e 	bl	8022de8 <tLinearDelay_free>
    tOnePole_free(&p->bridgeFilter);
 8028d4c:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8028d50:	f7fd fa2a 	bl	80261a8 <tOnePole_free>
    tOnePole_free(&p->nutFilter);
 8028d54:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8028d58:	f7fd fa26 	bl	80261a8 <tOnePole_free>
    tOnePole_free(&p->prepFilterU);
 8028d5c:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8028d60:	f7fd fa22 	bl	80261a8 <tOnePole_free>
    tOnePole_free(&p->prepFilterL);
 8028d64:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8028d68:	f7fd fa1e 	bl	80261a8 <tOnePole_free>
    tHighpass_free(&p->DCblockerU);
 8028d6c:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8028d70:	f7fd fc4c 	bl	802660c <tHighpass_free>
    tHighpass_free(&p->DCblockerL);
 8028d74:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8028d78:	f7fd fc48 	bl	802660c <tHighpass_free>
    tFeedbackLeveler_free(&p->fbLevU);
 8028d7c:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8028d80:	f7fa feb4 	bl	8023aec <tFeedbackLeveler_free>
    tFeedbackLeveler_free(&p->fbLevL);
 8028d84:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8028d88:	f7fa feb0 	bl	8023aec <tFeedbackLeveler_free>
    mpool_free((char*)p, p->mempool);
 8028d8c:	6821      	ldr	r1, [r4, #0]
 8028d8e:	4620      	mov	r0, r4
}
 8028d90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 8028d94:	f7ff b8d4 	b.w	8027f40 <mpool_free>

08028d98 <tComplexLivingString_setFreq>:
{    // NOTE: It is faster to set wavelength in samples directly
 8028d98:	f44f 4380 	mov.w	r3, #16384	; 0x4000
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028d9c:	f249 42a0 	movw	r2, #38048	; 0x94a0
 8028da0:	eef3 6a04 	vmov.f32	s13, #52	; 0x41a00000  20.0
    _tComplexLivingString* p = *pl;
 8028da4:	6801      	ldr	r1, [r0, #0]
 8028da6:	f2c4 631c 	movt	r3, #17948	; 0x461c
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028daa:	f2c2 0201 	movt	r2, #8193	; 0x2001
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8028dae:	f101 0064 	add.w	r0, r1, #100	; 0x64
 8028db2:	ee07 3a90 	vmov	s15, r3
    p->waveLengthInSamples = leaf.sampleRate/freq;
 8028db6:	ed92 7a00 	vldr	s14, [r2]
 8028dba:	fec0 7a67 	vminnm.f32	s15, s0, s15
 8028dbe:	fec7 7aa6 	vmaxnm.f32	s15, s15, s13
 8028dc2:	ee87 0a27 	vdiv.f32	s0, s14, s15
 8028dc6:	ed81 0a02 	vstr	s0, [r1, #8]
    tExpSmooth_setDest(&p->wlSmooth, p->waveLengthInSamples);
 8028dca:	f7fd b8e1 	b.w	8025f90 <tExpSmooth_setDest>
 8028dce:	bf00      	nop

08028dd0 <tComplexLivingString_setPickPos>:
{    // between 0 and 1
 8028dd0:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
 8028dd4:	6803      	ldr	r3, [r0, #0]
 8028dd6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8028dda:	f103 0068 	add.w	r0, r3, #104	; 0x68
 8028dde:	fe80 0a67 	vminnm.f32	s0, s0, s15
 8028de2:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->pickPos = pickPos;
 8028de6:	ed83 0a03 	vstr	s0, [r3, #12]
    tExpSmooth_setDest(&p->pickPosSmooth, p->pickPos);
 8028dea:	f7fd b8d1 	b.w	8025f90 <tExpSmooth_setDest>
 8028dee:	bf00      	nop

08028df0 <tComplexLivingString_setPrepPos>:
{    // between 0 and 1
 8028df0:	2300      	movs	r3, #0
 8028df2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
    _tComplexLivingString* p = *pl;
 8028df6:	6802      	ldr	r2, [r0, #0]
 8028df8:	ee07 3a10 	vmov	s14, r3
 8028dfc:	fe80 0a67 	vminnm.f32	s0, s0, s15
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 8028e00:	f102 006c 	add.w	r0, r2, #108	; 0x6c
 8028e04:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
    p->prepPos = prepPos;
 8028e08:	ed82 0a04 	vstr	s0, [r2, #16]
    tExpSmooth_setDest(&p->prepPosSmooth, p->prepPos);
 8028e0c:	f7fd b8c0 	b.w	8025f90 <tExpSmooth_setDest>

08028e10 <tComplexLivingString_setPrepIndex>:
void     tComplexLivingString_setPrepIndex(tComplexLivingString* const pl, float prepIndex)
{    // between 0 and 1
    _tComplexLivingString* p = *pl;
    if (prepIndex<0.f) prepIndex=0.f;
    else if (prepIndex>1.f) prepIndex=1.f;
    p->prepIndex = prepIndex;
 8028e10:	2300      	movs	r3, #0
 8028e12:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    _tComplexLivingString* p = *pl;
 8028e16:	6802      	ldr	r2, [r0, #0]
    p->prepIndex = prepIndex;
 8028e18:	ee07 3a10 	vmov	s14, r3
 8028e1c:	fe80 0a67 	vminnm.f32	s0, s0, s15
 8028e20:	fe80 0a07 	vmaxnm.f32	s0, s0, s14
 8028e24:	ed82 0a06 	vstr	s0, [r2, #24]
}
 8028e28:	4770      	bx	lr
 8028e2a:	bf00      	nop

08028e2c <tComplexLivingString_setDampFreq>:

void     tComplexLivingString_setDampFreq(tComplexLivingString* const pl, float dampFreq)
{
 8028e2c:	b510      	push	{r4, lr}
 8028e2e:	ed2d 8b02 	vpush	{d8}
 8028e32:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
 8028e36:	6804      	ldr	r4, [r0, #0]
    tOnePole_setFreq(&p->bridgeFilter, dampFreq);
 8028e38:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8028e3c:	f7fd f9b8 	bl	80261b0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->nutFilter, dampFreq);
 8028e40:	eeb0 0a48 	vmov.f32	s0, s16
 8028e44:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8028e48:	f7fd f9b2 	bl	80261b0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterU, dampFreq);
 8028e4c:	eeb0 0a48 	vmov.f32	s0, s16
 8028e50:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8028e54:	f7fd f9ac 	bl	80261b0 <tOnePole_setFreq>
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
 8028e58:	eeb0 0a48 	vmov.f32	s0, s16
 8028e5c:	f104 0050 	add.w	r0, r4, #80	; 0x50
}
 8028e60:	ecbd 8b02 	vpop	{d8}
 8028e64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&p->prepFilterL, dampFreq);
 8028e68:	f7fd b9a2 	b.w	80261b0 <tOnePole_setFreq>

08028e6c <tComplexLivingString_setDecay>:

void     tComplexLivingString_setDecay(tComplexLivingString* const pl, float decay)
{
    _tComplexLivingString* p = *pl;
 8028e6c:	6803      	ldr	r3, [r0, #0]
    p->decay=decay;
 8028e6e:	ed83 0a08 	vstr	s0, [r3, #32]
}
 8028e72:	4770      	bx	lr

08028e74 <tComplexLivingString_setTargetLev>:

void     tComplexLivingString_setTargetLev(tComplexLivingString* const pl, float targetLev)
{
 8028e74:	b510      	push	{r4, lr}
 8028e76:	ed2d 8b02 	vpush	{d8}
 8028e7a:	eeb0 8a40 	vmov.f32	s16, s0
    _tComplexLivingString* p = *pl;
 8028e7e:	6804      	ldr	r4, [r0, #0]
    tFeedbackLeveler_setTargetLevel(&p->fbLevU, targetLev);
 8028e80:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8028e84:	f7fa fe68 	bl	8023b58 <tFeedbackLeveler_setTargetLevel>
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
 8028e88:	eeb0 0a48 	vmov.f32	s0, s16
 8028e8c:	f104 0060 	add.w	r0, r4, #96	; 0x60
}
 8028e90:	ecbd 8b02 	vpop	{d8}
 8028e94:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tFeedbackLeveler_setTargetLevel(&p->fbLevL, targetLev);
 8028e98:	f7fa be5e 	b.w	8023b58 <tFeedbackLeveler_setTargetLevel>

08028e9c <tComplexLivingString_setLevMode>:
    tFeedbackLeveler_setStrength(&p->fbLevU, levStrength);
    tFeedbackLeveler_setStrength(&p->fbLevL, levStrength);
}

void     tComplexLivingString_setLevMode(tComplexLivingString* const pl, int levMode)
{
 8028e9c:	b510      	push	{r4, lr}
    _tComplexLivingString* p = *pl;
 8028e9e:	6804      	ldr	r4, [r0, #0]
{
 8028ea0:	b082      	sub	sp, #8
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
 8028ea2:	f104 005c 	add.w	r0, r4, #92	; 0x5c
{
 8028ea6:	9101      	str	r1, [sp, #4]
    tFeedbackLeveler_setMode(&p->fbLevU, levMode);
 8028ea8:	f7fa fe2c 	bl	8023b04 <tFeedbackLeveler_setMode>
    tFeedbackLeveler_setMode(&p->fbLevL, levMode);
 8028eac:	9901      	ldr	r1, [sp, #4]
 8028eae:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8028eb2:	f7fa fe27 	bl	8023b04 <tFeedbackLeveler_setMode>
    p->levMode=levMode;
 8028eb6:	eddd 7a01 	vldr	s15, [sp, #4]
 8028eba:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8028ebe:	edc4 7a09 	vstr	s15, [r4, #36]	; 0x24
}
 8028ec2:	b002      	add	sp, #8
 8028ec4:	bd10      	pop	{r4, pc}
 8028ec6:	bf00      	nop

08028ec8 <tComplexLivingString_tick>:

float   tComplexLivingString_tick(tComplexLivingString* const pl, float input)
{
 8028ec8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8028ecc:	ed2d 8b08 	vpush	{d8-d11}
    _tComplexLivingString* p = *pl;
 8028ed0:	6804      	ldr	r4, [r0, #0]
{
 8028ed2:	eef0 8a40 	vmov.f32	s17, s0

    // from pickPos upwards=forwards
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 8028ed6:	f104 0a2c 	add.w	sl, r4, #44	; 0x2c
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 8028eda:	f104 0834 	add.w	r8, r4, #52	; 0x34
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 8028ede:	f104 0630 	add.w	r6, r4, #48	; 0x30
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 8028ee2:	f104 053c 	add.w	r5, r4, #60	; 0x3c
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 8028ee6:	4650      	mov	r0, sl
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 8028ee8:	f104 0738 	add.w	r7, r4, #56	; 0x38
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 8028eec:	f7f9 ffe4 	bl	8022eb8 <tLinearDelay_tickOut>
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 8028ef0:	4640      	mov	r0, r8
    float fromLF=tLinearDelay_tickOut(&p->delLF);
 8028ef2:	eeb0 9a40 	vmov.f32	s18, s0
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 8028ef6:	f7f9 ffdf 	bl	8022eb8 <tLinearDelay_tickOut>
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 8028efa:	4630      	mov	r0, r6
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 8028efc:	f104 0940 	add.w	r9, r4, #64	; 0x40
    float fromMF=tLinearDelay_tickOut(&p->delMF);
 8028f00:	eef0 aa40 	vmov.f32	s21, s0
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 8028f04:	f7f9 ffd8 	bl	8022eb8 <tLinearDelay_tickOut>
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 8028f08:	4628      	mov	r0, r5
    float fromUF=tLinearDelay_tickOut(&p->delUF);
 8028f0a:	eef0 9a40 	vmov.f32	s19, s0
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 8028f0e:	f7f9 ffd3 	bl	8022eb8 <tLinearDelay_tickOut>
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 8028f12:	4638      	mov	r0, r7
    float fromUB=tLinearDelay_tickOut(&p->delUB);
 8028f14:	eeb0 aa40 	vmov.f32	s20, s0
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 8028f18:	f7f9 ffce 	bl	8022eb8 <tLinearDelay_tickOut>
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 8028f1c:	4648      	mov	r0, r9
    float fromMB=tLinearDelay_tickOut(&p->delMB);
 8028f1e:	eef0 ba40 	vmov.f32	s23, s0
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 8028f22:	f7f9 ffc9 	bl	8022eb8 <tLinearDelay_tickOut>

    // into upper part of string, from bridge, going backwards
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 8028f26:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    float fromLB=tLinearDelay_tickOut(&p->delLB);
 8028f2a:	eeb0 ba40 	vmov.f32	s22, s0
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 8028f2e:	f104 0b5c 	add.w	fp, r4, #92	; 0x5c
 8028f32:	eef5 7a40 	vcmp.f32	s15, #0.0
 8028f36:	f104 0044 	add.w	r0, r4, #68	; 0x44
 8028f3a:	eeb0 0a69 	vmov.f32	s0, s19
 8028f3e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028f42:	bf14      	ite	ne
 8028f44:	eeb7 8a00 	vmovne.f32	s16, #112	; 0x3f800000  1.0
 8028f48:	ed94 8a08 	vldreq	s16, [r4, #32]
 8028f4c:	f7fd f94c 	bl	80261e8 <tOnePole_tick>
 8028f50:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8028f54:	f7fd fb6e 	bl	8026634 <tHighpass_tick>
 8028f58:	4658      	mov	r0, fp
 8028f5a:	ee20 0a08 	vmul.f32	s0, s0, s16
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
    tLinearDelay_tickIn(&p->delLB, intoLower);

    // into lower part of string, from nut, going forwards toward prep position
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
 8028f5e:	f104 0b60 	add.w	fp, r4, #96	; 0x60
    float fromBridge=-tFeedbackLeveler_tick(&p->fbLevU, (p->levMode==0?p->decay:1)*tHighpass_tick(&p->DCblockerU, tOnePole_tick(&p->bridgeFilter, fromUF)));
 8028f62:	f7fa fdd3 	bl	8023b0c <tFeedbackLeveler_tick>
 8028f66:	eef1 9a40 	vneg.f32	s19, s0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
 8028f6a:	4628      	mov	r0, r5
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 8028f6c:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tLinearDelay_tickIn(&p->delUB, fromBridge);
 8028f70:	eeb0 0a69 	vmov.f32	s0, s19
 8028f74:	f7f9 ff8c 	bl	8022e90 <tLinearDelay_tickIn>
    tLinearDelay_tickIn(&p->delMB, fromUB+input);
 8028f78:	ee3a 0a28 	vadd.f32	s0, s20, s17
 8028f7c:	4638      	mov	r0, r7
 8028f7e:	f7f9 ff87 	bl	8022e90 <tLinearDelay_tickIn>
    float fromLowerPrep=-tOnePole_tick(&p->prepFilterL, fromLF);
 8028f82:	eeb0 0a49 	vmov.f32	s0, s18
 8028f86:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8028f8a:	f7fd f92d 	bl	80261e8 <tOnePole_tick>
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 8028f8e:	ed94 7a06 	vldr	s14, [r4, #24]
    tLinearDelay_tickIn(&p->delLB, intoLower);
 8028f92:	4648      	mov	r0, r9
    float intoLower=p->prepIndex*fromLowerPrep+(1.0f - p->prepIndex)*fromMB;
 8028f94:	ee78 7a47 	vsub.f32	s15, s16, s14
 8028f98:	ee67 7aab 	vmul.f32	s15, s15, s23
    tLinearDelay_tickIn(&p->delLB, intoLower);
 8028f9c:	eee0 7a47 	vfms.f32	s15, s0, s14
 8028fa0:	eeb0 0a67 	vmov.f32	s0, s15
 8028fa4:	f7f9 ff74 	bl	8022e90 <tLinearDelay_tickIn>
    float fromNut=-tFeedbackLeveler_tick(&p->fbLevL, (p->levMode==0?p->decay:1.0f)*tHighpass_tick(&p->DCblockerL, tOnePole_tick(&p->nutFilter, fromLB)));
 8028fa8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8028fac:	eeb0 0a4b 	vmov.f32	s0, s22
 8028fb0:	f104 0048 	add.w	r0, r4, #72	; 0x48
 8028fb4:	eef5 7a40 	vcmp.f32	s15, #0.0
 8028fb8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8028fbc:	bf08      	it	eq
 8028fbe:	ed94 8a08 	vldreq	s16, [r4, #32]
 8028fc2:	f7fd f911 	bl	80261e8 <tOnePole_tick>
 8028fc6:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8028fca:	f7fd fb33 	bl	8026634 <tHighpass_tick>
 8028fce:	4658      	mov	r0, fp
 8028fd0:	ee20 0a08 	vmul.f32	s0, s0, s16
 8028fd4:	f7fa fd9a 	bl	8023b0c <tFeedbackLeveler_tick>
    tLinearDelay_tickIn(&p->delLF, fromNut);
 8028fd8:	4650      	mov	r0, sl
 8028fda:	eeb1 0a40 	vneg.f32	s0, s0
 8028fde:	f7f9 ff57 	bl	8022e90 <tLinearDelay_tickIn>

    // into middle part of string, from prep going toward pick position
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 8028fe2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    float fromUpperPrep=-tOnePole_tick(&p->prepFilterU, fromUB);
 8028fe6:	eeb0 0a4a 	vmov.f32	s0, s20
 8028fea:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 8028fee:	f7fd f8fb 	bl	80261e8 <tOnePole_tick>
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 8028ff2:	edd4 7a06 	vldr	s15, [r4, #24]

    //pick position, take input and add it into the waveguide, going to come out of middle segment
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
 8028ff6:	4640      	mov	r0, r8
    float intoMiddle=p->prepIndex*fromUpperPrep+(1.0f - p->prepIndex)*fromLF;
 8028ff8:	ee38 7a67 	vsub.f32	s14, s16, s15
    tLinearDelay_tickIn(&p->delMF, intoMiddle + input);
 8028ffc:	eee7 8a09 	vfma.f32	s17, s14, s18
 8029000:	eee0 8a67 	vfms.f32	s17, s0, s15
 8029004:	eeb0 0a68 	vmov.f32	s0, s17
 8029008:	f7f9 ff42 	bl	8022e90 <tLinearDelay_tickIn>

    //take output of middle segment and put it into upper segment connecting to the bridge
    tLinearDelay_tickIn(&p->delUF, fromMF);
 802900c:	eeb0 0a6a 	vmov.f32	s0, s21
 8029010:	4630      	mov	r0, r6
 8029012:	f7f9 ff3d 	bl	8022e90 <tLinearDelay_tickIn>

    // update all delay lengths
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
 8029016:	f104 0068 	add.w	r0, r4, #104	; 0x68
 802901a:	f7fc ffc3 	bl	8025fa4 <tExpSmooth_tick>
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
 802901e:	f104 006c 	add.w	r0, r4, #108	; 0x6c
    float pickP=tExpSmooth_tick(&p->pickPosSmooth);
 8029022:	eeb0 9a40 	vmov.f32	s18, s0
    float prepP=tExpSmooth_tick(&p->prepPosSmooth);
 8029026:	f7fc ffbd 	bl	8025fa4 <tExpSmooth_tick>
 802902a:	eef0 8a40 	vmov.f32	s17, s0
    float wLen=tExpSmooth_tick(&p->wlSmooth);
 802902e:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8029032:	f7fc ffb7 	bl	8025fa4 <tExpSmooth_tick>
 8029036:	eef0 7a40 	vmov.f32	s15, s0

    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
    float lowLen = prepP*wLen; // the length from prep to nut
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
 802903a:	ee38 8a49 	vsub.f32	s16, s16, s18


    tLinearDelay_setDelay(&p->delLF, lowLen);
 802903e:	4650      	mov	r0, sl
    float lowLen = prepP*wLen; // the length from prep to nut
 8029040:	ee28 aa80 	vmul.f32	s20, s17, s0
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
 8029044:	ee79 8a68 	vsub.f32	s17, s18, s17
    float upLen = (1.0f-pickP)*wLen; // the length from pick to bridge
 8029048:	ee28 8a00 	vmul.f32	s16, s16, s0
    tLinearDelay_setDelay(&p->delLF, lowLen);
 802904c:	eeb0 0a4a 	vmov.f32	s0, s20
    float midLen = (pickP-prepP) * wLen; // the length between the pick and the prep;
 8029050:	ee68 8aa7 	vmul.f32	s17, s17, s15
    tLinearDelay_setDelay(&p->delLF, lowLen);
 8029054:	f7f9 ff5a 	bl	8022f0c <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delLB, lowLen);
 8029058:	eeb0 0a4a 	vmov.f32	s0, s20
 802905c:	4648      	mov	r0, r9
 802905e:	f7f9 ff55 	bl	8022f0c <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delMF, midLen);
 8029062:	4640      	mov	r0, r8
 8029064:	eeb0 0a68 	vmov.f32	s0, s17
 8029068:	f7f9 ff50 	bl	8022f0c <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delMB, midLen);
 802906c:	eeb0 0a68 	vmov.f32	s0, s17
 8029070:	4638      	mov	r0, r7
 8029072:	f7f9 ff4b 	bl	8022f0c <tLinearDelay_setDelay>

    tLinearDelay_setDelay(&p->delUF, upLen);
 8029076:	eeb0 0a48 	vmov.f32	s0, s16
 802907a:	4630      	mov	r0, r6
 802907c:	f7f9 ff46 	bl	8022f0c <tLinearDelay_setDelay>
    tLinearDelay_setDelay(&p->delUB, upLen);
 8029080:	eeb0 0a48 	vmov.f32	s0, s16
 8029084:	4628      	mov	r0, r5
 8029086:	f7f9 ff41 	bl	8022f0c <tLinearDelay_setDelay>

    //update this to allow pickup position variation
    p->curr = fromBridge;
    return p->curr;
}
 802908a:	eeb0 0a69 	vmov.f32	s0, s19
    p->curr = fromBridge;
 802908e:	edc4 9a0a 	vstr	s19, [r4, #40]	; 0x28
}
 8029092:	ecbd 8b08 	vpop	{d8-d11}
 8029096:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802909a:	bf00      	nop

0802909c <tNReverb_initToPool>:
{
    tNReverb_initToPool(rev, t60, &leaf.mempool);
}

void    tNReverb_initToPool     (tNReverb* const rev, float t60, tMempool* const mp)
{
 802909c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80290a0:	ed2d 8b06 	vpush	{d8-d10}
 80290a4:	eeb0 aa40 	vmov.f32	s20, s0
    _tMempool* m = *mp;
 80290a8:	680c      	ldr	r4, [r1, #0]
{
 80290aa:	b095      	sub	sp, #84	; 0x54
 80290ac:	4605      	mov	r5, r0
 80290ae:	4688      	mov	r8, r1
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 80290b0:	4621      	mov	r1, r4
{
 80290b2:	9002      	str	r0, [sp, #8]
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 80290b4:	2074      	movs	r0, #116	; 0x74
 80290b6:	f7fe fe99 	bl	8027dec <mpool_alloc>
    r->mempool = m;
    
    if (t60 <= 0.0f) t60 = 0.001f;
 80290ba:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev = (_tNReverb*) mpool_alloc(sizeof(_tNReverb), m);
 80290be:	6028      	str	r0, [r5, #0]
 80290c0:	4682      	mov	sl, r0
    r->mempool = m;
 80290c2:	6004      	str	r4, [r0, #0]
    if (t60 <= 0.0f) t60 = 0.001f;
 80290c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80290c8:	f240 80d1 	bls.w	802926e <tNReverb_initToPool+0x1d2>
 80290cc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 80290d0:	ee87 8a8a 	vdiv.f32	s16, s15, s20
    
    r->inv_441 = 1.0f/44100.0f;
    
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
    double scaler = leaf.sampleRate / 25641.0f;
 80290d4:	f249 47a0 	movw	r7, #38048	; 0x94a0
 80290d8:	f249 34f9 	movw	r4, #37881	; 0x93f9
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 80290dc:	f64d 0cd8 	movw	ip, #55512	; 0xd8d8
 80290e0:	ae05      	add	r6, sp, #20
    double scaler = leaf.sampleRate / 25641.0f;
 80290e2:	f6c3 0423 	movt	r4, #14371	; 0x3823
 80290e6:	f2c2 0701 	movt	r7, #8193	; 0x2001
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 80290ea:	f6c0 0c02 	movt	ip, #2050	; 0x802
 80290ee:	f10d 0914 	add.w	r9, sp, #20
    double scaler = leaf.sampleRate / 25641.0f;
 80290f2:	ee07 4a90 	vmov	s15, r4
 80290f6:	ed97 7a00 	vldr	s14, [r7]
    r->inv_441 = 1.0f/44100.0f;
 80290fa:	f243 74c6 	movw	r4, #14278	; 0x37c6
    double scaler = leaf.sampleRate / 25641.0f;
 80290fe:	ee67 7a27 	vmul.f32	s15, s14, s15
    r->inv_441 = 1.0f/44100.0f;
 8029102:	f2c3 74be 	movt	r4, #14270	; 0x37be
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 8029106:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 802910a:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 802910c:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8029110:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 8029112:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 8029116:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    r->inv_441 = 1.0f/44100.0f;
 802911a:	4625      	mov	r5, r4
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 802911c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 802911e:	e89c 0007 	ldmia.w	ip, {r0, r1, r2}
    r->inv_441 = 1.0f/44100.0f;
 8029122:	f8ca 5010 	str.w	r5, [sl, #16]
 8029126:	ee17 ba90 	vmov	fp, s15
 802912a:	ad04      	add	r5, sp, #16
    int lengths[15] = {1433, 1601, 1867, 2053, 2251, 2399, 347, 113, 37, 59, 53, 43, 37, 29, 19}; // Delay lengths for 44100 Hz sample rate.
 802912c:	e886 0007 	stmia.w	r6, {r0, r1, r2}
 8029130:	ae13      	add	r6, sp, #76	; 0x4c
    
    int delay, i;
    
    for (i=0; i < 15; i++)
    {
        delay = (int) scaler * lengths[i];
 8029132:	f855 4f04 	ldr.w	r4, [r5, #4]!
 8029136:	fb04 f40b 	mul.w	r4, r4, fp
        if ( (delay & 1) == 0)
 802913a:	07e3      	lsls	r3, r4, #31
 802913c:	d402      	bmi.n	8029144 <tNReverb_initToPool+0xa8>
            delay++;
 802913e:	3401      	adds	r4, #1
 8029140:	e000      	b.n	8029144 <tNReverb_initToPool+0xa8>
        while ( !LEAF_isPrime(delay) )
            delay += 2;
 8029142:	3402      	adds	r4, #2
        while ( !LEAF_isPrime(delay) )
 8029144:	4620      	mov	r0, r4
 8029146:	17e1      	asrs	r1, r4, #31
 8029148:	f7fe fc56 	bl	80279f8 <LEAF_isPrime>
 802914c:	2800      	cmp	r0, #0
 802914e:	d0f8      	beq.n	8029142 <tNReverb_initToPool+0xa6>
    for (i=0; i < 15; i++)
 8029150:	42ae      	cmp	r6, r5
        lengths[i] = delay;
 8029152:	602c      	str	r4, [r5, #0]
    for (i=0; i < 15; i++)
 8029154:	d1ed      	bne.n	8029132 <tNReverb_initToPool+0x96>
 8029156:	f10a 0368 	add.w	r3, sl, #104	; 0x68
 802915a:	f10a 0650 	add.w	r6, sl, #80	; 0x50
 802915e:	9503      	str	r5, [sp, #12]
 8029160:	469b      	mov	fp, r3
    }
    
    for ( i=0; i<6; i++ )
    {
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
 8029162:	f859 4b04 	ldr.w	r4, [r9], #4
 8029166:	f1a6 051c 	sub.w	r5, r6, #28
 802916a:	4642      	mov	r2, r8
 802916c:	ee07 4a90 	vmov	s15, r4
 8029170:	4628      	mov	r0, r5
        tLinearDelay_clear(&r->combDelays[i]);
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
 8029172:	eba4 0484 	sub.w	r4, r4, r4, lsl #2
        tLinearDelay_initToPool(&r->combDelays[i], lengths[i], lengths[i] * 2.0f, mp);
 8029176:	eeb8 0ae7 	vcvt.f32.s32	s0, s15
 802917a:	ee70 7a00 	vadd.f32	s15, s0, s0
 802917e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8029182:	ee17 1a90 	vmov	r1, s15
 8029186:	f7f9 fdbf 	bl	8022d08 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->combDelays[i]);
 802918a:	4628      	mov	r0, r5
 802918c:	f7f9 fe38 	bl	8022e00 <tLinearDelay_clear>
        r->combCoeffs[i] = pow(10.0, (-3 * lengths[i] * leaf.invSampleRate / t60));
 8029190:	edd7 7a01 	vldr	s15, [r7, #4]
 8029194:	ee07 4a10 	vmov	s14, r4
 8029198:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
 802919c:	ee68 7a27 	vmul.f32	s15, s16, s15
 80291a0:	eeb8 1ac7 	vcvt.f32.s32	s2, s14
 80291a4:	ee21 1a27 	vmul.f32	s2, s2, s15
 80291a8:	eeb7 1ac1 	vcvt.f64.f32	d1, s2
 80291ac:	f002 faa0 	bl	802b6f0 <pow>
 80291b0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 80291b4:	eca6 0a01 	vstmia	r6!, {s0}
    for ( i=0; i<6; i++ )
 80291b8:	45b3      	cmp	fp, r6
 80291ba:	d1d2      	bne.n	8029162 <tNReverb_initToPool+0xc6>
 80291bc:	9d03      	ldr	r5, [sp, #12]
 80291be:	ae0b      	add	r6, sp, #44	; 0x2c
 80291c0:	f10a 0414 	add.w	r4, sl, #20
    }
    
    for ( i=0; i<8; i++ )
    {
        tLinearDelay_initToPool(&r->allpassDelays[i], lengths[i+6], lengths[i+6] * 2.0f, mp);
 80291c4:	ecb6 0a01 	vldmia	r6!, {s0}
 80291c8:	4620      	mov	r0, r4
 80291ca:	4642      	mov	r2, r8
 80291cc:	eeb8 0ac0 	vcvt.f32.s32	s0, s0
 80291d0:	ee70 7a00 	vadd.f32	s15, s0, s0
 80291d4:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 80291d8:	ee17 1a90 	vmov	r1, s15
 80291dc:	f7f9 fd94 	bl	8022d08 <tLinearDelay_initToPool>
        tLinearDelay_clear(&r->allpassDelays[i]);
 80291e0:	4620      	mov	r0, r4
 80291e2:	f7f9 fe0d 	bl	8022e00 <tLinearDelay_clear>
    for ( i=0; i<8; i++ )
 80291e6:	42b5      	cmp	r5, r6
 80291e8:	f104 0404 	add.w	r4, r4, #4
 80291ec:	d1ea      	bne.n	80291c4 <tNReverb_initToPool+0x128>

void    tNReverb_setT60(tNReverb* const rev, float t60)
{
    _tNReverb* r = *rev;
    
    if (t60 <= 0.0f)           t60 = 0.001f;
 80291ee:	eeb5 aac0 	vcmpe.f32	s20, #0.0
    _tNReverb* r = *rev;
 80291f2:	9b02      	ldr	r3, [sp, #8]
 80291f4:	681b      	ldr	r3, [r3, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
 80291f6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80291fa:	d945      	bls.n	8029288 <tNReverb_initToPool+0x1ec>
 80291fc:	eeb7 7aca 	vcvt.f64.f32	d7, s20
 8029200:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
 8029204:	ee86 9b07 	vdiv.f64	d9, d6, d7
 8029208:	f103 0450 	add.w	r4, r3, #80	; 0x50
 802920c:	f103 0568 	add.w	r5, r3, #104	; 0x68
    
    r->t60 = t60;
 8029210:	ed83 aa02 	vstr	s20, [r3, #8]
    
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
 8029214:	eeb8 8b08 	vmov.f64	d8, #136	; 0xc0400000 -3.0
 8029218:	f1a4 001c 	sub.w	r0, r4, #28
 802921c:	f7f9 feb6 	bl	8022f8c <tLinearDelay_getDelay>
 8029220:	ed97 7a01 	vldr	s14, [r7, #4]
 8029224:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
 8029228:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 802922c:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
 8029230:	ee27 7b08 	vmul.f64	d7, d7, d8
 8029234:	ee27 7b09 	vmul.f64	d7, d7, d9
 8029238:	ee27 1b01 	vmul.f64	d1, d7, d1
 802923c:	f002 fa58 	bl	802b6f0 <pow>
 8029240:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8029244:	eca4 0a01 	vstmia	r4!, {s0}
 8029248:	42a5      	cmp	r5, r4
 802924a:	d1e5      	bne.n	8029218 <tNReverb_initToPool+0x17c>
    r->allpassCoeff = 0.7f;
 802924c:	f243 3233 	movw	r2, #13107	; 0x3333
    r->mix = 0.3f;
 8029250:	f649 139a 	movw	r3, #39322	; 0x999a
    r->allpassCoeff = 0.7f;
 8029254:	f6c3 7233 	movt	r2, #16179	; 0x3f33
    r->mix = 0.3f;
 8029258:	f6c3 6399 	movt	r3, #16025	; 0x3e99
    r->allpassCoeff = 0.7f;
 802925c:	f8ca 204c 	str.w	r2, [sl, #76]	; 0x4c
    r->mix = 0.3f;
 8029260:	f8ca 3004 	str.w	r3, [sl, #4]
}
 8029264:	b015      	add	sp, #84	; 0x54
 8029266:	ecbd 8b06 	vpop	{d8-d10}
 802926a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802926e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    if (t60 <= 0.0f) t60 = 0.001f;
 8029272:	f241 226f 	movw	r2, #4719	; 0x126f
 8029276:	f2c4 4379 	movt	r3, #17529	; 0x4479
 802927a:	f6c3 2283 	movt	r2, #14979	; 0x3a83
 802927e:	ee08 3a10 	vmov	s16, r3
 8029282:	ee0a 2a10 	vmov	s20, r2
 8029286:	e725      	b.n	80290d4 <tNReverb_initToPool+0x38>
    if (t60 <= 0.0f)           t60 = 0.001f;
 8029288:	2114      	movs	r1, #20
 802928a:	f241 226f 	movw	r2, #4719	; 0x126f
 802928e:	f2ce 7119 	movt	r1, #59161	; 0xe719
 8029292:	f6c3 2283 	movt	r2, #14979	; 0x3a83
 8029296:	9100      	str	r1, [sp, #0]
 8029298:	f643 71ff 	movw	r1, #16383	; 0x3fff
 802929c:	ee0a 2a10 	vmov	s20, r2
 80292a0:	460a      	mov	r2, r1
 80292a2:	f2c4 028f 	movt	r2, #16527	; 0x408f
 80292a6:	9201      	str	r2, [sp, #4]
 80292a8:	ed9d 9b00 	vldr	d9, [sp]
 80292ac:	e7ac      	b.n	8029208 <tNReverb_initToPool+0x16c>
 80292ae:	bf00      	nop

080292b0 <tNReverb_init>:
    tNReverb_initToPool(rev, t60, &leaf.mempool);
 80292b0:	f249 41b8 	movw	r1, #38072	; 0x94b8
 80292b4:	f2c2 0101 	movt	r1, #8193	; 0x2001
 80292b8:	f7ff bef0 	b.w	802909c <tNReverb_initToPool>

080292bc <tNReverb_free>:
{
 80292bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tNReverb* r = *rev;
 80292be:	6807      	ldr	r7, [r0, #0]
 80292c0:	f107 0534 	add.w	r5, r7, #52	; 0x34
 80292c4:	f107 064c 	add.w	r6, r7, #76	; 0x4c
 80292c8:	462c      	mov	r4, r5
        tLinearDelay_free(&r->combDelays[i]);
 80292ca:	4620      	mov	r0, r4
 80292cc:	3404      	adds	r4, #4
 80292ce:	f7f9 fd8b 	bl	8022de8 <tLinearDelay_free>
    for (int i = 0; i < 6; i++)
 80292d2:	42b4      	cmp	r4, r6
 80292d4:	d1f9      	bne.n	80292ca <tNReverb_free+0xe>
 80292d6:	f107 0414 	add.w	r4, r7, #20
        tLinearDelay_free(&r->allpassDelays[i]);
 80292da:	4620      	mov	r0, r4
 80292dc:	3404      	adds	r4, #4
 80292de:	f7f9 fd83 	bl	8022de8 <tLinearDelay_free>
    for (int i = 0; i < 8; i++)
 80292e2:	42a5      	cmp	r5, r4
 80292e4:	d1f9      	bne.n	80292da <tNReverb_free+0x1e>
    mpool_free((char*)r, r->mempool);
 80292e6:	6839      	ldr	r1, [r7, #0]
 80292e8:	4638      	mov	r0, r7
}
 80292ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    mpool_free((char*)r, r->mempool);
 80292ee:	f7fe be27 	b.w	8027f40 <mpool_free>
 80292f2:	bf00      	nop

080292f4 <tNReverb_setT60>:
    if (t60 <= 0.0f)           t60 = 0.001f;
 80292f4:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
{
 80292f8:	b570      	push	{r4, r5, r6, lr}
    if (t60 <= 0.0f)           t60 = 0.001f;
 80292fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
{
 80292fe:	ed2d 8b04 	vpush	{d8-d9}
    _tNReverb* r = *rev;
 8029302:	6802      	ldr	r2, [r0, #0]
    if (t60 <= 0.0f)           t60 = 0.001f;
 8029304:	d92e      	bls.n	8029364 <tNReverb_setT60+0x70>
 8029306:	eeb7 7ac0 	vcvt.f64.f32	d7, s0
 802930a:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
 802930e:	ee86 8b07 	vdiv.f64	d8, d6, d7
 8029312:	f249 45a0 	movw	r5, #38048	; 0x94a0
 8029316:	f102 0450 	add.w	r4, r2, #80	; 0x50
 802931a:	f102 0668 	add.w	r6, r2, #104	; 0x68
    r->t60 = t60;
 802931e:	ed82 0a02 	vstr	s0, [r2, #8]
 8029322:	f2c2 0501 	movt	r5, #8193	; 0x2001
    for (int i=0; i<6; i++)   r->combCoeffs[i] = pow(10.0, (-3.0 * tLinearDelay_getDelay(&r->combDelays[i]) * leaf.invSampleRate / t60 ));
 8029326:	eeb8 9b08 	vmov.f64	d9, #136	; 0xc0400000 -3.0
 802932a:	f1a4 001c 	sub.w	r0, r4, #28
 802932e:	f7f9 fe2d 	bl	8022f8c <tLinearDelay_getDelay>
 8029332:	ed95 7a01 	vldr	s14, [r5, #4]
 8029336:	eeb7 1ac0 	vcvt.f64.f32	d1, s0
 802933a:	eeb7 7ac7 	vcvt.f64.f32	d7, s14
 802933e:	eeb2 0b04 	vmov.f64	d0, #36	; 0x41200000  10.0
 8029342:	ee27 7b09 	vmul.f64	d7, d7, d9
 8029346:	ee27 7b08 	vmul.f64	d7, d7, d8
 802934a:	ee27 1b01 	vmul.f64	d1, d7, d1
 802934e:	f002 f9cf 	bl	802b6f0 <pow>
 8029352:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 8029356:	eca4 0a01 	vstmia	r4!, {s0}
 802935a:	42b4      	cmp	r4, r6
 802935c:	d1e5      	bne.n	802932a <tNReverb_setT60+0x36>
    
}
 802935e:	ecbd 8b04 	vpop	{d8-d9}
 8029362:	bd70      	pop	{r4, r5, r6, pc}
 8029364:	2414      	movs	r4, #20
    if (t60 <= 0.0f)           t60 = 0.001f;
 8029366:	f241 236f 	movw	r3, #4719	; 0x126f
 802936a:	f643 75ff 	movw	r5, #16383	; 0x3fff
 802936e:	f2ce 7419 	movt	r4, #59161	; 0xe719
 8029372:	f6c3 2383 	movt	r3, #14979	; 0x3a83
 8029376:	f2c4 058f 	movt	r5, #16527	; 0x408f
 802937a:	ee00 3a10 	vmov	s0, r3
 802937e:	ec45 4b18 	vmov	d8, r4, r5
 8029382:	e7c6      	b.n	8029312 <tNReverb_setT60+0x1e>

08029384 <tNReverb_setMix>:

void    tNReverb_setMix(tNReverb* const rev, float mix)
{
    _tNReverb* r = *rev;
 8029384:	6803      	ldr	r3, [r0, #0]
    r->mix = mix;
 8029386:	ed83 0a01 	vstr	s0, [r3, #4]
}
 802938a:	4770      	bx	lr

0802938c <tNReverb_tickStereo>:

    return out;
}

void   tNReverb_tickStereo(tNReverb* const rev, float input, float* output)
{
 802938c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    r->lastIn = input;

    float temp, temp0, temp1, temp2, temp3, out;
    int i;

    temp0 = 0.0;
 8029390:	2300      	movs	r3, #0
{
 8029392:	4688      	mov	r8, r1
 8029394:	ed2d 8b06 	vpush	{d8-d10}
    _tNReverb* r = *rev;
 8029398:	6805      	ldr	r5, [r0, #0]
{
 802939a:	eeb0 9a40 	vmov.f32	s18, s0
    temp0 = 0.0;
 802939e:	ee08 3a10 	vmov	s16, r3
 80293a2:	f105 0450 	add.w	r4, r5, #80	; 0x50
 80293a6:	f105 0768 	add.w	r7, r5, #104	; 0x68
    r->lastIn = input;
 80293aa:	ed85 0a1b 	vstr	s0, [r5, #108]	; 0x6c
 80293ae:	f1a4 061c 	sub.w	r6, r4, #28
    for ( i=0; i<6; i++ )
    {
        temp = input + (r->combCoeffs[i] * tLinearDelay_getLastOut(&r->combDelays[i]));
 80293b2:	ecf4 8a01 	vldmia	r4!, {s17}
 80293b6:	4630      	mov	r0, r6
 80293b8:	f7f9 fdec 	bl	8022f94 <tLinearDelay_getLastOut>
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
 80293bc:	eef0 7a49 	vmov.f32	s15, s18
 80293c0:	4630      	mov	r0, r6
 80293c2:	eee8 7a80 	vfma.f32	s15, s17, s0
 80293c6:	eeb0 0a67 	vmov.f32	s0, s15
 80293ca:	f7f9 fd27 	bl	8022e1c <tLinearDelay_tick>
    for ( i=0; i<6; i++ )
 80293ce:	42bc      	cmp	r4, r7
        temp0 += tLinearDelay_tick(&r->combDelays[i],temp);
 80293d0:	ee38 8a00 	vadd.f32	s16, s16, s0
    for ( i=0; i<6; i++ )
 80293d4:	d1eb      	bne.n	80293ae <tNReverb_tickStereo+0x22>
 80293d6:	f105 0414 	add.w	r4, r5, #20
 80293da:	f105 0620 	add.w	r6, r5, #32
    }

    for ( i=0; i<3; i++ )
    {
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
 80293de:	4620      	mov	r0, r4
 80293e0:	f7f9 fdd8 	bl	8022f94 <tLinearDelay_getLastOut>
        temp1 = r->allpassCoeff * temp;
        temp1 += temp0;
 80293e4:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
        temp = tLinearDelay_getLastOut(&r->allpassDelays[i]);
 80293e8:	eef0 8a40 	vmov.f32	s17, s0
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
 80293ec:	4620      	mov	r0, r4
        temp1 += temp0;
 80293ee:	eea7 8a80 	vfma.f32	s16, s15, s0
 80293f2:	3404      	adds	r4, #4
        tLinearDelay_tick(&r->allpassDelays[i], temp1);
 80293f4:	eeb0 0a48 	vmov.f32	s0, s16
 80293f8:	f7f9 fd10 	bl	8022e1c <tLinearDelay_tick>
        temp0 = -(r->allpassCoeff * temp1) + temp;
 80293fc:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    for ( i=0; i<3; i++ )
 8029400:	42a6      	cmp	r6, r4
        temp0 = -(r->allpassCoeff * temp1) + temp;
 8029402:	eee7 8ac8 	vfms.f32	s17, s15, s16
 8029406:	eeb0 8a68 	vmov.f32	s16, s17
    for ( i=0; i<3; i++ )
 802940a:	d1e8      	bne.n	80293de <tNReverb_tickStereo+0x52>
    }

    // One-pole lowpass filter.
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802940c:	f649 129a 	movw	r2, #39322	; 0x999a
 8029410:	f243 3333 	movw	r3, #13107	; 0x3333
 8029414:	edd5 6a1a 	vldr	s13, [r5, #104]	; 0x68

    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 8029418:	4630      	mov	r0, r6
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802941a:	f6c3 6299 	movt	r2, #16025	; 0x3e99
 802941e:	f6c3 7333 	movt	r3, #16179	; 0x3f33
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
    temp1 = -(r->allpassCoeff * temp1) + temp;

    float drymix = ( 1.0f - r->mix ) * input;

    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 8029422:	f105 0724 	add.w	r7, r5, #36	; 0x24
    float drymix = ( 1.0f - r->mix ) * input;
 8029426:	eeb7 aa00 	vmov.f32	s20, #112	; 0x3f800000  1.0
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 802942a:	ee07 2a10 	vmov	s14, r2
 802942e:	ee07 3a90 	vmov	s15, r3
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
    out = output[0];


    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 8029432:	f105 0428 	add.w	r4, r5, #40	; 0x28
    r->lowpassState = 0.7f * r->lowpassState + 0.3f * temp0;
 8029436:	ee28 8a87 	vmul.f32	s16, s17, s14
 802943a:	eea6 8aa7 	vfma.f32	s16, s13, s15
 802943e:	ed85 8a1a 	vstr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 8029442:	f7f9 fda7 	bl	8022f94 <tLinearDelay_getLastOut>
    temp1 += r->lowpassState;
 8029446:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
 802944a:	ed95 8a1a 	vldr	s16, [r5, #104]	; 0x68
    temp = tLinearDelay_getLastOut(&r->allpassDelays[3]);
 802944e:	eef0 8a40 	vmov.f32	s17, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
 8029452:	4630      	mov	r0, r6
    temp1 += r->lowpassState;
 8029454:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[3], temp1 );
 8029458:	eeb0 0a48 	vmov.f32	s0, s16
 802945c:	f7f9 fcde 	bl	8022e1c <tLinearDelay_tick>
    temp1 = -(r->allpassCoeff * temp1) + temp;
 8029460:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
    float drymix = ( 1.0f - r->mix ) * input;
 8029464:	edd5 7a01 	vldr	s15, [r5, #4]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 8029468:	4638      	mov	r0, r7
    temp1 = -(r->allpassCoeff * temp1) + temp;
 802946a:	eee7 8a48 	vfms.f32	s17, s14, s16
    float drymix = ( 1.0f - r->mix ) * input;
 802946e:	ee3a aa67 	vsub.f32	s20, s20, s15
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 8029472:	f7f9 fd8f 	bl	8022f94 <tLinearDelay_getLastOut>
    temp2 += temp1;
 8029476:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[4]);
 802947a:	eef0 9a40 	vmov.f32	s19, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
 802947e:	4638      	mov	r0, r7
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 8029480:	eeea 9a09 	vfma.f32	s19, s20, s18
    temp2 += temp1;
 8029484:	eeb0 8a68 	vmov.f32	s16, s17
 8029488:	eea7 8a80 	vfma.f32	s16, s15, s0
    tLinearDelay_tick(&r->allpassDelays[4], temp2 );
 802948c:	eeb0 0a48 	vmov.f32	s0, s16
 8029490:	f7f9 fcc4 	bl	8022e1c <tLinearDelay_tick>
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 8029494:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 8029498:	4620      	mov	r0, r4
    output[0] = -( r->allpassCoeff * temp2 ) + temp + drymix;
 802949a:	eee7 9ac8 	vfms.f32	s19, s15, s16
 802949e:	edc8 9a00 	vstr	s19, [r8]
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 80294a2:	f7f9 fd77 	bl	8022f94 <tLinearDelay_getLastOut>
    temp3 = r->allpassCoeff * temp;
    temp3 += temp1;
 80294a6:	edd5 7a13 	vldr	s15, [r5, #76]	; 0x4c
    temp = tLinearDelay_getLastOut(&r->allpassDelays[5]);
 80294aa:	eeb0 8a40 	vmov.f32	s16, s0
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
 80294ae:	4620      	mov	r0, r4
    temp3 += temp1;
 80294b0:	eee7 8a80 	vfma.f32	s17, s15, s0
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
 80294b4:	eeaa 8a09 	vfma.f32	s16, s20, s18
    tLinearDelay_tick(&r->allpassDelays[5], temp3 );
 80294b8:	eeb0 0a68 	vmov.f32	s0, s17
 80294bc:	f7f9 fcae 	bl	8022e1c <tLinearDelay_tick>
    output[1] = r->mix *( - ( r->allpassCoeff * temp3 ) + temp + drymix);
 80294c0:	ed95 7a13 	vldr	s14, [r5, #76]	; 0x4c
 80294c4:	edd5 7a01 	vldr	s15, [r5, #4]
 80294c8:	eea7 8a68 	vfms.f32	s16, s14, s17
 80294cc:	ee28 8a27 	vmul.f32	s16, s16, s15
 80294d0:	ed88 8a01 	vstr	s16, [r8, #4]

    r->lastOut = out;
 80294d4:	edc5 9a1c 	vstr	s19, [r5, #112]	; 0x70
}
 80294d8:	ecbd 8b06 	vpop	{d8-d10}
 80294dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080294e0 <tDattorroReverb_initToPool>:
{
    tDattorroReverb_initToPool(rev, &leaf.mempool);
}

void    tDattorroReverb_initToPool        (tDattorroReverb* const rev, tMempool* const mp)
{
 80294e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80294e4:	ed2d 8b04 	vpush	{d8-d9}
    _tMempool* m = *mp;
 80294e8:	680d      	ldr	r5, [r1, #0]
{
 80294ea:	460e      	mov	r6, r1
 80294ec:	4681      	mov	r9, r0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 80294ee:	2088      	movs	r0, #136	; 0x88
 80294f0:	4629      	mov	r1, r5
    r->mempool = m;
    
    r->size_max = 2.0f;
    r->size = 1.f;
 80294f2:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 80294f6:	f7fe fc79 	bl	8027dec <mpool_alloc>
    r->t = r->size * leaf.sampleRate * 0.001f;
 80294fa:	f249 41a0 	movw	r1, #38048	; 0x94a0
 80294fe:	f241 226f 	movw	r2, #4719	; 0x126f
    r->frozen = 0;
    // INPUT
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8029502:	2300      	movs	r3, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029504:	f2c2 0101 	movt	r1, #8193	; 0x2001
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 8029508:	f8c9 0000 	str.w	r0, [r9]
    r->t = r->size * leaf.sampleRate * 0.001f;
 802950c:	f6c3 2283 	movt	r2, #14979	; 0x3a83
    r->mempool = m;
 8029510:	6005      	str	r5, [r0, #0]
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029512:	ed91 7a00 	vldr	s14, [r1]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8029516:	f2c4 3348 	movt	r3, #17224	; 0x4348
    r->t = r->size * leaf.sampleRate * 0.001f;
 802951a:	ee06 2a90 	vmov	s13, r2
    _tDattorroReverb* r = *rev = (_tDattorroReverb*) mpool_alloc(sizeof(_tDattorroReverb), m);
 802951e:	4604      	mov	r4, r0
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8029520:	ee07 3a90 	vmov	s15, r3
    r->frozen = 0;
 8029524:	2100      	movs	r1, #0
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029526:	ee27 7a26 	vmul.f32	s14, s14, s13
    r->size_max = 2.0f;
 802952a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 802952e:	f240 3894 	movw	r8, #916	; 0x394
 8029532:	f240 37a4 	movw	r7, #932	; 0x3a4
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
    
    for (int i = 0; i < 4; i++)
    {
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
 8029536:	eeb3 8a04 	vmov.f32	s16, #52	; 0x41a00000  20.0
    r->size_max = 2.0f;
 802953a:	6202      	str	r2, [r0, #32]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 802953c:	ee67 7a27 	vmul.f32	s15, s14, s15
    r->frozen = 0;
 8029540:	6181      	str	r1, [r0, #24]
    r->size = 1.f;
 8029542:	edc0 8a07 	vstr	s17, [r0, #28]
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8029546:	ee00 1a10 	vmov	s0, r1
 802954a:	4632      	mov	r2, r6
 802954c:	3038      	adds	r0, #56	; 0x38
 802954e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029552:	ed84 7a09 	vstr	s14, [r4, #36]	; 0x24
 8029556:	f2c2 0800 	movt	r8, #8192	; 0x2000
 802955a:	f2c2 0700 	movt	r7, #8192	; 0x2000
 802955e:	f104 0540 	add.w	r5, r4, #64	; 0x40
 8029562:	f104 0a50 	add.w	sl, r4, #80	; 0x50
    tTapeDelay_initToPool(&r->in_delay, 0.f, SAMP(200.f), mp);
 8029566:	ee17 1a90 	vmov	r1, s15
 802956a:	f7f9 fd4b 	bl	8023004 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->in_filter, 1.f, mp);
 802956e:	4631      	mov	r1, r6
 8029570:	eeb0 0a68 	vmov.f32	s0, s17
 8029574:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 8029578:	f7fc fde0 	bl	802613c <tOnePole_initToPool>
        tAllpass_initToPool(&r->in_allpass[i], SAMP(in_allpass_delays[i]), SAMP(20.f), mp); // * r->size_max
 802957c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029580:	4628      	mov	r0, r5
 8029582:	ecb8 0a01 	vldmia	r8!, {s0}
 8029586:	4632      	mov	r2, r6
 8029588:	ee27 7a88 	vmul.f32	s14, s15, s16
 802958c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029590:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8029594:	ee17 1a90 	vmov	r1, s15
 8029598:	f7fc fd7c 	bl	8026094 <tAllpass_initToPool>
        tAllpass_setGain(&r->in_allpass[i], in_allpass_gains[i]);
 802959c:	4628      	mov	r0, r5
 802959e:	3504      	adds	r5, #4
 80295a0:	ecb7 0a01 	vldmia	r7!, {s0}
 80295a4:	f7fc fdac 	bl	8026100 <tAllpass_setGain>
    for (int i = 0; i < 4; i++)
 80295a8:	4555      	cmp	r5, sl
 80295aa:	d1e7      	bne.n	802957c <tDattorroReverb_initToPool+0x9c>
    }
    
    // FEEDBACK 1
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80295ac:	2100      	movs	r1, #0
 80295ae:	f241 437b 	movw	r3, #5243	; 0x147b
 80295b2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80295b6:	4632      	mov	r2, r6
 80295b8:	f2c4 21c8 	movt	r1, #17096	; 0x42c8
 80295bc:	f2c4 13f4 	movt	r3, #16884	; 0x41f4
 80295c0:	4628      	mov	r0, r5
    tAllpass_setGain(&r->f1_allpass, 0.7f);
    
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
 80295c2:	eeb7 8a00 	vmov.f32	s16, #112	; 0x3f800000  1.0
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80295c6:	ee09 1a10 	vmov	s18, r1
 80295ca:	ee07 3a90 	vmov	s15, r3
    
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f1_lfo, mp);
 80295ce:	f104 0868 	add.w	r8, r4, #104	; 0x68
    tCycle_setFreq(&r->f1_lfo, 0.1f);
    
    // FEEDBACK 2
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
 80295d2:	f104 076c 	add.w	r7, r4, #108	; 0x6c
    tAllpass_initToPool(&r->f1_allpass, SAMP(30.51f), SAMP(100.f), mp); // * r->size_max
 80295d6:	ee20 7a09 	vmul.f32	s14, s0, s18
 80295da:	ee20 0a27 	vmul.f32	s0, s0, s15
 80295de:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 80295e2:	ee17 1a90 	vmov	r1, s15
 80295e6:	f7fc fd55 	bl	8026094 <tAllpass_initToPool>
    tAllpass_setGain(&r->f1_allpass, 0.7f);
 80295ea:	f243 3333 	movw	r3, #13107	; 0x3333
 80295ee:	4628      	mov	r0, r5
    
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
    
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
    
    tCycle_initToPool(&r->f2_lfo, mp);
 80295f0:	f104 0584 	add.w	r5, r4, #132	; 0x84
    tAllpass_setGain(&r->f1_allpass, 0.7f);
 80295f4:	f6c3 7333 	movt	r3, #16179	; 0x3f33
 80295f8:	ee00 3a10 	vmov	s0, r3
 80295fc:	f7fc fd80 	bl	8026100 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f1_delay_1, SAMP(141.69f), SAMP(200.0f) * r->size_max + 1, mp);
 8029600:	2100      	movs	r1, #0
 8029602:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029606:	eef0 6a48 	vmov.f32	s13, s16
 802960a:	ed94 7a08 	vldr	s14, [r4, #32]
 802960e:	f2c4 3148 	movt	r1, #17224	; 0x4348
 8029612:	f24b 03a4 	movw	r3, #45220	; 0xb0a4
 8029616:	f104 0054 	add.w	r0, r4, #84	; 0x54
 802961a:	ee20 7a07 	vmul.f32	s14, s0, s14
 802961e:	ee08 1a90 	vmov	s17, r1
 8029622:	f2c4 330d 	movt	r3, #17165	; 0x430d
 8029626:	4632      	mov	r2, r6
 8029628:	eee7 6a28 	vfma.f32	s13, s14, s17
 802962c:	ee07 3a90 	vmov	s15, r3
 8029630:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029634:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 8029638:	ee17 1a90 	vmov	r1, s15
 802963c:	f7f9 fce2 	bl	8023004 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_2, SAMP(89.24f), SAMP(100.0f) * r->size_max + 1, mp);
 8029640:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029644:	ed94 7a08 	vldr	s14, [r4, #32]
 8029648:	eef0 6a48 	vmov.f32	s13, s16
 802964c:	f647 23e1 	movw	r3, #31457	; 0x7ae1
 8029650:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8029654:	ee20 7a07 	vmul.f32	s14, s0, s14
 8029658:	4632      	mov	r2, r6
 802965a:	f2c4 23b2 	movt	r3, #17074	; 0x42b2
 802965e:	eee7 6a09 	vfma.f32	s13, s14, s18
 8029662:	ee07 3a90 	vmov	s15, r3
 8029666:	ee20 0a27 	vmul.f32	s0, s0, s15
 802966a:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 802966e:	ee17 1a90 	vmov	r1, s15
 8029672:	f7f9 fcc7 	bl	8023004 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f1_delay_3, SAMP(125.f), SAMP(200.0f) * r->size_max + 1, mp);
 8029676:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 802967a:	ed94 7a08 	vldr	s14, [r4, #32]
 802967e:	eef0 6a48 	vmov.f32	s13, s16
 8029682:	2300      	movs	r3, #0
 8029684:	4632      	mov	r2, r6
 8029686:	ee20 7a07 	vmul.f32	s14, s0, s14
 802968a:	f104 0060 	add.w	r0, r4, #96	; 0x60
 802968e:	f2c4 23fa 	movt	r3, #17146	; 0x42fa
 8029692:	eee7 6a28 	vfma.f32	s13, s14, s17
 8029696:	ee07 3a90 	vmov	s15, r3
 802969a:	ee20 0a27 	vmul.f32	s0, s0, s15
 802969e:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 80296a2:	ee17 1a90 	vmov	r1, s15
 80296a6:	f7f9 fcad 	bl	8023004 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f1_filter, 1.f, mp);
 80296aa:	eeb0 0a48 	vmov.f32	s0, s16
 80296ae:	f104 0058 	add.w	r0, r4, #88	; 0x58
 80296b2:	4631      	mov	r1, r6
 80296b4:	f7fc fd42 	bl	802613c <tOnePole_initToPool>
    tHighpass_initToPool(&r->f1_hp, 20.f, mp);
 80296b8:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 80296bc:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80296c0:	4631      	mov	r1, r6
 80296c2:	f7fc ff81 	bl	80265c8 <tHighpass_initToPool>
    tCycle_initToPool(&r->f1_lfo, mp);
 80296c6:	4631      	mov	r1, r6
 80296c8:	4640      	mov	r0, r8
 80296ca:	f7ff f83b 	bl	8028744 <tCycle_initToPool>
    tCycle_setFreq(&r->f1_lfo, 0.1f);
 80296ce:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 80296d2:	4640      	mov	r0, r8
 80296d4:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 80296d8:	ee00 3a10 	vmov	s0, r3
 80296dc:	f7ff f844 	bl	8028768 <tCycle_setFreq>
    tAllpass_initToPool(&r->f2_allpass, SAMP(22.58f), SAMP(100.f), mp); // * r->size_max
 80296e0:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 80296e4:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
 80296e8:	4632      	mov	r2, r6
 80296ea:	ee20 7a09 	vmul.f32	s14, s0, s18
 80296ee:	4638      	mov	r0, r7
 80296f0:	f2c4 13b4 	movt	r3, #16820	; 0x41b4
 80296f4:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 80296f8:	ee07 3a90 	vmov	s15, r3
 80296fc:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029700:	ee17 1a10 	vmov	r1, s14
 8029704:	f7fc fcc6 	bl	8026094 <tAllpass_initToPool>
    tAllpass_setGain(&r->f2_allpass, 0.7f);
 8029708:	f243 3333 	movw	r3, #13107	; 0x3333
 802970c:	4638      	mov	r0, r7
 802970e:	f6c3 7333 	movt	r3, #16179	; 0x3f33
 8029712:	ee00 3a10 	vmov	s0, r3
 8029716:	f7fc fcf3 	bl	8026100 <tAllpass_setGain>
    tTapeDelay_initToPool(&r->f2_delay_1, SAMP(149.62f), SAMP(200.f) * r->size_max + 1, mp);
 802971a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 802971e:	ed94 7a08 	vldr	s14, [r4, #32]
 8029722:	eef0 6a48 	vmov.f32	s13, s16
 8029726:	f649 63b8 	movw	r3, #40632	; 0x9eb8
 802972a:	f104 0070 	add.w	r0, r4, #112	; 0x70
 802972e:	ee20 7a07 	vmul.f32	s14, s0, s14
 8029732:	4632      	mov	r2, r6
 8029734:	f2c4 3315 	movt	r3, #17173	; 0x4315
 8029738:	eee7 6a28 	vfma.f32	s13, s14, s17
 802973c:	ee07 3a90 	vmov	s15, r3
 8029740:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029744:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 8029748:	ee17 1a90 	vmov	r1, s15
 802974c:	f7f9 fc5a 	bl	8023004 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_2, SAMP(60.48f), SAMP(100.f) * r->size_max + 1, mp);
 8029750:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029754:	ed94 7a08 	vldr	s14, [r4, #32]
 8029758:	eef0 6a48 	vmov.f32	s13, s16
 802975c:	f64e 3385 	movw	r3, #60293	; 0xeb85
 8029760:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8029764:	ee20 7a07 	vmul.f32	s14, s0, s14
 8029768:	4632      	mov	r2, r6
 802976a:	f2c4 2371 	movt	r3, #17009	; 0x4271
 802976e:	eee7 6a09 	vfma.f32	s13, s14, s18
 8029772:	ee07 3a90 	vmov	s15, r3
 8029776:	ee20 0a27 	vmul.f32	s0, s0, s15
 802977a:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 802977e:	ee17 1a90 	vmov	r1, s15
 8029782:	f7f9 fc3f 	bl	8023004 <tTapeDelay_initToPool>
    tTapeDelay_initToPool(&r->f2_delay_3, SAMP(106.28f), SAMP(200.f) * r->size_max + 1, mp);
 8029786:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 802978a:	ed94 7a08 	vldr	s14, [r4, #32]
 802978e:	eef0 6a48 	vmov.f32	s13, s16
 8029792:	f648 735c 	movw	r3, #36700	; 0x8f5c
 8029796:	4632      	mov	r2, r6
 8029798:	ee20 7a07 	vmul.f32	s14, s0, s14
 802979c:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 80297a0:	f2c4 23d4 	movt	r3, #17108	; 0x42d4
 80297a4:	eee7 6a28 	vfma.f32	s13, s14, s17
 80297a8:	ee07 3a90 	vmov	s15, r3
 80297ac:	ee20 0a27 	vmul.f32	s0, s0, s15
 80297b0:	eefc 7ae6 	vcvt.u32.f32	s15, s13
 80297b4:	ee17 1a90 	vmov	r1, s15
 80297b8:	f7f9 fc24 	bl	8023004 <tTapeDelay_initToPool>
    tOnePole_initToPool(&r->f2_filter, 1.f, mp);
 80297bc:	eeb0 0a48 	vmov.f32	s0, s16
 80297c0:	f104 0074 	add.w	r0, r4, #116	; 0x74
 80297c4:	4631      	mov	r1, r6
 80297c6:	f7fc fcb9 	bl	802613c <tOnePole_initToPool>
    tHighpass_initToPool(&r->f2_hp, 20.f, mp);
 80297ca:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 80297ce:	f104 0080 	add.w	r0, r4, #128	; 0x80
 80297d2:	4631      	mov	r1, r6
 80297d4:	f7fc fef8 	bl	80265c8 <tHighpass_initToPool>
    tCycle_initToPool(&r->f2_lfo, mp);
 80297d8:	4631      	mov	r1, r6
 80297da:	4628      	mov	r0, r5
 80297dc:	f7fe ffb2 	bl	8028744 <tCycle_initToPool>
    tCycle_setFreq(&r->f2_lfo, 0.07f);
 80297e0:	f645 4329 	movw	r3, #23593	; 0x5c29
 80297e4:	4628      	mov	r0, r5
 80297e6:	f6c3 538f 	movt	r3, #15759	; 0x3d8f
 80297ea:	ee00 3a10 	vmov	s0, r3
 80297ee:	f7fe ffbb 	bl	8028768 <tCycle_setFreq>
}

void    tDattorroReverb_setMix            (tDattorroReverb* const rev, float mix)
{
    _tDattorroReverb* r = *rev;
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 80297f2:	2300      	movs	r3, #0
 80297f4:	eeb0 1a48 	vmov.f32	s2, s16
    _tDattorroReverb* r = *rev;
 80297f8:	f8d9 4000 	ldr.w	r4, [r9]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 80297fc:	eef6 0a00 	vmov.f32	s1, #96	; 0x3f000000  0.5
 8029800:	ee00 3a10 	vmov	s0, r3
 8029804:	f7fe f8d8 	bl	80279b8 <LEAF_clip>

void    tDattorroReverb_setInputDelay     (tDattorroReverb* const rev, float preDelay)
{
    _tDattorroReverb* r = *rev;
    
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8029808:	2300      	movs	r3, #0
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 802980a:	ed84 0a05 	vstr	s0, [r4, #20]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 802980e:	eeb0 1a68 	vmov.f32	s2, s17
    _tDattorroReverb* r = *rev;
 8029812:	f8d9 4000 	ldr.w	r4, [r9]
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 8029816:	ee00 3a90 	vmov	s1, r3
 802981a:	ee00 3a10 	vmov	s0, r3
 802981e:	f7fe f8cb 	bl	80279b8 <LEAF_clip>
    
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
 8029822:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029826:	f104 0038 	add.w	r0, r4, #56	; 0x38
    r->predelay = LEAF_clip(0.0f, preDelay, 200.0f);
 802982a:	ed84 0a01 	vstr	s0, [r4, #4]
    tTapeDelay_setDelay(&r->in_delay, SAMP(r->predelay));
 802982e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029832:	f7f9 fc99 	bl	8023168 <tTapeDelay_setDelay>

void    tDattorroReverb_setInputFilter    (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
    
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029836:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 802983a:	2100      	movs	r1, #0
    _tDattorroReverb* r = *rev;
 802983c:	f8d9 4000 	ldr.w	r4, [r9]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029840:	4613      	mov	r3, r2
 8029842:	f2c4 629c 	movt	r2, #18076	; 0x469c
 8029846:	ee00 1a10 	vmov	s0, r1
 802984a:	f2c4 631c 	movt	r3, #17948	; 0x461c
 802984e:	ee01 2a10 	vmov	s2, r2
 8029852:	ee00 3a90 	vmov	s1, r3
 8029856:	f7fe f8af 	bl	80279b8 <LEAF_clip>
    
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 802985a:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 802985e:	ed84 0a02 	vstr	s0, [r4, #8]
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8029862:	f7fc fca5 	bl	80261b0 <tOnePole_setFreq>

void    tDattorroReverb_setFeedbackFilter (tDattorroReverb* const rev, float freq)
{
    _tDattorroReverb* r = *rev;
    
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029866:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 802986a:	2100      	movs	r1, #0
    _tDattorroReverb* r = *rev;
 802986c:	f8d9 4000 	ldr.w	r4, [r9]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029870:	4613      	mov	r3, r2
 8029872:	f2c4 629c 	movt	r2, #18076	; 0x469c
 8029876:	ee00 1a10 	vmov	s0, r1
 802987a:	f2c4 539c 	movt	r3, #17820	; 0x459c
 802987e:	ee01 2a10 	vmov	s2, r2
 8029882:	ee00 3a90 	vmov	s1, r3
 8029886:	f7fe f897 	bl	80279b8 <LEAF_clip>
    
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 802988a:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 802988e:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8029892:	f7fc fc8d 	bl	80261b0 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8029896:	ed94 0a03 	vldr	s0, [r4, #12]
 802989a:	f104 0074 	add.w	r0, r4, #116	; 0x74
 802989e:	f7fc fc87 	bl	80261b0 <tOnePole_setFreq>
}

void    tDattorroReverb_setFeedbackGain   (tDattorroReverb* const rev, float gain)
{
    _tDattorroReverb* r = *rev;
    r->feedback_gain = gain;
 80298a2:	f64c 43cd 	movw	r3, #52429	; 0xcccd
    _tDattorroReverb* r = *rev;
 80298a6:	f8d9 2000 	ldr.w	r2, [r9]
    r->feedback_gain = gain;
 80298aa:	f6c3 63cc 	movt	r3, #16076	; 0x3ecc
 80298ae:	6113      	str	r3, [r2, #16]
}
 80298b0:	ecbd 8b04 	vpop	{d8-d9}
 80298b4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080298b8 <tDattorroReverb_init>:
    tDattorroReverb_initToPool(rev, &leaf.mempool);
 80298b8:	f249 41b8 	movw	r1, #38072	; 0x94b8
 80298bc:	f2c2 0101 	movt	r1, #8193	; 0x2001
 80298c0:	f7ff be0e 	b.w	80294e0 <tDattorroReverb_initToPool>

080298c4 <tDattorroReverb_free>:
{
 80298c4:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 80298c6:	6804      	ldr	r4, [r0, #0]
    tTapeDelay_free(&r->in_delay);
 80298c8:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80298cc:	f7f9 fbca 	bl	8023064 <tTapeDelay_free>
    tOnePole_free(&r->in_filter);
 80298d0:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 80298d4:	f7fc fc68 	bl	80261a8 <tOnePole_free>
        tAllpass_free(&r->in_allpass[i]);
 80298d8:	f104 0040 	add.w	r0, r4, #64	; 0x40
 80298dc:	f7fc fc00 	bl	80260e0 <tAllpass_free>
 80298e0:	f104 0044 	add.w	r0, r4, #68	; 0x44
 80298e4:	f7fc fbfc 	bl	80260e0 <tAllpass_free>
 80298e8:	f104 0048 	add.w	r0, r4, #72	; 0x48
 80298ec:	f7fc fbf8 	bl	80260e0 <tAllpass_free>
 80298f0:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 80298f4:	f7fc fbf4 	bl	80260e0 <tAllpass_free>
    tAllpass_free(&r->f1_allpass);
 80298f8:	f104 0050 	add.w	r0, r4, #80	; 0x50
 80298fc:	f7fc fbf0 	bl	80260e0 <tAllpass_free>
    tTapeDelay_free(&r->f1_delay_1);
 8029900:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8029904:	f7f9 fbae 	bl	8023064 <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_2);
 8029908:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 802990c:	f7f9 fbaa 	bl	8023064 <tTapeDelay_free>
    tTapeDelay_free(&r->f1_delay_3);
 8029910:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8029914:	f7f9 fba6 	bl	8023064 <tTapeDelay_free>
    tOnePole_free(&r->f1_filter);
 8029918:	f104 0058 	add.w	r0, r4, #88	; 0x58
 802991c:	f7fc fc44 	bl	80261a8 <tOnePole_free>
    tHighpass_free(&r->f1_hp);
 8029920:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8029924:	f7fc fe72 	bl	802660c <tHighpass_free>
    tCycle_free(&r->f1_lfo);
 8029928:	f104 0068 	add.w	r0, r4, #104	; 0x68
 802992c:	f7fe ff18 	bl	8028760 <tCycle_free>
    tAllpass_free(&r->f2_allpass);
 8029930:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8029934:	f7fc fbd4 	bl	80260e0 <tAllpass_free>
    tTapeDelay_free(&r->f2_delay_1);
 8029938:	f104 0070 	add.w	r0, r4, #112	; 0x70
 802993c:	f7f9 fb92 	bl	8023064 <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_2);
 8029940:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8029944:	f7f9 fb8e 	bl	8023064 <tTapeDelay_free>
    tTapeDelay_free(&r->f2_delay_3);
 8029948:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 802994c:	f7f9 fb8a 	bl	8023064 <tTapeDelay_free>
    tOnePole_free(&r->f2_filter);
 8029950:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8029954:	f7fc fc28 	bl	80261a8 <tOnePole_free>
    tHighpass_free(&r->f2_hp);
 8029958:	f104 0080 	add.w	r0, r4, #128	; 0x80
 802995c:	f7fc fe56 	bl	802660c <tHighpass_free>
    tCycle_free(&r->f2_lfo);
 8029960:	f104 0084 	add.w	r0, r4, #132	; 0x84
 8029964:	f7fe fefc 	bl	8028760 <tCycle_free>
    mpool_free((char*)r, r->mempool);
 8029968:	6821      	ldr	r1, [r4, #0]
 802996a:	4620      	mov	r0, r4
}
 802996c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)r, r->mempool);
 8029970:	f7fe bae6 	b.w	8027f40 <mpool_free>

08029974 <tDattorroReverb_tickStereo>:
{
 8029974:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8029978:	ed2d 8b06 	vpush	{d8-d10}
    _tDattorroReverb* r = *rev;
 802997c:	6804      	ldr	r4, [r0, #0]
    	input = 0.0f;
 802997e:	2300      	movs	r3, #0
{
 8029980:	460e      	mov	r6, r1
    if (r->frozen)
 8029982:	69a2      	ldr	r2, [r4, #24]
    	input = 0.0f;
 8029984:	ee09 3a90 	vmov	s19, r3
	in_sample = tTapeDelay_tick(&r->in_delay, input);
 8029988:	f104 0038 	add.w	r0, r4, #56	; 0x38
 802998c:	f104 0540 	add.w	r5, r4, #64	; 0x40
    	input = 0.0f;
 8029990:	429a      	cmp	r2, r3
 8029992:	f104 0750 	add.w	r7, r4, #80	; 0x50
 8029996:	fe40 9a29 	vseleq.f32	s19, s0, s19
	in_sample = tTapeDelay_tick(&r->in_delay, input);
 802999a:	eeb0 0a69 	vmov.f32	s0, s19
 802999e:	f7f9 fb6d 	bl	802307c <tTapeDelay_tick>
	in_sample = tOnePole_tick(&r->in_filter, in_sample);
 80299a2:	f104 003c 	add.w	r0, r4, #60	; 0x3c
 80299a6:	f7fc fc1f 	bl	80261e8 <tOnePole_tick>
 80299aa:	eeb0 8a40 	vmov.f32	s16, s0
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
 80299ae:	4628      	mov	r0, r5
 80299b0:	3504      	adds	r5, #4
 80299b2:	eeb0 0a48 	vmov.f32	s0, s16
 80299b6:	f7fc fba7 	bl	8026108 <tAllpass_tick>
	for (int i = 0; i < 4; i++)
 80299ba:	42bd      	cmp	r5, r7
		in_sample = tAllpass_tick(&r->in_allpass[i], in_sample);
 80299bc:	eeb0 8a40 	vmov.f32	s16, s0
	for (int i = 0; i < 4; i++)
 80299c0:	d1f5      	bne.n	80299ae <tDattorroReverb_tickStereo+0x3a>
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
 80299c2:	edd4 8a0d 	vldr	s17, [r4, #52]	; 0x34
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 80299c6:	f104 0068 	add.w	r0, r4, #104	; 0x68
 80299ca:	ed94 9a09 	vldr	s18, [r4, #36]	; 0x24
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
 80299ce:	f104 0854 	add.w	r8, r4, #84	; 0x54
		f1_sample = in_sample + r->f2_last; // + f2_last_out;
 80299d2:	ee70 8a28 	vadd.f32	s17, s0, s17
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 80299d6:	f7fe fed5 	bl	8028784 <tCycle_tick>
 80299da:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 80299de:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 80299e2:	f241 437b 	movw	r3, #5243	; 0x147b
 80299e6:	4628      	mov	r0, r5
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 80299e8:	f104 075c 	add.w	r7, r4, #92	; 0x5c
		tAllpass_setDelay(&r->f1_allpass, SAMP(30.51f) + tCycle_tick(&r->f1_lfo) * SAMP(4.0f));
 80299ec:	ee67 7a87 	vmul.f32	s15, s15, s14
 80299f0:	f2c4 13f4 	movt	r3, #16884	; 0x41f4
 80299f4:	ee07 3a10 	vmov	s14, r3
 80299f8:	ee27 0a80 	vmul.f32	s0, s15, s0
 80299fc:	eea9 0a07 	vfma.f32	s0, s18, s14
 8029a00:	f7fc fb7a 	bl	80260f8 <tAllpass_setDelay>
		f1_sample = tAllpass_tick(&r->f1_allpass, f1_sample);
 8029a04:	eeb0 0a68 	vmov.f32	s0, s17
 8029a08:	4628      	mov	r0, r5
 8029a0a:	f7fc fb7d 	bl	8026108 <tAllpass_tick>
		f1_sample = tTapeDelay_tick(&r->f1_delay_1, f1_sample);
 8029a0e:	4640      	mov	r0, r8
 8029a10:	f7f9 fb34 	bl	802307c <tTapeDelay_tick>
		f1_sample = tOnePole_tick(&r->f1_filter, f1_sample);
 8029a14:	f104 0058 	add.w	r0, r4, #88	; 0x58
 8029a18:	f7fc fbe6 	bl	80261e8 <tOnePole_tick>
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
 8029a1c:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8029a20:	ed94 7a0a 	vldr	s14, [r4, #40]	; 0x28
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 8029a24:	4638      	mov	r0, r7
		f1_sample = f1_sample + r->f1_delay_2_last * 0.5f;
 8029a26:	eea7 0a27 	vfma.f32	s0, s14, s15
 8029a2a:	eef0 8a40 	vmov.f32	s17, s0
		f1_delay_2_sample = tTapeDelay_tick(&r->f1_delay_2, f1_sample * 0.5f);
 8029a2e:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029a32:	f7f9 fb23 	bl	802307c <tTapeDelay_tick>
 8029a36:	eef0 7a40 	vmov.f32	s15, s0
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
 8029a3a:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8029a3e:	ee38 0a80 	vadd.f32	s0, s17, s0
		r->f1_delay_2_last = f1_delay_2_sample;
 8029a42:	edc4 7a0a 	vstr	s15, [r4, #40]	; 0x28
		f1_sample = tHighpass_tick(&r->f1_hp, f1_sample);
 8029a46:	f7fc fdf5 	bl	8026634 <tHighpass_tick>
		if (r->frozen)
 8029a4a:	69a3      	ldr	r3, [r4, #24]
		f1_sample *= r->feedback_gain;
 8029a4c:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
 8029a50:	2b00      	cmp	r3, #0
 8029a52:	f040 8150 	bne.w	8029cf6 <tDattorroReverb_tickStereo+0x382>
		f1_sample *= r->feedback_gain;
 8029a56:	ee27 0a80 	vmul.f32	s0, s15, s0
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8029a5a:	f104 0560 	add.w	r5, r4, #96	; 0x60
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8029a5e:	f104 0b6c 	add.w	fp, r4, #108	; 0x6c
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
 8029a62:	f104 0970 	add.w	r9, r4, #112	; 0x70
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8029a66:	f104 0a78 	add.w	sl, r4, #120	; 0x78
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8029a6a:	4628      	mov	r0, r5
 8029a6c:	f7f9 fb06 	bl	802307c <tTapeDelay_tick>
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8029a70:	f104 0084 	add.w	r0, r4, #132	; 0x84
		r->f1_last = tTapeDelay_tick(&r->f1_delay_3, f1_sample);
 8029a74:	ed84 0a0c 	vstr	s0, [r4, #48]	; 0x30
		f2_sample = in_sample + r->f1_last;
 8029a78:	ee30 8a08 	vadd.f32	s16, s0, s16
		tAllpass_setDelay(&r->f2_allpass, SAMP(22.58f) + tCycle_tick(&r->f2_lfo) * SAMP(4.0f));
 8029a7c:	edd4 8a09 	vldr	s17, [r4, #36]	; 0x24
 8029a80:	f7fe fe80 	bl	8028784 <tCycle_tick>
 8029a84:	eeb1 7a00 	vmov.f32	s14, #16	; 0x40800000  4.0
 8029a88:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029a8c:	f24a 33d7 	movw	r3, #41943	; 0xa3d7
 8029a90:	4658      	mov	r0, fp
 8029a92:	ee67 7a87 	vmul.f32	s15, s15, s14
 8029a96:	f2c4 13b4 	movt	r3, #16820	; 0x41b4
 8029a9a:	ee07 3a10 	vmov	s14, r3
 8029a9e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029aa2:	eea8 0a87 	vfma.f32	s0, s17, s14
 8029aa6:	f7fc fb27 	bl	80260f8 <tAllpass_setDelay>
		f2_sample = tAllpass_tick(&r->f2_allpass, f2_sample);
 8029aaa:	eeb0 0a48 	vmov.f32	s0, s16
 8029aae:	4658      	mov	r0, fp
 8029ab0:	f7fc fb2a 	bl	8026108 <tAllpass_tick>
		f2_sample = tTapeDelay_tick(&r->f2_delay_1, f2_sample);
 8029ab4:	4648      	mov	r0, r9
 8029ab6:	f7f9 fae1 	bl	802307c <tTapeDelay_tick>
		f2_sample = tOnePole_tick(&r->f2_filter, f2_sample);
 8029aba:	f104 0074 	add.w	r0, r4, #116	; 0x74
 8029abe:	f7fc fb93 	bl	80261e8 <tOnePole_tick>
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
 8029ac2:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 8029ac6:	ed94 7a0b 	vldr	s14, [r4, #44]	; 0x2c
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8029aca:	4650      	mov	r0, sl
		f2_sample = f2_sample + r->f2_delay_2_last * 0.5f;
 8029acc:	eea7 0a27 	vfma.f32	s0, s14, s15
 8029ad0:	eeb0 8a40 	vmov.f32	s16, s0
		f2_delay_2_sample = tTapeDelay_tick(&r->f2_delay_2, f2_sample * 0.5f);
 8029ad4:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029ad8:	f7f9 fad0 	bl	802307c <tTapeDelay_tick>
 8029adc:	eef0 7a40 	vmov.f32	s15, s0
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
 8029ae0:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8029ae4:	ee38 0a00 	vadd.f32	s0, s16, s0
		r->f2_delay_2_last = f2_delay_2_sample;
 8029ae8:	edc4 7a0b 	vstr	s15, [r4, #44]	; 0x2c
		f2_sample = tHighpass_tick(&r->f2_hp, f2_sample);
 8029aec:	f7fc fda2 	bl	8026634 <tHighpass_tick>
		if (r->frozen)
 8029af0:	69a3      	ldr	r3, [r4, #24]
		f2_sample *= r->feedback_gain;
 8029af2:	edd4 7a04 	vldr	s15, [r4, #16]
		if (r->frozen)
 8029af6:	2b00      	cmp	r3, #0
 8029af8:	f000 8101 	beq.w	8029cfe <tDattorroReverb_tickStereo+0x38a>
			f2_sample = 0.0f;
 8029afc:	2300      	movs	r3, #0
 8029afe:	ee00 3a10 	vmov	s0, r3
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
 8029b02:	f104 0b7c 	add.w	fp, r4, #124	; 0x7c
 8029b06:	4658      	mov	r0, fp
 8029b08:	f7f9 fab8 	bl	802307c <tTapeDelay_tick>
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8029b0c:	f246 6366 	movw	r3, #26214	; 0x6666
 8029b10:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029b14:	4640      	mov	r0, r8
 8029b16:	f2c4 130e 	movt	r3, #16654	; 0x410e
		r->f2_last = tTapeDelay_tick(&r->f2_delay_3, f2_sample);
 8029b1a:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8029b1e:	ee00 3a10 	vmov	s0, r3
 8029b22:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029b26:	f7f9 fb2f 	bl	8023188 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
 8029b2a:	f649 139a 	movw	r3, #39322	; 0x999a
    f1_sample =     tTapeDelay_tapOut(&r->f1_delay_1, SAMP(8.9f)) +
 8029b2e:	eeb0 8a40 	vmov.f32	s16, s0
    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(99.8f));
 8029b32:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029b36:	f2c4 23c7 	movt	r3, #17095	; 0x42c7
 8029b3a:	4640      	mov	r0, r8
 8029b3c:	ee07 3a90 	vmov	s15, r3
 8029b40:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029b44:	f7f9 fb20 	bl	8023188 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
 8029b48:	f246 6366 	movw	r3, #26214	; 0x6666
 8029b4c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029b50:	ee38 8a00 	vadd.f32	s16, s16, s0
 8029b54:	f2c4 2380 	movt	r3, #17024	; 0x4280
 8029b58:	4638      	mov	r0, r7
 8029b5a:	ee00 3a10 	vmov	s0, r3
 8029b5e:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029b62:	f7f9 fb11 	bl	8023188 <tTapeDelay_tapOut>
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8029b66:	2300      	movs	r3, #0
    f1_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(64.2f));
 8029b68:	eef0 8a40 	vmov.f32	s17, s0
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8029b6c:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029b70:	f2c4 2386 	movt	r3, #17030	; 0x4286
 8029b74:	4628      	mov	r0, r5
 8029b76:	ee07 3a90 	vmov	s15, r3
 8029b7a:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029b7e:	f7f9 fb03 	bl	8023188 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8029b82:	f649 139a 	movw	r3, #39322	; 0x999a
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8029b86:	ee30 9a08 	vadd.f32	s18, s0, s16
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8029b8a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029b8e:	f2c4 2385 	movt	r3, #17029	; 0x4285
 8029b92:	4648      	mov	r0, r9
 8029b94:	ee07 3a90 	vmov	s15, r3
    f1_sample +=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(67.f));
 8029b98:	ee39 9a68 	vsub.f32	s18, s18, s17
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8029b9c:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029ba0:	f7f9 faf2 	bl	8023188 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8029ba4:	f649 139a 	movw	r3, #39322	; 0x999a
 8029ba8:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(66.8f));
 8029bac:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8029bb0:	f2c4 03c9 	movt	r3, #16585	; 0x40c9
 8029bb4:	4650      	mov	r0, sl
 8029bb6:	ee08 3a10 	vmov	s16, r3
 8029bba:	ee27 0a88 	vmul.f32	s0, s15, s16
 8029bbe:	f7f9 fae3 	bl	8023188 <tTapeDelay_tapOut>
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8029bc2:	f243 3333 	movw	r3, #13107	; 0x3333
 8029bc6:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8029bca:	ee39 9a40 	vsub.f32	s18, s18, s0
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8029bce:	f2c4 230f 	movt	r3, #16911	; 0x420f
 8029bd2:	4658      	mov	r0, fp
 8029bd4:	ee00 3a10 	vmov	s0, r3
 8029bd8:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029bdc:	f7f9 fad4 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8029be0:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8029be4:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f1_sample -=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(35.8f));
 8029be8:	ee39 9a40 	vsub.f32	s18, s18, s0
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8029bec:	f2c4 133c 	movt	r3, #16700	; 0x413c
 8029bf0:	4648      	mov	r0, r9
 8029bf2:	ee00 3a10 	vmov	s0, r3
 8029bf6:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029bfa:	f7f9 fac5 	bl	8023188 <tTapeDelay_tapOut>
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
 8029bfe:	f246 6366 	movw	r3, #26214	; 0x6666
    f2_sample =     tTapeDelay_tapOut(&r->f2_delay_1, SAMP(11.8f)) +
 8029c02:	eef0 8a40 	vmov.f32	s17, s0
    tTapeDelay_tapOut(&r->f2_delay_1, SAMP(121.7f));
 8029c06:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029c0a:	f2c4 23f3 	movt	r3, #17139	; 0x42f3
 8029c0e:	4648      	mov	r0, r9
 8029c10:	ee07 3a90 	vmov	s15, r3
 8029c14:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029c18:	f7f9 fab6 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8029c1c:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
 8029c20:	ee78 8a80 	vadd.f32	s17, s17, s0
 8029c24:	4650      	mov	r0, sl
 8029c26:	ee27 0a88 	vmul.f32	s0, s15, s16
 8029c2a:	f7f9 faad 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8029c2e:	f246 6366 	movw	r3, #26214	; 0x6666
    f2_sample -=    tTapeDelay_tapOut(&r->f2_delay_2, SAMP(6.3f));
 8029c32:	eeb0 aa40 	vmov.f32	s20, s0
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8029c36:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029c3a:	f2c4 23b3 	movt	r3, #17075	; 0x42b3
 8029c3e:	4658      	mov	r0, fp
 8029c40:	ee07 3a90 	vmov	s15, r3
 8029c44:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029c48:	f7f9 fa9e 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8029c4c:	f649 139a 	movw	r3, #39322	; 0x999a
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8029c50:	ee30 8a28 	vadd.f32	s16, s0, s17
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8029c54:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029c58:	f2c4 238d 	movt	r3, #17037	; 0x428d
 8029c5c:	4640      	mov	r0, r8
 8029c5e:	ee07 3a90 	vmov	s15, r3
    f2_sample +=    tTapeDelay_tapOut(&r->f2_delay_3, SAMP(89.7f));
 8029c62:	ee38 8a4a 	vsub.f32	s16, s16, s20
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8029c66:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029c6a:	f7f9 fa8d 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8029c6e:	f243 3333 	movw	r3, #13107	; 0x3333
 8029c72:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_1, SAMP(70.8f));
 8029c76:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8029c7a:	f2c4 1333 	movt	r3, #16691	; 0x4133
 8029c7e:	4638      	mov	r0, r7
 8029c80:	ee00 3a10 	vmov	s0, r3
 8029c84:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029c88:	f7f9 fa7e 	bl	8023188 <tTapeDelay_tapOut>
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8029c8c:	f243 3333 	movw	r3, #13107	; 0x3333
 8029c90:	edd4 7a09 	vldr	s15, [r4, #36]	; 0x24
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_2, SAMP(11.2f));
 8029c94:	ee38 8a40 	vsub.f32	s16, s16, s0
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8029c98:	f2c4 0383 	movt	r3, #16515	; 0x4083
 8029c9c:	4628      	mov	r0, r5
 8029c9e:	ee00 3a10 	vmov	s0, r3
 8029ca2:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029ca6:	f7f9 fa6f 	bl	8023188 <tTapeDelay_tapOut>
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
 8029caa:	f645 4329 	movw	r3, #23593	; 0x5c29
 8029cae:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 8029cb2:	edd4 7a05 	vldr	s15, [r4, #20]
 8029cb6:	f6c3 630f 	movt	r3, #15887	; 0x3e0f
    f2_sample -=    tTapeDelay_tapOut(&r->f1_delay_3, SAMP(4.1f));
 8029cba:	ee38 0a40 	vsub.f32	s0, s16, s0
    output[0] = input * (1.0f - r->mix) + f1_sample  * r->mix;
 8029cbe:	ee07 3a10 	vmov	s14, r3
 8029cc2:	ee36 6ae7 	vsub.f32	s12, s13, s15
 8029cc6:	ee67 7a87 	vmul.f32	s15, s15, s14
 8029cca:	ee27 9a89 	vmul.f32	s18, s15, s18
 8029cce:	eea6 9a29 	vfma.f32	s18, s12, s19
 8029cd2:	ed86 9a00 	vstr	s18, [r6]
    output[1] = input * (1.0f - r->mix) + f2_sample * r->mix;
 8029cd6:	edd4 7a05 	vldr	s15, [r4, #20]
 8029cda:	ee27 7a87 	vmul.f32	s14, s15, s14
 8029cde:	ee76 6ae7 	vsub.f32	s13, s13, s15
 8029ce2:	ee20 0a07 	vmul.f32	s0, s0, s14
 8029ce6:	eea6 0aa9 	vfma.f32	s0, s13, s19
 8029cea:	ed86 0a01 	vstr	s0, [r6, #4]
}
 8029cee:	ecbd 8b06 	vpop	{d8-d10}
 8029cf2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			f1_sample = 0.0f;
 8029cf6:	2300      	movs	r3, #0
 8029cf8:	ee00 3a10 	vmov	s0, r3
 8029cfc:	e6ad      	b.n	8029a5a <tDattorroReverb_tickStereo+0xe6>
		f2_sample *= r->feedback_gain;
 8029cfe:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029d02:	e6fe      	b.n	8029b02 <tDattorroReverb_tickStereo+0x18e>

08029d04 <tDattorroReverb_setMix>:
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8029d04:	2300      	movs	r3, #0
 8029d06:	eef0 0a40 	vmov.f32	s1, s0
 8029d0a:	eeb7 1a00 	vmov.f32	s2, #112	; 0x3f800000  1.0
 8029d0e:	ee00 3a10 	vmov	s0, r3
{
 8029d12:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8029d14:	6804      	ldr	r4, [r0, #0]
    r->mix = LEAF_clip(0.0f, mix, 1.0f);
 8029d16:	f7fd fe4f 	bl	80279b8 <LEAF_clip>
 8029d1a:	ed84 0a05 	vstr	s0, [r4, #20]
}
 8029d1e:	bd10      	pop	{r4, pc}

08029d20 <tDattorroReverb_setFreeze>:
{
 8029d20:	b570      	push	{r4, r5, r6, lr}
    _tDattorroReverb* r = *rev;
 8029d22:	6804      	ldr	r4, [r0, #0]
    r->frozen = freeze;
 8029d24:	61a1      	str	r1, [r4, #24]
 8029d26:	f104 006c 	add.w	r0, r4, #108	; 0x6c
 8029d2a:	f104 0650 	add.w	r6, r4, #80	; 0x50
 8029d2e:	f104 0568 	add.w	r5, r4, #104	; 0x68
 8029d32:	3484      	adds	r4, #132	; 0x84
    if (freeze)
 8029d34:	bb21      	cbnz	r1, 8029d80 <tDattorroReverb_setFreeze+0x60>
    	tAllpass_setGain(&r->f2_allpass, 0.7f);
 8029d36:	f243 3333 	movw	r3, #13107	; 0x3333
 8029d3a:	f6c3 7333 	movt	r3, #16179	; 0x3f33
 8029d3e:	ee00 3a10 	vmov	s0, r3
 8029d42:	f7fc f9dd 	bl	8026100 <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 0.7f);
 8029d46:	f243 3333 	movw	r3, #13107	; 0x3333
 8029d4a:	4630      	mov	r0, r6
 8029d4c:	f6c3 7333 	movt	r3, #16179	; 0x3f33
 8029d50:	ee00 3a10 	vmov	s0, r3
 8029d54:	f7fc f9d4 	bl	8026100 <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.1f);
 8029d58:	f64c 43cd 	movw	r3, #52429	; 0xcccd
 8029d5c:	4628      	mov	r0, r5
 8029d5e:	f6c3 53cc 	movt	r3, #15820	; 0x3dcc
 8029d62:	ee00 3a10 	vmov	s0, r3
 8029d66:	f7fe fcff 	bl	8028768 <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
 8029d6a:	f645 4329 	movw	r3, #23593	; 0x5c29
 8029d6e:	4620      	mov	r0, r4
 8029d70:	f6c3 538f 	movt	r3, #15759	; 0x3d8f
}
 8029d74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.07f);
 8029d78:	ee00 3a10 	vmov	s0, r3
 8029d7c:	f7fe bcf4 	b.w	8028768 <tCycle_setFreq>
    	tAllpass_setGain(&r->f2_allpass, 1.0f);
 8029d80:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8029d84:	f7fc f9bc 	bl	8026100 <tAllpass_setGain>
    	tAllpass_setGain(&r->f1_allpass, 1.0f);
 8029d88:	4630      	mov	r0, r6
 8029d8a:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 8029d8e:	f7fc f9b7 	bl	8026100 <tAllpass_setGain>
    	tCycle_setFreq(&r->f1_lfo, 0.0f);
 8029d92:	2300      	movs	r3, #0
 8029d94:	4628      	mov	r0, r5
 8029d96:	ee00 3a10 	vmov	s0, r3
 8029d9a:	f7fe fce5 	bl	8028768 <tCycle_setFreq>
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
 8029d9e:	2300      	movs	r3, #0
 8029da0:	4620      	mov	r0, r4
 8029da2:	ee00 3a10 	vmov	s0, r3
}
 8029da6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    	tCycle_setFreq(&r->f2_lfo, 0.0f);
 8029daa:	f7fe bcdd 	b.w	8028768 <tCycle_setFreq>
 8029dae:	bf00      	nop

08029db0 <tDattorroReverb_setHP>:
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
 8029db0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8029db4:	eef0 0a40 	vmov.f32	s1, s0
 8029db8:	eeb3 0a04 	vmov.f32	s0, #52	; 0x41a00000  20.0
 8029dbc:	f2c4 639c 	movt	r3, #18076	; 0x469c
{
 8029dc0:	b510      	push	{r4, lr}
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
 8029dc2:	ee01 3a10 	vmov	s2, r3
{
 8029dc6:	ed2d 8b02 	vpush	{d8}
    _tDattorroReverb* r = *rev;
 8029dca:	6804      	ldr	r4, [r0, #0]
    float newFreq = LEAF_clip(20.0f, freq, 20000.0f);
 8029dcc:	f7fd fdf4 	bl	80279b8 <LEAF_clip>
 8029dd0:	eeb0 8a40 	vmov.f32	s16, s0
    tHighpass_setFreq(&r->f1_hp, newFreq);
 8029dd4:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8029dd8:	f7fc fc1c 	bl	8026614 <tHighpass_setFreq>
    tHighpass_setFreq(&r->f2_hp, newFreq);
 8029ddc:	f104 0080 	add.w	r0, r4, #128	; 0x80
 8029de0:	eeb0 0a48 	vmov.f32	s0, s16
}
 8029de4:	ecbd 8b02 	vpop	{d8}
 8029de8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tHighpass_setFreq(&r->f2_hp, newFreq);
 8029dec:	f7fc bc12 	b.w	8026614 <tHighpass_setFreq>

08029df0 <tDattorroReverb_setSize>:
{
 8029df0:	b510      	push	{r4, lr}
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
 8029df2:	f24d 730a 	movw	r3, #55050	; 0xd70a
    _tDattorroReverb* r = *rev;
 8029df6:	6804      	ldr	r4, [r0, #0]
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
 8029df8:	f6c3 4323 	movt	r3, #15395	; 0x3c23
 8029dfc:	ed94 1a08 	vldr	s2, [r4, #32]
 8029e00:	ee61 0a00 	vmul.f32	s1, s2, s0
 8029e04:	ee00 3a10 	vmov	s0, r3
 8029e08:	f7fd fdd6 	bl	80279b8 <LEAF_clip>
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e0c:	f249 41a0 	movw	r1, #38048	; 0x94a0
 8029e10:	f241 226f 	movw	r2, #4719	; 0x126f
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8029e14:	f24b 03a4 	movw	r3, #45220	; 0xb0a4
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e18:	f2c2 0101 	movt	r1, #8193	; 0x2001
    r->size = LEAF_clip(0.01f, size*r->size_max, r->size_max);
 8029e1c:	ed84 0a07 	vstr	s0, [r4, #28]
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e20:	f6c3 2283 	movt	r2, #14979	; 0x3a83
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8029e24:	f2c4 330d 	movt	r3, #17165	; 0x430d
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e28:	edd1 7a00 	vldr	s15, [r1]
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8029e2c:	f104 0054 	add.w	r0, r4, #84	; 0x54
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e30:	ee06 2a90 	vmov	s13, r2
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8029e34:	ee07 3a10 	vmov	s14, r3
    r->t = r->size * leaf.sampleRate * 0.001f;
 8029e38:	ee67 7aa6 	vmul.f32	s15, s15, s13
 8029e3c:	ee27 0a80 	vmul.f32	s0, s15, s0
 8029e40:	ed84 0a09 	vstr	s0, [r4, #36]	; 0x24
    tTapeDelay_setDelay(&r->f1_delay_1, SAMP(141.69f));
 8029e44:	ee20 0a07 	vmul.f32	s0, s0, s14
 8029e48:	f7f9 f98e 	bl	8023168 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_2, SAMP(89.24f));
 8029e4c:	f647 23e1 	movw	r3, #31457	; 0x7ae1
 8029e50:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029e54:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8029e58:	f2c4 23b2 	movt	r3, #17074	; 0x42b2
 8029e5c:	ee07 3a90 	vmov	s15, r3
 8029e60:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029e64:	f7f9 f980 	bl	8023168 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f1_delay_3, SAMP(125.f));
 8029e68:	2300      	movs	r3, #0
 8029e6a:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029e6e:	f104 0060 	add.w	r0, r4, #96	; 0x60
 8029e72:	f2c4 23fa 	movt	r3, #17146	; 0x42fa
 8029e76:	ee07 3a90 	vmov	s15, r3
 8029e7a:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029e7e:	f7f9 f973 	bl	8023168 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_1, SAMP(149.62f));
 8029e82:	f649 63b8 	movw	r3, #40632	; 0x9eb8
 8029e86:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029e8a:	f104 0070 	add.w	r0, r4, #112	; 0x70
 8029e8e:	f2c4 3315 	movt	r3, #17173	; 0x4315
 8029e92:	ee07 3a90 	vmov	s15, r3
 8029e96:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029e9a:	f7f9 f965 	bl	8023168 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_2, SAMP(60.48f));
 8029e9e:	f64e 3385 	movw	r3, #60293	; 0xeb85
 8029ea2:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029ea6:	f104 0078 	add.w	r0, r4, #120	; 0x78
 8029eaa:	f2c4 2371 	movt	r3, #17009	; 0x4271
 8029eae:	ee07 3a90 	vmov	s15, r3
 8029eb2:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029eb6:	f7f9 f957 	bl	8023168 <tTapeDelay_setDelay>
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
 8029eba:	f648 735c 	movw	r3, #36700	; 0x8f5c
 8029ebe:	ed94 0a09 	vldr	s0, [r4, #36]	; 0x24
 8029ec2:	f104 007c 	add.w	r0, r4, #124	; 0x7c
 8029ec6:	f2c4 23d4 	movt	r3, #17108	; 0x42d4
 8029eca:	ee07 3a90 	vmov	s15, r3
}
 8029ece:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tTapeDelay_setDelay(&r->f2_delay_3, SAMP(106.28f));
 8029ed2:	ee20 0a27 	vmul.f32	s0, s0, s15
 8029ed6:	f7f9 b947 	b.w	8023168 <tTapeDelay_setDelay>
 8029eda:	bf00      	nop

08029edc <tDattorroReverb_setInputFilter>:
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029edc:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8029ee0:	2200      	movs	r2, #0
 8029ee2:	eef0 0a40 	vmov.f32	s1, s0
 8029ee6:	f2c4 639c 	movt	r3, #18076	; 0x469c
 8029eea:	ee00 2a10 	vmov	s0, r2
{
 8029eee:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8029ef0:	6804      	ldr	r4, [r0, #0]
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029ef2:	ee01 3a10 	vmov	s2, r3
 8029ef6:	f7fd fd5f 	bl	80279b8 <LEAF_clip>
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8029efa:	f104 003c 	add.w	r0, r4, #60	; 0x3c
    r->input_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029efe:	ed84 0a02 	vstr	s0, [r4, #8]
}
 8029f02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->in_filter, r->input_filter);
 8029f06:	f7fc b953 	b.w	80261b0 <tOnePole_setFreq>
 8029f0a:	bf00      	nop

08029f0c <tDattorroReverb_setFeedbackFilter>:
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029f0c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8029f10:	2200      	movs	r2, #0
 8029f12:	eef0 0a40 	vmov.f32	s1, s0
 8029f16:	f2c4 639c 	movt	r3, #18076	; 0x469c
 8029f1a:	ee00 2a10 	vmov	s0, r2
{
 8029f1e:	b510      	push	{r4, lr}
    _tDattorroReverb* r = *rev;
 8029f20:	6804      	ldr	r4, [r0, #0]
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029f22:	ee01 3a10 	vmov	s2, r3
 8029f26:	f7fd fd47 	bl	80279b8 <LEAF_clip>
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8029f2a:	f104 0058 	add.w	r0, r4, #88	; 0x58
    r->feedback_filter = LEAF_clip(0.0f, freq, 20000.0f);
 8029f2e:	ed84 0a03 	vstr	s0, [r4, #12]
    tOnePole_setFreq(&r->f1_filter, r->feedback_filter);
 8029f32:	f7fc f93d 	bl	80261b0 <tOnePole_setFreq>
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8029f36:	ed94 0a03 	vldr	s0, [r4, #12]
 8029f3a:	f104 0074 	add.w	r0, r4, #116	; 0x74
}
 8029f3e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    tOnePole_setFreq(&r->f2_filter, r->feedback_filter);
 8029f42:	f7fc b935 	b.w	80261b0 <tOnePole_setFreq>
 8029f46:	bf00      	nop

08029f48 <tDattorroReverb_setFeedbackGain>:
    _tDattorroReverb* r = *rev;
 8029f48:	6803      	ldr	r3, [r0, #0]
    r->feedback_gain = gain;
 8029f4a:	ed83 0a04 	vstr	s0, [r3, #16]
}
 8029f4e:	4770      	bx	lr

08029f50 <tBuffer_initToPool>:
{
    tBuffer_initToPool(sb, length, &leaf.mempool);
}

void  tBuffer_initToPool (tBuffer* const sb, uint32_t length, tMempool* const mp)
{
 8029f50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tMempool* m = *mp;
 8029f52:	6815      	ldr	r5, [r2, #0]
{
 8029f54:	460e      	mov	r6, r1
 8029f56:	4607      	mov	r7, r0
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
 8029f58:	201c      	movs	r0, #28
 8029f5a:	4629      	mov	r1, r5
 8029f5c:	f7fd ff46 	bl	8027dec <mpool_alloc>
 8029f60:	4604      	mov	r4, r0
    s->mempool = m;
    
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 8029f62:	4629      	mov	r1, r5
 8029f64:	00b0      	lsls	r0, r6, #2
    _tBuffer* s = *sb = (_tBuffer*) mpool_alloc(sizeof(_tBuffer), m);
 8029f66:	603c      	str	r4, [r7, #0]
    s->mempool = m;
 8029f68:	6025      	str	r5, [r4, #0]
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 8029f6a:	f7fd ff3f 	bl	8027dec <mpool_alloc>
    
    s->bufferLength = length;
    s->recordedLength = 0;
 8029f6e:	2300      	movs	r3, #0
    s->buff = (float*) mpool_alloc( sizeof(float) * length, m);
 8029f70:	6060      	str	r0, [r4, #4]
    s->active = 0;
 8029f72:	61a3      	str	r3, [r4, #24]
    s->idx = 0;
 8029f74:	60a3      	str	r3, [r4, #8]
    s->mode = RecordOneShot;
 8029f76:	7523      	strb	r3, [r4, #20]
    s->recordedLength = 0;
 8029f78:	e9c4 6303 	strd	r6, r3, [r4, #12]
}
 8029f7c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8029f7e:	bf00      	nop

08029f80 <tBuffer_free>:

void  tBuffer_free (tBuffer* const sb)
{
 8029f80:	b510      	push	{r4, lr}
    _tBuffer* s = *sb;
 8029f82:	6804      	ldr	r4, [r0, #0]
    
    mpool_free((char*)s->buff, s->mempool);
 8029f84:	e9d4 1000 	ldrd	r1, r0, [r4]
 8029f88:	f7fd ffda 	bl	8027f40 <mpool_free>
    mpool_free((char*)s, s->mempool);
 8029f8c:	6821      	ldr	r1, [r4, #0]
 8029f8e:	4620      	mov	r0, r4
}
 8029f90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)s, s->mempool);
 8029f94:	f7fd bfd4 	b.w	8027f40 <mpool_free>

08029f98 <tBuffer_tick>:

void tBuffer_tick (tBuffer* const sb, float sample)
{
    _tBuffer* s = *sb;
 8029f98:	6803      	ldr	r3, [r0, #0]
    
    if (s->active == 1)
 8029f9a:	699a      	ldr	r2, [r3, #24]
 8029f9c:	2a01      	cmp	r2, #1
 8029f9e:	d000      	beq.n	8029fa2 <tBuffer_tick+0xa>
                s->idx = 0;
            }
        }
        s->recordedLength = s->idx;
    }
}
 8029fa0:	4770      	bx	lr
        s->buff[s->idx] = sample;
 8029fa2:	e9d3 2101 	ldrd	r2, r1, [r3, #4]
 8029fa6:	eb02 0281 	add.w	r2, r2, r1, lsl #2
 8029faa:	ed82 0a00 	vstr	s0, [r2]
        if (s->idx >= s->bufferLength)
 8029fae:	e9d3 2102 	ldrd	r2, r1, [r3, #8]
        s->idx += 1;
 8029fb2:	3201      	adds	r2, #1
        if (s->idx >= s->bufferLength)
 8029fb4:	428a      	cmp	r2, r1
        s->idx += 1;
 8029fb6:	609a      	str	r2, [r3, #8]
        if (s->idx >= s->bufferLength)
 8029fb8:	d304      	bcc.n	8029fc4 <tBuffer_tick+0x2c>
            if (s->mode == RecordOneShot)
 8029fba:	7d19      	ldrb	r1, [r3, #20]
 8029fbc:	b921      	cbnz	r1, 8029fc8 <tBuffer_tick+0x30>
    s->idx = 0;
}

void  tBuffer_stop(tBuffer* const sb)
{
    _tBuffer* s = *sb;
 8029fbe:	6802      	ldr	r2, [r0, #0]
    s->active = 0;
 8029fc0:	6191      	str	r1, [r2, #24]
 8029fc2:	689a      	ldr	r2, [r3, #8]
        s->recordedLength = s->idx;
 8029fc4:	611a      	str	r2, [r3, #16]
}
 8029fc6:	4770      	bx	lr
            else if (s->mode == RecordLoop)
 8029fc8:	2901      	cmp	r1, #1
 8029fca:	d1fb      	bne.n	8029fc4 <tBuffer_tick+0x2c>
                s->idx = 0;
 8029fcc:	2100      	movs	r1, #0
 8029fce:	460a      	mov	r2, r1
 8029fd0:	6099      	str	r1, [r3, #8]
 8029fd2:	e7f7      	b.n	8029fc4 <tBuffer_tick+0x2c>

08029fd4 <tBuffer_get>:
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
 8029fd4:	2900      	cmp	r1, #0
 8029fd6:	db09      	blt.n	8029fec <tBuffer_get+0x18>
    _tBuffer* s = *sb;
 8029fd8:	6803      	ldr	r3, [r0, #0]
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
 8029fda:	68da      	ldr	r2, [r3, #12]
 8029fdc:	428a      	cmp	r2, r1
 8029fde:	d905      	bls.n	8029fec <tBuffer_get+0x18>
    return s->buff[idx];
 8029fe0:	685b      	ldr	r3, [r3, #4]
 8029fe2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8029fe6:	ed91 0a00 	vldr	s0, [r1]
 8029fea:	4770      	bx	lr
    if ((idx < 0) || (idx >= s->bufferLength)) return 0.f;
 8029fec:	2300      	movs	r3, #0
 8029fee:	ee00 3a10 	vmov	s0, r3
}
 8029ff2:	4770      	bx	lr

08029ff4 <tBuffer_record>:
    _tBuffer* s = *sb;
 8029ff4:	6803      	ldr	r3, [r0, #0]
    s->active = 1;
 8029ff6:	2101      	movs	r1, #1
    s->idx = 0;
 8029ff8:	2200      	movs	r2, #0
    s->active = 1;
 8029ffa:	6199      	str	r1, [r3, #24]
    s->idx = 0;
 8029ffc:	609a      	str	r2, [r3, #8]
}
 8029ffe:	4770      	bx	lr

0802a000 <tBuffer_stop>:
    _tBuffer* s = *sb;
 802a000:	6803      	ldr	r3, [r0, #0]
    s->active = 0;
 802a002:	2200      	movs	r2, #0
 802a004:	619a      	str	r2, [r3, #24]
}
 802a006:	4770      	bx	lr

0802a008 <tBuffer_getRecordPosition>:

int   tBuffer_getRecordPosition(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->idx;
 802a008:	6803      	ldr	r3, [r0, #0]
}
 802a00a:	6898      	ldr	r0, [r3, #8]
 802a00c:	4770      	bx	lr
 802a00e:	bf00      	nop

0802a010 <tBuffer_setRecordPosition>:

void   tBuffer_setRecordPosition(tBuffer* const sb, int pos)
{
    _tBuffer* s = *sb;
 802a010:	6803      	ldr	r3, [r0, #0]
    s->idx = pos;
 802a012:	6099      	str	r1, [r3, #8]
}
 802a014:	4770      	bx	lr
 802a016:	bf00      	nop

0802a018 <tBuffer_setRecordMode>:

void  tBuffer_setRecordMode (tBuffer* const sb, RecordMode mode)
{
    _tBuffer* s = *sb;
 802a018:	6803      	ldr	r3, [r0, #0]
    s->mode = mode;
 802a01a:	7519      	strb	r1, [r3, #20]
}
 802a01c:	4770      	bx	lr
 802a01e:	bf00      	nop

0802a020 <tBuffer_getRecordedLength>:
}

uint32_t tBuffer_getRecordedLength(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->recordedLength;
 802a020:	6803      	ldr	r3, [r0, #0]
}
 802a022:	6918      	ldr	r0, [r3, #16]
 802a024:	4770      	bx	lr
 802a026:	bf00      	nop

0802a028 <tBuffer_setRecordedLength>:

void tBuffer_setRecordedLength(tBuffer* const sb, int length)
{
    _tBuffer* s = *sb;
 802a028:	6803      	ldr	r3, [r0, #0]
    s->recordedLength = length;
 802a02a:	6119      	str	r1, [r3, #16]
}
 802a02c:	4770      	bx	lr
 802a02e:	bf00      	nop

0802a030 <tBuffer_isActive>:

int tBuffer_isActive(tBuffer* const sb)
{
    _tBuffer* s = *sb;
    return s->active;
 802a030:	6803      	ldr	r3, [r0, #0]
}
 802a032:	6998      	ldr	r0, [r3, #24]
 802a034:	4770      	bx	lr
 802a036:	bf00      	nop

0802a038 <tSampler_init>:
static void handleStartEndChange(tSampler* const sp);

static void attemptStartEndChange(tSampler* const sp);

void tSampler_init(tSampler* const sp, tBuffer* const b)
{
 802a038:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    tSampler_initToPool(sp, b, &leaf.mempool);
}

void tSampler_initToPool(tSampler* const sp, tBuffer* const b, tMempool* const mp)
{
    _tMempool* m = *mp;
 802a03c:	f249 46a0 	movw	r6, #38048	; 0x94a0
{
 802a040:	4681      	mov	r9, r0
 802a042:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a044:	2054      	movs	r0, #84	; 0x54
    _tMempool* m = *mp;
 802a046:	f2c2 0601 	movt	r6, #8193	; 0x2001
    
    _tBuffer* s = *b;
    
    p->samp = s;
    
    p->active = 0;
 802a04a:	2500      	movs	r5, #0
{
 802a04c:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 802a050:	f856 7f18 	ldr.w	r7, [r6, #24]!
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a054:	4639      	mov	r1, r7
 802a056:	f7fd fec9 	bl	8027dec <mpool_alloc>
    
    p->mode = PlayNormal;
    
    p->cfxlen = 500; // default 300 sample crossfade
    
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a05a:	4632      	mov	r2, r6
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a05c:	4604      	mov	r4, r0
 802a05e:	f8c9 0000 	str.w	r0, [r9]
    p->inc = 1.f;
 802a062:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    p->mempool = m;
 802a066:	6007      	str	r7, [r0, #0]
    p->iinc = 1.f;
 802a068:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    _tBuffer* s = *b;
 802a06c:	f8d8 6000 	ldr.w	r6, [r8]
    p->iinc = 1.f;
 802a070:	f240 1001 	movw	r0, #257	; 0x101
    p->inc = 1.f;
 802a074:	6121      	str	r1, [r4, #16]
    p->samp = s;
 802a076:	6066      	str	r6, [r4, #4]
    p->cfxlen = 500; // default 300 sample crossfade
 802a078:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a07c:	f104 0608 	add.w	r6, r4, #8
    p->iinc = 1.f;
 802a080:	61a3      	str	r3, [r4, #24]
    p->flip = 1;
 802a082:	2301      	movs	r3, #1
    p->iinc = 1.f;
 802a084:	83a0      	strh	r0, [r4, #28]
    p->cfxlen = 500; // default 300 sample crossfade
 802a086:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a088:	4630      	mov	r0, r6
 802a08a:	4619      	mov	r1, r3
    p->flip = 1;
 802a08c:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a08e:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->idx = 0.f;
 802a092:	60e5      	str	r5, [r4, #12]
    p->active = 0;
 802a094:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
 802a096:	6225      	str	r5, [r4, #32]
    p->end = 0;
 802a098:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
 802a09a:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
 802a09c:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a0a0:	f7fb fe8e 	bl	8025dc0 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
 802a0a4:	ee00 5a10 	vmov	s0, r5
 802a0a8:	4630      	mov	r0, r6
 802a0aa:	f7fb fed1 	bl	8025e50 <tRamp_setVal>
    
    p->targetstart = -1;
    p->targetend = -1;
    
    p->inCrossfade = 0;
    p->flipStart = -1;
 802a0ae:	2300      	movs	r3, #0
    p->targetstart = -1;
 802a0b0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
 802a0b4:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
 802a0b8:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    p->targetstart = -1;
 802a0bc:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
 802a0be:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipStart = -1;
 802a0c0:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->flipIdx = -1;
 802a0c2:	6523      	str	r3, [r4, #80]	; 0x50
}
 802a0c4:	ecbd 8b02 	vpop	{d8}
 802a0c8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0802a0cc <tSampler_initToPool>:
{
 802a0cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 802a0d0:	ed2d 8b02 	vpush	{d8}
    _tMempool* m = *mp;
 802a0d4:	6816      	ldr	r6, [r2, #0]
{
 802a0d6:	4681      	mov	r9, r0
 802a0d8:	4688      	mov	r8, r1
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a0da:	2054      	movs	r0, #84	; 0x54
 802a0dc:	4631      	mov	r1, r6
{
 802a0de:	4617      	mov	r7, r2
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a0e0:	f7fd fe84 	bl	8027dec <mpool_alloc>
    p->inc = 1.f;
 802a0e4:	f04f 517e 	mov.w	r1, #1065353216	; 0x3f800000
    _tSampler* p = *sp = (_tSampler*) mpool_alloc(sizeof(_tSampler), m);
 802a0e8:	4604      	mov	r4, r0
 802a0ea:	f8c9 0000 	str.w	r0, [r9]
    p->iinc = 1.f;
 802a0ee:	f04f 537e 	mov.w	r3, #1065353216	; 0x3f800000
    p->mempool = m;
 802a0f2:	6006      	str	r6, [r0, #0]
    _tBuffer* s = *b;
 802a0f4:	f8d8 6000 	ldr.w	r6, [r8]
    p->active = 0;
 802a0f8:	2500      	movs	r5, #0
    p->iinc = 1.f;
 802a0fa:	f240 1001 	movw	r0, #257	; 0x101
    p->inc = 1.f;
 802a0fe:	6121      	str	r1, [r4, #16]
    p->samp = s;
 802a100:	6066      	str	r6, [r4, #4]
    p->cfxlen = 500; // default 300 sample crossfade
 802a102:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a106:	f104 0608 	add.w	r6, r4, #8
    p->iinc = 1.f;
 802a10a:	61a3      	str	r3, [r4, #24]
    p->flip = 1;
 802a10c:	2301      	movs	r3, #1
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a10e:	463a      	mov	r2, r7
    p->iinc = 1.f;
 802a110:	83a0      	strh	r0, [r4, #28]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a112:	eeb1 0a0c 	vmov.f32	s0, #28	; 0x40e00000  7.0
    p->flip = 1;
 802a116:	77a3      	strb	r3, [r4, #30]
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a118:	4630      	mov	r0, r6
    p->cfxlen = 500; // default 300 sample crossfade
 802a11a:	6361      	str	r1, [r4, #52]	; 0x34
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a11c:	4619      	mov	r1, r3
    p->idx = 0.f;
 802a11e:	60e5      	str	r5, [r4, #12]
    p->active = 0;
 802a120:	6465      	str	r5, [r4, #68]	; 0x44
    p->start = 0;
 802a122:	6225      	str	r5, [r4, #32]
    p->end = 0;
 802a124:	62a5      	str	r5, [r4, #40]	; 0x28
    p->len = p->end - p->start;
 802a126:	6325      	str	r5, [r4, #48]	; 0x30
    p->mode = PlayNormal;
 802a128:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    tRamp_initToPool(&p->gain, 7.0f, 1, mp);
 802a12c:	f7fb fe48 	bl	8025dc0 <tRamp_initToPool>
    tRamp_setVal(&p->gain, 0.f);
 802a130:	ee00 5a10 	vmov	s0, r5
 802a134:	4630      	mov	r0, r6
 802a136:	f7fb fe8b 	bl	8025e50 <tRamp_setVal>
    p->flipStart = -1;
 802a13a:	2300      	movs	r3, #0
    p->targetstart = -1;
 802a13c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    p->inCrossfade = 0;
 802a140:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
    p->flipStart = -1;
 802a144:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    p->targetstart = -1;
 802a148:	6262      	str	r2, [r4, #36]	; 0x24
    p->targetend = -1;
 802a14a:	62e2      	str	r2, [r4, #44]	; 0x2c
    p->flipStart = -1;
 802a14c:	64e3      	str	r3, [r4, #76]	; 0x4c
    p->flipIdx = -1;
 802a14e:	6523      	str	r3, [r4, #80]	; 0x50
}
 802a150:	ecbd 8b02 	vpop	{d8}
 802a154:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0802a158 <tSampler_free>:

void tSampler_free (tSampler* const sp)
{
 802a158:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 802a15a:	6804      	ldr	r4, [r0, #0]
    tRamp_free(&p->gain);
 802a15c:	f104 0008 	add.w	r0, r4, #8
 802a160:	f7fb fe64 	bl	8025e2c <tRamp_free>
    
    mpool_free((char*)p, p->mempool);
 802a164:	6821      	ldr	r1, [r4, #0]
 802a166:	4620      	mov	r0, r4
}
 802a168:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mpool_free((char*)p, p->mempool);
 802a16c:	f7fd bee8 	b.w	8027f40 <mpool_free>

0802a170 <tSampler_setMode>:
    return p->last;
}

void tSampler_setMode      (tSampler* const sp, PlayMode mode)
{
    _tSampler* p = *sp;
 802a170:	6803      	ldr	r3, [r0, #0]
    p->mode = mode;
 802a172:	f883 103c 	strb.w	r1, [r3, #60]	; 0x3c
}
 802a176:	4770      	bx	lr

0802a178 <tSampler_setCrossfadeLength>:

void tSampler_setCrossfadeLength  (tSampler* const sp, uint32_t length)
{
 802a178:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 802a17a:	6804      	ldr	r4, [r0, #0]
    
    uint32_t cfxlen = LEAF_clip(0, length, p->len * 0.25f);
 802a17c:	2300      	movs	r3, #0
 802a17e:	ee07 1a90 	vmov	s15, r1
 802a182:	ed94 1a0c 	vldr	s2, [r4, #48]	; 0x30
 802a186:	ee00 3a10 	vmov	s0, r3
 802a18a:	eef8 0a67 	vcvt.f32.u32	s1, s15
 802a18e:	eebb 1acf 	vcvt.f32.u32	s2, s2, #2
 802a192:	f7fd fc11 	bl	80279b8 <LEAF_clip>
 802a196:	eebc 0ac0 	vcvt.u32.f32	s0, s0
 802a19a:	ed84 0a0d 	vstr	s0, [r4, #52]	; 0x34
    
    p->cfxlen = cfxlen;
}
 802a19e:	bd10      	pop	{r4, pc}

0802a1a0 <tSampler_play>:

void tSampler_play         (tSampler* const sp)
{
 802a1a0:	b510      	push	{r4, lr}
    _tSampler* p = *sp;
 802a1a2:	6804      	ldr	r4, [r0, #0]
    
    if (p->active != 0)
 802a1a4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802a1a6:	f104 0008 	add.w	r0, r4, #8
 802a1aa:	bb93      	cbnz	r3, 802a212 <tSampler_play+0x72>
        
        tRamp_setDest(&p->gain, 0.f);
    }
    else
    {
        p->active = 1;
 802a1ac:	2201      	movs	r2, #1
        p->retrigger = 0;
 802a1ae:	6423      	str	r3, [r4, #64]	; 0x40
        
        tRamp_setDest(&p->gain, 1.f);
 802a1b0:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
        p->active = 1;
 802a1b4:	6462      	str	r2, [r4, #68]	; 0x44
        tRamp_setDest(&p->gain, 1.f);
 802a1b6:	f7fb fe3d 	bl	8025e34 <tRamp_setDest>
        
        if (p->dir > 0)
 802a1ba:	f994 301c 	ldrsb.w	r3, [r4, #28]
 802a1be:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 802a1c0:	2b00      	cmp	r3, #0
 802a1c2:	6a22      	ldr	r2, [r4, #32]
        {
            if (p->flip > 0)    p->idx = p->start;
 802a1c4:	f994 301d 	ldrsb.w	r3, [r4, #29]
        if (p->dir > 0)
 802a1c8:	dd2f      	ble.n	802a22a <tSampler_play+0x8a>
            if (p->flip > 0)    p->idx = p->start;
 802a1ca:	2b00      	cmp	r3, #0
 802a1cc:	dd2f      	ble.n	802a22e <tSampler_play+0x8e>
            else                p->idx = p->end;
        }
        else
        {
            if (p->flip > 0)    p->idx = p->end;
            else                p->idx = p->start;
 802a1ce:	ee07 2a90 	vmov	s15, r2
 802a1d2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a1d6:	edc4 7a03 	vstr	s15, [r4, #12]

static void handleStartEndChange(tSampler* const sp)
{
    _tSampler* p = *sp;
    
    p->len = abs(p->end - p->start);
 802a1da:	1a8b      	subs	r3, r1, r2
    
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a1dc:	edd4 7a0d 	vldr	s15, [r4, #52]	; 0x34
    p->len = abs(p->end - p->start);
 802a1e0:	2b00      	cmp	r3, #0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a1e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 802a1e6:	bfb8      	it	lt
 802a1e8:	425b      	neglt	r3, r3
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a1ea:	ee07 3a10 	vmov	s14, r3
    p->len = abs(p->end - p->start);
 802a1ee:	6323      	str	r3, [r4, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a1f0:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 802a1f4:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a1f8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a1fc:	dd03      	ble.n	802a206 <tSampler_play+0x66>
 802a1fe:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 802a202:	ed84 7a0d 	vstr	s14, [r4, #52]	; 0x34
    
    if (p->start > p->end)
 802a206:	4291      	cmp	r1, r2
    {
        p->flip = -1;
 802a208:	bfb4      	ite	lt
 802a20a:	23ff      	movlt	r3, #255	; 0xff
    }
    else
    {
        p->flip = 1;
 802a20c:	2301      	movge	r3, #1
 802a20e:	7763      	strb	r3, [r4, #29]
}
 802a210:	bd10      	pop	{r4, pc}
        p->active = -1;
 802a212:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
        p->retrigger = 1;
 802a216:	2201      	movs	r2, #1
        tRamp_setDest(&p->gain, 0.f);
 802a218:	2300      	movs	r3, #0
        p->retrigger = 1;
 802a21a:	e9c4 2110 	strd	r2, r1, [r4, #64]	; 0x40
        tRamp_setDest(&p->gain, 0.f);
 802a21e:	ee00 3a10 	vmov	s0, r3
}
 802a222:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        tRamp_setDest(&p->gain, 0.f);
 802a226:	f7fb be05 	b.w	8025e34 <tRamp_setDest>
            if (p->flip > 0)    p->idx = p->end;
 802a22a:	2b00      	cmp	r3, #0
 802a22c:	ddcf      	ble.n	802a1ce <tSampler_play+0x2e>
 802a22e:	ee07 1a90 	vmov	s15, r1
 802a232:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a236:	edc4 7a03 	vstr	s15, [r4, #12]
 802a23a:	e7ce      	b.n	802a1da <tSampler_play+0x3a>

0802a23c <tSampler_stop>:
    _tSampler* p = *sp;
 802a23c:	6800      	ldr	r0, [r0, #0]
    p->active = -1;
 802a23e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    tRamp_setDest(&p->gain, 0.f);
 802a242:	2300      	movs	r3, #0
    p->active = -1;
 802a244:	6442      	str	r2, [r0, #68]	; 0x44
    tRamp_setDest(&p->gain, 0.f);
 802a246:	3008      	adds	r0, #8
 802a248:	ee00 3a10 	vmov	s0, r3
 802a24c:	f7fb bdf2 	b.w	8025e34 <tRamp_setDest>

0802a250 <tSampler_setStart>:
        tSampler_setEnd(sp, p->targetend);
    }
}

void tSampler_setStart     (tSampler* const sp, int32_t start)
{
 802a250:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 802a252:	6804      	ldr	r4, [r0, #0]
    if (start == p->end)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
 802a254:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802a256:	2b00      	cmp	r3, #0
 802a258:	d042      	beq.n	802a2e0 <tSampler_setStart+0x90>
    {
        if (start > p->end)
 802a25a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 802a25c:	428b      	cmp	r3, r1
 802a25e:	db1d      	blt.n	802a29c <tSampler_setStart+0x4c>
 802a260:	2501      	movs	r5, #1
 802a262:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
 802a264:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
 802a266:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a26a:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802a26e:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
 802a272:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a276:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 802a27a:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a27e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a282:	bf48      	it	mi
 802a284:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 802a288:	b932      	cbnz	r2, 802a298 <tSampler_setStart+0x48>
 802a28a:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 802a28e:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a292:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a296:	db06      	blt.n	802a2a6 <tSampler_setStart+0x56>
        }
    }
    
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetstart = -1;
 802a298:	6261      	str	r1, [r4, #36]	; 0x24
    
}
 802a29a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (start > p->end)
 802a29c:	2701      	movs	r7, #1
 802a29e:	2500      	movs	r5, #0
            tempflip = -1;
 802a2a0:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 802a2a4:	e7df      	b.n	802a266 <tSampler_setStart+0x16>
        int dir = p->bnf * p->dir * tempflip;
 802a2a6:	f994 201e 	ldrsb.w	r2, [r4, #30]
 802a2aa:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 802a2ae:	fb12 f20c 	smulbb	r2, r2, ip
 802a2b2:	fb06 f202 	mul.w	r2, r6, r2
        if ((tempflip > 0) && (dir > 0)) // start is start and we're playing forward
 802a2b6:	2a00      	cmp	r2, #0
 802a2b8:	dd3c      	ble.n	802a334 <tSampler_setStart+0xe4>
 802a2ba:	2d00      	cmp	r5, #0
 802a2bc:	d03a      	beq.n	802a334 <tSampler_setStart+0xe4>
            if (start > p->idx)// start given is after current index or we're in a crossfade
 802a2be:	ee07 1a90 	vmov	s15, r1
 802a2c2:	edd4 6a03 	vldr	s13, [r4, #12]
 802a2c6:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a2ca:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a2ce:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a2d2:	dc3e      	bgt.n	802a352 <tSampler_setStart+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
 802a2d4:	f994 301d 	ldrsb.w	r3, [r4, #29]
 802a2d8:	42b3      	cmp	r3, r6
 802a2da:	d001      	beq.n	802a2e0 <tSampler_setStart+0x90>
            p->flipIdx = 0;
 802a2dc:	2300      	movs	r3, #0
 802a2de:	6523      	str	r3, [r4, #80]	; 0x50
    p->start = LEAF_clipInt(0, start, p->samp->recordedLength-1);
 802a2e0:	6863      	ldr	r3, [r4, #4]
 802a2e2:	4605      	mov	r5, r0
 802a2e4:	2000      	movs	r0, #0
 802a2e6:	691a      	ldr	r2, [r3, #16]
 802a2e8:	3a01      	subs	r2, #1
 802a2ea:	f7fd fb79 	bl	80279e0 <LEAF_clipInt>
 802a2ee:	6220      	str	r0, [r4, #32]
    handleStartEndChange(sp);
 802a2f0:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 802a2f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802a2f4:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a2f6:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 802a2fa:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a2fc:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 802a300:	2900      	cmp	r1, #0
 802a302:	bfb8      	it	lt
 802a304:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a306:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 802a30a:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a30c:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 802a310:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a314:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a318:	dd03      	ble.n	802a322 <tSampler_setStart+0xd2>
 802a31a:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 802a31e:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 802a322:	4282      	cmp	r2, r0
 802a324:	bfac      	ite	ge
 802a326:	2201      	movge	r2, #1
 802a328:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetstart = -1;
 802a32c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 802a330:	775a      	strb	r2, [r3, #29]
 802a332:	e7b1      	b.n	802a298 <tSampler_setStart+0x48>
        else if ((tempflip < 0) && (dir < 0)) // start is end and we're playing in reverse
 802a334:	2a00      	cmp	r2, #0
 802a336:	dacd      	bge.n	802a2d4 <tSampler_setStart+0x84>
 802a338:	2f00      	cmp	r7, #0
 802a33a:	d0cb      	beq.n	802a2d4 <tSampler_setStart+0x84>
            if (start < p->idx)// start given is before current index or we're in a crossfade
 802a33c:	ee07 1a90 	vmov	s15, r1
 802a340:	edd4 6a03 	vldr	s13, [r4, #12]
 802a344:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a348:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a34c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a350:	d5c0      	bpl.n	802a2d4 <tSampler_setStart+0x84>
                float tempLen = abs(p->end - start) * 0.25f;
 802a352:	1a5b      	subs	r3, r3, r1
                if (cfxlen > tempLen)
 802a354:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetstart = start;
 802a358:	6261      	str	r1, [r4, #36]	; 0x24
                float tempLen = abs(p->end - start) * 0.25f;
 802a35a:	2b00      	cmp	r3, #0
 802a35c:	bfb8      	it	lt
 802a35e:	425b      	neglt	r3, r3
 802a360:	ee07 3a90 	vmov	s15, r3
 802a364:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 802a368:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802a36c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a370:	dd93      	ble.n	802a29a <tSampler_setStart+0x4a>
                    p->cfxlen = tempLen;
 802a372:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802a376:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 802a37a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802a37c <tSampler_setEnd>:

void tSampler_setEnd       (tSampler* const sp, int32_t end)
{
 802a37c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 802a37e:	6804      	ldr	r4, [r0, #0]
    if (end == p->start)
    {
        return;
    }
    */
    if (p->active) // only bother with these checks if we're actually playing
 802a380:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802a382:	2b00      	cmp	r3, #0
 802a384:	d042      	beq.n	802a40c <tSampler_setEnd+0x90>
    {
        if (p->start > end)
 802a386:	6a23      	ldr	r3, [r4, #32]
 802a388:	428b      	cmp	r3, r1
 802a38a:	dc1d      	bgt.n	802a3c8 <tSampler_setEnd+0x4c>
 802a38c:	2501      	movs	r5, #1
 802a38e:	2700      	movs	r7, #0
        {
            tempflip = -1;
        }
        else
        {
            tempflip = 1;
 802a390:	462e      	mov	r6, r5
        }
        
        int dir = p->bnf * p->dir * tempflip;
        
        uint32_t cfxlen = p->cfxlen;
 802a392:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a396:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802a39a:	eef8 6a47 	vcvt.f32.u32	s13, s14
        
        if (p->inCrossfade || p->flipStart >= 0)
 802a39e:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a3a2:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 802a3a6:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a3aa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a3ae:	bf48      	it	mi
 802a3b0:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 802a3b4:	b932      	cbnz	r2, 802a3c4 <tSampler_setEnd+0x48>
 802a3b6:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 802a3ba:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802a3be:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a3c2:	db06      	blt.n	802a3d2 <tSampler_setEnd+0x56>
        }
    }
    
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
    handleStartEndChange(sp);
    p->targetend = -1;
 802a3c4:	62e1      	str	r1, [r4, #44]	; 0x2c
}
 802a3c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
 802a3c8:	2701      	movs	r7, #1
 802a3ca:	2500      	movs	r5, #0
            tempflip = -1;
 802a3cc:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 802a3d0:	e7df      	b.n	802a392 <tSampler_setEnd+0x16>
        int dir = p->bnf * p->dir * tempflip;
 802a3d2:	f994 201e 	ldrsb.w	r2, [r4, #30]
 802a3d6:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 802a3da:	fb12 f20c 	smulbb	r2, r2, ip
 802a3de:	fb06 f202 	mul.w	r2, r6, r2
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
 802a3e2:	2a00      	cmp	r2, #0
 802a3e4:	da3c      	bge.n	802a460 <tSampler_setEnd+0xe4>
 802a3e6:	2d00      	cmp	r5, #0
 802a3e8:	d03a      	beq.n	802a460 <tSampler_setEnd+0xe4>
            if (end < p->idx) // end given is before current index or we're in a crossfade
 802a3ea:	ee07 1a90 	vmov	s15, r1
 802a3ee:	edd4 6a03 	vldr	s13, [r4, #12]
 802a3f2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a3f6:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a3fa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a3fe:	d43e      	bmi.n	802a47e <tSampler_setEnd+0x102>
        if (tempflip != p->flip && p->flipStart < 0)
 802a400:	f994 301d 	ldrsb.w	r3, [r4, #29]
 802a404:	42b3      	cmp	r3, r6
 802a406:	d001      	beq.n	802a40c <tSampler_setEnd+0x90>
            p->flipIdx = 0;
 802a408:	2300      	movs	r3, #0
 802a40a:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
 802a40c:	6863      	ldr	r3, [r4, #4]
 802a40e:	4605      	mov	r5, r0
 802a410:	2000      	movs	r0, #0
 802a412:	691a      	ldr	r2, [r3, #16]
 802a414:	3a01      	subs	r2, #1
 802a416:	f7fd fae3 	bl	80279e0 <LEAF_clipInt>
 802a41a:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
 802a41c:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 802a41e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802a420:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a422:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 802a426:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a428:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 802a42c:	2900      	cmp	r1, #0
 802a42e:	bfb8      	it	lt
 802a430:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a432:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 802a436:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802a438:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 802a43c:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a440:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a444:	dd03      	ble.n	802a44e <tSampler_setEnd+0xd2>
 802a446:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 802a44a:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 802a44e:	4282      	cmp	r2, r0
 802a450:	bfac      	ite	ge
 802a452:	2201      	movge	r2, #1
 802a454:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
 802a458:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 802a45c:	775a      	strb	r2, [r3, #29]
 802a45e:	e7b1      	b.n	802a3c4 <tSampler_setEnd+0x48>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
 802a460:	2a00      	cmp	r2, #0
 802a462:	ddcd      	ble.n	802a400 <tSampler_setEnd+0x84>
 802a464:	2f00      	cmp	r7, #0
 802a466:	d0cb      	beq.n	802a400 <tSampler_setEnd+0x84>
            if (end > p->idx) // end given is after current index or we're in a crossfade
 802a468:	ee07 1a90 	vmov	s15, r1
 802a46c:	edd4 6a03 	vldr	s13, [r4, #12]
 802a470:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a474:	eef4 7ae6 	vcmpe.f32	s15, s13
 802a478:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a47c:	ddc0      	ble.n	802a400 <tSampler_setEnd+0x84>
                float tempLen = abs(end - p->start) * 0.25f;
 802a47e:	1acb      	subs	r3, r1, r3
                if (cfxlen > tempLen)
 802a480:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
 802a484:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
 802a486:	2b00      	cmp	r3, #0
 802a488:	bfb8      	it	lt
 802a48a:	425b      	neglt	r3, r3
 802a48c:	ee07 3a90 	vmov	s15, r3
 802a490:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 802a494:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802a498:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a49c:	dd93      	ble.n	802a3c6 <tSampler_setEnd+0x4a>
                    p->cfxlen = tempLen;
 802a49e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802a4a2:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 802a4a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802a4a8 <tSampler_tick>:
{
 802a4a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802a4ac:	ed2d 8b06 	vpush	{d8-d10}
    _tSampler* p = *sp;
 802a4b0:	6804      	ldr	r4, [r0, #0]
{
 802a4b2:	b087      	sub	sp, #28
 802a4b4:	4605      	mov	r5, r0
    if (p->targetstart >= 0)
 802a4b6:	6a61      	ldr	r1, [r4, #36]	; 0x24
 802a4b8:	2900      	cmp	r1, #0
 802a4ba:	db01      	blt.n	802a4c0 <tSampler_tick+0x18>
        tSampler_setStart(sp, p->targetstart);
 802a4bc:	f7ff fec8 	bl	802a250 <tSampler_setStart>
    if (p->targetend >= 0)
 802a4c0:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 802a4c2:	2900      	cmp	r1, #0
 802a4c4:	db02      	blt.n	802a4cc <tSampler_tick+0x24>
        tSampler_setEnd(sp, p->targetend);
 802a4c6:	4628      	mov	r0, r5
 802a4c8:	f7ff ff58 	bl	802a37c <tSampler_setEnd>
    if (p->active == 0)         return 0.f;
 802a4cc:	6c63      	ldr	r3, [r4, #68]	; 0x44
 802a4ce:	2b00      	cmp	r3, #0
 802a4d0:	f000 813b 	beq.w	802a74a <tSampler_tick+0x2a2>
    if ((p->inc == 0.0f) || (p->len < 2))
 802a4d4:	edd4 7a04 	vldr	s15, [r4, #16]
 802a4d8:	eef5 7a40 	vcmp.f32	s15, #0.0
 802a4dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a4e0:	f000 812a 	beq.w	802a738 <tSampler_tick+0x290>
 802a4e4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 802a4e6:	2b01      	cmp	r3, #1
 802a4e8:	f240 8126 	bls.w	802a738 <tSampler_tick+0x290>
    if (p->flip < 0)
 802a4ec:	f994 701d 	ldrsb.w	r7, [r4, #29]
    float* buff = p->samp->buff;
 802a4f0:	6862      	ldr	r2, [r4, #4]
    int myStart = p->start;
 802a4f2:	6a21      	ldr	r1, [r4, #32]
    if (p->flip < 0)
 802a4f4:	2f00      	cmp	r7, #0
    float* buff = p->samp->buff;
 802a4f6:	f8d2 a004 	ldr.w	sl, [r2, #4]
    int myStart = p->start;
 802a4fa:	9101      	str	r1, [sp, #4]
    int myEnd = p->end;
 802a4fc:	f8d4 9028 	ldr.w	r9, [r4, #40]	; 0x28
    if (p->flip < 0)
 802a500:	db02      	blt.n	802a508 <tSampler_tick+0x60>
 802a502:	464b      	mov	r3, r9
    int myStart = p->start;
 802a504:	4689      	mov	r9, r1
    int myEnd = p->end;
 802a506:	9301      	str	r3, [sp, #4]
    int dir = p->bnf * p->dir * p->flip;
 802a508:	f994 101c 	ldrsb.w	r1, [r4, #28]
 802a50c:	f994 301e 	ldrsb.w	r3, [r4, #30]
    int idx = (int) p->idx;
 802a510:	edd4 7a03 	vldr	s15, [r4, #12]
    int dir = p->bnf * p->dir * p->flip;
 802a514:	fb13 f301 	smulbb	r3, r3, r1
    int length = p->samp->recordedLength;
 802a518:	f8d2 b010 	ldr.w	fp, [r2, #16]
    int idx = (int) p->idx;
 802a51c:	eebd 9ae7 	vcvt.s32.f32	s18, s15
    int dir = p->bnf * p->dir * p->flip;
 802a520:	fb07 f703 	mul.w	r7, r7, r3
    int i4 = idx+(2*dir);
 802a524:	007b      	lsls	r3, r7, #1
    float alpha = rev + (p->idx - idx) * dir;
 802a526:	ee06 7a90 	vmov	s13, r7
    if (dir < 0) rev = 1;
 802a52a:	0ffe      	lsrs	r6, r7, #31
    float alpha = rev + (p->idx - idx) * dir;
 802a52c:	eeb8 7ac9 	vcvt.f32.s32	s14, s18
    int i4 = idx+(2*dir);
 802a530:	9302      	str	r3, [sp, #8]
    idx += rev;
 802a532:	ee19 3a10 	vmov	r3, s18
 802a536:	f1c6 0101 	rsb	r1, r6, #1
    float alpha = rev + (p->idx - idx) * dir;
 802a53a:	eef8 9ae6 	vcvt.f32.s32	s19, s13
    idx += rev;
 802a53e:	eb03 0806 	add.w	r8, r3, r6
    float alpha = rev + (p->idx - idx) * dir;
 802a542:	ee06 6a90 	vmov	s13, r6
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 802a546:	fb06 f60b 	mul.w	r6, r6, fp
    float alpha = rev + (p->idx - idx) * dir;
 802a54a:	ee77 7ac7 	vsub.f32	s15, s15, s14
    int i1 = idx-(1*dir);
 802a54e:	eba8 0307 	sub.w	r3, r8, r7
 802a552:	9103      	str	r1, [sp, #12]
 802a554:	fb01 f10b 	mul.w	r1, r1, fp
    int i3 = idx+(1*dir);
 802a558:	eb07 0e08 	add.w	lr, r7, r8
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 802a55c:	429e      	cmp	r6, r3
    float alpha = rev + (p->idx - idx) * dir;
 802a55e:	eef8 8ae6 	vcvt.f32.s32	s17, s13
    int i4 = idx+(2*dir);
 802a562:	eb07 020e 	add.w	r2, r7, lr
    i1 = (i1 < length*rev) ? i1 + (length * (1-rev)) : i1 - (length * rev);
 802a566:	bfcc      	ite	gt
 802a568:	185b      	addgt	r3, r3, r1
 802a56a:	1b9b      	suble	r3, r3, r6
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
 802a56c:	4546      	cmp	r6, r8
    float alpha = rev + (p->idx - idx) * dir;
 802a56e:	eee7 8aa9 	vfma.f32	s17, s15, s19
    i2 = (i2 < length*rev) ? i2 + (length * (1-rev)) : i2 - (length * rev);
 802a572:	bfcc      	ite	gt
 802a574:	eb08 0c01 	addgt.w	ip, r8, r1
 802a578:	eba8 0c06 	suble.w	ip, r8, r6
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
 802a57c:	458e      	cmp	lr, r1
 802a57e:	f280 80f6 	bge.w	802a76e <tSampler_tick+0x2c6>
 802a582:	eb06 000e 	add.w	r0, r6, lr
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
 802a586:	428a      	cmp	r2, r1
 802a588:	f280 80ed 	bge.w	802a766 <tSampler_tick+0x2be>
 802a58c:	4432      	add	r2, r6
    sample = LEAF_interpolate_hermite_x (buff[i1],
 802a58e:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
 802a592:	eeb0 2a68 	vmov.f32	s4, s17
 802a596:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 802a59a:	9102      	str	r1, [sp, #8]
 802a59c:	eb0a 0c8c 	add.w	ip, sl, ip, lsl #2
 802a5a0:	ed90 1a00 	vldr	s2, [r0]
 802a5a4:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 802a5a8:	edd2 1a00 	vldr	s3, [r2]
 802a5ac:	eddc 0a00 	vldr	s1, [ip]
 802a5b0:	ed93 0a00 	vldr	s0, [r3]
 802a5b4:	f7fd fb20 	bl	8027bf8 <LEAF_interpolate_hermite_x>
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a5b8:	ed94 7a0c 	vldr	s14, [r4, #48]	; 0x30
    int32_t cfxlen = p->cfxlen;
 802a5bc:	6b60      	ldr	r0, [r4, #52]	; 0x34
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a5be:	eef5 7a00 	vmov.f32	s15, #80	; 0x3e800000  0.250
 802a5c2:	eef8 0a47 	vcvt.f32.u32	s1, s14
 802a5c6:	9902      	ldr	r1, [sp, #8]
 802a5c8:	ee07 0a10 	vmov	s14, r0
    sample = LEAF_interpolate_hermite_x (buff[i1],
 802a5cc:	eeb0 8a40 	vmov.f32	s16, s0
    if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802a5d0:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a5d4:	ee60 7aa7 	vmul.f32	s15, s1, s15
 802a5d8:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a5dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a5e0:	d503      	bpl.n	802a5ea <tSampler_tick+0x142>
 802a5e2:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802a5e6:	ee17 0a90 	vmov	r0, s15
    if (myStart >= cfxlen) fadeLeftStart = myStart - cfxlen;
 802a5ea:	4581      	cmp	r9, r0
 802a5ec:	f2c0 80b7 	blt.w	802a75e <tSampler_tick+0x2b6>
 802a5f0:	eba9 0c00 	sub.w	ip, r9, r0
 802a5f4:	f8cd 9008 	str.w	r9, [sp, #8]
    if (p->mode == PlayLoop)
 802a5f8:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 802a5fc:	2a01      	cmp	r2, #1
 802a5fe:	f000 80e0 	beq.w	802a7c2 <tSampler_tick+0x31a>
 802a602:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
    float inc = fmodf(p->inc, (float)p->len);
 802a606:	ed94 0a04 	vldr	s0, [r4, #16]
 802a60a:	f001 f9a1 	bl	802b950 <fmodf>
    p->idx += (dir * inc);
 802a60e:	edd4 7a03 	vldr	s15, [r4, #12]
    if (p->flipStart >= 0)
 802a612:	eef5 8ac0 	vcmpe.f32	s17, #0.0
    p->idx += (dir * inc);
 802a616:	eee9 7a80 	vfma.f32	s15, s19, s0
    if (p->flipStart >= 0)
 802a61a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
    p->idx += (dir * inc);
 802a61e:	edc4 7a03 	vstr	s15, [r4, #12]
    if (p->flipStart >= 0)
 802a622:	db28      	blt.n	802a676 <tSampler_tick+0x1ce>
        p->flipIdx += (-dir * inc);
 802a624:	427b      	negs	r3, r7
 802a626:	edd4 6a14 	vldr	s13, [r4, #80]	; 0x50
 802a62a:	ee07 3a10 	vmov	s14, r3
 802a62e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a632:	eee7 6a00 	vfma.f32	s13, s14, s0
 802a636:	eeb0 7a66 	vmov.f32	s14, s13
        if((int)p->flipIdx < 0)
 802a63a:	eefd 6ae6 	vcvt.s32.f32	s13, s13
        p->flipIdx += (-dir * inc);
 802a63e:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
        if((int)p->flipIdx < 0)
 802a642:	ee16 3a90 	vmov	r3, s13
 802a646:	2b00      	cmp	r3, #0
 802a648:	da07      	bge.n	802a65a <tSampler_tick+0x1b2>
            p->idx += (float)length;
 802a64a:	ee07 ba10 	vmov	s14, fp
 802a64e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a652:	ee77 7a87 	vadd.f32	s15, s15, s14
 802a656:	edc4 7a03 	vstr	s15, [r4, #12]
        if((int)p->idx >= length)
 802a65a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802a65e:	ee17 3a10 	vmov	r3, s14
 802a662:	455b      	cmp	r3, fp
 802a664:	db07      	blt.n	802a676 <tSampler_tick+0x1ce>
            p->idx -= (float)length;
 802a666:	ee07 ba10 	vmov	s14, fp
 802a66a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a66e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802a672:	edc4 7a03 	vstr	s15, [r4, #12]
    _tSampler* p = *sp;
 802a676:	682e      	ldr	r6, [r5, #0]
    if (p->targetstart >= 0)
 802a678:	6a71      	ldr	r1, [r6, #36]	; 0x24
 802a67a:	2900      	cmp	r1, #0
 802a67c:	db02      	blt.n	802a684 <tSampler_tick+0x1dc>
        tSampler_setStart(sp, p->targetstart);
 802a67e:	4628      	mov	r0, r5
 802a680:	f7ff fde6 	bl	802a250 <tSampler_setStart>
    if (p->targetend >= 0)
 802a684:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 802a686:	2900      	cmp	r1, #0
 802a688:	db02      	blt.n	802a690 <tSampler_tick+0x1e8>
        tSampler_setEnd(sp, p->targetend);
 802a68a:	4628      	mov	r0, r5
 802a68c:	f7ff fe76 	bl	802a37c <tSampler_setEnd>
    if (p->mode == PlayLoop)
 802a690:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 802a694:	f104 0508 	add.w	r5, r4, #8
 802a698:	2b01      	cmp	r3, #1
 802a69a:	d06c      	beq.n	802a776 <tSampler_tick+0x2ce>
    else if (p->mode == PlayBackAndForth)
 802a69c:	2b02      	cmp	r3, #2
 802a69e:	f000 8121 	beq.w	802a8e4 <tSampler_tick+0x43c>
    if (p->mode == PlayNormal)
 802a6a2:	bbbb      	cbnz	r3, 802a714 <tSampler_tick+0x26c>
    	if (p->idx < myStart)
 802a6a4:	ee07 9a90 	vmov	s15, r9
 802a6a8:	eeb8 7ae7 	vcvt.f32.s32	s14, s15
 802a6ac:	edd4 7a03 	vldr	s15, [r4, #12]
 802a6b0:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a6b4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a6b8:	f140 80f9 	bpl.w	802a8ae <tSampler_tick+0x406>
    		p->idx = myEnd;
 802a6bc:	ed84 7a03 	vstr	s14, [r4, #12]
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
 802a6c0:	2f00      	cmp	r7, #0
 802a6c2:	edd4 7a06 	vldr	s15, [r4, #24]
 802a6c6:	f2c0 80e9 	blt.w	802a89c <tSampler_tick+0x3f4>
 802a6ca:	9b01      	ldr	r3, [sp, #4]
 802a6cc:	eba3 0308 	sub.w	r3, r3, r8
 802a6d0:	ee07 3a10 	vmov	s14, r3
 802a6d4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a6d8:	ee27 7a27 	vmul.f32	s14, s14, s15
    	if (ticksToEnd < (0.007f * leaf.sampleRate))
 802a6dc:	f249 42a0 	movw	r2, #38048	; 0x94a0
 802a6e0:	f246 0342 	movw	r3, #24642	; 0x6042
 802a6e4:	f2c2 0201 	movt	r2, #8193	; 0x2001
 802a6e8:	f6c3 33e5 	movt	r3, #15333	; 0x3be5
 802a6ec:	edd2 6a00 	vldr	s13, [r2]
 802a6f0:	ee07 3a90 	vmov	s15, r3
 802a6f4:	ee66 7aa7 	vmul.f32	s15, s13, s15
 802a6f8:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a6fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a700:	dd08      	ble.n	802a714 <tSampler_tick+0x26c>
            tRamp_setDest(&p->gain, 0.f);
 802a702:	2300      	movs	r3, #0
 802a704:	4628      	mov	r0, r5
 802a706:	ee00 3a10 	vmov	s0, r3
 802a70a:	f7fb fb93 	bl	8025e34 <tRamp_setDest>
            p->active = -1;
 802a70e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 802a712:	6463      	str	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
 802a714:	4628      	mov	r0, r5
 802a716:	f7fb fba9 	bl	8025e6c <tRamp_tick>
    if (p->active < 0)
 802a71a:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sample = sample * tRamp_tick(&p->gain);
 802a71c:	ee20 8a08 	vmul.f32	s16, s0, s16
    if (p->active < 0)
 802a720:	2b00      	cmp	r3, #0
 802a722:	f2c0 80f6 	blt.w	802a912 <tSampler_tick+0x46a>
}
 802a726:	eeb0 0a48 	vmov.f32	s0, s16
    p->last = sample;
 802a72a:	ed84 8a05 	vstr	s16, [r4, #20]
}
 802a72e:	b007      	add	sp, #28
 802a730:	ecbd 8b06 	vpop	{d8-d10}
 802a734:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        return p->last;
 802a738:	ed94 8a05 	vldr	s16, [r4, #20]
}
 802a73c:	eeb0 0a48 	vmov.f32	s0, s16
 802a740:	b007      	add	sp, #28
 802a742:	ecbd 8b06 	vpop	{d8-d10}
 802a746:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (p->active == 0)         return 0.f;
 802a74a:	2300      	movs	r3, #0
 802a74c:	ee08 3a10 	vmov	s16, r3
}
 802a750:	eeb0 0a48 	vmov.f32	s0, s16
 802a754:	b007      	add	sp, #28
 802a756:	ecbd 8b06 	vpop	{d8-d10}
 802a75a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802a75e:	9002      	str	r0, [sp, #8]
    int32_t fadeLeftStart = 0;
 802a760:	f04f 0c00 	mov.w	ip, #0
 802a764:	e748      	b.n	802a5f8 <tSampler_tick+0x150>
    i4 = (i4 < length*(1-rev)) ? i4 + (length * rev) : i4 - (length * (1-rev));
 802a766:	eba6 0e0b 	sub.w	lr, r6, fp
 802a76a:	4472      	add	r2, lr
 802a76c:	e70f      	b.n	802a58e <tSampler_tick+0xe6>
    i3 = (i3 < length*(1-rev)) ? i3 + (length * rev) : i3 - (length * (1-rev));
 802a76e:	eba6 000b 	sub.w	r0, r6, fp
 802a772:	4470      	add	r0, lr
 802a774:	e707      	b.n	802a586 <tSampler_tick+0xde>
        if((int)p->idx < myStart)
 802a776:	edd4 7a03 	vldr	s15, [r4, #12]
 802a77a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802a77e:	ee17 3a10 	vmov	r3, s14
 802a782:	454b      	cmp	r3, r9
 802a784:	da0e      	bge.n	802a7a4 <tSampler_tick+0x2fc>
            p->idx += (float)(fadeRightEnd - fadeLeftEnd);
 802a786:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
 802a78a:	1a9b      	subs	r3, r3, r2
 802a78c:	ee07 3a10 	vmov	s14, r3
 802a790:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a794:	ee77 7a87 	vadd.f32	s15, s15, s14
 802a798:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802a79c:	edc4 7a03 	vstr	s15, [r4, #12]
 802a7a0:	ee17 3a10 	vmov	r3, s14
        if((int)p->idx > myEnd)
 802a7a4:	9a01      	ldr	r2, [sp, #4]
 802a7a6:	429a      	cmp	r2, r3
 802a7a8:	4611      	mov	r1, r2
 802a7aa:	dab3      	bge.n	802a714 <tSampler_tick+0x26c>
            p->idx -= (float)(fadeRightEnd - fadeLeftEnd);
 802a7ac:	9a02      	ldr	r2, [sp, #8]
 802a7ae:	1a8b      	subs	r3, r1, r2
 802a7b0:	ee07 3a10 	vmov	s14, r3
 802a7b4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a7b8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802a7bc:	edc4 7a03 	vstr	s15, [r4, #12]
 802a7c0:	e7a8      	b.n	802a714 <tSampler_tick+0x26c>
 802a7c2:	ee07 0a90 	vmov	s15, r0
        if ((fadeLeftStart <= idx) && (idx <= fadeLeftEnd))
 802a7c6:	45c4      	cmp	ip, r8
 802a7c8:	eeb8 aae7 	vcvt.f32.s32	s20, s15
 802a7cc:	dc7a      	bgt.n	802a8c4 <tSampler_tick+0x41c>
 802a7ce:	9b02      	ldr	r3, [sp, #8]
 802a7d0:	4598      	cmp	r8, r3
 802a7d2:	dc77      	bgt.n	802a8c4 <tSampler_tick+0x41c>
            offset = fadeLeftEnd - idx;
 802a7d4:	eba3 0308 	sub.w	r3, r3, r8
            p->inCrossfade = 1;
 802a7d8:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
            cdx = fadeRightEnd - offset;
 802a7dc:	9a01      	ldr	r2, [sp, #4]
            offset = fadeLeftEnd - idx;
 802a7de:	9304      	str	r3, [sp, #16]
            cdx = fadeRightEnd - offset;
 802a7e0:	1ad3      	subs	r3, r2, r3
            int c1 = cdx-(1*dir);
 802a7e2:	eba3 0e07 	sub.w	lr, r3, r7
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
 802a7e6:	4576      	cmp	r6, lr
 802a7e8:	f340 8134 	ble.w	802aa54 <tSampler_tick+0x5ac>
 802a7ec:	448e      	add	lr, r1
            c2 = (c2 < length * rev) ? c2 + (length * (1-rev)) : c2 - (length * rev);
 802a7ee:	429e      	cmp	r6, r3
 802a7f0:	bfcc      	ite	gt
 802a7f2:	eb03 0c01 	addgt.w	ip, r3, r1
 802a7f6:	eba3 0c06 	suble.w	ip, r3, r6
            int c3 = cdx+(1*dir);
 802a7fa:	443b      	add	r3, r7
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
 802a7fc:	428b      	cmp	r3, r1
 802a7fe:	f280 8125 	bge.w	802aa4c <tSampler_tick+0x5a4>
 802a802:	18f2      	adds	r2, r6, r3
            int c4 = cdx+(2*dir);
 802a804:	443b      	add	r3, r7
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
 802a806:	428b      	cmp	r3, r1
 802a808:	f280 8127 	bge.w	802aa5a <tSampler_tick+0x5b2>
 802a80c:	4433      	add	r3, r6
            cfxsample = LEAF_interpolate_hermite_x (buff[c1],
 802a80e:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
 802a812:	eeb0 2a68 	vmov.f32	s4, s17
 802a816:	eb0a 0282 	add.w	r2, sl, r2, lsl #2
 802a81a:	9105      	str	r1, [sp, #20]
 802a81c:	eb0a 008c 	add.w	r0, sl, ip, lsl #2
 802a820:	edd3 1a00 	vldr	s3, [r3]
 802a824:	eb0a 038e 	add.w	r3, sl, lr, lsl #2
 802a828:	ed92 1a00 	vldr	s2, [r2]
 802a82c:	edd0 0a00 	vldr	s1, [r0]
 802a830:	ed93 0a00 	vldr	s0, [r3]
 802a834:	f7fd f9e0 	bl	8027bf8 <LEAF_interpolate_hermite_x>
            crossfadeMix = (float) offset / (float) cfxlen;
 802a838:	eddd 7a04 	vldr	s15, [sp, #16]
 802a83c:	9905      	ldr	r1, [sp, #20]
 802a83e:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 802a842:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802a846:	ee86 7a8a 	vdiv.f32	s14, s13, s20
 802a84a:	ee20 0a07 	vmul.f32	s0, s0, s14
 802a84e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802a852:	eea8 0a27 	vfma.f32	s0, s16, s15
 802a856:	eeb0 8a40 	vmov.f32	s16, s0
        float flipLength = fabsf(p->flipIdx - p->flipStart);
 802a85a:	ed94 7a14 	vldr	s14, [r4, #80]	; 0x50
 802a85e:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
 802a862:	ee77 7a68 	vsub.f32	s15, s14, s17
 802a866:	eef0 7ae7 	vabs.f32	s15, s15
        if (flipLength > cfxlen)
 802a86a:	eef4 7aca 	vcmpe.f32	s15, s20
 802a86e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a872:	dd64      	ble.n	802a93e <tSampler_tick+0x496>
            p->flipStart = -1;
 802a874:	2300      	movs	r3, #0
    float inc = fmodf(p->inc, (float)p->len);
 802a876:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802a87a:	ed94 0a04 	vldr	s0, [r4, #16]
            p->flipStart = -1;
 802a87e:	f6cb 7380 	movt	r3, #49024	; 0xbf80
    float inc = fmodf(p->inc, (float)p->len);
 802a882:	eef8 0a67 	vcvt.f32.u32	s1, s15
            p->flipStart = -1;
 802a886:	64e3      	str	r3, [r4, #76]	; 0x4c
            p->flipIdx = -1;
 802a888:	6523      	str	r3, [r4, #80]	; 0x50
    float inc = fmodf(p->inc, (float)p->len);
 802a88a:	f001 f861 	bl	802b950 <fmodf>
    p->idx += (dir * inc);
 802a88e:	edd4 7a03 	vldr	s15, [r4, #12]
 802a892:	eee9 7a80 	vfma.f32	s15, s19, s0
 802a896:	edc4 7a03 	vstr	s15, [r4, #12]
 802a89a:	e6ec      	b.n	802a676 <tSampler_tick+0x1ce>
    	float ticksToEnd = rev ? ((idx - myStart) * p->iinc) : ((myEnd - idx) * p->iinc);
 802a89c:	eba8 0309 	sub.w	r3, r8, r9
 802a8a0:	ee07 3a10 	vmov	s14, r3
 802a8a4:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a8a8:	ee27 7a27 	vmul.f32	s14, s14, s15
 802a8ac:	e716      	b.n	802a6dc <tSampler_tick+0x234>
    	else if (p->idx > myEnd)
 802a8ae:	ed9d 7a01 	vldr	s14, [sp, #4]
 802a8b2:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802a8b6:	eef4 7ac7 	vcmpe.f32	s15, s14
 802a8ba:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a8be:	f77f aeff 	ble.w	802a6c0 <tSampler_tick+0x218>
 802a8c2:	e6fb      	b.n	802a6bc <tSampler_tick+0x214>
    int32_t fadeRightStart = fadeRightEnd - cfxlen;
 802a8c4:	9b01      	ldr	r3, [sp, #4]
 802a8c6:	1a18      	subs	r0, r3, r0
        else if ((fadeRightStart <= idx) && (idx <= fadeRightEnd))
 802a8c8:	4580      	cmp	r8, r0
 802a8ca:	f2c0 80bb 	blt.w	802aa44 <tSampler_tick+0x59c>
 802a8ce:	4543      	cmp	r3, r8
 802a8d0:	f2c0 80b8 	blt.w	802aa44 <tSampler_tick+0x59c>
            offset = idx - fadeRightStart;
 802a8d4:	eba8 0300 	sub.w	r3, r8, r0
            p->inCrossfade = 1;
 802a8d8:	2201      	movs	r2, #1
            offset = idx - fadeRightStart;
 802a8da:	9304      	str	r3, [sp, #16]
            cdx = fadeLeftStart + offset;
 802a8dc:	4463      	add	r3, ip
            p->inCrossfade = 1;
 802a8de:	f884 2048 	strb.w	r2, [r4, #72]	; 0x48
 802a8e2:	e77e      	b.n	802a7e2 <tSampler_tick+0x33a>
        if (p->idx < myStart)
 802a8e4:	ee07 9a90 	vmov	s15, r9
 802a8e8:	ed94 7a03 	vldr	s14, [r4, #12]
 802a8ec:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a8f0:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802a8f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a8f8:	d57a      	bpl.n	802a9f0 <tSampler_tick+0x548>
            p->idx = myStart + 1;
 802a8fa:	f109 0901 	add.w	r9, r9, #1
            p->bnf = -p->bnf;
 802a8fe:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myStart + 1;
 802a900:	ee07 9a90 	vmov	s15, r9
            p->bnf = -p->bnf;
 802a904:	425b      	negs	r3, r3
            p->idx = myStart + 1;
 802a906:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
 802a90a:	77a3      	strb	r3, [r4, #30]
            p->idx = myStart + 1;
 802a90c:	edc4 7a03 	vstr	s15, [r4, #12]
 802a910:	e700      	b.n	802a714 <tSampler_tick+0x26c>
        if (tRamp_sample(&p->gain) <= 0.00001f)
 802a912:	4628      	mov	r0, r5
 802a914:	f7fb fad2 	bl	8025ebc <tRamp_sample>
 802a918:	f24c 53ac 	movw	r3, #50604	; 0xc5ac
 802a91c:	f2c3 7327 	movt	r3, #14119	; 0x3727
 802a920:	ee07 3a90 	vmov	s15, r3
 802a924:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802a928:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a92c:	f63f aefb 	bhi.w	802a726 <tSampler_tick+0x27e>
            if (p->retrigger == 1)
 802a930:	6c23      	ldr	r3, [r4, #64]	; 0x40
 802a932:	2b01      	cmp	r3, #1
 802a934:	f000 8095 	beq.w	802aa62 <tSampler_tick+0x5ba>
                p->active = 0;
 802a938:	2300      	movs	r3, #0
 802a93a:	6463      	str	r3, [r4, #68]	; 0x44
 802a93c:	e6f3      	b.n	802a726 <tSampler_tick+0x27e>
        if (p->flipIdx >= 0)
 802a93e:	eeb5 7ac0 	vcmpe.f32	s14, #0.0
 802a942:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a946:	db4e      	blt.n	802a9e6 <tSampler_tick+0x53e>
            if (p->flipStart == -1)
 802a948:	eeff 6a00 	vmov.f32	s13, #240	; 0xbf800000 -1.0
 802a94c:	eef4 8a66 	vcmp.f32	s17, s13
 802a950:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802a954:	d06a      	beq.n	802aa2c <tSampler_tick+0x584>
 802a956:	ee7a 7a67 	vsub.f32	s15, s20, s15
 802a95a:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802a95e:	eec7 8a8a 	vdiv.f32	s17, s15, s20
 802a962:	ee76 7ae8 	vsub.f32	s15, s13, s17
 802a966:	ee27 8a88 	vmul.f32	s16, s15, s16
            int fdx = (int) p->flipIdx;
 802a96a:	eefd 7ac7 	vcvt.s32.f32	s15, s14
            idx += (1-rev);
 802a96e:	ee19 2a10 	vmov	r2, s18
            int f3 = fdx-(1*dir);
 802a972:	0078      	lsls	r0, r7, #1
            idx += (1-rev);
 802a974:	f102 0801 	add.w	r8, r2, #1
            int fdx = (int) p->flipIdx;
 802a978:	ee17 3a90 	vmov	r3, s15
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 802a97c:	eddd 7a03 	vldr	s15, [sp, #12]
 802a980:	eeb8 2ae7 	vcvt.f32.s32	s4, s15
 802a984:	ee07 3a90 	vmov	s15, r3
            int f1 = fdx+(1*dir);
 802a988:	18fa      	adds	r2, r7, r3
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 802a98a:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            int f3 = fdx-(1*dir);
 802a98e:	1a10      	subs	r0, r2, r0
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 802a990:	428a      	cmp	r2, r1
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 802a992:	ee37 7ac7 	vsub.f32	s14, s15, s14
            int f4 = fdx-(2*dir);
 802a996:	eba0 0c07 	sub.w	ip, r0, r7
            float falpha = (1-rev) - (p->flipIdx - fdx) * dir;
 802a99a:	eea9 2a87 	vfma.f32	s4, s19, s14
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 802a99e:	da41      	bge.n	802aa24 <tSampler_tick+0x57c>
 802a9a0:	4432      	add	r2, r6
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
 802a9a2:	428b      	cmp	r3, r1
 802a9a4:	da3a      	bge.n	802aa1c <tSampler_tick+0x574>
 802a9a6:	4433      	add	r3, r6
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
 802a9a8:	4286      	cmp	r6, r0
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 802a9aa:	eb0a 0383 	add.w	r3, sl, r3, lsl #2
            f3 = (f3 < length*rev) ? f3 + (length * (1-rev)) : f3 - (length * rev);
 802a9ae:	bfcc      	ite	gt
 802a9b0:	1840      	addgt	r0, r0, r1
 802a9b2:	1b80      	suble	r0, r0, r6
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
 802a9b4:	4566      	cmp	r6, ip
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 802a9b6:	edd3 0a00 	vldr	s1, [r3]
 802a9ba:	eb0a 0080 	add.w	r0, sl, r0, lsl #2
            f4 = (f4 < length*rev) ? f4 + (length * (1-rev)) : f4 - (length * rev);
 802a9be:	bfcc      	ite	gt
 802a9c0:	4461      	addgt	r1, ip
 802a9c2:	ebac 0106 	suble.w	r1, ip, r6
            flipsample = LEAF_interpolate_hermite_x (buff[f1],
 802a9c6:	ed90 1a00 	vldr	s2, [r0]
 802a9ca:	eb0a 0181 	add.w	r1, sl, r1, lsl #2
 802a9ce:	eb0a 0a82 	add.w	sl, sl, r2, lsl #2
 802a9d2:	edd1 1a00 	vldr	s3, [r1]
 802a9d6:	ed9a 0a00 	vldr	s0, [sl]
 802a9da:	f7fd f90d 	bl	8027bf8 <LEAF_interpolate_hermite_x>
 802a9de:	eea0 8a28 	vfma.f32	s16, s0, s17
 802a9e2:	edd4 8a13 	vldr	s17, [r4, #76]	; 0x4c
 802a9e6:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802a9ea:	eef8 0a67 	vcvt.f32.u32	s1, s15
 802a9ee:	e60a      	b.n	802a606 <tSampler_tick+0x15e>
        else if (p->idx > myEnd)
 802a9f0:	eddd 7a01 	vldr	s15, [sp, #4]
 802a9f4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802a9f8:	eeb4 7ae7 	vcmpe.f32	s14, s15
 802a9fc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aa00:	f77f ae88 	ble.w	802a714 <tSampler_tick+0x26c>
            p->idx = myEnd - 1;
 802aa04:	9b01      	ldr	r3, [sp, #4]
 802aa06:	3b01      	subs	r3, #1
 802aa08:	ee07 3a90 	vmov	s15, r3
            p->bnf = -p->bnf;
 802aa0c:	7fa3      	ldrb	r3, [r4, #30]
            p->idx = myEnd - 1;
 802aa0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
            p->bnf = -p->bnf;
 802aa12:	425b      	negs	r3, r3
 802aa14:	77a3      	strb	r3, [r4, #30]
            p->idx = myEnd - 1;
 802aa16:	edc4 7a03 	vstr	s15, [r4, #12]
 802aa1a:	e67b      	b.n	802a714 <tSampler_tick+0x26c>
            f2 = (f2 < length*(1-rev)) ? f2 + (length * rev) : f2 - (length * (1-rev));
 802aa1c:	eba6 0e0b 	sub.w	lr, r6, fp
 802aa20:	4473      	add	r3, lr
 802aa22:	e7c1      	b.n	802a9a8 <tSampler_tick+0x500>
            f1 = (f1 < length*(1-rev)) ? f1 + (length * rev) : f1 - (length * (1-rev));
 802aa24:	eba6 0e0b 	sub.w	lr, r6, fp
 802aa28:	4472      	add	r2, lr
 802aa2a:	e7ba      	b.n	802a9a2 <tSampler_tick+0x4fa>
                p->flipStart = p->idx;
 802aa2c:	ed94 7a03 	vldr	s14, [r4, #12]
                p->flipIdx = p->idx;
 802aa30:	2300      	movs	r3, #0
 802aa32:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 802aa36:	ee08 3a10 	vmov	s16, r3
                p->flipStart = p->idx;
 802aa3a:	ed84 7a13 	vstr	s14, [r4, #76]	; 0x4c
                p->flipIdx = p->idx;
 802aa3e:	ed84 7a14 	vstr	s14, [r4, #80]	; 0x50
 802aa42:	e792      	b.n	802a96a <tSampler_tick+0x4c2>
        else p->inCrossfade = 0;
 802aa44:	2300      	movs	r3, #0
 802aa46:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
 802aa4a:	e706      	b.n	802a85a <tSampler_tick+0x3b2>
            c3 = (c3 < length * (1-rev)) ? c3 + (length * rev) : c3 - (length * (1-rev));
 802aa4c:	eba6 020b 	sub.w	r2, r6, fp
 802aa50:	441a      	add	r2, r3
 802aa52:	e6d7      	b.n	802a804 <tSampler_tick+0x35c>
            c1 = (c1 < length * rev) ? c1 + (length * (1-rev)) : c1 - (length * rev);
 802aa54:	ebae 0e06 	sub.w	lr, lr, r6
 802aa58:	e6c9      	b.n	802a7ee <tSampler_tick+0x346>
            c4 = (c4 < length * (1-rev)) ? c4 + (length * rev) : c4 - (length * (1-rev));
 802aa5a:	eba6 000b 	sub.w	r0, r6, fp
 802aa5e:	4403      	add	r3, r0
 802aa60:	e6d5      	b.n	802a80e <tSampler_tick+0x366>
                p->retrigger = 0;
 802aa62:	2200      	movs	r2, #0
                p->active = 1;
 802aa64:	6463      	str	r3, [r4, #68]	; 0x44
                tRamp_setDest(&p->gain, 1.f);
 802aa66:	4628      	mov	r0, r5
 802aa68:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
                p->retrigger = 0;
 802aa6c:	6422      	str	r2, [r4, #64]	; 0x40
                tRamp_setDest(&p->gain, 1.f);
 802aa6e:	f7fb f9e1 	bl	8025e34 <tRamp_setDest>
                if (p->dir > 0)
 802aa72:	f994 301c 	ldrsb.w	r3, [r4, #28]
 802aa76:	2b00      	cmp	r3, #0
                    if (p->flip > 0)    p->idx = p->start;
 802aa78:	f994 301d 	ldrsb.w	r3, [r4, #29]
                if (p->dir > 0)
 802aa7c:	dd08      	ble.n	802aa90 <tSampler_tick+0x5e8>
                    if (p->flip > 0)    p->idx = p->start;
 802aa7e:	2b00      	cmp	r3, #0
 802aa80:	dd08      	ble.n	802aa94 <tSampler_tick+0x5ec>
                    else                p->idx = p->start;
 802aa82:	edd4 7a08 	vldr	s15, [r4, #32]
 802aa86:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802aa8a:	edc4 7a03 	vstr	s15, [r4, #12]
 802aa8e:	e64a      	b.n	802a726 <tSampler_tick+0x27e>
                    if (p->flip > 0)    p->idx = p->end;
 802aa90:	2b00      	cmp	r3, #0
 802aa92:	ddf6      	ble.n	802aa82 <tSampler_tick+0x5da>
 802aa94:	edd4 7a0a 	vldr	s15, [r4, #40]	; 0x28
 802aa98:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802aa9c:	edc4 7a03 	vstr	s15, [r4, #12]
 802aaa0:	e641      	b.n	802a726 <tSampler_tick+0x27e>
 802aaa2:	bf00      	nop

0802aaa4 <tSampler_setLength>:

void    tSampler_setLength    (tSampler* const sp, int32_t length)
{
 802aaa4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    _tSampler* p = *sp;
 802aaa6:	6804      	ldr	r4, [r0, #0]
    if (length == 0) length = 1;
 802aaa8:	2900      	cmp	r1, #0
 802aaaa:	bf14      	ite	ne
 802aaac:	460a      	movne	r2, r1
 802aaae:	2201      	moveq	r2, #1
    tSampler_setEnd(sp, p->start + length);
 802aab0:	6a23      	ldr	r3, [r4, #32]
    if (p->active) // only bother with these checks if we're actually playing
 802aab2:	6c65      	ldr	r5, [r4, #68]	; 0x44
    tSampler_setEnd(sp, p->start + length);
 802aab4:	1899      	adds	r1, r3, r2
    if (p->active) // only bother with these checks if we're actually playing
 802aab6:	2d00      	cmp	r5, #0
 802aab8:	d041      	beq.n	802ab3e <tSampler_setLength+0x9a>
        if (p->start > end)
 802aaba:	428b      	cmp	r3, r1
 802aabc:	dc1d      	bgt.n	802aafa <tSampler_setLength+0x56>
 802aabe:	2501      	movs	r5, #1
 802aac0:	2700      	movs	r7, #0
            tempflip = 1;
 802aac2:	462e      	mov	r6, r5
        uint32_t cfxlen = p->cfxlen;
 802aac4:	ed94 7a0d 	vldr	s14, [r4, #52]	; 0x34
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802aac8:	edd4 7a0c 	vldr	s15, [r4, #48]	; 0x30
 802aacc:	eef8 6a47 	vcvt.f32.u32	s13, s14
        if (p->inCrossfade || p->flipStart >= 0)
 802aad0:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
        if (p->len * 0.25f < cfxlen) cfxlen = p->len * 0.25f;
 802aad4:	eefb 7acf 	vcvt.f32.u32	s15, s15, #2
 802aad8:	eef4 7ae6 	vcmpe.f32	s15, s13
 802aadc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aae0:	bf48      	it	mi
 802aae2:	eebc 7ae7 	vcvtmi.u32.f32	s14, s15
        if (p->inCrossfade || p->flipStart >= 0)
 802aae6:	b933      	cbnz	r3, 802aaf6 <tSampler_setLength+0x52>
 802aae8:	edd4 7a13 	vldr	s15, [r4, #76]	; 0x4c
 802aaec:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802aaf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aaf4:	db06      	blt.n	802ab04 <tSampler_setLength+0x60>
    p->targetend = -1;
 802aaf6:	62e1      	str	r1, [r4, #44]	; 0x2c
}
 802aaf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (p->start > end)
 802aafa:	2701      	movs	r7, #1
 802aafc:	2500      	movs	r5, #0
            tempflip = -1;
 802aafe:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 802ab02:	e7df      	b.n	802aac4 <tSampler_setLength+0x20>
        int dir = p->bnf * p->dir * tempflip;
 802ab04:	f994 301e 	ldrsb.w	r3, [r4, #30]
 802ab08:	f994 c01c 	ldrsb.w	ip, [r4, #28]
 802ab0c:	fb13 f30c 	smulbb	r3, r3, ip
 802ab10:	fb06 f303 	mul.w	r3, r6, r3
        if (tempflip > 0 && dir < 0) // end is end and we're playing in reverse
 802ab14:	2b00      	cmp	r3, #0
 802ab16:	da3c      	bge.n	802ab92 <tSampler_setLength+0xee>
 802ab18:	2d00      	cmp	r5, #0
 802ab1a:	d03a      	beq.n	802ab92 <tSampler_setLength+0xee>
            if (end < p->idx) // end given is before current index or we're in a crossfade
 802ab1c:	ee07 1a90 	vmov	s15, r1
 802ab20:	edd4 6a03 	vldr	s13, [r4, #12]
 802ab24:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ab28:	eef4 7ae6 	vcmpe.f32	s15, s13
 802ab2c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ab30:	d43e      	bmi.n	802abb0 <tSampler_setLength+0x10c>
        if (tempflip != p->flip && p->flipStart < 0)
 802ab32:	f994 301d 	ldrsb.w	r3, [r4, #29]
 802ab36:	429e      	cmp	r6, r3
 802ab38:	d001      	beq.n	802ab3e <tSampler_setLength+0x9a>
            p->flipIdx = 0;
 802ab3a:	2300      	movs	r3, #0
 802ab3c:	6523      	str	r3, [r4, #80]	; 0x50
    p->end = LEAF_clipInt(0, end, p->samp->recordedLength-1);
 802ab3e:	6863      	ldr	r3, [r4, #4]
 802ab40:	4605      	mov	r5, r0
 802ab42:	2000      	movs	r0, #0
 802ab44:	691a      	ldr	r2, [r3, #16]
 802ab46:	3a01      	subs	r2, #1
 802ab48:	f7fc ff4a 	bl	80279e0 <LEAF_clipInt>
 802ab4c:	62a0      	str	r0, [r4, #40]	; 0x28
    handleStartEndChange(sp);
 802ab4e:	682b      	ldr	r3, [r5, #0]
    p->len = abs(p->end - p->start);
 802ab50:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 802ab52:	6a18      	ldr	r0, [r3, #32]
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802ab54:	edd3 7a0d 	vldr	s15, [r3, #52]	; 0x34
    p->len = abs(p->end - p->start);
 802ab58:	1a11      	subs	r1, r2, r0
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802ab5a:	eef8 7a67 	vcvt.f32.u32	s15, s15
    p->len = abs(p->end - p->start);
 802ab5e:	2900      	cmp	r1, #0
 802ab60:	bfb8      	it	lt
 802ab62:	4249      	neglt	r1, r1
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802ab64:	ee07 1a10 	vmov	s14, r1
    p->len = abs(p->end - p->start);
 802ab68:	6319      	str	r1, [r3, #48]	; 0x30
    if (p->cfxlen > (p->len * 0.25f)) p->cfxlen = p->len * 0.25f;
 802ab6a:	eebb 7acf 	vcvt.f32.u32	s14, s14, #2
 802ab6e:	eef4 7ac7 	vcmpe.f32	s15, s14
 802ab72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ab76:	dd03      	ble.n	802ab80 <tSampler_setLength+0xdc>
 802ab78:	eebc 7ac7 	vcvt.u32.f32	s14, s14
 802ab7c:	ed83 7a0d 	vstr	s14, [r3, #52]	; 0x34
        p->flip = -1;
 802ab80:	4282      	cmp	r2, r0
 802ab82:	bfac      	ite	ge
 802ab84:	2201      	movge	r2, #1
 802ab86:	f04f 32ff 	movlt.w	r2, #4294967295	; 0xffffffff
    p->targetend = -1;
 802ab8a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 802ab8e:	775a      	strb	r2, [r3, #29]
 802ab90:	e7b1      	b.n	802aaf6 <tSampler_setLength+0x52>
        else if (tempflip < 0 && dir > 0) // end is start and we're playing forward
 802ab92:	2b00      	cmp	r3, #0
 802ab94:	ddcd      	ble.n	802ab32 <tSampler_setLength+0x8e>
 802ab96:	2f00      	cmp	r7, #0
 802ab98:	d0cb      	beq.n	802ab32 <tSampler_setLength+0x8e>
            if (end > p->idx) // end given is after current index or we're in a crossfade
 802ab9a:	ee07 1a90 	vmov	s15, r1
 802ab9e:	edd4 6a03 	vldr	s13, [r4, #12]
 802aba2:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802aba6:	eef4 7ae6 	vcmpe.f32	s15, s13
 802abaa:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abae:	ddc0      	ble.n	802ab32 <tSampler_setLength+0x8e>
                float tempLen = abs(end - p->start) * 0.25f;
 802abb0:	2a00      	cmp	r2, #0
                if (cfxlen > tempLen)
 802abb2:	eeb8 7a47 	vcvt.f32.u32	s14, s14
                p->targetend = end;
 802abb6:	62e1      	str	r1, [r4, #44]	; 0x2c
                float tempLen = abs(end - p->start) * 0.25f;
 802abb8:	bfb8      	it	lt
 802abba:	4252      	neglt	r2, r2
 802abbc:	ee07 2a90 	vmov	s15, r2
 802abc0:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
                if (cfxlen > tempLen)
 802abc4:	eef4 7ac7 	vcmpe.f32	s15, s14
 802abc8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abcc:	d594      	bpl.n	802aaf8 <tSampler_setLength+0x54>
                    p->cfxlen = tempLen;
 802abce:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 802abd2:	edc4 7a0d 	vstr	s15, [r4, #52]	; 0x34
}
 802abd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0802abd8 <tSampler_setRate>:

void tSampler_setRate      (tSampler* const sp, float rate)
{
    _tSampler* p = *sp;
    
    if (rate < 0.f)
 802abd8:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
    _tSampler* p = *sp;
 802abdc:	6803      	ldr	r3, [r0, #0]
    if (rate < 0.f)
 802abde:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802abe2:	d40a      	bmi.n	802abfa <tSampler_setRate+0x22>
        rate = -rate;
        p->dir = -1;
    }
    else
    {
        p->dir = 1;
 802abe4:	2201      	movs	r2, #1
    }
    
    p->inc = rate;
    p->iinc = 1.f / p->inc;
 802abe6:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802abea:	771a      	strb	r2, [r3, #28]
    p->inc = rate;
 802abec:	ed83 0a04 	vstr	s0, [r3, #16]
    p->iinc = 1.f / p->inc;
 802abf0:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802abf4:	edc3 7a06 	vstr	s15, [r3, #24]
}
 802abf8:	4770      	bx	lr
        rate = -rate;
 802abfa:	eeb1 0a40 	vneg.f32	s0, s0
        p->dir = -1;
 802abfe:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 802ac02:	e7f0      	b.n	802abe6 <tSampler_setRate+0xe>

0802ac04 <LEAF_init>:

LEAF leaf;

void LEAF_init(float sr, int blocksize, char* memory, size_t memorysize, float(*random)(void))

{
 802ac04:	b538      	push	{r3, r4, r5, lr}
 802ac06:	460c      	mov	r4, r1
 802ac08:	4605      	mov	r5, r0
    leaf_pool_init(memory, memorysize);
 802ac0a:	4611      	mov	r1, r2
 802ac0c:	4620      	mov	r0, r4
{
 802ac0e:	461c      	mov	r4, r3
 802ac10:	ed2d 8b02 	vpush	{d8}
 802ac14:	eeb0 8a40 	vmov.f32	s16, s0
    leaf_pool_init(memory, memorysize);
 802ac18:	f7fd f8d0 	bl	8027dbc <leaf_pool_init>
    
    leaf.sampleRate = sr;

    leaf.blockSize = blocksize;
    
    leaf.invSampleRate = 1.0f/sr;
 802ac1c:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
    
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 802ac20:	f640 71db 	movw	r1, #4059	; 0xfdb
    leaf.sampleRate = sr;
 802ac24:	f249 42a0 	movw	r2, #38048	; 0x94a0

    leaf.random = random;
    
    leaf.clearOnAllocation = 0;
 802ac28:	2000      	movs	r0, #0
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 802ac2a:	f2c4 01c9 	movt	r1, #16585	; 0x40c9
    leaf.invSampleRate = 1.0f/sr;
 802ac2e:	ee87 7a88 	vdiv.f32	s14, s15, s16
    leaf.sampleRate = sr;
 802ac32:	f2c2 0201 	movt	r2, #8193	; 0x2001
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 802ac36:	ee07 1a90 	vmov	s15, r1
    leaf.blockSize = blocksize;
 802ac3a:	6095      	str	r5, [r2, #8]
    leaf.sampleRate = sr;
 802ac3c:	ed82 8a00 	vstr	s16, [r2]
    leaf.clearOnAllocation = 0;
 802ac40:	e9c2 4004 	strd	r4, r0, [r2, #16]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 802ac44:	ee67 7a27 	vmul.f32	s15, s14, s15
    leaf.invSampleRate = 1.0f/sr;
 802ac48:	ed82 7a01 	vstr	s14, [r2, #4]
    leaf.twoPiTimesInvSampleRate = leaf.invSampleRate * TWO_PI;
 802ac4c:	edc2 7a03 	vstr	s15, [r2, #12]
}
 802ac50:	ecbd 8b02 	vpop	{d8}
 802ac54:	bd38      	pop	{r3, r4, r5, pc}
 802ac56:	bf00      	nop

0802ac58 <LEAF_error>:
//implement a function called this in your user code to catch errors
__attribute__((weak))
uint8_t LEAF_error(uint8_t whichone)
{
    return whichone;
}
 802ac58:	4770      	bx	lr
 802ac5a:	bf00      	nop

0802ac5c <__errno>:
 802ac5c:	4b01      	ldr	r3, [pc, #4]	; (802ac64 <__errno+0x8>)
 802ac5e:	6818      	ldr	r0, [r3, #0]
 802ac60:	4770      	bx	lr
 802ac62:	bf00      	nop
 802ac64:	20000434 	.word	0x20000434

0802ac68 <__libc_init_array>:
 802ac68:	b570      	push	{r4, r5, r6, lr}
 802ac6a:	4e0d      	ldr	r6, [pc, #52]	; (802aca0 <__libc_init_array+0x38>)
 802ac6c:	4c0d      	ldr	r4, [pc, #52]	; (802aca4 <__libc_init_array+0x3c>)
 802ac6e:	1ba4      	subs	r4, r4, r6
 802ac70:	10a4      	asrs	r4, r4, #2
 802ac72:	2500      	movs	r5, #0
 802ac74:	42a5      	cmp	r5, r4
 802ac76:	d109      	bne.n	802ac8c <__libc_init_array+0x24>
 802ac78:	4e0b      	ldr	r6, [pc, #44]	; (802aca8 <__libc_init_array+0x40>)
 802ac7a:	4c0c      	ldr	r4, [pc, #48]	; (802acac <__libc_init_array+0x44>)
 802ac7c:	f002 fe18 	bl	802d8b0 <_init>
 802ac80:	1ba4      	subs	r4, r4, r6
 802ac82:	10a4      	asrs	r4, r4, #2
 802ac84:	2500      	movs	r5, #0
 802ac86:	42a5      	cmp	r5, r4
 802ac88:	d105      	bne.n	802ac96 <__libc_init_array+0x2e>
 802ac8a:	bd70      	pop	{r4, r5, r6, pc}
 802ac8c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802ac90:	4798      	blx	r3
 802ac92:	3501      	adds	r5, #1
 802ac94:	e7ee      	b.n	802ac74 <__libc_init_array+0xc>
 802ac96:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 802ac9a:	4798      	blx	r3
 802ac9c:	3501      	adds	r5, #1
 802ac9e:	e7f2      	b.n	802ac86 <__libc_init_array+0x1e>
 802aca0:	080502e8 	.word	0x080502e8
 802aca4:	080502e8 	.word	0x080502e8
 802aca8:	080502e8 	.word	0x080502e8
 802acac:	080502ec 	.word	0x080502ec

0802acb0 <__itoa>:
 802acb0:	1e93      	subs	r3, r2, #2
 802acb2:	2b22      	cmp	r3, #34	; 0x22
 802acb4:	b510      	push	{r4, lr}
 802acb6:	460c      	mov	r4, r1
 802acb8:	d904      	bls.n	802acc4 <__itoa+0x14>
 802acba:	2300      	movs	r3, #0
 802acbc:	700b      	strb	r3, [r1, #0]
 802acbe:	461c      	mov	r4, r3
 802acc0:	4620      	mov	r0, r4
 802acc2:	bd10      	pop	{r4, pc}
 802acc4:	2a0a      	cmp	r2, #10
 802acc6:	d109      	bne.n	802acdc <__itoa+0x2c>
 802acc8:	2800      	cmp	r0, #0
 802acca:	da07      	bge.n	802acdc <__itoa+0x2c>
 802accc:	232d      	movs	r3, #45	; 0x2d
 802acce:	700b      	strb	r3, [r1, #0]
 802acd0:	4240      	negs	r0, r0
 802acd2:	2101      	movs	r1, #1
 802acd4:	4421      	add	r1, r4
 802acd6:	f000 f821 	bl	802ad1c <__utoa>
 802acda:	e7f1      	b.n	802acc0 <__itoa+0x10>
 802acdc:	2100      	movs	r1, #0
 802acde:	e7f9      	b.n	802acd4 <__itoa+0x24>

0802ace0 <itoa>:
 802ace0:	f7ff bfe6 	b.w	802acb0 <__itoa>

0802ace4 <memcpy>:
 802ace4:	b510      	push	{r4, lr}
 802ace6:	1e43      	subs	r3, r0, #1
 802ace8:	440a      	add	r2, r1
 802acea:	4291      	cmp	r1, r2
 802acec:	d100      	bne.n	802acf0 <memcpy+0xc>
 802acee:	bd10      	pop	{r4, pc}
 802acf0:	f811 4b01 	ldrb.w	r4, [r1], #1
 802acf4:	f803 4f01 	strb.w	r4, [r3, #1]!
 802acf8:	e7f7      	b.n	802acea <memcpy+0x6>

0802acfa <memset>:
 802acfa:	4402      	add	r2, r0
 802acfc:	4603      	mov	r3, r0
 802acfe:	4293      	cmp	r3, r2
 802ad00:	d100      	bne.n	802ad04 <memset+0xa>
 802ad02:	4770      	bx	lr
 802ad04:	f803 1b01 	strb.w	r1, [r3], #1
 802ad08:	e7f9      	b.n	802acfe <memset+0x4>

0802ad0a <stpcpy>:
 802ad0a:	4603      	mov	r3, r0
 802ad0c:	f811 2b01 	ldrb.w	r2, [r1], #1
 802ad10:	4618      	mov	r0, r3
 802ad12:	f803 2b01 	strb.w	r2, [r3], #1
 802ad16:	2a00      	cmp	r2, #0
 802ad18:	d1f8      	bne.n	802ad0c <stpcpy+0x2>
 802ad1a:	4770      	bx	lr

0802ad1c <__utoa>:
 802ad1c:	b5f0      	push	{r4, r5, r6, r7, lr}
 802ad1e:	4b1d      	ldr	r3, [pc, #116]	; (802ad94 <__utoa+0x78>)
 802ad20:	b08b      	sub	sp, #44	; 0x2c
 802ad22:	4605      	mov	r5, r0
 802ad24:	460c      	mov	r4, r1
 802ad26:	466e      	mov	r6, sp
 802ad28:	f103 0c20 	add.w	ip, r3, #32
 802ad2c:	6818      	ldr	r0, [r3, #0]
 802ad2e:	6859      	ldr	r1, [r3, #4]
 802ad30:	4637      	mov	r7, r6
 802ad32:	c703      	stmia	r7!, {r0, r1}
 802ad34:	3308      	adds	r3, #8
 802ad36:	4563      	cmp	r3, ip
 802ad38:	463e      	mov	r6, r7
 802ad3a:	d1f7      	bne.n	802ad2c <__utoa+0x10>
 802ad3c:	6818      	ldr	r0, [r3, #0]
 802ad3e:	791b      	ldrb	r3, [r3, #4]
 802ad40:	713b      	strb	r3, [r7, #4]
 802ad42:	1e93      	subs	r3, r2, #2
 802ad44:	2b22      	cmp	r3, #34	; 0x22
 802ad46:	6038      	str	r0, [r7, #0]
 802ad48:	f04f 0300 	mov.w	r3, #0
 802ad4c:	d904      	bls.n	802ad58 <__utoa+0x3c>
 802ad4e:	7023      	strb	r3, [r4, #0]
 802ad50:	461c      	mov	r4, r3
 802ad52:	4620      	mov	r0, r4
 802ad54:	b00b      	add	sp, #44	; 0x2c
 802ad56:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802ad58:	1e66      	subs	r6, r4, #1
 802ad5a:	fbb5 f0f2 	udiv	r0, r5, r2
 802ad5e:	af0a      	add	r7, sp, #40	; 0x28
 802ad60:	fb02 5510 	mls	r5, r2, r0, r5
 802ad64:	443d      	add	r5, r7
 802ad66:	1c59      	adds	r1, r3, #1
 802ad68:	f815 5c28 	ldrb.w	r5, [r5, #-40]
 802ad6c:	f806 5f01 	strb.w	r5, [r6, #1]!
 802ad70:	4605      	mov	r5, r0
 802ad72:	b968      	cbnz	r0, 802ad90 <__utoa+0x74>
 802ad74:	5460      	strb	r0, [r4, r1]
 802ad76:	4423      	add	r3, r4
 802ad78:	4622      	mov	r2, r4
 802ad7a:	1b19      	subs	r1, r3, r4
 802ad7c:	1b10      	subs	r0, r2, r4
 802ad7e:	4281      	cmp	r1, r0
 802ad80:	dde7      	ble.n	802ad52 <__utoa+0x36>
 802ad82:	7811      	ldrb	r1, [r2, #0]
 802ad84:	7818      	ldrb	r0, [r3, #0]
 802ad86:	f802 0b01 	strb.w	r0, [r2], #1
 802ad8a:	f803 1901 	strb.w	r1, [r3], #-1
 802ad8e:	e7f4      	b.n	802ad7a <__utoa+0x5e>
 802ad90:	460b      	mov	r3, r1
 802ad92:	e7e2      	b.n	802ad5a <__utoa+0x3e>
 802ad94:	0804f97c 	.word	0x0804f97c

0802ad98 <atanf>:
 802ad98:	b538      	push	{r3, r4, r5, lr}
 802ad9a:	ee10 5a10 	vmov	r5, s0
 802ad9e:	f025 4400 	bic.w	r4, r5, #2147483648	; 0x80000000
 802ada2:	f1b4 4fa1 	cmp.w	r4, #1350565888	; 0x50800000
 802ada6:	eef0 7a40 	vmov.f32	s15, s0
 802adaa:	db0f      	blt.n	802adcc <atanf+0x34>
 802adac:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802adb0:	dd04      	ble.n	802adbc <atanf+0x24>
 802adb2:	ee70 7a00 	vadd.f32	s15, s0, s0
 802adb6:	eeb0 0a67 	vmov.f32	s0, s15
 802adba:	bd38      	pop	{r3, r4, r5, pc}
 802adbc:	ed9f 7a4c 	vldr	s14, [pc, #304]	; 802aef0 <atanf+0x158>
 802adc0:	eddf 7a4c 	vldr	s15, [pc, #304]	; 802aef4 <atanf+0x15c>
 802adc4:	2d00      	cmp	r5, #0
 802adc6:	fe77 7a87 	vselgt.f32	s15, s15, s14
 802adca:	e7f4      	b.n	802adb6 <atanf+0x1e>
 802adcc:	4b4a      	ldr	r3, [pc, #296]	; (802aef8 <atanf+0x160>)
 802adce:	429c      	cmp	r4, r3
 802add0:	dc10      	bgt.n	802adf4 <atanf+0x5c>
 802add2:	f1b4 5f44 	cmp.w	r4, #822083584	; 0x31000000
 802add6:	da0a      	bge.n	802adee <atanf+0x56>
 802add8:	ed9f 7a48 	vldr	s14, [pc, #288]	; 802aefc <atanf+0x164>
 802addc:	ee30 7a07 	vadd.f32	s14, s0, s14
 802ade0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802ade4:	eeb4 7ae6 	vcmpe.f32	s14, s13
 802ade8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802adec:	dce3      	bgt.n	802adb6 <atanf+0x1e>
 802adee:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 802adf2:	e013      	b.n	802ae1c <atanf+0x84>
 802adf4:	f000 f960 	bl	802b0b8 <fabsf>
 802adf8:	4b41      	ldr	r3, [pc, #260]	; (802af00 <atanf+0x168>)
 802adfa:	429c      	cmp	r4, r3
 802adfc:	dc4f      	bgt.n	802ae9e <atanf+0x106>
 802adfe:	f5a3 03d0 	sub.w	r3, r3, #6815744	; 0x680000
 802ae02:	429c      	cmp	r4, r3
 802ae04:	dc41      	bgt.n	802ae8a <atanf+0xf2>
 802ae06:	eef0 7a00 	vmov.f32	s15, #0	; 0x40000000  2.0
 802ae0a:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802ae0e:	eea0 7a27 	vfma.f32	s14, s0, s15
 802ae12:	2300      	movs	r3, #0
 802ae14:	ee30 0a27 	vadd.f32	s0, s0, s15
 802ae18:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802ae1c:	1c5a      	adds	r2, r3, #1
 802ae1e:	ee27 6aa7 	vmul.f32	s12, s15, s15
 802ae22:	ed9f 7a38 	vldr	s14, [pc, #224]	; 802af04 <atanf+0x16c>
 802ae26:	eddf 5a38 	vldr	s11, [pc, #224]	; 802af08 <atanf+0x170>
 802ae2a:	ed9f 5a38 	vldr	s10, [pc, #224]	; 802af0c <atanf+0x174>
 802ae2e:	ee66 6a06 	vmul.f32	s13, s12, s12
 802ae32:	eee6 5a87 	vfma.f32	s11, s13, s14
 802ae36:	ed9f 7a36 	vldr	s14, [pc, #216]	; 802af10 <atanf+0x178>
 802ae3a:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802ae3e:	eddf 5a35 	vldr	s11, [pc, #212]	; 802af14 <atanf+0x17c>
 802ae42:	eee7 5a26 	vfma.f32	s11, s14, s13
 802ae46:	ed9f 7a34 	vldr	s14, [pc, #208]	; 802af18 <atanf+0x180>
 802ae4a:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802ae4e:	eddf 5a33 	vldr	s11, [pc, #204]	; 802af1c <atanf+0x184>
 802ae52:	eee7 5a26 	vfma.f32	s11, s14, s13
 802ae56:	ed9f 7a32 	vldr	s14, [pc, #200]	; 802af20 <atanf+0x188>
 802ae5a:	eea6 5a87 	vfma.f32	s10, s13, s14
 802ae5e:	ed9f 7a31 	vldr	s14, [pc, #196]	; 802af24 <atanf+0x18c>
 802ae62:	eea5 7a26 	vfma.f32	s14, s10, s13
 802ae66:	ed9f 5a30 	vldr	s10, [pc, #192]	; 802af28 <atanf+0x190>
 802ae6a:	eea7 5a26 	vfma.f32	s10, s14, s13
 802ae6e:	ed9f 7a2f 	vldr	s14, [pc, #188]	; 802af2c <atanf+0x194>
 802ae72:	eea5 7a26 	vfma.f32	s14, s10, s13
 802ae76:	ee27 7a26 	vmul.f32	s14, s14, s13
 802ae7a:	eea5 7a86 	vfma.f32	s14, s11, s12
 802ae7e:	ee27 7a27 	vmul.f32	s14, s14, s15
 802ae82:	d121      	bne.n	802aec8 <atanf+0x130>
 802ae84:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802ae88:	e795      	b.n	802adb6 <atanf+0x1e>
 802ae8a:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802ae8e:	ee30 7a67 	vsub.f32	s14, s0, s15
 802ae92:	ee30 0a27 	vadd.f32	s0, s0, s15
 802ae96:	2301      	movs	r3, #1
 802ae98:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802ae9c:	e7be      	b.n	802ae1c <atanf+0x84>
 802ae9e:	4b24      	ldr	r3, [pc, #144]	; (802af30 <atanf+0x198>)
 802aea0:	429c      	cmp	r4, r3
 802aea2:	dc0b      	bgt.n	802aebc <atanf+0x124>
 802aea4:	eef7 7a08 	vmov.f32	s15, #120	; 0x3fc00000  1.5
 802aea8:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802aeac:	eea0 7a27 	vfma.f32	s14, s0, s15
 802aeb0:	2302      	movs	r3, #2
 802aeb2:	ee70 6a67 	vsub.f32	s13, s0, s15
 802aeb6:	eec6 7a87 	vdiv.f32	s15, s13, s14
 802aeba:	e7af      	b.n	802ae1c <atanf+0x84>
 802aebc:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802aec0:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802aec4:	2303      	movs	r3, #3
 802aec6:	e7a9      	b.n	802ae1c <atanf+0x84>
 802aec8:	4a1a      	ldr	r2, [pc, #104]	; (802af34 <atanf+0x19c>)
 802aeca:	491b      	ldr	r1, [pc, #108]	; (802af38 <atanf+0x1a0>)
 802aecc:	009b      	lsls	r3, r3, #2
 802aece:	441a      	add	r2, r3
 802aed0:	440b      	add	r3, r1
 802aed2:	edd3 6a00 	vldr	s13, [r3]
 802aed6:	ee37 7a66 	vsub.f32	s14, s14, s13
 802aeda:	2d00      	cmp	r5, #0
 802aedc:	ee77 7a67 	vsub.f32	s15, s14, s15
 802aee0:	ed92 7a00 	vldr	s14, [r2]
 802aee4:	ee77 7a67 	vsub.f32	s15, s14, s15
 802aee8:	bfb8      	it	lt
 802aeea:	eef1 7a67 	vneglt.f32	s15, s15
 802aeee:	e762      	b.n	802adb6 <atanf+0x1e>
 802aef0:	bfc90fdb 	.word	0xbfc90fdb
 802aef4:	3fc90fdb 	.word	0x3fc90fdb
 802aef8:	3edfffff 	.word	0x3edfffff
 802aefc:	7149f2ca 	.word	0x7149f2ca
 802af00:	3f97ffff 	.word	0x3f97ffff
 802af04:	3c8569d7 	.word	0x3c8569d7
 802af08:	3d4bda59 	.word	0x3d4bda59
 802af0c:	bd6ef16b 	.word	0xbd6ef16b
 802af10:	3d886b35 	.word	0x3d886b35
 802af14:	3dba2e6e 	.word	0x3dba2e6e
 802af18:	3e124925 	.word	0x3e124925
 802af1c:	3eaaaaab 	.word	0x3eaaaaab
 802af20:	bd15a221 	.word	0xbd15a221
 802af24:	bd9d8795 	.word	0xbd9d8795
 802af28:	bde38e38 	.word	0xbde38e38
 802af2c:	be4ccccd 	.word	0xbe4ccccd
 802af30:	401bffff 	.word	0x401bffff
 802af34:	0804f9a4 	.word	0x0804f9a4
 802af38:	0804f9b4 	.word	0x0804f9b4

0802af3c <cosf>:
 802af3c:	ee10 3a10 	vmov	r3, s0
 802af40:	b507      	push	{r0, r1, r2, lr}
 802af42:	4a1c      	ldr	r2, [pc, #112]	; (802afb4 <cosf+0x78>)
 802af44:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802af48:	4293      	cmp	r3, r2
 802af4a:	dc04      	bgt.n	802af56 <cosf+0x1a>
 802af4c:	eddf 0a1a 	vldr	s1, [pc, #104]	; 802afb8 <cosf+0x7c>
 802af50:	f001 fd40 	bl	802c9d4 <__kernel_cosf>
 802af54:	e004      	b.n	802af60 <cosf+0x24>
 802af56:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802af5a:	db04      	blt.n	802af66 <cosf+0x2a>
 802af5c:	ee30 0a40 	vsub.f32	s0, s0, s0
 802af60:	b003      	add	sp, #12
 802af62:	f85d fb04 	ldr.w	pc, [sp], #4
 802af66:	4668      	mov	r0, sp
 802af68:	f001 fb9a 	bl	802c6a0 <__ieee754_rem_pio2f>
 802af6c:	f000 0003 	and.w	r0, r0, #3
 802af70:	2801      	cmp	r0, #1
 802af72:	d007      	beq.n	802af84 <cosf+0x48>
 802af74:	2802      	cmp	r0, #2
 802af76:	d00e      	beq.n	802af96 <cosf+0x5a>
 802af78:	b9a0      	cbnz	r0, 802afa4 <cosf+0x68>
 802af7a:	eddd 0a01 	vldr	s1, [sp, #4]
 802af7e:	ed9d 0a00 	vldr	s0, [sp]
 802af82:	e7e5      	b.n	802af50 <cosf+0x14>
 802af84:	eddd 0a01 	vldr	s1, [sp, #4]
 802af88:	ed9d 0a00 	vldr	s0, [sp]
 802af8c:	f002 f802 	bl	802cf94 <__kernel_sinf>
 802af90:	eeb1 0a40 	vneg.f32	s0, s0
 802af94:	e7e4      	b.n	802af60 <cosf+0x24>
 802af96:	eddd 0a01 	vldr	s1, [sp, #4]
 802af9a:	ed9d 0a00 	vldr	s0, [sp]
 802af9e:	f001 fd19 	bl	802c9d4 <__kernel_cosf>
 802afa2:	e7f5      	b.n	802af90 <cosf+0x54>
 802afa4:	2001      	movs	r0, #1
 802afa6:	eddd 0a01 	vldr	s1, [sp, #4]
 802afaa:	ed9d 0a00 	vldr	s0, [sp]
 802afae:	f001 fff1 	bl	802cf94 <__kernel_sinf>
 802afb2:	e7d5      	b.n	802af60 <cosf+0x24>
 802afb4:	3f490fd8 	.word	0x3f490fd8
 802afb8:	00000000 	.word	0x00000000

0802afbc <expf>:
 802afbc:	ee10 2a10 	vmov	r2, s0
 802afc0:	f240 412a 	movw	r1, #1066	; 0x42a
 802afc4:	f3c2 530a 	ubfx	r3, r2, #20, #11
 802afc8:	428b      	cmp	r3, r1
 802afca:	e92d 0830 	stmdb	sp!, {r4, r5, fp}
 802afce:	eeb7 6ac0 	vcvt.f64.f32	d6, s0
 802afd2:	d92e      	bls.n	802b032 <expf+0x76>
 802afd4:	f512 0f00 	cmn.w	r2, #8388608	; 0x800000
 802afd8:	d061      	beq.n	802b09e <expf+0xe2>
 802afda:	f5b3 6fff 	cmp.w	r3, #2040	; 0x7f8
 802afde:	d304      	bcc.n	802afea <expf+0x2e>
 802afe0:	ee30 0a00 	vadd.f32	s0, s0, s0
 802afe4:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 802afe8:	4770      	bx	lr
 802afea:	eddf 7a2e 	vldr	s15, [pc, #184]	; 802b0a4 <expf+0xe8>
 802afee:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802aff2:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802aff6:	dd04      	ble.n	802b002 <expf+0x46>
 802aff8:	2000      	movs	r0, #0
 802affa:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 802affe:	f002 b91b 	b.w	802d238 <__math_oflowf>
 802b002:	eddf 7a29 	vldr	s15, [pc, #164]	; 802b0a8 <expf+0xec>
 802b006:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802b00a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b00e:	d504      	bpl.n	802b01a <expf+0x5e>
 802b010:	2000      	movs	r0, #0
 802b012:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 802b016:	f002 b903 	b.w	802d220 <__math_uflowf>
 802b01a:	eddf 7a24 	vldr	s15, [pc, #144]	; 802b0ac <expf+0xf0>
 802b01e:	eeb4 0ae7 	vcmpe.f32	s0, s15
 802b022:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b026:	d504      	bpl.n	802b032 <expf+0x76>
 802b028:	2000      	movs	r0, #0
 802b02a:	e8bd 0830 	ldmia.w	sp!, {r4, r5, fp}
 802b02e:	f002 b8fd 	b.w	802d22c <__math_may_uflowf>
 802b032:	491f      	ldr	r1, [pc, #124]	; (802b0b0 <expf+0xf4>)
 802b034:	eeb7 0b00 	vmov.f64	d0, #112	; 0x3f800000  1.0
 802b038:	ed91 5b4a 	vldr	d5, [r1, #296]	; 0x128
 802b03c:	ed91 7b48 	vldr	d7, [r1, #288]	; 0x120
 802b040:	eeb0 4b47 	vmov.f64	d4, d7
 802b044:	eea5 4b06 	vfma.f64	d4, d5, d6
 802b048:	ec55 4b14 	vmov	r4, r5, d4
 802b04c:	ee34 7b47 	vsub.f64	d7, d4, d7
 802b050:	f004 021f 	and.w	r2, r4, #31
 802b054:	ee95 7b06 	vfnms.f64	d7, d5, d6
 802b058:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 802b05c:	ed91 6b50 	vldr	d6, [r1, #320]	; 0x140
 802b060:	e9d2 4500 	ldrd	r4, r5, [r2]
 802b064:	eea6 0b07 	vfma.f64	d0, d6, d7
 802b068:	ee14 0a10 	vmov	r0, s8
 802b06c:	ed91 5b4c 	vldr	d5, [r1, #304]	; 0x130
 802b070:	ed91 6b4e 	vldr	d6, [r1, #312]	; 0x138
 802b074:	f04f 0b00 	mov.w	fp, #0
 802b078:	eb1b 0204 	adds.w	r2, fp, r4
 802b07c:	ea4f 3cc0 	mov.w	ip, r0, lsl #15
 802b080:	eb4c 0305 	adc.w	r3, ip, r5
 802b084:	eea5 6b07 	vfma.f64	d6, d5, d7
 802b088:	ee27 7b07 	vmul.f64	d7, d7, d7
 802b08c:	eea6 0b07 	vfma.f64	d0, d6, d7
 802b090:	ec43 2b17 	vmov	d7, r2, r3
 802b094:	ee20 0b07 	vmul.f64	d0, d0, d7
 802b098:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802b09c:	e7a2      	b.n	802afe4 <expf+0x28>
 802b09e:	ed9f 0a05 	vldr	s0, [pc, #20]	; 802b0b4 <expf+0xf8>
 802b0a2:	e79f      	b.n	802afe4 <expf+0x28>
 802b0a4:	42b17217 	.word	0x42b17217
 802b0a8:	c2cff1b4 	.word	0xc2cff1b4
 802b0ac:	c2ce8ecf 	.word	0xc2ce8ecf
 802b0b0:	0804f9c8 	.word	0x0804f9c8
 802b0b4:	00000000 	.word	0x00000000

0802b0b8 <fabsf>:
 802b0b8:	ee10 3a10 	vmov	r3, s0
 802b0bc:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802b0c0:	ee00 3a10 	vmov	s0, r3
 802b0c4:	4770      	bx	lr
	...

0802b0c8 <logf>:
 802b0c8:	ee10 3a10 	vmov	r3, s0
 802b0cc:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b0d0:	b410      	push	{r4}
 802b0d2:	d057      	beq.n	802b184 <logf+0xbc>
 802b0d4:	f5a3 0200 	sub.w	r2, r3, #8388608	; 0x800000
 802b0d8:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 802b0dc:	d31a      	bcc.n	802b114 <logf+0x4c>
 802b0de:	005a      	lsls	r2, r3, #1
 802b0e0:	d104      	bne.n	802b0ec <logf+0x24>
 802b0e2:	2001      	movs	r0, #1
 802b0e4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b0e8:	f002 b8ac 	b.w	802d244 <__math_divzerof>
 802b0ec:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b0f0:	d045      	beq.n	802b17e <logf+0xb6>
 802b0f2:	2b00      	cmp	r3, #0
 802b0f4:	db02      	blt.n	802b0fc <logf+0x34>
 802b0f6:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
 802b0fa:	d303      	bcc.n	802b104 <logf+0x3c>
 802b0fc:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b100:	f002 b8b0 	b.w	802d264 <__math_invalidf>
 802b104:	eddf 7a21 	vldr	s15, [pc, #132]	; 802b18c <logf+0xc4>
 802b108:	ee20 0a27 	vmul.f32	s0, s0, s15
 802b10c:	ee10 3a10 	vmov	r3, s0
 802b110:	f1a3 6338 	sub.w	r3, r3, #192937984	; 0xb800000
 802b114:	f103 4240 	add.w	r2, r3, #3221225472	; 0xc0000000
 802b118:	491d      	ldr	r1, [pc, #116]	; (802b190 <logf+0xc8>)
 802b11a:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
 802b11e:	f502 024d 	add.w	r2, r2, #13434880	; 0xcd0000
 802b122:	f3c2 40c3 	ubfx	r0, r2, #19, #4
 802b126:	0dd4      	lsrs	r4, r2, #23
 802b128:	eb01 1000 	add.w	r0, r1, r0, lsl #4
 802b12c:	05e4      	lsls	r4, r4, #23
 802b12e:	ed90 5b00 	vldr	d5, [r0]
 802b132:	1b1b      	subs	r3, r3, r4
 802b134:	ee07 3a90 	vmov	s15, r3
 802b138:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 802b13c:	eea5 6b07 	vfma.f64	d6, d5, d7
 802b140:	ed91 5b44 	vldr	d5, [r1, #272]	; 0x110
 802b144:	ee26 3b06 	vmul.f64	d3, d6, d6
 802b148:	ed91 7b46 	vldr	d7, [r1, #280]	; 0x118
 802b14c:	eea5 7b06 	vfma.f64	d7, d5, d6
 802b150:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
 802b154:	15d2      	asrs	r2, r2, #23
 802b156:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
 802b15a:	eea5 7b03 	vfma.f64	d7, d5, d3
 802b15e:	eeb0 5b47 	vmov.f64	d5, d7
 802b162:	ed90 0b02 	vldr	d0, [r0, #8]
 802b166:	ee07 2a90 	vmov	s15, r2
 802b16a:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 802b16e:	eea7 0b04 	vfma.f64	d0, d7, d4
 802b172:	ee30 0b06 	vadd.f64	d0, d0, d6
 802b176:	eea3 0b05 	vfma.f64	d0, d3, d5
 802b17a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802b17e:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b182:	4770      	bx	lr
 802b184:	ed9f 0a03 	vldr	s0, [pc, #12]	; 802b194 <logf+0xcc>
 802b188:	e7f9      	b.n	802b17e <logf+0xb6>
 802b18a:	bf00      	nop
 802b18c:	4b000000 	.word	0x4b000000
 802b190:	0804fc30 	.word	0x0804fc30
 802b194:	00000000 	.word	0x00000000

0802b198 <log2f>:
 802b198:	ee10 2a10 	vmov	r2, s0
 802b19c:	f1b2 5f7e 	cmp.w	r2, #1065353216	; 0x3f800000
 802b1a0:	b410      	push	{r4}
 802b1a2:	d057      	beq.n	802b254 <log2f+0xbc>
 802b1a4:	f5a2 0300 	sub.w	r3, r2, #8388608	; 0x800000
 802b1a8:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802b1ac:	d31a      	bcc.n	802b1e4 <log2f+0x4c>
 802b1ae:	0053      	lsls	r3, r2, #1
 802b1b0:	d104      	bne.n	802b1bc <log2f+0x24>
 802b1b2:	2001      	movs	r0, #1
 802b1b4:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b1b8:	f002 b844 	b.w	802d244 <__math_divzerof>
 802b1bc:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802b1c0:	d045      	beq.n	802b24e <log2f+0xb6>
 802b1c2:	2a00      	cmp	r2, #0
 802b1c4:	db02      	blt.n	802b1cc <log2f+0x34>
 802b1c6:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 802b1ca:	d303      	bcc.n	802b1d4 <log2f+0x3c>
 802b1cc:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b1d0:	f002 b848 	b.w	802d264 <__math_invalidf>
 802b1d4:	eddf 7a21 	vldr	s15, [pc, #132]	; 802b25c <log2f+0xc4>
 802b1d8:	ee20 0a27 	vmul.f32	s0, s0, s15
 802b1dc:	ee10 3a10 	vmov	r3, s0
 802b1e0:	f1a3 6238 	sub.w	r2, r3, #192937984	; 0xb800000
 802b1e4:	f102 4340 	add.w	r3, r2, #3221225472	; 0xc0000000
 802b1e8:	491d      	ldr	r1, [pc, #116]	; (802b260 <log2f+0xc8>)
 802b1ea:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
 802b1ee:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
 802b1f2:	f3c3 40c3 	ubfx	r0, r3, #19, #4
 802b1f6:	0ddc      	lsrs	r4, r3, #23
 802b1f8:	eb01 1000 	add.w	r0, r1, r0, lsl #4
 802b1fc:	05e4      	lsls	r4, r4, #23
 802b1fe:	ed90 5b00 	vldr	d5, [r0]
 802b202:	1b12      	subs	r2, r2, r4
 802b204:	ee07 2a90 	vmov	s15, r2
 802b208:	ed91 4b42 	vldr	d4, [r1, #264]	; 0x108
 802b20c:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 802b210:	eea5 6b07 	vfma.f64	d6, d5, d7
 802b214:	eeb0 7b46 	vmov.f64	d7, d6
 802b218:	ee26 5b06 	vmul.f64	d5, d6, d6
 802b21c:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
 802b220:	eea4 6b07 	vfma.f64	d6, d4, d7
 802b224:	ed91 4b40 	vldr	d4, [r1, #256]	; 0x100
 802b228:	15db      	asrs	r3, r3, #23
 802b22a:	eea4 6b05 	vfma.f64	d6, d4, d5
 802b22e:	ed90 4b02 	vldr	d4, [r0, #8]
 802b232:	ee00 3a10 	vmov	s0, r3
 802b236:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
 802b23a:	ee30 0b04 	vadd.f64	d0, d0, d4
 802b23e:	ed91 4b46 	vldr	d4, [r1, #280]	; 0x118
 802b242:	eea4 0b07 	vfma.f64	d0, d4, d7
 802b246:	eea5 0b06 	vfma.f64	d0, d5, d6
 802b24a:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802b24e:	f85d 4b04 	ldr.w	r4, [sp], #4
 802b252:	4770      	bx	lr
 802b254:	ed9f 0a03 	vldr	s0, [pc, #12]	; 802b264 <log2f+0xcc>
 802b258:	e7f9      	b.n	802b24e <log2f+0xb6>
 802b25a:	bf00      	nop
 802b25c:	4b000000 	.word	0x4b000000
 802b260:	0804fb10 	.word	0x0804fb10
 802b264:	00000000 	.word	0x00000000

0802b268 <checkint>:
 802b268:	f3c0 53c7 	ubfx	r3, r0, #23, #8
 802b26c:	2b7e      	cmp	r3, #126	; 0x7e
 802b26e:	dd10      	ble.n	802b292 <checkint+0x2a>
 802b270:	2b96      	cmp	r3, #150	; 0x96
 802b272:	dc0c      	bgt.n	802b28e <checkint+0x26>
 802b274:	2201      	movs	r2, #1
 802b276:	f1c3 0396 	rsb	r3, r3, #150	; 0x96
 802b27a:	fa02 f303 	lsl.w	r3, r2, r3
 802b27e:	1e5a      	subs	r2, r3, #1
 802b280:	4202      	tst	r2, r0
 802b282:	d106      	bne.n	802b292 <checkint+0x2a>
 802b284:	4203      	tst	r3, r0
 802b286:	bf0c      	ite	eq
 802b288:	2002      	moveq	r0, #2
 802b28a:	2001      	movne	r0, #1
 802b28c:	4770      	bx	lr
 802b28e:	2002      	movs	r0, #2
 802b290:	4770      	bx	lr
 802b292:	2000      	movs	r0, #0
 802b294:	4770      	bx	lr
	...

0802b298 <powf>:
 802b298:	ee10 1a10 	vmov	r1, s0
 802b29c:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 802b2a0:	ee10 4a90 	vmov	r4, s1
 802b2a4:	f5a1 0300 	sub.w	r3, r1, #8388608	; 0x800000
 802b2a8:	0062      	lsls	r2, r4, #1
 802b2aa:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802b2ae:	eef0 4a60 	vmov.f32	s9, s1
 802b2b2:	f102 30ff 	add.w	r0, r2, #4294967295	; 0xffffffff
 802b2b6:	4b92      	ldr	r3, [pc, #584]	; (802b500 <powf+0x268>)
 802b2b8:	d255      	bcs.n	802b366 <powf+0xce>
 802b2ba:	4298      	cmp	r0, r3
 802b2bc:	d855      	bhi.n	802b36a <powf+0xd2>
 802b2be:	2000      	movs	r0, #0
 802b2c0:	f101 4340 	add.w	r3, r1, #3221225472	; 0xc0000000
 802b2c4:	4a8f      	ldr	r2, [pc, #572]	; (802b504 <powf+0x26c>)
 802b2c6:	eebf 2b00 	vmov.f64	d2, #240	; 0xbf800000 -1.0
 802b2ca:	f503 034d 	add.w	r3, r3, #13434880	; 0xcd0000
 802b2ce:	f3c3 44c3 	ubfx	r4, r3, #19, #4
 802b2d2:	0ddb      	lsrs	r3, r3, #23
 802b2d4:	eb02 1404 	add.w	r4, r2, r4, lsl #4
 802b2d8:	05db      	lsls	r3, r3, #23
 802b2da:	ed94 6b00 	vldr	d6, [r4]
 802b2de:	1ac9      	subs	r1, r1, r3
 802b2e0:	ee07 1a90 	vmov	s15, r1
 802b2e4:	ed92 5b40 	vldr	d5, [r2, #256]	; 0x100
 802b2e8:	eeb7 7ae7 	vcvt.f64.f32	d7, s15
 802b2ec:	eea6 2b07 	vfma.f64	d2, d6, d7
 802b2f0:	ed92 7b42 	vldr	d7, [r2, #264]	; 0x108
 802b2f4:	ee22 6b02 	vmul.f64	d6, d2, d2
 802b2f8:	eea2 7b05 	vfma.f64	d7, d2, d5
 802b2fc:	15db      	asrs	r3, r3, #23
 802b2fe:	ed94 5b02 	vldr	d5, [r4, #8]
 802b302:	ee00 3a10 	vmov	s0, r3
 802b306:	eeb8 0bc0 	vcvt.f64.s32	d0, s0
 802b30a:	ee30 0b05 	vadd.f64	d0, d0, d5
 802b30e:	ed92 5b48 	vldr	d5, [r2, #288]	; 0x120
 802b312:	ed92 3b44 	vldr	d3, [r2, #272]	; 0x110
 802b316:	eea2 0b05 	vfma.f64	d0, d2, d5
 802b31a:	ed92 5b46 	vldr	d5, [r2, #280]	; 0x118
 802b31e:	eea2 5b03 	vfma.f64	d5, d2, d3
 802b322:	eea6 0b05 	vfma.f64	d0, d6, d5
 802b326:	ee26 6b06 	vmul.f64	d6, d6, d6
 802b32a:	eea7 0b06 	vfma.f64	d0, d7, d6
 802b32e:	eeb7 7ae4 	vcvt.f64.f32	d7, s9
 802b332:	ee20 0b07 	vmul.f64	d0, d0, d7
 802b336:	ee10 3a90 	vmov	r3, s1
 802b33a:	2500      	movs	r5, #0
 802b33c:	0bda      	lsrs	r2, r3, #15
 802b33e:	2300      	movs	r3, #0
 802b340:	b292      	uxth	r2, r2
 802b342:	f248 04be 	movw	r4, #32958	; 0x80be
 802b346:	429d      	cmp	r5, r3
 802b348:	bf08      	it	eq
 802b34a:	4294      	cmpeq	r4, r2
 802b34c:	f080 8094 	bcs.w	802b478 <powf+0x1e0>
 802b350:	ed9f 7b65 	vldr	d7, [pc, #404]	; 802b4e8 <powf+0x250>
 802b354:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802b358:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b35c:	dd76      	ble.n	802b44c <powf+0x1b4>
 802b35e:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802b362:	f001 bf69 	b.w	802d238 <__math_oflowf>
 802b366:	4298      	cmp	r0, r3
 802b368:	d92d      	bls.n	802b3c6 <powf+0x12e>
 802b36a:	b952      	cbnz	r2, 802b382 <powf+0xea>
 802b36c:	f481 0380 	eor.w	r3, r1, #4194304	; 0x400000
 802b370:	005b      	lsls	r3, r3, #1
 802b372:	f513 0f00 	cmn.w	r3, #8388608	; 0x800000
 802b376:	f240 80ae 	bls.w	802b4d6 <powf+0x23e>
 802b37a:	ee30 0a24 	vadd.f32	s0, s0, s9
 802b37e:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
 802b382:	f1b1 5f7e 	cmp.w	r1, #1065353216	; 0x3f800000
 802b386:	d105      	bne.n	802b394 <powf+0xfc>
 802b388:	f484 0480 	eor.w	r4, r4, #4194304	; 0x400000
 802b38c:	0064      	lsls	r4, r4, #1
 802b38e:	f514 0f00 	cmn.w	r4, #8388608	; 0x800000
 802b392:	e7f0      	b.n	802b376 <powf+0xde>
 802b394:	004b      	lsls	r3, r1, #1
 802b396:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 802b39a:	d8ee      	bhi.n	802b37a <powf+0xe2>
 802b39c:	f1b2 4f7f 	cmp.w	r2, #4278190080	; 0xff000000
 802b3a0:	d1eb      	bne.n	802b37a <powf+0xe2>
 802b3a2:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802b3a6:	f000 8096 	beq.w	802b4d6 <powf+0x23e>
 802b3aa:	f1b3 4ffe 	cmp.w	r3, #2130706432	; 0x7f000000
 802b3ae:	ea6f 0404 	mvn.w	r4, r4
 802b3b2:	bf34      	ite	cc
 802b3b4:	2300      	movcc	r3, #0
 802b3b6:	2301      	movcs	r3, #1
 802b3b8:	0fe4      	lsrs	r4, r4, #31
 802b3ba:	42a3      	cmp	r3, r4
 802b3bc:	f040 808e 	bne.w	802b4dc <powf+0x244>
 802b3c0:	ee24 0aa4 	vmul.f32	s0, s9, s9
 802b3c4:	e7db      	b.n	802b37e <powf+0xe6>
 802b3c6:	004d      	lsls	r5, r1, #1
 802b3c8:	1e6a      	subs	r2, r5, #1
 802b3ca:	429a      	cmp	r2, r3
 802b3cc:	d91b      	bls.n	802b406 <powf+0x16e>
 802b3ce:	2900      	cmp	r1, #0
 802b3d0:	ee20 0a00 	vmul.f32	s0, s0, s0
 802b3d4:	da0e      	bge.n	802b3f4 <powf+0x15c>
 802b3d6:	ee10 0a90 	vmov	r0, s1
 802b3da:	f7ff ff45 	bl	802b268 <checkint>
 802b3de:	2801      	cmp	r0, #1
 802b3e0:	d108      	bne.n	802b3f4 <powf+0x15c>
 802b3e2:	eeb1 0a40 	vneg.f32	s0, s0
 802b3e6:	b93d      	cbnz	r5, 802b3f8 <powf+0x160>
 802b3e8:	2c00      	cmp	r4, #0
 802b3ea:	dac8      	bge.n	802b37e <powf+0xe6>
 802b3ec:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802b3f0:	f001 bf28 	b.w	802d244 <__math_divzerof>
 802b3f4:	2000      	movs	r0, #0
 802b3f6:	e7f6      	b.n	802b3e6 <powf+0x14e>
 802b3f8:	2c00      	cmp	r4, #0
 802b3fa:	dac0      	bge.n	802b37e <powf+0xe6>
 802b3fc:	eef7 7a00 	vmov.f32	s15, #112	; 0x3f800000  1.0
 802b400:	ee87 0a80 	vdiv.f32	s0, s15, s0
 802b404:	e7bb      	b.n	802b37e <powf+0xe6>
 802b406:	2900      	cmp	r1, #0
 802b408:	da1e      	bge.n	802b448 <powf+0x1b0>
 802b40a:	ee10 0a90 	vmov	r0, s1
 802b40e:	f7ff ff2b 	bl	802b268 <checkint>
 802b412:	b918      	cbnz	r0, 802b41c <powf+0x184>
 802b414:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802b418:	f001 bf24 	b.w	802d264 <__math_invalidf>
 802b41c:	2801      	cmp	r0, #1
 802b41e:	bf0c      	ite	eq
 802b420:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 802b424:	2000      	movne	r0, #0
 802b426:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802b42a:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 802b42e:	f4bf af47 	bcs.w	802b2c0 <powf+0x28>
 802b432:	eddf 0a35 	vldr	s1, [pc, #212]	; 802b508 <powf+0x270>
 802b436:	ee20 0a20 	vmul.f32	s0, s0, s1
 802b43a:	ee10 3a10 	vmov	r3, s0
 802b43e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802b442:	f1a3 6138 	sub.w	r1, r3, #192937984	; 0xb800000
 802b446:	e73b      	b.n	802b2c0 <powf+0x28>
 802b448:	2000      	movs	r0, #0
 802b44a:	e7ee      	b.n	802b42a <powf+0x192>
 802b44c:	ed9f 7b28 	vldr	d7, [pc, #160]	; 802b4f0 <powf+0x258>
 802b450:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802b454:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b458:	d803      	bhi.n	802b462 <powf+0x1ca>
 802b45a:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802b45e:	f001 bedf 	b.w	802d220 <__math_uflowf>
 802b462:	ed9f 7b25 	vldr	d7, [pc, #148]	; 802b4f8 <powf+0x260>
 802b466:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802b46a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b46e:	d503      	bpl.n	802b478 <powf+0x1e0>
 802b470:	e8bd 48f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, lr}
 802b474:	f001 beda 	b.w	802d22c <__math_may_uflowf>
 802b478:	4924      	ldr	r1, [pc, #144]	; (802b50c <powf+0x274>)
 802b47a:	ed91 7b40 	vldr	d7, [r1, #256]	; 0x100
 802b47e:	ee30 6b07 	vadd.f64	d6, d0, d7
 802b482:	ec55 4b16 	vmov	r4, r5, d6
 802b486:	ee36 7b47 	vsub.f64	d7, d6, d7
 802b48a:	f004 021f 	and.w	r2, r4, #31
 802b48e:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
 802b492:	ed91 6b46 	vldr	d6, [r1, #280]	; 0x118
 802b496:	ee30 0b47 	vsub.f64	d0, d0, d7
 802b49a:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 802b49e:	e9d2 6700 	ldrd	r6, r7, [r2]
 802b4a2:	eea0 7b06 	vfma.f64	d7, d0, d6
 802b4a6:	1824      	adds	r4, r4, r0
 802b4a8:	ed91 5b42 	vldr	d5, [r1, #264]	; 0x108
 802b4ac:	ed91 6b44 	vldr	d6, [r1, #272]	; 0x110
 802b4b0:	2000      	movs	r0, #0
 802b4b2:	1982      	adds	r2, r0, r6
 802b4b4:	ea4f 31c4 	mov.w	r1, r4, lsl #15
 802b4b8:	eb41 0307 	adc.w	r3, r1, r7
 802b4bc:	eea0 6b05 	vfma.f64	d6, d0, d5
 802b4c0:	ee20 0b00 	vmul.f64	d0, d0, d0
 802b4c4:	eea6 7b00 	vfma.f64	d7, d6, d0
 802b4c8:	ec43 2b16 	vmov	d6, r2, r3
 802b4cc:	ee27 0b06 	vmul.f64	d0, d7, d6
 802b4d0:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802b4d4:	e753      	b.n	802b37e <powf+0xe6>
 802b4d6:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b4da:	e750      	b.n	802b37e <powf+0xe6>
 802b4dc:	ed9f 0a0c 	vldr	s0, [pc, #48]	; 802b510 <powf+0x278>
 802b4e0:	e74d      	b.n	802b37e <powf+0xe6>
 802b4e2:	bf00      	nop
 802b4e4:	f3af 8000 	nop.w
 802b4e8:	ffd1d571 	.word	0xffd1d571
 802b4ec:	405fffff 	.word	0x405fffff
 802b4f0:	00000000 	.word	0x00000000
 802b4f4:	c062c000 	.word	0xc062c000
 802b4f8:	00000000 	.word	0x00000000
 802b4fc:	c062a000 	.word	0xc062a000
 802b500:	fefffffe 	.word	0xfefffffe
 802b504:	0804fd50 	.word	0x0804fd50
 802b508:	4b000000 	.word	0x4b000000
 802b50c:	0804f9c8 	.word	0x0804f9c8
 802b510:	00000000 	.word	0x00000000

0802b514 <tanf>:
 802b514:	ee10 3a10 	vmov	r3, s0
 802b518:	b507      	push	{r0, r1, r2, lr}
 802b51a:	4a10      	ldr	r2, [pc, #64]	; (802b55c <tanf+0x48>)
 802b51c:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802b520:	4293      	cmp	r3, r2
 802b522:	dc05      	bgt.n	802b530 <tanf+0x1c>
 802b524:	eddf 0a0e 	vldr	s1, [pc, #56]	; 802b560 <tanf+0x4c>
 802b528:	2001      	movs	r0, #1
 802b52a:	f001 fd7b 	bl	802d024 <__kernel_tanf>
 802b52e:	e004      	b.n	802b53a <tanf+0x26>
 802b530:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b534:	db04      	blt.n	802b540 <tanf+0x2c>
 802b536:	ee30 0a40 	vsub.f32	s0, s0, s0
 802b53a:	b003      	add	sp, #12
 802b53c:	f85d fb04 	ldr.w	pc, [sp], #4
 802b540:	4668      	mov	r0, sp
 802b542:	f001 f8ad 	bl	802c6a0 <__ieee754_rem_pio2f>
 802b546:	0040      	lsls	r0, r0, #1
 802b548:	f000 0002 	and.w	r0, r0, #2
 802b54c:	f1c0 0001 	rsb	r0, r0, #1
 802b550:	eddd 0a01 	vldr	s1, [sp, #4]
 802b554:	ed9d 0a00 	vldr	s0, [sp]
 802b558:	e7e7      	b.n	802b52a <tanf+0x16>
 802b55a:	bf00      	nop
 802b55c:	3f490fda 	.word	0x3f490fda
 802b560:	00000000 	.word	0x00000000

0802b564 <tanhf>:
 802b564:	b510      	push	{r4, lr}
 802b566:	ee10 4a10 	vmov	r4, s0
 802b56a:	f024 4300 	bic.w	r3, r4, #2147483648	; 0x80000000
 802b56e:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802b572:	ed2d 8b02 	vpush	{d8}
 802b576:	eef0 7a40 	vmov.f32	s15, s0
 802b57a:	db0c      	blt.n	802b596 <tanhf+0x32>
 802b57c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802b580:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802b584:	2c00      	cmp	r4, #0
 802b586:	bfac      	ite	ge
 802b588:	ee30 0a07 	vaddge.f32	s0, s0, s14
 802b58c:	ee30 0a47 	vsublt.f32	s0, s0, s14
 802b590:	ecbd 8b02 	vpop	{d8}
 802b594:	bd10      	pop	{r4, pc}
 802b596:	4a1b      	ldr	r2, [pc, #108]	; (802b604 <tanhf+0xa0>)
 802b598:	4293      	cmp	r3, r2
 802b59a:	dc30      	bgt.n	802b5fe <tanhf+0x9a>
 802b59c:	f1b3 5f10 	cmp.w	r3, #603979776	; 0x24000000
 802b5a0:	da06      	bge.n	802b5b0 <tanhf+0x4c>
 802b5a2:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b5a6:	ee37 0a80 	vadd.f32	s0, s15, s0
 802b5aa:	ee20 0a27 	vmul.f32	s0, s0, s15
 802b5ae:	e7ef      	b.n	802b590 <tanhf+0x2c>
 802b5b0:	f1b3 5f7e 	cmp.w	r3, #1065353216	; 0x3f800000
 802b5b4:	eeb0 8a00 	vmov.f32	s16, #0	; 0x40000000  2.0
 802b5b8:	db12      	blt.n	802b5e0 <tanhf+0x7c>
 802b5ba:	f7ff fd7d 	bl	802b0b8 <fabsf>
 802b5be:	ee30 0a00 	vadd.f32	s0, s0, s0
 802b5c2:	f001 ff83 	bl	802d4cc <expm1f>
 802b5c6:	ee30 0a08 	vadd.f32	s0, s0, s16
 802b5ca:	eec8 7a00 	vdiv.f32	s15, s16, s0
 802b5ce:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b5d2:	ee30 0a67 	vsub.f32	s0, s0, s15
 802b5d6:	2c00      	cmp	r4, #0
 802b5d8:	bfb8      	it	lt
 802b5da:	eeb1 0a40 	vneglt.f32	s0, s0
 802b5de:	e7d7      	b.n	802b590 <tanhf+0x2c>
 802b5e0:	f7ff fd6a 	bl	802b0b8 <fabsf>
 802b5e4:	eef8 7a00 	vmov.f32	s15, #128	; 0xc0000000 -2.0
 802b5e8:	ee20 0a27 	vmul.f32	s0, s0, s15
 802b5ec:	f001 ff6e 	bl	802d4cc <expm1f>
 802b5f0:	ee70 7a08 	vadd.f32	s15, s0, s16
 802b5f4:	eeb1 7a40 	vneg.f32	s14, s0
 802b5f8:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802b5fc:	e7eb      	b.n	802b5d6 <tanhf+0x72>
 802b5fe:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802b602:	e7e8      	b.n	802b5d6 <tanhf+0x72>
 802b604:	41afffff 	.word	0x41afffff

0802b608 <exp>:
 802b608:	b510      	push	{r4, lr}
 802b60a:	ed2d 8b04 	vpush	{d8-d9}
 802b60e:	eeb0 8b40 	vmov.f64	d8, d0
 802b612:	4c33      	ldr	r4, [pc, #204]	; (802b6e0 <exp+0xd8>)
 802b614:	b08a      	sub	sp, #40	; 0x28
 802b616:	f000 fad3 	bl	802bbc0 <__ieee754_exp>
 802b61a:	f994 3000 	ldrsb.w	r3, [r4]
 802b61e:	eeb0 9b40 	vmov.f64	d9, d0
 802b622:	3301      	adds	r3, #1
 802b624:	d029      	beq.n	802b67a <exp+0x72>
 802b626:	eeb0 0b48 	vmov.f64	d0, d8
 802b62a:	f001 fe33 	bl	802d294 <finite>
 802b62e:	b320      	cbz	r0, 802b67a <exp+0x72>
 802b630:	ed9f 7b27 	vldr	d7, [pc, #156]	; 802b6d0 <exp+0xc8>
 802b634:	eeb4 8bc7 	vcmpe.f64	d8, d7
 802b638:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b63c:	dd2e      	ble.n	802b69c <exp+0x94>
 802b63e:	2303      	movs	r3, #3
 802b640:	9300      	str	r3, [sp, #0]
 802b642:	4b28      	ldr	r3, [pc, #160]	; (802b6e4 <exp+0xdc>)
 802b644:	9301      	str	r3, [sp, #4]
 802b646:	2300      	movs	r3, #0
 802b648:	9308      	str	r3, [sp, #32]
 802b64a:	f994 3000 	ldrsb.w	r3, [r4]
 802b64e:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b652:	ed8d 8b02 	vstr	d8, [sp, #8]
 802b656:	b9b3      	cbnz	r3, 802b686 <exp+0x7e>
 802b658:	4b23      	ldr	r3, [pc, #140]	; (802b6e8 <exp+0xe0>)
 802b65a:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802b65e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b662:	4668      	mov	r0, sp
 802b664:	f001 fe1e 	bl	802d2a4 <matherr>
 802b668:	b198      	cbz	r0, 802b692 <exp+0x8a>
 802b66a:	9b08      	ldr	r3, [sp, #32]
 802b66c:	b11b      	cbz	r3, 802b676 <exp+0x6e>
 802b66e:	f7ff faf5 	bl	802ac5c <__errno>
 802b672:	9b08      	ldr	r3, [sp, #32]
 802b674:	6003      	str	r3, [r0, #0]
 802b676:	ed9d 9b06 	vldr	d9, [sp, #24]
 802b67a:	eeb0 0b49 	vmov.f64	d0, d9
 802b67e:	b00a      	add	sp, #40	; 0x28
 802b680:	ecbd 8b04 	vpop	{d8-d9}
 802b684:	bd10      	pop	{r4, pc}
 802b686:	4919      	ldr	r1, [pc, #100]	; (802b6ec <exp+0xe4>)
 802b688:	2000      	movs	r0, #0
 802b68a:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802b68e:	2b02      	cmp	r3, #2
 802b690:	d1e7      	bne.n	802b662 <exp+0x5a>
 802b692:	f7ff fae3 	bl	802ac5c <__errno>
 802b696:	2322      	movs	r3, #34	; 0x22
 802b698:	6003      	str	r3, [r0, #0]
 802b69a:	e7e6      	b.n	802b66a <exp+0x62>
 802b69c:	ed9f 7b0e 	vldr	d7, [pc, #56]	; 802b6d8 <exp+0xd0>
 802b6a0:	eeb4 8bc7 	vcmpe.f64	d8, d7
 802b6a4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b6a8:	d5e7      	bpl.n	802b67a <exp+0x72>
 802b6aa:	2304      	movs	r3, #4
 802b6ac:	9300      	str	r3, [sp, #0]
 802b6ae:	4b0d      	ldr	r3, [pc, #52]	; (802b6e4 <exp+0xdc>)
 802b6b0:	9301      	str	r3, [sp, #4]
 802b6b2:	2300      	movs	r3, #0
 802b6b4:	9308      	str	r3, [sp, #32]
 802b6b6:	2200      	movs	r2, #0
 802b6b8:	2300      	movs	r3, #0
 802b6ba:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b6be:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b6c2:	ed8d 8b02 	vstr	d8, [sp, #8]
 802b6c6:	f994 3000 	ldrsb.w	r3, [r4]
 802b6ca:	e7e0      	b.n	802b68e <exp+0x86>
 802b6cc:	f3af 8000 	nop.w
 802b6d0:	fefa39ef 	.word	0xfefa39ef
 802b6d4:	40862e42 	.word	0x40862e42
 802b6d8:	d52d3051 	.word	0xd52d3051
 802b6dc:	c0874910 	.word	0xc0874910
 802b6e0:	20000498 	.word	0x20000498
 802b6e4:	0804fe78 	.word	0x0804fe78
 802b6e8:	47efffff 	.word	0x47efffff
 802b6ec:	7ff00000 	.word	0x7ff00000

0802b6f0 <pow>:
 802b6f0:	b570      	push	{r4, r5, r6, lr}
 802b6f2:	ed2d 8b0a 	vpush	{d8-d12}
 802b6f6:	eeb0 9b40 	vmov.f64	d9, d0
 802b6fa:	eeb0 8b41 	vmov.f64	d8, d1
 802b6fe:	4c8c      	ldr	r4, [pc, #560]	; (802b930 <pow+0x240>)
 802b700:	b08a      	sub	sp, #40	; 0x28
 802b702:	f000 fb65 	bl	802bdd0 <__ieee754_pow>
 802b706:	f994 3000 	ldrsb.w	r3, [r4]
 802b70a:	eeb0 ab40 	vmov.f64	d10, d0
 802b70e:	1c5a      	adds	r2, r3, #1
 802b710:	4626      	mov	r6, r4
 802b712:	d04b      	beq.n	802b7ac <pow+0xbc>
 802b714:	eeb4 8b48 	vcmp.f64	d8, d8
 802b718:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b71c:	d646      	bvs.n	802b7ac <pow+0xbc>
 802b71e:	eeb4 9b49 	vcmp.f64	d9, d9
 802b722:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b726:	d719      	bvc.n	802b75c <pow+0x6c>
 802b728:	eeb5 8b40 	vcmp.f64	d8, #0.0
 802b72c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b730:	d13c      	bne.n	802b7ac <pow+0xbc>
 802b732:	2201      	movs	r2, #1
 802b734:	9200      	str	r2, [sp, #0]
 802b736:	497f      	ldr	r1, [pc, #508]	; (802b934 <pow+0x244>)
 802b738:	4a7f      	ldr	r2, [pc, #508]	; (802b938 <pow+0x248>)
 802b73a:	9201      	str	r2, [sp, #4]
 802b73c:	2000      	movs	r0, #0
 802b73e:	2200      	movs	r2, #0
 802b740:	2b02      	cmp	r3, #2
 802b742:	9208      	str	r2, [sp, #32]
 802b744:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b748:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b74c:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802b750:	d02a      	beq.n	802b7a8 <pow+0xb8>
 802b752:	4668      	mov	r0, sp
 802b754:	f001 fda6 	bl	802d2a4 <matherr>
 802b758:	bb00      	cbnz	r0, 802b79c <pow+0xac>
 802b75a:	e04e      	b.n	802b7fa <pow+0x10a>
 802b75c:	ed9f bb72 	vldr	d11, [pc, #456]	; 802b928 <pow+0x238>
 802b760:	eeb4 9b4b 	vcmp.f64	d9, d11
 802b764:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b768:	eeb0 cb4b 	vmov.f64	d12, d11
 802b76c:	d14a      	bne.n	802b804 <pow+0x114>
 802b76e:	eeb4 8b4b 	vcmp.f64	d8, d11
 802b772:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b776:	d11f      	bne.n	802b7b8 <pow+0xc8>
 802b778:	2201      	movs	r2, #1
 802b77a:	9200      	str	r2, [sp, #0]
 802b77c:	4a6e      	ldr	r2, [pc, #440]	; (802b938 <pow+0x248>)
 802b77e:	9201      	str	r2, [sp, #4]
 802b780:	2200      	movs	r2, #0
 802b782:	9208      	str	r2, [sp, #32]
 802b784:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b788:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b78c:	ed8d bb06 	vstr	d11, [sp, #24]
 802b790:	2b00      	cmp	r3, #0
 802b792:	d0de      	beq.n	802b752 <pow+0x62>
 802b794:	4b67      	ldr	r3, [pc, #412]	; (802b934 <pow+0x244>)
 802b796:	2200      	movs	r2, #0
 802b798:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b79c:	9b08      	ldr	r3, [sp, #32]
 802b79e:	b11b      	cbz	r3, 802b7a8 <pow+0xb8>
 802b7a0:	f7ff fa5c 	bl	802ac5c <__errno>
 802b7a4:	9b08      	ldr	r3, [sp, #32]
 802b7a6:	6003      	str	r3, [r0, #0]
 802b7a8:	ed9d ab06 	vldr	d10, [sp, #24]
 802b7ac:	eeb0 0b4a 	vmov.f64	d0, d10
 802b7b0:	b00a      	add	sp, #40	; 0x28
 802b7b2:	ecbd 8b0a 	vpop	{d8-d12}
 802b7b6:	bd70      	pop	{r4, r5, r6, pc}
 802b7b8:	eeb0 0b48 	vmov.f64	d0, d8
 802b7bc:	f001 fd6a 	bl	802d294 <finite>
 802b7c0:	2800      	cmp	r0, #0
 802b7c2:	d0f3      	beq.n	802b7ac <pow+0xbc>
 802b7c4:	eeb5 8bc0 	vcmpe.f64	d8, #0.0
 802b7c8:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b7cc:	d5ee      	bpl.n	802b7ac <pow+0xbc>
 802b7ce:	2301      	movs	r3, #1
 802b7d0:	9300      	str	r3, [sp, #0]
 802b7d2:	4b59      	ldr	r3, [pc, #356]	; (802b938 <pow+0x248>)
 802b7d4:	9301      	str	r3, [sp, #4]
 802b7d6:	2300      	movs	r3, #0
 802b7d8:	9308      	str	r3, [sp, #32]
 802b7da:	f994 3000 	ldrsb.w	r3, [r4]
 802b7de:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b7e2:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b7e6:	b913      	cbnz	r3, 802b7ee <pow+0xfe>
 802b7e8:	ed8d bb06 	vstr	d11, [sp, #24]
 802b7ec:	e7b1      	b.n	802b752 <pow+0x62>
 802b7ee:	4953      	ldr	r1, [pc, #332]	; (802b93c <pow+0x24c>)
 802b7f0:	2000      	movs	r0, #0
 802b7f2:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802b7f6:	2b02      	cmp	r3, #2
 802b7f8:	d1ab      	bne.n	802b752 <pow+0x62>
 802b7fa:	f7ff fa2f 	bl	802ac5c <__errno>
 802b7fe:	2321      	movs	r3, #33	; 0x21
 802b800:	6003      	str	r3, [r0, #0]
 802b802:	e7cb      	b.n	802b79c <pow+0xac>
 802b804:	f001 fd46 	bl	802d294 <finite>
 802b808:	4605      	mov	r5, r0
 802b80a:	2800      	cmp	r0, #0
 802b80c:	d164      	bne.n	802b8d8 <pow+0x1e8>
 802b80e:	eeb0 0b49 	vmov.f64	d0, d9
 802b812:	f001 fd3f 	bl	802d294 <finite>
 802b816:	2800      	cmp	r0, #0
 802b818:	d05e      	beq.n	802b8d8 <pow+0x1e8>
 802b81a:	eeb0 0b48 	vmov.f64	d0, d8
 802b81e:	f001 fd39 	bl	802d294 <finite>
 802b822:	2800      	cmp	r0, #0
 802b824:	d058      	beq.n	802b8d8 <pow+0x1e8>
 802b826:	eeb4 ab4a 	vcmp.f64	d10, d10
 802b82a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b82e:	f994 3000 	ldrsb.w	r3, [r4]
 802b832:	4a41      	ldr	r2, [pc, #260]	; (802b938 <pow+0x248>)
 802b834:	d70e      	bvc.n	802b854 <pow+0x164>
 802b836:	2101      	movs	r1, #1
 802b838:	e9cd 1200 	strd	r1, r2, [sp]
 802b83c:	9508      	str	r5, [sp, #32]
 802b83e:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b842:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b846:	2b00      	cmp	r3, #0
 802b848:	d0ce      	beq.n	802b7e8 <pow+0xf8>
 802b84a:	ee8b 7b0b 	vdiv.f64	d7, d11, d11
 802b84e:	ed8d 7b06 	vstr	d7, [sp, #24]
 802b852:	e7d0      	b.n	802b7f6 <pow+0x106>
 802b854:	2103      	movs	r1, #3
 802b856:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b85a:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
 802b85e:	ee28 8b07 	vmul.f64	d8, d8, d7
 802b862:	e9cd 1200 	strd	r1, r2, [sp]
 802b866:	9508      	str	r5, [sp, #32]
 802b868:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b86c:	b9fb      	cbnz	r3, 802b8ae <pow+0x1be>
 802b86e:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
 802b872:	4b33      	ldr	r3, [pc, #204]	; (802b940 <pow+0x250>)
 802b874:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802b878:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b87c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b880:	d54b      	bpl.n	802b91a <pow+0x22a>
 802b882:	eeb0 0b48 	vmov.f64	d0, d8
 802b886:	f001 fd17 	bl	802d2b8 <rint>
 802b88a:	eeb4 0b48 	vcmp.f64	d0, d8
 802b88e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b892:	d004      	beq.n	802b89e <pow+0x1ae>
 802b894:	4b2b      	ldr	r3, [pc, #172]	; (802b944 <pow+0x254>)
 802b896:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
 802b89a:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b89e:	f996 3000 	ldrsb.w	r3, [r6]
 802b8a2:	2b02      	cmp	r3, #2
 802b8a4:	d139      	bne.n	802b91a <pow+0x22a>
 802b8a6:	f7ff f9d9 	bl	802ac5c <__errno>
 802b8aa:	2322      	movs	r3, #34	; 0x22
 802b8ac:	e7a8      	b.n	802b800 <pow+0x110>
 802b8ae:	4b26      	ldr	r3, [pc, #152]	; (802b948 <pow+0x258>)
 802b8b0:	eeb5 9bc0 	vcmpe.f64	d9, #0.0
 802b8b4:	2200      	movs	r2, #0
 802b8b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b8ba:	e9cd 2306 	strd	r2, r3, [sp, #24]
 802b8be:	d5ee      	bpl.n	802b89e <pow+0x1ae>
 802b8c0:	eeb0 0b48 	vmov.f64	d0, d8
 802b8c4:	f001 fcf8 	bl	802d2b8 <rint>
 802b8c8:	eeb4 0b48 	vcmp.f64	d0, d8
 802b8cc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b8d0:	d0e5      	beq.n	802b89e <pow+0x1ae>
 802b8d2:	2200      	movs	r2, #0
 802b8d4:	4b19      	ldr	r3, [pc, #100]	; (802b93c <pow+0x24c>)
 802b8d6:	e7e0      	b.n	802b89a <pow+0x1aa>
 802b8d8:	eeb5 ab40 	vcmp.f64	d10, #0.0
 802b8dc:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b8e0:	f47f af64 	bne.w	802b7ac <pow+0xbc>
 802b8e4:	eeb0 0b49 	vmov.f64	d0, d9
 802b8e8:	f001 fcd4 	bl	802d294 <finite>
 802b8ec:	2800      	cmp	r0, #0
 802b8ee:	f43f af5d 	beq.w	802b7ac <pow+0xbc>
 802b8f2:	eeb0 0b48 	vmov.f64	d0, d8
 802b8f6:	f001 fccd 	bl	802d294 <finite>
 802b8fa:	2800      	cmp	r0, #0
 802b8fc:	f43f af56 	beq.w	802b7ac <pow+0xbc>
 802b900:	2304      	movs	r3, #4
 802b902:	9300      	str	r3, [sp, #0]
 802b904:	4b0c      	ldr	r3, [pc, #48]	; (802b938 <pow+0x248>)
 802b906:	9301      	str	r3, [sp, #4]
 802b908:	2300      	movs	r3, #0
 802b90a:	9308      	str	r3, [sp, #32]
 802b90c:	ed8d 9b02 	vstr	d9, [sp, #8]
 802b910:	ed8d 8b04 	vstr	d8, [sp, #16]
 802b914:	ed8d cb06 	vstr	d12, [sp, #24]
 802b918:	e7c1      	b.n	802b89e <pow+0x1ae>
 802b91a:	4668      	mov	r0, sp
 802b91c:	f001 fcc2 	bl	802d2a4 <matherr>
 802b920:	2800      	cmp	r0, #0
 802b922:	f47f af3b 	bne.w	802b79c <pow+0xac>
 802b926:	e7be      	b.n	802b8a6 <pow+0x1b6>
	...
 802b930:	20000498 	.word	0x20000498
 802b934:	3ff00000 	.word	0x3ff00000
 802b938:	0804fe7c 	.word	0x0804fe7c
 802b93c:	fff00000 	.word	0xfff00000
 802b940:	47efffff 	.word	0x47efffff
 802b944:	c7efffff 	.word	0xc7efffff
 802b948:	7ff00000 	.word	0x7ff00000
 802b94c:	00000000 	.word	0x00000000

0802b950 <fmodf>:
 802b950:	b500      	push	{lr}
 802b952:	ed2d 8b02 	vpush	{d8}
 802b956:	b08b      	sub	sp, #44	; 0x2c
 802b958:	eeb0 8a40 	vmov.f32	s16, s0
 802b95c:	eef0 8a60 	vmov.f32	s17, s1
 802b960:	f000 fdc0 	bl	802c4e4 <__ieee754_fmodf>
 802b964:	4b24      	ldr	r3, [pc, #144]	; (802b9f8 <fmodf+0xa8>)
 802b966:	f993 3000 	ldrsb.w	r3, [r3]
 802b96a:	1c5a      	adds	r2, r3, #1
 802b96c:	d02d      	beq.n	802b9ca <fmodf+0x7a>
 802b96e:	eef4 8a68 	vcmp.f32	s17, s17
 802b972:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b976:	d628      	bvs.n	802b9ca <fmodf+0x7a>
 802b978:	eeb4 8a48 	vcmp.f32	s16, s16
 802b97c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b980:	d623      	bvs.n	802b9ca <fmodf+0x7a>
 802b982:	eef5 8a40 	vcmp.f32	s17, #0.0
 802b986:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802b98a:	d11e      	bne.n	802b9ca <fmodf+0x7a>
 802b98c:	2201      	movs	r2, #1
 802b98e:	9200      	str	r2, [sp, #0]
 802b990:	eeb7 0ac8 	vcvt.f64.f32	d0, s16
 802b994:	4a19      	ldr	r2, [pc, #100]	; (802b9fc <fmodf+0xac>)
 802b996:	9201      	str	r2, [sp, #4]
 802b998:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
 802b99c:	2200      	movs	r2, #0
 802b99e:	9208      	str	r2, [sp, #32]
 802b9a0:	ed8d 0b02 	vstr	d0, [sp, #8]
 802b9a4:	ed8d 7b04 	vstr	d7, [sp, #16]
 802b9a8:	b9a3      	cbnz	r3, 802b9d4 <fmodf+0x84>
 802b9aa:	ed8d 0b06 	vstr	d0, [sp, #24]
 802b9ae:	4668      	mov	r0, sp
 802b9b0:	f001 fc78 	bl	802d2a4 <matherr>
 802b9b4:	b1b0      	cbz	r0, 802b9e4 <fmodf+0x94>
 802b9b6:	9b08      	ldr	r3, [sp, #32]
 802b9b8:	b11b      	cbz	r3, 802b9c2 <fmodf+0x72>
 802b9ba:	f7ff f94f 	bl	802ac5c <__errno>
 802b9be:	9b08      	ldr	r3, [sp, #32]
 802b9c0:	6003      	str	r3, [r0, #0]
 802b9c2:	ed9d 0b06 	vldr	d0, [sp, #24]
 802b9c6:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802b9ca:	b00b      	add	sp, #44	; 0x2c
 802b9cc:	ecbd 8b02 	vpop	{d8}
 802b9d0:	f85d fb04 	ldr.w	pc, [sp], #4
 802b9d4:	ed9f 7b06 	vldr	d7, [pc, #24]	; 802b9f0 <fmodf+0xa0>
 802b9d8:	2b02      	cmp	r3, #2
 802b9da:	ee87 6b07 	vdiv.f64	d6, d7, d7
 802b9de:	ed8d 6b06 	vstr	d6, [sp, #24]
 802b9e2:	d1e4      	bne.n	802b9ae <fmodf+0x5e>
 802b9e4:	f7ff f93a 	bl	802ac5c <__errno>
 802b9e8:	2321      	movs	r3, #33	; 0x21
 802b9ea:	6003      	str	r3, [r0, #0]
 802b9ec:	e7e3      	b.n	802b9b6 <fmodf+0x66>
 802b9ee:	bf00      	nop
	...
 802b9f8:	20000498 	.word	0x20000498
 802b9fc:	0804fe80 	.word	0x0804fe80

0802ba00 <log10f>:
 802ba00:	b500      	push	{lr}
 802ba02:	ed2d 8b02 	vpush	{d8}
 802ba06:	b08b      	sub	sp, #44	; 0x2c
 802ba08:	eeb0 8a40 	vmov.f32	s16, s0
 802ba0c:	f000 fdf2 	bl	802c5f4 <__ieee754_log10f>
 802ba10:	4b2f      	ldr	r3, [pc, #188]	; (802bad0 <log10f+0xd0>)
 802ba12:	f993 3000 	ldrsb.w	r3, [r3]
 802ba16:	1c5a      	adds	r2, r3, #1
 802ba18:	d055      	beq.n	802bac6 <log10f+0xc6>
 802ba1a:	eeb4 8a48 	vcmp.f32	s16, s16
 802ba1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba22:	d650      	bvs.n	802bac6 <log10f+0xc6>
 802ba24:	eeb5 8ac0 	vcmpe.f32	s16, #0.0
 802ba28:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba2c:	d84b      	bhi.n	802bac6 <log10f+0xc6>
 802ba2e:	4a29      	ldr	r2, [pc, #164]	; (802bad4 <log10f+0xd4>)
 802ba30:	9201      	str	r2, [sp, #4]
 802ba32:	eeb7 7ac8 	vcvt.f64.f32	d7, s16
 802ba36:	2200      	movs	r2, #0
 802ba38:	9208      	str	r2, [sp, #32]
 802ba3a:	ed8d 7b04 	vstr	d7, [sp, #16]
 802ba3e:	ed8d 7b02 	vstr	d7, [sp, #8]
 802ba42:	b993      	cbnz	r3, 802ba6a <log10f+0x6a>
 802ba44:	4924      	ldr	r1, [pc, #144]	; (802bad8 <log10f+0xd8>)
 802ba46:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802ba4a:	f04f 4060 	mov.w	r0, #3758096384	; 0xe0000000
 802ba4e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba52:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ba56:	d025      	beq.n	802baa4 <log10f+0xa4>
 802ba58:	2201      	movs	r2, #1
 802ba5a:	2b02      	cmp	r3, #2
 802ba5c:	9200      	str	r2, [sp, #0]
 802ba5e:	d116      	bne.n	802ba8e <log10f+0x8e>
 802ba60:	f7ff f8fc 	bl	802ac5c <__errno>
 802ba64:	2321      	movs	r3, #33	; 0x21
 802ba66:	6003      	str	r3, [r0, #0]
 802ba68:	e016      	b.n	802ba98 <log10f+0x98>
 802ba6a:	491c      	ldr	r1, [pc, #112]	; (802badc <log10f+0xdc>)
 802ba6c:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802ba70:	2000      	movs	r0, #0
 802ba72:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802ba76:	e9cd 0106 	strd	r0, r1, [sp, #24]
 802ba7a:	d1ed      	bne.n	802ba58 <log10f+0x58>
 802ba7c:	2202      	movs	r2, #2
 802ba7e:	4293      	cmp	r3, r2
 802ba80:	9200      	str	r2, [sp, #0]
 802ba82:	d111      	bne.n	802baa8 <log10f+0xa8>
 802ba84:	f7ff f8ea 	bl	802ac5c <__errno>
 802ba88:	2322      	movs	r3, #34	; 0x22
 802ba8a:	6003      	str	r3, [r0, #0]
 802ba8c:	e011      	b.n	802bab2 <log10f+0xb2>
 802ba8e:	4668      	mov	r0, sp
 802ba90:	f001 fc08 	bl	802d2a4 <matherr>
 802ba94:	2800      	cmp	r0, #0
 802ba96:	d0e3      	beq.n	802ba60 <log10f+0x60>
 802ba98:	4811      	ldr	r0, [pc, #68]	; (802bae0 <log10f+0xe0>)
 802ba9a:	f001 fc05 	bl	802d2a8 <nan>
 802ba9e:	ed8d 0b06 	vstr	d0, [sp, #24]
 802baa2:	e006      	b.n	802bab2 <log10f+0xb2>
 802baa4:	2302      	movs	r3, #2
 802baa6:	9300      	str	r3, [sp, #0]
 802baa8:	4668      	mov	r0, sp
 802baaa:	f001 fbfb 	bl	802d2a4 <matherr>
 802baae:	2800      	cmp	r0, #0
 802bab0:	d0e8      	beq.n	802ba84 <log10f+0x84>
 802bab2:	9b08      	ldr	r3, [sp, #32]
 802bab4:	b11b      	cbz	r3, 802babe <log10f+0xbe>
 802bab6:	f7ff f8d1 	bl	802ac5c <__errno>
 802baba:	9b08      	ldr	r3, [sp, #32]
 802babc:	6003      	str	r3, [r0, #0]
 802babe:	ed9d 0b06 	vldr	d0, [sp, #24]
 802bac2:	eeb7 0bc0 	vcvt.f32.f64	s0, d0
 802bac6:	b00b      	add	sp, #44	; 0x2c
 802bac8:	ecbd 8b02 	vpop	{d8}
 802bacc:	f85d fb04 	ldr.w	pc, [sp], #4
 802bad0:	20000498 	.word	0x20000498
 802bad4:	0804fe86 	.word	0x0804fe86
 802bad8:	c7efffff 	.word	0xc7efffff
 802badc:	fff00000 	.word	0xfff00000
 802bae0:	0804fe8c 	.word	0x0804fe8c
 802bae4:	00000000 	.word	0x00000000

0802bae8 <sinhf>:
 802bae8:	b530      	push	{r4, r5, lr}
 802baea:	ed2d 8b02 	vpush	{d8}
 802baee:	4c32      	ldr	r4, [pc, #200]	; (802bbb8 <sinhf+0xd0>)
 802baf0:	b08b      	sub	sp, #44	; 0x2c
 802baf2:	eef0 8a40 	vmov.f32	s17, s0
 802baf6:	f000 feff 	bl	802c8f8 <__ieee754_sinhf>
 802bafa:	f994 3000 	ldrsb.w	r3, [r4]
 802bafe:	3301      	adds	r3, #1
 802bb00:	eeb0 8a40 	vmov.f32	s16, s0
 802bb04:	d030      	beq.n	802bb68 <sinhf+0x80>
 802bb06:	f001 fe0b 	bl	802d720 <finitef>
 802bb0a:	4605      	mov	r5, r0
 802bb0c:	bb60      	cbnz	r0, 802bb68 <sinhf+0x80>
 802bb0e:	eeb0 0a68 	vmov.f32	s0, s17
 802bb12:	f001 fe05 	bl	802d720 <finitef>
 802bb16:	b338      	cbz	r0, 802bb68 <sinhf+0x80>
 802bb18:	2303      	movs	r3, #3
 802bb1a:	9300      	str	r3, [sp, #0]
 802bb1c:	4b27      	ldr	r3, [pc, #156]	; (802bbbc <sinhf+0xd4>)
 802bb1e:	9301      	str	r3, [sp, #4]
 802bb20:	eeb7 7ae8 	vcvt.f64.f32	d7, s17
 802bb24:	f994 3000 	ldrsb.w	r3, [r4]
 802bb28:	9508      	str	r5, [sp, #32]
 802bb2a:	ed8d 7b04 	vstr	d7, [sp, #16]
 802bb2e:	ed8d 7b02 	vstr	d7, [sp, #8]
 802bb32:	eef5 8ac0 	vcmpe.f32	s17, #0.0
 802bb36:	b9eb      	cbnz	r3, 802bb74 <sinhf+0x8c>
 802bb38:	ed9f 7b17 	vldr	d7, [pc, #92]	; 802bb98 <sinhf+0xb0>
 802bb3c:	ed9f 6b18 	vldr	d6, [pc, #96]	; 802bba0 <sinhf+0xb8>
 802bb40:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bb44:	fe37 7b06 	vselgt.f64	d7, d7, d6
 802bb48:	ed8d 7b06 	vstr	d7, [sp, #24]
 802bb4c:	4668      	mov	r0, sp
 802bb4e:	f001 fba9 	bl	802d2a4 <matherr>
 802bb52:	b1d8      	cbz	r0, 802bb8c <sinhf+0xa4>
 802bb54:	9b08      	ldr	r3, [sp, #32]
 802bb56:	b11b      	cbz	r3, 802bb60 <sinhf+0x78>
 802bb58:	f7ff f880 	bl	802ac5c <__errno>
 802bb5c:	9b08      	ldr	r3, [sp, #32]
 802bb5e:	6003      	str	r3, [r0, #0]
 802bb60:	ed9d 8b06 	vldr	d8, [sp, #24]
 802bb64:	eeb7 8bc8 	vcvt.f32.f64	s16, d8
 802bb68:	eeb0 0a48 	vmov.f32	s0, s16
 802bb6c:	b00b      	add	sp, #44	; 0x2c
 802bb6e:	ecbd 8b02 	vpop	{d8}
 802bb72:	bd30      	pop	{r4, r5, pc}
 802bb74:	ed9f 7b0c 	vldr	d7, [pc, #48]	; 802bba8 <sinhf+0xc0>
 802bb78:	ed9f 6b0d 	vldr	d6, [pc, #52]	; 802bbb0 <sinhf+0xc8>
 802bb7c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bb80:	fe37 7b06 	vselgt.f64	d7, d7, d6
 802bb84:	2b02      	cmp	r3, #2
 802bb86:	ed8d 7b06 	vstr	d7, [sp, #24]
 802bb8a:	d1df      	bne.n	802bb4c <sinhf+0x64>
 802bb8c:	f7ff f866 	bl	802ac5c <__errno>
 802bb90:	2322      	movs	r3, #34	; 0x22
 802bb92:	6003      	str	r3, [r0, #0]
 802bb94:	e7de      	b.n	802bb54 <sinhf+0x6c>
 802bb96:	bf00      	nop
 802bb98:	e0000000 	.word	0xe0000000
 802bb9c:	47efffff 	.word	0x47efffff
 802bba0:	e0000000 	.word	0xe0000000
 802bba4:	c7efffff 	.word	0xc7efffff
 802bba8:	00000000 	.word	0x00000000
 802bbac:	7ff00000 	.word	0x7ff00000
 802bbb0:	00000000 	.word	0x00000000
 802bbb4:	fff00000 	.word	0xfff00000
 802bbb8:	20000498 	.word	0x20000498
 802bbbc:	0804fe8d 	.word	0x0804fe8d

0802bbc0 <__ieee754_exp>:
 802bbc0:	ee10 1a90 	vmov	r1, s1
 802bbc4:	4b7a      	ldr	r3, [pc, #488]	; (802bdb0 <__ieee754_exp+0x1f0>)
 802bbc6:	f021 4200 	bic.w	r2, r1, #2147483648	; 0x80000000
 802bbca:	429a      	cmp	r2, r3
 802bbcc:	b082      	sub	sp, #8
 802bbce:	ea4f 70d1 	mov.w	r0, r1, lsr #31
 802bbd2:	d928      	bls.n	802bc26 <__ieee754_exp+0x66>
 802bbd4:	4b77      	ldr	r3, [pc, #476]	; (802bdb4 <__ieee754_exp+0x1f4>)
 802bbd6:	429a      	cmp	r2, r3
 802bbd8:	d90f      	bls.n	802bbfa <__ieee754_exp+0x3a>
 802bbda:	ee10 3a10 	vmov	r3, s0
 802bbde:	f3c1 0113 	ubfx	r1, r1, #0, #20
 802bbe2:	430b      	orrs	r3, r1
 802bbe4:	d003      	beq.n	802bbee <__ieee754_exp+0x2e>
 802bbe6:	ee30 0b00 	vadd.f64	d0, d0, d0
 802bbea:	b002      	add	sp, #8
 802bbec:	4770      	bx	lr
 802bbee:	ed9f 7b56 	vldr	d7, [pc, #344]	; 802bd48 <__ieee754_exp+0x188>
 802bbf2:	2800      	cmp	r0, #0
 802bbf4:	fe00 0b07 	vseleq.f64	d0, d0, d7
 802bbf8:	e7f7      	b.n	802bbea <__ieee754_exp+0x2a>
 802bbfa:	ed9f 7b55 	vldr	d7, [pc, #340]	; 802bd50 <__ieee754_exp+0x190>
 802bbfe:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802bc02:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bc06:	dd04      	ble.n	802bc12 <__ieee754_exp+0x52>
 802bc08:	ed9f 0b53 	vldr	d0, [pc, #332]	; 802bd58 <__ieee754_exp+0x198>
 802bc0c:	ee20 0b00 	vmul.f64	d0, d0, d0
 802bc10:	e7eb      	b.n	802bbea <__ieee754_exp+0x2a>
 802bc12:	ed9f 7b53 	vldr	d7, [pc, #332]	; 802bd60 <__ieee754_exp+0x1a0>
 802bc16:	eeb4 0bc7 	vcmpe.f64	d0, d7
 802bc1a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bc1e:	d505      	bpl.n	802bc2c <__ieee754_exp+0x6c>
 802bc20:	ed9f 0b49 	vldr	d0, [pc, #292]	; 802bd48 <__ieee754_exp+0x188>
 802bc24:	e7e1      	b.n	802bbea <__ieee754_exp+0x2a>
 802bc26:	4b64      	ldr	r3, [pc, #400]	; (802bdb8 <__ieee754_exp+0x1f8>)
 802bc28:	429a      	cmp	r2, r3
 802bc2a:	d956      	bls.n	802bcda <__ieee754_exp+0x11a>
 802bc2c:	4b63      	ldr	r3, [pc, #396]	; (802bdbc <__ieee754_exp+0x1fc>)
 802bc2e:	429a      	cmp	r2, r3
 802bc30:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 802bc34:	d838      	bhi.n	802bca8 <__ieee754_exp+0xe8>
 802bc36:	4b62      	ldr	r3, [pc, #392]	; (802bdc0 <__ieee754_exp+0x200>)
 802bc38:	4413      	add	r3, r2
 802bc3a:	ed93 6b00 	vldr	d6, [r3]
 802bc3e:	4b61      	ldr	r3, [pc, #388]	; (802bdc4 <__ieee754_exp+0x204>)
 802bc40:	ee30 6b46 	vsub.f64	d6, d0, d6
 802bc44:	4413      	add	r3, r2
 802bc46:	ed93 7b00 	vldr	d7, [r3]
 802bc4a:	f1c0 0301 	rsb	r3, r0, #1
 802bc4e:	1a1b      	subs	r3, r3, r0
 802bc50:	ee36 0b47 	vsub.f64	d0, d6, d7
 802bc54:	ed9f 4b44 	vldr	d4, [pc, #272]	; 802bd68 <__ieee754_exp+0x1a8>
 802bc58:	ee20 5b00 	vmul.f64	d5, d0, d0
 802bc5c:	ed9f 3b44 	vldr	d3, [pc, #272]	; 802bd70 <__ieee754_exp+0x1b0>
 802bc60:	eea5 3b04 	vfma.f64	d3, d5, d4
 802bc64:	ed9f 4b44 	vldr	d4, [pc, #272]	; 802bd78 <__ieee754_exp+0x1b8>
 802bc68:	eea3 4b05 	vfma.f64	d4, d3, d5
 802bc6c:	ed9f 3b44 	vldr	d3, [pc, #272]	; 802bd80 <__ieee754_exp+0x1c0>
 802bc70:	eea4 3b05 	vfma.f64	d3, d4, d5
 802bc74:	ed9f 4b44 	vldr	d4, [pc, #272]	; 802bd88 <__ieee754_exp+0x1c8>
 802bc78:	eea3 4b05 	vfma.f64	d4, d3, d5
 802bc7c:	eeb0 3b40 	vmov.f64	d3, d0
 802bc80:	eea4 3b45 	vfms.f64	d3, d4, d5
 802bc84:	eeb0 4b00 	vmov.f64	d4, #0	; 0x40000000  2.0
 802bc88:	eeb0 5b43 	vmov.f64	d5, d3
 802bc8c:	ee20 2b03 	vmul.f64	d2, d0, d3
 802bc90:	eeb7 3b00 	vmov.f64	d3, #112	; 0x3f800000  1.0
 802bc94:	bba3      	cbnz	r3, 802bd00 <__ieee754_exp+0x140>
 802bc96:	ee35 5b44 	vsub.f64	d5, d5, d4
 802bc9a:	ee82 7b05 	vdiv.f64	d7, d2, d5
 802bc9e:	ee37 0b40 	vsub.f64	d0, d7, d0
 802bca2:	ee33 0b40 	vsub.f64	d0, d3, d0
 802bca6:	e7a0      	b.n	802bbea <__ieee754_exp+0x2a>
 802bca8:	4b47      	ldr	r3, [pc, #284]	; (802bdc8 <__ieee754_exp+0x208>)
 802bcaa:	4413      	add	r3, r2
 802bcac:	ed93 7b00 	vldr	d7, [r3]
 802bcb0:	ed9f 6b37 	vldr	d6, [pc, #220]	; 802bd90 <__ieee754_exp+0x1d0>
 802bcb4:	ed9f 5b38 	vldr	d5, [pc, #224]	; 802bd98 <__ieee754_exp+0x1d8>
 802bcb8:	eea0 7b06 	vfma.f64	d7, d0, d6
 802bcbc:	ed9f 6b38 	vldr	d6, [pc, #224]	; 802bda0 <__ieee754_exp+0x1e0>
 802bcc0:	eefd 7bc7 	vcvt.s32.f64	s15, d7
 802bcc4:	ee17 3a90 	vmov	r3, s15
 802bcc8:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 802bccc:	eea7 0b46 	vfms.f64	d0, d7, d6
 802bcd0:	ee27 7b05 	vmul.f64	d7, d7, d5
 802bcd4:	eeb0 6b40 	vmov.f64	d6, d0
 802bcd8:	e7ba      	b.n	802bc50 <__ieee754_exp+0x90>
 802bcda:	4b3c      	ldr	r3, [pc, #240]	; (802bdcc <__ieee754_exp+0x20c>)
 802bcdc:	429a      	cmp	r2, r3
 802bcde:	d80d      	bhi.n	802bcfc <__ieee754_exp+0x13c>
 802bce0:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
 802bce4:	ed9f 5b1c 	vldr	d5, [pc, #112]	; 802bd58 <__ieee754_exp+0x198>
 802bce8:	ee30 5b05 	vadd.f64	d5, d0, d5
 802bcec:	eeb4 5bc4 	vcmpe.f64	d5, d4
 802bcf0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802bcf4:	dd02      	ble.n	802bcfc <__ieee754_exp+0x13c>
 802bcf6:	ee30 0b04 	vadd.f64	d0, d0, d4
 802bcfa:	e776      	b.n	802bbea <__ieee754_exp+0x2a>
 802bcfc:	2300      	movs	r3, #0
 802bcfe:	e7a9      	b.n	802bc54 <__ieee754_exp+0x94>
 802bd00:	f46f 717f 	mvn.w	r1, #1020	; 0x3fc
 802bd04:	ee34 5b45 	vsub.f64	d5, d4, d5
 802bd08:	428b      	cmp	r3, r1
 802bd0a:	ee82 4b05 	vdiv.f64	d4, d2, d5
 802bd0e:	ee37 7b44 	vsub.f64	d7, d7, d4
 802bd12:	ee37 7b46 	vsub.f64	d7, d7, d6
 802bd16:	ee33 7b47 	vsub.f64	d7, d3, d7
 802bd1a:	ed8d 7b00 	vstr	d7, [sp]
 802bd1e:	9a01      	ldr	r2, [sp, #4]
 802bd20:	e9dd 0100 	ldrd	r0, r1, [sp]
 802bd24:	db04      	blt.n	802bd30 <__ieee754_exp+0x170>
 802bd26:	eb02 5103 	add.w	r1, r2, r3, lsl #20
 802bd2a:	ec41 0b10 	vmov	d0, r0, r1
 802bd2e:	e75c      	b.n	802bbea <__ieee754_exp+0x2a>
 802bd30:	f503 737a 	add.w	r3, r3, #1000	; 0x3e8
 802bd34:	eb02 5103 	add.w	r1, r2, r3, lsl #20
 802bd38:	ed9f 7b1b 	vldr	d7, [pc, #108]	; 802bda8 <__ieee754_exp+0x1e8>
 802bd3c:	ec41 0b10 	vmov	d0, r0, r1
 802bd40:	ee20 0b07 	vmul.f64	d0, d0, d7
 802bd44:	e751      	b.n	802bbea <__ieee754_exp+0x2a>
 802bd46:	bf00      	nop
	...
 802bd50:	fefa39ef 	.word	0xfefa39ef
 802bd54:	40862e42 	.word	0x40862e42
 802bd58:	8800759c 	.word	0x8800759c
 802bd5c:	7e37e43c 	.word	0x7e37e43c
 802bd60:	d52d3051 	.word	0xd52d3051
 802bd64:	c0874910 	.word	0xc0874910
 802bd68:	72bea4d0 	.word	0x72bea4d0
 802bd6c:	3e663769 	.word	0x3e663769
 802bd70:	c5d26bf1 	.word	0xc5d26bf1
 802bd74:	bebbbd41 	.word	0xbebbbd41
 802bd78:	af25de2c 	.word	0xaf25de2c
 802bd7c:	3f11566a 	.word	0x3f11566a
 802bd80:	16bebd93 	.word	0x16bebd93
 802bd84:	bf66c16c 	.word	0xbf66c16c
 802bd88:	5555553e 	.word	0x5555553e
 802bd8c:	3fc55555 	.word	0x3fc55555
 802bd90:	652b82fe 	.word	0x652b82fe
 802bd94:	3ff71547 	.word	0x3ff71547
 802bd98:	35793c76 	.word	0x35793c76
 802bd9c:	3dea39ef 	.word	0x3dea39ef
 802bda0:	fee00000 	.word	0xfee00000
 802bda4:	3fe62e42 	.word	0x3fe62e42
 802bda8:	00000000 	.word	0x00000000
 802bdac:	01700000 	.word	0x01700000
 802bdb0:	40862e41 	.word	0x40862e41
 802bdb4:	7fefffff 	.word	0x7fefffff
 802bdb8:	3fd62e42 	.word	0x3fd62e42
 802bdbc:	3ff0a2b1 	.word	0x3ff0a2b1
 802bdc0:	0804fea8 	.word	0x0804fea8
 802bdc4:	0804feb8 	.word	0x0804feb8
 802bdc8:	0804fe98 	.word	0x0804fe98
 802bdcc:	3e2fffff 	.word	0x3e2fffff

0802bdd0 <__ieee754_pow>:
 802bdd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802bdd4:	ec57 6b11 	vmov	r6, r7, d1
 802bdd8:	ed2d 8b02 	vpush	{d8}
 802bddc:	eeb0 8b40 	vmov.f64	d8, d0
 802bde0:	f027 4800 	bic.w	r8, r7, #2147483648	; 0x80000000
 802bde4:	ea58 0306 	orrs.w	r3, r8, r6
 802bde8:	b085      	sub	sp, #20
 802bdea:	46b9      	mov	r9, r7
 802bdec:	ee11 2a10 	vmov	r2, s2
 802bdf0:	f000 8306 	beq.w	802c400 <__ieee754_pow+0x630>
 802bdf4:	ee18 aa90 	vmov	sl, s17
 802bdf8:	4bb9      	ldr	r3, [pc, #740]	; (802c0e0 <__ieee754_pow+0x310>)
 802bdfa:	f02a 4400 	bic.w	r4, sl, #2147483648	; 0x80000000
 802bdfe:	429c      	cmp	r4, r3
 802be00:	ee10 ba10 	vmov	fp, s0
 802be04:	dc0b      	bgt.n	802be1e <__ieee754_pow+0x4e>
 802be06:	d105      	bne.n	802be14 <__ieee754_pow+0x44>
 802be08:	f1bb 0f00 	cmp.w	fp, #0
 802be0c:	d107      	bne.n	802be1e <__ieee754_pow+0x4e>
 802be0e:	45a0      	cmp	r8, r4
 802be10:	dc0d      	bgt.n	802be2e <__ieee754_pow+0x5e>
 802be12:	e001      	b.n	802be18 <__ieee754_pow+0x48>
 802be14:	4598      	cmp	r8, r3
 802be16:	dc02      	bgt.n	802be1e <__ieee754_pow+0x4e>
 802be18:	4598      	cmp	r8, r3
 802be1a:	d110      	bne.n	802be3e <__ieee754_pow+0x6e>
 802be1c:	b17a      	cbz	r2, 802be3e <__ieee754_pow+0x6e>
 802be1e:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 802be22:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 802be26:	ea54 030b 	orrs.w	r3, r4, fp
 802be2a:	f000 82e9 	beq.w	802c400 <__ieee754_pow+0x630>
 802be2e:	48ad      	ldr	r0, [pc, #692]	; (802c0e4 <__ieee754_pow+0x314>)
 802be30:	b005      	add	sp, #20
 802be32:	ecbd 8b02 	vpop	{d8}
 802be36:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802be3a:	f001 ba35 	b.w	802d2a8 <nan>
 802be3e:	f1ba 0f00 	cmp.w	sl, #0
 802be42:	da4e      	bge.n	802bee2 <__ieee754_pow+0x112>
 802be44:	4ba8      	ldr	r3, [pc, #672]	; (802c0e8 <__ieee754_pow+0x318>)
 802be46:	4598      	cmp	r8, r3
 802be48:	dc49      	bgt.n	802bede <__ieee754_pow+0x10e>
 802be4a:	f1a3 7354 	sub.w	r3, r3, #55574528	; 0x3500000
 802be4e:	4598      	cmp	r8, r3
 802be50:	dd47      	ble.n	802bee2 <__ieee754_pow+0x112>
 802be52:	ea4f 5328 	mov.w	r3, r8, asr #20
 802be56:	f2a3 33ff 	subw	r3, r3, #1023	; 0x3ff
 802be5a:	2b14      	cmp	r3, #20
 802be5c:	dd24      	ble.n	802bea8 <__ieee754_pow+0xd8>
 802be5e:	f1c3 0334 	rsb	r3, r3, #52	; 0x34
 802be62:	fa22 f503 	lsr.w	r5, r2, r3
 802be66:	fa05 f303 	lsl.w	r3, r5, r3
 802be6a:	4293      	cmp	r3, r2
 802be6c:	d139      	bne.n	802bee2 <__ieee754_pow+0x112>
 802be6e:	f005 0501 	and.w	r5, r5, #1
 802be72:	f1c5 0502 	rsb	r5, r5, #2
 802be76:	2a00      	cmp	r2, #0
 802be78:	d15a      	bne.n	802bf30 <__ieee754_pow+0x160>
 802be7a:	4b99      	ldr	r3, [pc, #612]	; (802c0e0 <__ieee754_pow+0x310>)
 802be7c:	4598      	cmp	r8, r3
 802be7e:	d122      	bne.n	802bec6 <__ieee754_pow+0xf6>
 802be80:	f104 4340 	add.w	r3, r4, #3221225472	; 0xc0000000
 802be84:	f503 1380 	add.w	r3, r3, #1048576	; 0x100000
 802be88:	ea53 030b 	orrs.w	r3, r3, fp
 802be8c:	f000 82b8 	beq.w	802c400 <__ieee754_pow+0x630>
 802be90:	4b96      	ldr	r3, [pc, #600]	; (802c0ec <__ieee754_pow+0x31c>)
 802be92:	429c      	cmp	r4, r3
 802be94:	dd27      	ble.n	802bee6 <__ieee754_pow+0x116>
 802be96:	f1b9 0f00 	cmp.w	r9, #0
 802be9a:	f280 82b4 	bge.w	802c406 <__ieee754_pow+0x636>
 802be9e:	ed9f 7b84 	vldr	d7, [pc, #528]	; 802c0b0 <__ieee754_pow+0x2e0>
 802bea2:	ed8d 7b00 	vstr	d7, [sp]
 802bea6:	e026      	b.n	802bef6 <__ieee754_pow+0x126>
 802bea8:	2a00      	cmp	r2, #0
 802beaa:	d140      	bne.n	802bf2e <__ieee754_pow+0x15e>
 802beac:	f1c3 0314 	rsb	r3, r3, #20
 802beb0:	fa48 f503 	asr.w	r5, r8, r3
 802beb4:	fa05 f303 	lsl.w	r3, r5, r3
 802beb8:	4543      	cmp	r3, r8
 802beba:	f040 82aa 	bne.w	802c412 <__ieee754_pow+0x642>
 802bebe:	f005 0501 	and.w	r5, r5, #1
 802bec2:	f1c5 0502 	rsb	r5, r5, #2
 802bec6:	4b8a      	ldr	r3, [pc, #552]	; (802c0f0 <__ieee754_pow+0x320>)
 802bec8:	4598      	cmp	r8, r3
 802beca:	d11b      	bne.n	802bf04 <__ieee754_pow+0x134>
 802becc:	f1b9 0f00 	cmp.w	r9, #0
 802bed0:	f280 829c 	bge.w	802c40c <__ieee754_pow+0x63c>
 802bed4:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 802bed8:	ee87 7b08 	vdiv.f64	d7, d7, d8
 802bedc:	e7e1      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bede:	2502      	movs	r5, #2
 802bee0:	e7c9      	b.n	802be76 <__ieee754_pow+0xa6>
 802bee2:	2500      	movs	r5, #0
 802bee4:	e7c7      	b.n	802be76 <__ieee754_pow+0xa6>
 802bee6:	f1b9 0f00 	cmp.w	r9, #0
 802beea:	dad8      	bge.n	802be9e <__ieee754_pow+0xce>
 802beec:	f087 4400 	eor.w	r4, r7, #2147483648	; 0x80000000
 802bef0:	4633      	mov	r3, r6
 802bef2:	e9cd 3400 	strd	r3, r4, [sp]
 802bef6:	ed9d 0b00 	vldr	d0, [sp]
 802befa:	b005      	add	sp, #20
 802befc:	ecbd 8b02 	vpop	{d8}
 802bf00:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802bf04:	f1b9 4f80 	cmp.w	r9, #1073741824	; 0x40000000
 802bf08:	d102      	bne.n	802bf10 <__ieee754_pow+0x140>
 802bf0a:	ee28 7b08 	vmul.f64	d7, d8, d8
 802bf0e:	e7c8      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bf10:	4b78      	ldr	r3, [pc, #480]	; (802c0f4 <__ieee754_pow+0x324>)
 802bf12:	4599      	cmp	r9, r3
 802bf14:	d10c      	bne.n	802bf30 <__ieee754_pow+0x160>
 802bf16:	f1ba 0f00 	cmp.w	sl, #0
 802bf1a:	db09      	blt.n	802bf30 <__ieee754_pow+0x160>
 802bf1c:	eeb0 0b48 	vmov.f64	d0, d8
 802bf20:	b005      	add	sp, #20
 802bf22:	ecbd 8b02 	vpop	{d8}
 802bf26:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802bf2a:	f000 bad7 	b.w	802c4dc <__ieee754_sqrt>
 802bf2e:	2500      	movs	r5, #0
 802bf30:	eeb0 0b48 	vmov.f64	d0, d8
 802bf34:	f001 f9a5 	bl	802d282 <fabs>
 802bf38:	ed8d 0b00 	vstr	d0, [sp]
 802bf3c:	f1bb 0f00 	cmp.w	fp, #0
 802bf40:	d128      	bne.n	802bf94 <__ieee754_pow+0x1c4>
 802bf42:	b124      	cbz	r4, 802bf4e <__ieee754_pow+0x17e>
 802bf44:	4b6a      	ldr	r3, [pc, #424]	; (802c0f0 <__ieee754_pow+0x320>)
 802bf46:	f02a 4240 	bic.w	r2, sl, #3221225472	; 0xc0000000
 802bf4a:	429a      	cmp	r2, r3
 802bf4c:	d122      	bne.n	802bf94 <__ieee754_pow+0x1c4>
 802bf4e:	f1b9 0f00 	cmp.w	r9, #0
 802bf52:	da07      	bge.n	802bf64 <__ieee754_pow+0x194>
 802bf54:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 802bf58:	ed9d 6b00 	vldr	d6, [sp]
 802bf5c:	ee87 7b06 	vdiv.f64	d7, d7, d6
 802bf60:	ed8d 7b00 	vstr	d7, [sp]
 802bf64:	f1ba 0f00 	cmp.w	sl, #0
 802bf68:	dac5      	bge.n	802bef6 <__ieee754_pow+0x126>
 802bf6a:	f104 4440 	add.w	r4, r4, #3221225472	; 0xc0000000
 802bf6e:	f504 1480 	add.w	r4, r4, #1048576	; 0x100000
 802bf72:	ea54 0305 	orrs.w	r3, r4, r5
 802bf76:	d106      	bne.n	802bf86 <__ieee754_pow+0x1b6>
 802bf78:	ed9d 7b00 	vldr	d7, [sp]
 802bf7c:	ee37 7b47 	vsub.f64	d7, d7, d7
 802bf80:	ee87 7b07 	vdiv.f64	d7, d7, d7
 802bf84:	e78d      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bf86:	2d01      	cmp	r5, #1
 802bf88:	d1b5      	bne.n	802bef6 <__ieee754_pow+0x126>
 802bf8a:	ed9d 7b00 	vldr	d7, [sp]
 802bf8e:	eeb1 7b47 	vneg.f64	d7, d7
 802bf92:	e786      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bf94:	ea4f 7ada 	mov.w	sl, sl, lsr #31
 802bf98:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 802bf9c:	ea55 030a 	orrs.w	r3, r5, sl
 802bfa0:	d104      	bne.n	802bfac <__ieee754_pow+0x1dc>
 802bfa2:	ee38 8b48 	vsub.f64	d8, d8, d8
 802bfa6:	ee88 7b08 	vdiv.f64	d7, d8, d8
 802bfaa:	e77a      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bfac:	4b52      	ldr	r3, [pc, #328]	; (802c0f8 <__ieee754_pow+0x328>)
 802bfae:	4598      	cmp	r8, r3
 802bfb0:	f340 80a8 	ble.w	802c104 <__ieee754_pow+0x334>
 802bfb4:	f103 7304 	add.w	r3, r3, #34603008	; 0x2100000
 802bfb8:	4598      	cmp	r8, r3
 802bfba:	dd0b      	ble.n	802bfd4 <__ieee754_pow+0x204>
 802bfbc:	4b4b      	ldr	r3, [pc, #300]	; (802c0ec <__ieee754_pow+0x31c>)
 802bfbe:	429c      	cmp	r4, r3
 802bfc0:	dc0e      	bgt.n	802bfe0 <__ieee754_pow+0x210>
 802bfc2:	f1b9 0f00 	cmp.w	r9, #0
 802bfc6:	f6bf af6a 	bge.w	802be9e <__ieee754_pow+0xce>
 802bfca:	ed9f 7b3b 	vldr	d7, [pc, #236]	; 802c0b8 <__ieee754_pow+0x2e8>
 802bfce:	ee27 7b07 	vmul.f64	d7, d7, d7
 802bfd2:	e766      	b.n	802bea2 <__ieee754_pow+0xd2>
 802bfd4:	4b49      	ldr	r3, [pc, #292]	; (802c0fc <__ieee754_pow+0x32c>)
 802bfd6:	429c      	cmp	r4, r3
 802bfd8:	ddf3      	ble.n	802bfc2 <__ieee754_pow+0x1f2>
 802bfda:	4b45      	ldr	r3, [pc, #276]	; (802c0f0 <__ieee754_pow+0x320>)
 802bfdc:	429c      	cmp	r4, r3
 802bfde:	dd03      	ble.n	802bfe8 <__ieee754_pow+0x218>
 802bfe0:	f1b9 0f00 	cmp.w	r9, #0
 802bfe4:	dcf1      	bgt.n	802bfca <__ieee754_pow+0x1fa>
 802bfe6:	e75a      	b.n	802be9e <__ieee754_pow+0xce>
 802bfe8:	ed9d 7b00 	vldr	d7, [sp]
 802bfec:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
 802bff0:	ed9f 5b33 	vldr	d5, [pc, #204]	; 802c0c0 <__ieee754_pow+0x2f0>
 802bff4:	ee37 6b46 	vsub.f64	d6, d7, d6
 802bff8:	eeb5 7b00 	vmov.f64	d7, #80	; 0x3e800000  0.250
 802bffc:	eeb1 3b46 	vneg.f64	d3, d6
 802c000:	eea3 5b07 	vfma.f64	d5, d3, d7
 802c004:	eeb6 7b00 	vmov.f64	d7, #96	; 0x3f000000  0.5
 802c008:	eea5 7b46 	vfms.f64	d7, d5, d6
 802c00c:	ee26 5b06 	vmul.f64	d5, d6, d6
 802c010:	ee27 5b05 	vmul.f64	d5, d7, d5
 802c014:	ed9f 7b2c 	vldr	d7, [pc, #176]	; 802c0c8 <__ieee754_pow+0x2f8>
 802c018:	ee27 7b45 	vnmul.f64	d7, d7, d5
 802c01c:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 802c0d0 <__ieee754_pow+0x300>
 802c020:	eea6 7b05 	vfma.f64	d7, d6, d5
 802c024:	ed9f 5b2c 	vldr	d5, [pc, #176]	; 802c0d8 <__ieee754_pow+0x308>
 802c028:	eeb0 4b47 	vmov.f64	d4, d7
 802c02c:	eea6 4b05 	vfma.f64	d4, d6, d5
 802c030:	ec53 2b14 	vmov	r2, r3, d4
 802c034:	2200      	movs	r2, #0
 802c036:	ec43 2b14 	vmov	d4, r2, r3
 802c03a:	eeb0 6b44 	vmov.f64	d6, d4
 802c03e:	eea3 6b05 	vfma.f64	d6, d3, d5
 802c042:	ee37 7b46 	vsub.f64	d7, d7, d6
 802c046:	3d01      	subs	r5, #1
 802c048:	ea55 030a 	orrs.w	r3, r5, sl
 802c04c:	f04f 0200 	mov.w	r2, #0
 802c050:	463b      	mov	r3, r7
 802c052:	eebf 6b00 	vmov.f64	d6, #240	; 0xbf800000 -1.0
 802c056:	eeb7 8b00 	vmov.f64	d8, #112	; 0x3f800000  1.0
 802c05a:	ec47 6b15 	vmov	d5, r6, r7
 802c05e:	fe06 8b08 	vseleq.f64	d8, d6, d8
 802c062:	ec47 6b13 	vmov	d3, r6, r7
 802c066:	ec43 2b16 	vmov	d6, r2, r3
 802c06a:	ee27 7b03 	vmul.f64	d7, d7, d3
 802c06e:	ee35 5b46 	vsub.f64	d5, d5, d6
 802c072:	4b23      	ldr	r3, [pc, #140]	; (802c100 <__ieee754_pow+0x330>)
 802c074:	eea5 7b04 	vfma.f64	d7, d5, d4
 802c078:	ee24 6b06 	vmul.f64	d6, d4, d6
 802c07c:	ee37 5b06 	vadd.f64	d5, d7, d6
 802c080:	ee15 1a90 	vmov	r1, s11
 802c084:	4299      	cmp	r1, r3
 802c086:	ee15 2a10 	vmov	r2, s10
 802c08a:	f340 819b 	ble.w	802c3c4 <__ieee754_pow+0x5f4>
 802c08e:	f101 433f 	add.w	r3, r1, #3204448256	; 0xbf000000
 802c092:	f503 03e0 	add.w	r3, r3, #7340032	; 0x700000
 802c096:	4313      	orrs	r3, r2
 802c098:	f000 810a 	beq.w	802c2b0 <__ieee754_pow+0x4e0>
 802c09c:	ed9f 7b06 	vldr	d7, [pc, #24]	; 802c0b8 <__ieee754_pow+0x2e8>
 802c0a0:	ee28 8b07 	vmul.f64	d8, d8, d7
 802c0a4:	ee28 7b07 	vmul.f64	d7, d8, d7
 802c0a8:	e6fb      	b.n	802bea2 <__ieee754_pow+0xd2>
 802c0aa:	bf00      	nop
 802c0ac:	f3af 8000 	nop.w
	...
 802c0b8:	8800759c 	.word	0x8800759c
 802c0bc:	7e37e43c 	.word	0x7e37e43c
 802c0c0:	55555555 	.word	0x55555555
 802c0c4:	3fd55555 	.word	0x3fd55555
 802c0c8:	652b82fe 	.word	0x652b82fe
 802c0cc:	3ff71547 	.word	0x3ff71547
 802c0d0:	f85ddf44 	.word	0xf85ddf44
 802c0d4:	3e54ae0b 	.word	0x3e54ae0b
 802c0d8:	60000000 	.word	0x60000000
 802c0dc:	3ff71547 	.word	0x3ff71547
 802c0e0:	7ff00000 	.word	0x7ff00000
 802c0e4:	0804fe8c 	.word	0x0804fe8c
 802c0e8:	433fffff 	.word	0x433fffff
 802c0ec:	3fefffff 	.word	0x3fefffff
 802c0f0:	3ff00000 	.word	0x3ff00000
 802c0f4:	3fe00000 	.word	0x3fe00000
 802c0f8:	41e00000 	.word	0x41e00000
 802c0fc:	3feffffe 	.word	0x3feffffe
 802c100:	408fffff 	.word	0x408fffff
 802c104:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
 802c108:	f280 80ce 	bge.w	802c2a8 <__ieee754_pow+0x4d8>
 802c10c:	ed9d 6b00 	vldr	d6, [sp]
 802c110:	ed9f 7bc1 	vldr	d7, [pc, #772]	; 802c418 <__ieee754_pow+0x648>
 802c114:	ee26 7b07 	vmul.f64	d7, d6, d7
 802c118:	ed8d 7b00 	vstr	d7, [sp]
 802c11c:	9c01      	ldr	r4, [sp, #4]
 802c11e:	f06f 0334 	mvn.w	r3, #52	; 0x34
 802c122:	1521      	asrs	r1, r4, #20
 802c124:	f2a1 31ff 	subw	r1, r1, #1023	; 0x3ff
 802c128:	4419      	add	r1, r3
 802c12a:	4be3      	ldr	r3, [pc, #908]	; (802c4b8 <__ieee754_pow+0x6e8>)
 802c12c:	f3c4 0413 	ubfx	r4, r4, #0, #20
 802c130:	f044 507f 	orr.w	r0, r4, #1069547520	; 0x3fc00000
 802c134:	429c      	cmp	r4, r3
 802c136:	f440 1040 	orr.w	r0, r0, #3145728	; 0x300000
 802c13a:	dd06      	ble.n	802c14a <__ieee754_pow+0x37a>
 802c13c:	4bdf      	ldr	r3, [pc, #892]	; (802c4bc <__ieee754_pow+0x6ec>)
 802c13e:	429c      	cmp	r4, r3
 802c140:	f340 80b4 	ble.w	802c2ac <__ieee754_pow+0x4dc>
 802c144:	3101      	adds	r1, #1
 802c146:	f5a0 1080 	sub.w	r0, r0, #1048576	; 0x100000
 802c14a:	2400      	movs	r4, #0
 802c14c:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c150:	eeb7 4b00 	vmov.f64	d4, #112	; 0x3f800000  1.0
 802c154:	4603      	mov	r3, r0
 802c156:	ec43 2b17 	vmov	d7, r2, r3
 802c15a:	4bd9      	ldr	r3, [pc, #868]	; (802c4c0 <__ieee754_pow+0x6f0>)
 802c15c:	ea4f 0cc4 	mov.w	ip, r4, lsl #3
 802c160:	4463      	add	r3, ip
 802c162:	ed93 5b00 	vldr	d5, [r3]
 802c166:	1040      	asrs	r0, r0, #1
 802c168:	ee37 2b45 	vsub.f64	d2, d7, d5
 802c16c:	ee35 6b07 	vadd.f64	d6, d5, d7
 802c170:	ee84 1b06 	vdiv.f64	d1, d4, d6
 802c174:	ee22 6b01 	vmul.f64	d6, d2, d1
 802c178:	ed8d 6b00 	vstr	d6, [sp]
 802c17c:	e9dd 8900 	ldrd	r8, r9, [sp]
 802c180:	f040 5000 	orr.w	r0, r0, #536870912	; 0x20000000
 802c184:	f500 2000 	add.w	r0, r0, #524288	; 0x80000
 802c188:	f04f 0800 	mov.w	r8, #0
 802c18c:	eb00 4384 	add.w	r3, r0, r4, lsl #18
 802c190:	2200      	movs	r2, #0
 802c192:	ec49 8b14 	vmov	d4, r8, r9
 802c196:	ec43 2b16 	vmov	d6, r2, r3
 802c19a:	eeb1 3b44 	vneg.f64	d3, d4
 802c19e:	eea3 2b06 	vfma.f64	d2, d3, d6
 802c1a2:	ee36 6b45 	vsub.f64	d6, d6, d5
 802c1a6:	ee37 7b46 	vsub.f64	d7, d7, d6
 802c1aa:	eea3 2b07 	vfma.f64	d2, d3, d7
 802c1ae:	ed9d 7b00 	vldr	d7, [sp]
 802c1b2:	ee22 2b01 	vmul.f64	d2, d2, d1
 802c1b6:	ee27 5b07 	vmul.f64	d5, d7, d7
 802c1ba:	ee37 6b04 	vadd.f64	d6, d7, d4
 802c1be:	ed9f 1b98 	vldr	d1, [pc, #608]	; 802c420 <__ieee754_pow+0x650>
 802c1c2:	ee25 0b05 	vmul.f64	d0, d5, d5
 802c1c6:	ee26 6b02 	vmul.f64	d6, d6, d2
 802c1ca:	ed9f 7b97 	vldr	d7, [pc, #604]	; 802c428 <__ieee754_pow+0x658>
 802c1ce:	eea5 7b01 	vfma.f64	d7, d5, d1
 802c1d2:	ed9f 1b97 	vldr	d1, [pc, #604]	; 802c430 <__ieee754_pow+0x660>
 802c1d6:	eea7 1b05 	vfma.f64	d1, d7, d5
 802c1da:	ed9f 7b97 	vldr	d7, [pc, #604]	; 802c438 <__ieee754_pow+0x668>
 802c1de:	eea1 7b05 	vfma.f64	d7, d1, d5
 802c1e2:	ed9f 1b97 	vldr	d1, [pc, #604]	; 802c440 <__ieee754_pow+0x670>
 802c1e6:	eea7 1b05 	vfma.f64	d1, d7, d5
 802c1ea:	ed9f 7b97 	vldr	d7, [pc, #604]	; 802c448 <__ieee754_pow+0x678>
 802c1ee:	eea1 7b05 	vfma.f64	d7, d1, d5
 802c1f2:	eea0 6b07 	vfma.f64	d6, d0, d7
 802c1f6:	eeb0 7b08 	vmov.f64	d7, #8	; 0x40400000  3.0
 802c1fa:	eeb0 5b47 	vmov.f64	d5, d7
 802c1fe:	eea4 5b04 	vfma.f64	d5, d4, d4
 802c202:	ee35 5b06 	vadd.f64	d5, d5, d6
 802c206:	ed8d 5b02 	vstr	d5, [sp, #8]
 802c20a:	f8cd 8008 	str.w	r8, [sp, #8]
 802c20e:	ed9d 5b02 	vldr	d5, [sp, #8]
 802c212:	ee35 7b47 	vsub.f64	d7, d5, d7
 802c216:	eea3 7b04 	vfma.f64	d7, d3, d4
 802c21a:	ee36 7b47 	vsub.f64	d7, d6, d7
 802c21e:	ed9d 6b00 	vldr	d6, [sp]
 802c222:	ee27 7b06 	vmul.f64	d7, d7, d6
 802c226:	eea2 7b05 	vfma.f64	d7, d2, d5
 802c22a:	eeb0 6b47 	vmov.f64	d6, d7
 802c22e:	eea4 6b05 	vfma.f64	d6, d4, d5
 802c232:	ed8d 6b00 	vstr	d6, [sp]
 802c236:	f8cd 8000 	str.w	r8, [sp]
 802c23a:	ed9d 2b00 	vldr	d2, [sp]
 802c23e:	eeb0 6b42 	vmov.f64	d6, d2
 802c242:	eea3 6b05 	vfma.f64	d6, d3, d5
 802c246:	ee37 7b46 	vsub.f64	d7, d7, d6
 802c24a:	ed9f 6b81 	vldr	d6, [pc, #516]	; 802c450 <__ieee754_pow+0x680>
 802c24e:	4b9d      	ldr	r3, [pc, #628]	; (802c4c4 <__ieee754_pow+0x6f4>)
 802c250:	ee27 7b06 	vmul.f64	d7, d7, d6
 802c254:	ed9f 6b80 	vldr	d6, [pc, #512]	; 802c458 <__ieee754_pow+0x688>
 802c258:	4463      	add	r3, ip
 802c25a:	eea2 7b06 	vfma.f64	d7, d2, d6
 802c25e:	ed93 6b00 	vldr	d6, [r3]
 802c262:	4b99      	ldr	r3, [pc, #612]	; (802c4c8 <__ieee754_pow+0x6f8>)
 802c264:	ee37 6b06 	vadd.f64	d6, d7, d6
 802c268:	449c      	add	ip, r3
 802c26a:	ed9c 1b00 	vldr	d1, [ip]
 802c26e:	eeb0 4b46 	vmov.f64	d4, d6
 802c272:	ed9f 3b7b 	vldr	d3, [pc, #492]	; 802c460 <__ieee754_pow+0x690>
 802c276:	ee07 1a90 	vmov	s15, r1
 802c27a:	eea2 4b03 	vfma.f64	d4, d2, d3
 802c27e:	eeb8 7be7 	vcvt.f64.s32	d7, s15
 802c282:	ee34 4b01 	vadd.f64	d4, d4, d1
 802c286:	ee34 5b07 	vadd.f64	d5, d4, d7
 802c28a:	ed8d 5b00 	vstr	d5, [sp]
 802c28e:	f8cd 8000 	str.w	r8, [sp]
 802c292:	ed9d 4b00 	vldr	d4, [sp]
 802c296:	ee34 7b47 	vsub.f64	d7, d4, d7
 802c29a:	ee37 7b41 	vsub.f64	d7, d7, d1
 802c29e:	eea2 7b43 	vfms.f64	d7, d2, d3
 802c2a2:	ee36 7b47 	vsub.f64	d7, d6, d7
 802c2a6:	e6ce      	b.n	802c046 <__ieee754_pow+0x276>
 802c2a8:	2300      	movs	r3, #0
 802c2aa:	e73a      	b.n	802c122 <__ieee754_pow+0x352>
 802c2ac:	2401      	movs	r4, #1
 802c2ae:	e74d      	b.n	802c14c <__ieee754_pow+0x37c>
 802c2b0:	ed9f 4b6d 	vldr	d4, [pc, #436]	; 802c468 <__ieee754_pow+0x698>
 802c2b4:	ee35 5b46 	vsub.f64	d5, d5, d6
 802c2b8:	ee37 4b04 	vadd.f64	d4, d7, d4
 802c2bc:	eeb4 4bc5 	vcmpe.f64	d4, d5
 802c2c0:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c2c4:	f73f aeea 	bgt.w	802c09c <__ieee754_pow+0x2cc>
 802c2c8:	4a80      	ldr	r2, [pc, #512]	; (802c4cc <__ieee754_pow+0x6fc>)
 802c2ca:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 802c2ce:	4293      	cmp	r3, r2
 802c2d0:	f340 808e 	ble.w	802c3f0 <__ieee754_pow+0x620>
 802c2d4:	151b      	asrs	r3, r3, #20
 802c2d6:	f2a3 30fe 	subw	r0, r3, #1022	; 0x3fe
 802c2da:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 802c2de:	4103      	asrs	r3, r0
 802c2e0:	440b      	add	r3, r1
 802c2e2:	f3c3 520a 	ubfx	r2, r3, #20, #11
 802c2e6:	487a      	ldr	r0, [pc, #488]	; (802c4d0 <__ieee754_pow+0x700>)
 802c2e8:	f2a2 32ff 	subw	r2, r2, #1023	; 0x3ff
 802c2ec:	4110      	asrs	r0, r2
 802c2ee:	ea23 0500 	bic.w	r5, r3, r0
 802c2f2:	f3c3 0013 	ubfx	r0, r3, #0, #20
 802c2f6:	2400      	movs	r4, #0
 802c2f8:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
 802c2fc:	f1c2 0214 	rsb	r2, r2, #20
 802c300:	ec45 4b15 	vmov	d5, r4, r5
 802c304:	4110      	asrs	r0, r2
 802c306:	2900      	cmp	r1, #0
 802c308:	bfb8      	it	lt
 802c30a:	4240      	neglt	r0, r0
 802c30c:	ee36 6b45 	vsub.f64	d6, d6, d5
 802c310:	ee36 5b07 	vadd.f64	d5, d6, d7
 802c314:	ec53 2b15 	vmov	r2, r3, d5
 802c318:	2200      	movs	r2, #0
 802c31a:	ec43 2b15 	vmov	d5, r2, r3
 802c31e:	ed9f 4b54 	vldr	d4, [pc, #336]	; 802c470 <__ieee754_pow+0x6a0>
 802c322:	ee35 6b46 	vsub.f64	d6, d5, d6
 802c326:	ee37 6b46 	vsub.f64	d6, d7, d6
 802c32a:	ed9f 7b53 	vldr	d7, [pc, #332]	; 802c478 <__ieee754_pow+0x6a8>
 802c32e:	ee25 7b07 	vmul.f64	d7, d5, d7
 802c332:	eea6 7b04 	vfma.f64	d7, d6, d4
 802c336:	ed9f 6b52 	vldr	d6, [pc, #328]	; 802c480 <__ieee754_pow+0x6b0>
 802c33a:	eeb0 4b47 	vmov.f64	d4, d7
 802c33e:	eea5 4b06 	vfma.f64	d4, d5, d6
 802c342:	eeb0 3b44 	vmov.f64	d3, d4
 802c346:	eea5 3b46 	vfms.f64	d3, d5, d6
 802c34a:	ed9f 5b4f 	vldr	d5, [pc, #316]	; 802c488 <__ieee754_pow+0x6b8>
 802c34e:	ee37 7b43 	vsub.f64	d7, d7, d3
 802c352:	ee24 6b04 	vmul.f64	d6, d4, d4
 802c356:	ed9f 3b4e 	vldr	d3, [pc, #312]	; 802c490 <__ieee754_pow+0x6c0>
 802c35a:	eea4 7b07 	vfma.f64	d7, d4, d7
 802c35e:	eea6 3b05 	vfma.f64	d3, d6, d5
 802c362:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 802c498 <__ieee754_pow+0x6c8>
 802c366:	eea3 5b06 	vfma.f64	d5, d3, d6
 802c36a:	ed9f 3b4d 	vldr	d3, [pc, #308]	; 802c4a0 <__ieee754_pow+0x6d0>
 802c36e:	eea5 3b06 	vfma.f64	d3, d5, d6
 802c372:	ed9f 5b4d 	vldr	d5, [pc, #308]	; 802c4a8 <__ieee754_pow+0x6d8>
 802c376:	eea3 5b06 	vfma.f64	d5, d3, d6
 802c37a:	eeb0 3b44 	vmov.f64	d3, d4
 802c37e:	eea5 3b46 	vfms.f64	d3, d5, d6
 802c382:	eeb0 5b00 	vmov.f64	d5, #0	; 0x40000000  2.0
 802c386:	eeb0 6b43 	vmov.f64	d6, d3
 802c38a:	ee24 3b03 	vmul.f64	d3, d4, d3
 802c38e:	ee36 5b45 	vsub.f64	d5, d6, d5
 802c392:	ee83 6b05 	vdiv.f64	d6, d3, d5
 802c396:	ee36 7b47 	vsub.f64	d7, d6, d7
 802c39a:	eeb7 6b00 	vmov.f64	d6, #112	; 0x3f800000  1.0
 802c39e:	ee37 7b44 	vsub.f64	d7, d7, d4
 802c3a2:	ee36 7b47 	vsub.f64	d7, d6, d7
 802c3a6:	ed8d 7b00 	vstr	d7, [sp]
 802c3aa:	9901      	ldr	r1, [sp, #4]
 802c3ac:	eb01 5100 	add.w	r1, r1, r0, lsl #20
 802c3b0:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 802c3b4:	da1e      	bge.n	802c3f4 <__ieee754_pow+0x624>
 802c3b6:	eeb0 0b47 	vmov.f64	d0, d7
 802c3ba:	f001 f809 	bl	802d3d0 <scalbn>
 802c3be:	ee20 7b08 	vmul.f64	d7, d0, d8
 802c3c2:	e56e      	b.n	802bea2 <__ieee754_pow+0xd2>
 802c3c4:	4b43      	ldr	r3, [pc, #268]	; (802c4d4 <__ieee754_pow+0x704>)
 802c3c6:	f021 4000 	bic.w	r0, r1, #2147483648	; 0x80000000
 802c3ca:	4298      	cmp	r0, r3
 802c3cc:	f77f af7c 	ble.w	802c2c8 <__ieee754_pow+0x4f8>
 802c3d0:	4b41      	ldr	r3, [pc, #260]	; (802c4d8 <__ieee754_pow+0x708>)
 802c3d2:	440b      	add	r3, r1
 802c3d4:	4313      	orrs	r3, r2
 802c3d6:	d002      	beq.n	802c3de <__ieee754_pow+0x60e>
 802c3d8:	ed9f 7b35 	vldr	d7, [pc, #212]	; 802c4b0 <__ieee754_pow+0x6e0>
 802c3dc:	e660      	b.n	802c0a0 <__ieee754_pow+0x2d0>
 802c3de:	ee35 5b46 	vsub.f64	d5, d5, d6
 802c3e2:	eeb4 5bc7 	vcmpe.f64	d5, d7
 802c3e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c3ea:	f6ff af6d 	blt.w	802c2c8 <__ieee754_pow+0x4f8>
 802c3ee:	e7f3      	b.n	802c3d8 <__ieee754_pow+0x608>
 802c3f0:	2000      	movs	r0, #0
 802c3f2:	e78d      	b.n	802c310 <__ieee754_pow+0x540>
 802c3f4:	e9dd 2300 	ldrd	r2, r3, [sp]
 802c3f8:	460b      	mov	r3, r1
 802c3fa:	ec43 2b10 	vmov	d0, r2, r3
 802c3fe:	e7de      	b.n	802c3be <__ieee754_pow+0x5ee>
 802c400:	eeb7 7b00 	vmov.f64	d7, #112	; 0x3f800000  1.0
 802c404:	e54d      	b.n	802bea2 <__ieee754_pow+0xd2>
 802c406:	e9cd 6700 	strd	r6, r7, [sp]
 802c40a:	e574      	b.n	802bef6 <__ieee754_pow+0x126>
 802c40c:	ed8d 8b00 	vstr	d8, [sp]
 802c410:	e571      	b.n	802bef6 <__ieee754_pow+0x126>
 802c412:	4615      	mov	r5, r2
 802c414:	e557      	b.n	802bec6 <__ieee754_pow+0xf6>
 802c416:	bf00      	nop
 802c418:	00000000 	.word	0x00000000
 802c41c:	43400000 	.word	0x43400000
 802c420:	4a454eef 	.word	0x4a454eef
 802c424:	3fca7e28 	.word	0x3fca7e28
 802c428:	93c9db65 	.word	0x93c9db65
 802c42c:	3fcd864a 	.word	0x3fcd864a
 802c430:	a91d4101 	.word	0xa91d4101
 802c434:	3fd17460 	.word	0x3fd17460
 802c438:	518f264d 	.word	0x518f264d
 802c43c:	3fd55555 	.word	0x3fd55555
 802c440:	db6fabff 	.word	0xdb6fabff
 802c444:	3fdb6db6 	.word	0x3fdb6db6
 802c448:	33333303 	.word	0x33333303
 802c44c:	3fe33333 	.word	0x3fe33333
 802c450:	dc3a03fd 	.word	0xdc3a03fd
 802c454:	3feec709 	.word	0x3feec709
 802c458:	145b01f5 	.word	0x145b01f5
 802c45c:	be3e2fe0 	.word	0xbe3e2fe0
 802c460:	e0000000 	.word	0xe0000000
 802c464:	3feec709 	.word	0x3feec709
 802c468:	652b82fe 	.word	0x652b82fe
 802c46c:	3c971547 	.word	0x3c971547
 802c470:	fefa39ef 	.word	0xfefa39ef
 802c474:	3fe62e42 	.word	0x3fe62e42
 802c478:	0ca86c39 	.word	0x0ca86c39
 802c47c:	be205c61 	.word	0xbe205c61
 802c480:	00000000 	.word	0x00000000
 802c484:	3fe62e43 	.word	0x3fe62e43
 802c488:	72bea4d0 	.word	0x72bea4d0
 802c48c:	3e663769 	.word	0x3e663769
 802c490:	c5d26bf1 	.word	0xc5d26bf1
 802c494:	bebbbd41 	.word	0xbebbbd41
 802c498:	af25de2c 	.word	0xaf25de2c
 802c49c:	3f11566a 	.word	0x3f11566a
 802c4a0:	16bebd93 	.word	0x16bebd93
 802c4a4:	bf66c16c 	.word	0xbf66c16c
 802c4a8:	5555553e 	.word	0x5555553e
 802c4ac:	3fc55555 	.word	0x3fc55555
 802c4b0:	c2f8f359 	.word	0xc2f8f359
 802c4b4:	01a56e1f 	.word	0x01a56e1f
 802c4b8:	0003988e 	.word	0x0003988e
 802c4bc:	000bb679 	.word	0x000bb679
 802c4c0:	0804fec8 	.word	0x0804fec8
 802c4c4:	0804fee8 	.word	0x0804fee8
 802c4c8:	0804fed8 	.word	0x0804fed8
 802c4cc:	3fe00000 	.word	0x3fe00000
 802c4d0:	000fffff 	.word	0x000fffff
 802c4d4:	4090cbff 	.word	0x4090cbff
 802c4d8:	3f6f3400 	.word	0x3f6f3400

0802c4dc <__ieee754_sqrt>:
 802c4dc:	eeb1 0bc0 	vsqrt.f64	d0, d0
 802c4e0:	4770      	bx	lr
	...

0802c4e4 <__ieee754_fmodf>:
 802c4e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c4e6:	ee10 6a90 	vmov	r6, s1
 802c4ea:	f036 4500 	bics.w	r5, r6, #2147483648	; 0x80000000
 802c4ee:	ee10 3a10 	vmov	r3, s0
 802c4f2:	d009      	beq.n	802c508 <__ieee754_fmodf+0x24>
 802c4f4:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802c4f8:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802c4fc:	ee10 7a10 	vmov	r7, s0
 802c500:	da02      	bge.n	802c508 <__ieee754_fmodf+0x24>
 802c502:	f1b5 4fff 	cmp.w	r5, #2139095040	; 0x7f800000
 802c506:	dd0a      	ble.n	802c51e <__ieee754_fmodf+0x3a>
 802c508:	ee07 3a90 	vmov	s15, r3
 802c50c:	ee67 0aa0 	vmul.f32	s1, s15, s1
 802c510:	eec0 7aa0 	vdiv.f32	s15, s1, s1
 802c514:	ee17 3a90 	vmov	r3, s15
 802c518:	ee00 3a10 	vmov	s0, r3
 802c51c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c51e:	42a9      	cmp	r1, r5
 802c520:	dbfa      	blt.n	802c518 <__ieee754_fmodf+0x34>
 802c522:	f003 4400 	and.w	r4, r3, #2147483648	; 0x80000000
 802c526:	d105      	bne.n	802c534 <__ieee754_fmodf+0x50>
 802c528:	4a30      	ldr	r2, [pc, #192]	; (802c5ec <__ieee754_fmodf+0x108>)
 802c52a:	0fe3      	lsrs	r3, r4, #31
 802c52c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 802c530:	681b      	ldr	r3, [r3, #0]
 802c532:	e7f1      	b.n	802c518 <__ieee754_fmodf+0x34>
 802c534:	4b2e      	ldr	r3, [pc, #184]	; (802c5f0 <__ieee754_fmodf+0x10c>)
 802c536:	4299      	cmp	r1, r3
 802c538:	dc3e      	bgt.n	802c5b8 <__ieee754_fmodf+0xd4>
 802c53a:	020a      	lsls	r2, r1, #8
 802c53c:	f06f 007d 	mvn.w	r0, #125	; 0x7d
 802c540:	2a00      	cmp	r2, #0
 802c542:	dc36      	bgt.n	802c5b2 <__ieee754_fmodf+0xce>
 802c544:	429d      	cmp	r5, r3
 802c546:	dc3a      	bgt.n	802c5be <__ieee754_fmodf+0xda>
 802c548:	022b      	lsls	r3, r5, #8
 802c54a:	f06f 027d 	mvn.w	r2, #125	; 0x7d
 802c54e:	005b      	lsls	r3, r3, #1
 802c550:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
 802c554:	d5fb      	bpl.n	802c54e <__ieee754_fmodf+0x6a>
 802c556:	f110 0f7e 	cmn.w	r0, #126	; 0x7e
 802c55a:	bfbb      	ittet	lt
 802c55c:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
 802c560:	1a1b      	sublt	r3, r3, r0
 802c562:	f3c7 0116 	ubfxge	r1, r7, #0, #23
 802c566:	4099      	lsllt	r1, r3
 802c568:	bfa8      	it	ge
 802c56a:	f441 0100 	orrge.w	r1, r1, #8388608	; 0x800000
 802c56e:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 802c572:	bfb5      	itete	lt
 802c574:	f06f 037d 	mvnlt.w	r3, #125	; 0x7d
 802c578:	f3c6 0516 	ubfxge	r5, r6, #0, #23
 802c57c:	1a9b      	sublt	r3, r3, r2
 802c57e:	f445 0500 	orrge.w	r5, r5, #8388608	; 0x800000
 802c582:	bfb8      	it	lt
 802c584:	409d      	lsllt	r5, r3
 802c586:	1a80      	subs	r0, r0, r2
 802c588:	1b4b      	subs	r3, r1, r5
 802c58a:	b9d8      	cbnz	r0, 802c5c4 <__ieee754_fmodf+0xe0>
 802c58c:	ea33 0323 	bics.w	r3, r3, r3, asr #32
 802c590:	bf28      	it	cs
 802c592:	460b      	movcs	r3, r1
 802c594:	2b00      	cmp	r3, #0
 802c596:	d0c7      	beq.n	802c528 <__ieee754_fmodf+0x44>
 802c598:	4915      	ldr	r1, [pc, #84]	; (802c5f0 <__ieee754_fmodf+0x10c>)
 802c59a:	428b      	cmp	r3, r1
 802c59c:	dd1a      	ble.n	802c5d4 <__ieee754_fmodf+0xf0>
 802c59e:	f112 0f7e 	cmn.w	r2, #126	; 0x7e
 802c5a2:	db1a      	blt.n	802c5da <__ieee754_fmodf+0xf6>
 802c5a4:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 802c5a8:	4323      	orrs	r3, r4
 802c5aa:	327f      	adds	r2, #127	; 0x7f
 802c5ac:	ea43 53c2 	orr.w	r3, r3, r2, lsl #23
 802c5b0:	e7b2      	b.n	802c518 <__ieee754_fmodf+0x34>
 802c5b2:	3801      	subs	r0, #1
 802c5b4:	0052      	lsls	r2, r2, #1
 802c5b6:	e7c3      	b.n	802c540 <__ieee754_fmodf+0x5c>
 802c5b8:	15c8      	asrs	r0, r1, #23
 802c5ba:	387f      	subs	r0, #127	; 0x7f
 802c5bc:	e7c2      	b.n	802c544 <__ieee754_fmodf+0x60>
 802c5be:	15ea      	asrs	r2, r5, #23
 802c5c0:	3a7f      	subs	r2, #127	; 0x7f
 802c5c2:	e7c8      	b.n	802c556 <__ieee754_fmodf+0x72>
 802c5c4:	2b00      	cmp	r3, #0
 802c5c6:	da02      	bge.n	802c5ce <__ieee754_fmodf+0xea>
 802c5c8:	0049      	lsls	r1, r1, #1
 802c5ca:	3801      	subs	r0, #1
 802c5cc:	e7dc      	b.n	802c588 <__ieee754_fmodf+0xa4>
 802c5ce:	d0ab      	beq.n	802c528 <__ieee754_fmodf+0x44>
 802c5d0:	0059      	lsls	r1, r3, #1
 802c5d2:	e7fa      	b.n	802c5ca <__ieee754_fmodf+0xe6>
 802c5d4:	005b      	lsls	r3, r3, #1
 802c5d6:	3a01      	subs	r2, #1
 802c5d8:	e7df      	b.n	802c59a <__ieee754_fmodf+0xb6>
 802c5da:	f1c2 22ff 	rsb	r2, r2, #4278255360	; 0xff00ff00
 802c5de:	f502 027f 	add.w	r2, r2, #16711680	; 0xff0000
 802c5e2:	3282      	adds	r2, #130	; 0x82
 802c5e4:	4113      	asrs	r3, r2
 802c5e6:	4323      	orrs	r3, r4
 802c5e8:	e796      	b.n	802c518 <__ieee754_fmodf+0x34>
 802c5ea:	bf00      	nop
 802c5ec:	0804fef8 	.word	0x0804fef8
 802c5f0:	007fffff 	.word	0x007fffff

0802c5f4 <__ieee754_log10f>:
 802c5f4:	b508      	push	{r3, lr}
 802c5f6:	ee10 2a10 	vmov	r2, s0
 802c5fa:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 802c5fe:	ed2d 8b02 	vpush	{d8}
 802c602:	d108      	bne.n	802c616 <__ieee754_log10f+0x22>
 802c604:	ed9f 7a20 	vldr	s14, [pc, #128]	; 802c688 <__ieee754_log10f+0x94>
 802c608:	eddf 7a20 	vldr	s15, [pc, #128]	; 802c68c <__ieee754_log10f+0x98>
 802c60c:	ee87 0a27 	vdiv.f32	s0, s14, s15
 802c610:	ecbd 8b02 	vpop	{d8}
 802c614:	bd08      	pop	{r3, pc}
 802c616:	2a00      	cmp	r2, #0
 802c618:	da02      	bge.n	802c620 <__ieee754_log10f+0x2c>
 802c61a:	ee30 7a40 	vsub.f32	s14, s0, s0
 802c61e:	e7f3      	b.n	802c608 <__ieee754_log10f+0x14>
 802c620:	f1b2 4fff 	cmp.w	r2, #2139095040	; 0x7f800000
 802c624:	db02      	blt.n	802c62c <__ieee754_log10f+0x38>
 802c626:	ee30 0a00 	vadd.f32	s0, s0, s0
 802c62a:	e7f1      	b.n	802c610 <__ieee754_log10f+0x1c>
 802c62c:	f5b2 0f00 	cmp.w	r2, #8388608	; 0x800000
 802c630:	bfbf      	itttt	lt
 802c632:	eddf 7a17 	vldrlt	s15, [pc, #92]	; 802c690 <__ieee754_log10f+0x9c>
 802c636:	ee60 7a27 	vmullt.f32	s15, s0, s15
 802c63a:	f06f 0118 	mvnlt.w	r1, #24
 802c63e:	ee17 2a90 	vmovlt	r2, s15
 802c642:	ea4f 53e2 	mov.w	r3, r2, asr #23
 802c646:	bfa8      	it	ge
 802c648:	2100      	movge	r1, #0
 802c64a:	3b7f      	subs	r3, #127	; 0x7f
 802c64c:	440b      	add	r3, r1
 802c64e:	0fd9      	lsrs	r1, r3, #31
 802c650:	440b      	add	r3, r1
 802c652:	f3c2 0216 	ubfx	r2, r2, #0, #23
 802c656:	f1c1 017f 	rsb	r1, r1, #127	; 0x7f
 802c65a:	ee07 3a90 	vmov	s15, r3
 802c65e:	ea42 53c1 	orr.w	r3, r2, r1, lsl #23
 802c662:	ee00 3a10 	vmov	s0, r3
 802c666:	eeb8 8ae7 	vcvt.f32.s32	s16, s15
 802c66a:	f7fe fd2d 	bl	802b0c8 <logf>
 802c66e:	eddf 7a09 	vldr	s15, [pc, #36]	; 802c694 <__ieee754_log10f+0xa0>
 802c672:	ee20 0a27 	vmul.f32	s0, s0, s15
 802c676:	eddf 7a08 	vldr	s15, [pc, #32]	; 802c698 <__ieee754_log10f+0xa4>
 802c67a:	eea8 0a27 	vfma.f32	s0, s16, s15
 802c67e:	eddf 7a07 	vldr	s15, [pc, #28]	; 802c69c <__ieee754_log10f+0xa8>
 802c682:	eea8 0a27 	vfma.f32	s0, s16, s15
 802c686:	e7c3      	b.n	802c610 <__ieee754_log10f+0x1c>
 802c688:	cc000000 	.word	0xcc000000
 802c68c:	00000000 	.word	0x00000000
 802c690:	4c000000 	.word	0x4c000000
 802c694:	3ede5bd9 	.word	0x3ede5bd9
 802c698:	355427db 	.word	0x355427db
 802c69c:	3e9a2080 	.word	0x3e9a2080

0802c6a0 <__ieee754_rem_pio2f>:
 802c6a0:	b5f0      	push	{r4, r5, r6, r7, lr}
 802c6a2:	ee10 6a10 	vmov	r6, s0
 802c6a6:	4b86      	ldr	r3, [pc, #536]	; (802c8c0 <__ieee754_rem_pio2f+0x220>)
 802c6a8:	f026 4400 	bic.w	r4, r6, #2147483648	; 0x80000000
 802c6ac:	429c      	cmp	r4, r3
 802c6ae:	b087      	sub	sp, #28
 802c6b0:	4605      	mov	r5, r0
 802c6b2:	dc05      	bgt.n	802c6c0 <__ieee754_rem_pio2f+0x20>
 802c6b4:	2300      	movs	r3, #0
 802c6b6:	ed85 0a00 	vstr	s0, [r5]
 802c6ba:	6043      	str	r3, [r0, #4]
 802c6bc:	2000      	movs	r0, #0
 802c6be:	e020      	b.n	802c702 <__ieee754_rem_pio2f+0x62>
 802c6c0:	4b80      	ldr	r3, [pc, #512]	; (802c8c4 <__ieee754_rem_pio2f+0x224>)
 802c6c2:	429c      	cmp	r4, r3
 802c6c4:	dc38      	bgt.n	802c738 <__ieee754_rem_pio2f+0x98>
 802c6c6:	2e00      	cmp	r6, #0
 802c6c8:	f024 040f 	bic.w	r4, r4, #15
 802c6cc:	ed9f 7a7e 	vldr	s14, [pc, #504]	; 802c8c8 <__ieee754_rem_pio2f+0x228>
 802c6d0:	4b7e      	ldr	r3, [pc, #504]	; (802c8cc <__ieee754_rem_pio2f+0x22c>)
 802c6d2:	dd18      	ble.n	802c706 <__ieee754_rem_pio2f+0x66>
 802c6d4:	429c      	cmp	r4, r3
 802c6d6:	ee70 7a47 	vsub.f32	s15, s0, s14
 802c6da:	bf09      	itett	eq
 802c6dc:	ed9f 7a7c 	vldreq	s14, [pc, #496]	; 802c8d0 <__ieee754_rem_pio2f+0x230>
 802c6e0:	ed9f 7a7c 	vldrne	s14, [pc, #496]	; 802c8d4 <__ieee754_rem_pio2f+0x234>
 802c6e4:	ee77 7ac7 	vsubeq.f32	s15, s15, s14
 802c6e8:	ed9f 7a7b 	vldreq	s14, [pc, #492]	; 802c8d8 <__ieee754_rem_pio2f+0x238>
 802c6ec:	ee77 6ac7 	vsub.f32	s13, s15, s14
 802c6f0:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c6f4:	edc0 6a00 	vstr	s13, [r0]
 802c6f8:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c6fc:	edc0 7a01 	vstr	s15, [r0, #4]
 802c700:	2001      	movs	r0, #1
 802c702:	b007      	add	sp, #28
 802c704:	bdf0      	pop	{r4, r5, r6, r7, pc}
 802c706:	429c      	cmp	r4, r3
 802c708:	ee70 7a07 	vadd.f32	s15, s0, s14
 802c70c:	bf09      	itett	eq
 802c70e:	ed9f 7a70 	vldreq	s14, [pc, #448]	; 802c8d0 <__ieee754_rem_pio2f+0x230>
 802c712:	ed9f 7a70 	vldrne	s14, [pc, #448]	; 802c8d4 <__ieee754_rem_pio2f+0x234>
 802c716:	ee77 7a87 	vaddeq.f32	s15, s15, s14
 802c71a:	ed9f 7a6f 	vldreq	s14, [pc, #444]	; 802c8d8 <__ieee754_rem_pio2f+0x238>
 802c71e:	ee77 6a87 	vadd.f32	s13, s15, s14
 802c722:	ee77 7ae6 	vsub.f32	s15, s15, s13
 802c726:	edc0 6a00 	vstr	s13, [r0]
 802c72a:	ee77 7a87 	vadd.f32	s15, s15, s14
 802c72e:	edc0 7a01 	vstr	s15, [r0, #4]
 802c732:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 802c736:	e7e4      	b.n	802c702 <__ieee754_rem_pio2f+0x62>
 802c738:	4b68      	ldr	r3, [pc, #416]	; (802c8dc <__ieee754_rem_pio2f+0x23c>)
 802c73a:	429c      	cmp	r4, r3
 802c73c:	dc71      	bgt.n	802c822 <__ieee754_rem_pio2f+0x182>
 802c73e:	f7fe fcbb 	bl	802b0b8 <fabsf>
 802c742:	ed9f 7a67 	vldr	s14, [pc, #412]	; 802c8e0 <__ieee754_rem_pio2f+0x240>
 802c746:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802c74a:	eee0 7a07 	vfma.f32	s15, s0, s14
 802c74e:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802c752:	eeb8 6ae7 	vcvt.f32.s32	s12, s15
 802c756:	ee17 0a90 	vmov	r0, s15
 802c75a:	eddf 7a5b 	vldr	s15, [pc, #364]	; 802c8c8 <__ieee754_rem_pio2f+0x228>
 802c75e:	eeb1 7a46 	vneg.f32	s14, s12
 802c762:	eea7 0a27 	vfma.f32	s0, s14, s15
 802c766:	281f      	cmp	r0, #31
 802c768:	eddf 7a5a 	vldr	s15, [pc, #360]	; 802c8d4 <__ieee754_rem_pio2f+0x234>
 802c76c:	ee66 7a27 	vmul.f32	s15, s12, s15
 802c770:	ee70 6a67 	vsub.f32	s13, s0, s15
 802c774:	ee16 3a90 	vmov	r3, s13
 802c778:	dc1c      	bgt.n	802c7b4 <__ieee754_rem_pio2f+0x114>
 802c77a:	1e47      	subs	r7, r0, #1
 802c77c:	4959      	ldr	r1, [pc, #356]	; (802c8e4 <__ieee754_rem_pio2f+0x244>)
 802c77e:	f851 1027 	ldr.w	r1, [r1, r7, lsl #2]
 802c782:	f024 02ff 	bic.w	r2, r4, #255	; 0xff
 802c786:	428a      	cmp	r2, r1
 802c788:	d014      	beq.n	802c7b4 <__ieee754_rem_pio2f+0x114>
 802c78a:	602b      	str	r3, [r5, #0]
 802c78c:	ed95 7a00 	vldr	s14, [r5]
 802c790:	ee30 0a47 	vsub.f32	s0, s0, s14
 802c794:	2e00      	cmp	r6, #0
 802c796:	ee30 0a67 	vsub.f32	s0, s0, s15
 802c79a:	ed85 0a01 	vstr	s0, [r5, #4]
 802c79e:	dab0      	bge.n	802c702 <__ieee754_rem_pio2f+0x62>
 802c7a0:	eeb1 7a47 	vneg.f32	s14, s14
 802c7a4:	eeb1 0a40 	vneg.f32	s0, s0
 802c7a8:	ed85 7a00 	vstr	s14, [r5]
 802c7ac:	ed85 0a01 	vstr	s0, [r5, #4]
 802c7b0:	4240      	negs	r0, r0
 802c7b2:	e7a6      	b.n	802c702 <__ieee754_rem_pio2f+0x62>
 802c7b4:	15e4      	asrs	r4, r4, #23
 802c7b6:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802c7ba:	1aa2      	subs	r2, r4, r2
 802c7bc:	2a08      	cmp	r2, #8
 802c7be:	dde4      	ble.n	802c78a <__ieee754_rem_pio2f+0xea>
 802c7c0:	eddf 7a43 	vldr	s15, [pc, #268]	; 802c8d0 <__ieee754_rem_pio2f+0x230>
 802c7c4:	eef0 6a40 	vmov.f32	s13, s0
 802c7c8:	eee7 6a27 	vfma.f32	s13, s14, s15
 802c7cc:	ee30 0a66 	vsub.f32	s0, s0, s13
 802c7d0:	eea7 0a27 	vfma.f32	s0, s14, s15
 802c7d4:	eddf 7a40 	vldr	s15, [pc, #256]	; 802c8d8 <__ieee754_rem_pio2f+0x238>
 802c7d8:	ee96 0a27 	vfnms.f32	s0, s12, s15
 802c7dc:	ee76 5ac0 	vsub.f32	s11, s13, s0
 802c7e0:	eef0 7a40 	vmov.f32	s15, s0
 802c7e4:	ee15 3a90 	vmov	r3, s11
 802c7e8:	f3c3 52c7 	ubfx	r2, r3, #23, #8
 802c7ec:	1aa4      	subs	r4, r4, r2
 802c7ee:	2c19      	cmp	r4, #25
 802c7f0:	dc04      	bgt.n	802c7fc <__ieee754_rem_pio2f+0x15c>
 802c7f2:	edc5 5a00 	vstr	s11, [r5]
 802c7f6:	eeb0 0a66 	vmov.f32	s0, s13
 802c7fa:	e7c7      	b.n	802c78c <__ieee754_rem_pio2f+0xec>
 802c7fc:	eddf 5a3a 	vldr	s11, [pc, #232]	; 802c8e8 <__ieee754_rem_pio2f+0x248>
 802c800:	eeb0 0a66 	vmov.f32	s0, s13
 802c804:	eea7 0a25 	vfma.f32	s0, s14, s11
 802c808:	ee76 7ac0 	vsub.f32	s15, s13, s0
 802c80c:	eee7 7a25 	vfma.f32	s15, s14, s11
 802c810:	ed9f 7a36 	vldr	s14, [pc, #216]	; 802c8ec <__ieee754_rem_pio2f+0x24c>
 802c814:	eed6 7a07 	vfnms.f32	s15, s12, s14
 802c818:	ee30 7a67 	vsub.f32	s14, s0, s15
 802c81c:	ed85 7a00 	vstr	s14, [r5]
 802c820:	e7b4      	b.n	802c78c <__ieee754_rem_pio2f+0xec>
 802c822:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802c826:	db06      	blt.n	802c836 <__ieee754_rem_pio2f+0x196>
 802c828:	ee70 7a40 	vsub.f32	s15, s0, s0
 802c82c:	edc0 7a01 	vstr	s15, [r0, #4]
 802c830:	edc0 7a00 	vstr	s15, [r0]
 802c834:	e742      	b.n	802c6bc <__ieee754_rem_pio2f+0x1c>
 802c836:	15e2      	asrs	r2, r4, #23
 802c838:	3a86      	subs	r2, #134	; 0x86
 802c83a:	eba4 53c2 	sub.w	r3, r4, r2, lsl #23
 802c83e:	ee07 3a90 	vmov	s15, r3
 802c842:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802c846:	eddf 6a2a 	vldr	s13, [pc, #168]	; 802c8f0 <__ieee754_rem_pio2f+0x250>
 802c84a:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802c84e:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c852:	ed8d 7a03 	vstr	s14, [sp, #12]
 802c856:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802c85a:	eebd 7ae7 	vcvt.s32.f32	s14, s15
 802c85e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802c862:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802c866:	ed8d 7a04 	vstr	s14, [sp, #16]
 802c86a:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802c86e:	eef5 7a40 	vcmp.f32	s15, #0.0
 802c872:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c876:	edcd 7a05 	vstr	s15, [sp, #20]
 802c87a:	d11e      	bne.n	802c8ba <__ieee754_rem_pio2f+0x21a>
 802c87c:	eeb5 7a40 	vcmp.f32	s14, #0.0
 802c880:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c884:	bf0c      	ite	eq
 802c886:	2301      	moveq	r3, #1
 802c888:	2302      	movne	r3, #2
 802c88a:	491a      	ldr	r1, [pc, #104]	; (802c8f4 <__ieee754_rem_pio2f+0x254>)
 802c88c:	9101      	str	r1, [sp, #4]
 802c88e:	2102      	movs	r1, #2
 802c890:	9100      	str	r1, [sp, #0]
 802c892:	a803      	add	r0, sp, #12
 802c894:	4629      	mov	r1, r5
 802c896:	f000 f8fb 	bl	802ca90 <__kernel_rem_pio2f>
 802c89a:	2e00      	cmp	r6, #0
 802c89c:	f6bf af31 	bge.w	802c702 <__ieee754_rem_pio2f+0x62>
 802c8a0:	edd5 7a00 	vldr	s15, [r5]
 802c8a4:	eef1 7a67 	vneg.f32	s15, s15
 802c8a8:	edc5 7a00 	vstr	s15, [r5]
 802c8ac:	edd5 7a01 	vldr	s15, [r5, #4]
 802c8b0:	eef1 7a67 	vneg.f32	s15, s15
 802c8b4:	edc5 7a01 	vstr	s15, [r5, #4]
 802c8b8:	e77a      	b.n	802c7b0 <__ieee754_rem_pio2f+0x110>
 802c8ba:	2303      	movs	r3, #3
 802c8bc:	e7e5      	b.n	802c88a <__ieee754_rem_pio2f+0x1ea>
 802c8be:	bf00      	nop
 802c8c0:	3f490fd8 	.word	0x3f490fd8
 802c8c4:	4016cbe3 	.word	0x4016cbe3
 802c8c8:	3fc90f80 	.word	0x3fc90f80
 802c8cc:	3fc90fd0 	.word	0x3fc90fd0
 802c8d0:	37354400 	.word	0x37354400
 802c8d4:	37354443 	.word	0x37354443
 802c8d8:	2e85a308 	.word	0x2e85a308
 802c8dc:	43490f80 	.word	0x43490f80
 802c8e0:	3f22f984 	.word	0x3f22f984
 802c8e4:	0804ff00 	.word	0x0804ff00
 802c8e8:	2e85a300 	.word	0x2e85a300
 802c8ec:	248d3132 	.word	0x248d3132
 802c8f0:	43800000 	.word	0x43800000
 802c8f4:	0804ff80 	.word	0x0804ff80

0802c8f8 <__ieee754_sinhf>:
 802c8f8:	b510      	push	{r4, lr}
 802c8fa:	ee10 3a10 	vmov	r3, s0
 802c8fe:	f023 4400 	bic.w	r4, r3, #2147483648	; 0x80000000
 802c902:	f1b4 4fff 	cmp.w	r4, #2139095040	; 0x7f800000
 802c906:	ed2d 8b02 	vpush	{d8}
 802c90a:	eef0 7a40 	vmov.f32	s15, s0
 802c90e:	db06      	blt.n	802c91e <__ieee754_sinhf+0x26>
 802c910:	ee70 7a00 	vadd.f32	s15, s0, s0
 802c914:	ecbd 8b02 	vpop	{d8}
 802c918:	eeb0 0a67 	vmov.f32	s0, s15
 802c91c:	bd10      	pop	{r4, pc}
 802c91e:	2b00      	cmp	r3, #0
 802c920:	4b28      	ldr	r3, [pc, #160]	; (802c9c4 <__ieee754_sinhf+0xcc>)
 802c922:	eef6 8a00 	vmov.f32	s17, #96	; 0x3f000000  0.5
 802c926:	eebe 8a00 	vmov.f32	s16, #224	; 0xbf000000 -0.5
 802c92a:	fe28 8a88 	vselge.f32	s16, s17, s16
 802c92e:	429c      	cmp	r4, r3
 802c930:	dc2a      	bgt.n	802c988 <__ieee754_sinhf+0x90>
 802c932:	f1b4 5f46 	cmp.w	r4, #830472192	; 0x31800000
 802c936:	eef7 8a00 	vmov.f32	s17, #112	; 0x3f800000  1.0
 802c93a:	da08      	bge.n	802c94e <__ieee754_sinhf+0x56>
 802c93c:	ed9f 7a22 	vldr	s14, [pc, #136]	; 802c9c8 <__ieee754_sinhf+0xd0>
 802c940:	ee30 7a07 	vadd.f32	s14, s0, s14
 802c944:	eeb4 7ae8 	vcmpe.f32	s14, s17
 802c948:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802c94c:	dce2      	bgt.n	802c914 <__ieee754_sinhf+0x1c>
 802c94e:	eeb0 0a67 	vmov.f32	s0, s15
 802c952:	f7fe fbb1 	bl	802b0b8 <fabsf>
 802c956:	f000 fdb9 	bl	802d4cc <expm1f>
 802c95a:	f1b4 5f7e 	cmp.w	r4, #1065353216	; 0x3f800000
 802c95e:	bfbb      	ittet	lt
 802c960:	ee20 7a00 	vmullt.f32	s14, s0, s0
 802c964:	ee70 8a28 	vaddlt.f32	s17, s0, s17
 802c968:	ee70 8a28 	vaddge.f32	s17, s0, s17
 802c96c:	eec7 7a28 	vdivlt.f32	s15, s14, s17
 802c970:	bfad      	iteet	ge
 802c972:	eec0 7a28 	vdivge.f32	s15, s0, s17
 802c976:	eeb0 7a00 	vmovlt.f32	s14, #0	; 0x40000000  2.0
 802c97a:	eed0 7a07 	vfnmslt.f32	s15, s0, s14
 802c97e:	ee77 7a80 	vaddge.f32	s15, s15, s0
 802c982:	ee67 7a88 	vmul.f32	s15, s15, s16
 802c986:	e7c5      	b.n	802c914 <__ieee754_sinhf+0x1c>
 802c988:	4b10      	ldr	r3, [pc, #64]	; (802c9cc <__ieee754_sinhf+0xd4>)
 802c98a:	429c      	cmp	r4, r3
 802c98c:	dc06      	bgt.n	802c99c <__ieee754_sinhf+0xa4>
 802c98e:	f7fe fb93 	bl	802b0b8 <fabsf>
 802c992:	f7fe fb13 	bl	802afbc <expf>
 802c996:	ee60 7a08 	vmul.f32	s15, s0, s16
 802c99a:	e7bb      	b.n	802c914 <__ieee754_sinhf+0x1c>
 802c99c:	4b0c      	ldr	r3, [pc, #48]	; (802c9d0 <__ieee754_sinhf+0xd8>)
 802c99e:	429c      	cmp	r4, r3
 802c9a0:	dc0a      	bgt.n	802c9b8 <__ieee754_sinhf+0xc0>
 802c9a2:	f7fe fb89 	bl	802b0b8 <fabsf>
 802c9a6:	ee20 0a28 	vmul.f32	s0, s0, s17
 802c9aa:	f7fe fb07 	bl	802afbc <expf>
 802c9ae:	ee68 7a00 	vmul.f32	s15, s16, s0
 802c9b2:	ee67 7a80 	vmul.f32	s15, s15, s0
 802c9b6:	e7ad      	b.n	802c914 <__ieee754_sinhf+0x1c>
 802c9b8:	ed9f 7a03 	vldr	s14, [pc, #12]	; 802c9c8 <__ieee754_sinhf+0xd0>
 802c9bc:	ee60 7a07 	vmul.f32	s15, s0, s14
 802c9c0:	e7a8      	b.n	802c914 <__ieee754_sinhf+0x1c>
 802c9c2:	bf00      	nop
 802c9c4:	41afffff 	.word	0x41afffff
 802c9c8:	7cf0bdc2 	.word	0x7cf0bdc2
 802c9cc:	42b17217 	.word	0x42b17217
 802c9d0:	42b2d4fc 	.word	0x42b2d4fc

0802c9d4 <__kernel_cosf>:
 802c9d4:	ee10 3a10 	vmov	r3, s0
 802c9d8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802c9dc:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802c9e0:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802c9e4:	da05      	bge.n	802c9f2 <__kernel_cosf+0x1e>
 802c9e6:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802c9ea:	ee17 2a90 	vmov	r2, s15
 802c9ee:	2a00      	cmp	r2, #0
 802c9f0:	d03b      	beq.n	802ca6a <__kernel_cosf+0x96>
 802c9f2:	ee20 6a00 	vmul.f32	s12, s0, s0
 802c9f6:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
 802c9fa:	eddf 5a1d 	vldr	s11, [pc, #116]	; 802ca70 <__kernel_cosf+0x9c>
 802c9fe:	4a1d      	ldr	r2, [pc, #116]	; (802ca74 <__kernel_cosf+0xa0>)
 802ca00:	ee66 7a07 	vmul.f32	s15, s12, s14
 802ca04:	ed9f 7a1c 	vldr	s14, [pc, #112]	; 802ca78 <__kernel_cosf+0xa4>
 802ca08:	eea6 7a25 	vfma.f32	s14, s12, s11
 802ca0c:	4293      	cmp	r3, r2
 802ca0e:	eddf 5a1b 	vldr	s11, [pc, #108]	; 802ca7c <__kernel_cosf+0xa8>
 802ca12:	eee7 5a06 	vfma.f32	s11, s14, s12
 802ca16:	ed9f 7a1a 	vldr	s14, [pc, #104]	; 802ca80 <__kernel_cosf+0xac>
 802ca1a:	eea5 7a86 	vfma.f32	s14, s11, s12
 802ca1e:	eddf 5a19 	vldr	s11, [pc, #100]	; 802ca84 <__kernel_cosf+0xb0>
 802ca22:	eee7 5a06 	vfma.f32	s11, s14, s12
 802ca26:	ed9f 7a18 	vldr	s14, [pc, #96]	; 802ca88 <__kernel_cosf+0xb4>
 802ca2a:	eea5 7a86 	vfma.f32	s14, s11, s12
 802ca2e:	ee60 0ac0 	vnmul.f32	s1, s1, s0
 802ca32:	ee27 7a06 	vmul.f32	s14, s14, s12
 802ca36:	eee6 0a07 	vfma.f32	s1, s12, s14
 802ca3a:	dc04      	bgt.n	802ca46 <__kernel_cosf+0x72>
 802ca3c:	ee77 0ae0 	vsub.f32	s1, s15, s1
 802ca40:	ee36 0ae0 	vsub.f32	s0, s13, s1
 802ca44:	4770      	bx	lr
 802ca46:	4a11      	ldr	r2, [pc, #68]	; (802ca8c <__kernel_cosf+0xb8>)
 802ca48:	4293      	cmp	r3, r2
 802ca4a:	bfda      	itte	le
 802ca4c:	f103 437f 	addle.w	r3, r3, #4278190080	; 0xff000000
 802ca50:	ee07 3a10 	vmovle	s14, r3
 802ca54:	eeb5 7a02 	vmovgt.f32	s14, #82	; 0x3e900000  0.2812500
 802ca58:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802ca5c:	ee36 0ac7 	vsub.f32	s0, s13, s14
 802ca60:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802ca64:	ee30 0a67 	vsub.f32	s0, s0, s15
 802ca68:	4770      	bx	lr
 802ca6a:	eeb0 0a66 	vmov.f32	s0, s13
 802ca6e:	4770      	bx	lr
 802ca70:	ad47d74e 	.word	0xad47d74e
 802ca74:	3e999999 	.word	0x3e999999
 802ca78:	310f74f6 	.word	0x310f74f6
 802ca7c:	b493f27c 	.word	0xb493f27c
 802ca80:	37d00d01 	.word	0x37d00d01
 802ca84:	bab60b61 	.word	0xbab60b61
 802ca88:	3d2aaaab 	.word	0x3d2aaaab
 802ca8c:	3f480000 	.word	0x3f480000

0802ca90 <__kernel_rem_pio2f>:
 802ca90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 802ca94:	ed2d 8b04 	vpush	{d8-d9}
 802ca98:	b0d7      	sub	sp, #348	; 0x15c
 802ca9a:	469b      	mov	fp, r3
 802ca9c:	460e      	mov	r6, r1
 802ca9e:	4bbe      	ldr	r3, [pc, #760]	; (802cd98 <__kernel_rem_pio2f+0x308>)
 802caa0:	9964      	ldr	r1, [sp, #400]	; 0x190
 802caa2:	9002      	str	r0, [sp, #8]
 802caa4:	f853 9021 	ldr.w	r9, [r3, r1, lsl #2]
 802caa8:	9865      	ldr	r0, [sp, #404]	; 0x194
 802caaa:	ed9f 7abf 	vldr	s14, [pc, #764]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802caae:	1ed1      	subs	r1, r2, #3
 802cab0:	2308      	movs	r3, #8
 802cab2:	fb91 f1f3 	sdiv	r1, r1, r3
 802cab6:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 802caba:	f10b 3aff 	add.w	sl, fp, #4294967295	; 0xffffffff
 802cabe:	1c4c      	adds	r4, r1, #1
 802cac0:	eba2 04c4 	sub.w	r4, r2, r4, lsl #3
 802cac4:	eba1 050a 	sub.w	r5, r1, sl
 802cac8:	aa1a      	add	r2, sp, #104	; 0x68
 802caca:	eb09 070a 	add.w	r7, r9, sl
 802cace:	eb00 0c85 	add.w	ip, r0, r5, lsl #2
 802cad2:	4696      	mov	lr, r2
 802cad4:	2300      	movs	r3, #0
 802cad6:	42bb      	cmp	r3, r7
 802cad8:	dd0f      	ble.n	802cafa <__kernel_rem_pio2f+0x6a>
 802cada:	af42      	add	r7, sp, #264	; 0x108
 802cadc:	2200      	movs	r2, #0
 802cade:	454a      	cmp	r2, r9
 802cae0:	dc27      	bgt.n	802cb32 <__kernel_rem_pio2f+0xa2>
 802cae2:	f10d 0c68 	add.w	ip, sp, #104	; 0x68
 802cae6:	eb0b 0302 	add.w	r3, fp, r2
 802caea:	eb0c 0383 	add.w	r3, ip, r3, lsl #2
 802caee:	9d02      	ldr	r5, [sp, #8]
 802caf0:	eddf 7aad 	vldr	s15, [pc, #692]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802caf4:	f04f 0c00 	mov.w	ip, #0
 802caf8:	e015      	b.n	802cb26 <__kernel_rem_pio2f+0x96>
 802cafa:	42dd      	cmn	r5, r3
 802cafc:	bf5d      	ittte	pl
 802cafe:	f85c 2023 	ldrpl.w	r2, [ip, r3, lsl #2]
 802cb02:	ee07 2a90 	vmovpl	s15, r2
 802cb06:	eef8 7ae7 	vcvtpl.f32.s32	s15, s15
 802cb0a:	eef0 7a47 	vmovmi.f32	s15, s14
 802cb0e:	ecee 7a01 	vstmia	lr!, {s15}
 802cb12:	3301      	adds	r3, #1
 802cb14:	e7df      	b.n	802cad6 <__kernel_rem_pio2f+0x46>
 802cb16:	ecf5 6a01 	vldmia	r5!, {s13}
 802cb1a:	ed33 7a01 	vldmdb	r3!, {s14}
 802cb1e:	eee6 7a87 	vfma.f32	s15, s13, s14
 802cb22:	f10c 0c01 	add.w	ip, ip, #1
 802cb26:	45d4      	cmp	ip, sl
 802cb28:	ddf5      	ble.n	802cb16 <__kernel_rem_pio2f+0x86>
 802cb2a:	ece7 7a01 	vstmia	r7!, {s15}
 802cb2e:	3201      	adds	r2, #1
 802cb30:	e7d5      	b.n	802cade <__kernel_rem_pio2f+0x4e>
 802cb32:	ab06      	add	r3, sp, #24
 802cb34:	eb03 0389 	add.w	r3, r3, r9, lsl #2
 802cb38:	9304      	str	r3, [sp, #16]
 802cb3a:	eddf 8a9a 	vldr	s17, [pc, #616]	; 802cda4 <__kernel_rem_pio2f+0x314>
 802cb3e:	ed9f 9a98 	vldr	s18, [pc, #608]	; 802cda0 <__kernel_rem_pio2f+0x310>
 802cb42:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 802cb46:	9303      	str	r3, [sp, #12]
 802cb48:	464d      	mov	r5, r9
 802cb4a:	ab56      	add	r3, sp, #344	; 0x158
 802cb4c:	f105 4780 	add.w	r7, r5, #1073741824	; 0x40000000
 802cb50:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 802cb54:	3f01      	subs	r7, #1
 802cb56:	ed13 0a14 	vldr	s0, [r3, #-80]	; 0xffffffb0
 802cb5a:	00bf      	lsls	r7, r7, #2
 802cb5c:	ab56      	add	r3, sp, #344	; 0x158
 802cb5e:	19da      	adds	r2, r3, r7
 802cb60:	3a4c      	subs	r2, #76	; 0x4c
 802cb62:	2300      	movs	r3, #0
 802cb64:	1ae9      	subs	r1, r5, r3
 802cb66:	2900      	cmp	r1, #0
 802cb68:	dc4c      	bgt.n	802cc04 <__kernel_rem_pio2f+0x174>
 802cb6a:	4620      	mov	r0, r4
 802cb6c:	f000 fe24 	bl	802d7b8 <scalbnf>
 802cb70:	eeb0 8a40 	vmov.f32	s16, s0
 802cb74:	eeb4 0a00 	vmov.f32	s0, #64	; 0x3e000000  0.125
 802cb78:	ee28 0a00 	vmul.f32	s0, s16, s0
 802cb7c:	f000 fdda 	bl	802d734 <floorf>
 802cb80:	eef2 7a00 	vmov.f32	s15, #32	; 0x41000000  8.0
 802cb84:	eea0 8a67 	vfms.f32	s16, s0, s15
 802cb88:	2c00      	cmp	r4, #0
 802cb8a:	eefd 7ac8 	vcvt.s32.f32	s15, s16
 802cb8e:	edcd 7a01 	vstr	s15, [sp, #4]
 802cb92:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cb96:	ee38 8a67 	vsub.f32	s16, s16, s15
 802cb9a:	dd48      	ble.n	802cc2e <__kernel_rem_pio2f+0x19e>
 802cb9c:	1e69      	subs	r1, r5, #1
 802cb9e:	ab06      	add	r3, sp, #24
 802cba0:	f1c4 0008 	rsb	r0, r4, #8
 802cba4:	f853 c021 	ldr.w	ip, [r3, r1, lsl #2]
 802cba8:	9a01      	ldr	r2, [sp, #4]
 802cbaa:	fa4c f300 	asr.w	r3, ip, r0
 802cbae:	441a      	add	r2, r3
 802cbb0:	4083      	lsls	r3, r0
 802cbb2:	9201      	str	r2, [sp, #4]
 802cbb4:	ebac 0203 	sub.w	r2, ip, r3
 802cbb8:	ab06      	add	r3, sp, #24
 802cbba:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
 802cbbe:	f1c4 0307 	rsb	r3, r4, #7
 802cbc2:	fa42 f803 	asr.w	r8, r2, r3
 802cbc6:	f1b8 0f00 	cmp.w	r8, #0
 802cbca:	dd41      	ble.n	802cc50 <__kernel_rem_pio2f+0x1c0>
 802cbcc:	9b01      	ldr	r3, [sp, #4]
 802cbce:	2000      	movs	r0, #0
 802cbd0:	3301      	adds	r3, #1
 802cbd2:	9301      	str	r3, [sp, #4]
 802cbd4:	4601      	mov	r1, r0
 802cbd6:	4285      	cmp	r5, r0
 802cbd8:	dc6d      	bgt.n	802ccb6 <__kernel_rem_pio2f+0x226>
 802cbda:	2c00      	cmp	r4, #0
 802cbdc:	dd04      	ble.n	802cbe8 <__kernel_rem_pio2f+0x158>
 802cbde:	2c01      	cmp	r4, #1
 802cbe0:	d07e      	beq.n	802cce0 <__kernel_rem_pio2f+0x250>
 802cbe2:	2c02      	cmp	r4, #2
 802cbe4:	f000 8086 	beq.w	802ccf4 <__kernel_rem_pio2f+0x264>
 802cbe8:	f1b8 0f02 	cmp.w	r8, #2
 802cbec:	d130      	bne.n	802cc50 <__kernel_rem_pio2f+0x1c0>
 802cbee:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802cbf2:	ee30 8a48 	vsub.f32	s16, s0, s16
 802cbf6:	b359      	cbz	r1, 802cc50 <__kernel_rem_pio2f+0x1c0>
 802cbf8:	4620      	mov	r0, r4
 802cbfa:	f000 fddd 	bl	802d7b8 <scalbnf>
 802cbfe:	ee38 8a40 	vsub.f32	s16, s16, s0
 802cc02:	e025      	b.n	802cc50 <__kernel_rem_pio2f+0x1c0>
 802cc04:	ee60 7a28 	vmul.f32	s15, s0, s17
 802cc08:	a806      	add	r0, sp, #24
 802cc0a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802cc0e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cc12:	eea7 0ac9 	vfms.f32	s0, s15, s18
 802cc16:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802cc1a:	ee10 1a10 	vmov	r1, s0
 802cc1e:	ed32 0a01 	vldmdb	r2!, {s0}
 802cc22:	f840 1023 	str.w	r1, [r0, r3, lsl #2]
 802cc26:	ee37 0a80 	vadd.f32	s0, s15, s0
 802cc2a:	3301      	adds	r3, #1
 802cc2c:	e79a      	b.n	802cb64 <__kernel_rem_pio2f+0xd4>
 802cc2e:	d106      	bne.n	802cc3e <__kernel_rem_pio2f+0x1ae>
 802cc30:	1e6b      	subs	r3, r5, #1
 802cc32:	aa06      	add	r2, sp, #24
 802cc34:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 802cc38:	ea4f 2822 	mov.w	r8, r2, asr #8
 802cc3c:	e7c3      	b.n	802cbc6 <__kernel_rem_pio2f+0x136>
 802cc3e:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802cc42:	eeb4 8ae7 	vcmpe.f32	s16, s15
 802cc46:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cc4a:	da31      	bge.n	802ccb0 <__kernel_rem_pio2f+0x220>
 802cc4c:	f04f 0800 	mov.w	r8, #0
 802cc50:	eeb5 8a40 	vcmp.f32	s16, #0.0
 802cc54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cc58:	f040 80a8 	bne.w	802cdac <__kernel_rem_pio2f+0x31c>
 802cc5c:	1e6b      	subs	r3, r5, #1
 802cc5e:	4618      	mov	r0, r3
 802cc60:	2200      	movs	r2, #0
 802cc62:	4548      	cmp	r0, r9
 802cc64:	da4d      	bge.n	802cd02 <__kernel_rem_pio2f+0x272>
 802cc66:	2a00      	cmp	r2, #0
 802cc68:	f000 8087 	beq.w	802cd7a <__kernel_rem_pio2f+0x2ea>
 802cc6c:	aa06      	add	r2, sp, #24
 802cc6e:	3c08      	subs	r4, #8
 802cc70:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 802cc74:	2900      	cmp	r1, #0
 802cc76:	f000 808d 	beq.w	802cd94 <__kernel_rem_pio2f+0x304>
 802cc7a:	4620      	mov	r0, r4
 802cc7c:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802cc80:	9302      	str	r3, [sp, #8]
 802cc82:	f000 fd99 	bl	802d7b8 <scalbnf>
 802cc86:	9b02      	ldr	r3, [sp, #8]
 802cc88:	ed9f 7a46 	vldr	s14, [pc, #280]	; 802cda4 <__kernel_rem_pio2f+0x314>
 802cc8c:	0099      	lsls	r1, r3, #2
 802cc8e:	aa42      	add	r2, sp, #264	; 0x108
 802cc90:	1850      	adds	r0, r2, r1
 802cc92:	1d05      	adds	r5, r0, #4
 802cc94:	461c      	mov	r4, r3
 802cc96:	2c00      	cmp	r4, #0
 802cc98:	f280 80b8 	bge.w	802ce0c <__kernel_rem_pio2f+0x37c>
 802cc9c:	2500      	movs	r5, #0
 802cc9e:	1b5c      	subs	r4, r3, r5
 802cca0:	2c00      	cmp	r4, #0
 802cca2:	f2c0 80d8 	blt.w	802ce56 <__kernel_rem_pio2f+0x3c6>
 802cca6:	4f3d      	ldr	r7, [pc, #244]	; (802cd9c <__kernel_rem_pio2f+0x30c>)
 802cca8:	eddf 7a3f 	vldr	s15, [pc, #252]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802ccac:	2400      	movs	r4, #0
 802ccae:	e0c6      	b.n	802ce3e <__kernel_rem_pio2f+0x3ae>
 802ccb0:	f04f 0802 	mov.w	r8, #2
 802ccb4:	e78a      	b.n	802cbcc <__kernel_rem_pio2f+0x13c>
 802ccb6:	ab06      	add	r3, sp, #24
 802ccb8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 802ccbc:	b949      	cbnz	r1, 802ccd2 <__kernel_rem_pio2f+0x242>
 802ccbe:	b12b      	cbz	r3, 802cccc <__kernel_rem_pio2f+0x23c>
 802ccc0:	aa06      	add	r2, sp, #24
 802ccc2:	f5c3 7380 	rsb	r3, r3, #256	; 0x100
 802ccc6:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 802ccca:	2301      	movs	r3, #1
 802cccc:	3001      	adds	r0, #1
 802ccce:	4619      	mov	r1, r3
 802ccd0:	e781      	b.n	802cbd6 <__kernel_rem_pio2f+0x146>
 802ccd2:	aa06      	add	r2, sp, #24
 802ccd4:	f1c3 03ff 	rsb	r3, r3, #255	; 0xff
 802ccd8:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 802ccdc:	460b      	mov	r3, r1
 802ccde:	e7f5      	b.n	802cccc <__kernel_rem_pio2f+0x23c>
 802cce0:	1e68      	subs	r0, r5, #1
 802cce2:	ab06      	add	r3, sp, #24
 802cce4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 802cce8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 802ccec:	aa06      	add	r2, sp, #24
 802ccee:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
 802ccf2:	e779      	b.n	802cbe8 <__kernel_rem_pio2f+0x158>
 802ccf4:	1e68      	subs	r0, r5, #1
 802ccf6:	ab06      	add	r3, sp, #24
 802ccf8:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 802ccfc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 802cd00:	e7f4      	b.n	802ccec <__kernel_rem_pio2f+0x25c>
 802cd02:	a906      	add	r1, sp, #24
 802cd04:	f851 1020 	ldr.w	r1, [r1, r0, lsl #2]
 802cd08:	3801      	subs	r0, #1
 802cd0a:	430a      	orrs	r2, r1
 802cd0c:	e7a9      	b.n	802cc62 <__kernel_rem_pio2f+0x1d2>
 802cd0e:	f10c 0c01 	add.w	ip, ip, #1
 802cd12:	f853 2d04 	ldr.w	r2, [r3, #-4]!
 802cd16:	2a00      	cmp	r2, #0
 802cd18:	d0f9      	beq.n	802cd0e <__kernel_rem_pio2f+0x27e>
 802cd1a:	eb0b 0305 	add.w	r3, fp, r5
 802cd1e:	aa1a      	add	r2, sp, #104	; 0x68
 802cd20:	009b      	lsls	r3, r3, #2
 802cd22:	1898      	adds	r0, r3, r2
 802cd24:	3004      	adds	r0, #4
 802cd26:	1c69      	adds	r1, r5, #1
 802cd28:	3704      	adds	r7, #4
 802cd2a:	2200      	movs	r2, #0
 802cd2c:	4465      	add	r5, ip
 802cd2e:	9005      	str	r0, [sp, #20]
 802cd30:	428d      	cmp	r5, r1
 802cd32:	f6ff af0a 	blt.w	802cb4a <__kernel_rem_pio2f+0xba>
 802cd36:	a81a      	add	r0, sp, #104	; 0x68
 802cd38:	eb02 0c03 	add.w	ip, r2, r3
 802cd3c:	4484      	add	ip, r0
 802cd3e:	9803      	ldr	r0, [sp, #12]
 802cd40:	f8dd e008 	ldr.w	lr, [sp, #8]
 802cd44:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
 802cd48:	9001      	str	r0, [sp, #4]
 802cd4a:	ee07 0a90 	vmov	s15, r0
 802cd4e:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cd52:	9805      	ldr	r0, [sp, #20]
 802cd54:	edcc 7a00 	vstr	s15, [ip]
 802cd58:	eddf 7a13 	vldr	s15, [pc, #76]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802cd5c:	eb00 0802 	add.w	r8, r0, r2
 802cd60:	f04f 0c00 	mov.w	ip, #0
 802cd64:	45d4      	cmp	ip, sl
 802cd66:	dd0c      	ble.n	802cd82 <__kernel_rem_pio2f+0x2f2>
 802cd68:	eb02 0c07 	add.w	ip, r2, r7
 802cd6c:	a842      	add	r0, sp, #264	; 0x108
 802cd6e:	4484      	add	ip, r0
 802cd70:	edcc 7a01 	vstr	s15, [ip, #4]
 802cd74:	3101      	adds	r1, #1
 802cd76:	3204      	adds	r2, #4
 802cd78:	e7da      	b.n	802cd30 <__kernel_rem_pio2f+0x2a0>
 802cd7a:	9b04      	ldr	r3, [sp, #16]
 802cd7c:	f04f 0c01 	mov.w	ip, #1
 802cd80:	e7c7      	b.n	802cd12 <__kernel_rem_pio2f+0x282>
 802cd82:	ecfe 6a01 	vldmia	lr!, {s13}
 802cd86:	ed38 7a01 	vldmdb	r8!, {s14}
 802cd8a:	f10c 0c01 	add.w	ip, ip, #1
 802cd8e:	eee6 7a87 	vfma.f32	s15, s13, s14
 802cd92:	e7e7      	b.n	802cd64 <__kernel_rem_pio2f+0x2d4>
 802cd94:	3b01      	subs	r3, #1
 802cd96:	e769      	b.n	802cc6c <__kernel_rem_pio2f+0x1dc>
 802cd98:	080502c4 	.word	0x080502c4
 802cd9c:	08050298 	.word	0x08050298
 802cda0:	43800000 	.word	0x43800000
 802cda4:	3b800000 	.word	0x3b800000
 802cda8:	00000000 	.word	0x00000000
 802cdac:	4260      	negs	r0, r4
 802cdae:	eeb0 0a48 	vmov.f32	s0, s16
 802cdb2:	f000 fd01 	bl	802d7b8 <scalbnf>
 802cdb6:	ed1f 7a06 	vldr	s14, [pc, #-24]	; 802cda0 <__kernel_rem_pio2f+0x310>
 802cdba:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802cdbe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802cdc2:	db1a      	blt.n	802cdfa <__kernel_rem_pio2f+0x36a>
 802cdc4:	ed5f 7a09 	vldr	s15, [pc, #-36]	; 802cda4 <__kernel_rem_pio2f+0x314>
 802cdc8:	ee60 7a27 	vmul.f32	s15, s0, s15
 802cdcc:	aa06      	add	r2, sp, #24
 802cdce:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802cdd2:	a906      	add	r1, sp, #24
 802cdd4:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802cdd8:	3408      	adds	r4, #8
 802cdda:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802cdde:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802cde2:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802cde6:	ee10 3a10 	vmov	r3, s0
 802cdea:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
 802cdee:	1c6b      	adds	r3, r5, #1
 802cdf0:	ee17 2a90 	vmov	r2, s15
 802cdf4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
 802cdf8:	e73f      	b.n	802cc7a <__kernel_rem_pio2f+0x1ea>
 802cdfa:	eebd 0ac0 	vcvt.s32.f32	s0, s0
 802cdfe:	aa06      	add	r2, sp, #24
 802ce00:	ee10 3a10 	vmov	r3, s0
 802ce04:	f842 3025 	str.w	r3, [r2, r5, lsl #2]
 802ce08:	462b      	mov	r3, r5
 802ce0a:	e736      	b.n	802cc7a <__kernel_rem_pio2f+0x1ea>
 802ce0c:	aa06      	add	r2, sp, #24
 802ce0e:	f852 2024 	ldr.w	r2, [r2, r4, lsl #2]
 802ce12:	9202      	str	r2, [sp, #8]
 802ce14:	ee07 2a90 	vmov	s15, r2
 802ce18:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802ce1c:	3c01      	subs	r4, #1
 802ce1e:	ee67 7a80 	vmul.f32	s15, s15, s0
 802ce22:	ee20 0a07 	vmul.f32	s0, s0, s14
 802ce26:	ed65 7a01 	vstmdb	r5!, {s15}
 802ce2a:	e734      	b.n	802cc96 <__kernel_rem_pio2f+0x206>
 802ce2c:	eb00 0c84 	add.w	ip, r0, r4, lsl #2
 802ce30:	ecf7 6a01 	vldmia	r7!, {s13}
 802ce34:	ed9c 7a00 	vldr	s14, [ip]
 802ce38:	eee6 7a87 	vfma.f32	s15, s13, s14
 802ce3c:	3401      	adds	r4, #1
 802ce3e:	454c      	cmp	r4, r9
 802ce40:	dc01      	bgt.n	802ce46 <__kernel_rem_pio2f+0x3b6>
 802ce42:	42a5      	cmp	r5, r4
 802ce44:	daf2      	bge.n	802ce2c <__kernel_rem_pio2f+0x39c>
 802ce46:	aa56      	add	r2, sp, #344	; 0x158
 802ce48:	eb02 0485 	add.w	r4, r2, r5, lsl #2
 802ce4c:	ed44 7a28 	vstr	s15, [r4, #-160]	; 0xffffff60
 802ce50:	3501      	adds	r5, #1
 802ce52:	3804      	subs	r0, #4
 802ce54:	e723      	b.n	802cc9e <__kernel_rem_pio2f+0x20e>
 802ce56:	9a64      	ldr	r2, [sp, #400]	; 0x190
 802ce58:	2a03      	cmp	r2, #3
 802ce5a:	d84d      	bhi.n	802cef8 <__kernel_rem_pio2f+0x468>
 802ce5c:	e8df f002 	tbb	[pc, r2]
 802ce60:	021f1f3e 	.word	0x021f1f3e
 802ce64:	aa56      	add	r2, sp, #344	; 0x158
 802ce66:	4411      	add	r1, r2
 802ce68:	399c      	subs	r1, #156	; 0x9c
 802ce6a:	4608      	mov	r0, r1
 802ce6c:	461c      	mov	r4, r3
 802ce6e:	2c00      	cmp	r4, #0
 802ce70:	dc5f      	bgt.n	802cf32 <__kernel_rem_pio2f+0x4a2>
 802ce72:	4608      	mov	r0, r1
 802ce74:	461c      	mov	r4, r3
 802ce76:	2c01      	cmp	r4, #1
 802ce78:	dc6b      	bgt.n	802cf52 <__kernel_rem_pio2f+0x4c2>
 802ce7a:	ed5f 7a35 	vldr	s15, [pc, #-212]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802ce7e:	2b01      	cmp	r3, #1
 802ce80:	dc77      	bgt.n	802cf72 <__kernel_rem_pio2f+0x4e2>
 802ce82:	eddd 6a2e 	vldr	s13, [sp, #184]	; 0xb8
 802ce86:	ed9d 7a2f 	vldr	s14, [sp, #188]	; 0xbc
 802ce8a:	f1b8 0f00 	cmp.w	r8, #0
 802ce8e:	d176      	bne.n	802cf7e <__kernel_rem_pio2f+0x4ee>
 802ce90:	edc6 6a00 	vstr	s13, [r6]
 802ce94:	ed86 7a01 	vstr	s14, [r6, #4]
 802ce98:	edc6 7a02 	vstr	s15, [r6, #8]
 802ce9c:	e02c      	b.n	802cef8 <__kernel_rem_pio2f+0x468>
 802ce9e:	aa56      	add	r2, sp, #344	; 0x158
 802cea0:	4411      	add	r1, r2
 802cea2:	ed1f 7a3f 	vldr	s14, [pc, #-252]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802cea6:	399c      	subs	r1, #156	; 0x9c
 802cea8:	4618      	mov	r0, r3
 802ceaa:	2800      	cmp	r0, #0
 802ceac:	da32      	bge.n	802cf14 <__kernel_rem_pio2f+0x484>
 802ceae:	f1b8 0f00 	cmp.w	r8, #0
 802ceb2:	d035      	beq.n	802cf20 <__kernel_rem_pio2f+0x490>
 802ceb4:	eef1 7a47 	vneg.f32	s15, s14
 802ceb8:	edc6 7a00 	vstr	s15, [r6]
 802cebc:	eddd 7a2e 	vldr	s15, [sp, #184]	; 0xb8
 802cec0:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cec4:	a82f      	add	r0, sp, #188	; 0xbc
 802cec6:	2101      	movs	r1, #1
 802cec8:	428b      	cmp	r3, r1
 802ceca:	da2c      	bge.n	802cf26 <__kernel_rem_pio2f+0x496>
 802cecc:	f1b8 0f00 	cmp.w	r8, #0
 802ced0:	d001      	beq.n	802ced6 <__kernel_rem_pio2f+0x446>
 802ced2:	eef1 7a67 	vneg.f32	s15, s15
 802ced6:	edc6 7a01 	vstr	s15, [r6, #4]
 802ceda:	e00d      	b.n	802cef8 <__kernel_rem_pio2f+0x468>
 802cedc:	aa56      	add	r2, sp, #344	; 0x158
 802cede:	4411      	add	r1, r2
 802cee0:	ed5f 7a4f 	vldr	s15, [pc, #-316]	; 802cda8 <__kernel_rem_pio2f+0x318>
 802cee4:	399c      	subs	r1, #156	; 0x9c
 802cee6:	2b00      	cmp	r3, #0
 802cee8:	da0e      	bge.n	802cf08 <__kernel_rem_pio2f+0x478>
 802ceea:	f1b8 0f00 	cmp.w	r8, #0
 802ceee:	d001      	beq.n	802cef4 <__kernel_rem_pio2f+0x464>
 802cef0:	eef1 7a67 	vneg.f32	s15, s15
 802cef4:	edc6 7a00 	vstr	s15, [r6]
 802cef8:	9b01      	ldr	r3, [sp, #4]
 802cefa:	f003 0007 	and.w	r0, r3, #7
 802cefe:	b057      	add	sp, #348	; 0x15c
 802cf00:	ecbd 8b04 	vpop	{d8-d9}
 802cf04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 802cf08:	ed31 7a01 	vldmdb	r1!, {s14}
 802cf0c:	3b01      	subs	r3, #1
 802cf0e:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cf12:	e7e8      	b.n	802cee6 <__kernel_rem_pio2f+0x456>
 802cf14:	ed71 7a01 	vldmdb	r1!, {s15}
 802cf18:	3801      	subs	r0, #1
 802cf1a:	ee37 7a27 	vadd.f32	s14, s14, s15
 802cf1e:	e7c4      	b.n	802ceaa <__kernel_rem_pio2f+0x41a>
 802cf20:	eef0 7a47 	vmov.f32	s15, s14
 802cf24:	e7c8      	b.n	802ceb8 <__kernel_rem_pio2f+0x428>
 802cf26:	ecb0 7a01 	vldmia	r0!, {s14}
 802cf2a:	3101      	adds	r1, #1
 802cf2c:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cf30:	e7ca      	b.n	802cec8 <__kernel_rem_pio2f+0x438>
 802cf32:	ed50 7a02 	vldr	s15, [r0, #-8]
 802cf36:	ed70 6a01 	vldmdb	r0!, {s13}
 802cf3a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802cf3e:	3c01      	subs	r4, #1
 802cf40:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cf44:	ed00 7a01 	vstr	s14, [r0, #-4]
 802cf48:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802cf4c:	edc0 7a00 	vstr	s15, [r0]
 802cf50:	e78d      	b.n	802ce6e <__kernel_rem_pio2f+0x3de>
 802cf52:	ed50 7a02 	vldr	s15, [r0, #-8]
 802cf56:	ed70 6a01 	vldmdb	r0!, {s13}
 802cf5a:	ee37 7aa6 	vadd.f32	s14, s15, s13
 802cf5e:	3c01      	subs	r4, #1
 802cf60:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802cf64:	ed00 7a01 	vstr	s14, [r0, #-4]
 802cf68:	ee77 7aa6 	vadd.f32	s15, s15, s13
 802cf6c:	edc0 7a00 	vstr	s15, [r0]
 802cf70:	e781      	b.n	802ce76 <__kernel_rem_pio2f+0x3e6>
 802cf72:	ed31 7a01 	vldmdb	r1!, {s14}
 802cf76:	3b01      	subs	r3, #1
 802cf78:	ee77 7a87 	vadd.f32	s15, s15, s14
 802cf7c:	e77f      	b.n	802ce7e <__kernel_rem_pio2f+0x3ee>
 802cf7e:	eef1 6a66 	vneg.f32	s13, s13
 802cf82:	eeb1 7a47 	vneg.f32	s14, s14
 802cf86:	edc6 6a00 	vstr	s13, [r6]
 802cf8a:	ed86 7a01 	vstr	s14, [r6, #4]
 802cf8e:	eef1 7a67 	vneg.f32	s15, s15
 802cf92:	e781      	b.n	802ce98 <__kernel_rem_pio2f+0x408>

0802cf94 <__kernel_sinf>:
 802cf94:	ee10 3a10 	vmov	r3, s0
 802cf98:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802cf9c:	f1b3 5f48 	cmp.w	r3, #838860800	; 0x32000000
 802cfa0:	da04      	bge.n	802cfac <__kernel_sinf+0x18>
 802cfa2:	eefd 7ac0 	vcvt.s32.f32	s15, s0
 802cfa6:	ee17 3a90 	vmov	r3, s15
 802cfaa:	b35b      	cbz	r3, 802d004 <__kernel_sinf+0x70>
 802cfac:	ee20 7a00 	vmul.f32	s14, s0, s0
 802cfb0:	eddf 7a15 	vldr	s15, [pc, #84]	; 802d008 <__kernel_sinf+0x74>
 802cfb4:	ed9f 6a15 	vldr	s12, [pc, #84]	; 802d00c <__kernel_sinf+0x78>
 802cfb8:	eea7 6a27 	vfma.f32	s12, s14, s15
 802cfbc:	eddf 7a14 	vldr	s15, [pc, #80]	; 802d010 <__kernel_sinf+0x7c>
 802cfc0:	eee6 7a07 	vfma.f32	s15, s12, s14
 802cfc4:	ed9f 6a13 	vldr	s12, [pc, #76]	; 802d014 <__kernel_sinf+0x80>
 802cfc8:	eea7 6a87 	vfma.f32	s12, s15, s14
 802cfcc:	eddf 7a12 	vldr	s15, [pc, #72]	; 802d018 <__kernel_sinf+0x84>
 802cfd0:	ee60 6a07 	vmul.f32	s13, s0, s14
 802cfd4:	eee6 7a07 	vfma.f32	s15, s12, s14
 802cfd8:	b930      	cbnz	r0, 802cfe8 <__kernel_sinf+0x54>
 802cfda:	ed9f 6a10 	vldr	s12, [pc, #64]	; 802d01c <__kernel_sinf+0x88>
 802cfde:	eea7 6a27 	vfma.f32	s12, s14, s15
 802cfe2:	eea6 0a26 	vfma.f32	s0, s12, s13
 802cfe6:	4770      	bx	lr
 802cfe8:	ee67 7ae6 	vnmul.f32	s15, s15, s13
 802cfec:	eeb6 6a00 	vmov.f32	s12, #96	; 0x3f000000  0.5
 802cff0:	eee0 7a86 	vfma.f32	s15, s1, s12
 802cff4:	eed7 0a87 	vfnms.f32	s1, s15, s14
 802cff8:	eddf 7a09 	vldr	s15, [pc, #36]	; 802d020 <__kernel_sinf+0x8c>
 802cffc:	eee6 0aa7 	vfma.f32	s1, s13, s15
 802d000:	ee30 0a60 	vsub.f32	s0, s0, s1
 802d004:	4770      	bx	lr
 802d006:	bf00      	nop
 802d008:	2f2ec9d3 	.word	0x2f2ec9d3
 802d00c:	b2d72f34 	.word	0xb2d72f34
 802d010:	3638ef1b 	.word	0x3638ef1b
 802d014:	b9500d01 	.word	0xb9500d01
 802d018:	3c088889 	.word	0x3c088889
 802d01c:	be2aaaab 	.word	0xbe2aaaab
 802d020:	3e2aaaab 	.word	0x3e2aaaab

0802d024 <__kernel_tanf>:
 802d024:	b508      	push	{r3, lr}
 802d026:	ee10 3a10 	vmov	r3, s0
 802d02a:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
 802d02e:	f1b2 5f46 	cmp.w	r2, #830472192	; 0x31800000
 802d032:	eef0 7a40 	vmov.f32	s15, s0
 802d036:	da17      	bge.n	802d068 <__kernel_tanf+0x44>
 802d038:	eebd 7ac0 	vcvt.s32.f32	s14, s0
 802d03c:	ee17 1a10 	vmov	r1, s14
 802d040:	bb41      	cbnz	r1, 802d094 <__kernel_tanf+0x70>
 802d042:	1c43      	adds	r3, r0, #1
 802d044:	4313      	orrs	r3, r2
 802d046:	d108      	bne.n	802d05a <__kernel_tanf+0x36>
 802d048:	f7fe f836 	bl	802b0b8 <fabsf>
 802d04c:	eeb7 7a00 	vmov.f32	s14, #112	; 0x3f800000  1.0
 802d050:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802d054:	eeb0 0a67 	vmov.f32	s0, s15
 802d058:	bd08      	pop	{r3, pc}
 802d05a:	2801      	cmp	r0, #1
 802d05c:	d0fa      	beq.n	802d054 <__kernel_tanf+0x30>
 802d05e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802d062:	eec7 7a00 	vdiv.f32	s15, s14, s0
 802d066:	e7f5      	b.n	802d054 <__kernel_tanf+0x30>
 802d068:	494e      	ldr	r1, [pc, #312]	; (802d1a4 <__kernel_tanf+0x180>)
 802d06a:	428a      	cmp	r2, r1
 802d06c:	dd12      	ble.n	802d094 <__kernel_tanf+0x70>
 802d06e:	2b00      	cmp	r3, #0
 802d070:	ed9f 7a4d 	vldr	s14, [pc, #308]	; 802d1a8 <__kernel_tanf+0x184>
 802d074:	bfb8      	it	lt
 802d076:	eef1 7a40 	vneglt.f32	s15, s0
 802d07a:	ee77 7a67 	vsub.f32	s15, s14, s15
 802d07e:	ed9f 7a4b 	vldr	s14, [pc, #300]	; 802d1ac <__kernel_tanf+0x188>
 802d082:	bfb8      	it	lt
 802d084:	eef1 0a60 	vneglt.f32	s1, s1
 802d088:	ee77 0a60 	vsub.f32	s1, s14, s1
 802d08c:	ee70 7aa7 	vadd.f32	s15, s1, s15
 802d090:	eddf 0a47 	vldr	s1, [pc, #284]	; 802d1b0 <__kernel_tanf+0x18c>
 802d094:	ed9f 6a47 	vldr	s12, [pc, #284]	; 802d1b4 <__kernel_tanf+0x190>
 802d098:	eddf 5a47 	vldr	s11, [pc, #284]	; 802d1b8 <__kernel_tanf+0x194>
 802d09c:	ed9f 5a47 	vldr	s10, [pc, #284]	; 802d1bc <__kernel_tanf+0x198>
 802d0a0:	4940      	ldr	r1, [pc, #256]	; (802d1a4 <__kernel_tanf+0x180>)
 802d0a2:	ee67 6aa7 	vmul.f32	s13, s15, s15
 802d0a6:	428a      	cmp	r2, r1
 802d0a8:	ee26 7aa6 	vmul.f32	s14, s13, s13
 802d0ac:	ee67 4aa6 	vmul.f32	s9, s15, s13
 802d0b0:	eee7 5a06 	vfma.f32	s11, s14, s12
 802d0b4:	ed9f 6a42 	vldr	s12, [pc, #264]	; 802d1c0 <__kernel_tanf+0x19c>
 802d0b8:	eea5 6a87 	vfma.f32	s12, s11, s14
 802d0bc:	eddf 5a41 	vldr	s11, [pc, #260]	; 802d1c4 <__kernel_tanf+0x1a0>
 802d0c0:	eee6 5a07 	vfma.f32	s11, s12, s14
 802d0c4:	ed9f 6a40 	vldr	s12, [pc, #256]	; 802d1c8 <__kernel_tanf+0x1a4>
 802d0c8:	eea5 6a87 	vfma.f32	s12, s11, s14
 802d0cc:	eddf 5a3f 	vldr	s11, [pc, #252]	; 802d1cc <__kernel_tanf+0x1a8>
 802d0d0:	eee6 5a07 	vfma.f32	s11, s12, s14
 802d0d4:	ed9f 6a3e 	vldr	s12, [pc, #248]	; 802d1d0 <__kernel_tanf+0x1ac>
 802d0d8:	eea7 6a05 	vfma.f32	s12, s14, s10
 802d0dc:	ed9f 5a3d 	vldr	s10, [pc, #244]	; 802d1d4 <__kernel_tanf+0x1b0>
 802d0e0:	eea6 5a07 	vfma.f32	s10, s12, s14
 802d0e4:	ed9f 6a3c 	vldr	s12, [pc, #240]	; 802d1d8 <__kernel_tanf+0x1b4>
 802d0e8:	eea5 6a07 	vfma.f32	s12, s10, s14
 802d0ec:	ed9f 5a3b 	vldr	s10, [pc, #236]	; 802d1dc <__kernel_tanf+0x1b8>
 802d0f0:	eea6 5a07 	vfma.f32	s10, s12, s14
 802d0f4:	ed9f 6a3a 	vldr	s12, [pc, #232]	; 802d1e0 <__kernel_tanf+0x1bc>
 802d0f8:	eea5 6a07 	vfma.f32	s12, s10, s14
 802d0fc:	eeb0 7a46 	vmov.f32	s14, s12
 802d100:	eea5 7aa6 	vfma.f32	s14, s11, s13
 802d104:	eeb0 6a60 	vmov.f32	s12, s1
 802d108:	eea7 6a24 	vfma.f32	s12, s14, s9
 802d10c:	ed9f 7a35 	vldr	s14, [pc, #212]	; 802d1e4 <__kernel_tanf+0x1c0>
 802d110:	eee6 0a26 	vfma.f32	s1, s12, s13
 802d114:	eee4 0a87 	vfma.f32	s1, s9, s14
 802d118:	ee77 6aa0 	vadd.f32	s13, s15, s1
 802d11c:	dd1d      	ble.n	802d15a <__kernel_tanf+0x136>
 802d11e:	ee07 0a10 	vmov	s14, r0
 802d122:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 802d126:	ee66 5aa6 	vmul.f32	s11, s13, s13
 802d12a:	ee76 6a87 	vadd.f32	s13, s13, s14
 802d12e:	179b      	asrs	r3, r3, #30
 802d130:	ee85 6aa6 	vdiv.f32	s12, s11, s13
 802d134:	f003 0302 	and.w	r3, r3, #2
 802d138:	f1c3 0301 	rsb	r3, r3, #1
 802d13c:	eef0 6a00 	vmov.f32	s13, #0	; 0x40000000  2.0
 802d140:	ee76 0a60 	vsub.f32	s1, s12, s1
 802d144:	ee77 7ae0 	vsub.f32	s15, s15, s1
 802d148:	eea7 7ae6 	vfms.f32	s14, s15, s13
 802d14c:	ee07 3a90 	vmov	s15, r3
 802d150:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802d154:	ee67 7a27 	vmul.f32	s15, s14, s15
 802d158:	e77c      	b.n	802d054 <__kernel_tanf+0x30>
 802d15a:	2801      	cmp	r0, #1
 802d15c:	d01f      	beq.n	802d19e <__kernel_tanf+0x17a>
 802d15e:	eebf 7a00 	vmov.f32	s14, #240	; 0xbf800000 -1.0
 802d162:	eec7 5a26 	vdiv.f32	s11, s14, s13
 802d166:	4b20      	ldr	r3, [pc, #128]	; (802d1e8 <__kernel_tanf+0x1c4>)
 802d168:	ee16 2a90 	vmov	r2, s13
 802d16c:	401a      	ands	r2, r3
 802d16e:	ee06 2a10 	vmov	s12, r2
 802d172:	ee15 2a90 	vmov	r2, s11
 802d176:	4013      	ands	r3, r2
 802d178:	ee07 3a10 	vmov	s14, r3
 802d17c:	eef7 6a00 	vmov.f32	s13, #112	; 0x3f800000  1.0
 802d180:	eee6 6a07 	vfma.f32	s13, s12, s14
 802d184:	ee76 7a67 	vsub.f32	s15, s12, s15
 802d188:	ee70 0ae7 	vsub.f32	s1, s1, s15
 802d18c:	eef0 7a66 	vmov.f32	s15, s13
 802d190:	eee7 7a20 	vfma.f32	s15, s14, s1
 802d194:	eea7 7aa5 	vfma.f32	s14, s15, s11
 802d198:	eef0 7a47 	vmov.f32	s15, s14
 802d19c:	e75a      	b.n	802d054 <__kernel_tanf+0x30>
 802d19e:	eef0 7a66 	vmov.f32	s15, s13
 802d1a2:	e757      	b.n	802d054 <__kernel_tanf+0x30>
 802d1a4:	3f2ca13f 	.word	0x3f2ca13f
 802d1a8:	3f490fda 	.word	0x3f490fda
 802d1ac:	33222168 	.word	0x33222168
 802d1b0:	00000000 	.word	0x00000000
 802d1b4:	37d95384 	.word	0x37d95384
 802d1b8:	3895c07a 	.word	0x3895c07a
 802d1bc:	b79bae5f 	.word	0xb79bae5f
 802d1c0:	398137b9 	.word	0x398137b9
 802d1c4:	3abede48 	.word	0x3abede48
 802d1c8:	3c11371f 	.word	0x3c11371f
 802d1cc:	3d5d0dd1 	.word	0x3d5d0dd1
 802d1d0:	38a3f445 	.word	0x38a3f445
 802d1d4:	3a1a26c8 	.word	0x3a1a26c8
 802d1d8:	3b6b6916 	.word	0x3b6b6916
 802d1dc:	3cb327a4 	.word	0x3cb327a4
 802d1e0:	3e088889 	.word	0x3e088889
 802d1e4:	3eaaaaab 	.word	0x3eaaaaab
 802d1e8:	fffff000 	.word	0xfffff000

0802d1ec <with_errnof>:
 802d1ec:	b510      	push	{r4, lr}
 802d1ee:	ed2d 8b02 	vpush	{d8}
 802d1f2:	eeb0 8a40 	vmov.f32	s16, s0
 802d1f6:	4604      	mov	r4, r0
 802d1f8:	f7fd fd30 	bl	802ac5c <__errno>
 802d1fc:	eeb0 0a48 	vmov.f32	s0, s16
 802d200:	ecbd 8b02 	vpop	{d8}
 802d204:	6004      	str	r4, [r0, #0]
 802d206:	bd10      	pop	{r4, pc}

0802d208 <xflowf>:
 802d208:	b130      	cbz	r0, 802d218 <xflowf+0x10>
 802d20a:	eef1 7a40 	vneg.f32	s15, s0
 802d20e:	2022      	movs	r0, #34	; 0x22
 802d210:	ee27 0a80 	vmul.f32	s0, s15, s0
 802d214:	f7ff bfea 	b.w	802d1ec <with_errnof>
 802d218:	eef0 7a40 	vmov.f32	s15, s0
 802d21c:	e7f7      	b.n	802d20e <xflowf+0x6>
	...

0802d220 <__math_uflowf>:
 802d220:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802d228 <__math_uflowf+0x8>
 802d224:	f7ff bff0 	b.w	802d208 <xflowf>
 802d228:	10000000 	.word	0x10000000

0802d22c <__math_may_uflowf>:
 802d22c:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802d234 <__math_may_uflowf+0x8>
 802d230:	f7ff bfea 	b.w	802d208 <xflowf>
 802d234:	1a200000 	.word	0x1a200000

0802d238 <__math_oflowf>:
 802d238:	ed9f 0a01 	vldr	s0, [pc, #4]	; 802d240 <__math_oflowf+0x8>
 802d23c:	f7ff bfe4 	b.w	802d208 <xflowf>
 802d240:	70000000 	.word	0x70000000

0802d244 <__math_divzerof>:
 802d244:	eeb7 0a00 	vmov.f32	s0, #112	; 0x3f800000  1.0
 802d248:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802d24c:	2800      	cmp	r0, #0
 802d24e:	fe40 7a27 	vseleq.f32	s15, s0, s15
 802d252:	ed9f 0a03 	vldr	s0, [pc, #12]	; 802d260 <__math_divzerof+0x1c>
 802d256:	2022      	movs	r0, #34	; 0x22
 802d258:	ee87 0a80 	vdiv.f32	s0, s15, s0
 802d25c:	f7ff bfc6 	b.w	802d1ec <with_errnof>
 802d260:	00000000 	.word	0x00000000

0802d264 <__math_invalidf>:
 802d264:	eef0 7a40 	vmov.f32	s15, s0
 802d268:	ee30 7a40 	vsub.f32	s14, s0, s0
 802d26c:	eef4 7a67 	vcmp.f32	s15, s15
 802d270:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d274:	ee87 0a07 	vdiv.f32	s0, s14, s14
 802d278:	d602      	bvs.n	802d280 <__math_invalidf+0x1c>
 802d27a:	2021      	movs	r0, #33	; 0x21
 802d27c:	f7ff bfb6 	b.w	802d1ec <with_errnof>
 802d280:	4770      	bx	lr

0802d282 <fabs>:
 802d282:	ec51 0b10 	vmov	r0, r1, d0
 802d286:	ee10 2a10 	vmov	r2, s0
 802d28a:	f021 4300 	bic.w	r3, r1, #2147483648	; 0x80000000
 802d28e:	ec43 2b10 	vmov	d0, r2, r3
 802d292:	4770      	bx	lr

0802d294 <finite>:
 802d294:	ee10 3a90 	vmov	r3, s1
 802d298:	f043 4000 	orr.w	r0, r3, #2147483648	; 0x80000000
 802d29c:	f500 1080 	add.w	r0, r0, #1048576	; 0x100000
 802d2a0:	0fc0      	lsrs	r0, r0, #31
 802d2a2:	4770      	bx	lr

0802d2a4 <matherr>:
 802d2a4:	2000      	movs	r0, #0
 802d2a6:	4770      	bx	lr

0802d2a8 <nan>:
 802d2a8:	ed9f 0b01 	vldr	d0, [pc, #4]	; 802d2b0 <nan+0x8>
 802d2ac:	4770      	bx	lr
 802d2ae:	bf00      	nop
 802d2b0:	00000000 	.word	0x00000000
 802d2b4:	7ff80000 	.word	0x7ff80000

0802d2b8 <rint>:
 802d2b8:	b530      	push	{r4, r5, lr}
 802d2ba:	b085      	sub	sp, #20
 802d2bc:	ed8d 0b00 	vstr	d0, [sp]
 802d2c0:	e9dd 2300 	ldrd	r2, r3, [sp]
 802d2c4:	f3c3 510a 	ubfx	r1, r3, #20, #11
 802d2c8:	f2a1 30ff 	subw	r0, r1, #1023	; 0x3ff
 802d2cc:	2813      	cmp	r0, #19
 802d2ce:	ea4f 74d3 	mov.w	r4, r3, lsr #31
 802d2d2:	dc5a      	bgt.n	802d38a <rint+0xd2>
 802d2d4:	2800      	cmp	r0, #0
 802d2d6:	da2f      	bge.n	802d338 <rint+0x80>
 802d2d8:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802d2dc:	4311      	orrs	r1, r2
 802d2de:	d027      	beq.n	802d330 <rint+0x78>
 802d2e0:	f3c3 0513 	ubfx	r5, r3, #0, #20
 802d2e4:	4315      	orrs	r5, r2
 802d2e6:	426a      	negs	r2, r5
 802d2e8:	432a      	orrs	r2, r5
 802d2ea:	0b12      	lsrs	r2, r2, #12
 802d2ec:	0c5b      	lsrs	r3, r3, #17
 802d2ee:	045b      	lsls	r3, r3, #17
 802d2f0:	f402 2200 	and.w	r2, r2, #524288	; 0x80000
 802d2f4:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d2f8:	ea42 0103 	orr.w	r1, r2, r3
 802d2fc:	4b31      	ldr	r3, [pc, #196]	; (802d3c4 <rint+0x10c>)
 802d2fe:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
 802d302:	ed93 6b00 	vldr	d6, [r3]
 802d306:	ec41 0b17 	vmov	d7, r0, r1
 802d30a:	ee36 7b07 	vadd.f64	d7, d6, d7
 802d30e:	ed8d 7b02 	vstr	d7, [sp, #8]
 802d312:	ed9d 7b02 	vldr	d7, [sp, #8]
 802d316:	ee37 7b46 	vsub.f64	d7, d7, d6
 802d31a:	ed8d 7b00 	vstr	d7, [sp]
 802d31e:	9b01      	ldr	r3, [sp, #4]
 802d320:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d324:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802d328:	ea43 71c4 	orr.w	r1, r3, r4, lsl #31
 802d32c:	e9cd 0100 	strd	r0, r1, [sp]
 802d330:	ed9d 0b00 	vldr	d0, [sp]
 802d334:	b005      	add	sp, #20
 802d336:	bd30      	pop	{r4, r5, pc}
 802d338:	4923      	ldr	r1, [pc, #140]	; (802d3c8 <rint+0x110>)
 802d33a:	4101      	asrs	r1, r0
 802d33c:	ea03 0501 	and.w	r5, r3, r1
 802d340:	4315      	orrs	r5, r2
 802d342:	d0f5      	beq.n	802d330 <rint+0x78>
 802d344:	0849      	lsrs	r1, r1, #1
 802d346:	ea03 0501 	and.w	r5, r3, r1
 802d34a:	432a      	orrs	r2, r5
 802d34c:	d00b      	beq.n	802d366 <rint+0xae>
 802d34e:	ea23 0101 	bic.w	r1, r3, r1
 802d352:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 802d356:	2813      	cmp	r0, #19
 802d358:	fa43 f300 	asr.w	r3, r3, r0
 802d35c:	bf0c      	ite	eq
 802d35e:	f04f 4200 	moveq.w	r2, #2147483648	; 0x80000000
 802d362:	2200      	movne	r2, #0
 802d364:	430b      	orrs	r3, r1
 802d366:	4619      	mov	r1, r3
 802d368:	4b16      	ldr	r3, [pc, #88]	; (802d3c4 <rint+0x10c>)
 802d36a:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
 802d36e:	ed94 6b00 	vldr	d6, [r4]
 802d372:	4610      	mov	r0, r2
 802d374:	ec41 0b17 	vmov	d7, r0, r1
 802d378:	ee36 7b07 	vadd.f64	d7, d6, d7
 802d37c:	ed8d 7b02 	vstr	d7, [sp, #8]
 802d380:	ed9d 7b02 	vldr	d7, [sp, #8]
 802d384:	ee37 7b46 	vsub.f64	d7, d7, d6
 802d388:	e008      	b.n	802d39c <rint+0xe4>
 802d38a:	2833      	cmp	r0, #51	; 0x33
 802d38c:	dd09      	ble.n	802d3a2 <rint+0xea>
 802d38e:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 802d392:	d1cd      	bne.n	802d330 <rint+0x78>
 802d394:	ed9d 7b00 	vldr	d7, [sp]
 802d398:	ee37 7b07 	vadd.f64	d7, d7, d7
 802d39c:	ed8d 7b00 	vstr	d7, [sp]
 802d3a0:	e7c6      	b.n	802d330 <rint+0x78>
 802d3a2:	f2a1 4013 	subw	r0, r1, #1043	; 0x413
 802d3a6:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 802d3aa:	40c1      	lsrs	r1, r0
 802d3ac:	420a      	tst	r2, r1
 802d3ae:	d0bf      	beq.n	802d330 <rint+0x78>
 802d3b0:	0849      	lsrs	r1, r1, #1
 802d3b2:	420a      	tst	r2, r1
 802d3b4:	bf1f      	itttt	ne
 802d3b6:	ea22 0101 	bicne.w	r1, r2, r1
 802d3ba:	f04f 4280 	movne.w	r2, #1073741824	; 0x40000000
 802d3be:	4102      	asrne	r2, r0
 802d3c0:	430a      	orrne	r2, r1
 802d3c2:	e7d0      	b.n	802d366 <rint+0xae>
 802d3c4:	080502d0 	.word	0x080502d0
 802d3c8:	000fffff 	.word	0x000fffff
 802d3cc:	00000000 	.word	0x00000000

0802d3d0 <scalbn>:
 802d3d0:	b500      	push	{lr}
 802d3d2:	ed2d 8b02 	vpush	{d8}
 802d3d6:	b083      	sub	sp, #12
 802d3d8:	ed8d 0b00 	vstr	d0, [sp]
 802d3dc:	9b01      	ldr	r3, [sp, #4]
 802d3de:	f3c3 520a 	ubfx	r2, r3, #20, #11
 802d3e2:	b9a2      	cbnz	r2, 802d40e <scalbn+0x3e>
 802d3e4:	9a00      	ldr	r2, [sp, #0]
 802d3e6:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802d3ea:	4313      	orrs	r3, r2
 802d3ec:	d03a      	beq.n	802d464 <scalbn+0x94>
 802d3ee:	ed9f 7b2e 	vldr	d7, [pc, #184]	; 802d4a8 <scalbn+0xd8>
 802d3f2:	4b35      	ldr	r3, [pc, #212]	; (802d4c8 <scalbn+0xf8>)
 802d3f4:	ee20 7b07 	vmul.f64	d7, d0, d7
 802d3f8:	4298      	cmp	r0, r3
 802d3fa:	ed8d 7b00 	vstr	d7, [sp]
 802d3fe:	da11      	bge.n	802d424 <scalbn+0x54>
 802d400:	ed9f 7b2b 	vldr	d7, [pc, #172]	; 802d4b0 <scalbn+0xe0>
 802d404:	ed9d 6b00 	vldr	d6, [sp]
 802d408:	ee27 7b06 	vmul.f64	d7, d7, d6
 802d40c:	e007      	b.n	802d41e <scalbn+0x4e>
 802d40e:	f240 71ff 	movw	r1, #2047	; 0x7ff
 802d412:	428a      	cmp	r2, r1
 802d414:	d10a      	bne.n	802d42c <scalbn+0x5c>
 802d416:	ed9d 7b00 	vldr	d7, [sp]
 802d41a:	ee37 7b07 	vadd.f64	d7, d7, d7
 802d41e:	ed8d 7b00 	vstr	d7, [sp]
 802d422:	e01f      	b.n	802d464 <scalbn+0x94>
 802d424:	9b01      	ldr	r3, [sp, #4]
 802d426:	f3c3 520a 	ubfx	r2, r3, #20, #11
 802d42a:	3a36      	subs	r2, #54	; 0x36
 802d42c:	4402      	add	r2, r0
 802d42e:	f240 71fe 	movw	r1, #2046	; 0x7fe
 802d432:	428a      	cmp	r2, r1
 802d434:	dd0a      	ble.n	802d44c <scalbn+0x7c>
 802d436:	ed9f 8b20 	vldr	d8, [pc, #128]	; 802d4b8 <scalbn+0xe8>
 802d43a:	eeb0 0b48 	vmov.f64	d0, d8
 802d43e:	ed9d 1b00 	vldr	d1, [sp]
 802d442:	f000 fa19 	bl	802d878 <copysign>
 802d446:	ee20 7b08 	vmul.f64	d7, d0, d8
 802d44a:	e7e8      	b.n	802d41e <scalbn+0x4e>
 802d44c:	2a00      	cmp	r2, #0
 802d44e:	dd10      	ble.n	802d472 <scalbn+0xa2>
 802d450:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d454:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802d458:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 802d45c:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
 802d460:	e9cd 0100 	strd	r0, r1, [sp]
 802d464:	ed9d 0b00 	vldr	d0, [sp]
 802d468:	b003      	add	sp, #12
 802d46a:	ecbd 8b02 	vpop	{d8}
 802d46e:	f85d fb04 	ldr.w	pc, [sp], #4
 802d472:	f112 0f35 	cmn.w	r2, #53	; 0x35
 802d476:	da06      	bge.n	802d486 <scalbn+0xb6>
 802d478:	f24c 3350 	movw	r3, #50000	; 0xc350
 802d47c:	4298      	cmp	r0, r3
 802d47e:	dcda      	bgt.n	802d436 <scalbn+0x66>
 802d480:	ed9f 8b0b 	vldr	d8, [pc, #44]	; 802d4b0 <scalbn+0xe0>
 802d484:	e7d9      	b.n	802d43a <scalbn+0x6a>
 802d486:	e9dd 0100 	ldrd	r0, r1, [sp]
 802d48a:	f023 43ff 	bic.w	r3, r3, #2139095040	; 0x7f800000
 802d48e:	3236      	adds	r2, #54	; 0x36
 802d490:	f423 03e0 	bic.w	r3, r3, #7340032	; 0x700000
 802d494:	ea43 5102 	orr.w	r1, r3, r2, lsl #20
 802d498:	ec41 0b17 	vmov	d7, r0, r1
 802d49c:	ed9f 6b08 	vldr	d6, [pc, #32]	; 802d4c0 <scalbn+0xf0>
 802d4a0:	e7b2      	b.n	802d408 <scalbn+0x38>
 802d4a2:	bf00      	nop
 802d4a4:	f3af 8000 	nop.w
 802d4a8:	00000000 	.word	0x00000000
 802d4ac:	43500000 	.word	0x43500000
 802d4b0:	c2f8f359 	.word	0xc2f8f359
 802d4b4:	01a56e1f 	.word	0x01a56e1f
 802d4b8:	8800759c 	.word	0x8800759c
 802d4bc:	7e37e43c 	.word	0x7e37e43c
 802d4c0:	00000000 	.word	0x00000000
 802d4c4:	3c900000 	.word	0x3c900000
 802d4c8:	ffff3cb0 	.word	0xffff3cb0

0802d4cc <expm1f>:
 802d4cc:	ee10 2a10 	vmov	r2, s0
 802d4d0:	4984      	ldr	r1, [pc, #528]	; (802d6e4 <expm1f+0x218>)
 802d4d2:	f022 4300 	bic.w	r3, r2, #2147483648	; 0x80000000
 802d4d6:	428b      	cmp	r3, r1
 802d4d8:	d923      	bls.n	802d522 <expm1f+0x56>
 802d4da:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802d4de:	d902      	bls.n	802d4e6 <expm1f+0x1a>
 802d4e0:	ee30 0a00 	vadd.f32	s0, s0, s0
 802d4e4:	4770      	bx	lr
 802d4e6:	d105      	bne.n	802d4f4 <expm1f+0x28>
 802d4e8:	eeff 7a00 	vmov.f32	s15, #240	; 0xbf800000 -1.0
 802d4ec:	2a00      	cmp	r2, #0
 802d4ee:	fe20 0a27 	vselge.f32	s0, s0, s15
 802d4f2:	4770      	bx	lr
 802d4f4:	2a00      	cmp	r2, #0
 802d4f6:	db08      	blt.n	802d50a <expm1f+0x3e>
 802d4f8:	4a7b      	ldr	r2, [pc, #492]	; (802d6e8 <expm1f+0x21c>)
 802d4fa:	4293      	cmp	r3, r2
 802d4fc:	f240 80ea 	bls.w	802d6d4 <expm1f+0x208>
 802d500:	ed9f 0a7a 	vldr	s0, [pc, #488]	; 802d6ec <expm1f+0x220>
 802d504:	ee20 0a00 	vmul.f32	s0, s0, s0
 802d508:	4770      	bx	lr
 802d50a:	eddf 7a79 	vldr	s15, [pc, #484]	; 802d6f0 <expm1f+0x224>
 802d50e:	ee70 7a27 	vadd.f32	s15, s0, s15
 802d512:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 802d516:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d51a:	d554      	bpl.n	802d5c6 <expm1f+0xfa>
 802d51c:	eebf 0a00 	vmov.f32	s0, #240	; 0xbf800000 -1.0
 802d520:	4770      	bx	lr
 802d522:	4974      	ldr	r1, [pc, #464]	; (802d6f4 <expm1f+0x228>)
 802d524:	428b      	cmp	r3, r1
 802d526:	d96c      	bls.n	802d602 <expm1f+0x136>
 802d528:	4973      	ldr	r1, [pc, #460]	; (802d6f8 <expm1f+0x22c>)
 802d52a:	428b      	cmp	r3, r1
 802d52c:	d84b      	bhi.n	802d5c6 <expm1f+0xfa>
 802d52e:	ed9f 7a73 	vldr	s14, [pc, #460]	; 802d6fc <expm1f+0x230>
 802d532:	2a00      	cmp	r2, #0
 802d534:	bfa7      	ittee	ge
 802d536:	ee30 7a47 	vsubge.f32	s14, s0, s14
 802d53a:	eddf 7a71 	vldrge	s15, [pc, #452]	; 802d700 <expm1f+0x234>
 802d53e:	eddf 7a71 	vldrlt	s15, [pc, #452]	; 802d704 <expm1f+0x238>
 802d542:	ee30 7a07 	vaddlt.f32	s14, s0, s14
 802d546:	bfac      	ite	ge
 802d548:	2301      	movge	r3, #1
 802d54a:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 802d54e:	ee37 0a67 	vsub.f32	s0, s14, s15
 802d552:	ee37 7a40 	vsub.f32	s14, s14, s0
 802d556:	ee77 7a67 	vsub.f32	s15, s14, s15
 802d55a:	eef6 5a00 	vmov.f32	s11, #96	; 0x3f000000  0.5
 802d55e:	ee20 5a25 	vmul.f32	s10, s0, s11
 802d562:	eddf 6a69 	vldr	s13, [pc, #420]	; 802d708 <expm1f+0x23c>
 802d566:	ed9f 6a69 	vldr	s12, [pc, #420]	; 802d70c <expm1f+0x240>
 802d56a:	ee20 7a05 	vmul.f32	s14, s0, s10
 802d56e:	eea7 6a26 	vfma.f32	s12, s14, s13
 802d572:	eddf 6a67 	vldr	s13, [pc, #412]	; 802d710 <expm1f+0x244>
 802d576:	eee6 6a07 	vfma.f32	s13, s12, s14
 802d57a:	ed9f 6a66 	vldr	s12, [pc, #408]	; 802d714 <expm1f+0x248>
 802d57e:	eea6 6a87 	vfma.f32	s12, s13, s14
 802d582:	eddf 6a65 	vldr	s13, [pc, #404]	; 802d718 <expm1f+0x24c>
 802d586:	eee6 6a07 	vfma.f32	s13, s12, s14
 802d58a:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
 802d58e:	eef0 4a46 	vmov.f32	s9, s12
 802d592:	eee6 4a87 	vfma.f32	s9, s13, s14
 802d596:	eef0 6a64 	vmov.f32	s13, s9
 802d59a:	eef0 4a08 	vmov.f32	s9, #8	; 0x40400000  3.0
 802d59e:	eee5 4a66 	vfms.f32	s9, s10, s13
 802d5a2:	ee36 5ae4 	vsub.f32	s10, s13, s9
 802d5a6:	eef1 6a08 	vmov.f32	s13, #24	; 0x40c00000  6.0
 802d5aa:	eee0 6a64 	vfms.f32	s13, s0, s9
 802d5ae:	eef0 4a66 	vmov.f32	s9, s13
 802d5b2:	eec5 6a24 	vdiv.f32	s13, s10, s9
 802d5b6:	ee66 6a87 	vmul.f32	s13, s13, s14
 802d5ba:	bb83      	cbnz	r3, 802d61e <expm1f+0x152>
 802d5bc:	eef0 7a47 	vmov.f32	s15, s14
 802d5c0:	eed0 7a26 	vfnms.f32	s15, s0, s13
 802d5c4:	e026      	b.n	802d614 <expm1f+0x148>
 802d5c6:	eddf 7a55 	vldr	s15, [pc, #340]	; 802d71c <expm1f+0x250>
 802d5ca:	eef6 6a00 	vmov.f32	s13, #96	; 0x3f000000  0.5
 802d5ce:	ee20 7a27 	vmul.f32	s14, s0, s15
 802d5d2:	eefe 7a00 	vmov.f32	s15, #224	; 0xbf000000 -0.5
 802d5d6:	2a00      	cmp	r2, #0
 802d5d8:	fe66 7aa7 	vselge.f32	s15, s13, s15
 802d5dc:	ee77 7a87 	vadd.f32	s15, s15, s14
 802d5e0:	ed9f 7a46 	vldr	s14, [pc, #280]	; 802d6fc <expm1f+0x230>
 802d5e4:	eddf 6a46 	vldr	s13, [pc, #280]	; 802d700 <expm1f+0x234>
 802d5e8:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 802d5ec:	ee17 3a90 	vmov	r3, s15
 802d5f0:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 802d5f4:	eea7 0ac7 	vfms.f32	s0, s15, s14
 802d5f8:	ee67 7aa6 	vmul.f32	s15, s15, s13
 802d5fc:	eeb0 7a40 	vmov.f32	s14, s0
 802d600:	e7a5      	b.n	802d54e <expm1f+0x82>
 802d602:	f1b3 5f4c 	cmp.w	r3, #855638016	; 0x33000000
 802d606:	d208      	bcs.n	802d61a <expm1f+0x14e>
 802d608:	eddf 7a38 	vldr	s15, [pc, #224]	; 802d6ec <expm1f+0x220>
 802d60c:	ee70 7a27 	vadd.f32	s15, s0, s15
 802d610:	ee77 7ae7 	vsub.f32	s15, s15, s15
 802d614:	ee30 0a67 	vsub.f32	s0, s0, s15
 802d618:	4770      	bx	lr
 802d61a:	2300      	movs	r3, #0
 802d61c:	e79d      	b.n	802d55a <expm1f+0x8e>
 802d61e:	ee76 6ae7 	vsub.f32	s13, s13, s15
 802d622:	1c5a      	adds	r2, r3, #1
 802d624:	eed6 7a80 	vfnms.f32	s15, s13, s0
 802d628:	ee77 7ac7 	vsub.f32	s15, s15, s14
 802d62c:	d106      	bne.n	802d63c <expm1f+0x170>
 802d62e:	ee70 7a67 	vsub.f32	s15, s0, s15
 802d632:	eebe 0a00 	vmov.f32	s0, #224	; 0xbf000000 -0.5
 802d636:	eea7 0aa5 	vfma.f32	s0, s15, s11
 802d63a:	4770      	bx	lr
 802d63c:	2b01      	cmp	r3, #1
 802d63e:	d118      	bne.n	802d672 <expm1f+0x1a6>
 802d640:	eebd 7a00 	vmov.f32	s14, #208	; 0xbe800000 -0.250
 802d644:	eeb4 0ac7 	vcmpe.f32	s0, s14
 802d648:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d64c:	bf41      	itttt	mi
 802d64e:	ee30 0a25 	vaddmi.f32	s0, s0, s11
 802d652:	ee37 0ac0 	vsubmi.f32	s0, s15, s0
 802d656:	eef8 7a00 	vmovmi.f32	s15, #128	; 0xc0000000 -2.0
 802d65a:	ee20 0a27 	vmulmi.f32	s0, s0, s15
 802d65e:	bf5f      	itttt	pl
 802d660:	ee30 0a67 	vsubpl.f32	s0, s0, s15
 802d664:	eef0 7a00 	vmovpl.f32	s15, #0	; 0x40000000  2.0
 802d668:	eea0 6a27 	vfmapl.f32	s12, s0, s15
 802d66c:	eeb0 0a46 	vmovpl.f32	s0, s12
 802d670:	4770      	bx	lr
 802d672:	1c5a      	adds	r2, r3, #1
 802d674:	2a39      	cmp	r2, #57	; 0x39
 802d676:	ea4f 51c3 	mov.w	r1, r3, lsl #23
 802d67a:	d90b      	bls.n	802d694 <expm1f+0x1c8>
 802d67c:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d680:	ee36 0a40 	vsub.f32	s0, s12, s0
 802d684:	ee10 3a10 	vmov	r3, s0
 802d688:	440b      	add	r3, r1
 802d68a:	ee00 3a10 	vmov	s0, r3
 802d68e:	ee30 0a46 	vsub.f32	s0, s0, s12
 802d692:	4770      	bx	lr
 802d694:	2b16      	cmp	r3, #22
 802d696:	dc11      	bgt.n	802d6bc <expm1f+0x1f0>
 802d698:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 802d69c:	fa42 f303 	asr.w	r3, r2, r3
 802d6a0:	f1c3 537e 	rsb	r3, r3, #1065353216	; 0x3f800000
 802d6a4:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d6a8:	ee07 3a90 	vmov	s15, r3
 802d6ac:	ee37 0ac0 	vsub.f32	s0, s15, s0
 802d6b0:	ee10 3a10 	vmov	r3, s0
 802d6b4:	440b      	add	r3, r1
 802d6b6:	ee00 3a10 	vmov	s0, r3
 802d6ba:	4770      	bx	lr
 802d6bc:	f1c3 037f 	rsb	r3, r3, #127	; 0x7f
 802d6c0:	05db      	lsls	r3, r3, #23
 802d6c2:	ee07 3a10 	vmov	s14, r3
 802d6c6:	ee77 7a87 	vadd.f32	s15, s15, s14
 802d6ca:	ee30 0a67 	vsub.f32	s0, s0, s15
 802d6ce:	ee30 0a06 	vadd.f32	s0, s0, s12
 802d6d2:	e7ed      	b.n	802d6b0 <expm1f+0x1e4>
 802d6d4:	eddf 7a11 	vldr	s15, [pc, #68]	; 802d71c <expm1f+0x250>
 802d6d8:	ee20 7a27 	vmul.f32	s14, s0, s15
 802d6dc:	eef6 7a00 	vmov.f32	s15, #96	; 0x3f000000  0.5
 802d6e0:	e77c      	b.n	802d5dc <expm1f+0x110>
 802d6e2:	bf00      	nop
 802d6e4:	4195b843 	.word	0x4195b843
 802d6e8:	42b17217 	.word	0x42b17217
 802d6ec:	7149f2ca 	.word	0x7149f2ca
 802d6f0:	0da24260 	.word	0x0da24260
 802d6f4:	3eb17218 	.word	0x3eb17218
 802d6f8:	3f851591 	.word	0x3f851591
 802d6fc:	3f317180 	.word	0x3f317180
 802d700:	3717f7d1 	.word	0x3717f7d1
 802d704:	b717f7d1 	.word	0xb717f7d1
 802d708:	b457edbb 	.word	0xb457edbb
 802d70c:	36867e54 	.word	0x36867e54
 802d710:	b8a670cd 	.word	0xb8a670cd
 802d714:	3ad00d01 	.word	0x3ad00d01
 802d718:	bd088889 	.word	0xbd088889
 802d71c:	3fb8aa3b 	.word	0x3fb8aa3b

0802d720 <finitef>:
 802d720:	ee10 3a10 	vmov	r3, s0
 802d724:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 802d728:	f1b0 4fff 	cmp.w	r0, #2139095040	; 0x7f800000
 802d72c:	bfac      	ite	ge
 802d72e:	2000      	movge	r0, #0
 802d730:	2001      	movlt	r0, #1
 802d732:	4770      	bx	lr

0802d734 <floorf>:
 802d734:	ee10 3a10 	vmov	r3, s0
 802d738:	f023 4100 	bic.w	r1, r3, #2147483648	; 0x80000000
 802d73c:	0dca      	lsrs	r2, r1, #23
 802d73e:	3a7f      	subs	r2, #127	; 0x7f
 802d740:	2a16      	cmp	r2, #22
 802d742:	dc2a      	bgt.n	802d79a <floorf+0x66>
 802d744:	2a00      	cmp	r2, #0
 802d746:	da11      	bge.n	802d76c <floorf+0x38>
 802d748:	eddf 7a18 	vldr	s15, [pc, #96]	; 802d7ac <floorf+0x78>
 802d74c:	ee30 0a27 	vadd.f32	s0, s0, s15
 802d750:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802d754:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d758:	dd05      	ble.n	802d766 <floorf+0x32>
 802d75a:	2b00      	cmp	r3, #0
 802d75c:	da23      	bge.n	802d7a6 <floorf+0x72>
 802d75e:	4a14      	ldr	r2, [pc, #80]	; (802d7b0 <floorf+0x7c>)
 802d760:	2900      	cmp	r1, #0
 802d762:	bf18      	it	ne
 802d764:	4613      	movne	r3, r2
 802d766:	ee00 3a10 	vmov	s0, r3
 802d76a:	4770      	bx	lr
 802d76c:	4911      	ldr	r1, [pc, #68]	; (802d7b4 <floorf+0x80>)
 802d76e:	4111      	asrs	r1, r2
 802d770:	420b      	tst	r3, r1
 802d772:	d0fa      	beq.n	802d76a <floorf+0x36>
 802d774:	eddf 7a0d 	vldr	s15, [pc, #52]	; 802d7ac <floorf+0x78>
 802d778:	ee30 0a27 	vadd.f32	s0, s0, s15
 802d77c:	eeb5 0ac0 	vcmpe.f32	s0, #0.0
 802d780:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 802d784:	ddef      	ble.n	802d766 <floorf+0x32>
 802d786:	2b00      	cmp	r3, #0
 802d788:	bfbe      	ittt	lt
 802d78a:	f44f 0000 	movlt.w	r0, #8388608	; 0x800000
 802d78e:	fa40 f202 	asrlt.w	r2, r0, r2
 802d792:	189b      	addlt	r3, r3, r2
 802d794:	ea23 0301 	bic.w	r3, r3, r1
 802d798:	e7e5      	b.n	802d766 <floorf+0x32>
 802d79a:	f1b1 4fff 	cmp.w	r1, #2139095040	; 0x7f800000
 802d79e:	d3e4      	bcc.n	802d76a <floorf+0x36>
 802d7a0:	ee30 0a00 	vadd.f32	s0, s0, s0
 802d7a4:	4770      	bx	lr
 802d7a6:	2300      	movs	r3, #0
 802d7a8:	e7dd      	b.n	802d766 <floorf+0x32>
 802d7aa:	bf00      	nop
 802d7ac:	7149f2ca 	.word	0x7149f2ca
 802d7b0:	bf800000 	.word	0xbf800000
 802d7b4:	007fffff 	.word	0x007fffff

0802d7b8 <scalbnf>:
 802d7b8:	b508      	push	{r3, lr}
 802d7ba:	ee10 2a10 	vmov	r2, s0
 802d7be:	f032 4300 	bics.w	r3, r2, #2147483648	; 0x80000000
 802d7c2:	ed2d 8b02 	vpush	{d8}
 802d7c6:	eef0 0a40 	vmov.f32	s1, s0
 802d7ca:	d004      	beq.n	802d7d6 <scalbnf+0x1e>
 802d7cc:	f1b3 4fff 	cmp.w	r3, #2139095040	; 0x7f800000
 802d7d0:	d306      	bcc.n	802d7e0 <scalbnf+0x28>
 802d7d2:	ee70 0a00 	vadd.f32	s1, s0, s0
 802d7d6:	ecbd 8b02 	vpop	{d8}
 802d7da:	eeb0 0a60 	vmov.f32	s0, s1
 802d7de:	bd08      	pop	{r3, pc}
 802d7e0:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
 802d7e4:	d21c      	bcs.n	802d820 <scalbnf+0x68>
 802d7e6:	4b1f      	ldr	r3, [pc, #124]	; (802d864 <scalbnf+0xac>)
 802d7e8:	eddf 7a1f 	vldr	s15, [pc, #124]	; 802d868 <scalbnf+0xb0>
 802d7ec:	4298      	cmp	r0, r3
 802d7ee:	ee60 0a27 	vmul.f32	s1, s0, s15
 802d7f2:	db10      	blt.n	802d816 <scalbnf+0x5e>
 802d7f4:	ee10 2a90 	vmov	r2, s1
 802d7f8:	f3c2 53c7 	ubfx	r3, r2, #23, #8
 802d7fc:	3b19      	subs	r3, #25
 802d7fe:	4403      	add	r3, r0
 802d800:	2bfe      	cmp	r3, #254	; 0xfe
 802d802:	dd0f      	ble.n	802d824 <scalbnf+0x6c>
 802d804:	ed9f 8a19 	vldr	s16, [pc, #100]	; 802d86c <scalbnf+0xb4>
 802d808:	eeb0 0a48 	vmov.f32	s0, s16
 802d80c:	f000 f843 	bl	802d896 <copysignf>
 802d810:	ee60 0a08 	vmul.f32	s1, s0, s16
 802d814:	e7df      	b.n	802d7d6 <scalbnf+0x1e>
 802d816:	eddf 7a16 	vldr	s15, [pc, #88]	; 802d870 <scalbnf+0xb8>
 802d81a:	ee60 0aa7 	vmul.f32	s1, s1, s15
 802d81e:	e7da      	b.n	802d7d6 <scalbnf+0x1e>
 802d820:	0ddb      	lsrs	r3, r3, #23
 802d822:	e7ec      	b.n	802d7fe <scalbnf+0x46>
 802d824:	2b00      	cmp	r3, #0
 802d826:	dd06      	ble.n	802d836 <scalbnf+0x7e>
 802d828:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 802d82c:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 802d830:	ee00 3a90 	vmov	s1, r3
 802d834:	e7cf      	b.n	802d7d6 <scalbnf+0x1e>
 802d836:	f113 0f16 	cmn.w	r3, #22
 802d83a:	da06      	bge.n	802d84a <scalbnf+0x92>
 802d83c:	f24c 3350 	movw	r3, #50000	; 0xc350
 802d840:	4298      	cmp	r0, r3
 802d842:	dcdf      	bgt.n	802d804 <scalbnf+0x4c>
 802d844:	ed9f 8a0a 	vldr	s16, [pc, #40]	; 802d870 <scalbnf+0xb8>
 802d848:	e7de      	b.n	802d808 <scalbnf+0x50>
 802d84a:	3319      	adds	r3, #25
 802d84c:	f022 42ff 	bic.w	r2, r2, #2139095040	; 0x7f800000
 802d850:	ea42 53c3 	orr.w	r3, r2, r3, lsl #23
 802d854:	eddf 7a07 	vldr	s15, [pc, #28]	; 802d874 <scalbnf+0xbc>
 802d858:	ee07 3a10 	vmov	s14, r3
 802d85c:	ee67 0a27 	vmul.f32	s1, s14, s15
 802d860:	e7b9      	b.n	802d7d6 <scalbnf+0x1e>
 802d862:	bf00      	nop
 802d864:	ffff3cb0 	.word	0xffff3cb0
 802d868:	4c000000 	.word	0x4c000000
 802d86c:	7149f2ca 	.word	0x7149f2ca
 802d870:	0da24260 	.word	0x0da24260
 802d874:	33000000 	.word	0x33000000

0802d878 <copysign>:
 802d878:	ec51 0b10 	vmov	r0, r1, d0
 802d87c:	ee11 0a90 	vmov	r0, s3
 802d880:	ee10 2a10 	vmov	r2, s0
 802d884:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 802d888:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 802d88c:	ea41 0300 	orr.w	r3, r1, r0
 802d890:	ec43 2b10 	vmov	d0, r2, r3
 802d894:	4770      	bx	lr

0802d896 <copysignf>:
 802d896:	ee10 3a10 	vmov	r3, s0
 802d89a:	ee10 2a90 	vmov	r2, s1
 802d89e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 802d8a2:	f002 4200 	and.w	r2, r2, #2147483648	; 0x80000000
 802d8a6:	4313      	orrs	r3, r2
 802d8a8:	ee00 3a10 	vmov	s0, r3
 802d8ac:	4770      	bx	lr
	...

0802d8b0 <_init>:
 802d8b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d8b2:	bf00      	nop
 802d8b4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802d8b6:	bc08      	pop	{r3}
 802d8b8:	469e      	mov	lr, r3
 802d8ba:	4770      	bx	lr

0802d8bc <_fini>:
 802d8bc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 802d8be:	bf00      	nop
 802d8c0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 802d8c2:	bc08      	pop	{r3}
 802d8c4:	469e      	mov	lr, r3
 802d8c6:	4770      	bx	lr
